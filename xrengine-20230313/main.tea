/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'xrengine-daily.aliyuncs.com',
    ap-northeast-2-pop = 'xrengine-daily.aliyuncs.com',
    ap-south-1 = 'xrengine-daily.aliyuncs.com',
    ap-southeast-1 = 'xrengine-daily.aliyuncs.com',
    ap-southeast-2 = 'xrengine-daily.aliyuncs.com',
    ap-southeast-3 = 'xrengine-daily.aliyuncs.com',
    ap-southeast-5 = 'xrengine-daily.aliyuncs.com',
    cn-beijing = 'xrengine-daily.aliyuncs.com',
    cn-beijing-finance-1 = 'xrengine-daily.aliyuncs.com',
    cn-beijing-finance-pop = 'xrengine-daily.aliyuncs.com',
    cn-beijing-gov-1 = 'xrengine-daily.aliyuncs.com',
    cn-beijing-nu16-b01 = 'xrengine-daily.aliyuncs.com',
    cn-chengdu = 'xrengine-daily.aliyuncs.com',
    cn-edge-1 = 'xrengine-daily.aliyuncs.com',
    cn-fujian = 'xrengine-daily.aliyuncs.com',
    cn-haidian-cm12-c01 = 'xrengine-daily.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'xrengine-daily.aliyuncs.com',
    cn-hangzhou-finance = 'xrengine-daily.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'xrengine-daily.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'xrengine-daily.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'xrengine-daily.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'xrengine-daily.aliyuncs.com',
    cn-hangzhou-test-306 = 'xrengine-daily.aliyuncs.com',
    cn-hongkong = 'xrengine-daily.aliyuncs.com',
    cn-hongkong-finance-pop = 'xrengine-daily.aliyuncs.com',
    cn-huhehaote = 'xrengine-daily.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'xrengine-daily.aliyuncs.com',
    cn-north-2-gov-1 = 'xrengine-daily.aliyuncs.com',
    cn-qingdao = 'xrengine-daily.aliyuncs.com',
    cn-qingdao-nebula = 'xrengine-daily.aliyuncs.com',
    cn-shanghai = 'xrengine-daily.aliyuncs.com',
    cn-shanghai-et15-b01 = 'xrengine-daily.aliyuncs.com',
    cn-shanghai-et2-b01 = 'xrengine-daily.aliyuncs.com',
    cn-shanghai-finance-1 = 'xrengine-daily.aliyuncs.com',
    cn-shanghai-inner = 'xrengine-daily.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'xrengine-daily.aliyuncs.com',
    cn-shenzhen = 'xrengine-daily.aliyuncs.com',
    cn-shenzhen-finance-1 = 'xrengine-daily.aliyuncs.com',
    cn-shenzhen-inner = 'xrengine-daily.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'xrengine-daily.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'xrengine-daily.aliyuncs.com',
    cn-wuhan = 'xrengine-daily.aliyuncs.com',
    cn-wulanchabu = 'xrengine-daily.aliyuncs.com',
    cn-yushanfang = 'xrengine-daily.aliyuncs.com',
    cn-zhangbei = 'xrengine-daily.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'xrengine-daily.aliyuncs.com',
    cn-zhangjiakou = 'xrengine-daily.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'xrengine-daily.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'xrengine-daily.aliyuncs.com',
    eu-central-1 = 'xrengine-daily.aliyuncs.com',
    eu-west-1 = 'xrengine-daily.aliyuncs.com',
    eu-west-1-oxs = 'xrengine-daily.aliyuncs.com',
    me-east-1 = 'xrengine-daily.aliyuncs.com',
    rus-west-1-pop = 'xrengine-daily.aliyuncs.com',
    us-east-1 = 'xrengine-daily.aliyuncs.com',
    us-west-1 = 'xrengine-daily.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('xrengine', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AuthUserRequest {
  jwtToken?: string(name='JwtToken'),
}

model AuthUserResponseBody = {
  code?: string(name='Code'),
  data?: {
    jwtToken?: string(name='JwtToken'),
    type?: string(name='Type'),
  }(name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AuthUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AuthUserResponseBody(name='body'),
}

async function authUserWithOptions(request: AuthUserRequest, runtime: Util.RuntimeOptions): AuthUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AuthUser',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function authUser(request: AuthUserRequest): AuthUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return authUserWithOptions(request, runtime);
}

model BatchQueryMotionShopTaskStatusRequest {
  jwtToken?: string(name='JwtToken'),
  taskId?: string(name='TaskId'),
}

model BatchQueryMotionShopTaskStatusResponseBody = {
  code?: string(name='Code'),
  data?: {
    tasks?: [ 
      {
        result?: {
          coverUrl?: string(name='CoverUrl'),
          shareUrl?: string(name='ShareUrl'),
          videoUrl?: string(name='VideoUrl'),
        }(name='Result'),
        status?: string(name='Status'),
        taskId?: string(name='TaskId'),
      }
    ](name='Tasks'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchQueryMotionShopTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchQueryMotionShopTaskStatusResponseBody(name='body'),
}

async function batchQueryMotionShopTaskStatusWithOptions(request: BatchQueryMotionShopTaskStatusRequest, runtime: Util.RuntimeOptions): BatchQueryMotionShopTaskStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchQueryMotionShopTaskStatus',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchQueryMotionShopTaskStatus(request: BatchQueryMotionShopTaskStatusRequest): BatchQueryMotionShopTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchQueryMotionShopTaskStatusWithOptions(request, runtime);
}

model CreateAvatarTalkProjectRequest {
  avatarProjectId?: string(name='AvatarProjectId'),
  jwtToken?: string(name='JwtToken'),
  title?: string(name='Title'),
  ttsVoice?: string(name='TtsVoice'),
  txtContent?: string(name='TxtContent'),
}

model CreateAvatarTalkProjectResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateAvatarTalkProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAvatarTalkProjectResponseBody(name='body'),
}

async function createAvatarTalkProjectWithOptions(request: CreateAvatarTalkProjectRequest, runtime: Util.RuntimeOptions): CreateAvatarTalkProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.avatarProjectId)) {
    body['AvatarProjectId'] = request.avatarProjectId;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  if (!Util.isUnset(request.ttsVoice)) {
    body['TtsVoice'] = request.ttsVoice;
  }
  if (!Util.isUnset(request.txtContent)) {
    body['TxtContent'] = request.txtContent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAvatarTalkProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAvatarTalkProject(request: CreateAvatarTalkProjectRequest): CreateAvatarTalkProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAvatarTalkProjectWithOptions(request, runtime);
}

model CreateDigitalHumanProjectRequest {
  audioId?: string(name='AudioId'),
  audioUrl?: string(name='AudioUrl'),
  backgroundId?: string(name='BackgroundId'),
  backgroundUrl?: string(name='BackgroundUrl'),
  content?: string(name='Content'),
  foregroundId?: string(name='ForegroundId'),
  foregroundUrl?: string(name='ForegroundUrl'),
  humanLayerStyle?: string(name='HumanLayerStyle'),
  intro?: string(name='Intro'),
  jwtToken?: string(name='JwtToken'),
  mode?: string(name='Mode'),
  modelId?: string(name='ModelId'),
  outputConfig?: string(name='OutputConfig'),
  title?: string(name='Title'),
  ttsVoiceId?: string(name='TtsVoiceId'),
  watermarkImageUrl?: string(name='WatermarkImageUrl'),
  watermarkStyle?: string(name='WatermarkStyle'),
}

model CreateDigitalHumanProjectResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDigitalHumanProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDigitalHumanProjectResponseBody(name='body'),
}

async function createDigitalHumanProjectWithOptions(request: CreateDigitalHumanProjectRequest, runtime: Util.RuntimeOptions): CreateDigitalHumanProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.audioId)) {
    body['AudioId'] = request.audioId;
  }
  if (!Util.isUnset(request.audioUrl)) {
    body['AudioUrl'] = request.audioUrl;
  }
  if (!Util.isUnset(request.backgroundId)) {
    body['BackgroundId'] = request.backgroundId;
  }
  if (!Util.isUnset(request.backgroundUrl)) {
    body['BackgroundUrl'] = request.backgroundUrl;
  }
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.foregroundId)) {
    body['ForegroundId'] = request.foregroundId;
  }
  if (!Util.isUnset(request.foregroundUrl)) {
    body['ForegroundUrl'] = request.foregroundUrl;
  }
  if (!Util.isUnset(request.humanLayerStyle)) {
    body['HumanLayerStyle'] = request.humanLayerStyle;
  }
  if (!Util.isUnset(request.intro)) {
    body['Intro'] = request.intro;
  }
  if (!Util.isUnset(request.mode)) {
    body['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.modelId)) {
    body['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.outputConfig)) {
    body['OutputConfig'] = request.outputConfig;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  if (!Util.isUnset(request.ttsVoiceId)) {
    body['TtsVoiceId'] = request.ttsVoiceId;
  }
  if (!Util.isUnset(request.watermarkImageUrl)) {
    body['WatermarkImageUrl'] = request.watermarkImageUrl;
  }
  if (!Util.isUnset(request.watermarkStyle)) {
    body['WatermarkStyle'] = request.watermarkStyle;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDigitalHumanProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDigitalHumanProject(request: CreateDigitalHumanProjectRequest): CreateDigitalHumanProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDigitalHumanProjectWithOptions(request, runtime);
}

model CreateLivePortraitProjectRequest {
  audioId?: string(name='AudioId'),
  audioUrl?: string(name='AudioUrl'),
  content?: string(name='Content'),
  imageId?: string(name='ImageId'),
  imageUrl?: string(name='ImageUrl'),
  intro?: string(name='Intro'),
  jwtToken?: string(name='JwtToken'),
  lightModel?: boolean(name='LightModel'),
  mode?: string(name='Mode'),
  outputConfig?: string(name='OutputConfig'),
  title?: string(name='Title'),
  ttsVoiceId?: string(name='TtsVoiceId'),
  watermarkImageUrl?: string(name='WatermarkImageUrl'),
  watermarkStyle?: string(name='WatermarkStyle'),
}

model CreateLivePortraitProjectResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateLivePortraitProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLivePortraitProjectResponseBody(name='body'),
}

async function createLivePortraitProjectWithOptions(request: CreateLivePortraitProjectRequest, runtime: Util.RuntimeOptions): CreateLivePortraitProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.audioId)) {
    body['AudioId'] = request.audioId;
  }
  if (!Util.isUnset(request.audioUrl)) {
    body['AudioUrl'] = request.audioUrl;
  }
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.imageId)) {
    body['ImageId'] = request.imageId;
  }
  if (!Util.isUnset(request.imageUrl)) {
    body['ImageUrl'] = request.imageUrl;
  }
  if (!Util.isUnset(request.intro)) {
    body['Intro'] = request.intro;
  }
  if (!Util.isUnset(request.lightModel)) {
    body['LightModel'] = request.lightModel;
  }
  if (!Util.isUnset(request.mode)) {
    body['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.outputConfig)) {
    body['OutputConfig'] = request.outputConfig;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  if (!Util.isUnset(request.ttsVoiceId)) {
    body['TtsVoiceId'] = request.ttsVoiceId;
  }
  if (!Util.isUnset(request.watermarkImageUrl)) {
    body['WatermarkImageUrl'] = request.watermarkImageUrl;
  }
  if (!Util.isUnset(request.watermarkStyle)) {
    body['WatermarkStyle'] = request.watermarkStyle;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLivePortraitProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLivePortraitProject(request: CreateLivePortraitProjectRequest): CreateLivePortraitProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLivePortraitProjectWithOptions(request, runtime);
}

model GenerateMotionShopVideoUploadUrlRequest {
  jwtToken?: string(name='JwtToken'),
}

model GenerateMotionShopVideoUploadUrlResponseBody = {
  code?: string(name='Code'),
  data?: {
    ossKey?: string(name='OssKey'),
    uploadUrl?: string(name='UploadUrl'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GenerateMotionShopVideoUploadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateMotionShopVideoUploadUrlResponseBody(name='body'),
}

async function generateMotionShopVideoUploadUrlWithOptions(request: GenerateMotionShopVideoUploadUrlRequest, runtime: Util.RuntimeOptions): GenerateMotionShopVideoUploadUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateMotionShopVideoUploadUrl',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateMotionShopVideoUploadUrl(request: GenerateMotionShopVideoUploadUrlRequest): GenerateMotionShopVideoUploadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateMotionShopVideoUploadUrlWithOptions(request, runtime);
}

model GetMapDataRequest {
  appId?: string(name='AppId'),
  jwtToken?: string(name='JwtToken'),
}

model GetMapDataResponseBody = {
  code?: string(name='Code'),
  data?: [  map[string]any ](name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMapDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMapDataResponseBody(name='body'),
}

async function getMapDataWithOptions(request: GetMapDataRequest, runtime: Util.RuntimeOptions): GetMapDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMapData',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMapData(request: GetMapDataRequest): GetMapDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMapDataWithOptions(request, runtime);
}

model GetMapPublishDataRequest {
  appId?: string(name='AppId'),
  jwtToken?: string(name='JwtToken'),
}

model GetMapPublishDataResponseBody = {
  code?: string(name='Code'),
  data?: [  map[string]any ](name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMapPublishDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMapPublishDataResponseBody(name='body'),
}

async function getMapPublishDataWithOptions(request: GetMapPublishDataRequest, runtime: Util.RuntimeOptions): GetMapPublishDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMapPublishData',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMapPublishData(request: GetMapPublishDataRequest): GetMapPublishDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMapPublishDataWithOptions(request, runtime);
}

model InitLocateRequest {
  jwtToken?: string(name='JwtToken'),
  params?: string(name='Params'),
}

model InitLocateResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InitLocateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InitLocateResponseBody(name='body'),
}

async function initLocateWithOptions(request: InitLocateRequest, runtime: Util.RuntimeOptions): InitLocateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.params)) {
    body['Params'] = request.params;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InitLocate',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function initLocate(request: InitLocateRequest): InitLocateResponse {
  var runtime = new Util.RuntimeOptions{};
  return initLocateWithOptions(request, runtime);
}

model ListCommonMaterialsRequest {
  jwtToken?: string(name='JwtToken'),
  type?: string(name='Type'),
}

model ListCommonMaterialsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      coverUrl?: string(name='CoverUrl'),
      ext?: string(name='Ext'),
      fileUrl?: string(name='FileUrl'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      ossKey?: string(name='OssKey'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListCommonMaterialsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCommonMaterialsResponseBody(name='body'),
}

async function listCommonMaterialsWithOptions(request: ListCommonMaterialsRequest, runtime: Util.RuntimeOptions): ListCommonMaterialsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCommonMaterials',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCommonMaterials(request: ListCommonMaterialsRequest): ListCommonMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCommonMaterialsWithOptions(request, runtime);
}

model ListDigitalHumanMaterialsRequest {
  current?: int32(name='Current'),
  jwtToken?: string(name='JwtToken'),
  onlyPersonalMaterials?: boolean(name='OnlyPersonalMaterials'),
  size?: int32(name='Size'),
  types?: string(name='Types'),
}

model ListDigitalHumanMaterialsResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      components?: [ 
        {
          ext?: string(name='Ext'),
          fileUrl?: string(name='FileUrl'),
          files?: map[string]any(name='Files'),
          id?: string(name='Id'),
          name?: string(name='Name'),
          type?: string(name='Type'),
        }
      ](name='Components'),
      ext?: string(name='Ext'),
      fileUrl?: string(name='FileUrl'),
      files?: map[string]any(name='Files'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListDigitalHumanMaterialsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDigitalHumanMaterialsResponseBody(name='body'),
}

async function listDigitalHumanMaterialsWithOptions(request: ListDigitalHumanMaterialsRequest, runtime: Util.RuntimeOptions): ListDigitalHumanMaterialsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.onlyPersonalMaterials)) {
    body['OnlyPersonalMaterials'] = request.onlyPersonalMaterials;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.types)) {
    body['Types'] = request.types;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDigitalHumanMaterials',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDigitalHumanMaterials(request: ListDigitalHumanMaterialsRequest): ListDigitalHumanMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDigitalHumanMaterialsWithOptions(request, runtime);
}

model ListLocationServiceRequest {
  current?: int32(name='Current'),
  jwtToken?: string(name='JwtToken'),
  size?: int32(name='Size'),
  sort?: string(name='Sort'),
  sortField?: string(name='SortField'),
}

model ListLocationServiceResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      appId?: string(name='AppId'),
      expireTime?: string(name='ExpireTime'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      note?: string(name='Note'),
      qps?: long(name='Qps'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      svcState?: string(name='SvcState'),
    }
  ](name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListLocationServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLocationServiceResponseBody(name='body'),
}

async function listLocationServiceWithOptions(request: ListLocationServiceRequest, runtime: Util.RuntimeOptions): ListLocationServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.sort)) {
    body['Sort'] = request.sort;
  }
  if (!Util.isUnset(request.sortField)) {
    body['SortField'] = request.sortField;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListLocationService',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLocationService(request: ListLocationServiceRequest): ListLocationServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLocationServiceWithOptions(request, runtime);
}

model ListMotionShopTasksRequest {
  current?: int32(name='Current'),
  jwtToken?: string(name='JwtToken'),
  size?: int32(name='Size'),
}

model ListMotionShopTasksResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      material?: {
        avatarId?: string(name='AvatarId'),
        box?: [ double ](name='Box'),
        coverUrl?: string(name='CoverUrl'),
      }(name='Material'),
      result?: {
        coverUrl?: string(name='CoverUrl'),
        shareUrl?: string(name='ShareUrl'),
        videoUrl?: string(name='VideoUrl'),
      }(name='Result'),
      status?: string(name='Status'),
      taskId?: string(name='TaskId'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model ListMotionShopTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMotionShopTasksResponseBody(name='body'),
}

async function listMotionShopTasksWithOptions(request: ListMotionShopTasksRequest, runtime: Util.RuntimeOptions): ListMotionShopTasksResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMotionShopTasks',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMotionShopTasks(request: ListMotionShopTasksRequest): ListMotionShopTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMotionShopTasksWithOptions(request, runtime);
}

model LivePortraitFaceDetectRequest {
  imageUrl?: string(name='ImageUrl'),
  jwtToken?: string(name='JwtToken'),
}

model LivePortraitFaceDetectResponseBody = {
  code?: string(name='Code'),
  data?: {
    code?: int32(name='Code'),
    message?: string(name='Message'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model LivePortraitFaceDetectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LivePortraitFaceDetectResponseBody(name='body'),
}

async function livePortraitFaceDetectWithOptions(request: LivePortraitFaceDetectRequest, runtime: Util.RuntimeOptions): LivePortraitFaceDetectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageUrl)) {
    body['ImageUrl'] = request.imageUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'LivePortraitFaceDetect',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function livePortraitFaceDetect(request: LivePortraitFaceDetectRequest): LivePortraitFaceDetectResponse {
  var runtime = new Util.RuntimeOptions{};
  return livePortraitFaceDetectWithOptions(request, runtime);
}

model LocateRequest {
  image?: string(name='Image'),
  jwtToken?: string(name='JwtToken'),
  params?: string(name='Params'),
}

model LocateResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model LocateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LocateResponseBody(name='body'),
}

async function locateWithOptions(request: LocateRequest, runtime: Util.RuntimeOptions): LocateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.image)) {
    body['Image'] = request.image;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.params)) {
    body['Params'] = request.params;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'Locate',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function locate(request: LocateRequest): LocateResponse {
  var runtime = new Util.RuntimeOptions{};
  return locateWithOptions(request, runtime);
}

model LoginModelScopeRequest {
  empId?: string(name='EmpId'),
  empName?: string(name='EmpName'),
  token?: string(name='Token'),
  type?: string(name='Type'),
}

model LoginModelScopeResponseBody = {
  code?: string(name='Code'),
  data?: {
    email?: string(name='Email'),
    jwtToken?: string(name='JwtToken'),
    nickname?: string(name='Nickname'),
    uid?: string(name='Uid'),
  }(name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model LoginModelScopeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LoginModelScopeResponseBody(name='body'),
}

async function loginModelScopeWithOptions(request: LoginModelScopeRequest, runtime: Util.RuntimeOptions): LoginModelScopeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.empId)) {
    body['EmpId'] = request.empId;
  }
  if (!Util.isUnset(request.empName)) {
    body['EmpName'] = request.empName;
  }
  if (!Util.isUnset(request.token)) {
    body['Token'] = request.token;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'LoginModelScope',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function loginModelScope(request: LoginModelScopeRequest): LoginModelScopeResponse {
  var runtime = new Util.RuntimeOptions{};
  return loginModelScopeWithOptions(request, runtime);
}

model MotionShopVideoDetectRequest {
  jwtToken?: string(name='JwtToken'),
  ossKey?: string(name='OssKey'),
}

model MotionShopVideoDetectResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model MotionShopVideoDetectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MotionShopVideoDetectResponseBody(name='body'),
}

async function motionShopVideoDetectWithOptions(request: MotionShopVideoDetectRequest, runtime: Util.RuntimeOptions): MotionShopVideoDetectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.ossKey)) {
    body['OssKey'] = request.ossKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'MotionShopVideoDetect',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function motionShopVideoDetect(request: MotionShopVideoDetectRequest): MotionShopVideoDetectResponse {
  var runtime = new Util.RuntimeOptions{};
  return motionShopVideoDetectWithOptions(request, runtime);
}

model PopBatchQueryObjectGenerationProjectStatusRequest {
  jwtToken?: string(name='JwtToken'),
  projectIds?: string(name='ProjectIds'),
}

model PopBatchQueryObjectGenerationProjectStatusResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      bizUsage?: string(name='BizUsage'),
      dataset?: {
        buildResultUrl?: map[string]any(name='BuildResultUrl'),
      }(name='Dataset'),
      id?: string(name='Id'),
      status?: string(name='Status'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopBatchQueryObjectGenerationProjectStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopBatchQueryObjectGenerationProjectStatusResponseBody(name='body'),
}

async function popBatchQueryObjectGenerationProjectStatusWithOptions(request: PopBatchQueryObjectGenerationProjectStatusRequest, runtime: Util.RuntimeOptions): PopBatchQueryObjectGenerationProjectStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectIds)) {
    body['ProjectIds'] = request.projectIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopBatchQueryObjectGenerationProjectStatus',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popBatchQueryObjectGenerationProjectStatus(request: PopBatchQueryObjectGenerationProjectStatusRequest): PopBatchQueryObjectGenerationProjectStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return popBatchQueryObjectGenerationProjectStatusWithOptions(request, runtime);
}

model PopBatchQueryObjectProjectStatusRequest {
  jwtToken?: string(name='JwtToken'),
  projectIds?: string(name='ProjectIds'),
}

model PopBatchQueryObjectProjectStatusResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      checkStatus?: string(name='CheckStatus'),
      id?: string(name='Id'),
      status?: string(name='Status'),
    }
  ](name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopBatchQueryObjectProjectStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopBatchQueryObjectProjectStatusResponseBody(name='body'),
}

async function popBatchQueryObjectProjectStatusWithOptions(request: PopBatchQueryObjectProjectStatusRequest, runtime: Util.RuntimeOptions): PopBatchQueryObjectProjectStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.projectIds)) {
    body['ProjectIds'] = request.projectIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopBatchQueryObjectProjectStatus',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popBatchQueryObjectProjectStatus(request: PopBatchQueryObjectProjectStatusRequest): PopBatchQueryObjectProjectStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return popBatchQueryObjectProjectStatusWithOptions(request, runtime);
}

model PopBuildFeatureToAvatarProjectRequest {
  projectId?: string(name='ProjectId'),
}

model PopBuildFeatureToAvatarProjectResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopBuildFeatureToAvatarProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopBuildFeatureToAvatarProjectResponseBody(name='body'),
}

async function popBuildFeatureToAvatarProjectWithOptions(request: PopBuildFeatureToAvatarProjectRequest, runtime: Util.RuntimeOptions): PopBuildFeatureToAvatarProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopBuildFeatureToAvatarProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popBuildFeatureToAvatarProject(request: PopBuildFeatureToAvatarProjectRequest): PopBuildFeatureToAvatarProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popBuildFeatureToAvatarProjectWithOptions(request, runtime);
}

model PopBuildLivePortraitModelScopeProjectRequest {
  projectId?: string(name='ProjectId'),
}

model PopBuildLivePortraitModelScopeProjectResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopBuildLivePortraitModelScopeProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopBuildLivePortraitModelScopeProjectResponseBody(name='body'),
}

async function popBuildLivePortraitModelScopeProjectWithOptions(request: PopBuildLivePortraitModelScopeProjectRequest, runtime: Util.RuntimeOptions): PopBuildLivePortraitModelScopeProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopBuildLivePortraitModelScopeProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popBuildLivePortraitModelScopeProject(request: PopBuildLivePortraitModelScopeProjectRequest): PopBuildLivePortraitModelScopeProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popBuildLivePortraitModelScopeProjectWithOptions(request, runtime);
}

model PopBuildObjectGenerationProjectRequest {
  jwtToken?: string(name='JwtToken'),
  projectId?: string(name='ProjectId'),
}

model PopBuildObjectGenerationProjectResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopBuildObjectGenerationProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopBuildObjectGenerationProjectResponseBody(name='body'),
}

async function popBuildObjectGenerationProjectWithOptions(request: PopBuildObjectGenerationProjectRequest, runtime: Util.RuntimeOptions): PopBuildObjectGenerationProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopBuildObjectGenerationProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popBuildObjectGenerationProject(request: PopBuildObjectGenerationProjectRequest): PopBuildObjectGenerationProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popBuildObjectGenerationProjectWithOptions(request, runtime);
}

model PopBuildObjectProjectRequest {
  jwtToken?: string(name='JwtToken'),
  projectId?: string(name='ProjectId'),
}

model PopBuildObjectProjectResponseBody = {
  code?: string(name='Code'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopBuildObjectProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopBuildObjectProjectResponseBody(name='body'),
}

async function popBuildObjectProjectWithOptions(request: PopBuildObjectProjectRequest, runtime: Util.RuntimeOptions): PopBuildObjectProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopBuildObjectProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popBuildObjectProject(request: PopBuildObjectProjectRequest): PopBuildObjectProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popBuildObjectProjectWithOptions(request, runtime);
}

model PopBuildPakRenderProjectRequest {
  projectId?: string(name='ProjectId'),
}

model PopBuildPakRenderProjectResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopBuildPakRenderProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopBuildPakRenderProjectResponseBody(name='body'),
}

async function popBuildPakRenderProjectWithOptions(request: PopBuildPakRenderProjectRequest, runtime: Util.RuntimeOptions): PopBuildPakRenderProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopBuildPakRenderProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popBuildPakRenderProject(request: PopBuildPakRenderProjectRequest): PopBuildPakRenderProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popBuildPakRenderProjectWithOptions(request, runtime);
}

model PopBuildTextToAvatarProjectRequest {
  jwtToken?: string(name='JwtToken'),
  projectId?: string(name='ProjectId'),
}

model PopBuildTextToAvatarProjectResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopBuildTextToAvatarProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopBuildTextToAvatarProjectResponseBody(name='body'),
}

async function popBuildTextToAvatarProjectWithOptions(request: PopBuildTextToAvatarProjectRequest, runtime: Util.RuntimeOptions): PopBuildTextToAvatarProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopBuildTextToAvatarProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popBuildTextToAvatarProject(request: PopBuildTextToAvatarProjectRequest): PopBuildTextToAvatarProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popBuildTextToAvatarProjectWithOptions(request, runtime);
}

model PopCreateFeatureToAvatarProjectRequest {
  extInfo?: string(name='ExtInfo'),
  intro?: string(name='Intro'),
  title?: string(name='Title'),
}

model PopCreateFeatureToAvatarProjectResponseBody = {
  code?: string(name='Code'),
  data?: {
    bizUsage?: string(name='BizUsage'),
    buildDetail?: {
      completedTime?: string(name='CompletedTime'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorMessage?: string(name='ErrorMessage'),
      estimatedDuration?: long(name='EstimatedDuration'),
      id?: long(name='Id'),
      modifiedTime?: string(name='ModifiedTime'),
      runningTime?: string(name='RunningTime'),
      status?: string(name='Status'),
      submitTime?: string(name='SubmitTime'),
    }(name='BuildDetail'),
    checkStatus?: string(name='CheckStatus'),
    createMode?: string(name='CreateMode'),
    createTime?: string(name='CreateTime'),
    dataset?: {
      buildResultUrl?: map[string]any(name='BuildResultUrl'),
      coverUrl?: string(name='CoverUrl'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      glbModelUrl?: string(name='GlbModelUrl'),
      id?: long(name='Id'),
      modelUrl?: string(name='ModelUrl'),
      modifiedTime?: string(name='ModifiedTime'),
      originResultUrl?: string(name='OriginResultUrl'),
      ossKey?: string(name='OssKey'),
      policy?: {
        accessId?: string(name='AccessId'),
        dir?: string(name='Dir'),
        expire?: string(name='Expire'),
        host?: string(name='Host'),
        policy?: string(name='Policy'),
        signature?: string(name='Signature'),
      }(name='Policy'),
      poseUrl?: string(name='PoseUrl'),
      previewUrl?: string(name='PreviewUrl'),
    }(name='Dataset'),
    deleted?: boolean(name='Deleted'),
    ext?: string(name='Ext'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    materialCoverUrl?: string(name='MaterialCoverUrl'),
    modifiedTime?: string(name='ModifiedTime'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    type?: string(name='Type'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopCreateFeatureToAvatarProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopCreateFeatureToAvatarProjectResponseBody(name='body'),
}

async function popCreateFeatureToAvatarProjectWithOptions(request: PopCreateFeatureToAvatarProjectRequest, runtime: Util.RuntimeOptions): PopCreateFeatureToAvatarProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extInfo)) {
    body['ExtInfo'] = request.extInfo;
  }
  if (!Util.isUnset(request.intro)) {
    body['Intro'] = request.intro;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopCreateFeatureToAvatarProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popCreateFeatureToAvatarProject(request: PopCreateFeatureToAvatarProjectRequest): PopCreateFeatureToAvatarProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popCreateFeatureToAvatarProjectWithOptions(request, runtime);
}

model PopCreateLivePortraitModelScopeProjectRequest {
  extInfo?: string(name='ExtInfo'),
  intro?: string(name='Intro'),
  title?: string(name='Title'),
}

model PopCreateLivePortraitModelScopeProjectResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopCreateLivePortraitModelScopeProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopCreateLivePortraitModelScopeProjectResponseBody(name='body'),
}

async function popCreateLivePortraitModelScopeProjectWithOptions(request: PopCreateLivePortraitModelScopeProjectRequest, runtime: Util.RuntimeOptions): PopCreateLivePortraitModelScopeProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extInfo)) {
    body['ExtInfo'] = request.extInfo;
  }
  if (!Util.isUnset(request.intro)) {
    body['Intro'] = request.intro;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopCreateLivePortraitModelScopeProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popCreateLivePortraitModelScopeProject(request: PopCreateLivePortraitModelScopeProjectRequest): PopCreateLivePortraitModelScopeProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popCreateLivePortraitModelScopeProjectWithOptions(request, runtime);
}

model PopCreateMaterialRequest {
  checkStatus?: string(name='CheckStatus'),
  ext?: string(name='Ext'),
  intro?: string(name='Intro'),
  jwtToken?: string(name='JwtToken'),
  listStatus?: string(name='ListStatus'),
  name?: string(name='Name'),
  ossKey?: string(name='OssKey'),
  type?: string(name='Type'),
}

model PopCreateMaterialResponseBody = {
  code?: string(name='Code'),
  data?: {
    checkStatus?: string(name='CheckStatus'),
    common?: boolean(name='Common'),
    coverUrl?: string(name='CoverUrl'),
    createTime?: string(name='CreateTime'),
    deleted?: boolean(name='Deleted'),
    ext?: string(name='Ext'),
    fileUrl?: string(name='FileUrl'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    listStatus?: string(name='ListStatus'),
    modifiedTime?: string(name='ModifiedTime'),
    name?: string(name='Name'),
    ossKey?: string(name='OssKey'),
    previewUrl?: string(name='PreviewUrl'),
    type?: string(name='Type'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopCreateMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopCreateMaterialResponseBody(name='body'),
}

async function popCreateMaterialWithOptions(request: PopCreateMaterialRequest, runtime: Util.RuntimeOptions): PopCreateMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkStatus)) {
    body['CheckStatus'] = request.checkStatus;
  }
  if (!Util.isUnset(request.ext)) {
    body['Ext'] = request.ext;
  }
  if (!Util.isUnset(request.intro)) {
    body['Intro'] = request.intro;
  }
  if (!Util.isUnset(request.listStatus)) {
    body['ListStatus'] = request.listStatus;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.ossKey)) {
    body['OssKey'] = request.ossKey;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopCreateMaterial',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popCreateMaterial(request: PopCreateMaterialRequest): PopCreateMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return popCreateMaterialWithOptions(request, runtime);
}

model PopCreateObjectGenerationProjectRequest {
  bizUsage?: string(name='BizUsage'),
  extInfo?: string(name='ExtInfo'),
  intro?: string(name='Intro'),
  jwtToken?: string(name='JwtToken'),
  title?: string(name='Title'),
}

model PopCreateObjectGenerationProjectResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopCreateObjectGenerationProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopCreateObjectGenerationProjectResponseBody(name='body'),
}

async function popCreateObjectGenerationProjectWithOptions(request: PopCreateObjectGenerationProjectRequest, runtime: Util.RuntimeOptions): PopCreateObjectGenerationProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizUsage)) {
    body['BizUsage'] = request.bizUsage;
  }
  if (!Util.isUnset(request.extInfo)) {
    body['ExtInfo'] = request.extInfo;
  }
  if (!Util.isUnset(request.intro)) {
    body['Intro'] = request.intro;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopCreateObjectGenerationProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popCreateObjectGenerationProject(request: PopCreateObjectGenerationProjectRequest): PopCreateObjectGenerationProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popCreateObjectGenerationProjectWithOptions(request, runtime);
}

model PopCreateObjectProjectRequest {
  autoBuild?: boolean(name='AutoBuild'),
  bizUsage?: string(name='BizUsage'),
  customSource?: string(name='CustomSource'),
  dependencies?: string(name='Dependencies'),
  foreignUid?: string(name='ForeignUid'),
  intro?: string(name='Intro'),
  jwtToken?: string(name='JwtToken'),
  mode?: string(name='Mode'),
  recommendStatus?: string(name='RecommendStatus'),
  title?: string(name='Title'),
}

model PopCreateObjectProjectResponseBody = {
  code?: string(name='Code'),
  data?: {
    auditStatus?: string(name='AuditStatus'),
    autoBuild?: boolean(name='AutoBuild'),
    bizUsage?: string(name='BizUsage'),
    buildDetail?: {
      completedTime?: string(name='CompletedTime'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorMessage?: string(name='ErrorMessage'),
      estimatedDuration?: long(name='EstimatedDuration'),
      modifiedTime?: string(name='ModifiedTime'),
      runningTime?: string(name='RunningTime'),
      submitTime?: string(name='SubmitTime'),
    }(name='BuildDetail'),
    checkStatus?: string(name='CheckStatus'),
    createMode?: string(name='CreateMode'),
    createTime?: string(name='CreateTime'),
    customSource?: string(name='CustomSource'),
    dataset?: {
      buildResultUrl?: map[string]any(name='BuildResultUrl'),
      coverUrl?: string(name='CoverUrl'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorMessage?: string(name='ErrorMessage'),
      glbModelUrl?: string(name='GlbModelUrl'),
      modelUrl?: string(name='ModelUrl'),
      modifiedTime?: string(name='ModifiedTime'),
      originResultUrl?: string(name='OriginResultUrl'),
      ossKey?: string(name='OssKey'),
      policy?: {
        accessId?: string(name='AccessId'),
        dir?: string(name='Dir'),
        expire?: string(name='Expire'),
        host?: string(name='Host'),
        policy?: string(name='Policy'),
        signature?: string(name='Signature'),
      }(name='Policy'),
      poseUrl?: string(name='PoseUrl'),
      previewUrl?: string(name='PreviewUrl'),
      token?: {
        accessKeyId?: string(name='AccessKeyId'),
        accessKeySecret?: string(name='AccessKeySecret'),
        dir?: string(name='Dir'),
        expiration?: string(name='Expiration'),
        host?: string(name='Host'),
        securityToken?: string(name='SecurityToken'),
      }(name='Token'),
    }(name='Dataset'),
    deleted?: boolean(name='Deleted'),
    dependencies?: string(name='Dependencies'),
    ext?: string(name='Ext'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    modifiedTime?: string(name='ModifiedTime'),
    recommendStatus?: string(name='RecommendStatus'),
    source?: {
      clothes?: [ 
        {
          coverUrl?: string(name='CoverUrl'),
          createTime?: string(name='CreateTime'),
          deleted?: boolean(name='Deleted'),
          modifiedTime?: string(name='ModifiedTime'),
          name?: string(name='Name'),
          ossKey?: string(name='OssKey'),
          type?: string(name='Type'),
        }
      ](name='Clothes'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      modifiedTime?: string(name='ModifiedTime'),
      ossKey?: string(name='OssKey'),
      policy?: {
        accessId?: string(name='AccessId'),
        dir?: string(name='Dir'),
        expire?: string(name='Expire'),
        host?: string(name='Host'),
        policy?: string(name='Policy'),
        signature?: string(name='Signature'),
      }(name='Policy'),
      sourceFiles?: [ 
        {
          coverUrl?: string(name='CoverUrl'),
          createTime?: string(name='CreateTime'),
          deleted?: boolean(name='Deleted'),
          fileName?: string(name='FileName'),
          filesize?: long(name='Filesize'),
          modifiedTime?: string(name='ModifiedTime'),
          ossKey?: string(name='OssKey'),
          type?: string(name='Type'),
          url?: string(name='Url'),
        }
      ](name='SourceFiles'),
      token?: {
        accessKeyId?: string(name='AccessKeyId'),
        accessKeySecret?: string(name='AccessKeySecret'),
        dir?: string(name='Dir'),
        expiration?: string(name='Expiration'),
        host?: string(name='Host'),
        securityToken?: string(name='SecurityToken'),
      }(name='Token'),
    }(name='Source'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    type?: string(name='Type'),
  }(name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopCreateObjectProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopCreateObjectProjectResponseBody(name='body'),
}

async function popCreateObjectProjectWithOptions(request: PopCreateObjectProjectRequest, runtime: Util.RuntimeOptions): PopCreateObjectProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoBuild)) {
    body['AutoBuild'] = request.autoBuild;
  }
  if (!Util.isUnset(request.bizUsage)) {
    body['BizUsage'] = request.bizUsage;
  }
  if (!Util.isUnset(request.customSource)) {
    body['CustomSource'] = request.customSource;
  }
  if (!Util.isUnset(request.dependencies)) {
    body['Dependencies'] = request.dependencies;
  }
  if (!Util.isUnset(request.foreignUid)) {
    body['ForeignUid'] = request.foreignUid;
  }
  if (!Util.isUnset(request.intro)) {
    body['Intro'] = request.intro;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.mode)) {
    body['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.recommendStatus)) {
    body['RecommendStatus'] = request.recommendStatus;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopCreateObjectProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popCreateObjectProject(request: PopCreateObjectProjectRequest): PopCreateObjectProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popCreateObjectProjectWithOptions(request, runtime);
}

model PopCreatePakRenderProjectRequest {
  extInfo?: string(name='ExtInfo'),
  intro?: string(name='Intro'),
  title?: string(name='Title'),
}

model PopCreatePakRenderProjectResponseBody = {
  code?: string(name='Code'),
  data?: {
    autoBuild?: boolean(name='AutoBuild'),
    bizUsage?: string(name='BizUsage'),
    checkStatus?: string(name='CheckStatus'),
    createMode?: string(name='CreateMode'),
    createTime?: string(name='CreateTime'),
    deleted?: boolean(name='Deleted'),
    dependencies?: string(name='Dependencies'),
    ext?: string(name='Ext'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    materialCoverUrl?: string(name='MaterialCoverUrl'),
    modifiedTime?: string(name='ModifiedTime'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    type?: string(name='Type'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopCreatePakRenderProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopCreatePakRenderProjectResponseBody(name='body'),
}

async function popCreatePakRenderProjectWithOptions(request: PopCreatePakRenderProjectRequest, runtime: Util.RuntimeOptions): PopCreatePakRenderProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extInfo)) {
    body['ExtInfo'] = request.extInfo;
  }
  if (!Util.isUnset(request.intro)) {
    body['Intro'] = request.intro;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopCreatePakRenderProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popCreatePakRenderProject(request: PopCreatePakRenderProjectRequest): PopCreatePakRenderProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popCreatePakRenderProjectWithOptions(request, runtime);
}

model PopCreateTextToAvatarProjectRequest {
  extInfo?: string(name='ExtInfo'),
  intro?: string(name='Intro'),
  jwtToken?: string(name='JwtToken'),
  title?: string(name='Title'),
}

model PopCreateTextToAvatarProjectResponseBody = {
  code?: string(name='Code'),
  data?: {
    autoBuild?: boolean(name='AutoBuild'),
    bizUsage?: string(name='BizUsage'),
    checkStatus?: string(name='CheckStatus'),
    createMode?: string(name='CreateMode'),
    createTime?: string(name='CreateTime'),
    deleted?: boolean(name='Deleted'),
    dependencies?: string(name='Dependencies'),
    ext?: string(name='Ext'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    materialCoverUrl?: string(name='MaterialCoverUrl'),
    modifiedTime?: string(name='ModifiedTime'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    type?: string(name='Type'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopCreateTextToAvatarProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopCreateTextToAvatarProjectResponseBody(name='body'),
}

async function popCreateTextToAvatarProjectWithOptions(request: PopCreateTextToAvatarProjectRequest, runtime: Util.RuntimeOptions): PopCreateTextToAvatarProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.extInfo)) {
    body['ExtInfo'] = request.extInfo;
  }
  if (!Util.isUnset(request.intro)) {
    body['Intro'] = request.intro;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopCreateTextToAvatarProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popCreateTextToAvatarProject(request: PopCreateTextToAvatarProjectRequest): PopCreateTextToAvatarProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popCreateTextToAvatarProjectWithOptions(request, runtime);
}

model PopDeleteMaterialRequest {
  jwtToken?: string(name='JwtToken'),
  materialId?: string(name='MaterialId'),
}

model PopDeleteMaterialResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopDeleteMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopDeleteMaterialResponseBody(name='body'),
}

async function popDeleteMaterialWithOptions(request: PopDeleteMaterialRequest, runtime: Util.RuntimeOptions): PopDeleteMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.materialId)) {
    query['MaterialId'] = request.materialId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PopDeleteMaterial',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popDeleteMaterial(request: PopDeleteMaterialRequest): PopDeleteMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return popDeleteMaterialWithOptions(request, runtime);
}

model PopGetAITryOnJobRequest {
  jwtToken?: string(name='JwtToken'),
  projectId?: string(name='ProjectId'),
  withMaterial?: boolean(name='WithMaterial'),
  withResult?: boolean(name='WithResult'),
}

model PopGetAITryOnJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    dummyProjectInfo?: {
      auditStatus?: string(name='AuditStatus'),
      autoBuild?: boolean(name='AutoBuild'),
      bizUsage?: string(name='BizUsage'),
      buildDetail?: {
        completedTime?: string(name='CompletedTime'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorMessage?: string(name='ErrorMessage'),
        estimatedDuration?: long(name='EstimatedDuration'),
        id?: long(name='Id'),
        modifiedTime?: string(name='ModifiedTime'),
        runningTime?: string(name='RunningTime'),
        status?: string(name='Status'),
        submitTime?: string(name='SubmitTime'),
      }(name='BuildDetail'),
      checkStatus?: string(name='CheckStatus'),
      createMode?: string(name='CreateMode'),
      createTime?: string(name='CreateTime'),
      customSource?: string(name='CustomSource'),
      dataset?: {
        buildResultUrl?: map[string]any(name='BuildResultUrl'),
        coverUrl?: string(name='CoverUrl'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        glbModelUrl?: string(name='GlbModelUrl'),
        id?: long(name='Id'),
        modelUrl?: string(name='ModelUrl'),
        modifiedTime?: string(name='ModifiedTime'),
        originResultUrl?: string(name='OriginResultUrl'),
        ossKey?: string(name='OssKey'),
        policy?: {
          accessId?: string(name='AccessId'),
          dir?: string(name='Dir'),
          expire?: string(name='Expire'),
          host?: string(name='Host'),
          policy?: string(name='Policy'),
          signature?: string(name='Signature'),
        }(name='Policy'),
        poseUrl?: string(name='PoseUrl'),
        previewUrl?: string(name='PreviewUrl'),
      }(name='Dataset'),
      deleted?: boolean(name='Deleted'),
      dependencies?: string(name='Dependencies'),
      ext?: string(name='Ext'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      materialCoverUrl?: string(name='MaterialCoverUrl'),
      modifiedTime?: string(name='ModifiedTime'),
      source?: {
        clothes?: [ 
          {
            coverUrl?: string(name='CoverUrl'),
            createTime?: string(name='CreateTime'),
            deleted?: boolean(name='Deleted'),
            id?: long(name='Id'),
            modifiedTime?: string(name='ModifiedTime'),
            name?: string(name='Name'),
            ossKey?: string(name='OssKey'),
            part?: string(name='Part'),
            size?: string(name='Size'),
            skuProps?: [ 
              {
                name?: string(name='Name'),
                options?: [ string ](name='Options'),
              }
            ](name='SkuProps'),
            skus?: [ 
              {
                color?: string(name='Color'),
                cover?: string(name='Cover'),
                size?: string(name='Size'),
                status?: string(name='Status'),
              }
            ](name='Skus'),
            status?: map[string]string(name='Status'),
            type?: string(name='Type'),
            version?: int32(name='Version'),
          }
        ](name='Clothes'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        id?: long(name='Id'),
        modifiedTime?: string(name='ModifiedTime'),
        ossKey?: string(name='OssKey'),
        policy?: {
          accessId?: string(name='AccessId'),
          dir?: string(name='Dir'),
          expire?: string(name='Expire'),
          host?: string(name='Host'),
          policy?: string(name='Policy'),
          signature?: string(name='Signature'),
        }(name='Policy'),
        sourceFiles?: [ 
          {
            coverUrl?: string(name='CoverUrl'),
            createTime?: string(name='CreateTime'),
            deleted?: boolean(name='Deleted'),
            fileName?: string(name='FileName'),
            filesize?: long(name='Filesize'),
            id?: long(name='Id'),
            modifiedTime?: string(name='ModifiedTime'),
            ossKey?: string(name='OssKey'),
            type?: string(name='Type'),
            url?: string(name='Url'),
          }
        ](name='SourceFiles'),
        token?: {
          accessKeyId?: string(name='AccessKeyId'),
          accessKeySecret?: string(name='AccessKeySecret'),
          dir?: string(name='Dir'),
          expiration?: string(name='Expiration'),
          host?: string(name='Host'),
          securityToken?: string(name='SecurityToken'),
        }(name='Token'),
      }(name='Source'),
      status?: string(name='Status'),
      title?: string(name='Title'),
      type?: string(name='Type'),
    }(name='DummyProjectInfo'),
    materialInfo?: {
      bottoms?: {
        checkStatus?: string(name='CheckStatus'),
        common?: boolean(name='Common'),
        coverUrl?: string(name='CoverUrl'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        ext?: string(name='Ext'),
        fileUrl?: string(name='FileUrl'),
        id?: long(name='Id'),
        intro?: string(name='Intro'),
        listStatus?: string(name='ListStatus'),
        modifiedTime?: string(name='ModifiedTime'),
        name?: string(name='Name'),
        ossKey?: string(name='OssKey'),
        previewUrl?: string(name='PreviewUrl'),
        type?: string(name='Type'),
      }(name='Bottoms'),
      clothingType?: string(name='ClothingType'),
      model?: {
        checkStatus?: string(name='CheckStatus'),
        common?: boolean(name='Common'),
        coverUrl?: string(name='CoverUrl'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        ext?: string(name='Ext'),
        fileUrl?: string(name='FileUrl'),
        id?: long(name='Id'),
        intro?: string(name='Intro'),
        listStatus?: string(name='ListStatus'),
        modifiedTime?: string(name='ModifiedTime'),
        name?: string(name='Name'),
        ossKey?: string(name='OssKey'),
        previewUrl?: string(name='PreviewUrl'),
        type?: string(name='Type'),
      }(name='Model'),
      shoeType?: string(name='ShoeType'),
      suit?: {
        checkStatus?: string(name='CheckStatus'),
        common?: boolean(name='Common'),
        coverUrl?: string(name='CoverUrl'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        ext?: string(name='Ext'),
        fileUrl?: string(name='FileUrl'),
        id?: long(name='Id'),
        intro?: string(name='Intro'),
        listStatus?: string(name='ListStatus'),
        modifiedTime?: string(name='ModifiedTime'),
        name?: string(name='Name'),
        ossKey?: string(name='OssKey'),
        previewUrl?: string(name='PreviewUrl'),
        type?: string(name='Type'),
      }(name='Suit'),
      tops?: {
        checkStatus?: string(name='CheckStatus'),
        common?: boolean(name='Common'),
        coverUrl?: string(name='CoverUrl'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        ext?: string(name='Ext'),
        fileUrl?: string(name='FileUrl'),
        id?: long(name='Id'),
        intro?: string(name='Intro'),
        listStatus?: string(name='ListStatus'),
        modifiedTime?: string(name='ModifiedTime'),
        name?: string(name='Name'),
        ossKey?: string(name='OssKey'),
        previewUrl?: string(name='PreviewUrl'),
        type?: string(name='Type'),
      }(name='Tops'),
    }(name='MaterialInfo'),
    subTasks?: [ 
      {
        feedback?: {
          dislikeTags?: [ int32 ](name='DislikeTags'),
          otherReason?: string(name='OtherReason'),
          projectId?: long(name='ProjectId'),
          rating?: int32(name='Rating'),
        }(name='Feedback'),
        subProjectInfo?: {
          auditStatus?: string(name='AuditStatus'),
          autoBuild?: boolean(name='AutoBuild'),
          bizUsage?: string(name='BizUsage'),
          buildDetail?: {
            completedTime?: string(name='CompletedTime'),
            createTime?: string(name='CreateTime'),
            deleted?: boolean(name='Deleted'),
            errorMessage?: string(name='ErrorMessage'),
            estimatedDuration?: long(name='EstimatedDuration'),
            id?: long(name='Id'),
            modifiedTime?: string(name='ModifiedTime'),
            runningTime?: string(name='RunningTime'),
            status?: string(name='Status'),
            submitTime?: string(name='SubmitTime'),
          }(name='BuildDetail'),
          checkStatus?: string(name='CheckStatus'),
          createMode?: string(name='CreateMode'),
          createTime?: string(name='CreateTime'),
          customSource?: string(name='CustomSource'),
          dataset?: {
            buildResultUrl?: map[string]any(name='BuildResultUrl'),
            coverUrl?: string(name='CoverUrl'),
            createTime?: string(name='CreateTime'),
            deleted?: boolean(name='Deleted'),
            errorCode?: string(name='ErrorCode'),
            errorMessage?: string(name='ErrorMessage'),
            glbModelUrl?: string(name='GlbModelUrl'),
            id?: long(name='Id'),
            modelUrl?: string(name='ModelUrl'),
            modifiedTime?: string(name='ModifiedTime'),
            originResultUrl?: string(name='OriginResultUrl'),
            ossKey?: string(name='OssKey'),
            policy?: {
              accessId?: string(name='AccessId'),
              dir?: string(name='Dir'),
              expire?: string(name='Expire'),
              host?: string(name='Host'),
              policy?: string(name='Policy'),
              signature?: string(name='Signature'),
            }(name='Policy'),
            poseUrl?: string(name='PoseUrl'),
            previewUrl?: string(name='PreviewUrl'),
          }(name='Dataset'),
          deleted?: boolean(name='Deleted'),
          dependencies?: string(name='Dependencies'),
          ext?: string(name='Ext'),
          id?: string(name='Id'),
          intro?: string(name='Intro'),
          materialCoverUrl?: string(name='MaterialCoverUrl'),
          modifiedTime?: string(name='ModifiedTime'),
          source?: {
            clothes?: [ 
              {
                coverUrl?: string(name='CoverUrl'),
                createTime?: string(name='CreateTime'),
                deleted?: boolean(name='Deleted'),
                id?: long(name='Id'),
                modifiedTime?: string(name='ModifiedTime'),
                name?: string(name='Name'),
                ossKey?: string(name='OssKey'),
                part?: string(name='Part'),
                size?: string(name='Size'),
                skuProps?: [ 
                  {
                    name?: string(name='Name'),
                    options?: [ string ](name='Options'),
                  }
                ](name='SkuProps'),
                skus?: [ 
                  {
                    color?: string(name='Color'),
                    cover?: string(name='Cover'),
                    size?: string(name='Size'),
                    status?: string(name='Status'),
                  }
                ](name='Skus'),
                status?: map[string]string(name='Status'),
                type?: string(name='Type'),
                version?: int32(name='Version'),
              }
            ](name='Clothes'),
            createTime?: string(name='CreateTime'),
            deleted?: boolean(name='Deleted'),
            id?: long(name='Id'),
            modifiedTime?: string(name='ModifiedTime'),
            ossKey?: string(name='OssKey'),
            policy?: {
              accessId?: string(name='AccessId'),
              dir?: string(name='Dir'),
              expire?: string(name='Expire'),
              host?: string(name='Host'),
              policy?: string(name='Policy'),
              signature?: string(name='Signature'),
            }(name='Policy'),
            sourceFiles?: [ 
              {
                coverUrl?: string(name='CoverUrl'),
                createTime?: string(name='CreateTime'),
                deleted?: boolean(name='Deleted'),
                fileName?: string(name='FileName'),
                filesize?: long(name='Filesize'),
                id?: long(name='Id'),
                modifiedTime?: string(name='ModifiedTime'),
                ossKey?: string(name='OssKey'),
                type?: string(name='Type'),
                url?: string(name='Url'),
              }
            ](name='SourceFiles'),
            token?: {
              accessKeyId?: string(name='AccessKeyId'),
              accessKeySecret?: string(name='AccessKeySecret'),
              dir?: string(name='Dir'),
              expiration?: string(name='Expiration'),
              host?: string(name='Host'),
              securityToken?: string(name='SecurityToken'),
            }(name='Token'),
          }(name='Source'),
          status?: string(name='Status'),
          title?: string(name='Title'),
          type?: string(name='Type'),
        }(name='SubProjectInfo'),
      }
    ](name='SubTasks'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopGetAITryOnJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopGetAITryOnJobResponseBody(name='body'),
}

async function popGetAITryOnJobWithOptions(request: PopGetAITryOnJobRequest, runtime: Util.RuntimeOptions): PopGetAITryOnJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.withMaterial)) {
    query['WithMaterial'] = request.withMaterial;
  }
  if (!Util.isUnset(request.withResult)) {
    query['WithResult'] = request.withResult;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PopGetAITryOnJob',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popGetAITryOnJob(request: PopGetAITryOnJobRequest): PopGetAITryOnJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return popGetAITryOnJobWithOptions(request, runtime);
}

model PopListAITryOnJobsRequest {
  current?: int32(name='Current'),
  jwtToken?: string(name='JwtToken'),
  size?: int32(name='Size'),
}

model PopListAITryOnJobsResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      dummyProjectInfo?: {
        auditStatus?: string(name='AuditStatus'),
        autoBuild?: boolean(name='AutoBuild'),
        bizUsage?: string(name='BizUsage'),
        buildDetail?: {
          completedTime?: string(name='CompletedTime'),
          createTime?: string(name='CreateTime'),
          deleted?: boolean(name='Deleted'),
          errorMessage?: string(name='ErrorMessage'),
          estimatedDuration?: long(name='EstimatedDuration'),
          id?: long(name='Id'),
          modifiedTime?: string(name='ModifiedTime'),
          runningTime?: string(name='RunningTime'),
          status?: string(name='Status'),
          submitTime?: string(name='SubmitTime'),
        }(name='BuildDetail'),
        checkStatus?: string(name='CheckStatus'),
        createMode?: string(name='CreateMode'),
        createTime?: string(name='CreateTime'),
        customSource?: string(name='CustomSource'),
        dataset?: {
          buildResultUrl?: map[string]any(name='BuildResultUrl'),
          coverUrl?: string(name='CoverUrl'),
          createTime?: string(name='CreateTime'),
          deleted?: boolean(name='Deleted'),
          errorCode?: string(name='ErrorCode'),
          errorMessage?: string(name='ErrorMessage'),
          glbModelUrl?: string(name='GlbModelUrl'),
          id?: long(name='Id'),
          modelUrl?: string(name='ModelUrl'),
          modifiedTime?: string(name='ModifiedTime'),
          originResultUrl?: string(name='OriginResultUrl'),
          ossKey?: string(name='OssKey'),
          policy?: {
            accessId?: string(name='AccessId'),
            dir?: string(name='Dir'),
            expire?: string(name='Expire'),
            host?: string(name='Host'),
            policy?: string(name='Policy'),
            signature?: string(name='Signature'),
          }(name='Policy'),
          poseUrl?: string(name='PoseUrl'),
          previewUrl?: string(name='PreviewUrl'),
        }(name='Dataset'),
        deleted?: boolean(name='Deleted'),
        dependencies?: string(name='Dependencies'),
        ext?: string(name='Ext'),
        id?: string(name='Id'),
        intro?: string(name='Intro'),
        materialCoverUrl?: string(name='MaterialCoverUrl'),
        modifiedTime?: string(name='ModifiedTime'),
        source?: {
          clothes?: [ 
            {
              coverUrl?: string(name='CoverUrl'),
              createTime?: string(name='CreateTime'),
              deleted?: boolean(name='Deleted'),
              id?: long(name='Id'),
              modifiedTime?: string(name='ModifiedTime'),
              name?: string(name='Name'),
              ossKey?: string(name='OssKey'),
              part?: string(name='Part'),
              size?: string(name='Size'),
              skuProps?: [ 
                {
                  name?: string(name='Name'),
                  options?: [ string ](name='Options'),
                }
              ](name='SkuProps'),
              skus?: [ 
                {
                  color?: string(name='Color'),
                  cover?: string(name='Cover'),
                  size?: string(name='Size'),
                  status?: string(name='Status'),
                }
              ](name='Skus'),
              status?: map[string]string(name='Status'),
              type?: string(name='Type'),
              version?: int32(name='Version'),
            }
          ](name='Clothes'),
          createTime?: string(name='CreateTime'),
          deleted?: boolean(name='Deleted'),
          id?: long(name='Id'),
          modifiedTime?: string(name='ModifiedTime'),
          ossKey?: string(name='OssKey'),
          policy?: {
            accessId?: string(name='AccessId'),
            dir?: string(name='Dir'),
            expire?: string(name='Expire'),
            host?: string(name='Host'),
            policy?: string(name='Policy'),
            signature?: string(name='Signature'),
          }(name='Policy'),
          sourceFiles?: [ 
            {
              coverUrl?: string(name='CoverUrl'),
              createTime?: string(name='CreateTime'),
              deleted?: boolean(name='Deleted'),
              fileName?: string(name='FileName'),
              filesize?: long(name='Filesize'),
              id?: long(name='Id'),
              modifiedTime?: string(name='ModifiedTime'),
              ossKey?: string(name='OssKey'),
              type?: string(name='Type'),
              url?: string(name='Url'),
            }
          ](name='SourceFiles'),
          token?: {
            accessKeyId?: string(name='AccessKeyId'),
            accessKeySecret?: string(name='AccessKeySecret'),
            dir?: string(name='Dir'),
            expiration?: string(name='Expiration'),
            host?: string(name='Host'),
            securityToken?: string(name='SecurityToken'),
          }(name='Token'),
        }(name='Source'),
        status?: string(name='Status'),
        title?: string(name='Title'),
        type?: string(name='Type'),
      }(name='DummyProjectInfo'),
      materialInfo?: {
        bottoms?: {
          checkStatus?: string(name='CheckStatus'),
          common?: boolean(name='Common'),
          coverUrl?: string(name='CoverUrl'),
          createTime?: string(name='CreateTime'),
          deleted?: boolean(name='Deleted'),
          ext?: string(name='Ext'),
          fileUrl?: string(name='FileUrl'),
          id?: long(name='Id'),
          intro?: string(name='Intro'),
          listStatus?: string(name='ListStatus'),
          modifiedTime?: string(name='ModifiedTime'),
          name?: string(name='Name'),
          ossKey?: string(name='OssKey'),
          previewUrl?: string(name='PreviewUrl'),
          type?: string(name='Type'),
        }(name='Bottoms'),
        clothingType?: string(name='ClothingType'),
        model?: {
          checkStatus?: string(name='CheckStatus'),
          common?: boolean(name='Common'),
          coverUrl?: string(name='CoverUrl'),
          createTime?: string(name='CreateTime'),
          deleted?: boolean(name='Deleted'),
          ext?: string(name='Ext'),
          fileUrl?: string(name='FileUrl'),
          id?: long(name='Id'),
          intro?: string(name='Intro'),
          listStatus?: string(name='ListStatus'),
          modifiedTime?: string(name='ModifiedTime'),
          name?: string(name='Name'),
          ossKey?: string(name='OssKey'),
          previewUrl?: string(name='PreviewUrl'),
          type?: string(name='Type'),
        }(name='Model'),
        shoeType?: string(name='ShoeType'),
        suit?: {
          checkStatus?: string(name='CheckStatus'),
          common?: boolean(name='Common'),
          coverUrl?: string(name='CoverUrl'),
          createTime?: string(name='CreateTime'),
          deleted?: boolean(name='Deleted'),
          ext?: string(name='Ext'),
          fileUrl?: string(name='FileUrl'),
          id?: long(name='Id'),
          intro?: string(name='Intro'),
          listStatus?: string(name='ListStatus'),
          modifiedTime?: string(name='ModifiedTime'),
          name?: string(name='Name'),
          ossKey?: string(name='OssKey'),
          previewUrl?: string(name='PreviewUrl'),
          type?: string(name='Type'),
        }(name='Suit'),
        tops?: {
          checkStatus?: string(name='CheckStatus'),
          common?: boolean(name='Common'),
          coverUrl?: string(name='CoverUrl'),
          createTime?: string(name='CreateTime'),
          deleted?: boolean(name='Deleted'),
          ext?: string(name='Ext'),
          fileUrl?: string(name='FileUrl'),
          id?: long(name='Id'),
          intro?: string(name='Intro'),
          listStatus?: string(name='ListStatus'),
          modifiedTime?: string(name='ModifiedTime'),
          name?: string(name='Name'),
          ossKey?: string(name='OssKey'),
          previewUrl?: string(name='PreviewUrl'),
          type?: string(name='Type'),
        }(name='Tops'),
      }(name='MaterialInfo'),
      subTasks?: [ 
        {
          feedback?: {
            dislikeTags?: [ int32 ](name='DislikeTags'),
            otherReason?: string(name='OtherReason'),
            projectId?: long(name='ProjectId'),
            rating?: int32(name='Rating'),
          }(name='Feedback'),
          subProjectInfo?: {
            auditStatus?: string(name='AuditStatus'),
            autoBuild?: boolean(name='AutoBuild'),
            bizUsage?: string(name='BizUsage'),
            buildDetail?: {
              completedTime?: string(name='CompletedTime'),
              createTime?: string(name='CreateTime'),
              deleted?: boolean(name='Deleted'),
              errorMessage?: string(name='ErrorMessage'),
              estimatedDuration?: long(name='EstimatedDuration'),
              id?: long(name='Id'),
              modifiedTime?: string(name='ModifiedTime'),
              runningTime?: string(name='RunningTime'),
              status?: string(name='Status'),
              submitTime?: string(name='SubmitTime'),
            }(name='BuildDetail'),
            checkStatus?: string(name='CheckStatus'),
            createMode?: string(name='CreateMode'),
            createTime?: string(name='CreateTime'),
            customSource?: string(name='CustomSource'),
            dataset?: {
              buildResultUrl?: map[string]any(name='BuildResultUrl'),
              coverUrl?: string(name='CoverUrl'),
              createTime?: string(name='CreateTime'),
              deleted?: boolean(name='Deleted'),
              errorCode?: string(name='ErrorCode'),
              errorMessage?: string(name='ErrorMessage'),
              glbModelUrl?: string(name='GlbModelUrl'),
              id?: long(name='Id'),
              modelUrl?: string(name='ModelUrl'),
              modifiedTime?: string(name='ModifiedTime'),
              originResultUrl?: string(name='OriginResultUrl'),
              ossKey?: string(name='OssKey'),
              policy?: {
                accessId?: string(name='AccessId'),
                dir?: string(name='Dir'),
                expire?: string(name='Expire'),
                host?: string(name='Host'),
                policy?: string(name='Policy'),
                signature?: string(name='Signature'),
              }(name='Policy'),
              poseUrl?: string(name='PoseUrl'),
              previewUrl?: string(name='PreviewUrl'),
            }(name='Dataset'),
            deleted?: boolean(name='Deleted'),
            dependencies?: string(name='Dependencies'),
            ext?: string(name='Ext'),
            id?: string(name='Id'),
            intro?: string(name='Intro'),
            materialCoverUrl?: string(name='MaterialCoverUrl'),
            modifiedTime?: string(name='ModifiedTime'),
            source?: {
              clothes?: [ 
                {
                  coverUrl?: string(name='CoverUrl'),
                  createTime?: string(name='CreateTime'),
                  deleted?: boolean(name='Deleted'),
                  id?: long(name='Id'),
                  modifiedTime?: string(name='ModifiedTime'),
                  name?: string(name='Name'),
                  ossKey?: string(name='OssKey'),
                  part?: string(name='Part'),
                  size?: string(name='Size'),
                  skuProps?: [ 
                    {
                      name?: string(name='Name'),
                      options?: [ string ](name='Options'),
                    }
                  ](name='SkuProps'),
                  skus?: [ 
                    {
                      color?: string(name='Color'),
                      cover?: string(name='Cover'),
                      size?: string(name='Size'),
                      status?: string(name='Status'),
                    }
                  ](name='Skus'),
                  status?: map[string]string(name='Status'),
                  type?: string(name='Type'),
                  version?: int32(name='Version'),
                }
              ](name='Clothes'),
              createTime?: string(name='CreateTime'),
              deleted?: boolean(name='Deleted'),
              id?: long(name='Id'),
              modifiedTime?: string(name='ModifiedTime'),
              ossKey?: string(name='OssKey'),
              policy?: {
                accessId?: string(name='AccessId'),
                dir?: string(name='Dir'),
                expire?: string(name='Expire'),
                host?: string(name='Host'),
                policy?: string(name='Policy'),
                signature?: string(name='Signature'),
              }(name='Policy'),
              sourceFiles?: [ 
                {
                  coverUrl?: string(name='CoverUrl'),
                  createTime?: string(name='CreateTime'),
                  deleted?: boolean(name='Deleted'),
                  fileName?: string(name='FileName'),
                  filesize?: long(name='Filesize'),
                  id?: long(name='Id'),
                  modifiedTime?: string(name='ModifiedTime'),
                  ossKey?: string(name='OssKey'),
                  type?: string(name='Type'),
                  url?: string(name='Url'),
                }
              ](name='SourceFiles'),
              token?: {
                accessKeyId?: string(name='AccessKeyId'),
                accessKeySecret?: string(name='AccessKeySecret'),
                dir?: string(name='Dir'),
                expiration?: string(name='Expiration'),
                host?: string(name='Host'),
                securityToken?: string(name='SecurityToken'),
              }(name='Token'),
            }(name='Source'),
            status?: string(name='Status'),
            title?: string(name='Title'),
            type?: string(name='Type'),
          }(name='SubProjectInfo'),
        }
      ](name='SubTasks'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PopListAITryOnJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopListAITryOnJobsResponseBody(name='body'),
}

async function popListAITryOnJobsWithOptions(request: PopListAITryOnJobsRequest, runtime: Util.RuntimeOptions): PopListAITryOnJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopListAITryOnJobs',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popListAITryOnJobs(request: PopListAITryOnJobsRequest): PopListAITryOnJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return popListAITryOnJobsWithOptions(request, runtime);
}

model PopListCommonMaterialsAllRequest {
  current?: int32(name='Current'),
  jwtToken?: string(name='JwtToken'),
  listStatus?: string(name='ListStatus'),
  name?: string(name='Name'),
  size?: int32(name='Size'),
  tags?: string(name='Tags'),
  type?: string(name='Type'),
}

model PopListCommonMaterialsAllResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      checkStatus?: string(name='CheckStatus'),
      common?: boolean(name='Common'),
      coverUrl?: string(name='CoverUrl'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      ext?: string(name='Ext'),
      fileUrl?: string(name='FileUrl'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      listStatus?: string(name='ListStatus'),
      modifiedTime?: string(name='ModifiedTime'),
      name?: string(name='Name'),
      ossKey?: string(name='OssKey'),
      previewUrl?: string(name='PreviewUrl'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopListCommonMaterialsAllResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopListCommonMaterialsAllResponseBody(name='body'),
}

async function popListCommonMaterialsAllWithOptions(request: PopListCommonMaterialsAllRequest, runtime: Util.RuntimeOptions): PopListCommonMaterialsAllResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.listStatus)) {
    query['ListStatus'] = request.listStatus;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopListCommonMaterialsAll',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popListCommonMaterialsAll(request: PopListCommonMaterialsAllRequest): PopListCommonMaterialsAllResponse {
  var runtime = new Util.RuntimeOptions{};
  return popListCommonMaterialsAllWithOptions(request, runtime);
}

model PopListFeatureToAvatarMaterialsRequest {
  current?: int32(name='Current'),
  listStatus?: string(name='ListStatus'),
  size?: int32(name='Size'),
  tags?: string(name='Tags'),
}

model PopListFeatureToAvatarMaterialsResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      checkStatus?: string(name='CheckStatus'),
      common?: boolean(name='Common'),
      coverUrl?: string(name='CoverUrl'),
      deleted?: boolean(name='Deleted'),
      ext?: string(name='Ext'),
      fileUrl?: string(name='FileUrl'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      listStatus?: string(name='ListStatus'),
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PopListFeatureToAvatarMaterialsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopListFeatureToAvatarMaterialsResponseBody(name='body'),
}

async function popListFeatureToAvatarMaterialsWithOptions(request: PopListFeatureToAvatarMaterialsRequest, runtime: Util.RuntimeOptions): PopListFeatureToAvatarMaterialsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.listStatus)) {
    body['ListStatus'] = request.listStatus;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.tags)) {
    body['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopListFeatureToAvatarMaterials',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popListFeatureToAvatarMaterials(request: PopListFeatureToAvatarMaterialsRequest): PopListFeatureToAvatarMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return popListFeatureToAvatarMaterialsWithOptions(request, runtime);
}

model PopListFeatureToAvatarProjectRequest {
  current?: int32(name='Current'),
  size?: int32(name='Size'),
  sortField?: string(name='SortField'),
  status?: string(name='Status'),
  title?: string(name='Title'),
}

model PopListFeatureToAvatarProjectResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      bizUsage?: string(name='BizUsage'),
      buildDetail?: {
        completedTime?: string(name='CompletedTime'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorMessage?: string(name='ErrorMessage'),
        estimatedDuration?: long(name='EstimatedDuration'),
        modifiedTime?: string(name='ModifiedTime'),
        runningTime?: string(name='RunningTime'),
        status?: string(name='Status'),
        submitTime?: string(name='SubmitTime'),
      }(name='BuildDetail'),
      checkStatus?: string(name='CheckStatus'),
      createMode?: string(name='CreateMode'),
      createTime?: string(name='CreateTime'),
      dataset?: {
        buildResultUrl?: map[string]any(name='BuildResultUrl'),
        coverUrl?: string(name='CoverUrl'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        glbModelUrl?: string(name='GlbModelUrl'),
        modelUrl?: string(name='ModelUrl'),
        modifiedTime?: string(name='ModifiedTime'),
        originResultUrl?: string(name='OriginResultUrl'),
        ossKey?: string(name='OssKey'),
        policy?: {
          accessId?: string(name='AccessId'),
          dir?: string(name='Dir'),
          expire?: string(name='Expire'),
          host?: string(name='Host'),
          policy?: string(name='Policy'),
          signature?: string(name='Signature'),
        }(name='Policy'),
        poseUrl?: string(name='PoseUrl'),
        previewUrl?: string(name='PreviewUrl'),
      }(name='Dataset'),
      deleted?: boolean(name='Deleted'),
      ext?: string(name='Ext'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      materialCoverUrl?: string(name='MaterialCoverUrl'),
      modifiedTime?: string(name='ModifiedTime'),
      status?: string(name='Status'),
      title?: string(name='Title'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PopListFeatureToAvatarProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopListFeatureToAvatarProjectResponseBody(name='body'),
}

async function popListFeatureToAvatarProjectWithOptions(request: PopListFeatureToAvatarProjectRequest, runtime: Util.RuntimeOptions): PopListFeatureToAvatarProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.sortField)) {
    body['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopListFeatureToAvatarProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popListFeatureToAvatarProject(request: PopListFeatureToAvatarProjectRequest): PopListFeatureToAvatarProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popListFeatureToAvatarProjectWithOptions(request, runtime);
}

model PopListLivePortraitModelScopeMaterialsRequest {
  current?: int32(name='Current'),
  size?: int32(name='Size'),
  types?: string(name='Types'),
}

model PopListLivePortraitModelScopeMaterialsResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      coverUrl?: string(name='CoverUrl'),
      ext?: string(name='Ext'),
      fileUrl?: string(name='FileUrl'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PopListLivePortraitModelScopeMaterialsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopListLivePortraitModelScopeMaterialsResponseBody(name='body'),
}

async function popListLivePortraitModelScopeMaterialsWithOptions(request: PopListLivePortraitModelScopeMaterialsRequest, runtime: Util.RuntimeOptions): PopListLivePortraitModelScopeMaterialsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.types)) {
    body['Types'] = request.types;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopListLivePortraitModelScopeMaterials',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popListLivePortraitModelScopeMaterials(request: PopListLivePortraitModelScopeMaterialsRequest): PopListLivePortraitModelScopeMaterialsResponse {
  var runtime = new Util.RuntimeOptions{};
  return popListLivePortraitModelScopeMaterialsWithOptions(request, runtime);
}

model PopListObjectCaseRequest {
  current?: int32(name='Current'),
  jwtToken?: string(name='JwtToken'),
  size?: int32(name='Size'),
}

model PopListObjectCaseResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      auditStatus?: string(name='AuditStatus'),
      autoBuild?: boolean(name='AutoBuild'),
      bizUsage?: string(name='BizUsage'),
      buildDetail?: {
        completedTime?: string(name='CompletedTime'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorMessage?: string(name='ErrorMessage'),
        estimatedDuration?: long(name='EstimatedDuration'),
        modifiedTime?: string(name='ModifiedTime'),
        runningTime?: string(name='RunningTime'),
        submitTime?: string(name='SubmitTime'),
      }(name='BuildDetail'),
      checkStatus?: string(name='CheckStatus'),
      createMode?: string(name='CreateMode'),
      createTime?: string(name='CreateTime'),
      customSource?: string(name='CustomSource'),
      dataset?: {
        buildResultUrl?: map[string]any(name='BuildResultUrl'),
        coverUrl?: string(name='CoverUrl'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorMessage?: string(name='ErrorMessage'),
        glbModelUrl?: string(name='GlbModelUrl'),
        modelUrl?: string(name='ModelUrl'),
        modifiedTime?: string(name='ModifiedTime'),
        originResultUrl?: string(name='OriginResultUrl'),
        ossKey?: string(name='OssKey'),
        policy?: {
          accessId?: string(name='AccessId'),
          dir?: string(name='Dir'),
          expire?: string(name='Expire'),
          host?: string(name='Host'),
          policy?: string(name='Policy'),
          signature?: string(name='Signature'),
        }(name='Policy'),
        poseUrl?: string(name='PoseUrl'),
        previewUrl?: string(name='PreviewUrl'),
      }(name='Dataset'),
      deleted?: boolean(name='Deleted'),
      dependencies?: string(name='Dependencies'),
      ext?: string(name='Ext'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      modifiedTime?: string(name='ModifiedTime'),
      source?: {
        clothes?: [ 
          {
            coverUrl?: string(name='CoverUrl'),
            createTime?: string(name='CreateTime'),
            deleted?: boolean(name='Deleted'),
            modifiedTime?: string(name='ModifiedTime'),
            name?: string(name='Name'),
            ossKey?: string(name='OssKey'),
            type?: string(name='Type'),
          }
        ](name='Clothes'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        modifiedTime?: string(name='ModifiedTime'),
        ossKey?: string(name='OssKey'),
        policy?: {
          accessId?: string(name='AccessId'),
          dir?: string(name='Dir'),
          expire?: string(name='Expire'),
          host?: string(name='Host'),
          policy?: string(name='Policy'),
          signature?: string(name='Signature'),
        }(name='Policy'),
        sourceFiles?: [ 
          {
            coverUrl?: string(name='CoverUrl'),
            createTime?: string(name='CreateTime'),
            deleted?: boolean(name='Deleted'),
            fileName?: string(name='FileName'),
            filesize?: long(name='Filesize'),
            modifiedTime?: string(name='ModifiedTime'),
            ossKey?: string(name='OssKey'),
            type?: string(name='Type'),
            url?: string(name='Url'),
          }
        ](name='SourceFiles'),
      }(name='Source'),
      status?: string(name='Status'),
      title?: string(name='Title'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PopListObjectCaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopListObjectCaseResponseBody(name='body'),
}

async function popListObjectCaseWithOptions(request: PopListObjectCaseRequest, runtime: Util.RuntimeOptions): PopListObjectCaseResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopListObjectCase',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popListObjectCase(request: PopListObjectCaseRequest): PopListObjectCaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return popListObjectCaseWithOptions(request, runtime);
}

model PopListObjectGenerationProjectRequest {
  current?: int32(name='Current'),
  jwtToken?: string(name='JwtToken'),
  size?: int32(name='Size'),
}

model PopListObjectGenerationProjectResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      bizUsage?: string(name='BizUsage'),
      buildDetail?: {
        completedTime?: string(name='CompletedTime'),
        errorMessage?: string(name='ErrorMessage'),
        estimatedDuration?: long(name='EstimatedDuration'),
        runningTime?: string(name='RunningTime'),
        submitTime?: string(name='SubmitTime'),
      }(name='BuildDetail'),
      dataset?: {
        buildResultUrl?: map[string]any(name='BuildResultUrl'),
      }(name='Dataset'),
      ext?: string(name='Ext'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      status?: string(name='Status'),
      title?: string(name='Title'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PopListObjectGenerationProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopListObjectGenerationProjectResponseBody(name='body'),
}

async function popListObjectGenerationProjectWithOptions(request: PopListObjectGenerationProjectRequest, runtime: Util.RuntimeOptions): PopListObjectGenerationProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopListObjectGenerationProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popListObjectGenerationProject(request: PopListObjectGenerationProjectRequest): PopListObjectGenerationProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popListObjectGenerationProjectWithOptions(request, runtime);
}

model PopListObjectProjectRequest {
  auditStatus?: string(name='AuditStatus'),
  current?: int32(name='Current'),
  customSource?: string(name='CustomSource'),
  jwtToken?: string(name='JwtToken'),
  size?: int32(name='Size'),
  sortField?: string(name='SortField'),
  status?: string(name='Status'),
  title?: string(name='Title'),
  withSource?: boolean(name='WithSource'),
}

model PopListObjectProjectResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      auditStatus?: string(name='AuditStatus'),
      autoBuild?: boolean(name='AutoBuild'),
      bizUsage?: string(name='BizUsage'),
      buildDetail?: {
        completedTime?: string(name='CompletedTime'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorMessage?: string(name='ErrorMessage'),
        estimatedDuration?: long(name='EstimatedDuration'),
        modifiedTime?: string(name='ModifiedTime'),
        runningTime?: string(name='RunningTime'),
        submitTime?: string(name='SubmitTime'),
      }(name='BuildDetail'),
      checkStatus?: string(name='CheckStatus'),
      createMode?: string(name='CreateMode'),
      createTime?: string(name='CreateTime'),
      customSource?: string(name='CustomSource'),
      dataset?: {
        buildResultUrl?: map[string]any(name='BuildResultUrl'),
        coverUrl?: string(name='CoverUrl'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorMessage?: string(name='ErrorMessage'),
        glbModelUrl?: string(name='GlbModelUrl'),
        modelUrl?: string(name='ModelUrl'),
        modifiedTime?: string(name='ModifiedTime'),
        originResultUrl?: string(name='OriginResultUrl'),
        ossKey?: string(name='OssKey'),
        policy?: {
          accessId?: string(name='AccessId'),
          dir?: string(name='Dir'),
          expire?: string(name='Expire'),
          host?: string(name='Host'),
          policy?: string(name='Policy'),
          signature?: string(name='Signature'),
        }(name='Policy'),
        poseUrl?: string(name='PoseUrl'),
        previewUrl?: string(name='PreviewUrl'),
      }(name='Dataset'),
      deleted?: boolean(name='Deleted'),
      dependencies?: string(name='Dependencies'),
      ext?: string(name='Ext'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      modifiedTime?: string(name='ModifiedTime'),
      source?: {
        clothes?: [ 
          {
            coverUrl?: string(name='CoverUrl'),
            createTime?: string(name='CreateTime'),
            deleted?: boolean(name='Deleted'),
            modifiedTime?: string(name='ModifiedTime'),
            name?: string(name='Name'),
            ossKey?: string(name='OssKey'),
            type?: string(name='Type'),
          }
        ](name='Clothes'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        modifiedTime?: string(name='ModifiedTime'),
        ossKey?: string(name='OssKey'),
        policy?: {
          accessId?: string(name='AccessId'),
          dir?: string(name='Dir'),
          expire?: string(name='Expire'),
          host?: string(name='Host'),
          policy?: string(name='Policy'),
          signature?: string(name='Signature'),
        }(name='Policy'),
        sourceFiles?: [ 
          {
            coverUrl?: string(name='CoverUrl'),
            createTime?: string(name='CreateTime'),
            deleted?: boolean(name='Deleted'),
            fileName?: string(name='FileName'),
            filesize?: long(name='Filesize'),
            modifiedTime?: string(name='ModifiedTime'),
            ossKey?: string(name='OssKey'),
            type?: string(name='Type'),
            url?: string(name='Url'),
          }
        ](name='SourceFiles'),
      }(name='Source'),
      status?: string(name='Status'),
      title?: string(name='Title'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PopListObjectProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopListObjectProjectResponseBody(name='body'),
}

async function popListObjectProjectWithOptions(request: PopListObjectProjectRequest, runtime: Util.RuntimeOptions): PopListObjectProjectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.auditStatus)) {
    body['AuditStatus'] = request.auditStatus;
  }
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.customSource)) {
    body['CustomSource'] = request.customSource;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.sortField)) {
    body['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  if (!Util.isUnset(request.withSource)) {
    body['WithSource'] = request.withSource;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopListObjectProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popListObjectProject(request: PopListObjectProjectRequest): PopListObjectProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popListObjectProjectWithOptions(request, runtime);
}

model PopListPakRenderExpressionRequest {
  current?: int32(name='Current'),
  listStatus?: string(name='ListStatus'),
  size?: int32(name='Size'),
}

model PopListPakRenderExpressionResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      coverUrl?: string(name='CoverUrl'),
      ext?: string(name='Ext'),
      fileUrl?: string(name='FileUrl'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      name?: string(name='Name'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PopListPakRenderExpressionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopListPakRenderExpressionResponseBody(name='body'),
}

async function popListPakRenderExpressionWithOptions(request: PopListPakRenderExpressionRequest, runtime: Util.RuntimeOptions): PopListPakRenderExpressionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listStatus)) {
    query['ListStatus'] = request.listStatus;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopListPakRenderExpression',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popListPakRenderExpression(request: PopListPakRenderExpressionRequest): PopListPakRenderExpressionResponse {
  var runtime = new Util.RuntimeOptions{};
  return popListPakRenderExpressionWithOptions(request, runtime);
}

model PopListTextToAvatarProjectRequest {
  current?: int32(name='Current'),
  jwtToken?: string(name='JwtToken'),
  size?: int32(name='Size'),
  sortField?: string(name='SortField'),
  status?: string(name='Status'),
  title?: string(name='Title'),
}

model PopListTextToAvatarProjectResponseBody = {
  code?: string(name='Code'),
  current?: int32(name='Current'),
  data?: [ 
    {
      autoBuild?: boolean(name='AutoBuild'),
      bizUsage?: string(name='BizUsage'),
      buildDetail?: {
        completedTime?: string(name='CompletedTime'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorMessage?: string(name='ErrorMessage'),
        estimatedDuration?: long(name='EstimatedDuration'),
        modifiedTime?: string(name='ModifiedTime'),
        runningTime?: string(name='RunningTime'),
        status?: string(name='Status'),
        submitTime?: string(name='SubmitTime'),
      }(name='BuildDetail'),
      checkStatus?: string(name='CheckStatus'),
      createMode?: string(name='CreateMode'),
      createTime?: string(name='CreateTime'),
      dataset?: {
        buildResultUrl?: map[string]any(name='BuildResultUrl'),
        createTime?: string(name='CreateTime'),
        deleted?: boolean(name='Deleted'),
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        modifiedTime?: string(name='ModifiedTime'),
        ossKey?: string(name='OssKey'),
        policy?: {
          accessId?: string(name='AccessId'),
          dir?: string(name='Dir'),
          expire?: string(name='Expire'),
          host?: string(name='Host'),
          policy?: string(name='Policy'),
          signature?: string(name='Signature'),
        }(name='Policy'),
      }(name='Dataset'),
      deleted?: boolean(name='Deleted'),
      dependencies?: string(name='Dependencies'),
      ext?: string(name='Ext'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      materialCoverUrl?: string(name='MaterialCoverUrl'),
      modifiedTime?: string(name='ModifiedTime'),
      status?: string(name='Status'),
      title?: string(name='Title'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pages?: int32(name='Pages'),
  requestId?: string(name='RequestId'),
  size?: int32(name='Size'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model PopListTextToAvatarProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopListTextToAvatarProjectResponseBody(name='body'),
}

async function popListTextToAvatarProjectWithOptions(request: PopListTextToAvatarProjectRequest, runtime: Util.RuntimeOptions): PopListTextToAvatarProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.current)) {
    body['Current'] = request.current;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.sortField)) {
    body['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopListTextToAvatarProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popListTextToAvatarProject(request: PopListTextToAvatarProjectRequest): PopListTextToAvatarProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return popListTextToAvatarProjectWithOptions(request, runtime);
}

model PopObjectProjectDetailRequest {
  jwtToken?: string(name='JwtToken'),
  projectId?: string(name='ProjectId'),
}

model PopObjectProjectDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    autoBuild?: boolean(name='AutoBuild'),
    bizUsage?: string(name='BizUsage'),
    buildDetail?: {
      completedTime?: string(name='CompletedTime'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorMessage?: string(name='ErrorMessage'),
      estimatedDuration?: long(name='EstimatedDuration'),
      modifiedTime?: string(name='ModifiedTime'),
      runningTime?: string(name='RunningTime'),
      submitTime?: string(name='SubmitTime'),
    }(name='BuildDetail'),
    checkStatus?: string(name='CheckStatus'),
    createMode?: string(name='CreateMode'),
    createTime?: string(name='CreateTime'),
    dataset?: {
      buildResultUrl?: map[string]any(name='BuildResultUrl'),
      coverUrl?: string(name='CoverUrl'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorMessage?: string(name='ErrorMessage'),
      glbModelUrl?: string(name='GlbModelUrl'),
      modelUrl?: string(name='ModelUrl'),
      modifiedTime?: string(name='ModifiedTime'),
      originResultUrl?: string(name='OriginResultUrl'),
      ossKey?: string(name='OssKey'),
      policy?: {
        accessId?: string(name='AccessId'),
        dir?: string(name='Dir'),
        expire?: string(name='Expire'),
        host?: string(name='Host'),
        policy?: string(name='Policy'),
        signature?: string(name='Signature'),
      }(name='Policy'),
      poseUrl?: string(name='PoseUrl'),
      previewUrl?: string(name='PreviewUrl'),
    }(name='Dataset'),
    deleted?: boolean(name='Deleted'),
    dependencies?: string(name='Dependencies'),
    ext?: string(name='Ext'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    modifiedTime?: string(name='ModifiedTime'),
    source?: {
      clothes?: [ 
        {
          coverUrl?: string(name='CoverUrl'),
          createTime?: string(name='CreateTime'),
          deleted?: boolean(name='Deleted'),
          modifiedTime?: string(name='ModifiedTime'),
          name?: string(name='Name'),
          ossKey?: string(name='OssKey'),
          type?: string(name='Type'),
        }
      ](name='Clothes'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      modifiedTime?: string(name='ModifiedTime'),
      ossKey?: string(name='OssKey'),
      policy?: {
        accessId?: string(name='AccessId'),
        dir?: string(name='Dir'),
        expire?: string(name='Expire'),
        host?: string(name='Host'),
        policy?: string(name='Policy'),
        signature?: string(name='Signature'),
      }(name='Policy'),
      sourceFiles?: [ 
        {
          coverUrl?: string(name='CoverUrl'),
          createTime?: string(name='CreateTime'),
          deleted?: boolean(name='Deleted'),
          fileName?: string(name='FileName'),
          filesize?: long(name='Filesize'),
          modifiedTime?: string(name='ModifiedTime'),
          ossKey?: string(name='OssKey'),
          type?: string(name='Type'),
          url?: string(name='Url'),
        }
      ](name='SourceFiles'),
    }(name='Source'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    type?: string(name='Type'),
  }(name='Data'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopObjectProjectDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopObjectProjectDetailResponseBody(name='body'),
}

async function popObjectProjectDetailWithOptions(request: PopObjectProjectDetailRequest, runtime: Util.RuntimeOptions): PopObjectProjectDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopObjectProjectDetail',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popObjectProjectDetail(request: PopObjectProjectDetailRequest): PopObjectProjectDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return popObjectProjectDetailWithOptions(request, runtime);
}

model PopObjectRetrievalRequest {
  content?: string(name='Content'),
  jwtToken?: string(name='JwtToken'),
  sourceType?: string(name='SourceType'),
  topK?: int32(name='TopK'),
}

model PopObjectRetrievalResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      coverUrl?: string(name='CoverUrl'),
      glbUrl?: string(name='GlbUrl'),
      id?: string(name='Id'),
      modelUrl?: string(name='ModelUrl'),
      previewUrl?: string(name='PreviewUrl'),
      title?: string(name='Title'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopObjectRetrievalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopObjectRetrievalResponseBody(name='body'),
}

async function popObjectRetrievalWithOptions(request: PopObjectRetrievalRequest, runtime: Util.RuntimeOptions): PopObjectRetrievalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.sourceType)) {
    body['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.topK)) {
    body['TopK'] = request.topK;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopObjectRetrieval',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popObjectRetrieval(request: PopObjectRetrievalRequest): PopObjectRetrievalResponse {
  var runtime = new Util.RuntimeOptions{};
  return popObjectRetrievalWithOptions(request, runtime);
}

model PopObjectRetrievalUploadDataRequest {
  jwtToken?: string(name='JwtToken'),
}

model PopObjectRetrievalUploadDataResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessId?: string(name='AccessId'),
    dir?: string(name='Dir'),
    expire?: string(name='Expire'),
    host?: string(name='Host'),
    policy?: string(name='Policy'),
    signature?: string(name='Signature'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopObjectRetrievalUploadDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopObjectRetrievalUploadDataResponseBody(name='body'),
}

async function popObjectRetrievalUploadDataWithOptions(request: PopObjectRetrievalUploadDataRequest, runtime: Util.RuntimeOptions): PopObjectRetrievalUploadDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PopObjectRetrievalUploadData',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popObjectRetrievalUploadData(request: PopObjectRetrievalUploadDataRequest): PopObjectRetrievalUploadDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return popObjectRetrievalUploadDataWithOptions(request, runtime);
}

model PopQueryAvatarProjectDetailRequest {
  projectId?: string(name='ProjectId'),
}

model PopQueryAvatarProjectDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    autoBuild?: boolean(name='AutoBuild'),
    bizUsage?: string(name='BizUsage'),
    buildDetail?: {
      completedTime?: string(name='CompletedTime'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorMessage?: string(name='ErrorMessage'),
      estimatedDuration?: long(name='EstimatedDuration'),
      modifiedTime?: string(name='ModifiedTime'),
      runningTime?: string(name='RunningTime'),
      status?: string(name='Status'),
      submitTime?: string(name='SubmitTime'),
    }(name='BuildDetail'),
    checkStatus?: string(name='CheckStatus'),
    createMode?: string(name='CreateMode'),
    createTime?: string(name='CreateTime'),
    dataset?: {
      buildResultUrl?: map[string]any(name='BuildResultUrl'),
      coverUrl?: string(name='CoverUrl'),
      createTime?: string(name='CreateTime'),
      deleted?: boolean(name='Deleted'),
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      glbModelUrl?: string(name='GlbModelUrl'),
      modelUrl?: string(name='ModelUrl'),
      modifiedTime?: string(name='ModifiedTime'),
      originResultUrl?: string(name='OriginResultUrl'),
      ossKey?: string(name='OssKey'),
      poseUrl?: string(name='PoseUrl'),
      previewUrl?: string(name='PreviewUrl'),
    }(name='Dataset'),
    deleted?: boolean(name='Deleted'),
    dependencies?: string(name='Dependencies'),
    ext?: string(name='Ext'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    materialCoverUrl?: string(name='MaterialCoverUrl'),
    modifiedTime?: string(name='ModifiedTime'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    type?: string(name='Type'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopQueryAvatarProjectDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopQueryAvatarProjectDetailResponseBody(name='body'),
}

async function popQueryAvatarProjectDetailWithOptions(request: PopQueryAvatarProjectDetailRequest, runtime: Util.RuntimeOptions): PopQueryAvatarProjectDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PopQueryAvatarProjectDetail',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popQueryAvatarProjectDetail(request: PopQueryAvatarProjectDetailRequest): PopQueryAvatarProjectDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return popQueryAvatarProjectDetailWithOptions(request, runtime);
}

model PopQueryLatestAvatarProjectDetailByUserRequest {
  jwtToken?: string(name='JwtToken'),
}

model PopQueryLatestAvatarProjectDetailByUserResponseBody = {
  code?: string(name='Code'),
  data?: {
    bizUsage?: string(name='BizUsage'),
    buildDetail?: {
      runningTime?: string(name='RunningTime'),
      status?: string(name='Status'),
    }(name='BuildDetail'),
    createTime?: string(name='CreateTime'),
    dataset?: {
      buildResultUrl?: map[string]any(name='BuildResultUrl'),
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
    }(name='Dataset'),
    ext?: string(name='Ext'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    status?: string(name='Status'),
    title?: string(name='Title'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopQueryLatestAvatarProjectDetailByUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopQueryLatestAvatarProjectDetailByUserResponseBody(name='body'),
}

async function popQueryLatestAvatarProjectDetailByUserWithOptions(request: PopQueryLatestAvatarProjectDetailByUserRequest, runtime: Util.RuntimeOptions): PopQueryLatestAvatarProjectDetailByUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PopQueryLatestAvatarProjectDetailByUser',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popQueryLatestAvatarProjectDetailByUser(request: PopQueryLatestAvatarProjectDetailByUserRequest): PopQueryLatestAvatarProjectDetailByUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return popQueryLatestAvatarProjectDetailByUserWithOptions(request, runtime);
}

model PopQueryLivePortraitModelScopeProjectDetailRequest {
  projectId?: string(name='ProjectId'),
}

model PopQueryLivePortraitModelScopeProjectDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    bizUsage?: string(name='BizUsage'),
    dataset?: {
      buildResultUrl?: map[string]any(name='BuildResultUrl'),
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
    }(name='Dataset'),
    ext?: string(name='Ext'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    materialCoverUrl?: string(name='MaterialCoverUrl'),
    status?: string(name='Status'),
    title?: string(name='Title'),
    type?: string(name='Type'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopQueryLivePortraitModelScopeProjectDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopQueryLivePortraitModelScopeProjectDetailResponseBody(name='body'),
}

async function popQueryLivePortraitModelScopeProjectDetailWithOptions(request: PopQueryLivePortraitModelScopeProjectDetailRequest, runtime: Util.RuntimeOptions): PopQueryLivePortraitModelScopeProjectDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PopQueryLivePortraitModelScopeProjectDetail',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popQueryLivePortraitModelScopeProjectDetail(request: PopQueryLivePortraitModelScopeProjectDetailRequest): PopQueryLivePortraitModelScopeProjectDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return popQueryLivePortraitModelScopeProjectDetailWithOptions(request, runtime);
}

model PopQueryObjectGenerationProjectDetailRequest {
  jwtToken?: string(name='JwtToken'),
  projectId?: string(name='ProjectId'),
}

model PopQueryObjectGenerationProjectDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    bizUsage?: string(name='BizUsage'),
    buildDetail?: {
      completedTime?: string(name='CompletedTime'),
      errorMessage?: string(name='ErrorMessage'),
      estimatedDuration?: long(name='EstimatedDuration'),
      runningTime?: string(name='RunningTime'),
      submitTime?: string(name='SubmitTime'),
    }(name='BuildDetail'),
    dataset?: {
      buildResultUrl?: map[string]any(name='BuildResultUrl'),
    }(name='Dataset'),
    ext?: string(name='Ext'),
    id?: string(name='Id'),
    intro?: string(name='Intro'),
    status?: string(name='Status'),
    title?: string(name='Title'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopQueryObjectGenerationProjectDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopQueryObjectGenerationProjectDetailResponseBody(name='body'),
}

async function popQueryObjectGenerationProjectDetailWithOptions(request: PopQueryObjectGenerationProjectDetailRequest, runtime: Util.RuntimeOptions): PopQueryObjectGenerationProjectDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopQueryObjectGenerationProjectDetail',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popQueryObjectGenerationProjectDetail(request: PopQueryObjectGenerationProjectDetailRequest): PopQueryObjectGenerationProjectDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return popQueryObjectGenerationProjectDetailWithOptions(request, runtime);
}

model PopRetryAITryOnTaskRequest {
  jwtToken?: string(name='JwtToken'),
  projectId?: string(name='ProjectId'),
}

model PopRetryAITryOnTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopRetryAITryOnTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopRetryAITryOnTaskResponseBody(name='body'),
}

async function popRetryAITryOnTaskWithOptions(request: PopRetryAITryOnTaskRequest, runtime: Util.RuntimeOptions): PopRetryAITryOnTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PopRetryAITryOnTask',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popRetryAITryOnTask(request: PopRetryAITryOnTaskRequest): PopRetryAITryOnTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return popRetryAITryOnTaskWithOptions(request, runtime);
}

model PopSubmitAITryOnJobRequest {
  bottomsId?: string(name='BottomsId'),
  clothingType?: string(name='ClothingType'),
  generatePictureNum?: int32(name='GeneratePictureNum'),
  jwtToken?: string(name='JwtToken'),
  modelId?: string(name='ModelId'),
  shoeType?: string(name='ShoeType'),
  suitId?: string(name='SuitId'),
  topsId?: string(name='TopsId'),
}

model PopSubmitAITryOnJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    projectId?: string(name='ProjectId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopSubmitAITryOnJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopSubmitAITryOnJobResponseBody(name='body'),
}

async function popSubmitAITryOnJobWithOptions(request: PopSubmitAITryOnJobRequest, runtime: Util.RuntimeOptions): PopSubmitAITryOnJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bottomsId)) {
    query['BottomsId'] = request.bottomsId;
  }
  if (!Util.isUnset(request.clothingType)) {
    query['ClothingType'] = request.clothingType;
  }
  if (!Util.isUnset(request.generatePictureNum)) {
    query['GeneratePictureNum'] = request.generatePictureNum;
  }
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.modelId)) {
    query['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.shoeType)) {
    query['ShoeType'] = request.shoeType;
  }
  if (!Util.isUnset(request.suitId)) {
    query['SuitId'] = request.suitId;
  }
  if (!Util.isUnset(request.topsId)) {
    query['TopsId'] = request.topsId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PopSubmitAITryOnJob',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popSubmitAITryOnJob(request: PopSubmitAITryOnJobRequest): PopSubmitAITryOnJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return popSubmitAITryOnJobWithOptions(request, runtime);
}

model PopUploadMaterialRequest {
  jwtToken?: string(name='JwtToken'),
}

model PopUploadMaterialResponseBody = {
  code?: string(name='Code'),
  data?: {
    ossKey?: string(name='OssKey'),
    policy?: {
      accessId?: string(name='AccessId'),
      dir?: string(name='Dir'),
      expire?: string(name='Expire'),
      host?: string(name='Host'),
      policy?: string(name='Policy'),
      signature?: string(name='Signature'),
    }(name='Policy'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopUploadMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopUploadMaterialResponseBody(name='body'),
}

async function popUploadMaterialWithOptions(request: PopUploadMaterialRequest, runtime: Util.RuntimeOptions): PopUploadMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PopUploadMaterial',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popUploadMaterial(request: PopUploadMaterialRequest): PopUploadMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return popUploadMaterialWithOptions(request, runtime);
}

model PopVideoSaveSourceRequest {
  jwtToken?: string(name='JwtToken'),
  projectId?: string(name='ProjectId'),
  sourceType?: string(name='SourceType'),
}

model PopVideoSaveSourceResponseBody = {
  code?: string(name='Code'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PopVideoSaveSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PopVideoSaveSourceResponseBody(name='body'),
}

async function popVideoSaveSourceWithOptions(request: PopVideoSaveSourceRequest, runtime: Util.RuntimeOptions): PopVideoSaveSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PopVideoSaveSource',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function popVideoSaveSource(request: PopVideoSaveSourceRequest): PopVideoSaveSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return popVideoSaveSourceWithOptions(request, runtime);
}

model QueryDigitalHumanProjectRequest {
  ids?: string(name='Ids'),
  jwtToken?: string(name='JwtToken'),
}

model QueryDigitalHumanProjectResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      estimatedDuration?: int32(name='EstimatedDuration'),
      fileUrl?: string(name='FileUrl'),
      id?: string(name='Id'),
      intro?: string(name='Intro'),
      runningTime?: string(name='RunningTime'),
      status?: string(name='Status'),
      subtitleUrl?: string(name='SubtitleUrl'),
      title?: string(name='Title'),
      videoLength?: int32(name='VideoLength'),
      waitingTime?: int32(name='WaitingTime'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDigitalHumanProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDigitalHumanProjectResponseBody(name='body'),
}

async function queryDigitalHumanProjectWithOptions(request: QueryDigitalHumanProjectRequest, runtime: Util.RuntimeOptions): QueryDigitalHumanProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.ids)) {
    body['Ids'] = request.ids;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryDigitalHumanProject',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDigitalHumanProject(request: QueryDigitalHumanProjectRequest): QueryDigitalHumanProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDigitalHumanProjectWithOptions(request, runtime);
}

model QueryLongTtsResultRequest {
  jobId?: string(name='JobId'),
  jwtToken?: string(name='JwtToken'),
}

model QueryLongTtsResultResponseBody = {
  code?: string(name='Code'),
  data?: {
    audioUrl?: string(name='AudioUrl'),
    duration?: float(name='Duration'),
    status?: string(name='Status'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryLongTtsResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryLongTtsResultResponseBody(name='body'),
}

async function queryLongTtsResultWithOptions(request: QueryLongTtsResultRequest, runtime: Util.RuntimeOptions): QueryLongTtsResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryLongTtsResult',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryLongTtsResult(request: QueryLongTtsResultRequest): QueryLongTtsResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryLongTtsResultWithOptions(request, runtime);
}

model QueryMotionShopVideoDetectResultRequest {
  jobId?: string(name='JobId'),
  jwtToken?: string(name='JwtToken'),
}

model QueryMotionShopVideoDetectResultResponseBody = {
  code?: string(name='Code'),
  data?: {
    detectResult?: {
      box?: [ double ](name='Box'),
      code?: int32(name='Code'),
      coverUrl?: string(name='CoverUrl'),
      message?: string(name='Message'),
      selectedFrameIndex?: int32(name='SelectedFrameIndex'),
    }(name='DetectResult'),
    status?: string(name='Status'),
    videoId?: string(name='VideoId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryMotionShopVideoDetectResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMotionShopVideoDetectResultResponseBody(name='body'),
}

async function queryMotionShopVideoDetectResultWithOptions(request: QueryMotionShopVideoDetectResultRequest, runtime: Util.RuntimeOptions): QueryMotionShopVideoDetectResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryMotionShopVideoDetectResult',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMotionShopVideoDetectResult(request: QueryMotionShopVideoDetectResultRequest): QueryMotionShopVideoDetectResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMotionShopVideoDetectResultWithOptions(request, runtime);
}

model SubmitLongTtsTaskRequest {
  content?: string(name='Content'),
  jwtToken?: string(name='JwtToken'),
  ttsVoiceId?: string(name='TtsVoiceId'),
}

model SubmitLongTtsTaskResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubmitLongTtsTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitLongTtsTaskResponseBody(name='body'),
}

async function submitLongTtsTaskWithOptions(request: SubmitLongTtsTaskRequest, runtime: Util.RuntimeOptions): SubmitLongTtsTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jwtToken)) {
    query['JwtToken'] = request.jwtToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.ttsVoiceId)) {
    body['TtsVoiceId'] = request.ttsVoiceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SubmitLongTtsTask',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitLongTtsTask(request: SubmitLongTtsTaskRequest): SubmitLongTtsTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitLongTtsTaskWithOptions(request, runtime);
}

model SubmitMotionShopTaskRequest {
  avatarId?: string(name='AvatarId'),
  jwtToken?: string(name='JwtToken'),
  title?: string(name='Title'),
  videoId?: string(name='VideoId'),
}

model SubmitMotionShopTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    taskId?: string(name='TaskId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubmitMotionShopTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitMotionShopTaskResponseBody(name='body'),
}

async function submitMotionShopTaskWithOptions(request: SubmitMotionShopTaskRequest, runtime: Util.RuntimeOptions): SubmitMotionShopTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.avatarId)) {
    body['AvatarId'] = request.avatarId;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  if (!Util.isUnset(request.videoId)) {
    body['VideoId'] = request.videoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SubmitMotionShopTask',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitMotionShopTask(request: SubmitMotionShopTaskRequest): SubmitMotionShopTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitMotionShopTaskWithOptions(request, runtime);
}

model UpdateUserEmailRequest {
  email?: string(name='Email'),
  jwtToken?: string(name='JwtToken'),
}

model UpdateUserEmailResponseBody = {
  code?: string(name='Code'),
  errorName?: string(name='ErrorName'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateUserEmailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUserEmailResponseBody(name='body'),
}

async function updateUserEmailWithOptions(request: UpdateUserEmailRequest, runtime: Util.RuntimeOptions): UpdateUserEmailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.email)) {
    body['Email'] = request.email;
  }
  if (!Util.isUnset(request.jwtToken)) {
    body['JwtToken'] = request.jwtToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUserEmail',
    version = '2023-03-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUserEmail(request: UpdateUserEmailRequest): UpdateUserEmailResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserEmailWithOptions(request, runtime);
}

