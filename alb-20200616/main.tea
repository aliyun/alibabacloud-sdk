/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('alb', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddEntriesToAclRequest {
  aclEntries?: [ 
    {
      description?: string(name='Description', description='The description of the IP entry. The description must be 2 to 256 characters in length, and can contain letters, digits, and the following special characters: , . ; / @ \\_ -.

You can add up to 20 IP entries in each call.', example='test-entry'),
      entry?: string(name='Entry', description='The CIDR block of the IP entry.

You can add up to 20 IP entries in each call.', example='10.0.1.0/24'),
    }
  ](name='AclEntries', description='The IP entries that you want to add. You can add up to 20 IP entries in each call.'),
  aclId?: string(name='AclId', description='The ACL ID.', example='nacl-hp34s2h0xx1ht4nwo****'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
}

model AddEntriesToAclResponseBody = {
  jobId?: string(name='JobId', description='The asynchronous task ID.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The request ID.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model AddEntriesToAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddEntriesToAclResponseBody(name='body'),
}

/**
  * *   Each ACL can contain IP addresses or CIDR blocks. Take note of the following limits on ACLs:
  *     *   The maximum number of IP entries that can be added to an ACL with each Alibaba Cloud account at a time: 20
  *     *   The maximum number of IP entries that each ACL can contain: 1,000
  * *   **AddEntriesToAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListAclEntries](~~213616~~) operation to query the status of the task.
  *     *   If the ACL is in the **Adding** state, the IP entries are being added.
  *     *   If the ACL is in the **Available** state, the IP entries are added.
  *
  * @param request AddEntriesToAclRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AddEntriesToAclResponse
 */
async function addEntriesToAclWithOptions(request: AddEntriesToAclRequest, runtime: Util.RuntimeOptions): AddEntriesToAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclEntries)) {
    query['AclEntries'] = request.aclEntries;
  }
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddEntriesToAcl',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   Each ACL can contain IP addresses or CIDR blocks. Take note of the following limits on ACLs:
  *     *   The maximum number of IP entries that can be added to an ACL with each Alibaba Cloud account at a time: 20
  *     *   The maximum number of IP entries that each ACL can contain: 1,000
  * *   **AddEntriesToAcl** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListAclEntries](~~213616~~) operation to query the status of the task.
  *     *   If the ACL is in the **Adding** state, the IP entries are being added.
  *     *   If the ACL is in the **Available** state, the IP entries are added.
  *
  * @param request AddEntriesToAclRequest
  * @return AddEntriesToAclResponse
 */
async function addEntriesToAcl(request: AddEntriesToAclRequest): AddEntriesToAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return addEntriesToAclWithOptions(request, runtime);
}

model AddServersToServerGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: prechecks the request, but does not add a backend server to a server group. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='sgp-atstuj3rtop****'),
  servers?: [ 
    {
      description?: string(name='Description', description='The description of the backend server. The description must be 2 to 256 characters in length and can contain letters, digits, periods (.), underscores (\\_), hyphens (-), commas (,), semicolons (;), forward slashes (/), and at signs (@). You can specify up to 40 servers in each call.', example='test'),
      port?: int32(name='Port', description='The port used by the backend server. Valid values: **1** to **65535**. You can specify up to 40 server IDs in each call.

> This parameter is required if the **ServerType** parameter is set to **Ecs**, **Eni**, **Eci**, or **Ip**. You do not need to set this parameter if **ServerType** is set to **Fc**.', example='80'),
      remoteIpEnabled?: boolean(name='RemoteIpEnabled', description='Specifies whether to enable the remote IP address feature. You can specify up to 40 server IDs in each call. Valid values:

*   **true**
*   **false**

Regions that support the remote IP address feature: China (Hangzhou), China (Shenzhen), China (Qingdao), China (Beijing), China (Zhangjiakou), China (Ulanqab), China (Shanghai), China (Chengdu), China (Guangzhou), China (Hong Kong), US (Virginia), Japan (Tokyo), UK (London), US (Silicon Valley), Germany (Frankfurt), Indonesia (Jakarta), Singapore, Malaysia (Kuala Lumpur), Australia (Sydney), and India (Mumbai).

> If **ServerType** is set to **Ip**, this parameter is available.', example='false'),
      serverId?: string(name='ServerId', description='The backend server ID. You can specify up to 40 server IDs in each call.

*   If ServerType is set to **Instance**, set the ServerId parameter to the ID of an Elastic Compute Service (ECS) instance, an elastic network interface (ENI), or an elastic container instance. These backend servers are specified by **Ecs**, **Eni**, or **Eci**.
*   If ServerType is set to **Ip**, set the ServerId parameter to an IP address specified in the server group.
*   If the backend server group is of the **Fc** type, set this parameter to the Alibaba Cloud Resource Name (ARN) of a function.', example='ecs-bp67acfmxazb4p****'),
      serverIp?: string(name='ServerIp', description='The IP address in inclusive ENI mode. You can specify up to 40 server IDs in each call.

> You do not need to set this parameter if **ServerType** is set to **Fc**.', example='192.168.1.1'),
      serverType?: string(name='ServerType', description='The type of the backend server that you want to add to the server group. You can specify up to 40 server IDs in each call. Valid values:

*   **Ecs**
*   **Eni**
*   **Eci**
*   **Ip**
*   **fc**', example='Ecs'),
      weight?: int32(name='Weight', description='The weight of the backend server. Valid values: **0** to **100**. Default value: **100**. If the weight of a backend server is set to **0**, no requests are forwarded to the backend server. You can specify up to 40 server IDs in each call.

> You do not need to set this parameter if **ServerType** is set to **Fc**.', example='100'),
    }
  ](name='Servers', description='The backend servers that you want to add to the server group. You can specify up to 40 backend servers in each call.'),
}

model AddServersToServerGroupResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous job.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The request ID.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model AddServersToServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddServersToServerGroupResponseBody(name='body'),
}

/**
  * **AddServersToServerGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background.
  * 1.  You can call the [ListServerGroups](~~213627~~) operation to query the status of a server group.
  * *   If a server group is in the **Configuring** state, it indicates that the server group is being modified.
  * *   If a server group is in the **Available** state, it indicates that the server group is running.
  * 2.  You can call the [ListServerGroupServers](~~213628~~) operation to query the status of a backend server.
  * *   If a backend server is in the **Adding** state, it indicates that the backend server is being added to a server group.
  * *   If a backend server is in the **Available** state, it indicates that the server is running.
  *
  * @param request AddServersToServerGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AddServersToServerGroupResponse
 */
async function addServersToServerGroupWithOptions(request: AddServersToServerGroupRequest, runtime: Util.RuntimeOptions): AddServersToServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.servers)) {
    query['Servers'] = request.servers;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddServersToServerGroup',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * **AddServersToServerGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background.
  * 1.  You can call the [ListServerGroups](~~213627~~) operation to query the status of a server group.
  * *   If a server group is in the **Configuring** state, it indicates that the server group is being modified.
  * *   If a server group is in the **Available** state, it indicates that the server group is running.
  * 2.  You can call the [ListServerGroupServers](~~213628~~) operation to query the status of a backend server.
  * *   If a backend server is in the **Adding** state, it indicates that the backend server is being added to a server group.
  * *   If a backend server is in the **Available** state, it indicates that the server is running.
  *
  * @param request AddServersToServerGroupRequest
  * @return AddServersToServerGroupResponse
 */
async function addServersToServerGroup(request: AddServersToServerGroupRequest): AddServersToServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addServersToServerGroupWithOptions(request, runtime);
}

model ApplyHealthCheckTemplateToServerGroupRequest {
  clientToken?: string(name='ClientToken', description='The ID of the asynchronous task.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', description='The ID of the request.', example='false'),
  healthCheckTemplateId?: string(name='HealthCheckTemplateId', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.

>  If you do not set this parameter, the system automatically uses **RequestId** as **ClientToken**. **RequestId** may be different for each API request.', example='hct-bp1qjwo61pqz3ahltv****'),
  serverGroupId?: string(name='ServerGroupId', description='Specifies whether to check the request without applying the template. Valid values:

*   **true**: checks the request without applying the template. The system checks the required parameters, request syntax, and limits. If the request fails to pass the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false** (default): sends the API request. If the request passes the check, a 2xx HTTP status code is returned and the template is applied.', example='sgp-n80wyad08u0tox****'),
}

model ApplyHealthCheckTemplateToServerGroupResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model ApplyHealthCheckTemplateToServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyHealthCheckTemplateToServerGroupResponseBody(name='body'),
}

async function applyHealthCheckTemplateToServerGroupWithOptions(request: ApplyHealthCheckTemplateToServerGroupRequest, runtime: Util.RuntimeOptions): ApplyHealthCheckTemplateToServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.healthCheckTemplateId)) {
    query['HealthCheckTemplateId'] = request.healthCheckTemplateId;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyHealthCheckTemplateToServerGroup',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyHealthCheckTemplateToServerGroup(request: ApplyHealthCheckTemplateToServerGroupRequest): ApplyHealthCheckTemplateToServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyHealthCheckTemplateToServerGroupWithOptions(request, runtime);
}

model AssociateAclsWithListenerRequest {
  aclIds?: [ string ](name='AclIds'),
  aclType?: string(name='AclType', example='White'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', example='true'),
  listenerId?: string(name='ListenerId', description='The ID of the request.', example='lsr-bp1bpn0kn908w4nbw****'),
}

model AssociateAclsWithListenerResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model AssociateAclsWithListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateAclsWithListenerResponseBody(name='body'),
}

/**
  * Specifies whether only to precheck this request. Valid values:
  * *   **true**: sends the precheck request but does not associate the ACLs with the listener. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
  * *   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.
  *
  * @param request AssociateAclsWithListenerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AssociateAclsWithListenerResponse
 */
async function associateAclsWithListenerWithOptions(request: AssociateAclsWithListenerRequest, runtime: Util.RuntimeOptions): AssociateAclsWithListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclIds)) {
    query['AclIds'] = request.aclIds;
  }
  if (!Util.isUnset(request.aclType)) {
    query['AclType'] = request.aclType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateAclsWithListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Specifies whether only to precheck this request. Valid values:
  * *   **true**: sends the precheck request but does not associate the ACLs with the listener. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
  * *   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.
  *
  * @param request AssociateAclsWithListenerRequest
  * @return AssociateAclsWithListenerResponse
 */
async function associateAclsWithListener(request: AssociateAclsWithListenerRequest): AssociateAclsWithListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateAclsWithListenerWithOptions(request, runtime);
}

model AssociateAdditionalCertificatesWithListenerRequest {
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId', description='The ID of the certificate. Only server certificates are supported.', example='cert-123'),
    }
  ](name='Certificates'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** may be different for each API request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to check the request without performing the operation. Valid values:

*   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the check, an HTTP `2xx` status code is returned and the operation is performed.', example='true'),
  listenerId?: string(name='ListenerId', description='The ID of the listener. You must specify the ID of an HTTPS listener or a QUIC listener.', example='lsr-bp1bpn0kn908w4nbw****'),
}

model AssociateAdditionalCertificatesWithListenerResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model AssociateAdditionalCertificatesWithListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateAdditionalCertificatesWithListenerResponseBody(name='body'),
}

/**
  * The **AssociateAdditionalCertificatesWithListener** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the background. You can call the [GetListenerAttribute](~~2254865~~) operation to query the status of an additional certificate:
  * *   If the HTTPS or QUIC listener is in the **Associating** state, the additional certificate is being added.
  * *   If the HTTPS or QUIC listener is in the **Associated** state, the additional certificate is added.
  *
  * @param request AssociateAdditionalCertificatesWithListenerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AssociateAdditionalCertificatesWithListenerResponse
 */
async function associateAdditionalCertificatesWithListenerWithOptions(request: AssociateAdditionalCertificatesWithListenerRequest, runtime: Util.RuntimeOptions): AssociateAdditionalCertificatesWithListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificates)) {
    query['Certificates'] = request.certificates;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateAdditionalCertificatesWithListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The **AssociateAdditionalCertificatesWithListener** operation is asynchronous. After you send a request, the system returns a request ID, but the operation is still being performed in the background. You can call the [GetListenerAttribute](~~2254865~~) operation to query the status of an additional certificate:
  * *   If the HTTPS or QUIC listener is in the **Associating** state, the additional certificate is being added.
  * *   If the HTTPS or QUIC listener is in the **Associated** state, the additional certificate is added.
  *
  * @param request AssociateAdditionalCertificatesWithListenerRequest
  * @return AssociateAdditionalCertificatesWithListenerResponse
 */
async function associateAdditionalCertificatesWithListener(request: AssociateAdditionalCertificatesWithListenerRequest): AssociateAdditionalCertificatesWithListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateAdditionalCertificatesWithListenerWithOptions(request, runtime);
}

model AttachCommonBandwidthPackageToLoadBalancerRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId', example='cbwp-bp1pzf0ym72pu3y76****'),
  clientToken?: string(name='ClientToken', description='The ID of the asynchronous task.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', example='true'),
  loadBalancerId?: string(name='LoadBalancerId', example='alb-d676fho813rmu3****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model AttachCommonBandwidthPackageToLoadBalancerResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='2EF39708-974B-5E74-AFF5-3445263035A8'),
}

model AttachCommonBandwidthPackageToLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachCommonBandwidthPackageToLoadBalancerResponseBody(name='body'),
}

/**
  * Specifies whether only to precheck the request. Valid values:
  * *   **true**: sends the precheck request but does not associate the EIP bandwidth plan with the ALB instance. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
  * *   **false** (default): sends the API request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.
  *
  * @param request AttachCommonBandwidthPackageToLoadBalancerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return AttachCommonBandwidthPackageToLoadBalancerResponse
 */
async function attachCommonBandwidthPackageToLoadBalancerWithOptions(request: AttachCommonBandwidthPackageToLoadBalancerRequest, runtime: Util.RuntimeOptions): AttachCommonBandwidthPackageToLoadBalancerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachCommonBandwidthPackageToLoadBalancer',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Specifies whether only to precheck the request. Valid values:
  * *   **true**: sends the precheck request but does not associate the EIP bandwidth plan with the ALB instance. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
  * *   **false** (default): sends the API request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.
  *
  * @param request AttachCommonBandwidthPackageToLoadBalancerRequest
  * @return AttachCommonBandwidthPackageToLoadBalancerResponse
 */
async function attachCommonBandwidthPackageToLoadBalancer(request: AttachCommonBandwidthPackageToLoadBalancerRequest): AttachCommonBandwidthPackageToLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachCommonBandwidthPackageToLoadBalancerWithOptions(request, runtime);
}

model CreateAScriptsRequest {
  AScripts?: [ 
    {
      AScriptName?: string(name='AScriptName', description='The ID of the AScript rule.', example='test'),
      enabled?: boolean(name='Enabled', example='false'),
      scriptContent?: string(name='ScriptContent', example='if and(match_re($uri, \\"^/1.txt$\\"), $arg_type) {   rewrite(concat(\\"/1.\\", $arg_type), \\"break\\") }'),
    }
  ](name='AScripts'),
  clientToken?: string(name='ClientToken', description='The ID of the asynchronous task.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='The ID of the request.', example='false'),
  listenerId?: string(name='ListenerId', description='The IDs of AScript rules.', example='lsn-6hfq3zs0x04ibn****'),
}

model CreateAScriptsResponseBody = {
  AScriptIds?: [ 
    {
      AScriptId?: string(name='AScriptId', example='as-xvq5igaa7uv6vr****'),
    }
  ](name='AScriptIds'),
  jobId?: string(name='JobId', example='5c607642-535e-4e06-9d77-df53049b****'),
  requestId?: string(name='RequestId', example='BF0FE763-9603-558F-A55B-0F4B9A3E3C02'),
}

model CreateAScriptsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAScriptsResponseBody(name='body'),
}

/**
  * Specifies whether to enable the AScript rule. Valid values:
  * *   **true**: enables the AScript rule.
  * *   **false** (default): disables the AScript rule.
  *
  * @param request CreateAScriptsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateAScriptsResponse
 */
async function createAScriptsWithOptions(request: CreateAScriptsRequest, runtime: Util.RuntimeOptions): CreateAScriptsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.AScripts)) {
    query['AScripts'] = request.AScripts;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAScripts',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Specifies whether to enable the AScript rule. Valid values:
  * *   **true**: enables the AScript rule.
  * *   **false** (default): disables the AScript rule.
  *
  * @param request CreateAScriptsRequest
  * @return CreateAScriptsResponse
 */
async function createAScripts(request: CreateAScriptsRequest): CreateAScriptsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAScriptsWithOptions(request, runtime);
}

model CreateAclRequest {
  aclName?: string(name='AclName', description='The ID of the ACL.', example='test-acl'),
  clientToken?: string(name='ClientToken', description='The ID of the asynchronous task.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='The ID of the request.', example='true'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-atstuj3rtop****'),
}

model CreateAclResponseBody = {
  aclId?: string(name='AclId', example='nacl-hp34s2h0xx1ht4nwo****'),
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model CreateAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAclResponseBody(name='body'),
}

/**
  * Specifies whether to check the request without performing the operation. Valid values:
  * *   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
  * *   **false** (default): sends the request. If the request passes the check, an HTTP 2xx status code is returned and the operation is performed.
  *
  * @param request CreateAclRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateAclResponse
 */
async function createAclWithOptions(request: CreateAclRequest, runtime: Util.RuntimeOptions): CreateAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclName)) {
    query['AclName'] = request.aclName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAcl',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Specifies whether to check the request without performing the operation. Valid values:
  * *   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
  * *   **false** (default): sends the request. If the request passes the check, an HTTP 2xx status code is returned and the operation is performed.
  *
  * @param request CreateAclRequest
  * @return CreateAclResponse
 */
async function createAcl(request: CreateAclRequest): CreateAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAclWithOptions(request, runtime);
}

model CreateHealthCheckTemplateRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a **2xx** HTTP status code is returned and the operation is performed.', example='true'),
  healthCheckCodes?: [ string ](name='HealthCheckCodes', description='The interval at which health checks are performed.

Valid values: **1 to 50**.

Default value: **2**.', example='5'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The port that is used for health checks.

Valid values: **0 to 65535**.

Default value: **0**. If you set the value to 0, the port of a backend server is used for health checks.', example='80'),
  healthCheckHost?: string(name='HealthCheckHost', description='The domain name that you want to use for the health check.

Default value: **$SERVER_IP**. The domain name must be 1 to 80 characters in length. The domain name must meet the following requirements:

*   The domain name can contain lowercase letters, digits, hyphens (-), and periods (.).
*   The domain name must contain at least one period (.) but cannot start or end with a period (.).
*   The rightmost domain label can contain only letters but cannot contain digits or hyphens (-).
*   Other fields cannot start or end with a hyphen (-).

This parameter is required only if the **HealthCheckProtocol** parameter is set to **HTTP**.', example='$_ip'),
  healthCheckHttpVersion?: string(name='HealthCheckHttpVersion', description='The HTTP version that is used for health checks.

Valid values: **HTTP 1.0** and **HTTP 1.1**.

Default value: **HTTP 1.1**.

> This parameter is valid only if the `HealthCheckProtocol` parameter is set to **HTTP**.', example='HTTP 1.0'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='The interval at which health checks are performed.

Valid values: **1 to 50**.

Default value: **2**.', example='2'),
  healthCheckMethod?: string(name='HealthCheckMethod', description='The method that you want to use for the health check. Valid values:

*   **HEAD**: By default, the ALB instance sends HEAD requests to a backend server to perform HTTP health checks.
*   **POST**: gRPC health checks automatically use the POST method.
*   **GET**: If the length of a response exceeds 8 KB, the response is truncated. However, the health check result is not affected.

> This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP** or **gRPC**.', example='HEAD'),
  healthCheckPath?: string(name='HealthCheckPath', description='The URL that is used for health checks.

It must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), percent signs (%), question marks (?), number signs (#), and ampersands (&). It can also contain the following extended characters: `_ ; ~ ! ( ) * [ ] @ $ ^ : \\" , +`. The URL must start with a forward slash (/).

> This parameter is valid only if the `HealthCheckProtocol` parameter is set to **HTTP**.', example='/test/index.html'),
  healthCheckProtocol?: string(name='HealthCheckProtocol', description='The protocol that you want to use for health checks. Valid values:

*   **HTTP** (default): To perform HTTP health checks, ALB sends HEAD or GET requests to a backend server to check whether the backend server is healthy.
*   **TCP**: To perform TCP health checks, ALB sends SYN packets to a backend server to check whether the port of the backend server is available to receive requests.
*   **gRPC**: To perform gRPC health checks, ALB sends POST or GET requests to a backend server to check whether the backend server is healthy.', example='HTTP'),
  healthCheckTemplateName?: string(name='HealthCheckTemplateName', description='The name of the health check template.

The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.', example='HealthCheckTemplate1'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', description='The timeout period of a health check. If a backend server does not respond within the specified timeout period, the backend server fails the health check.

Valid values: **1 to 300**.

Default value: **5**.

> If the value of the `HealthCheckTimeout` parameter is smaller than that of the `HealthCheckInterval` parameter, the timeout period specified by the `HealthCheckTimeout` parameter is ignored and the value of the `HealthCheckInterval` parameter is used as the timeout period.', example='5'),
  healthyThreshold?: int32(name='HealthyThreshold', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**.

Valid values: **2 to 10**.

Default value: **3**.', example='4'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**.

Valid values: **2 to 10**.

Default value: **3**.', example='4'),
}

model CreateHealthCheckTemplateResponseBody = {
  healthCheckTemplateId?: string(name='HealthCheckTemplateId', description='The ID of the health check template.', example='hct-1224334'),
  requestId?: string(name='RequestId', description='The request ID.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model CreateHealthCheckTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHealthCheckTemplateResponseBody(name='body'),
}

async function createHealthCheckTemplateWithOptions(request: CreateHealthCheckTemplateRequest, runtime: Util.RuntimeOptions): CreateHealthCheckTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.healthCheckCodes)) {
    query['HealthCheckCodes'] = request.healthCheckCodes;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckHost)) {
    query['HealthCheckHost'] = request.healthCheckHost;
  }
  if (!Util.isUnset(request.healthCheckHttpVersion)) {
    query['HealthCheckHttpVersion'] = request.healthCheckHttpVersion;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckMethod)) {
    query['HealthCheckMethod'] = request.healthCheckMethod;
  }
  if (!Util.isUnset(request.healthCheckPath)) {
    query['HealthCheckPath'] = request.healthCheckPath;
  }
  if (!Util.isUnset(request.healthCheckProtocol)) {
    query['HealthCheckProtocol'] = request.healthCheckProtocol;
  }
  if (!Util.isUnset(request.healthCheckTemplateName)) {
    query['HealthCheckTemplateName'] = request.healthCheckTemplateName;
  }
  if (!Util.isUnset(request.healthCheckTimeout)) {
    query['HealthCheckTimeout'] = request.healthCheckTimeout;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHealthCheckTemplate',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHealthCheckTemplate(request: CreateHealthCheckTemplateRequest): CreateHealthCheckTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHealthCheckTemplateWithOptions(request, runtime);
}

model CreateListenerRequest {
  caCertificates?: [ 
    {
    }
  ](name='CaCertificates', description='A list of certificates.'),
  caEnabled?: boolean(name='CaEnabled', description='Specifies whether to enable mutual authentication. Valid values:

*   **true**
*   **false** (default):', example='false'),
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId', description='The ID of the certificate. Only server certificates are supported. You can specify a maximum of 20 certificate IDs.

> This parameter is required if **ListenerProtocol** is set to **HTTPS** or **QUIC**.', example='12315790212_166f8204689_1714763408_70998****'),
    }
  ](name='Certificates', description='A list of certificates.'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='123e4567-e89b-12d3-a456-426655440000'),
  defaultActions?: [ 
    {
      forwardGroupConfig?: {
        serverGroupTuples?: [ 
          {
            serverGroupId?: string(name='ServerGroupId', description='The ID of the server group to which requests are forwarded.', example='rsp-cige6j****'),
          }
        ](name='ServerGroupTuples', description='The server group to which requests are forwarded.'),
      }(name='ForwardGroupConfig', description='Specifies the configurations of the forwarding action. You can specify a maximum of 20 configurations.'),
      type?: string(name='Type', description='The type of the action. You can specify only one action type.

Set the value to **ForwardGroup** to forward requests to multiple vServer groups.', example='ForwardGroup'),
    }
  ](name='DefaultActions', description='The actions of the forwarding rule.'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  gzipEnabled?: boolean(name='GzipEnabled', description='Specifies whether to enable `GZIP` compression to compress specific types of files. Valid values:

*   **true** (default)
*   **false**', example='true'),
  http2Enabled?: boolean(name='Http2Enabled', description='Specifies whether to enable `HTTP/2`. Valid values:

*   **true** (default)
*   **false**

> This parameter is available only when you create an HTTPS listener.', example='true'),
  idleTimeout?: int32(name='IdleTimeout', description='The timeout period of an idle connection. Unit: seconds.

Valid values: **1 to 60**.

Default value: **15**.

If no requests are received within the specified timeout period, ALB closes the current connection. When a new request is received, ALB establishes a new connection.', example='3'),
  listenerDescription?: string(name='ListenerDescription', description='The name of the listener.

The description must be 2 to 256 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), and underscores (\\_). Regular expressions are supported.', example='HTTP_80'),
  listenerPort?: int32(name='ListenerPort', description='The frontend port that is used by the ALB instance.

Valid values: **1 to 65535**.', example='80'),
  listenerProtocol?: string(name='ListenerProtocol', description='The listener protocol.

Valid values: **HTTP**, **HTTPS**, and **QUIC**.', example='HTTP'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the Application Load Balancer (ALB) instance.', example='lb-bp1o94dp5i6ea****'),
  quicConfig?: {
    quicListenerId?: string(name='QuicListenerId', description='The ID of the QUIC listener that you want to associate with the HTTPS listener. Only HTTPS listeners support this parameter. This parameter is required when **QuicUpgradeEnabled** is set to **true**.

> You must add the HTTPS listener and the QUIC listener to the same ALB instance. In addition, make sure that the QUIC listener has never been associated with another listener.', example='lsr-bp1bpn0kn908w4nbw****'),
    quicUpgradeEnabled?: boolean(name='QuicUpgradeEnabled', description='Specifies whether to enable QUIC upgrade. Valid values:

*   **true**
*   **false** (default)

> This parameter is available only when you create an HTTPS listener.', example='false'),
  }(name='QuicConfig', description='Selects a QUIC listener and associates it with the HTTPS listener of the ALB instance.'),
  requestTimeout?: int32(name='RequestTimeout', description='The timeout period of a request. Unit: seconds.

Valid values: **1 to 180**.

Default value: **60**.

If no response is received from the backend server during the request timeout period, ALB sends an `HTTP 504` error code to the client.', example='60'),
  securityPolicyId?: string(name='SecurityPolicyId', description='The ID of the security policy. System security policies and custom security policies are supported.

Default value: **tls_cipher_policy\\_1\\_0** (system security policy).

> This parameter is available only when you create an HTTPS listener.', example='tls_cipher_policy_1_0'),
  XForwardedForConfig?: {
    XForwardedForClientCertClientVerifyAlias?: string(name='XForwardedForClientCertClientVerifyAlias', description='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertClientVerifyEnabled** is set to **true**.

The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (\\_), and digits.

> This parameter is available only when you create an HTTPS listener.', example='test_client-verify-alias_123456'),
    XForwardedForClientCertClientVerifyEnabled?: boolean(name='XForwardedForClientCertClientVerifyEnabled', description='Specifies whether to use the `X-Forwarded-Clientcert-clientverify` header to retrieve the verification result of the client certificate. Valid values:

*   **true**
*   **false** (default)

> This parameter is available only when you create an HTTPS listener.', example='true'),
    XForwardedForClientCertFingerprintAlias?: string(name='XForwardedForClientCertFingerprintAlias', description='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertFingerprintEnabled** is set to **true**.

The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (\\_), and digits.

> This parameter is available only when you create an HTTPS listener.', example='test_finger-print-alias_123456'),
    XForwardedForClientCertFingerprintEnabled?: boolean(name='XForwardedForClientCertFingerprintEnabled', description='Specifies whether to use the `X-Forwarded-Clientcert-fingerprint` header to retrieve the fingerprint of the client certificate. Valid values:

*   **true**
*   **false** (default)

> This parameter is available only when you create an HTTPS listener.', example='true'),
    XForwardedForClientCertIssuerDNAlias?: string(name='XForwardedForClientCertIssuerDNAlias', description='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertIssuerDNEnabled** is set to **true**.

The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (\\_), and digits.

> This parameter is available only when you create an HTTPS listener.', example='test_issue-dn-alias_123456'),
    XForwardedForClientCertIssuerDNEnabled?: boolean(name='XForwardedForClientCertIssuerDNEnabled', description='Specifies whether to use the `X-Forwarded-Clientcert-issuerdn` header to retrieve information about the authority that issues the client certificate. Valid values:

*   **true**
*   **false** (default)

> This parameter is available only when you create an HTTPS listener.', example='true'),
    XForwardedForClientCertSubjectDNAlias?: string(name='XForwardedForClientCertSubjectDNAlias', description='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertSubjectDNEnabled** is set to **true**.

The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (\\_), and digits.

> This parameter is available only when you create an HTTPS listener.', example='test_subject-dn-alias_123456'),
    XForwardedForClientCertSubjectDNEnabled?: boolean(name='XForwardedForClientCertSubjectDNEnabled', description='Specifies whether to use the `X-Forwarded-Clientcert-subjectdn` header to retrieve information about the owner of the client certificate. Valid values:

*   **true**
*   **false** (default)

> This parameter is available only when you create an HTTPS listener.', example='true'),
    XForwardedForClientSourceIpsEnabled?: boolean(name='XForwardedForClientSourceIpsEnabled', description='Specifies whether to use the `X-Forwarded-Client-Ip` header to obtain the source IP address of the ALB instance. Valid values:

*   **true**
*   **false** (default)

> This parameter is available only when you create an HTTP, HTTPS, or QUIC listener. The feature specified by this parameter is unavailable by default. To use the feature, contact your account manager.', example='false'),
    XForwardedForClientSourceIpsTrusted?: string(name='XForwardedForClientSourceIpsTrusted', description='The trusted proxy IP address.

ALB traverses `X-Forwarded-For` backward and selects the first IP address that is not in the trusted IP address list as the real IP address of the client. The IP address is used in source IP address throttling.', example='10.1.1.0/24'),
    XForwardedForClientSrcPortEnabled?: boolean(name='XForwardedForClientSrcPortEnabled', description='Specifies whether to use the `X-Forwarded-Client-Port` header to retrieve the client port. Valid values:

*   **true**
*   **false** (default)

> This parameter is available only when you create an HTTP or HTTPS listener.', example='true'),
    XForwardedForEnabled?: boolean(name='XForwardedForEnabled', description='Specifies whether to use the `X-Forwarded-For` header to retrieve client IP addresses. Valid values:

*   **true** (default)
*   **false**

> This parameter is available only when you create an HTTP or HTTPS listener.', example='true'),
    XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled', description='Specifies whether to use the `X-Forwarded-Proto` header to retrieve the listener protocol. Valid values:

*   **true**
*   **false** (default)

> This parameter is available only when you create an HTTP, HTTPS, or QUIC listener.', example='false'),
    XForwardedForSLBIdEnabled?: boolean(name='XForwardedForSLBIdEnabled', description='Specifies whether to use the `SLB-ID` header to retrieve the ID of the CLB instance. Valid values:

*   **true**
*   **false** (default)

> This parameter is available only when you create an HTTP, HTTPS, or QUIC listener.', example='false'),
    XForwardedForSLBPortEnabled?: boolean(name='XForwardedForSLBPortEnabled', description='Specifies whether to use the `X-Forwarded-Port` header to retrieve the listener port of the ALB instance. Valid values:

*   **true**
*   **false** (default)

> This parameter is available only when you create an HTTP, HTTPS, or QUIC listener.', example='false'),
  }(name='XForwardedForConfig', description='The configuration of the XForward header.'),
}

model CreateListenerResponseBody = {
  jobId?: string(name='JobId', description='The asynchronous task ID.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  listenerId?: string(name='ListenerId', description='The listener ID.', example='lsr-bp1bpn0kn908w4nbw****'),
  requestId?: string(name='RequestId', description='The request ID.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model CreateListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateListenerResponseBody(name='body'),
}

/**
  * **CreateListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetListenerAttribute](~~214353~~) operation to query the status of the HTTP, HTTPS, or QUIC listener.
  * *   If the HTTP, HTTPS, or QUIC listener is in the **Provisioning** state, it indicates that the listener is being created.
  * *   If the HTTP, HTTPS, or QUIC listener is in the **Running** state, it indicates that the listener has been created.
  *
  * @param request CreateListenerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateListenerResponse
 */
async function createListenerWithOptions(request: CreateListenerRequest, runtime: Util.RuntimeOptions): CreateListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caCertificates)) {
    query['CaCertificates'] = request.caCertificates;
  }
  if (!Util.isUnset(request.caEnabled)) {
    query['CaEnabled'] = request.caEnabled;
  }
  if (!Util.isUnset(request.certificates)) {
    query['Certificates'] = request.certificates;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.defaultActions)) {
    query['DefaultActions'] = request.defaultActions;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.gzipEnabled)) {
    query['GzipEnabled'] = request.gzipEnabled;
  }
  if (!Util.isUnset(request.http2Enabled)) {
    query['Http2Enabled'] = request.http2Enabled;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    query['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerDescription)) {
    query['ListenerDescription'] = request.listenerDescription;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.quicConfig)) {
    query['QuicConfig'] = request.quicConfig;
  }
  if (!Util.isUnset(request.requestTimeout)) {
    query['RequestTimeout'] = request.requestTimeout;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    query['SecurityPolicyId'] = request.securityPolicyId;
  }
  if (!Util.isUnset(request.XForwardedForConfig)) {
    query['XForwardedForConfig'] = request.XForwardedForConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * **CreateListener** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetListenerAttribute](~~214353~~) operation to query the status of the HTTP, HTTPS, or QUIC listener.
  * *   If the HTTP, HTTPS, or QUIC listener is in the **Provisioning** state, it indicates that the listener is being created.
  * *   If the HTTP, HTTPS, or QUIC listener is in the **Running** state, it indicates that the listener has been created.
  *
  * @param request CreateListenerRequest
  * @return CreateListenerResponse
 */
async function createListener(request: CreateListenerRequest): CreateListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createListenerWithOptions(request, runtime);
}

model CreateLoadBalancerRequest {
  addressAllocatedMode?: string(name='AddressAllocatedMode', description='The mode used to assign IP addresses to zones of the ALB instance. Default value: Dynamic. Valid values:

*   **Fixed:** assigns a static IP address to the ALB instance.
*   **Dynamic:** dynamically assigns an IP address to each zone of the ALB instance.', example='Dynamic'),
  addressIpVersion?: string(name='AddressIpVersion', description='The protocol version. Valid values:

*   **IPv4:** IPv4.
*   **DualStack:** dual stack.', example='IPv4'),
  addressType?: string(name='AddressType', description='The type of the address of the ALB instance. Valid values:

*   **Internet:** The ALB instance uses a public IP address. The domain name of the ALB instance is resolved to the public IP address. In this case, the ALB instance can be accessed over the Internet.
*   **Intranet:** The ALB instance uses a private IP address. The domain name of the ALB instance is resolved to the private IP address. In this case, the ALB instance can be accessed over the VPC in which the ALB instance is deployed.', example='Internet'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters.

>  If you do not specify this parameter, the system uses the value of **RequestId** as the value of **ClientToken**. The value of the **RequestId** parameter may be different for each API request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  deletionProtectionEnabled?: boolean(name='DeletionProtectionEnabled', description='Specifies whether to enable deletion protection. Default value: false. Valid values:

*   **true:** enables deletion protection.
*   **false:** disables deletion protection.', example='false'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run. Default value: false. Valid values:

*   **true:** performs a dry run. The system checks the required parameters, request format, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false:** performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  loadBalancerBillingConfig?: {
    bandwidthPackageId?: string(name='BandwidthPackageId', description='The ID of the Elastic IP Address (EIP) bandwidth plan that is associated with the ALB instance if the ALB instance uses a public IP address.', example='cbwp-bp1vevu8h3ieh****'),
    payType?: string(name='PayType', description='The billing method of the ALB instance.

Set the value to **PostPay**, which specifies the pay-as-you-go billing method.', example='PostPay'),
  }(name='LoadBalancerBillingConfig', description='The configuration of the billing method of the ALB instance.'),
  loadBalancerEdition?: string(name='LoadBalancerEdition', description='The edition of the ALB instance. The features and billing rules vary based on the edition of the ALB instance. Valid values:

*   **Basic:** basic.
*   **Standard:** standard.
*   **StandardWithWaf:** WAF-enabled.', example='Standard'),
  loadBalancerName?: string(name='LoadBalancerName', description='The name of the ALB instance.

The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.', example='alb1'),
  modificationProtectionConfig?: {
    reason?: string(name='Reason', description='The reason why the configuration read-only mode is enabled. The reason must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The reason must start with a letter.

>  This parameter takes effect only when you set the `Status` parameter to **ConsoleProtection**.'),
    status?: string(name='Status', description='Specifies whether to enable the configuration read-only mode for the ALB instance. Valid values:

*   **NonProtection:** disables the configuration read-only mode. In this case, you cannot specify the ModificationProtectionReason parameter. If you specify the ModificationProtectionReason parameter, the value is cleared.
*   **ConsoleProtection:** enables the configuration read-only mode. In this case, you can specify the ModificationProtectionReason parameter.

>  If you set this parameter to **ConsoleProtection**, you cannot modify the configurations of the ALB instance in the ALB console. However, you can call API operations to modify the configurations of the ALB instance.', example='ConsoleProtection'),
  }(name='ModificationProtectionConfig', description='The configuration of the configuration read-only mode.'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-atstuj3rtop****'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC) in which you want to create the ALB instance.', example='vpc-bp1b49rqrybk45nio****'),
  zoneMappings?: [ 
    {
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch in the zone. You can specify only one vSwitch (subnet) in each zone of an ALB instance. You can specify up to 10 vSwitch IDs.', example='vsw-sersdf****'),
      zoneId?: string(name='ZoneId', description='The ID of the zone where the ALB instance is deployed. You can specify up to 10 zone IDs.

You can call the [DescribeZones](~~36064~~) operation to query the zones of the ALB instance.', example='cn-hangzhou-a'),
    }
  ](name='ZoneMappings', description='The zones and the vSwitches. You must specify at least two zones.'),
}

model CreateLoadBalancerResponseBody = {
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the ALB instance.', example='alb-o9ulmq5hgn68jk****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model CreateLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLoadBalancerResponseBody(name='body'),
}

/**
  * **CreateLoadBalancer** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetLoadBalancerAttribute](~~214362~~) operation to query the status of an ALB instance.
  * *   If an ALB instance is in the **Provisioning** state, it indicates that the ALB instance is being created.
  * *   If an ALB instance is in the **Active** state, it indicates that the ALB instance is created.
  *
  * @param request CreateLoadBalancerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateLoadBalancerResponse
 */
async function createLoadBalancerWithOptions(request: CreateLoadBalancerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addressAllocatedMode)) {
    query['AddressAllocatedMode'] = request.addressAllocatedMode;
  }
  if (!Util.isUnset(request.addressIpVersion)) {
    query['AddressIpVersion'] = request.addressIpVersion;
  }
  if (!Util.isUnset(request.addressType)) {
    query['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deletionProtectionEnabled)) {
    query['DeletionProtectionEnabled'] = request.deletionProtectionEnabled;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerBillingConfig)) {
    query['LoadBalancerBillingConfig'] = request.loadBalancerBillingConfig;
  }
  if (!Util.isUnset(request.loadBalancerEdition)) {
    query['LoadBalancerEdition'] = request.loadBalancerEdition;
  }
  if (!Util.isUnset(request.loadBalancerName)) {
    query['LoadBalancerName'] = request.loadBalancerName;
  }
  if (!Util.isUnset(request.modificationProtectionConfig)) {
    query['ModificationProtectionConfig'] = request.modificationProtectionConfig;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneMappings)) {
    query['ZoneMappings'] = request.zoneMappings;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoadBalancer',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * **CreateLoadBalancer** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetLoadBalancerAttribute](~~214362~~) operation to query the status of an ALB instance.
  * *   If an ALB instance is in the **Provisioning** state, it indicates that the ALB instance is being created.
  * *   If an ALB instance is in the **Active** state, it indicates that the ALB instance is created.
  *
  * @param request CreateLoadBalancerRequest
  * @return CreateLoadBalancerResponse
 */
async function createLoadBalancer(request: CreateLoadBalancerRequest): CreateLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerWithOptions(request, runtime);
}

model CreateRuleRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  direction?: string(name='Direction', description='The direction to which the forwarding rule is applied. Valid values:

*   **Request** (default): The forwarding rule is applied to the client requests received by ALB.
*   **Response**: The forwarding rule is applied to the responses returned by backend servers.

> Basic ALB instances do not support the **Response** value.', example='Request'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a `2xx HTTP` status code is returned and the operation is performed.', example='false'),
  listenerId?: string(name='ListenerId', description='The ID of the listener of the ALB instance.', example='lsr-bp1bpn0kn908w4nbw****'),
  priority?: int32(name='Priority', description='The priority of the forwarding rule. Valid values: **1 to 10000**. A smaller value indicates a higher priority.

> The priorities of the forwarding rules created for the same listener must be unique.', example='10'),
  ruleActions?: [ 
    {
      corsConfig?: {
        allowCredentials?: string(name='AllowCredentials', description='Specifies whether credentials can be carried in CORS requests. Valid values:

*   **on**: yes
*   **off**: no', example='on'),
        allowHeaders?: [ string ](name='AllowHeaders', description='The allowed headers for CORS requests.'),
        allowMethods?: [ string ](name='AllowMethods', description='The allowed HTTP methods for CORS requests.'),
        allowOrigin?: [ string ](name='AllowOrigin', description='The allowed origins of CORS requests.'),
        exposeHeaders?: [ string ](name='ExposeHeaders', description='The headers that can be exposed.'),
        maxAge?: long(name='MaxAge', description='The maximum cache time of dry run requests in the browser. Unit: seconds.

Valid values: **-1** to **172800**.', example='1000'),
      }(name='CorsConfig', description='The origins allowed.'),
      fixedResponseConfig?: {
        content?: string(name='Content', description='The content of the custom response. The content can be up to 1 KB in size and can contain only ASCII characters.', example='dssacav'),
        contentType?: string(name='ContentType', description='The format of the response.

Valid values: **text/plain**, **text/css**, **text/html**, **application/javascript**, and **application/json**.', example='text/plain'),
        httpCode?: string(name='HttpCode', description='The HTTP status code in the response. Valid values: **HTTP\\_2xx**, **HTTP\\_4xx**, and **HTTP\\_5xx**. **x** must be a digit.', example='HTTP_200'),
      }(name='FixedResponseConfig', description='The configuration of the custom response.'),
      forwardGroupConfig?: {
        serverGroupStickySession?: {
          enabled?: boolean(name='Enabled', description='Specifies whether to enable session persistence. Valid values:

*   **true**
*   **false** (default)', example='false'),
          timeout?: int32(name='Timeout', description='The timeout period of sessions. Unit: seconds. Valid values: **1** to **86400**. Default value: **1000**.', example='100'),
        }(name='ServerGroupStickySession', description='The configuration of session persistence for server groups.'),
        serverGroupTuples?: [ 
          {
            serverGroupId?: string(name='ServerGroupId', description='The server group to which requests are distributed.', example='sgp-k86c1ov501id6p****'),
            weight?: int32(name='Weight', description='The weight of the server group. A larger value specifies a higher weight. A server group with a higher weight receives more requests. Valid values: **0** to **100**.

*   If only one destination server group exists and you do not specify a weight, the default value **100** is used.
*   If more than one destination server group exists, you must specify weights.', example='100'),
          }
        ](name='ServerGroupTuples', description='The server groups to which requests are distributed. Each forwarding rule supports at most five server groups.'),
      }(name='ForwardGroupConfig', description='The server groups to which requests are distributed. Each forwarding rule supports at most five server groups.'),
      insertHeaderConfig?: {
        key?: string(name='Key', description='The key of the header. The key must be 1 to 40 characters in length, and can contain letters, digits, underscores (\\_), and hyphens (-). The header key specified by **InsertHeaderConfig** must be unique.

> You cannot specify the following header keys (case-insensitive): `slb-id`, `slb-ip`, `x-forwarded-for`, `x-forwarded-proto`, `x-forwarded-eip`, `x-forwarded-port`, `x-forwarded-client-srcport`, `connection`, `upgrade`, `content-length`, `transfer-encoding`, `keep-alive`, `te`, `host`, `cookie`, `remoteip`, and `authority`.', example='key'),
        value?: string(name='Value', description='The value of the header to be inserted.

*   If **ValueType** is set to **SystemDefined**, you can specify one of the following header values:

    *   **ClientSrcPort**: the client port.
    *   **ClientSrcIp**: the client IP address.
    *   **Protocol**: the request protocol (HTTP or HTTPS).
    *   **SLBId**: the ID of the ALB instance.
    *   **SLBPort**: the listening port.

*   If **ValueType** is set to **UserDefined**, you can specify a custom header value. The header value must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and lower than 127`. You can use asterisks (\\*) and question marks (?) as wildcards. The value cannot start or end with a space character.

*   If **ValueType** is set to **ReferenceHeader**, you can reference one of the request headers. The header value must be 1 to 128 characters in length, and can contain lowercase letters, digits, underscores (\\_), and hyphens (-).', example='UserDefined'),
        valueType?: string(name='ValueType', description='The type of header. Valid values:

*   **UserDefined**: a custom header
*   **ReferenceHeader**: a header that references one of the request headers
*   **SystemDefined**: a header predefined by the system', example='UserDefined'),
      }(name='InsertHeaderConfig', description='The configuration of the header to be inserted.'),
      order?: int32(name='Order', description='The priority of the action. Valid values: **1 to 50000**. A smaller value indicates a higher priority. The actions of a forwarding rule are applied in descending order of priority. This parameter is required. The priority of each action within a forwarding rule must be unique.', example='1'),
      redirectConfig?: {
        host?: string(name='Host', description='The hostname to which requests are redirected. Valid values:

*   **${host}** (default): If you set the value to ${host}, you cannot append other characters.

*   A custom value. Make sure that the custom value meets the following requirements:

    *   The hostname must be 3 to 128 characters in length, and can contain lowercase letters, digits, and the following special characters: - . \\* = ~ \\_ + \\ ^ ! $ & | ( ) \\[ ] ?.
    *   The hostname must contain at least one period (.) but cannot start or end with a period (.).
    *   The rightmost domain label can contain only letters and wildcards, and cannot contain digits or hyphens (-). The leftmost `domain label` can be an asterisk (\\*).
    *   The domain labels cannot start or end with a hyphen (-).
    *   You can use asterisks (\\*) and question marks (?) anywhere in a domain label as wildcard characters.', example='${host}'),
        httpCode?: string(name='HttpCode', description='The redirect type. Valid values: **301**, **302**, **303**, **307**, and **308**.', example='301'),
        path?: string(name='Path', description='The path to which requests are redirected. Valid values:

*   Default value: **${path}**. \\*\\*${host}**, **${protocol}**, and **${port}\\*\\* are also supported. Each variable can be specified only once. You can specify one or more of the preceding variables in each request. You can also combine them with a custom value.

*   A custom value. You must make sure that the custom value meets the following requirements:

    *   The value must be 1 to 128 characters in length, and can contain asterisks (\\*) and question marks (?) as wildcards. The value is case-sensitive.
    *   It must start with a forward slash (/) and can contain letters, digits, and the following special characters: `$ - _ .+ / & ~ @ :`. It cannot contain the following special characters: `" % # ; ! ( ) [ ] ^ , "`. You can use asterisks (\\*) and question marks (?) as wildcard characters.', example='/test'),
        port?: string(name='Port', description='The port to which requests are redirected.

*   **${port}** (default): If you set the value to ${port}, you cannot add other characters to the value.
*   You can also enter a port number. Valid values: **1 to 63335**.', example='10'),
        protocol?: string(name='Protocol', description='The redirect protocol. Valid values:

*   **${protocol}** (default): If you set the value to ${protocol}, you cannot add other characters to the value.
*   **HTTP** or **HTTPS**.

> HTTPS listeners support only HTTPS to HTTPS redirects.', example='HTTP'),
        query?: string(name='Query', description='The query string of the URL to which requests are redirected.

*   Default value: **${query}**. \\*\\*${host}**, **${protocol}**, and **${port}\\*\\* are also supported. Each variable can be specified only once. You can specify one or more of the preceding variables in each request. You can also combine them with a custom value.

*   A custom value. You must make sure that the custom value meets the following requirements:

    *   The value must be 1 to 128 characters in length.
    *   It can contain printable characters, except space characters, the special characters `# [ ] { } \\ | < > &`, and uppercase letters.', example='${query}'),
      }(name='RedirectConfig', description='The redirect configuration.

> When you configure the **RedirectConfig** action, you can use the default value only for the **httpCode** parameter. Do not use the default values for the other parameters.'),
      rewriteConfig?: {
        host?: string(name='Host', description='The hostname to which requests are redirected. Valid values:

*   **${host}** (default): If you set the value to ${host}, you cannot append other characters.

*   If you want to specify a custom value, make sure that the following requirements are met:

    *   The hostname must be 3 to 128 characters in length, and can contain lowercase letters, digits, and the following special characters: - . \\* = ~ \\_ + \\ ^ ! $ & | ( ) \\[ ] ?.
    *   The hostname must contain at least one period (.) but cannot start or end with a period (.).
    *   The rightmost domain label can contain only letters and wildcards, and cannot contain digits or hyphens (-). The leftmost `domain label` can be an asterisk (\\*).
    *   The domain labels cannot start or end with a hyphen (-). You can use asterisks (\\*) and question marks (?) anywhere in a domain label as wildcard characters.', example='www.example.com'),
        path?: string(name='Path', description='The path to which requests are redirected. Valid values:

*   Default value: **${path}**. \\*\\*${host}**, **${protocol}**, and **${port}\\*\\* are also supported. Each variable can be specified only once. You can specify one or more of the preceding variables in each request. You can also combine them with a custom value.

*   A custom value. You must make sure that the custom value meets the following requirements:

    *   The value must be 1 to 128 characters in length, and can contain asterisks (\\*) and question marks (?) as wildcards. The value is case-sensitive.
    *   It must start with a forward slash (/) and can contain letters, digits, and the following special characters: `$ - _ .+ / & ~ @ :`. It cannot contain the following special characters: `" % # ; ! ( ) [ ] ^ , "`. You can use asterisks (\\*) and question marks (?) as wildcard characters.', example='/tsdf'),
        query?: string(name='Query', description='The query string of the URL to which requests are redirected.

*   Default value: **${query}**. \\*\\*${host}**, **${protocol}**, and **${port}\\*\\* are also supported. Each variable can be specified only once. You can specify one or more of the preceding variables in each request. You can also combine them with a custom value.

*   A custom value. You must make sure that the custom value meets the following requirements:

    *   The value must be 1 to 128 characters in length.
    *   It can contain printable characters, except space characters, the special characters `# [ ] { } \\ | < > &`, and uppercase letters.', example='${query}'),
      }(name='RewriteConfig', description='The rewrite configuration.

> If multiple actions are configured within a forwarding rule, you must set **RewriteConfig** to the value of **ForwardGroup**.'),
      trafficLimitConfig?: {
        perIpQps?: int32(name='PerIpQps', description='The QPS of each IP address. Valid values: **1 to 100000**.

> If both the **QPS** and **PerIpQps** properties are specified, make sure that the value of the **QPS** property is smaller than the value of the PerIpQps property.', example='80'),
        QPS?: int32(name='QPS', description='The queries per second (QPS). Valid values: **1 to 100000**.', example='100'),
      }(name='TrafficLimitConfig', description='The action to throttle traffic.'),
      trafficMirrorConfig?: {
        mirrorGroupConfig?: {
          serverGroupTuples?: [ 
            {
              serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-00mkgijak0w4qgz9****'),
            }
          ](name='ServerGroupTuples', description='The configuration of the server group to which traffic is mirrored.'),
        }(name='MirrorGroupConfig', description='The configuration of the server group to which traffic is mirrored.'),
        targetType?: string(name='TargetType', description='The type of destination to which network traffic is mirrored. Valid values:

*   **ForwardGroupMirror**: a server group
*   **SlsMirror**: Log Service', example='ForwardGroupMirror'),
      }(name='TrafficMirrorConfig', description='The action to mirror traffic.'),
      type?: string(name='Type', description='The action type. Valid values:

*   **ForwardGroup**: forwards a request to multiple vServer groups.
*   **Redirect**: redirects a request.
*   **FixedResponse**: returns a custom response.
*   **Rewrite**: rewrites a request.
*   **InsertHeader**: inserts a header.
*   **RemoveHeaderConfig**: deletes a header.
*   **TrafficLimitConfig**: throttles network traffic.
*   **TrafficMirrorConfig**: mirrors traffic.
*   **CorsConfig**: forwards requests based on CORS.

The following action types are supported:

*   **FinalType**: the last action to be performed in a forwarding rule. Each forwarding rule can contain only one FinalType action. You can specify the **ForwardGroup**, **Redirect**, or **FixedResponse** action as the FinalType action.
*   **ExtType**: the action or the actions to be performed before the **FinalType** action. A forwarding rule can contain one or more **ExtType** actions. To specify this parameter, you must also specify **FinalType**. You can specify multiple **InsertHeader** actions or one **Rewrite** action.', example='ForwardGroup'),
    }
  ](name='RuleActions', description='The actions of the forwarding rule.

The maximum number of actions that can be specified for a forwarding rule.

*   Basic ALB instances: You can specify at most three actions for a forwarding rule.
*   Standard ALB instances: You can specify at most five actions for a forwarding rule.'),
  ruleConditions?: [ 
    {
      cookieConfig?: {
        values?: [ 
          {
            key?: string(name='Key', description='The key of the cookie.

*   The key must be 1 to 100 characters in length.
*   You can use asterisks (\\*) and question marks (?) as wildcard characters.
*   The key can contain printable characters, except uppercase letters, space characters, and the following special characters: `; # [ ] { } \\ | < > &`.', example='test'),
            value?: string(name='Value', description='The value of the cookie.

*   The value must be 1 to 100 characters in length.
*   You can use asterisks (\\*) and question marks (?) as wildcard characters.
*   The value can contain printable characters, except uppercase letters, space characters, and the following special characters: `; # [ ] { } \\ | < > &`.', example='test'),
          }
        ](name='Values', description='The cookie values.'),
      }(name='CookieConfig', description='The configurations of the cookies.'),
      headerConfig?: {
        key?: string(name='Key', description='The key of the header.

*   The key must be 1 to 40 characters in length.
*   It can contain lowercase letters, digits, hyphens (-), and underscores (\\_).
*   Cookie and Host are not supported.', example='Port'),
        values?: [ string ](name='Values', description='The value of the header.'),
      }(name='HeaderConfig', description='The configuration of the header.'),
      hostConfig?: {
        values?: [ string ](name='Values', description='The hostname.'),
      }(name='HostConfig', description='The configurations of the host.'),
      methodConfig?: {
        values?: [ string ](name='Values', description='The request methods.'),
      }(name='MethodConfig', description='The configurations of the request methods.'),
      pathConfig?: {
        values?: [ string ](name='Values', description='The path.'),
      }(name='PathConfig', description='The configurations of the URLs.'),
      queryStringConfig?: {
        values?: [ 
          {
            key?: string(name='Key', description='The key of the query string.

*   The key must be 1 to 100 characters in length.
*   You can use asterisks (\\*) and question marks (?) as wildcards. The key can contain printable characters, except uppercase letters, space characters, and the following special characters: `# [ ] { } \\ | < > &`.', example='test'),
            value?: string(name='Value', description='The value of the query string.

*   The value must be 1 to 128 characters in length.
*   It can contain printable characters, except uppercase letters, space characters, and the following special characters: `# [ ] { } \\ | < > &`. You can use asterisks (\\*) and question marks (?) as wildcard characters.', example='test'),
          }
        ](name='Values', description='The query strings.'),
      }(name='QueryStringConfig', description='The configurations of the query strings.'),
      sourceIpConfig?: {
        values?: [ string ](name='Values', description='The configuration of the source IP-based forwarding rule.'),
      }(name='SourceIpConfig', description='The configuration of the source IP-based forwarding rule. This parameter is required and takes effect only when **Type** is set to **SourceIP**.'),
      type?: string(name='Type', description='The type of forwarding rule. Valid values:

*   **Host**: Requests are distributed based on hosts.
*   **Path**: Requests are distributed based on paths.
*   **Header**: Requests are distributed based on HTTP headers.
*   **QueryString**: Requests are distributed based on query strings.
*   **Method**: Requests are distributed based on request methods.
*   **Cookie**: Requests are distributed based on cookies.
*   **SourceIp**: Requests are distributed based on source IP addresses.', example='Host'),
    }
  ](name='RuleConditions', description='The match conditions of the forwarding rule.

The maximum number of conditions supported by a forwarding rule.

*   Basic ALB instances: You can specify at most five conditions for a forwarding rule.
*   Standard ALB instances: You can specify at most 10 conditions for a forwarding rule.'),
  ruleName?: string(name='RuleName', description='The name of the forwarding rule.

*   It must be 2 to 128 characters in length.
*   It can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). It must start with a letter.', example='rule-doc'),
}

model CreateRuleResponseBody = {
  jobId?: string(name='JobId', description='The asynchronous task ID.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The request ID.', example='365F4154-92F6-4AE4-92F8-7FF34B540750'),
  ruleId?: string(name='RuleId', description='The ID of the forwarding rule.', example='rule-a3x3pg1yohq3lq****'),
}

model CreateRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRuleResponseBody(name='body'),
}

/**
  * Take note of the following limits:
  * *   When you configure the **Redirect** action, you can use the default value only for the **HttpCode** parameter. Do not use the default values for the other parameters.
  * *   If you specify the **Rewrite** action together with other actions in a forwarding rule, make sure that the **ForwardGroup** action is specified.
  * *   **CreateRule** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListRules](~~214379~~) operation to query the status of a forwarding rule.
  *     *   If a forwarding rule is in the **Provisioning** state, the forwarding rule is being created.
  *     *   If a forwarding rule is in the **Available** state, the forwarding rule is created.
  * *   You can set **RuleConditions** and **RuleActions** to add conditions and actions to a forwarding rule. The limits on conditions and actions are:
  *     *   Limits on conditions: You can specify at most 5 conditions for a basic Application Load Balancer (ALB) instance, at most 10 conditions for a standard ALB instance, and at most 10 conditions for a WAF-enabled ALB instance.
  *     *   Limits on actions: You can specify at most 3 actions for a basic ALB instance, at most 5 actions for a standard ALB instance, and at most 5 actions for a WAF-enabled ALB instance.
  *
  * @param request CreateRuleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateRuleResponse
 */
async function createRuleWithOptions(request: CreateRuleRequest, runtime: Util.RuntimeOptions): CreateRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.ruleActions)) {
    query['RuleActions'] = request.ruleActions;
  }
  if (!Util.isUnset(request.ruleConditions)) {
    query['RuleConditions'] = request.ruleConditions;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRule',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Take note of the following limits:
  * *   When you configure the **Redirect** action, you can use the default value only for the **HttpCode** parameter. Do not use the default values for the other parameters.
  * *   If you specify the **Rewrite** action together with other actions in a forwarding rule, make sure that the **ForwardGroup** action is specified.
  * *   **CreateRule** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListRules](~~214379~~) operation to query the status of a forwarding rule.
  *     *   If a forwarding rule is in the **Provisioning** state, the forwarding rule is being created.
  *     *   If a forwarding rule is in the **Available** state, the forwarding rule is created.
  * *   You can set **RuleConditions** and **RuleActions** to add conditions and actions to a forwarding rule. The limits on conditions and actions are:
  *     *   Limits on conditions: You can specify at most 5 conditions for a basic Application Load Balancer (ALB) instance, at most 10 conditions for a standard ALB instance, and at most 10 conditions for a WAF-enabled ALB instance.
  *     *   Limits on actions: You can specify at most 3 actions for a basic ALB instance, at most 5 actions for a standard ALB instance, and at most 5 actions for a WAF-enabled ALB instance.
  *
  * @param request CreateRuleRequest
  * @return CreateRuleResponse
 */
async function createRule(request: CreateRuleRequest): CreateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRuleWithOptions(request, runtime);
}

model CreateRulesRequest {
  clientToken?: string(name='ClientToken', description='The format of the response. Valid values:

*   **text/plain**
*   **text/css**
*   **text/html**
*   **application/javascript**
*   **application/json**', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='The HTTP status code in the response. Valid values: **HTTP\\_2xx**, **HTTP\\_4xx**, and **HTTP\\_5xx**. **x** must be a digit.', example='false'),
  listenerId?: string(name='ListenerId', description='The content of the custom response. The content can be up to 1 KB in size and can contain only ASCII characters.', example='lsr-bp1bpn0kn908w4nbw****'),
  rules?: [ 
    {
      direction?: string(name='Direction', description='The ID of the forwarding rule.', example='Request'),
      priority?: int32(name='Priority', description='The server group to which requests are distributed.', example='10'),
      ruleActions?: [ 
        {
          corsConfig?: {
            allowCredentials?: string(name='AllowCredentials', description='The key of the header.

*   The key must be 1 to 40 characters in length.
*   It can contain letters, digits, hyphens (-), and underscores (\\_).
*   You cannot set Cookie or Host.', example='on'),
            allowHeaders?: [ string ](name='AllowHeaders'),
            allowMethods?: [ string ](name='AllowMethods'),
            allowOrigin?: [ string ](name='AllowOrigin'),
            exposeHeaders?: [ string ](name='ExposeHeaders'),
            maxAge?: long(name='MaxAge', description='The value of the header. The header values within a forwarding rule must be unique.

*   The value must be 1 to 128 characters in length.
*   It can contain printable characters whose ASCII values are `greater than or equal to 32 and lower than 127`. You can use asterisks (\\*) and question marks (?) as wildcard characters.
*   The value cannot start or end with a space character.', example='1000'),
          }(name='CorsConfig'),
          fixedResponseConfig?: {
            content?: string(name='Content', description='The weight of the server group. A larger value indicates a higher weight. A server group with a higher weight receives more requests. Valid values: **1 to 100**. Default value: **100**.', example='dssacav'),
            contentType?: string(name='ContentType', description='Specifies whether to enable session persistence. Valid values:

*   **true**: enables session persistence.
*   **false** (default): disables session persistence.', example='text/plain'),
            httpCode?: string(name='HttpCode', description='The timeout period of sessions. Unit: seconds. Valid values: **1 to 86400**.', example='HTTP_200'),
          }(name='FixedResponseConfig'),
          forwardGroupConfig?: {
            serverGroupStickySession?: {
              enabled?: boolean(name='Enabled', description='The type of header. Valid values:

*   **UserDefined**: a custom header.
*   **ReferenceHeader**: a header that is referenced from one of the request headers.
*   **SystemDefined**: a header predefined by the system.', example='false'),
              timeout?: int32(name='Timeout', description='The priority of the action within the forwarding rule. Valid values: **1 to 50000**. A lower value indicates a higher priority. The actions of a forwarding rule are applied in descending order of priority. This parameter is required. The priority of each action within a forwarding rule must be unique. You can specify priorities for at most 20 actions.', example='2'),
            }(name='ServerGroupStickySession'),
            serverGroupTuples?: [ 
              {
                serverGroupId?: string(name='ServerGroupId', description='The name of the header to insert. The name must be 1 to 40 characters in length, and can contain letters, digits, underscores (\\_), and hyphens (-). The header names specified by **InsertHeaderConfig** must be unique.

>  You cannot set the name of the header to any of the following values (case-insensitive): `slb-id`, `slb-ip`, `x-forwarded-for`, `x-forwarded-proto`, `x-forwarded-eip`, `x-forwarded-port`, `x-forwarded-client-srcport`, `connection`, `upgrade`, `content-length`, `transfer-encoding`, `keep-alive`, `te`, `host`, `cookie`, `remoteip`, and `authority`.', example='sgp-k86c1ov501id6p****'),
                weight?: int32(name='Weight', description='The value of the header to insert.

*   If **ValueType** is set to **SystemDefined**, you can set one of the following header values:

    *   **ClientSrcPort**: the client port.
    *   **ClientSrcIp**: the client IP address.
    *   **Protocol**: the request protocol (HTTP or HTTPS).
    *   **SLBId**: the ID of the ALB instance.
    *   **SLBPort**: the listening port.

*   If **ValueType** is set to **UserDefined**, you can specify a custom header value. The header value must be 1 to 128 characters in length and can contain printable characters whose ASCII character values are `greater than or equal to 32 and lower than 127`. You can use asterisks (\\*) and question marks (?) as wildcards. The value cannot start or end with a space character.

*   If **ValueType** is set to **ReferenceHeader**, you can reference one of the request headers. The header value must be 1 to 128 characters in length, and can contain lowercase letters, digits, underscores (\\_), and hyphens (-).', example='100'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
          insertHeaderConfig?: {
            key?: string(name='Key', description='The hostname to which requests are distributed. Valid values:

*   **${host}** (default): If you set the value to ${host}, you cannot append other characters.

*   If you want to specify a custom value, make sure that the following requirements are met:

    *   The hostname must be 3 to 128 characters in length, and can contain lowercase letters, digits, hyphens (-), and periods (.). You can use asterisks (\\*) and question marks (?) as wildcard characters.
    *   The hostname must contain at least one period (.) but cannot start or end with a period (.).
    *   The rightmost domain label can contain only letters and wildcard characters. It cannot contain digits or hyphens (-).
    *   The domain labels cannot start or end with a hyphen (-).
    *   You can use asterisks (\\*) and question marks (?) as wildcards anywhere in a domain label.', example='key'),
            value?: string(name='Value', description='The HTTP status code that indicates the redirect type. Valid values: **301**, **302**, **303**, **307**, and **308**.', example='UserDefined'),
            valueType?: string(name='ValueType', description='The path to which requests are redirected. Valid values:

*   Default value: **${path}**. **${host}**, **${protocol}**, and **${port}** are also supported. Each variable cannot be specified more than once. You can specify one or more of the preceding variables in each request. You can also combine them with the following characters.

*   If you want to specify a custom value, make sure that the following requirements are met:

    *   The value is 1 to 128 characters in length.
    *   It must start with a forward slash (/) and can contain letters, digits, and the following special characters: `$ - _ .+ / & ~ @ :`. It cannot contain the following special characters: `" % # ; ! ( ) [ ]^ , "`. You can use asterisks (\\*) and question marks (?) as wildcards.
    *   The value is case-sensitive.', example='UserDefined'),
          }(name='InsertHeaderConfig'),
          order?: int32(name='Order', description='The port to which requests are redirected.

*   **${port}** (default): If you set the value to ${port}, you cannot append other characters.
*   You can also enter a port number. Valid values: **1 to 63335**.', example='1'),
          redirectConfig?: {
            host?: string(name='Host', description='The redirect protocol. Valid values:

*   **${protocol}** (default): If you set the value to ${protocol}, you cannot append other characters.
*   You can set the protocol to **HTTP** or **HTTPS**.

>  HTTPS listeners do not support HTTPS-to-HTTP redirects.', example='www.example.com'),
            httpCode?: string(name='HttpCode', description='The query string of the URL to which requests are redirected.

*   Default value: **${query}**. **${host}**, **${protocol}**, and **${port}** are also supported. Each variable cannot be specified more than once. You can specify one or more of the preceding variables in each request. You can also combine them with the following characters.

*   If you want to specify a custom value, make sure that the following requirements are met:

    *   The value is 1 to 128 characters in length.
    *   It can contain printable characters, except space characters, the special characters `# [ ] { } \\ | < > &`, and uppercase letters.', example='301'),
            path?: string(name='Path', description='The hostname to which requests are redirected. Valid values:

*   **${host}** (default): If you set the value to ${host}, you cannot append other characters.

*   If you want to specify a custom value, make sure that the following requirements are met:

    *   The hostname must be 3 to 128 characters in length, and can contain lowercase letters, digits, hyphens (-), and periods (.). You can use asterisks (\\*) and question marks (?) as wildcard characters.
    *   The hostname must contain at least one period (.) but cannot start or end with a period (.).
    *   The rightmost domain label can contain only letters and wildcard characters. It cannot contain digits or hyphens (-).
    *   The domain labels cannot start or end with a hyphen (-). You can use an asterisk (\\*) and question mark (?) as wildcards anywhere in a domain label.', example='/test'),
            port?: string(name='Port', description='The path to which requests are redirected. Valid values:

*   Default value: **${path}**. **${host}**, **${protocol}**, and **${port}** are also supported. Each variable cannot be specified more than once. You can specify one or more of the preceding variables in each request. You can also combine them with the following characters.

*   If you want to specify a custom value, make sure that the following requirements are met:

    *   The value is 1 to 128 characters in length.
    *   It must start with a forward slash (/) and can contain letters, digits, and the following special characters: `$ - _ .+ / & ~ @ :`. It cannot contain the following special characters: `" % # ; ! ( ) [ ]^ , "`. You can use asterisks (\\*) and question marks (?) as wildcards.
    *   The value is case-sensitive.', example='10'),
            protocol?: string(name='Protocol', description='The query string of the URL to which requests are redirected.

*   Default value: **${query}**. **${host}**, **${protocol}**, and **${port}** are also supported. Each variable cannot be specified more than once. You can specify one or more of the preceding variables in each request. You can also combine them with the following characters.

*   If you want to specify a custom value, make sure that the following requirements are met:

    *   The value is 1 to 128 characters in length.
    *   It can contain printable characters, except space characters, the special characters `# [ ] { } \\ | < > &`, and uppercase letters.', example='HTTP'),
            query?: string(name='Query', description='The action type. You can specify at most 11 types of action. Valid values:

*   **ForwardGroup**: forwards a request to multiple vServer groups.
*   **Redirect**: redirects a request.
*   **FixedResponse**: returns a custom response.
*   **Rewrite**: rewrites a request.
*   **InsertHeader**: inserts a header.
*   **RemoveHeaderConfig**: deletes a header.
*   **TrafficLimitConfig**: throttles network traffic.
*   **TrafficMirrorConfig**: mirrors network traffic.
*   **CORS**: enables cross-origin resource sharing (CORS).

You can specify the last action and the actions that you want to perform before the last action:

*   **FinalType**: the last action to be performed in a forwarding rule. Each forwarding rule can contain only one FinalType action. You can specify a **ForwardGroup**, **Redirect**, or **FixedResponse** action as the FinalType action.
*   **ExtType**: the action to be performed before the FinalType action. A forwarding rule can contain one or more ExtType actions. To specify this parameter, you must also specify FinalType. You can specify multiple **InsertHeader** actions or one **Rewrite** action.', example='quert'),
          }(name='RedirectConfig'),
          rewriteConfig?: {
            host?: string(name='Host', description='Queries per second (QPS). Valid values: **1 to 100000**.', example='www.example.com'),
            path?: string(name='Path', description='The QPS of each IP address. Valid values: **1 to 100000**.

>  If **QPS** and PerIpQps are configured at the same time, the value of the **PerIpQps** parameter must be smaller than that of the **QPS** parameter.', example='/tsdf'),
            query?: string(name='Query', description='The type of destination to which network traffic is mirrored. Valid values:

*   **ForwardGroupMirror**: a server group.
*   **SlsMirror**: Log Service.', example='quedsa'),
          }(name='RewriteConfig'),
          trafficLimitConfig?: {
            perIpQps?: int32(name='PerIpQps', description='The allowed HTTP methods for CORS requests. Valid values:

*   **GET**
*   **POST**
*   **PUT**
*   **DELETE**
*   **HEAD**
*   **OPTIONS**
*   **PATCH**', example='80'),
            QPS?: int32(name='QPS', description='The origin site that is allowed to access. You can specify an asterisk (`*`) or one or more values. The value cannot be an asterisk (`*`).

*   The value must start with `http://` or `https://` and include a valid domain name or top-level wildcard domain name, such as `*.test.abc.example.com`.
*   You can choose to include a port number from **1** to **65535** in each value based on your business requirement.', example='100'),
          }(name='TrafficLimitConfig'),
          trafficMirrorConfig?: {
            mirrorGroupConfig?: {
              serverGroupTuples?: [ 
                {
                  serverGroupId?: string(name='ServerGroupId', description='The headers that are allowed to expose. You can specify an asterisk (`*`) or one or more values. Separate multiple values with commas (,). The value must be 1 to 32 characters in length, and can contain letters and digits. The value cannot start or end with an underscore (\\_) or hyphen (-).', example='srg-00mkgijak0w4qgz9****'),
                }
              ](name='ServerGroupTuples'),
            }(name='MirrorGroupConfig'),
            targetType?: string(name='TargetType', description='The allowed headers for CORS requests. You can specify an asterisk (`*`) or one or more values. Separate multiple values with commas (,). The value must be 1 to 32 characters in length, and can contain letters and digits. The value cannot start or end with an underscore (\\_) or hyphen (-).', example='ForwardGroupMirror'),
          }(name='TrafficMirrorConfig'),
          type?: string(name='Type', description='The ID of the vServer group.', example='ForwardGroup'),
        }
      ](name='RuleActions'),
      ruleConditions?: [ 
        {
          cookieConfig?: {
            values?: [ 
              {
                key?: string(name='Key', description='The hostname. A forwarding rule can contain only one unique hostname.

*   The hostname must be 3 to 128 characters in length, and can contain lowercase letters, digits, hyphens (-), periods (.), asterisks (\\*), and question marks (?).
*   The hostname must contain at least one period (.) but cannot start or end with a period (.).
*   The rightmost domain label can contain only letters and wildcard characters. It cannot contain digits or hyphens (-).
*   The domain labels do not start or end with hyphens (-). You can use an asterisk (\\*) and question mark (?) as wildcards anywhere in a domain label.', example='test'),
                value?: string(name='Value', description='The request methods. Valid values: **HEAD**, **GET**, **POST**, **OPTIONS**, **PUT**, **PATCH**, and **DELETE**.', example='test'),
              }
            ](name='Values'),
          }(name='CookieConfig'),
          headerConfig?: {
            key?: string(name='Key', description='The path to which requests are forwarded. Limits:

*   The path must be 1 to 128 characters in length.
*   It must start with a forward slash (/) and can contain letters, digits, and the following special characters: `$ - _ .+ / & ~ @ :`. It cannot contain the following special characters: `" % # ; ! ( ) [ ]^ , "`. You can use asterisks (\\*) and question marks (?) as wildcards.
*   The value is case-sensitive.', example='Port'),
            values?: [ string ](name='Values'),
          }(name='HeaderConfig'),
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
          methodConfig?: {
            values?: [ string ](name='Values'),
          }(name='MethodConfig'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          queryStringConfig?: {
            values?: [ 
              {
                key?: string(name='Key', description='The type of forwarding rule. You can specify at most seven types. Valid values:

*   **Host**: Requests are forwarded based on hosts.
*   **Path**: Requests are forwarded based on paths.
*   **Header**: Requests are forwarded based on HTTP headers.
*   **QueryString**: Requests are forwarded based on query strings.
*   **Method**: Requests are forwarded based on request methods.
*   **Cookie**: Requests are forwarded based on cookies.
*   **SourceIp**: Requests are forwarded based on source IP addresses.', example='test'),
                value?: string(name='Value', description='The IP addresses or CIDR blocks.

You can specify at most five values for **SourceIp**.', example='test'),
              }
            ](name='Values'),
          }(name='QueryStringConfig'),
          responseHeaderConfig?: {
            key?: string(name='Key', description='The name of the forwarding rule. You can name at most 20 forwarding rules.

*   The name must be 2 to 128 characters in length.
*   It can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). It must start with a letter.', example='Port'),
            values?: [ string ](name='Values'),
          }(name='ResponseHeaderConfig'),
          sourceIpConfig?: {
            values?: [ string ](name='Values'),
          }(name='SourceIpConfig'),
          type?: string(name='Type', description='The ID of the asynchronous task.', example='Host'),
        }
      ](name='RuleConditions'),
      ruleName?: string(name='RuleName', description='The list of forwarding rules.', example='test'),
    }
  ](name='Rules'),
}

model CreateRulesResponseBody = {
  jobId?: string(name='JobId', description='The priority of the forwarding rule. Valid values: **1 to 10000**. A smaller value indicates a higher priority.

>  The priority of each forwarding rule added to a listener is unique.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
  ruleIds?: [ 
    {
      priority?: int32(name='Priority', example='10'),
      ruleId?: string(name='RuleId', example='rule-a3x3pg1yohq3lq****'),
    }
  ](name='RuleIds'),
}

model CreateRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRulesResponseBody(name='body'),
}

/**
  * Specifies whether to precheck the request without performing the operation. Valid values:
  * *   **true**: prechecks the request but does not create the forwarding rule. The system checks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
  * *   **false** (default): sends the request. If the request passes the precheck, the system returns an `HTTP 2xx` status code and creates the forwarding rule.
  *
  * @param request CreateRulesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateRulesResponse
 */
async function createRulesWithOptions(request: CreateRulesRequest, runtime: Util.RuntimeOptions): CreateRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.rules)) {
    query['Rules'] = request.rules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRules',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Specifies whether to precheck the request without performing the operation. Valid values:
  * *   **true**: prechecks the request but does not create the forwarding rule. The system checks the required parameters, request syntax, and limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
  * *   **false** (default): sends the request. If the request passes the precheck, the system returns an `HTTP 2xx` status code and creates the forwarding rule.
  *
  * @param request CreateRulesRequest
  * @return CreateRulesResponse
 */
async function createRules(request: CreateRulesRequest): CreateRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRulesWithOptions(request, runtime);
}

model CreateSecurityPolicyRequest {
  ciphers?: [ string ](name='Ciphers', description='The supported cipher suites, which are determined by the TLS protocol version.****

The specified cipher suites must be supported by at least one TLS protocol version that you specify.****

>  For example, if you set the TLSVersions parameter to TLSv1.3, you must specify cipher suites that are supported by TLS 1.3.

*   TLS 1.0 and TLS 1.1 support the following cipher suites:

    *   ECDHE-ECDSA-AES128-SHA
    *   ECDHE-ECDSA-AES256-SHA
    *   ECDHE-RSA-AES128-SHA
    *   ECDHE-RSA-AES256-SHA
    *   AES128-SHA
    *   AES256-SHA
    *   DES-CBC3-SHA

*   TLS 1.2 supports the following cipher suites:

    *   ECDHE-ECDSA-AES128-SHA
    *   ECDHE-ECDSA-AES256-SHA
    *   ECDHE-RSA-AES128-SHA
    *   ECDHE-RSA-AES256-SHA
    *   AES128-SHA
    *   AES256-SHA
    *   DES-CBC3-SHA
    *   ECDHE-ECDSA-AES128-GCM-SHA256
    *   ECDHE-ECDSA-AES256-GCM-SHA384
    *   ECDHE-ECDSA-AES128-SHA256
    *   ECDHE-ECDSA-AES256-SHA384
    *   ECDHE-RSA-AES128-GCM-SHA256
    *   ECDHE-RSA-AES256-GCM-SHA384
    *   ECDHE-RSA-AES128-SHA256
    *   ECDHE-RSA-AES256-SHA384
    *   AES128-GCM-SHA256
    *   AES256-GCM-SHA384
    *   AES128-SHA256
    *   AES256-SHA256

*   TLS 1.3 supports the following cipher suites:

    *   TLS_AES\\_128\\_GCM_SHA256
    *   TLS_AES\\_256\\_GCM_SHA384
    *   TLS_CHACHA20\\_POLY1305\\_SHA256
    *   TLS_AES\\_128\\_CCM_SHA256
    *   TLS_AES\\_128\\_CCM\\_8\\_SHA256'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The ID of each request is unique.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  dryRun?: boolean(name='DryRun', description='Specifies whether only to precheck the request. Valid values:

*   **true**: only prechecks the request and does not perform the requested operation. The system checks the required parameters, request format, and service limits. If the request fails the precheck, an error code is returned based on the cause of the failure. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false**: prechecks the request and performs the requested operation. After the request passes the precheck, an HTTP 2xx status code is returned and the system performs the operation. This is the default value.', example='true'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-atstuj3rtop****'),
  securityPolicyName?: string(name='SecurityPolicyName', description='The name of the security policy.

The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.', example='test-secrity'),
  TLSVersions?: [ string ](name='TLSVersions', description='The supported versions of the Transport Layer Security (TLS) protocol. Valid values: **TLSv1.0**, **TLSv1.1**, **TLSv1.2**, and **TLSv1.3**.'),
}

model CreateSecurityPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  securityPolicyId?: string(name='SecurityPolicyId', description='The ID of the security policy.', example='scp-bp1bpn0kn9****'),
}

model CreateSecurityPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSecurityPolicyResponseBody(name='body'),
}

async function createSecurityPolicyWithOptions(request: CreateSecurityPolicyRequest, runtime: Util.RuntimeOptions): CreateSecurityPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ciphers)) {
    query['Ciphers'] = request.ciphers;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityPolicyName)) {
    query['SecurityPolicyName'] = request.securityPolicyName;
  }
  if (!Util.isUnset(request.TLSVersions)) {
    query['TLSVersions'] = request.TLSVersions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSecurityPolicy',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSecurityPolicy(request: CreateSecurityPolicyRequest): CreateSecurityPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSecurityPolicyWithOptions(request, runtime);
}

model CreateServerGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
  healthCheckConfig?: {
    healthCheckCodes?: [ string ](name='HealthCheckCodes', description='The HTTP status codes that are used to determine whether the backend server passes the health check.'),
    healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The port that you want to use for health checks on backend servers.

Valid values: **0** to **65535**.

Default value: **0**. If you set the value to 0, the port of a backend server is used for health checks.', example='80'),
    healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='Indicates whether the health check feature is enabled. Valid values:

*   **true**
*   **false**

> If the **ServerGroupType** parameter is set to **Instance** or **Ip**, the health check feature is enabled by default. If the **ServerGroupType** parameter is set to **Fc**, the health check feature is disabled by default.', example='true'),
    healthCheckHost?: string(name='HealthCheckHost', description='The domain name that is used for health checks. The domain name must meet the following requirements:

*   The domain name must be 1 to 80 characters in length.
*   The domain name can contain lowercase letters, digits, hyphens (-), and periods (.).
*   It must contain at least one period (.) but cannot start or end with a period (.).
*   The rightmost domain label of the domain name can contain only letters, and cannot contain digits or hyphens (-).
*   The domain name cannot start or end with a hyphen (-).

> This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP**.', example='www.example.com'),
    healthCheckHttpVersion?: string(name='HealthCheckHttpVersion', description='The HTTP version. Valid values: **HTTP1.0** and **HTTP1.1**. Default value: HTTP1.1.

> This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP**.', example='HTTP1.1'),
    healthCheckInterval?: int32(name='HealthCheckInterval', description='The interval at which health checks are performed. Unit: seconds.

Valid values: **1** to **50**.

Default value: **2**.', example='2'),
    healthCheckMethod?: string(name='HealthCheckMethod', description='The HTTP method that is used for health checks. Valid values:

*   **GET**: If the length of a response exceeds 8 KB, the response is truncated. However, the health check result is not affected.
*   **POST**: gRPC health checks automatically use the POST method.
*   **HEAD**: By default, HTTP health checks use the HEAD method.

> This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP** or **gRPC**.', example='HEAD'),
    healthCheckPath?: string(name='HealthCheckPath', description='The path that is used for health checks.

The path must be 1 to 80 characters in length and can contain only letters, digits, and the following special characters: `- / . % ? # & =`. It can also contain the following extended characters: `_ ; ~ ! ( ) * [ ] @ $ ^ : \\" , +`. The URL must start with a forward slash (/).

> This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP**.', example='/test/index.html'),
    healthCheckProtocol?: string(name='HealthCheckProtocol', description='The protocol that is used for health checks. Valid values:

*   **HTTP**: To perform HTTP health checks, Application Load Balancer (ALB) sends HEAD or GET requests to a backend server to check whether the backend server is healthy.
*   **HTTPS**: To perform HTTPS health checks, ALB sends SYN packets to a backend server to check whether the port of the backend server is available to receive requests.
*   **gRPC**: To perform gRPC health checks, ALB sends POST or GET requests to a backend server to check whether the backend server is healthy.', example='HTTP'),
    healthCheckTimeout?: int32(name='HealthCheckTimeout', description='Specify the timeout period of a health check response. If a backend server, such as an Elastic Compute Service (ECS) instance, does not return a health check response within the specified timeout period, the server fails the health check. Unit: seconds.

Valid values: **1** to **300**.

Default value: **5**.

> If the value of the **HealthCheckTimeout** parameter is smaller than that of the **HealthCheckInterval** parameter, the timeout period specified by the **HealthCheckTimeout** parameter is ignored and the value of the **HealthCheckInterval** parameter is used as the timeout period.', example='5'),
    healthyThreshold?: int32(name='HealthyThreshold', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**.

Valid values: **2** to **10**.

Default value: **3**.', example='3'),
    unhealthyThreshold?: int32(name='UnhealthyThreshold', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**.

Valid values: **2** to **10**.

Default value: **3**.', example='3'),
  }(name='HealthCheckConfig', description='The configuration of health checks.'),
  protocol?: string(name='Protocol', description='The backend protocol. Valid values:

*   **HTTP** (default): The server group can be associated with HTTPS, HTTP, and QUIC listeners.
*   **HTTPS**: The server group can be associated with HTTPS listeners.
*   **gRPC**: The server group can be associated with HTTPS and QUIC listeners.

> If the **ServerGroupType** parameter is set to **Fc**, you can set Protocol only to **HTTP**.', example='HTTP'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-atstuj3rtop****'),
  scheduler?: string(name='Scheduler', description='The scheduling algorithm. Valid values:

*   **Wrr** (default): The weighted round-robin algorithm is used. Backend servers that have higher weights receive more requests than those that have lower weights.
*   **Wlc**: The weighted least connections algorithm is used. Requests are distributed based on the weights and the number of connections to backend servers. If two backend servers have the same weight, the backend server that has fewer connections is expected to receive more requests.
*   **Sch**: The consistent hashing algorithm is used. Requests from the same source IP address are distributed to the same backend server.

> This parameter takes effect when the **ServerGroupType** parameter is set to **Instance** or **Ip**.', example='Wrr'),
  serverGroupName?: string(name='ServerGroupName', description='The name of the server group. The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.', example='sg-atstuj3rtoptyui****'),
  serverGroupType?: string(name='ServerGroupType', description='The type of server group. Valid values:

*   **Instance** (default): allows you to add servers by specifying **Ecs**, **Ens**, or **Eci**.
*   **Ip**: allows you to add servers by specifying IP addresses.
*   **Fc**: allows you to add servers by specifying functions of Function Compute.', example='Instance'),
  serviceName?: string(name='ServiceName', description='This parameter is available only if the ALB Ingress controller is used. In this case, set this parameter to the name of the `Kubernetes Service` that is associated with the server group.', example='test'),
  stickySessionConfig?: {
    cookie?: string(name='Cookie', description='The cookie to be configured on the server.

The cookie must be 1 to 200 characters in length and can contain only ASCII characters and digits. It cannot contain commas (,), semicolons (;), or space characters. It cannot start with a dollar sign ($).

> This parameter takes effect when the **StickySessionEnabled** parameter is set to **true** and the **StickySessionType** parameter is set to **Server**.', example='B490B5EBF6F3CD402E515D22BCDA****'),
    cookieTimeout?: int32(name='CookieTimeout', description='The timeout period of a cookie. Unit: seconds.

Valid values: **1** to **86400**.

Default value: **1000**.

> This parameter takes effect only when the **StickySessionEnabled** parameter is set to **true** and the **StickySessionType** parameter is set to **Insert**.', example='1000'),
    stickySessionEnabled?: boolean(name='StickySessionEnabled', description='Specifies whether to enable session persistence. Valid values:

*   **true**
*   **false** (default)

> This parameter takes effect when the **ServerGroupType** parameter is set to **Instance** or **Ip**.', example='false'),
    stickySessionType?: string(name='StickySessionType', description='The method that is used to handle a cookie. Valid values:

*   **Insert** (default): inserts a cookie.

ALB inserts a session cookie (SERVERID) into the first HTTP or HTTPS response that is sent to a client. Subsequent requests to ALB carry this cookie, and ALB determines the destination servers of the requests based on the cookies.

*   **Server**: rewrites a cookie.

When ALB detects a user-defined cookie, it overwrites the original cookie with the user-defined cookie. Subsequent requests to ALB carry this user-defined cookie, and ALB determines the destination servers of the requests based on the cookies.

> This parameter takes effect when the **StickySessionEnabled** parameter is set to **true**.', example='Insert'),
  }(name='StickySessionConfig', description='The configuration of session persistence.

> This parameter takes effect when the **ServerGroupType** parameter is set to **Instance** or **Ip**.'),
  uchConfig?: {
    type?: string(name='Type', description='Type', example='QueryString'),
    value?: string(name='Value', description='The setting of consistent hashing.', example='abc'),
  }(name='UchConfig', description='The setting of consistent hashing based on URLs.'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC). You can add only backend servers that are deployed in the specified VPC to the server group.

> This parameter takes effect when the **ServerGroupType** parameter is set to **Instance** or **Ip**.', example='vpc-bp15zckdt37pq72zv****'),
}

model CreateServerGroupResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous job.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The request ID.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sg-atstuj3rtoptyui****'),
}

model CreateServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServerGroupResponseBody(name='body'),
}

/**
  * **CreateServerGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListServerGroups](~~213627~~) operation to query the status of the task.
  * *   If a server group is in the **Creating** state, it indicates that the server group is being created.
  * *   If a server group is in the **Available** state, it indicates that the server group is created.
  *
  * @param request CreateServerGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateServerGroupResponse
 */
async function createServerGroupWithOptions(request: CreateServerGroupRequest, runtime: Util.RuntimeOptions): CreateServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.healthCheckConfig)) {
    query['HealthCheckConfig'] = request.healthCheckConfig;
  }
  if (!Util.isUnset(request.protocol)) {
    query['Protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.serverGroupName)) {
    query['ServerGroupName'] = request.serverGroupName;
  }
  if (!Util.isUnset(request.serverGroupType)) {
    query['ServerGroupType'] = request.serverGroupType;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.stickySessionConfig)) {
    query['StickySessionConfig'] = request.stickySessionConfig;
  }
  if (!Util.isUnset(request.uchConfig)) {
    query['UchConfig'] = request.uchConfig;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServerGroup',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * **CreateServerGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListServerGroups](~~213627~~) operation to query the status of the task.
  * *   If a server group is in the **Creating** state, it indicates that the server group is being created.
  * *   If a server group is in the **Available** state, it indicates that the server group is created.
  *
  * @param request CreateServerGroupRequest
  * @return CreateServerGroupResponse
 */
async function createServerGroup(request: CreateServerGroupRequest): CreateServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServerGroupWithOptions(request, runtime);
}

model DeleteAScriptsRequest {
  AScriptIds?: [ string ](name='AScriptIds'),
  clientToken?: string(name='ClientToken', example='f516e84e-fc0c-4c2d-a461-6cd774a84dbd'),
  dryRun?: boolean(name='DryRun', example='false'),
}

model DeleteAScriptsResponseBody = {
  jobId?: string(name='JobId', example='03cf3fe1-ab37-479b-92a6-b481d762****'),
  requestId?: string(name='RequestId', example='1B7B7695-3596-50C8-B739-030C6C685E61'),
}

model DeleteAScriptsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAScriptsResponseBody(name='body'),
}

async function deleteAScriptsWithOptions(request: DeleteAScriptsRequest, runtime: Util.RuntimeOptions): DeleteAScriptsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.AScriptIds)) {
    query['AScriptIds'] = request.AScriptIds;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAScripts',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAScripts(request: DeleteAScriptsRequest): DeleteAScriptsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAScriptsWithOptions(request, runtime);
}

model DeleteAclRequest {
  aclId?: string(name='AclId', example='nacl-hp34s2h0xx1ht4nwo****'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', example='true'),
}

model DeleteAclResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model DeleteAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAclResponseBody(name='body'),
}

/**
  * The ID of the asynchronous task.
  *
  * @param request DeleteAclRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteAclResponse
 */
async function deleteAclWithOptions(request: DeleteAclRequest, runtime: Util.RuntimeOptions): DeleteAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAcl',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The ID of the asynchronous task.
  *
  * @param request DeleteAclRequest
  * @return DeleteAclResponse
 */
async function deleteAcl(request: DeleteAclRequest): DeleteAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAclWithOptions(request, runtime);
}

model DeleteHealthCheckTemplatesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to precheck the API request. Valid values:

*   **true**: only prechecks the API request. If you select this option, the specified endpoint service is not created after the request passes the precheck. The system prechecks the required parameters, request format, and service limits. If the request fails the precheck, the corresponding error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false**: checks the request. After the request passes the check, an **http\\_2xx** status code is returned and the operation is performed. This is the default value.', example='true'),
  healthCheckTemplateIds?: [ string ](name='HealthCheckTemplateIds', description='The IDs of the health check templates that you want to delete. You can specify up to 10 IDs.', example='acl-123'),
}

model DeleteHealthCheckTemplatesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model DeleteHealthCheckTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHealthCheckTemplatesResponseBody(name='body'),
}

async function deleteHealthCheckTemplatesWithOptions(request: DeleteHealthCheckTemplatesRequest, runtime: Util.RuntimeOptions): DeleteHealthCheckTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.healthCheckTemplateIds)) {
    query['HealthCheckTemplateIds'] = request.healthCheckTemplateIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHealthCheckTemplates',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHealthCheckTemplates(request: DeleteHealthCheckTemplatesRequest): DeleteHealthCheckTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHealthCheckTemplatesWithOptions(request, runtime);
}

model DeleteListenerRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='Specifies whether only to precheck this request. Valid values:

*   **true**: prechecks the request but does not delete the listener. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false**: sends the API request. This is the default value. If the request passes the precheck, an `HTTP_2xx` status code is returned and the operation is performed.', example='true'),
  listenerId?: string(name='ListenerId', description='The ID of the region where the ALB instance is deployed.', example='lsr-bp1bpn0kn908w4nbw****'),
}

model DeleteListenerResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model DeleteListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteListenerResponseBody(name='body'),
}

/**
  * The **DeleteRouteEntry** operation is asynchronous. After you send a request, the system returns the request ID. However, the operation is still being performed in the system background. You can call [GetListenerAttribute](~~2254865~~) to query the status of a listener.
  * *   If the listener is in the **Deleting** state, the vSwitch is being deleted.
  * *   If the listener cannot be found, the listener is deleted.
  *
  * @param request DeleteListenerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteListenerResponse
 */
async function deleteListenerWithOptions(request: DeleteListenerRequest, runtime: Util.RuntimeOptions): DeleteListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The **DeleteRouteEntry** operation is asynchronous. After you send a request, the system returns the request ID. However, the operation is still being performed in the system background. You can call [GetListenerAttribute](~~2254865~~) to query the status of a listener.
  * *   If the listener is in the **Deleting** state, the vSwitch is being deleted.
  * *   If the listener cannot be found, the listener is deleted.
  *
  * @param request DeleteListenerRequest
  * @return DeleteListenerResponse
 */
async function deleteListener(request: DeleteListenerRequest): DeleteListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteListenerWithOptions(request, runtime);
}

model DeleteLoadBalancerRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', example='true'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model DeleteLoadBalancerResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model DeleteLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLoadBalancerResponseBody(name='body'),
}

/**
  * The ID of the request.
  *
  * @param request DeleteLoadBalancerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteLoadBalancerResponse
 */
async function deleteLoadBalancerWithOptions(request: DeleteLoadBalancerRequest, runtime: Util.RuntimeOptions): DeleteLoadBalancerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLoadBalancer',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The ID of the request.
  *
  * @param request DeleteLoadBalancerRequest
  * @return DeleteLoadBalancerResponse
 */
async function deleteLoadBalancer(request: DeleteLoadBalancerRequest): DeleteLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoadBalancerWithOptions(request, runtime);
}

model DeleteRuleRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', example='true'),
  ruleId?: string(name='RuleId', example='rule-doc****'),
}

model DeleteRuleResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model DeleteRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRuleResponseBody(name='body'),
}

/**
  * The ID of the asynchronous task.
  *
  * @param request DeleteRuleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteRuleResponse
 */
async function deleteRuleWithOptions(request: DeleteRuleRequest, runtime: Util.RuntimeOptions): DeleteRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRule',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The ID of the asynchronous task.
  *
  * @param request DeleteRuleRequest
  * @return DeleteRuleResponse
 */
async function deleteRule(request: DeleteRuleRequest): DeleteRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRuleWithOptions(request, runtime);
}

model DeleteRulesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** may be different for each API request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to check the request without performing the operation. Valid values:

*   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the check, the system returns an `HTTP 2xx` status code and performs the operation.', example='false'),
  ruleIds?: [ string ](name='RuleIds', description='The list of forwarding rules that you want to delete.

>  The RuleIds parameter is required. You can specify up to 10 forwarding rules in each request.'),
}

model DeleteRulesResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7BED4F62-3E6E-5E4F-8C53-2D8CCE77F2ED'),
}

model DeleteRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRulesResponseBody(name='body'),
}

/**
  * The **DeleteRules** operation is asynchronous. After you send a request, the system returns a request ID. However, the operation is still being performed in the system background. You can call [ListRules](~~214379~~) to query the status of forwarding rules.
  * *   If the forwarding rules are in the **Deleting** state, the forwarding rules are being deleted.
  * *   If the forwarding rules cannot be found, the forwarding rules are deleted.
  *
  * @param request DeleteRulesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteRulesResponse
 */
async function deleteRulesWithOptions(request: DeleteRulesRequest, runtime: Util.RuntimeOptions): DeleteRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ruleIds)) {
    query['RuleIds'] = request.ruleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRules',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The **DeleteRules** operation is asynchronous. After you send a request, the system returns a request ID. However, the operation is still being performed in the system background. You can call [ListRules](~~214379~~) to query the status of forwarding rules.
  * *   If the forwarding rules are in the **Deleting** state, the forwarding rules are being deleted.
  * *   If the forwarding rules cannot be found, the forwarding rules are deleted.
  *
  * @param request DeleteRulesRequest
  * @return DeleteRulesResponse
 */
async function deleteRules(request: DeleteRulesRequest): DeleteRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRulesWithOptions(request, runtime);
}

model DeleteSecurityPolicyRequest {
  clientToken?: string(name='ClientToken', description='The ID of the security policy.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  dryRun?: boolean(name='DryRun', description='The ID of the request.', example='true'),
  securityPolicyId?: string(name='SecurityPolicyId', example='spy-n0kn923****'),
}

model DeleteSecurityPolicyResponseBody = {
  requestId?: string(name='RequestId', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
}

model DeleteSecurityPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSecurityPolicyResponseBody(name='body'),
}

async function deleteSecurityPolicyWithOptions(request: DeleteSecurityPolicyRequest, runtime: Util.RuntimeOptions): DeleteSecurityPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    query['SecurityPolicyId'] = request.securityPolicyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecurityPolicy',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSecurityPolicy(request: DeleteSecurityPolicyRequest): DeleteSecurityPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecurityPolicyWithOptions(request, runtime);
}

model DeleteServerGroupRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', example='true'),
  serverGroupId?: string(name='ServerGroupId', example='sgp-cige6j****'),
}

model DeleteServerGroupResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model DeleteServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServerGroupResponseBody(name='body'),
}

/**
  * The ID of the asynchronous task.
  *
  * @param request DeleteServerGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteServerGroupResponse
 */
async function deleteServerGroupWithOptions(request: DeleteServerGroupRequest, runtime: Util.RuntimeOptions): DeleteServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServerGroup',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The ID of the asynchronous task.
  *
  * @param request DeleteServerGroupRequest
  * @return DeleteServerGroupResponse
 */
async function deleteServerGroup(request: DeleteServerGroupRequest): DeleteServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServerGroupWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The supported natural language. Valid values:

*   zh-CN: **Chinese**
*   en-US: **English**
*   ja: **Japanese**', example='zh-CN'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName', description='The name of the region.', example=''),
      regionEndpoint?: string(name='RegionEndpoint', description='The endpoint of region service.', example='alb.cn-hangzhou.aliyuncs.com'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='Regions', description='The regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeZonesRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The supported natural language. Valid values:

*   **zh-CN**: Chinese
*   **en-US**: English
*   **ja**: Japanese', example='zh-CN'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  zones?: [ 
    {
      localName?: string(name='LocalName', description='The name of the zone.', example=''),
      zoneId?: string(name='ZoneId', description='The ID of the zone.', example='cn-hangzhou-g'),
    }
  ](name='Zones', description='The list of zones.', example='FFmyTO70tTpLG6I3FmYAXGKPdzTKM4svjIT4VQig7tTMKqiHlxKt2p5Zuz45p+Lxdq'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZonesWithOptions(request: DescribeZonesRequest, runtime: Util.RuntimeOptions): DescribeZonesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeZones',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeZonesWithOptions(request, runtime);
}

model DetachCommonBandwidthPackageFromLoadBalancerRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId', example='cbwp-bp1pzf0ym72pu3y76****'),
  clientToken?: string(name='ClientToken', description='The ID of the asynchronous task.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', example='true'),
  loadBalancerId?: string(name='LoadBalancerId', example='alb-d676fho813rmu3****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model DetachCommonBandwidthPackageFromLoadBalancerResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='2EF39708-974B-5E74-AFF5-3445263035A8'),
}

model DetachCommonBandwidthPackageFromLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachCommonBandwidthPackageFromLoadBalancerResponseBody(name='body'),
}

/**
  * Specifies whether to check the request without performing the operation. Valid values:
  * *   **true**: checks the request without perform the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
  * *   **false** (default): sends the request. If the request passes the check, a 2xx HTTP status code is returned and the operation is performed.
  *
  * @param request DetachCommonBandwidthPackageFromLoadBalancerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DetachCommonBandwidthPackageFromLoadBalancerResponse
 */
async function detachCommonBandwidthPackageFromLoadBalancerWithOptions(request: DetachCommonBandwidthPackageFromLoadBalancerRequest, runtime: Util.RuntimeOptions): DetachCommonBandwidthPackageFromLoadBalancerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachCommonBandwidthPackageFromLoadBalancer',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Specifies whether to check the request without performing the operation. Valid values:
  * *   **true**: checks the request without perform the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
  * *   **false** (default): sends the request. If the request passes the check, a 2xx HTTP status code is returned and the operation is performed.
  *
  * @param request DetachCommonBandwidthPackageFromLoadBalancerRequest
  * @return DetachCommonBandwidthPackageFromLoadBalancerResponse
 */
async function detachCommonBandwidthPackageFromLoadBalancer(request: DetachCommonBandwidthPackageFromLoadBalancerRequest): DetachCommonBandwidthPackageFromLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachCommonBandwidthPackageFromLoadBalancerWithOptions(request, runtime);
}

model DisableDeletionProtectionRequest {
  clientToken?: string(name='ClientToken', description='The ID of the Application Load Balancer (ALB) instance.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='The ID of the request.', example='true'),
  resourceId?: string(name='ResourceId', example='re-atstuj3rtop****'),
}

model DisableDeletionProtectionResponseBody = {
  requestId?: string(name='RequestId', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model DisableDeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableDeletionProtectionResponseBody(name='body'),
}

async function disableDeletionProtectionWithOptions(request: DisableDeletionProtectionRequest, runtime: Util.RuntimeOptions): DisableDeletionProtectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableDeletionProtection',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableDeletionProtection(request: DisableDeletionProtectionRequest): DisableDeletionProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableDeletionProtectionWithOptions(request, runtime);
}

model DisableLoadBalancerAccessLogRequest {
  clientToken?: string(name='ClientToken', description='The ID of the ALB instance.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  dryRun?: boolean(name='DryRun', description='The ID of the request.', example='true'),
  loadBalancerId?: string(name='LoadBalancerId', example='lb-bp1b6c719dfa08ex*****'),
}

model DisableLoadBalancerAccessLogResponseBody = {
  requestId?: string(name='RequestId', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
}

model DisableLoadBalancerAccessLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableLoadBalancerAccessLogResponseBody(name='body'),
}

async function disableLoadBalancerAccessLogWithOptions(request: DisableLoadBalancerAccessLogRequest, runtime: Util.RuntimeOptions): DisableLoadBalancerAccessLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableLoadBalancerAccessLog',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableLoadBalancerAccessLog(request: DisableLoadBalancerAccessLogRequest): DisableLoadBalancerAccessLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableLoadBalancerAccessLogWithOptions(request, runtime);
}

model DisableLoadBalancerIpv6InternetRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that the value is unique among all requests. The token can only contain ASCII characters.

>  If you do not specify this parameter, the system automatically sets **ClientToken** to the value of **RequestId**. The value of **RequestId** may be different for each API request.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run. Valid values:

*   **true:** performs a dry run. The system prechecks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false:** performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed. This is the default value.', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the ALB instance.', example='alb-chugtlrj1iusjh****'),
}

model DisableLoadBalancerIpv6InternetResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='d12871a6-ebb2-41f3-8d74-d9f452bb****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7D866E37-1123-5160-AFF1-BDAF5EB86A8A'),
}

model DisableLoadBalancerIpv6InternetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableLoadBalancerIpv6InternetResponseBody(name='body'),
}

/**
  * - After the DisableLoadBalancerIpv6Internet operation is called, the value of the **Ipv6AddressType** parameter is changed to **Intranet** and the type of the IPv6 address of the ALB instance is changed from public to private. If you upgrade the instance or the instance scales elastic network interface (ENIs) along with workloads, private IPv6 addresses are automatically enabled for the instance and the new ENIs. You can call the [GetLoadBalancerAttribute](/help/en/server-load-balancer/latest/getloadbalancerattribute) operation to query the value of the **Ipv6AddressType** parameter.
  * - **DisableLoadBalancerIpv6Internet** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetLoadBalancerAttribute](/help/en/server-load-balancer/latest/getloadbalancerattribute) operation to query the network type of the IPv6 address of an ALB instance.
  *       - If the ALB instance is in the **Configuring** state, the network type of the IPv6 address that is used by the ALB instance is being changed.
  *   - If the ALB instance is in the **Active** state, the network type of the IPv6 address that is used by the ALB instance has been changed successfully.
  * ## Prerequisites
  * An ALB instance is created and IPv4/IPv6 dual stack is enabled for the instance. You can call the [CreateLoadBalancer](~~214358~~) operation and set the **AddressIpVersion** parameter to **DualStack** to create a dual-stack ALB instance.
  * When **AddressIpVersion** is set to **DualStack**:
  *    *   If you set the **AddressType** parameter to **Internet**, the ALB instance uses a public IPv4 IP address and a private IPv6 address.
  *    *   If you set the **AddressType** parameter to **Intranet**, the ALB instance uses a private IPv4 IP address and a private IPv6 address.
  *
  * @param request DisableLoadBalancerIpv6InternetRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DisableLoadBalancerIpv6InternetResponse
 */
async function disableLoadBalancerIpv6InternetWithOptions(request: DisableLoadBalancerIpv6InternetRequest, runtime: Util.RuntimeOptions): DisableLoadBalancerIpv6InternetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableLoadBalancerIpv6Internet',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * - After the DisableLoadBalancerIpv6Internet operation is called, the value of the **Ipv6AddressType** parameter is changed to **Intranet** and the type of the IPv6 address of the ALB instance is changed from public to private. If you upgrade the instance or the instance scales elastic network interface (ENIs) along with workloads, private IPv6 addresses are automatically enabled for the instance and the new ENIs. You can call the [GetLoadBalancerAttribute](/help/en/server-load-balancer/latest/getloadbalancerattribute) operation to query the value of the **Ipv6AddressType** parameter.
  * - **DisableLoadBalancerIpv6Internet** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetLoadBalancerAttribute](/help/en/server-load-balancer/latest/getloadbalancerattribute) operation to query the network type of the IPv6 address of an ALB instance.
  *       - If the ALB instance is in the **Configuring** state, the network type of the IPv6 address that is used by the ALB instance is being changed.
  *   - If the ALB instance is in the **Active** state, the network type of the IPv6 address that is used by the ALB instance has been changed successfully.
  * ## Prerequisites
  * An ALB instance is created and IPv4/IPv6 dual stack is enabled for the instance. You can call the [CreateLoadBalancer](~~214358~~) operation and set the **AddressIpVersion** parameter to **DualStack** to create a dual-stack ALB instance.
  * When **AddressIpVersion** is set to **DualStack**:
  *    *   If you set the **AddressType** parameter to **Internet**, the ALB instance uses a public IPv4 IP address and a private IPv6 address.
  *    *   If you set the **AddressType** parameter to **Intranet**, the ALB instance uses a private IPv4 IP address and a private IPv6 address.
  *
  * @param request DisableLoadBalancerIpv6InternetRequest
  * @return DisableLoadBalancerIpv6InternetResponse
 */
async function disableLoadBalancerIpv6Internet(request: DisableLoadBalancerIpv6InternetRequest): DisableLoadBalancerIpv6InternetResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableLoadBalancerIpv6InternetWithOptions(request, runtime);
}

model DissociateAclsFromListenerRequest {
  aclIds?: [ string ](name='AclIds'),
  clientToken?: string(name='ClientToken', description='The ID of the asynchronous task.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.', example='true'),
  listenerId?: string(name='ListenerId', description='Specifies whether only to precheck this request. Valid values:

*   **true**: prechecks the request but does not disassociate the network ACL from the listener. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the NAT CIDR block is created.', example='lsr-bp1bpn0kn908w4nbw****'),
}

model DissociateAclsFromListenerResponseBody = {
  jobId?: string(name='JobId', description='The ID of the request.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model DissociateAclsFromListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DissociateAclsFromListenerResponseBody(name='body'),
}

/**
  * The operation that you want to perform. Set the value to **DissociateAclsFromListener**.
  *
  * @param request DissociateAclsFromListenerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DissociateAclsFromListenerResponse
 */
async function dissociateAclsFromListenerWithOptions(request: DissociateAclsFromListenerRequest, runtime: Util.RuntimeOptions): DissociateAclsFromListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclIds)) {
    query['AclIds'] = request.aclIds;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DissociateAclsFromListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The operation that you want to perform. Set the value to **DissociateAclsFromListener**.
  *
  * @param request DissociateAclsFromListenerRequest
  * @return DissociateAclsFromListenerResponse
 */
async function dissociateAclsFromListener(request: DissociateAclsFromListenerRequest): DissociateAclsFromListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateAclsFromListenerWithOptions(request, runtime);
}

model DissociateAdditionalCertificatesFromListenerRequest {
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId', description='The ID of the request.', example='12315790343_166f8204689_1714763408_70998****'),
    }
  ](name='Certificates', description='The ID of the asynchronous task.'),
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', example='true'),
  listenerId?: string(name='ListenerId', description='Specifies whether to check the request without performing the operation. Valid values:

*   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the check, the system returns an **HTTP 2xx** status code and performs the operation.', example='lsr-bp1bpn0kn908w4nbw****'),
}

model DissociateAdditionalCertificatesFromListenerResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model DissociateAdditionalCertificatesFromListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DissociateAdditionalCertificatesFromListenerResponseBody(name='body'),
}

/**
  * The ID of the certificate. Only server certificates are supported. A maximum of 20 certificate IDs are supported.
  *
  * @param request DissociateAdditionalCertificatesFromListenerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DissociateAdditionalCertificatesFromListenerResponse
 */
async function dissociateAdditionalCertificatesFromListenerWithOptions(request: DissociateAdditionalCertificatesFromListenerRequest, runtime: Util.RuntimeOptions): DissociateAdditionalCertificatesFromListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificates)) {
    query['Certificates'] = request.certificates;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DissociateAdditionalCertificatesFromListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The ID of the certificate. Only server certificates are supported. A maximum of 20 certificate IDs are supported.
  *
  * @param request DissociateAdditionalCertificatesFromListenerRequest
  * @return DissociateAdditionalCertificatesFromListenerResponse
 */
async function dissociateAdditionalCertificatesFromListener(request: DissociateAdditionalCertificatesFromListenerRequest): DissociateAdditionalCertificatesFromListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateAdditionalCertificatesFromListenerWithOptions(request, runtime);
}

model EnableDeletionProtectionRequest {
  clientToken?: string(name='ClientToken', description='The ID of the Application Load Balancer (ALB) instance.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='The ID of the request.', example='true'),
  resourceId?: string(name='ResourceId', example='re-atstuj3rtop****'),
}

model EnableDeletionProtectionResponseBody = {
  requestId?: string(name='RequestId', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model EnableDeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableDeletionProtectionResponseBody(name='body'),
}

async function enableDeletionProtectionWithOptions(request: EnableDeletionProtectionRequest, runtime: Util.RuntimeOptions): EnableDeletionProtectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableDeletionProtection',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableDeletionProtection(request: EnableDeletionProtectionRequest): EnableDeletionProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableDeletionProtectionWithOptions(request, runtime);
}

model EnableLoadBalancerAccessLogRequest {
  clientToken?: string(name='ClientToken', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  dryRun?: boolean(name='DryRun', example='true'),
  loadBalancerId?: string(name='LoadBalancerId', example='alb-123'),
  logProject?: string(name='LogProject', example='sls-setter'),
  logStore?: string(name='LogStore', example='test'),
}

model EnableLoadBalancerAccessLogResponseBody = {
  requestId?: string(name='RequestId', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
}

model EnableLoadBalancerAccessLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableLoadBalancerAccessLogResponseBody(name='body'),
}

async function enableLoadBalancerAccessLogWithOptions(request: EnableLoadBalancerAccessLogRequest, runtime: Util.RuntimeOptions): EnableLoadBalancerAccessLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.logProject)) {
    query['LogProject'] = request.logProject;
  }
  if (!Util.isUnset(request.logStore)) {
    query['LogStore'] = request.logStore;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableLoadBalancerAccessLog',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableLoadBalancerAccessLog(request: EnableLoadBalancerAccessLogRequest): EnableLoadBalancerAccessLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableLoadBalancerAccessLogWithOptions(request, runtime);
}

model EnableLoadBalancerIpv6InternetRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. The ClientToken value contains only ASCII characters.

>  If you do not specify this parameter, the system automatically sets **ClientToken** to the value of **RequestId**. The value of **RequestId** may be different for each API request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run. Valid values:

*   **true:** performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false:** performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed. This is the default value.', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the ALB instance.', example='alb-o2cvudgo6rlqz7****'),
}

model EnableLoadBalancerIpv6InternetResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='4a6e3ad4-ef08-4ab1-b332-fa621cfe****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BB920797-D70E-567F-8098-55A861DD7912'),
}

model EnableLoadBalancerIpv6InternetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableLoadBalancerIpv6InternetResponseBody(name='body'),
}

/**
  * - After the EnableLoadBalancerIpv6Internet operation is called, the value of the **Ipv6AddressType** parameter is changed to **Internet** and the type of the IPv6 address of the ALB instance is changed from private to public. If you upgrade the instance or the instance scales elastic network interface (ENIs) along with workloads, public IPv6 addresses are automatically enabled for the instance and the new ENIs. You can call the [GetLoadBalancerAttribute](/help/en/server-load-balancer/latest/getloadbalancerattribute) operation to query the value of the **Ipv6AddressType** parameter.
  * - **EnableLoadBalancerIpv6Internet** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetLoadBalancerAttribute](/help/en/server-load-balancer/latest/getloadbalancerattribute) operation to query the network type of the IPv6 address of an ALB instance.
  *       - If the ALB instance is in the **Configuring** state, the network type of the IPv6 address that is used by the ALB instance is being changed.
  *   - If the ALB instance is in the **Active** state, the network type of the IPv6 address that is used by the ALB instance has been changed successfully.
  * ## Prerequisites
  * An ALB instance is created and IPv4/IPv6 dual stack is enabled for the instance. You can call the [CreateLoadBalancer](~~214358~~) operation and set the **AddressIpVersion** parameter to **DualStack** to create a dual-stack ALB instance.
  * When **AddressIpVersion** is set to **DualStack**:
  *   *   If you set the **AddressType** parameter to **Internet**, the ALB instance uses a public IPv4 IP address and a private IPv6 address.
  *   *   If you set the **AddressType** parameter to **Intranet**, the ALB instance uses a private IPv4 IP address and a private IPv6 address.
  *
  * @param request EnableLoadBalancerIpv6InternetRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return EnableLoadBalancerIpv6InternetResponse
 */
async function enableLoadBalancerIpv6InternetWithOptions(request: EnableLoadBalancerIpv6InternetRequest, runtime: Util.RuntimeOptions): EnableLoadBalancerIpv6InternetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableLoadBalancerIpv6Internet',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * - After the EnableLoadBalancerIpv6Internet operation is called, the value of the **Ipv6AddressType** parameter is changed to **Internet** and the type of the IPv6 address of the ALB instance is changed from private to public. If you upgrade the instance or the instance scales elastic network interface (ENIs) along with workloads, public IPv6 addresses are automatically enabled for the instance and the new ENIs. You can call the [GetLoadBalancerAttribute](/help/en/server-load-balancer/latest/getloadbalancerattribute) operation to query the value of the **Ipv6AddressType** parameter.
  * - **EnableLoadBalancerIpv6Internet** is an asynchronous operation. After you send a request, the system returns a request ID and runs the task in the background. You can call the [GetLoadBalancerAttribute](/help/en/server-load-balancer/latest/getloadbalancerattribute) operation to query the network type of the IPv6 address of an ALB instance.
  *       - If the ALB instance is in the **Configuring** state, the network type of the IPv6 address that is used by the ALB instance is being changed.
  *   - If the ALB instance is in the **Active** state, the network type of the IPv6 address that is used by the ALB instance has been changed successfully.
  * ## Prerequisites
  * An ALB instance is created and IPv4/IPv6 dual stack is enabled for the instance. You can call the [CreateLoadBalancer](~~214358~~) operation and set the **AddressIpVersion** parameter to **DualStack** to create a dual-stack ALB instance.
  * When **AddressIpVersion** is set to **DualStack**:
  *   *   If you set the **AddressType** parameter to **Internet**, the ALB instance uses a public IPv4 IP address and a private IPv6 address.
  *   *   If you set the **AddressType** parameter to **Intranet**, the ALB instance uses a private IPv4 IP address and a private IPv6 address.
  *
  * @param request EnableLoadBalancerIpv6InternetRequest
  * @return EnableLoadBalancerIpv6InternetResponse
 */
async function enableLoadBalancerIpv6Internet(request: EnableLoadBalancerIpv6InternetRequest): EnableLoadBalancerIpv6InternetResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableLoadBalancerIpv6InternetWithOptions(request, runtime);
}

model GetHealthCheckTemplateAttributeRequest {
  healthCheckTemplateId?: string(name='HealthCheckTemplateId', description='The domain name that is used for health checks. Valid values:

*   **$SERVER_IP**: the private IP addresses of backend servers. If you do not set the HealthCheckHost parameter or set the parameter to $SERVER_IP, the Application Load Balancer (ALB) instance uses the private IP addresses of backend servers for health checks.
*   **domain**: The domain name must be 1 to 80 characters in length and can contain letters, digits, periods (.), and hyphens (-).

>  This parameter takes effect only when the `HealthCheckProtocol` parameter is set to **HTTP**.', example='hct-x4jazoyi6tvsq9****'),
}

model GetHealthCheckTemplateAttributeResponseBody = {
  healthCheckCodes?: [ string ](name='HealthCheckCodes', description='The ID of the health check template.'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The HTTP status codes that are used to determine whether the backend server passes the health check.

*   If **HealthCheckProtocol** is set to **HTTP**, **HealthCheckCodes** can be set to **http\\_2xx** (default), **http\\_3xx**, **http\\_4xx**, and **http\\_5xx**. Separate multiple HTTP status codes with a comma (,).
*   If **HealthCheckProtocol** is set to **gRPC**, **HealthCheckCodes** can be set to **0 to 99**. Default value: **0**. Value ranges are supported. You can enter 20 value ranges at most and must separate each range with a comma (,).

>  This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP** or **gRPC**.', example='80'),
  healthCheckHost?: string(name='HealthCheckHost', description='The HTTP version that is used for health checks.

Valid values: **HTTP1.0** and **HTTP1.1**.

>  This parameter takes effect only when the `HealthCheckProtocol` parameter is set to **HTTP**.', example='$SERVER_IP'),
  healthCheckHttpVersion?: string(name='HealthCheckHttpVersion', description='The interval between two consecutive health checks. Unit: seconds. Valid values: **1 to 50**.', example='HTTP1.0'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='The URL that is used for health checks.

The URL must be 1 to 80 characters in length and can contain only letters, digits, hyphens (-), forward slashes (/), periods (.), percent signs (%), question marks (?), number signs (#), and ampersands (&). The URL can also contain the following extended characters: `_ ; ~ ! ( ) * [ ] @ $ ^ : \\" , +`.

The URL path must start with a forward slash (/).

>  This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP** or **gRPC**.', example='3'),
  healthCheckMethod?: string(name='HealthCheckMethod', description='The protocol that is used for health checks. Valid values:

*   **HTTP** (default): To perform HTTP health checks, ALB sends HEAD or GET requests to a backend server to check whether the backend server is healthy.
*   **TCP**: To perform TCP health checks, ALB sends SYN packets to a backend server to check whether the port of the backend server is available to receive requests.
*   **gRPC**: To perform gRPC health checks, ALB sends POST or GET requests to a backend server to check whether the backend server is healthy.', example='GET'),
  healthCheckPath?: string(name='HealthCheckPath', description='The name of the health check template.

The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.', example='/test/index.html'),
  healthCheckProtocol?: string(name='HealthCheckProtocol', description='The timeout period of a health check. If a backend server does not return a health check response within the specified timeout period, the server fails the health check. Unit: seconds.

Valid values: **1** to **300**.

>  If the value of the `HealthCheckTimeout` parameter is smaller than that of the `HealthCheckInterval` parameter, the timeout period specified by the `HealthCheckTimeout` parameter is ignored and the value of the `HealthCheckInterval` parameter is used as the timeout period.', example='HTTP'),
  healthCheckTemplateId?: string(name='HealthCheckTemplateId', description='The HTTP method that is used for health checks. Valid values:

*   **HEAD**: By default, HTTP health checks use the HEAD method.
*   **GET**: If the size of a response exceeds 8 KB, the response is truncated. However, the health check result is not affected.
*   **POST**: By default, gRPC health checks use the POST method.

>  This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP** or **gRPC**.', example='hct-x4jazoyi6tvsq9****'),
  healthCheckTemplateName?: string(name='HealthCheckTemplateName', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**.

Valid values: **2** to **10**.', example='HealthCheckTemplate1'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', description='The ID of the request.', example='200'),
  healthyThreshold?: int32(name='HealthyThreshold', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**.

Valid values: **2** to **10**.', example='5'),
  requestId?: string(name='RequestId', example='DB1AFC33-DAE8-528E-AA4D-4A6AABE71945'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', example='5'),
}

model GetHealthCheckTemplateAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetHealthCheckTemplateAttributeResponseBody(name='body'),
}

async function getHealthCheckTemplateAttributeWithOptions(request: GetHealthCheckTemplateAttributeRequest, runtime: Util.RuntimeOptions): GetHealthCheckTemplateAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.healthCheckTemplateId)) {
    query['HealthCheckTemplateId'] = request.healthCheckTemplateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHealthCheckTemplateAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHealthCheckTemplateAttribute(request: GetHealthCheckTemplateAttributeRequest): GetHealthCheckTemplateAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHealthCheckTemplateAttributeWithOptions(request, runtime);
}

model GetListenerAttributeRequest {
  listenerId?: string(name='ListenerId', description='The configuration of the action. This parameter is returned and takes effect when the Type parameter is set to **FowardGroup**.', example='lsr-bp1bpn0kn908w4nbw****'),
}

model GetListenerAttributeResponseBody = {
  aclConfig?: {
    aclRelations?: [ 
      {
        aclId?: string(name='AclId', description='The action type. 

If **ForwardGroup** is returned, it indicates that requests are forwarded to multiple vServer groups.', example='acl-doc****'),
        status?: string(name='Status', description='Indicates whether gzip compression is enabled to compress specific types of files. Valid values:

- **true**: enabled
- **false**: disabled', example='Associating'),
      }
    ](name='AclRelations', description='The ID of the server group to which requests are forwarded.'),
    aclType?: string(name='AclType', description='Indicates whether HTTP/2 is enabled. Valid values:

*   **true**: enabled
*   **false**: disabled

>  Only HTTPS listeners support this parameter.', example='White'),
  }(name='AclConfig', description='The server groups to which requests are forwarded.'),
  caCertificates?: [ 
    {
      certificateId?: string(name='CertificateId', description='The frontend port that is used by the ALB instance.', example='139a00604bd-cn-east-hangzho****'),
      isDefault?: boolean(name='IsDefault', description='The status of the listener. Valid values:

*   **Provisioning**: The listener is being created.
*   **Running**: The listener is running.
*   **Configuring**: The listener is being configured.
*   **Stopped**: The listener is stopped.', example='true'),
      status?: string(name='Status', description='The listener protocol. Valid values: **HTTP**, **HTTPS**, and **QUIC**.', example='Associated'),
    }
  ](name='CaCertificates', description='The ID of the listener.'),
  caEnabled?: boolean(name='CaEnabled', description='The ID of the ALB instance.', example='false'),
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId', description='The description of the listener.', example='12315790212_166f8204689_1714763408_70998****'),
    }
  ](name='Certificates', description='The timeout period of an idle connection. Unit: seconds.

If no requests are received within the specified timeout period, Application Load Balancer (ALB) closes the current connection. When another request is received, ALB establishes a new connection.'),
  defaultActions?: [ 
    {
      forwardGroupConfig?: {
        serverGroupTuples?: [ 
          {
            serverGroupId?: string(name='ServerGroupId', description='Indicates whether Xtrace is enabled. Valid values:

*   **true**: enabled
*   **false**: disabled

>  **true** is returned only if the access log feature is enabled.', example='rsp-cige6j****'),
          }
        ](name='ServerGroupTuples', description='The configuration of Xtrace. Xtrace is used to record the requests sent to ALB.'),
      }(name='ForwardGroupConfig', description='Indicates whether custom headers are recorded in the access log. Valid values:

*   **true**: yes
*   **false**: no'),
      type?: string(name='Type', description='The sampling rate of Xtrace. Valid values: 1 to 10000.

>  This parameter takes effect when **TracingEnabled** is set to **true**.', example='ForwardGroup'),
    }
  ](name='DefaultActions', description='The configuration of the access log.'),
  gzipEnabled?: boolean(name='GzipEnabled', description='The Xtrace type. Supported Xtrace type: **Zipkin**.

>  This parameter takes effect when **TracingEnabled** is set to **true**.', example='true'),
  http2Enabled?: boolean(name='Http2Enabled', description='The configuration information when the listener is associated with a QUIC listener.', example='true'),
  idleTimeout?: int32(name='IdleTimeout', description='The ID of the QUIC listener. This parameter is returned when **QuicUpgradeEnabled** is set to **true**. Only HTTPS listeners support this parameter. 

>  The HTTPS listener and the QUIC listener must be added to the same ALB instance. In addition, make sure that the QUIC listener is not associated with another listener.', example='2'),
  listenerDescription?: string(name='ListenerDescription', description='Indicates whether QUIC upgrade is enabled. Valid values:

- **true**: enabled
- **false**: disabled

>  Only HTTPS listeners support this parameter.', example='The ID of the request.'),
  listenerId?: string(name='ListenerId', description='The timeout period of a request. Unit: seconds.

If no responses are received from the backend server within the specified timeout period, ALB returns an `HTTP 504` error code to the client.', example='lsr-bp1bpn0kn908w4nbw****'),
  listenerPort?: int32(name='ListenerPort', description='The security policy.

>  Only HTTPS listeners support this parameter.', example='80'),
  listenerProtocol?: string(name='ListenerProtocol', description='The configuration of the XForward headers.', example='HTTP'),
  listenerStatus?: string(name='ListenerStatus', description='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertClientVerifyEnabled** is set to **true**.

The name is 1 to 40 characters in length, and can contain lowercase letters, hyphens (-), underscores (\\_), and digits.

>  Only HTTPS listeners support this parameter.', example='Running'),
  loadBalancerId?: string(name='LoadBalancerId', description='Indicates whether the `X-Forwarded-Clientcert-clientverify` header is used to retrieve the verification result of the client certificate. Valid values:

*   **true**: yes
*   **false**: no

>  Only HTTPS listeners support this parameter.', example='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertFingerprintEnabled** is set to **true**.

The name is 1 to 40 characters in length, and can contain lowercase letters, hyphens (-), underscores (\\_), and digits.

>  Only HTTPS listeners support this parameter.'),
  logConfig?: {
    accessLogRecordCustomizedHeadersEnabled?: boolean(name='AccessLogRecordCustomizedHeadersEnabled', description='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertIssuerDNEnabled** is set to **true**.

The name is 1 to 40 characters in length, and can contain lowercase letters, hyphens (-), underscores (\\_), and digits.

>  Only HTTPS listeners support this parameter.', example='true'),
    accessLogTracingConfig?: {
      tracingEnabled?: boolean(name='TracingEnabled', description='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertSubjectDNEnabled** is set to **true**.

The name is 1 to 40 characters in length, and can contain lowercase letters, hyphens (-), underscores (\\_), and digits.

>  Only HTTPS listeners support this parameter.', example='true'),
      tracingSample?: int32(name='TracingSample', description='Indicates whether the `X-Forwarded-Clientcert-subjectdn` header is used to retrieve information about the owner of the client certificate. Valid values:

*   **true**: yes
*   **false**: no

>  Only HTTPS listeners support this parameter.', example='100'),
      tracingType?: string(name='TracingType', description='Indicates whether the `X-Forwarded-Client-Port` header is used to retrieve the client port. Valid values:

*   **true**: yes
*   **false**: no

>  HTTP and HTTPS listeners support this parameter.', example='Zipkin'),
    }(name='AccessLogTracingConfig', description='Indicates whether the `X-Forwarded-Clientcert-issuerdn` header is used to retrieve information about the authority that issues the client certificate. Valid values:

*   **true**: yes
*   **false**: no

>  Only HTTPS listeners support this parameter.'),
  }(name='LogConfig', description='Indicates whether the `X-Forwarded-Clientcert-fingerprint` header is used to retrieve the fingerprint of the client certificate. Valid values:

*   **true**: yes
*   **false**: no

>  Only HTTPS listeners support this parameter.'),
  quicConfig?: {
    quicListenerId?: string(name='QuicListenerId', description='Indicates whether the `X-Forwarded-Proto` header is used to retrieve the listener protocol. Valid values:

*   **true**: yes
*   **false**: no

>  HTTP, HTTPS, and QUIC listeners support this parameter.', example='lsn-333'),
    quicUpgradeEnabled?: boolean(name='QuicUpgradeEnabled', description='Indicates whether the `SLB-ID` header is used to retrieve the ID of the ALB instance. Valid values:

*   **true**: yes
*   **false**: no

>  HTTP, HTTPS, and QUIC listeners support this parameter.', example='true'),
  }(name='QuicConfig', description='Indicates whether the `X-Forwarded-For` header is used to retrieve the client IP address. Valid values:

*   **true**: yes
*   **false**: no

>  HTTP and HTTPS listeners support this parameter.'),
  requestId?: string(name='RequestId', description='Indicates whether the `X-Forwarded-Port` header is used to retrieve the listening port of the ALB instance. Valid values:

*   **true**: yes
*   **false**: no

>  HTTP, HTTPS, and QUIC listeners support this parameter.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
  requestTimeout?: int32(name='RequestTimeout', description='Indicates whether the `X-Forwarded-Client-Ip` header is used to retrieve the source port of the ALB instance. Valid values:

*   **true**: yes
*   **false**: no

>  HTTP, HTTPS, and QUIC listeners support this parameter.', example='34'),
  securityPolicyId?: string(name='SecurityPolicyId', description='The trusted proxy IP address.

ALB traverses `X-Forwarded-For` backwards and selects the first IP address that is not in the trusted IP list as the originating IP address of the client, which will be throttled if source IP address throttling is enabled.', example='tls_cipher_policy_1_1'),
  XForwardedForConfig?: {
    XForwardedForClientCertClientVerifyAlias?: string(name='XForwardedForClientCertClientVerifyAlias', example='test_client-verify-alias_123456'),
    XForwardedForClientCertClientVerifyEnabled?: boolean(name='XForwardedForClientCertClientVerifyEnabled', example='true'),
    XForwardedForClientCertFingerprintAlias?: string(name='XForwardedForClientCertFingerprintAlias', example='test_finger-print-alias_123456'),
    XForwardedForClientCertFingerprintEnabled?: boolean(name='XForwardedForClientCertFingerprintEnabled', example='true'),
    XForwardedForClientCertIssuerDNAlias?: string(name='XForwardedForClientCertIssuerDNAlias', example='test_issue-dn-alias_123456'),
    XForwardedForClientCertIssuerDNEnabled?: boolean(name='XForwardedForClientCertIssuerDNEnabled', example='true'),
    XForwardedForClientCertSubjectDNAlias?: string(name='XForwardedForClientCertSubjectDNAlias', example='test_subject-dn-alias_123456'),
    XForwardedForClientCertSubjectDNEnabled?: boolean(name='XForwardedForClientCertSubjectDNEnabled', example='true'),
    XForwardedForClientSourceIpsEnabled?: boolean(name='XForwardedForClientSourceIpsEnabled', example='false'),
    XForwardedForClientSourceIpsTrusted?: string(name='XForwardedForClientSourceIpsTrusted', example='10.1.1.0/24'),
    XForwardedForClientSrcPortEnabled?: boolean(name='XForwardedForClientSrcPortEnabled', example='true'),
    XForwardedForEnabled?: boolean(name='XForwardedForEnabled', example='true'),
    XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled', example='true'),
    XForwardedForSLBIdEnabled?: boolean(name='XForwardedForSLBIdEnabled', example='true'),
    XForwardedForSLBPortEnabled?: boolean(name='XForwardedForSLBPortEnabled', example='true'),
  }(name='XForwardedForConfig'),
}

model GetListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetListenerAttributeResponseBody(name='body'),
}

async function getListenerAttributeWithOptions(request: GetListenerAttributeRequest, runtime: Util.RuntimeOptions): GetListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetListenerAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getListenerAttribute(request: GetListenerAttributeRequest): GetListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getListenerAttributeWithOptions(request, runtime);
}

model GetListenerHealthStatusRequest {
  includeRule?: boolean(name='IncludeRule', description='The ID of the listener.', example='true'),
  listenerId?: string(name='ListenerId', description='The health check status of the server groups that are associated with the listener.', example='lsr-bp1bpn0kn908w4nbw****'),
  maxResults?: long(name='MaxResults', description='The listening protocol.', example='20'),
  nextToken?: string(name='NextToken', description='The listening port.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
}

model GetListenerHealthStatusResponseBody = {
  listenerHealthStatus?: [ 
    {
      listenerId?: string(name='ListenerId', description='Indicates whether health checks are enabled. If **on** is returned, it indicates that health checks are enabled.', example='lsr-bp1bpn0kn908w4nbw****'),
      listenerPort?: int32(name='ListenerPort', description='The list of unhealthy backend servers.', example='80'),
      listenerProtocol?: string(name='ListenerProtocol', description='The backend port.', example='http'),
      serverGroupInfos?: [ 
        {
          actionType?: string(name='ActionType', description='The list of server groups.', example='TrafficMirror'),
          healthCheckEnabled?: string(name='HealthCheckEnabled', description='The HTTP status code returned from the backend server. For example, **302**.

>  This value is returned only if the return value of `ReasonCode` is **RESPONSE_MISMATCH**.', example='on'),
          nonNormalServers?: [ 
            {
              port?: int32(name='Port', description='The reason why **Status** is Unhealthy. Only HTTP and HTTPS listeners support this parameter.

*   **CONNECT_TIMEOUT**: Application Load Balancer (ALB) failed to connect to the backend server within the specified period of time.
*   **CONNECT_FAILED**: ALB failed to connect to the backend server.
*   **RECV_RESPONSE_FAILED**: ALB failed to receive a response from the backend server.
*   **RECV_RESPONSE_TIMEOUT**: ALB failed to receive a response from the backend server within the specified period of time.
*   **SEND_REQUEST_FAILED**: ALB failed to send a request to the backend server.
*   **SEND_REQUEST_TIMEOUT**: ALB failed to send a request to the backend server within the specified period of time.
*   **RESPONSE_FORMAT_ERROR**: The format of the response from the backend server is invalid.
*   **RESPONSE_FORMAT_ERROR**: The HTTP status code returned from the backend server is not the expected one.', example='90'),
              reason?: {
                actualResponse?: string(name='ActualResponse', description='The IP address of the backend server.', example='302'),
                expectedResponse?: string(name='ExpectedResponse', description='The health check status. Valid values:

*   **Initial**: indicates that health checks are configured for the ALB instance, but no data was found.
*   **Unhealthy**: indicates that the backend server consecutively fails health checks.
*   **Unused**: indicates that the weight of the backend server is 0.
*   **Unavailable**: indicates that health checks are disabled.', example='HTTP_2xx'),
                reasonCode?: string(name='ReasonCode', description='The ID of the server group that is associated with the listener.', example='RESPONSE_MISMATCH'),
              }(name='Reason', description='The ID of the backend server.'),
              serverId?: string(name='ServerId', description='The action specified for the server group.', example='rg-bp1bfa08ex*****'),
              serverIp?: string(name='ServerIp', description='The ID of the request.', example='192.168.8.10'),
              status?: string(name='Status', description='The health check status of the forwarding rules.', example='Initial'),
            }
          ](name='NonNormalServers', description='The HTTP status code returned after backend servers pass health checks.

Valid values: **HTTP\\_2xx**, **HTTP\\_3xx**, **HTTP\\_4xx**, and **HTTP\\_5xx**. Multiple status codes are separated by commas (,).

>  This value is returned only if the return value of **ReasonCode** is **RESPONSE_MISMATCH**.'),
          serverGroupId?: string(name='ServerGroupId', description='The ID of the forwarding rule.', example='vsp-bp1qjwo61pqz3ahltv****'),
        }
      ](name='ServerGroupInfos', description='The cause of the health check failure.'),
    }
  ](name='ListenerHealthStatus', description='The information about server groups.'),
  nextToken?: string(name='NextToken', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='Indicates whether health checks are enabled. If **on** is returned, it indicates that health checks are enabled.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
  ruleHealthStatus?: [ 
    {
      ruleId?: string(name='RuleId', description='The backend port.', example='rule-hp34s2h0xx1ht4nwo****'),
      serverGroupInfos?: [ 
        {
          actionType?: string(name='ActionType', example='TrafficMirror'),
          healthCheckEnabled?: string(name='HealthCheckEnabled', description='The HTTP status code returned from the backend server. For example, **302**.

>  A value is returned only if the return value of **ReasonCode** is **RESPONSE_MISMATCH**.', example='on'),
          nonNormalServers?: [ 
            {
              port?: int32(name='Port', description='The reason why **Status** is Unhealthy. Only HTTP and HTTPS listeners support this parameter.

*   **CONNECT_TIMEOUT**: ALB failed to connect to the backend server within the specified period of time.
*   **CONNECT_FAILED**: ALB failed to connect to the backend server.
*   **RECV_RESPONSE_FAILED**: ALB failed to receive a response from the backend server.
*   **RECV_RESPONSE_TIMEOUT**: ALB failed to receive a response from the backend server within the specified period of time.
*   **SEND_REQUEST_FAILED**: ALB failed to send a request to the backend server.
*   **SEND_REQUEST_TIMEOUT**: ALB failed to send a request to the backend server within the specified period of time.
*   **RESPONSE_FORMAT_ERROR**: The format of the response from the backend server is invalid.
*   **RESPONSE_FORMAT_ERROR**: The HTTP status code returned from the backend server is not the expected one.', example='90'),
              reason?: {
                actualResponse?: string(name='ActualResponse', description='The IP address of the server group.', example='302'),
                expectedResponse?: string(name='ExpectedResponse', description='The health check status. Valid values:

*   **Initial**: indicates that health checks are configured for the ALB instance, but no data was found.
*   **Unhealthy**: indicates that the backend server consecutively fails health checks.
*   **Unused**: indicates that the weight of the backend server is 0.
*   **Unavailable**: indicates that health checks are disabled.', example='HTTP_2xx'),
                reasonCode?: string(name='ReasonCode', description='The ID of the server group that is associated with the listener.', example='RESPONSE_MISMATCH'),
              }(name='Reason', description='The ID of the backend server.'),
              serverId?: string(name='ServerId', description='The action specified for the server group.', example='rg-bp1bfa08ex****'),
              serverIp?: string(name='ServerIp', description='The token that is used for the next query. Valid values:

- If **NextToken** is empty, it indicates that no next query is to be sent.
- If a value of **NextToken** is returned, the value is the token that is used for the next query.', example='192.168.2.11'),
              status?: string(name='Status', example='Initial'),
            }
          ](name='NonNormalServers', description='The HTTP status code returned after backend servers pass health checks.

Valid values: **HTTP\\_2xx**, **HTTP\\_3xx**, **HTTP\\_4xx**, and **HTTP\\_5xx**. Multiple status codes are separated by commas (,).

>  A value is returned only if the return value of **ReasonCode** is **RESPONSE_MISMATCH**.'),
          serverGroupId?: string(name='ServerGroupId', example='vsp-bp1qjwo61pqz3ahlt****'),
        }
      ](name='ServerGroupInfos', description='The cause of the health check failure.'),
    }
  ](name='RuleHealthStatus', description='The list of unhealthy backend servers.'),
}

model GetListenerHealthStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetListenerHealthStatusResponseBody(name='body'),
}

async function getListenerHealthStatusWithOptions(request: GetListenerHealthStatusRequest, runtime: Util.RuntimeOptions): GetListenerHealthStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.includeRule)) {
    query['IncludeRule'] = request.includeRule;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetListenerHealthStatus',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getListenerHealthStatus(request: GetListenerHealthStatusRequest): GetListenerHealthStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getListenerHealthStatusWithOptions(request, runtime);
}

model GetLoadBalancerAttributeRequest {
  loadBalancerId?: string(name='LoadBalancerId', description='The Logstore.', example='alb-o9ulmq5hgn68jk****'),
}

model GetLoadBalancerAttributeResponseBody = {
  accessLogConfig?: {
    logProject?: string(name='LogProject', description='The type of the IPv4 address that is used by the ALB instance. Valid values:

*   **Internet:** The ALB instance uses a public IP address. The domain name of the ALB instance is resolved to the public IP address. In this case, the ALB instance can be accessed over the Internet.
*   **Intranet:** The ALB instance uses a private IP address. The domain name of the ALB instance is resolved to the private IP address. In this case, the ALB instance can be accessed over the virtual private cloud (VPC) where the ALB instance is deployed.', example='sls-setter'),
    logStore?: string(name='LogStore', description='The ID of the Elastic IP Address (EIP) bandwidth plan which is associated with the ALB instance if the ALB instance uses a public IP address.', example='test'),
  }(name='AccessLogConfig', description='The mode used to assign IP addresses to zones of the ALB instance. Valid values:

*   **Fixed:** assigns a static IP address to the ALB instance.
*   **Dynamic:** dynamically assigns an IP address to each zone of the ALB instance.'),
  addressAllocatedMode?: string(name='AddressAllocatedMode', description='The time when the resource was created. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='Dynamic'),
  addressIpVersion?: string(name='AddressIpVersion', example='DualStack'),
  addressType?: string(name='AddressType', description='The domain name of the ALB instance.', example='Intranet'),
  bandwidthPackageId?: string(name='BandwidthPackageId', description='The configuration of the deletion protection feature.', example='cbwp-bp1vevu8h3ieh****'),
  createTime?: string(name='CreateTime', description='Indicates whether the deletion protection feature is enabled. Valid values:

*   **true:** The deletion protection feature is enabled.
*   **false:** The deletion protection feature is disabled.', example='2022-07-02T02:49:05Z'),
  DNSName?: string(name='DNSName', description='The time when the deletion protection feature was enabled. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='alb-95qnr2itwu9orb****.cn-hangzhou.alb.aliyuncs.com'),
  deletionProtectionConfig?: {
    enabled?: boolean(name='Enabled', description='The billing method.

The value **PostPay** is returned. The value indicates the pay-as-you-go billing method.', example='true'),
    enabledTime?: string(name='EnabledTime', description='The status of the ALB instance. Valid values:

*   **Abnormal:** The ALB instance is not working as expected.
*   **Normal:** The ALB instance is working as expected.', example='2022-08-02T02:49:05Z'),
  }(name='DeletionProtectionConfig', description='The configuration of the billing method of the ALB instance.'),
  ipv6AddressType?: string(name='Ipv6AddressType', example='Intranet'),
  loadBalancerBillingConfig?: {
    payType?: string(name='PayType', description='The ID of the ALB instance.', example='PostPay'),
  }(name='LoadBalancerBillingConfig', description='The edition of the ALB instance. The features and billing rules vary based on the edition of the ALB instance. Valid values:

*   **Basic:** basic.
*   **Standard:** standard.
*   **StandardWithWaf:** WAF-enabled.'),
  loadBalancerBussinessStatus?: string(name='LoadBalancerBussinessStatus', description='The name of the ALB instance.

The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.', example='Normal'),
  loadBalancerEdition?: string(name='LoadBalancerEdition', description='The configuration of the operation lock.', example='Standard'),
  loadBalancerId?: string(name='LoadBalancerId', description='The reason why the ALB instance was locked. This parameter is available only if you specify the **LoadBalancerBussinessStatus** parameter to **Abnormal**.', example='alb-o9ulmq5hgn68jk****'),
  loadBalancerName?: string(name='LoadBalancerName', description='The type of the lock. Valid values:

*   **SecurityLocked:** The ALB instance was locked due to security reasons.
*   **RelatedResourceLocked:** The ALB instance was locked due to association issues.
*   **FinancialLocked:** The ALB instance was locked due to overdue payments.
*   **ResidualLocked:** The ALB instance was locked because the associated EIP bandwidth plans were released.', example='alb1'),
  loadBalancerOperationLocks?: [ 
    {
      lockReason?: string(name='LockReason', description='The configuration of the configuration read-only mode.'),
      lockType?: string(name='LockType', description='The reason why the configuration read-only mode was enabled. The reason must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The reason must start with a letter.

This parameter is valid only if you set the **ModificationProtectionStatus** parameter to **ConsoleProtection**.', example='FinancialLocked'),
    }
  ](name='LoadBalancerOperationLocks', description='The status of the ALB instance. Valid values:

*   **Inactive:** The ALB instance is disabled. ALB instances in the Inactive state do not forward traffic.
*   **Active:** The ALB instance is running.
*   **Provisioning:** The ALB instance is being created.
*   **Configuring:** The ALB instance is being modified.
*   **CreateFailed:** The system failed to create the ALB instance. In this case, you are not charged for the ALB instance.'),
  loadBalancerStatus?: string(name='LoadBalancerStatus', description='The status of the configuration read-only mode. Valid values:

*   **NonProtection:** The configuration read-only mode is disabled. In this case, you cannot specify the ModificationProtectionReason parameter. If you specify the ModificationProtectionReason parameter, the value of the parameter is cleared.
*   **ConsoleProtection:** The configuration read-only mode is enabled. In this case, you can specify the ModificationProtectionReason parameter.

>  If you set this parameter to **ConsoleProtection**, you cannot modify the configurations of the instance in the ALB console. However, you can call API operations to modify the configurations of the instance.', example='Active'),
  modificationProtectionConfig?: {
    reason?: string(name='Reason', description='The ID of the request.'),
    status?: string(name='Status', description='The ID of the resource group.', example='ConsoleProtection'),
  }(name='ModificationProtectionConfig', description='The ID of the region where the ALB instance was deployed.'),
  regionId?: string(name='RegionId', description='The tags that were added to the ALB instance.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='The key of tag N.

The key can be up to 128 characters in length, and cannot start with `acs:` or `aliyun`. The key cannot contain `http://` or `https://`.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
  resourceGroupId?: string(name='ResourceGroupId', description='The value of tag N.

The value can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. The value cannot contain `http://` or `https://`.', example='rg-atstuj3rtop****'),
  tags?: [ 
    {
      key?: string(name='Key', description='The zones and the vSwitches. You must specify at least two zones.', example='FinanceDept'),
      value?: string(name='Value', description='The IP addresses that are used by the ALB instance.', example='FinanceJoshua'),
    }
  ](name='Tags', description='The ID of the VPC in which the ALB instance was deployed.'),
  vpcId?: string(name='VpcId', description='The IPv4 address that is used by the ALB instance.

This parameter is available only if you set the **AddressIPVersion** parameter to **IPv4**. The AddressType parameter determines whether the IPv4 address is public or private.', example='vpc-bp1b49rqrybk45nio****'),
  zoneMappings?: [ 
    {
      loadBalancerAddresses?: [ 
        {
          address?: string(name='Address', description='The ID of the zone where the ALB instance was deployed.

You can call the [DescribeZones](~~189196~~) operation to query the zones of the ALB instance.', example='192.168.10.1'),
          allocationId?: string(name='AllocationId'),
          eipType?: string(name='EipType'),
          ipv6Address?: string(name='Ipv6Address', description='The protocol version. Valid values:

*   **IPv4:** IPv4.
*   **DualStack:** dual stack.', example='2408:XXXX:39d:eb00::/56'),
        }
      ](name='LoadBalancerAddresses', description='The ID of the vSwitch in the zone. Each zone can contain only one vSwitch and one subnet.'),
      vSwitchId?: string(name='VSwitchId', description='The type of IPv6 address that is used by the ALB instance. Valid values:

*   **Internet:** The ALB instance uses a public IP address. The domain name of the ALB instance is resolved to the public IP address. Therefore, the ALB instance can be accessed over the Internet.
*   **Intranet:** The ALB instance uses a private IP address. The domain name of the ALB instance is resolved to the private IP address. Therefore, the ALB instance can be accessed over the VPC in which the ALB instance is deployed.', example='vsw-bp12mw1f8k3jgy****'),
      zoneId?: string(name='ZoneId', example='cn-hangzhou-a'),
    }
  ](name='ZoneMappings', description='The IPv6 address that is used by the ALB instance.

This parameter is available only if you set the **AddressIPVersion** parameter to **DualStack**. The AddressType parameter determines whether the IPv6 address is public or private.'),
}

model GetLoadBalancerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLoadBalancerAttributeResponseBody(name='body'),
}

async function getLoadBalancerAttributeWithOptions(request: GetLoadBalancerAttributeRequest, runtime: Util.RuntimeOptions): GetLoadBalancerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLoadBalancerAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLoadBalancerAttribute(request: GetLoadBalancerAttributeRequest): GetLoadBalancerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLoadBalancerAttributeWithOptions(request, runtime);
}

model ListAScriptsRequest {
  AScriptIds?: [ string ](name='AScriptIds', description='The IDs of the AScript rules. You can specify at most 20 IDs at a time.'),
  AScriptNames?: [ string ](name='AScriptNames', description='The names of the AScript rules. You can specify at most 10 names at a time.'),
  listenerIds?: [ string ](name='ListenerIds', description='The IDs of the listeners. You can specify at most 20 IDs in each request.'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries to return.

Valid values: **1** to **100**.

Default value: **20**. If you do not set this parameter, the default value is used.', example='50'),
  nextToken?: string(name='NextToken', description='The token that determines the start point of the query. Valid values:

*   If **NextToken** is empty, it indicates that no subsequent query is to be sent.
*   If a value of **NextToken** is returned, the value is the token used for the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
}

model ListAScriptsResponseBody = {
  AScripts?: [ 
    {
      AScriptId?: string(name='AScriptId', description='The ID of the AScript rule.', example='as-aznwocxofkakf7****'),
      AScriptName?: string(name='AScriptName', description='The name of the AScript rule.', example='test'),
      AScriptStatus?: string(name='AScriptStatus', description='The status of the AScript rule. Valid values:

*   **Creating**: being created.
*   **Available**: created or updated.
*   **Configuring**: being updated.
*   **Deleting**: being deleted.', example='Available'),
      enabled?: boolean(name='Enabled', description='Indicates whether the AScript rule is enabled. Valid values:

*   **true**: enabled
*   **false**: disabled', example='true'),
      listenerId?: string(name='ListenerId', description='The ID of the listener.', example='lsn-t0w1m9r6suiwmc****'),
      loadBalancerId?: string(name='LoadBalancerId', description='The ID of the Application Load Balancer (ALB) instance.', example='alb-vv9rg2ub31tyec****'),
      scriptContent?: string(name='ScriptContent', description='The content of the AScript rule.', example='{test}'),
    }
  ](name='AScripts', description='The list of the AScript rules.'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='50'),
  nextToken?: string(name='NextToken', description='The token that determines the start point of the query. Valid values:

*   If **NextToken** is empty, it indicates that no subsequent query is to be sent.
*   If a value of **NextToken** is returned, the value is the token used for the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2CA81429-F160-593A-8AB5-A2A9617845B9'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.

>  This parameter is optional and is not returned by default.', example='1000'),
}

model ListAScriptsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAScriptsResponseBody(name='body'),
}

async function listAScriptsWithOptions(request: ListAScriptsRequest, runtime: Util.RuntimeOptions): ListAScriptsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.AScriptIds)) {
    query['AScriptIds'] = request.AScriptIds;
  }
  if (!Util.isUnset(request.AScriptNames)) {
    query['AScriptNames'] = request.AScriptNames;
  }
  if (!Util.isUnset(request.listenerIds)) {
    query['ListenerIds'] = request.listenerIds;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAScripts',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAScripts(request: ListAScriptsRequest): ListAScriptsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAScriptsWithOptions(request, runtime);
}

model ListAclEntriesRequest {
  aclId?: string(name='AclId', description='The ACL ID.', example='nacl-hp34s2h0xx1ht4nwo****'),
  maxResults?: int32(name='MaxResults', description='The number of entries per page. Valid values: **1** to **100**. Default value: **20**.', example='50'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   You do not need to specify this parameter for the first request.
*   You must specify the token that is obtained from the previous query as the value of **NextToken**.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
}

model ListAclEntriesResponseBody = {
  aclEntries?: [ 
    {
      description?: string(name='Description', description='The description of the ACL entry. The description must be 1 to 256 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), and underscores (\\_).', example='test-entry'),
      entry?: string(name='Entry', description='The CIDR block of the ACL entry.', example='10.0.1.1/24'),
      status?: string(name='Status', description='The status of the ACL entry. Valid values:

*   **Adding**
*   **Available**
*   **Removing**', example='Available'),
    }
  ](name='AclEntries', description='The ACL entries.'),
  maxResults?: int32(name='MaxResults', description='The number of entries per page.', example='50'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value is returned for **NextToken**, the value is the token that determines the start point of the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The request ID.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1000'),
}

model ListAclEntriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAclEntriesResponseBody(name='body'),
}

async function listAclEntriesWithOptions(request: ListAclEntriesRequest, runtime: Util.RuntimeOptions): ListAclEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAclEntries',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAclEntries(request: ListAclEntriesRequest): ListAclEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAclEntriesWithOptions(request, runtime);
}

model ListAclRelationsRequest {
  aclIds?: [ string ](name='AclIds', description='The listeners associated with the specified ACL.'),
}

model ListAclRelationsResponseBody = {
  aclRelations?: [ 
    {
      aclId?: string(name='AclId', description='The port of the listener.', example='nacl-hp34s2h0xx1ht4nwo****'),
      relatedListeners?: [ 
        {
          listenerId?: string(name='ListenerId', description='The ID of the SLB instance.', example='lsr-bp1bpn0kn908w4nbw****'),
          listenerPort?: int32(name='ListenerPort', description='The status of association between the listener and the ACL.

*   **Associating**: The listener is being associated with the ACL.
*   **Associated**: The listener is associated with the ACL.
*   **Dissociating**: The listener is being disassociated from the ACL.', example='80'),
          listenerProtocol?: string(name='ListenerProtocol', description='The ID of the request.', example='HTTPS'),
          loadBalancerId?: string(name='LoadBalancerId', example='lb-bp1b6c719dfa08ex****'),
          status?: string(name='Status', example='Associated'),
        }
      ](name='RelatedListeners', description='The protocol used by the listener.'),
    }
  ](name='AclRelations', description='The ID of the listener.'),
  requestId?: string(name='RequestId', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
}

model ListAclRelationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAclRelationsResponseBody(name='body'),
}

async function listAclRelationsWithOptions(request: ListAclRelationsRequest, runtime: Util.RuntimeOptions): ListAclRelationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclIds)) {
    query['AclIds'] = request.aclIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAclRelations',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAclRelations(request: ListAclRelationsRequest): ListAclRelationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAclRelationsWithOptions(request, runtime);
}

model ListAclsRequest {
  aclIds?: [ string ](name='AclIds', description='The names of the network ACLs. You can specify at most 10 network ACL names in each request.'),
  aclNames?: [ string ](name='AclNames', description='The ID of the resource group. You can filter the query results based on the specified ID.'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries to return. This parameter is optional. Valid values: **1** to **100**. Default value: **20**.', example='50'),
  nextToken?: string(name='NextToken', description='The operation that you want to perform. Set the value to **ListAcls**.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The IP version. **IPv4** is returned.', example='rg-atstuj3rtopty****'),
}

model ListAclsResponseBody = {
  acls?: [ 
    {
      aclId?: string(name='AclId', description='The ID of the network ACL.', example='nacl-hp34s2h0xx1ht4nwo****'),
      aclName?: string(name='AclName', description='The ID of the network ACL. You can specify at most 20 network ACL IDs in each request.', example='test-acl'),
      aclStatus?: string(name='AclStatus', description='The name of the network ACL.', example='Available'),
      addressIPVersion?: string(name='AddressIPVersion', description='The status of configuration management. Valid values:

*   **true**: configuration management is enabled.
*   **false**: configuration management is disabled.', example='IPv4'),
      configManagedEnabled?: boolean(name='ConfigManagedEnabled', description='The network ACLs.', example='false'),
      createTime?: string(name='CreateTime'),
      resourceGroupId?: string(name='ResourceGroupId', description='The token that is used for the next query. Valid values:

*   If this is your first query or no next query is to be sent, ignore this parameter.
*   If a next query is to be sent, set the value to the value of NextToken that is returned from the last call.', example='rg-atstuj3rtopty****'),
    }
  ](name='Acls', description='The status of the network ACL. Valid values:

*   **Creating**: The network ACL is being created.
*   **Available**: The network ACL is available.
*   **Configuring**: The network ACL is being configured.'),
  maxResults?: int32(name='MaxResults', description='The ID of the request.', example='20'),
  nextToken?: string(name='NextToken', description='The ID of the resource group.', example='FFmyTO70t****'),
  requestId?: string(name='RequestId', description='The operation that you want to perform. Set the value to **ListAcls**.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  totalCount?: int32(name='TotalCount', description='The ID of the network ACL. You can specify at most 20 network ACL IDs in each request.', example='10'),
}

model ListAclsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAclsResponseBody(name='body'),
}

/**
  * The maximum number of network ACLs returned. This parameter is optional. Valid values: **1** to **100**. If this parameter is not set, the default value **20** is returned.
  *
  * @param request ListAclsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListAclsResponse
 */
async function listAclsWithOptions(request: ListAclsRequest, runtime: Util.RuntimeOptions): ListAclsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclIds)) {
    query['AclIds'] = request.aclIds;
  }
  if (!Util.isUnset(request.aclNames)) {
    query['AclNames'] = request.aclNames;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAcls',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The maximum number of network ACLs returned. This parameter is optional. Valid values: **1** to **100**. If this parameter is not set, the default value **20** is returned.
  *
  * @param request ListAclsRequest
  * @return ListAclsResponse
 */
async function listAcls(request: ListAclsRequest): ListAclsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAclsWithOptions(request, runtime);
}

model ListAsynJobsRequest {
  apiName?: string(name='ApiName', description='The operation that you want to perform.', example='CreateLoadBalancer'),
  beginTime?: long(name='BeginTime', description='The time when the task started. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC.', example='2021-06-03T17:22Z'),
  endTime?: long(name='EndTime', description='The time when the task ended. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC.', example='2021-06-04T17:22Z'),
  jobIds?: [ string ](name='JobIds', description='The ID of the asynchronous task.'),
  maxResults?: long(name='MaxResults', description='The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.', example='20'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

*   If this is your first query or no next query is to be sent, ignore this parameter.
*   If a next query is to be sent, set the value to the value of **NextToken** that is returned from the last call.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  resourceIds?: [ string ](name='ResourceIds', description='The ID of the resource.'),
  resourceType?: string(name='ResourceType', description='The type of the associated resource. Valid values:

*   **loadbalancer**: an Application Load Balancer (ALB) instance
*   **listener**: a listener
*   **rule**: a forwarding rule
*   **acl**: a network access control list (ACL)
*   **securitypolicy**: a security policy
*   **servergroup**: a server group', example='acl'),
}

model ListAsynJobsResponseBody = {
  jobs?: [ 
    {
      apiName?: string(name='ApiName', description='The operation performed.', example='CreateLoadBalancer'),
      createTime?: long(name='CreateTime', description='The timestamp that indicates the start time of the task. Unit: milliseconds.

This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='2134663231234'),
      errorCode?: string(name='ErrorCode', description='If the **Status** parameter indicates Failed, an error code is returned.', example='506'),
      errorMessage?: string(name='ErrorMessage', description='If the **Status** parameter indicates Failed, an error message is returned.', example='AllocateEipAddress Failed'),
      id?: string(name='Id', description='The ID of the task.', example='365F4154-92F6-4AE4-92F8-7FF34B5****'),
      modifyTime?: long(name='ModifyTime', description='The timestamp that indicates the end time of the task. Unit: milliseconds.

This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='2144663233315'),
      operateType?: string(name='OperateType', description='The operation type. Valid values:

*   **Create**: creation
*   **Update**: modification
*   **Delete**: deletion', example='Create'),
      resourceId?: string(name='ResourceId', description='The ID of the associated resource.', example='alb-o8mszt95oamfjy****'),
      resourceType?: string(name='ResourceType', description='The type of the associated resource. Valid values:

*   **loadbalancer**: an ALB instance
*   **listener**: a listener
*   **rule**: a forwarding rule
*   **acl**: a network ACL
*   **securitypolicy**: a security policy
*   **servergroup**: a server group', example='acl'),
      status?: string(name='Status', description='The status of the task. Valid values:

*   **Succeeded**: The task is successful.
*   **Failed**: The task failed.
*   **Processing**: The task is being processed.', example='Succeeded'),
    }
  ](name='Jobs', description='The list of tasks.'),
  maxResults?: long(name='MaxResults', description='The number of entries returned per page.', example='10'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

*   If **NextToken** is empty, it indicates that no next query is to be sent.
*   If a value of **NextToken** is returned, the value is the token that is used for the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
  totalCount?: long(name='TotalCount', description='The number of entries returned.', example='1000'),
}

model ListAsynJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAsynJobsResponseBody(name='body'),
}

async function listAsynJobsWithOptions(request: ListAsynJobsRequest, runtime: Util.RuntimeOptions): ListAsynJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiName)) {
    query['ApiName'] = request.apiName;
  }
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.jobIds)) {
    query['JobIds'] = request.jobIds;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAsynJobs',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAsynJobs(request: ListAsynJobsRequest): ListAsynJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAsynJobsWithOptions(request, runtime);
}

model ListHealthCheckTemplatesRequest {
  healthCheckTemplateIds?: [ string ](name='HealthCheckTemplateIds', description='The IDs of health check templates.'),
  healthCheckTemplateNames?: [ string ](name='HealthCheckTemplateNames', description='The health check templates.'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.', example='50'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   You do not need to specify this parameter for the first request.
*   You must specify the token that is obtained from the previous query as the value of **NextToken**.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
}

model ListHealthCheckTemplatesResponseBody = {
  healthCheckTemplates?: [ 
    {
      healthCheckCodes?: [ string ](name='HealthCheckCodes', description='The status code.'),
      healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The port that is used for health checks.

Valid values: \\*\\* 0 to 65535\\*\\*.

Default value: **0**. If you set the value to 0, the port of a backend server is used for health checks.', example='80'),
      healthCheckHost?: string(name='HealthCheckHost', description='The domain name that is used for health checks. Valid values:

**$SERVER_IP** (default): the private IP addresses of backend servers. If you do not set the HealthCheckHost parameter or set the parameter to $SERVER_IP, the Application Load Balancer (ALB) uses the private IP addresses of backend servers for health checks.

**domain**: The domain name must be 1 to 80 characters in length and can contain letters, digits, periods (.), and hyphens (-).

> This parameter is valid only if the `HealthCheckProtocol` parameter is set to **HTTP**.', example='$_ip'),
      healthCheckHttpVersion?: string(name='HealthCheckHttpVersion', description='The HTTP version that is used for health checks.

Valid values: **HTTP 1.0** and **HTTP 1.1**.

Default value: **HTTP 1.1**.

> This parameter is valid only if the `HealthCheckProtocol` parameter is set to **HTTP**.', example='HTTP 1.0'),
      healthCheckInterval?: int32(name='HealthCheckInterval', description='The interval at which health checks are performed. Unit: seconds. Valid values: **1 to 50**. Default value: **2**.', example='5'),
      healthCheckMethod?: string(name='HealthCheckMethod', description='The method that you want to use for the health check. Valid values:

*   **HEAD**: By default, the ALB instance sends HEAD requests to a backend server to perform HTTP health checks.
*   **GET**: If the length of a response exceeds 8 KB, the response is truncated. However, the health check result is not affected.
*   **POST**: gRPC health checks automatically use the POST method.

> This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP** or **gRPC**.', example='HEAD'),
      healthCheckPath?: string(name='HealthCheckPath', description='The URL that is used for health checks.

The URL must be 1 to 80 characters in length and can contain only letters, digits, hyphens (-), forward slashes (/), periods (.), percent signs (%), question marks (?), number signs (#), and ampersands (&). The URL can also contain the following extended characters: `_ ; ~ ! ( ) * [ ] @ $ ^ : \\" , +`. The URL must start with a forward slash (/).', example='/test/index.html'),
      healthCheckProtocol?: string(name='HealthCheckProtocol', description='The protocol that you want to use for health checks. Valid values:

*   **HTTP** (default): To perform HTTP health checks, ALB sends HEAD or GET requests to a backend server to check whether the backend server is healthy.
*   **TCP**: To perform TCP health checks, ALB sends SYN packets to a backend server to check whether the port of the backend server is available to receive requests.
*   **gRPC**: To perform gRPC health checks, ALB sends POST or GET requests to a backend server to check whether the backend server is healthy.', example='HTTP'),
      healthCheckTemplateId?: string(name='HealthCheckTemplateId', description='The ID of the health check template.', example='hct-bp1qjwo61pqz3ahltv****'),
      healthCheckTemplateName?: string(name='HealthCheckTemplateName', description='The name of the health check template.

The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.', example='HealthCheckTemplate1'),
      healthCheckTimeout?: int32(name='HealthCheckTimeout', description='The timeout period of a health check response. If a backend Elastic Compute Service (ECS) instance does not return a health check response within the specified timeout period, the server fails the health check.

Valid values: **1 to 300**. Unit: seconds.

Default value: **5**.

> If the value of the **HealthCheckTimeout** parameter is smaller than that of the **HealthCheckInterval** parameter, the timeout period specified by the **HealthCheckTimeout** parameter is ignored and the value of the **HealthCheckInterval** parameter is used as the timeout period.', example='3'),
      healthyThreshold?: int32(name='HealthyThreshold', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**.

Valid values: **2 to 10**.

Default value: **3**.', example='4'),
      unhealthyThreshold?: int32(name='UnhealthyThreshold', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**.

Valid values: **2 to 10**.

Default value: **3**.', example='4'),
    }
  ](name='HealthCheckTemplates', description='The health check templates.'),
  maxResults?: int32(name='MaxResults', description='The number of entries returned per page. Valid values: **1** to **100**. Default value: **20**.', example='50'),
  nextToken?: string(name='NextToken', description='The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value of **NextToken** was returned in the previous query, specify the value to obtain the next set of results.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The request ID.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1000'),
}

model ListHealthCheckTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListHealthCheckTemplatesResponseBody(name='body'),
}

async function listHealthCheckTemplatesWithOptions(request: ListHealthCheckTemplatesRequest, runtime: Util.RuntimeOptions): ListHealthCheckTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.healthCheckTemplateIds)) {
    query['HealthCheckTemplateIds'] = request.healthCheckTemplateIds;
  }
  if (!Util.isUnset(request.healthCheckTemplateNames)) {
    query['HealthCheckTemplateNames'] = request.healthCheckTemplateNames;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHealthCheckTemplates',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHealthCheckTemplates(request: ListHealthCheckTemplatesRequest): ListHealthCheckTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHealthCheckTemplatesWithOptions(request, runtime);
}

model ListListenerCertificatesRequest {
  certificateType?: string(name='CertificateType', description='The token that is used for the next query. Valid values:

*   If **NextToken** is empty, it indicates that no next query is to be sent.
*   If **NextToken** is not empty, the value indicates the token that is used for the next query.', example='Server'),
  listenerId?: string(name='ListenerId', description='The maximum number of entries returned.', example='lsr-bp1bpn0kn908w4nbw****'),
  maxResults?: int32(name='MaxResults', description='The type of the certificate. Valid values: **Ca** and **Server**.', example='50'),
  nextToken?: string(name='NextToken', description='The ID of the listener. You must specify the ID of an HTTPS listener or a QUIC listener.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
}

model ListListenerCertificatesResponseBody = {
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId', description='Indicates whether the certificate is associated with the listener. Valid values:

*   **Associating**: The certificate is being associated with the listener.
*   **Associated**: The certificate is associated with the listener.
*   **Diassociating**: The certificate is being disassociated from the listener.', example='12315790343_166f8204689_1714763408_70998****'),
      certificateType?: string(name='CertificateType', example='Server'),
      isDefault?: boolean(name='IsDefault', description='The type of the certificate.', example='true'),
      status?: string(name='Status', example='Associating'),
    }
  ](name='Certificates', description='Indicates whether the certificate is the default certificate of the listener. Valid values:

*   **true**: the default certificate
*   **false**: an additional certificate'),
  maxResults?: int32(name='MaxResults', description='The ID of the request.', example='50'),
  nextToken?: string(name='NextToken', description='The total number of entries returned.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The list of certificates.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
  totalCount?: int32(name='TotalCount', description='The ID of the certificate. Only server certificates are supported.', example='1000'),
}

model ListListenerCertificatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListListenerCertificatesResponseBody(name='body'),
}

async function listListenerCertificatesWithOptions(request: ListListenerCertificatesRequest, runtime: Util.RuntimeOptions): ListListenerCertificatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateType)) {
    query['CertificateType'] = request.certificateType;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListListenerCertificates',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listListenerCertificates(request: ListListenerCertificatesRequest): ListListenerCertificatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenerCertificatesWithOptions(request, runtime);
}

model ListListenersRequest {
  listenerIds?: [ string ](name='ListenerIds', description='The listener IDs. You can specify up to 20 IDs.'),
  listenerProtocol?: string(name='ListenerProtocol', description='The listener protocol. Valid values:

*   **HTTP**
*   **HTTPS**
*   **QUIC**', example='HTTP'),
  loadBalancerIds?: [ string ](name='LoadBalancerIds', description='The Server Load Balancer (SLB) instance IDs. You can specify up to 20 IDs.'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries to return. This parameter is optional. Valid values: **1 to 100**. If you do not specify this parameter, the default value **20** is used.', example='50'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   You do not need to specify this parameter for the first request.
*   You must specify the token that is obtained from the previous query as the value of **NextToken**.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
}

model ListListenersResponseBody = {
  listeners?: [ 
    {
      defaultActions?: [ 
        {
          forwardGroupConfig?: {
            serverGroupTuples?: [ 
              {
                serverGroupId?: string(name='ServerGroupId', description='The ID of the server group to which requests are forwarded.', example='rsp-cige6j****'),
              }
            ](name='ServerGroupTuples', description='The server groups to which requests are forwarded.'),
          }(name='ForwardGroupConfig', description='The configuration of the forwarding action. This parameter is returned and takes effect only if the action type is **FowardGroup**.'),
          type?: string(name='Type', description='The type of the action. If **ForwardGroup** is returned, requests are forwarded to multiple vServer groups.', example='ForwardGroup'),
        }
      ](name='DefaultActions', description='The actions of the default forwarding rule.'),
      gzipEnabled?: boolean(name='GzipEnabled', description='Indicates whether GZIP compression is enabled to compress specific types of files. Valid values:

*   **true**
*   **false**', example='false'),
      http2Enabled?: boolean(name='Http2Enabled', description='Indicates whether HTTP/2 is enabled. Valid values:

*   **true**
*   **false**

> This parameter is available only when you create an HTTPS listener.', example='false'),
      idleTimeout?: int32(name='IdleTimeout', description='The timeout period of an idle connection. Unit: seconds. Valid values: **1 to 60**.

If no request is received within the specified timeout period, SLB closes the connection. SLB establishes the connection again when a new connection request is received.', example='3'),
      listenerDescription?: string(name='ListenerDescription', description='The description of the listener. The description must be 2 to 256 characters in length.', example='test'),
      listenerId?: string(name='ListenerId', description='The listener ID.', example='lsr-bp1bpn0kn908w4nbw****'),
      listenerPort?: int32(name='ListenerPort', description='The frontend port that is used by the SLB instance. Valid values: **1 to 65535**.', example='80'),
      listenerProtocol?: string(name='ListenerProtocol', description='The listener protocol. Valid values:

*   **HTTP**
*   **HTTPS**
*   **QUIC**', example='HTTP'),
      listenerStatus?: string(name='ListenerStatus', description='The status of the listener. Valid values:

*   **Provisioning**
*   **Running**
*   **Configuring**
*   **Stopped**', example='Running'),
      loadBalancerId?: string(name='LoadBalancerId', description='The SLB instance ID.', example='lb-bp1b6c719dfa08ex*****'),
      logConfig?: {
        accessLogRecordCustomizedHeadersEnabled?: boolean(name='AccessLogRecordCustomizedHeadersEnabled', description='Indicates whether custom headers are carried in the access log. Valid values:

*   **true**
*   **false**', example='true'),
        accessLogTracingConfig?: {
          tracingEnabled?: boolean(name='TracingEnabled', description='Indicates whether Xtrace is enabled. Valid values:

*   **true**
*   **false**

> You can set this parameter to **true** only if the access log feature is enabled by specifying **AccessLogEnabled**.', example='true'),
          tracingSample?: int32(name='TracingSample', description='The sampling rate of Xtrace. Valid values: **1 to 10000**.

> This parameter takes effect only if **TracingEnabled** is set to **true**.', example='100'),
          tracingType?: string(name='TracingType', description='The Xtrace type. This parameter can be set to **Zipkin**.

> This parameter takes effect only if **TracingEnabled** is set to **true**.', example='Zipkin'),
        }(name='AccessLogTracingConfig', description='The configuration of Xtrace that is used to record the requests sent to SLB.'),
      }(name='LogConfig', description='The logging configuration.'),
      quicConfig?: {
        quicListenerId?: string(name='QuicListenerId', description='The QUIC listener ID. This parameter is returned when **QuicUpgradeEnabled** is set to **true**. Only HTTPS listeners support this parameter.

> You must add the HTTPS listener and the QUIC listener to the same ALB instance. In addition, make sure that the QUIC listener has never been associated with another listener.', example='lsr-bp1bpn908w4nbw****'),
        quicUpgradeEnabled?: boolean(name='QuicUpgradeEnabled', description='Indicates whether QUIC upgrade is enabled. Valid values:

*   **true**
*   **false**

> Only HTTPS listeners support this parameter.', example='true'),
      }(name='QuicConfig', description='The configuration information when the listener is associated with a QUIC listener.'),
      requestTimeout?: int32(name='RequestTimeout', description='The timeout period of a request. Unit: seconds. Valid values: **1 to 180**.

If no responses are received from the backend server within the specified timeout period, SLB returns an `HTTP 504` error code to the client.', example='34'),
      securityPolicyId?: string(name='SecurityPolicyId', description='The security policy.

> This parameter is available only when you create an HTTPS listener.', example='tls_cipher_policy_1_1'),
      XForwardedForConfig?: {
        XForwardedForClientCertClientVerifyAlias?: string(name='XForwardedForClientCertClientVerifyAlias', description='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertClientVerifyEnabled** is set to **true**.

The name is 1 to 40 characters in length, and can contain letters, digits, hyphens (-), and underscores (\\_).

> This parameter is available only when you create an HTTPS listener.', example='test_client-verify-alias_123456'),
        XForwardedForClientCertClientVerifyEnabled?: boolean(name='XForwardedForClientCertClientVerifyEnabled', description='Indicates whether the `X-Forwarded-Clientcert-clientverify` header is used to obtain the verification result of the client certificate. Valid values:

*   **true**
*   **false**

> This parameter is available only when you create an HTTPS listener.', example='true'),
        XForwardedForClientCertFingerprintAlias?: string(name='XForwardedForClientCertFingerprintAlias', description='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertFingerprintEnabled** is set to **true**.

The name is 1 to 40 characters in length, and can contain letters, digits, hyphens (-), and underscores (\\_).

> This parameter is available only when you create an HTTPS listener.', example='test_finger-print-alias_123456'),
        XForwardedForClientCertFingerprintEnabled?: boolean(name='XForwardedForClientCertFingerprintEnabled', description='Indicates whether the `X-Forwarded-Clientcert-fingerprint` header is used to retrieve the fingerprint of the client certificate. Valid values:

*   **true**
*   **false**

> This parameter is available only when you create an HTTPS listener.', example='true'),
        XForwardedForClientCertIssuerDNAlias?: string(name='XForwardedForClientCertIssuerDNAlias', description='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertIssuerDNEnabled** is set to **true**.

The name is 1 to 40 characters in length, and can contain letters, digits, hyphens (-), and underscores (\\_).

> This parameter is available only when you create an HTTPS listener.', example='test_issue-dn-alias_123456'),
        XForwardedForClientCertIssuerDNEnabled?: boolean(name='XForwardedForClientCertIssuerDNEnabled', description='Indicates whether the `X-Forwarded-Clientcert-issuerdn` header is used to retrieve information about the authority that issues the client certificate. Valid values:

*   **true**
*   **false**

> This parameter is available only when you create an HTTPS listener.', example='true'),
        XForwardedForClientCertSubjectDNAlias?: string(name='XForwardedForClientCertSubjectDNAlias', description='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertSubjectDNEnabled** is set to **true**.

The name is 1 to 40 characters in length, and can contain letters, digits, hyphens (-), and underscores (\\_).

> This parameter is available only when you create an HTTPS listener.', example='test_subject-dn-alias_123456'),
        XForwardedForClientCertSubjectDNEnabled?: boolean(name='XForwardedForClientCertSubjectDNEnabled', description='Indicates whether the `X-Forwarded-Clientcert-subjectdn` header is used to retrieve information about the owner of the client certificate. Valid values:

*   **true**
*   **false**

> This parameter is available only when you create an HTTPS listener.', example='true'),
        XForwardedForClientSourceIpsEnabled?: boolean(name='XForwardedForClientSourceIpsEnabled', description='Indicates whether the `X-Forwarded-Client-Ip` header is used to retrieve the source port of the SLB instance. Valid values:

*   **true**
*   **false**

> HTTP, HTTPS, and QUIC listeners support this parameter.', example='false'),
        XForwardedForClientSourceIpsTrusted?: string(name='XForwardedForClientSourceIpsTrusted', description='The trusted proxy IP address.

ALB traverses `X-Forwarded-For` backward and selects the first IP address that is not in the trusted IP address list as the real IP address of the client. The IP address is used in source IP address throttling.', example='10.1.1.0/24'),
        XForwardedForClientSrcPortEnabled?: boolean(name='XForwardedForClientSrcPortEnabled', description='Indicates whether the `X-Forwarded-Client-Port` header is used to retrieve the client port. Valid values:

*   **true**
*   **false**

> HTTP and HTTPS listeners support this parameter.', example='true'),
        XForwardedForEnabled?: boolean(name='XForwardedForEnabled', description='Indicates whether the `X-Forwarded-For` header is used to retrieve the client IP address. Valid values:

*   **true**
*   **false**

> HTTP and HTTPS listeners support this parameter.', example='true'),
        XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled', description='Indicates whether the `X-Forwarded-Proto` header is used to retrieve the listener protocol. Valid values:

*   **true**
*   **false**

> HTTP, HTTPS, and QUIC listeners support this parameter.', example='true'),
        XForwardedForSLBIdEnabled?: boolean(name='XForwardedForSLBIdEnabled', description='Indicates whether the `SLB-ID` header is used to retrieve the ID of the SLB instance. Valid values:

*   **true**
*   **false**

> HTTP, HTTPS, and QUIC listeners support this parameter.', example='true'),
        XForwardedForSLBPortEnabled?: boolean(name='XForwardedForSLBPortEnabled', description='Indicates whether the `X-Forwarded-Port` header is used to retrieve the listener port of the SLB instance. Valid values:

*   **true**
*   **false**

> HTTP, HTTPS, and QUIC listeners support this parameter.', example='true'),
      }(name='XForwardedForConfig', description='The configuration of the `XForward` headers.'),
    }
  ](name='Listeners', description='The listeners.'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='50'),
  nextToken?: string(name='NextToken', description='The position where the query stopped. If this parameter is not returned, all data is queried.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The request ID.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1000'),
}

model ListListenersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListListenersResponseBody(name='body'),
}

async function listListenersWithOptions(request: ListListenersRequest, runtime: Util.RuntimeOptions): ListListenersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerIds)) {
    query['ListenerIds'] = request.listenerIds;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerIds)) {
    query['LoadBalancerIds'] = request.loadBalancerIds;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListListeners',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listListeners(request: ListListenersRequest): ListListenersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenersWithOptions(request, runtime);
}

model ListLoadBalancersRequest {
  addressType?: string(name='AddressType', description='The network type. Valid values:

*   **Internet**: The ALB instance uses a public IP address. The domain name of the ALB instance is resolved to the public IP address. Therefore, the ALB instance can be accessed over the Internet.
*   **Intranet**: The ALB instance uses a private IP address. The domain name of the ALB instance is resolved to the private IP address. In this case, the ALB instance can be accessed over the VPC where the ALB instance is deployed.', example='Intranet'),
  loadBalancerBussinessStatus?: string(name='LoadBalancerBussinessStatus', description='The service status of the ALB instance. Valid values:

*   **Abnormal**
*   **Normal**', example='Normal'),
  loadBalancerIds?: [ string ](name='LoadBalancerIds', description='The instance IDs. You can specify at most 20 ALB instance IDs.'),
  loadBalancerNames?: [ string ](name='LoadBalancerNames', description='The names of the instances. You can specify at most 10 names.'),
  loadBalancerStatus?: string(name='LoadBalancerStatus', description='The status of the ALB instance. Valid values:

*   **Inactive**: The ALB instance is disabled. The listeners do not forward traffic.
*   **Active**: The ALB instance is running.
*   **Provisioning**: The ALB instance is being created.
*   **Configuring**: The ALB instance is being modified.
*   **CreateFailed**: The system failed to create the ALB instance. In this case, you are not charged for the ALB instance. You can only delete the ALB instance. By default, the system deletes the ALB instances that are in the CreateFailed state within the last day.', example='Active'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.', example='20'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   You do not need to specify this parameter for the first request.
*   You must specify the token that is obtained from the previous query as the value of **NextToken**.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  payType?: string(name='PayType', description='The billing method of the ALB instance. Set the value to

**PostPay**, which specifies the pay-as-you-go billing method. This is the default value.', example='PostPay'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmxazb4ph****'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. You can specify at most 20 tag keys. The tag key cannot be an empty string.

The tag key can be up to 64 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.', example='KeyTest'),
      value?: string(name='Value', description='The tag value. You can specify at most 20 tag values. The tag value can be an empty string.

The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.', example='alueTest'),
    }
  ](name='Tag', description='The tags added to the ALB instance.'),
  vpcIds?: [ string ](name='VpcIds', description='The ID of the virtual private cloud (VPC) to which the ALB instance belongs. You can specify at most 10 IDs.'),
  zoneId?: string(name='ZoneId', description='The ID of the zone where the ALB instance is deployed.

You can call the [DescribeZones](~~189196~~) operation to query zones.', example='cn-hangzhou-a'),
}

model ListLoadBalancersResponseBody = {
  loadBalancers?: [ 
    {
      accessLogConfig?: {
        logProject?: string(name='LogProject', description='The log project.', example='sls-setter'),
        logStore?: string(name='LogStore', description='The Logstore.', example='test'),
      }(name='AccessLogConfig', description='The configuration of the access log.'),
      addressAllocatedMode?: string(name='AddressAllocatedMode', description='The mode in which IP addresses are allocated. Valid values:

*   **Fixed**: allocates a static IP address to the ALB instance.
*   **Dynamic**: dynamically allocates an IP address to each zone of the ALB instance.', example='Fixed'),
      addressIpVersion?: string(name='AddressIpVersion', description='The IP version. Valid values:

*   **IPv4**
*   **DualStack**', example='DualStack'),
      addressType?: string(name='AddressType', description='The type of IP address that the ALB instance uses to provide services. Valid values:

*   **Internet**: The ALB instance uses a public IP address. The domain name of the ALB instance is resolved to the public IP address. Therefore, the ALB instance can be accessed over the Internet.
*   **Intranet**: The ALB instance uses a private IP address. The domain name of the ALB instance is resolved to the private IP address. In this case, the ALB instance can be accessed over the VPC where the ALB instance is deployed.', example='Intranet'),
      bandwidthPackageId?: string(name='BandwidthPackageId', description='The ID of the EIP bandwidth plan that is associated with the NLB instance if the NLB instance uses a public IP address.', example='cbwp-bp1vevu8h3ieh****'),
      createTime?: string(name='CreateTime', description='The time when the resource was created.', example='2022-07-02T02:49:05Z'),
      DNSName?: string(name='DNSName', description='The domain name of the ALB instance.', example='alb-95qnr2itwu9orb****.cn-hangzhou.alb.aliyuncs.com'),
      deletionProtectionConfig?: {
        enabled?: boolean(name='Enabled', description='Indicates whether deletion protection is enabled. Valid values:

*   **true**
*   **false**', example='true'),
        enabledTime?: string(name='EnabledTime', description='The time when deletion protection is enabled.', example='2022-08-02T02:49:05Z'),
      }(name='DeletionProtectionConfig', description='The configuration of deletion protection.'),
      ipv6AddressType?: string(name='Ipv6AddressType', description='The type of IPv6 address that is used by the ALB instance. Valid values:

*   **Internet**: The ALB instance uses a public IP address. The domain name of the ALB instance is resolved to the public IP address. Therefore, the ALB instance can be accessed over the Internet.
*   **Intranet**: The ALB instance uses a private IP address. The domain name of the ALB instance is resolved to the private IP address. Therefore, the ALB instance can be accessed over the VPC in which the ALB instance is deployed.', example='Intranet'),
      loadBalancerBillingConfig?: {
        payType?: string(name='PayType', description='The billing method. Valid values:

Only **PostPay** may be returned, which indicates the pay-as-you-go billing method.', example='PostPay'),
      }(name='LoadBalancerBillingConfig', description='The configuration of the billing method.'),
      loadBalancerBussinessStatus?: string(name='LoadBalancerBussinessStatus', description='The business status of the ALB instance. Valid values:

*   **Abnormal**
*   **Normal**', example='Normal'),
      loadBalancerEdition?: string(name='LoadBalancerEdition', description='The edition of the ALB instance. Different editions have different limits and support different billing methods. Valid values:

*   **Basic**: basic
*   **Standard**: standard
*   **StandardWithWaf**: WAF-enabled', example='Standard'),
      loadBalancerId?: string(name='LoadBalancerId', description='The ID of the ALB instance.', example='alb-o9ulmq5hgn68jk****'),
      loadBalancerName?: string(name='LoadBalancerName', description='The name of the NLB instance.', example='alb-instance-test'),
      loadBalancerOperationLocks?: [ 
        {
          lockReason?: string(name='LockReason', description='The reason why the ALB instance is locked. This parameter is available only when **LoadBalancerBussinessStatus** is set to **Abnormal**.'),
          lockType?: string(name='LockType', description='The lock type. Valid values:

*   **SecurityLocked**: The ALB instance is locked due to security reasons.
*   **RelatedResourceLocked**: The ALB instance is locked due to association issues.
*   **FinancialLocked**: The ALB instance is locked due to overdue payments.
*   **ResidualLocked**: The ALB instance is locked because the associated resources have overdue payments and the resources are released.', example='FinancialLocked'),
        }
      ](name='LoadBalancerOperationLocks', description='The configuration of the operation lock.'),
      loadBalancerStatus?: string(name='LoadBalancerStatus', description='The status of the ALB instance. Valid values:

*   **Inactive**: The ALB instance is disabled. The listeners do not forward traffic.
*   **Active**: The ALB instance is running.
*   **Provisioning**: The ALB instance is being created.
*   **Configuring**: The ALB instance is being modified.
*   **CreateFailed**: The system failed to create the ALB instance.', example='Active'),
      modificationProtectionConfig?: {
        reason?: string(name='Reason', description='The reason why deletion protection is enabled.

It must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). It must start with a letter.

This parameter takes effect only when **ModificationProtectionStatus** is set to **ConsoleProtection**.'),
        status?: string(name='Status', description='Indicates whether the configuration read-only mode is enabled for the ALB instance. Valid values:

*   **NonProtection**: The configuration read-only mode is disabled. In this case, you cannot specify ModificationProtectionReason. If you specify ModificationProtectionReason, the value of the parameter is cleared.
*   **ConsoleProtection**: The configuration read-only mode is enabled. In this case, you can specify ModificationProtectionReason.

> If you set this parameter to **ConsoleProtection**, you cannot use the ALB console to modify instance configurations. However, you can call API operations to modify instance configurations.', example='ConsoleProtection'),
      }(name='ModificationProtectionConfig', description='The configuration read-only mode.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-atstuj3rtop****'),
      tags?: [ 
        {
          key?: string(name='Key', description='The tag key.', example='KeyTest'),
          value?: string(name='Value', description='The tag value.', example='alueTest'),
        }
      ](name='Tags', description='The tags that are added to the instance.'),
      vpcId?: string(name='VpcId', description='The ID of the VPC to which the ALB instance belongs.', example='vpc-bp1b49rqrybk45nio****'),
    }
  ](name='LoadBalancers', description='The list of ALB instances.'),
  maxResults?: int32(name='MaxResults', description='The number of entries returned per page.', example='20'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value is returned for **NextToken**, the value is used to retrieve a new page of results.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The request ID.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
}

model ListLoadBalancersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLoadBalancersResponseBody(name='body'),
}

async function listLoadBalancersWithOptions(request: ListLoadBalancersRequest, runtime: Util.RuntimeOptions): ListLoadBalancersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addressType)) {
    query['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.loadBalancerBussinessStatus)) {
    query['LoadBalancerBussinessStatus'] = request.loadBalancerBussinessStatus;
  }
  if (!Util.isUnset(request.loadBalancerIds)) {
    query['LoadBalancerIds'] = request.loadBalancerIds;
  }
  if (!Util.isUnset(request.loadBalancerNames)) {
    query['LoadBalancerNames'] = request.loadBalancerNames;
  }
  if (!Util.isUnset(request.loadBalancerStatus)) {
    query['LoadBalancerStatus'] = request.loadBalancerStatus;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vpcIds)) {
    query['VpcIds'] = request.vpcIds;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLoadBalancers',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLoadBalancers(request: ListLoadBalancersRequest): ListLoadBalancersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLoadBalancersWithOptions(request, runtime);
}

model ListRulesRequest {
  direction?: string(name='Direction', description='The direction to which the forwarding rule is applied. Valid values:

*   **Request** (default): The forwarding rule is applied to the client requests received by ALB.
*   **Response**: The forwarding rule is applied to the responses returned by backend servers.

> You cannot set this parameter to Response if you use basic ALB instances.', example='Request'),
  listenerIds?: [ string ](name='ListenerIds', description='The listener IDs.'),
  loadBalancerIds?: [ string ](name='LoadBalancerIds', description='The Application Load Balancer (ALB) instance IDs.'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries to return.

Valid values: **1 to 100**.

Default value: **20**. If you do not specify this parameter, the default value is used.

> This parameter is optional.', example='20'),
  nextToken?: string(name='NextToken', description='The starting point of the current query. If you do not specify this parameter, the query starts from the beginning.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  ruleIds?: [ string ](name='RuleIds', description='The forwarding rules.'),
}

model ListRulesResponseBody = {
  maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='50'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value is returned for **NextToken**, the value is the token that determines the start point of the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The request ID.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
  rules?: [ 
    {
      direction?: string(name='Direction', description='

* RequestALB

* ResponseALB

> ALBResponse'),
      listenerId?: string(name='ListenerId', description='The ID of the listener to which the forwarding rule belongs.', example='lsn-i35udpz3pxsmnf****'),
      loadBalancerId?: string(name='LoadBalancerId', description='The ID of the ALB instance to which the forwarding rule belongs.', example='alb-x30o38azsuj0sx****'),
      priority?: int32(name='Priority', description='The priority of the forwarding rule. Valid values: **1 to 10000**. A lower value indicates a higher priority.

> The priority of each forwarding rule added to a listener must be unique.', example='1'),
      ruleActions?: [ 
        {
          corsConfig?: {
            allowCredentials?: string(name='AllowCredentials', description='Indicates whether credentials can be carried in CORS requests. Valid values:

*   **on**
*   **off**', example='on'),
            allowHeaders?: [ string ](name='AllowHeaders', description='The allowed headers for CORS requests.'),
            allowMethods?: [ string ](name='AllowMethods', description='The allowed HTTP methods for CORS requests.'),
            allowOrigin?: [ string ](name='AllowOrigin', description='The origin sites that are allowed.'),
            exposeHeaders?: [ string ](name='ExposeHeaders', description='The headers that can be exposed.'),
            maxAge?: long(name='MaxAge', description='The maximum cache time of preflight requests in the browser. Unit: seconds.

Valid values: **-1** to **172800**.', example='1000'),
          }(name='CorsConfig', description='The CORS configuration.'),
          fixedResponseConfig?: {
            content?: string(name='Content', description='The content of the custom response. The content is up to 1 KB in size, and can contain only ASCII characters.', example='dssacav'),
            contentType?: string(name='ContentType', description='The format of the response.

Valid values: **text/plain**, **text/css**, **text/html**, **application/javascript**, and **application/json**.', example='text/plain'),
            httpCode?: string(name='HttpCode', description='The HTTP status code in the response. Valid values: **HTTP\\_2xx**, **HTTP\\_4xx**, and **HTTP\\_5xx**. **x** must be a digit.', example='HTTP_2xx'),
          }(name='FixedResponseConfig', description='The configuration of the custom response.'),
          forwardGroupConfig?: {
            serverGroupTuples?: [ 
              {
                serverGroupId?: string(name='ServerGroupId', description='The server group to which requests are forwarded.', example='sg-atstuj3rtoptyui****'),
                weight?: int32(name='Weight', description='The weight. Valid values: **0** to **100**.', example='2'),
              }
            ](name='ServerGroupTuples', description='The server groups to which requests are forwarded.'),
          }(name='ForwardGroupConfig', description='The configurations of the server groups.'),
          insertHeaderConfig?: {
            key?: string(name='Key', description='The key of the header to be inserted. The key must be 1 to 40 characters in length, and can contain letters, digits, underscores (\\_), and hyphens (-). The key specified in `InsertHeader` must be unique.

> : **Cookie** and **Host** are not supported.', example='key'),
            value?: string(name='Value', description='The value of the header to be inserted.

*   If **ValueType** is set to **SystemDefined**, one of the following header values is supported:

    *   **ClientSrcPort**: the client port.
    *   **ClientSrcIp**: the client IP address.
    *   **Protocol**: the request protocol (HTTP or HTTPS).
    *   **SLBId**: the ALB instance ID.
    *   **SLBPort**: the listener port.

*   If **ValueType** is set to **UserDefined**, you can specify a custom header value. The header value must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and lower than 127`. You can use asterisks (\\*) and question marks (?) as wildcards. The value cannot start or end with a space character.

*   If **ValueType** is set to **ReferenceHeader**, you can reference one of the request headers. The header value must be 1 to 128 characters in length, and can contain lowercase letters, digits, underscores (\\_), and hyphens (-).', example='ClientSrcPort'),
            valueType?: string(name='ValueType', description='The type of the header. Valid values:

*   **UserDefined:** a user-defined header.
*   **ReferenceHeader:** a header that is referenced from a request header.
*   **SystemDefined:** a system-defined header.', example='SystemDefined'),
          }(name='InsertHeaderConfig', description='The configuration of the header to be inserted.'),
          order?: int32(name='Order', description='The priority of the action. Valid values: **1 to 50000**. A lower value indicates a higher priority. The actions of a forwarding rule are applied in descending order of priority. This parameter is not empty. The priority of each action within a forwarding rule is unique.', example='1'),
          redirectConfig?: {
            host?: string(name='Host', description='The hostname to which requests are redirected. Valid values:

*   **${host}** (default): If you set the value to ${host}, you cannot append other characters.

*   A custom value that meets the following requirements:

    *   The hostname is 3 to 128 characters in length, and can contain lowercase letters, digits, hyphens (-), and periods (.). Asterisks (\\*) and question marks (?) can be used as wildcards.
    *   The hostname contains at least one period (.) but does not start or end with a period (.).
    *   The rightmost domain label contains only letters and wildcard characters. It does not contain digits or hyphens (-).
    *   The domain labels do not start or end with hyphens (-).
    *   You can use asterisks (\\*) and question marks (?) anywhere in a domain label as wildcard characters.', example='www.example.com'),
            httpCode?: string(name='HttpCode', description='The redirect type. Valid values: **301**, **302**, **303**, **307**, and **308**.', example='301'),
            path?: string(name='Path', description='The path to which requests are redirected. Valid values:

*   **${path}** (default): You can reference \\*\\*${host}**, **${protocol}**, and**${port}**. The path can consist of **${host}**,**${protocol}**, and **${port}\\*\\*. Each variable can be used only once. You can specify one or more of the preceding variables in each request. You can also combine them with a custom value.

*   A custom value that meets the following requirements:

    *   The value is 1 to 128 characters in length.
    *   It must start with a forward slash (/) and can contain letters, digits, and the following special characters: `$ - _ .+ / & ~ @ :`. It cannot contain the following special characters: `" % # ; ! ( ) [ ] ^ , "`. You can use asterisks (\\*) and question marks (?) as wildcards.', example='/test'),
            port?: string(name='Port', description='The port to which requests are redirected. Valid values:

*   **${port}** (default): If you set the value to ${port}, you cannot append other characters.
*   You can also enter a port number. Valid values: **1 to 63335**.', example='10'),
            protocol?: string(name='Protocol', description='The redirect protocol. Valid values:

*   **${protocol}** (default): If you set the value to ${protocol}, you cannot append other characters.
*   **HTTP** or **HTTPS**.

> HTTPS listeners support only HTTP to HTTPS redirection.', example='HTTP'),
            query?: string(name='Query', description='The query string to which requests are forwarded. The query string must be 1 to 128 characters in length, and can contain printable characters, excluding uppercase letters and the following special characters: `# [ ] { } \\ | < > &`.', example='quert'),
          }(name='RedirectConfig', description='The configuration of the redirect action.'),
          removeHeaderConfig?: {
            key?: string(name='Key', description='1\\~40a~z_-RemoveHeader

* DirectionRequest`slb-id``slb-ip``x-forwarded-for``x-forwarded-proto``x-forwarded-eip``x-forwarded-port``x-forwarded-client-srcport``connection``upgrade``content-length``transfer-encoding``keep-alive``te``host``cookie``remoteip``authority`
* DirectionResponse`connection``upgrade``content-length``transfer-encoding`'),
          }(name='RemoveHeaderConfig', description='HTTP'),
          rewriteConfig?: {
            host?: string(name='Host', description='The hostname to which requests are redirected. Valid values:

*   **${host}** (default): If you set the value to ${host}, you cannot append other characters.

*   A custom value that meets the following requirements:

    *   The hostname is 3 to 128 characters in length, and can contain lowercase letters, digits, hyphens (-), and periods (.). Asterisks (\\*) and question marks (?) can be used as wildcards.
    *   The hostname contains at least one period (.) but does not start or end with a period (.).
    *   The rightmost domain label contains only letters and wildcard characters. It does not contain digits or hyphens (-).
    *   The domain labels do not start or end with hyphens (-).
    *   You can use asterisks (\\*) and question marks (?) anywhere in a domain label as wildcard characters.', example='www.example.com'),
            path?: string(name='Path', description='The path to which requests are forwarded. The path is 1 to 128 characters in length and starts with a forward slash (/). The path can contain letters, digits, asterisks (\\*), question marks (?), and the following special characters: `$ - _ . + / & ~ @ :`. The path does not contain the following special characters: `" % # ; ! ( ) [ ] ^ , "`.', example='/tsdf'),
            query?: string(name='Query', description='The query string to which requests are forwarded. The query string must be 1 to 128 characters in length, and can contain printable characters, excluding uppercase letters and the following special characters: `# [ ] { } \\ | < > &`.', example='quedsa'),
          }(name='RewriteConfig', description='The configuration of the rewrite action.'),
          trafficLimitConfig?: {
            perIpQps?: int32(name='PerIpQps', description='The QPS of each IP address. Valid values: **1 to 100000**.

> If you specify this parameter and **QPS**, the value of **PerIpQps** must be smaller than the value of **QPS**.', example='80'),
            QPS?: int32(name='QPS', description='The number of queries per second (QPS). Valid values: **1** to **100000**.', example='4'),
          }(name='TrafficLimitConfig', description='The configuration of the action to throttle traffic.'),
          trafficMirrorConfig?: {
            mirrorGroupConfig?: {
              serverGroupTuples?: [ 
                {
                  serverGroupId?: string(name='ServerGroupId', description='The server group ID.', example='srg-00mkgijak0w4qgz9****'),
                  weight?: int32(name='Weight', description='The weight. Valid values: **0** to **100**.', example='2'),
                }
              ](name='ServerGroupTuples', description='The server group to which network traffic is mirrored.'),
            }(name='MirrorGroupConfig', description='The server groups to which network traffic is mirrored.'),
          }(name='TrafficMirrorConfig', description='The configuration of the action to mirror traffic.'),
          type?: string(name='Type', description='The action type. Valid values:

*   **ForwardGroup**: forwards a request to multiple vServer groups.
*   **Redirect**: redirects a request.
*   **FixedResponse**: returns a custom response.
*   **Rewrite**: rewrites a request.
*   **InsertHeader**: inserts a header.
*   **RemoveHeaderConfig**: deletes a header.
*   **TrafficLimitConfig**: throttles network traffic.
*   **TrafficMirrorConfig**: mirrors traffic.
*   **CorsConfig**: forwards requests based on CORS.

The following action types are supported:

*   **FinalType**: the last action to be performed in a forwarding rule. Each forwarding rule can contain only one FinalType action. You can specify a **ForwardGroup**, **Redirect**, or **FixedResponse** action as the FinalType action.
*   **ExtType**: the action or the actions to be performed before the **FinalType** action. A forwarding rule can contain one or more **ExtType** actions. To specify an ExtType action, you must specify a **FinalType** action. You can specify multiple **InsertHeader** actions or one **Rewrite** action.', example='ForwardGroup'),
        }
      ](name='RuleActions', description='The actions of the forwarding rule.'),
      ruleConditions?: [ 
        {
          cookieConfig?: {
            values?: [ 
              {
                key?: string(name='Key', description='The key of the cookie. The key is 1 to 100 characters in length, and can contain printable characters such as lowercase letters, asterisks (\\*), and question marks (?). The key cannot contain uppercase letters, space characters, or the following special characters: `# [ ] { } \\ | < > &`.', example='test'),
                value?: string(name='Value', description='The value of the cookie. The value is 1 to 128 characters in length, and can contain printable characters such as lowercase letters, asterisks (\\*), and question marks (?). Uppercase letters, space characters, and the following special characters are not supported: `# [ ] { } \\ | < > &`.', example='test'),
              }
            ](name='Values', description='The values of the cookie.'),
          }(name='CookieConfig', description='The configuration of the cookie.'),
          headerConfig?: {
            key?: string(name='Key', description='The key of the header. The key must be 1 to 40 characters in length. It can contain letters, digits, hyphens (-), and underscores (\\_). Cookie and Host are not supported.', example='Port'),
            values?: [ string ](name='Values', description='The values of the header.'),
          }(name='HeaderConfig', description='The configuration of the header.'),
          hostConfig?: {
            values?: [ string ](name='Values', description='The hostnames.'),
          }(name='HostConfig', description='The configurations of the hosts.'),
          methodConfig?: {
            values?: [ string ](name='Values', description='The request methods.'),
          }(name='MethodConfig', description='The configurations of the request methods.'),
          pathConfig?: {
            values?: [ string ](name='Values', description='The paths.'),
          }(name='PathConfig', description='The configurations of the paths.'),
          queryStringConfig?: {
            values?: [ 
              {
                key?: string(name='Key', description='They key of the query string. The key must be 1 to 100 characters in length, and can contain printable characters such as lowercase letters, asterisks (\\*), and question marks (?). The key cannot contain uppercase letters, space characters, or the following special characters: `# [ ] { } \\ | < > &`.', example='test'),
                value?: string(name='Value', description='The value of the query string. The value must be 1 to 128 characters in length, and can contain printable characters such as lowercase letters, asterisks (\\*), and question marks (?). However, uppercase letters, space characters, and the following special characters are not supported: `# [ ] { } \\ | < > &`.', example='test'),
              }
            ](name='Values', description='The query strings.'),
          }(name='QueryStringConfig', description='The configurations of the query strings.'),
          responseHeaderConfig?: {
            key?: string(name='Key', description='HTTP1\\~40a~z-_CookieHost'),
            values?: [ string ](name='Values', description='HTTP'),
          }(name='ResponseHeaderConfig', description='HTTP'),
          responseStatusCodeConfig?: {
            values?: [ string ](name='Values', description=''),
          }(name='ResponseStatusCodeConfig', description=''),
          sourceIpConfig?: {
            values?: [ string ](name='Values', description='The source IP addresses.'),
          }(name='SourceIpConfig', description='The configuration of the source IP addresses based on which user traffic is matched.'),
          type?: string(name='Type', description='The type of forwarding rule. Valid values:

*   **Host**: Requests are distributed based on hosts.
*   **Path**: Requests are distributed based on paths.
*   **Header**: Requests are distributed based on HTTP headers.
*   **QueryString**: Requests are distributed based on query strings.
*   **Method**: Requests are distributed based on request methods.
*   **Cookie**: Requests are distributed based on cookies.
*   **SourceIp**: Requests are distributed based on source IP addresses.', example='Host'),
        }
      ](name='RuleConditions', description='The match conditions of the forwarding rule.'),
      ruleId?: string(name='RuleId', description='The forwarding rule ID.', example='rule-bpn0kn908w4nbw****'),
      ruleName?: string(name='RuleName', description='The name of the forwarding rule. The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.', example='rule-instance-test'),
      ruleStatus?: string(name='RuleStatus', description='The status of the forwarding rule. Valid values:

*   **Provisioning**
*   **Configuring**
*   **Available**', example='Available'),
    }
  ](name='Rules', description='The forwarding rules.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1000'),
}

model ListRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRulesResponseBody(name='body'),
}

async function listRulesWithOptions(request: ListRulesRequest, runtime: Util.RuntimeOptions): ListRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.listenerIds)) {
    query['ListenerIds'] = request.listenerIds;
  }
  if (!Util.isUnset(request.loadBalancerIds)) {
    query['LoadBalancerIds'] = request.loadBalancerIds;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ruleIds)) {
    query['RuleIds'] = request.ruleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRules',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRules(request: ListRulesRequest): ListRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRulesWithOptions(request, runtime);
}

model ListSecurityPoliciesRequest {
  maxResults?: int32(name='MaxResults', description='The number of entries per page. Valid values: **1** to **100**. Default value: **20**.', example='50'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   You do not need to specify this parameter for the first request.
*   You must specify the token that is obtained from the previous query as the value of **NextToken**.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-atstuj3rtop****'),
  securityPolicyIds?: [ string ](name='SecurityPolicyIds', description='The security policy IDs. You can specify up to 20 IDs.'),
  securityPolicyNames?: [ string ](name='SecurityPolicyNames', description='The names of the security policies. You can specify up to 10 names.'),
}

model ListSecurityPoliciesResponseBody = {
  maxResults?: int32(name='MaxResults', description='The number of entries per page.', example='50'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. Valid values:

*   If **NextToken** is empty, no next page exists.
*   If a value is returned for **NextToken**, the value is the token that determines the start point of the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The request ID.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  securityPolicies?: [ 
    {
      ciphers?: [ string ](name='Ciphers', description='The supported cipher suites.'),
      createTime?: string(name='CreateTime'),
      resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-atstuj3rtop****'),
      securityPolicyId?: string(name='SecurityPolicyId', description='The security policy ID.', example='rg-atstuj3rtop****'),
      securityPolicyName?: string(name='SecurityPolicyName', description='The name of the security policy.', example='test-secrity'),
      securityPolicyStatus?: string(name='SecurityPolicyStatus', description='The status of the security policy. Valid values:

*   **Configuring**
*   **Available**', example='Available'),
      TLSVersions?: [ string ](name='TLSVersions', description='The supported TLS protocol versions.'),
    }
  ](name='SecurityPolicies', description='The supported security policies.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1000'),
}

model ListSecurityPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecurityPoliciesResponseBody(name='body'),
}

async function listSecurityPoliciesWithOptions(request: ListSecurityPoliciesRequest, runtime: Util.RuntimeOptions): ListSecurityPoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityPolicyIds)) {
    query['SecurityPolicyIds'] = request.securityPolicyIds;
  }
  if (!Util.isUnset(request.securityPolicyNames)) {
    query['SecurityPolicyNames'] = request.securityPolicyNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecurityPolicies',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSecurityPolicies(request: ListSecurityPoliciesRequest): ListSecurityPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecurityPoliciesWithOptions(request, runtime);
}

model ListSecurityPolicyRelationsRequest {
  securityPolicyIds?: [ string ](name='SecurityPolicyIds', description='The listeners that associated with the security policy.'),
}

model ListSecurityPolicyRelationsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the listener.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  secrityPolicyRelations?: [ 
    {
      relatedListeners?: [ 
        {
          listenerId?: string(name='ListenerId', description='The ID of the SLB instance.', example='lsn-0bfuc****'),
          listenerPort?: long(name='ListenerPort', description='The ID of the security policy.', example='80'),
          listenerProtocol?: string(name='ListenerProtocol', example='HTTPS'),
          loadBalancerId?: string(name='LoadBalancerId', example='lb-bp1o94dp5i6ea****'),
        }
      ](name='RelatedListeners', description='The protocol that is used by the listener.'),
      securityPolicyId?: string(name='SecurityPolicyId', example='scp-bp1bpn0kn9****'),
    }
  ](name='SecrityPolicyRelations', description='The port that is used by the listener.'),
}

model ListSecurityPolicyRelationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecurityPolicyRelationsResponseBody(name='body'),
}

async function listSecurityPolicyRelationsWithOptions(request: ListSecurityPolicyRelationsRequest, runtime: Util.RuntimeOptions): ListSecurityPolicyRelationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.securityPolicyIds)) {
    query['SecurityPolicyIds'] = request.securityPolicyIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecurityPolicyRelations',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSecurityPolicyRelations(request: ListSecurityPolicyRelationsRequest): ListSecurityPolicyRelationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecurityPolicyRelationsWithOptions(request, runtime);
}

model ListServerGroupServersRequest {
  maxResults?: int32(name='MaxResults', description='The number of entries to return. Valid values: **1** to **100**. If you do not specify a value, the default value **20** is used.', example='50'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

*   If this is your first query or no next queries are to be sent, ignore this parameter.
*   If a next query is to be sent, set the value to the value of **NextToken** that is returned from the last call.', example='FFmyTO70tTpLG6I3FmYAXG****'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='rg-atstuj3rtop****'),
  serverIds?: [ string ](name='ServerIds'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key. You can specify up to 10 tag keys.

It can be at most 64 characters in length, and cannot contain `http://` or `https://`. It must not start with `aliyun` or `acs:`.', example='Test'),
      value?: string(name='Value', description='The tag value. You can specify up to 10 tag values.

It can be up to 128 characters in length, and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.', example='Test'),
    }
  ](name='Tag'),
}

model ListServerGroupServersResponseBody = {
  maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='50'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

*   If **NextToken** is empty, it indicates that no subsequent query is to be sent.
*   If a value is returned for **NextToken**, the value is the token that is used for the next query.', example='caeba0bbb2be03f8****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
  servers?: [ 
    {
      description?: string(name='Description', description='The description of the backend server.', example='test'),
      port?: int32(name='Port', description='The port used by the backend server. Valid values: **1** to **65535**.', example='80'),
      remoteIpEnabled?: boolean(name='RemoteIpEnabled', description='Indicates whether the remote IP address feature is enabled. Valid values:

*   **true**: enabled
*   **false**: disabled', example='true'),
      serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-qy042e1jabmprh****'),
      serverId?: string(name='ServerId', description='The ID of the backend server.

>  If **ServerType** is set to **Fc**, **ServerId** is the ARN of a function.', example='i-bp1f9kdprbgy9uiu****'),
      serverIp?: string(name='ServerIp', description='The IP address in inclusive ENI mode.', example='192.168.XX.XX'),
      serverType?: string(name='ServerType', description='The type of the backend server.', example='Ecs'),
      status?: string(name='Status', description='The status of the backend server. Valid values:

*   **Adding**: The backend server is being added.
*   **Available**: The backend server is added.
*   **Configuring**: The backend server is being configured.
*   **Removing**: The backend server is being removed.', example='Available'),
      weight?: int32(name='Weight', description='The weight of the backend server. An ECS instance with a higher weight receives more requests.', example='100'),
    }
  ](name='Servers', description='The list of backend servers.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='3'),
}

model ListServerGroupServersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServerGroupServersResponseBody(name='body'),
}

async function listServerGroupServersWithOptions(request: ListServerGroupServersRequest, runtime: Util.RuntimeOptions): ListServerGroupServersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.serverIds)) {
    query['ServerIds'] = request.serverIds;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServerGroupServers',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServerGroupServers(request: ListServerGroupServersRequest): ListServerGroupServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServerGroupServersWithOptions(request, runtime);
}

model ListServerGroupsRequest {
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.', example='20'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

*   If this is your first query or no next query is to be sent, ignore this parameter.
*   If a next query is to be sent, set the value to the value of **NextToken** that is returned from the last call.', example='FFmyTO70tTpLG6I3FmYAXG****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-atstuj3rtop****'),
  serverGroupIds?: [ string ](name='ServerGroupIds'),
  serverGroupNames?: [ string ](name='ServerGroupNames'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag keys. You can specify up to 10 tags.

It can be at most 64 characters in length, and cannot contain `http://` or `https://`. It must not start with `aliyun` or `acs:`.', example='Test'),
      value?: string(name='Value', description='The tag values. You can specify up to 10 tags.

It can be at most 128 characters in length, and cannot contain `http://` or `https://`. It must not start with `aliyun` or `acs:`.', example='Test'),
    }
  ](name='Tag'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp15zckdt37pq72zv****'),
}

model ListServerGroupsResponseBody = {
  maxResults?: int32(name='MaxResults', description='The number of entries returned per page.', example='50'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

*   If **NextToken** is empty, it indicates that no next query is to be sent.
*   If a value of **NextToken** is returned, the value is the token that is used for the next query.', example='caeba0bbb2be03f8****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
  serverGroups?: [ 
    {
      configManagedEnabled?: boolean(name='ConfigManagedEnabled', description='Indicates whether configuration management is enabled. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
      createTime?: string(name='CreateTime'),
      healthCheckConfig?: {
        healthCheckCodes?: [ string ](name='HealthCheckCodes', description='The HTTP status codes that indicate a successful health check.

*   If **HealthCheckProtocol** is set to **HTTP**, **HealthCheckCodes** can be set to **http\\_2xx**, **http\\_3xx**, **http\\_4xx**, and **http\\_5xx**. Separate multiple HTTP status codes with commas (,).
*   If **HealthCheckProtocol** is set to **gRPC**, **HealthCheckCodes** can be set to **0 to 99**. Value ranges are supported. You can enter at most 20 value ranges and must separate them with commas (,).

>  This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP** or **gRPC**.'),
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The backend port that is used for health checks. Valid values: **0** to **65535**.

**0** indicates that the port on a backend server is used for health checks.', example='80'),
        healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='Indicates whether the health check feature is enabled. Valid values:

*   **true**: enabled
*   **false**: disabled', example='true'),
        healthCheckHost?: string(name='HealthCheckHost', description='The domain name that is used for health checks. The domain name meets the following requirements:

*   The domain name is 1 to 80 characters in length.
*   The domain name can contain lowercase letters, digits, hyphens (-), and periods (.).
*   It contains at least one period (.) but does not start or end with a period (.).
*   The rightmost domain label of the domain name contains only letters, and does not contain digits or hyphens (-).
*   The domain name does not start or end with a hyphen (-).

>  This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP**.', example='www.example.com'),
        healthCheckHttpVersion?: string(name='HealthCheckHttpVersion', description='The HTTP version that is used for health checks.

Valid values: **HTTP1.0** and **HTTP1.1**.

>  This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP**.', example='HTTP1.1'),
        healthCheckInterval?: int32(name='HealthCheckInterval', description='The interval between two consecutive health checks. Unit: seconds. Valid values: **1** to **50**.', example='5'),
        healthCheckMethod?: string(name='HealthCheckMethod', description='The HTTP method that is used for health checks. Valid values:

*   **GET**: If the length of a response exceeds 8 KB, the response is truncated. However, the health check result is not affected.
*   **POST**: By default, gRPC health checks use the POST method.
*   **HEAD**: By default, HTTP health checks use the HEAD method.

>  This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP** or **gRPC**.', example='HEAD'),
        healthCheckPath?: string(name='HealthCheckPath', description='The path that is used for health checks.

>  This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP**.', example='/test/index.html'),
        healthCheckProtocol?: string(name='HealthCheckProtocol', description='The protocol that is used for health checks. Valid values:

*   **HTTP**: To perform HTTP health checks, ALB sends HEAD or GET requests to a backend server to check whether the backend server is healthy.
*   **TCP**: To perform TCP health checks, ALB sends SYN packets to a backend server to check whether the port of the backend server is available to receive requests.
*   **gRPC**: To perform gRPC health checks, ALB sends POST or GET requests to a backend server to check whether the backend server is healthy.', example='HTTP'),
        healthCheckTimeout?: int32(name='HealthCheckTimeout', description='The timeout period of a health check. If a backend server does not respond within the specified timeout period, the backend server fails the health check. Unit: seconds.', example='3'),
        healthyThreshold?: int32(name='HealthyThreshold', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**.', example='4'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**.', example='4'),
      }(name='HealthCheckConfig', description='The health check configurations.'),
      ipv6Enabled?: boolean(name='Ipv6Enabled', description='Indicates whether IPv6 is supported. Valid values:

*   **true**: supported
*   **false**: not supported', example='false'),
      protocol?: string(name='Protocol', description='The backend protocol. Valid values:

*   **HTTP**: allows you to associate an HTTPS, HTTP, or QUIC listener with the server group.
*   **HTTPS**: allows you to associate HTTPS listeners with backend servers.
*   **GRPC**: If you select this option, you can associate the server group with HTTPS and QUIC listeners.', example='HTTP'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-atstuj3rtop****'),
      scheduler?: string(name='Scheduler', description='The routing algorithm. Valid values:

*   **Wrr**: Backend servers with higher weights receive more requests than backend servers with lower weights.
*   **Wlc**: Requests are distributed based on the weight and load of each backend server. The load refers to the number of connections on a backend server. If multiple backend servers have the same weight, requests are forwarded to the backend server with the least connections.
*   **Sch**: enables consistent hashing. Requests from the same source IP address are distributed to the same backend server.', example='Wrr'),
      serverCount?: int32(name='ServerCount', description='The number of backend servers in the server group.', example='1'),
      serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.', example='sgp-cige6j****'),
      serverGroupName?: string(name='ServerGroupName', description='The name of the server group.', example='Group3'),
      serverGroupStatus?: string(name='ServerGroupStatus', description='The status of the server group. Valid values:

*   **Creating**: The server group is being created.
*   **Available**: The server group is available
*   **Configuring**: The server group is being configured.', example='Available'),
      serverGroupType?: string(name='ServerGroupType', description='The type of the server group. Valid values:

*   **Instance**: a server group of the Instance type.
*   **Ip**: a server group of the IP type.
*   **Fc**: a server group of the Function Compute type.', example='Instance'),
      serviceName?: string(name='ServiceName', description='The name of the server group.', example='test'),
      stickySessionConfig?: {
        cookie?: string(name='Cookie', description='The cookie that is configured on the backend server.', example='B490B5EBF6F3CD402E515D22BCDA****'),
        cookieTimeout?: int32(name='CookieTimeout', description='The timeout period of a cookie. Unit: seconds. Valid values: **1** to **86400**.

>  This parameter takes effect when the **StickySessionEnabled** parameter is set to **true** and the **StickySessionType** parameter is set to **Insert**.', example='1000'),
        stickySessionEnabled?: boolean(name='StickySessionEnabled', description='Indicates whether session persistence is enabled. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
        stickySessionType?: string(name='StickySessionType', description='The method that is used to handle a cookie. Valid values:

*   **Insert**: inserts a cookie.

    ALB inserts a cookie (SERVERID) into the first HTTP or HTTPS response packet that is sent to a client. The next request from the client contains this cookie and the listener forwards this request to the recorded backend server.

*   **Server**: rewrites a cookie.

    When ALB detects a user-defined cookie, it overwrites the original cookie with the user-defined cookie. The next request from the client carries the user-defined cookie, and the listener will distribute this request to the recorded backend server.', example='Insert'),
      }(name='StickySessionConfig', description='The configuration of session persistence.'),
      tags?: [ 
        {
          key?: string(name='Key', description='The key of the tag.', example='Test'),
          value?: string(name='Value', description='The value of the tag.', example='Test'),
        }
      ](name='Tags', description='The tags that are added to the server group.'),
      uchConfig?: {
        type?: string(name='Type', description='', example='QueryString'),
        value?: string(name='Value', description='hash', example='abc'),
      }(name='UchConfig', description='urlhash'),
      upstreamKeepaliveEnabled?: boolean(name='UpstreamKeepaliveEnabled', description='Indicates whether persistent TCP connections are enabled. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
      vpcId?: string(name='VpcId', description='The ID of the VPC.', example='vpc-bp15zckdt37pq72zv****'),
    }
  ](name='ServerGroups', description='A list of server groups.'),
  totalCount?: int32(name='TotalCount', description='The number of entries returned.', example='1000'),
}

model ListServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServerGroupsResponseBody(name='body'),
}

async function listServerGroupsWithOptions(request: ListServerGroupsRequest, runtime: Util.RuntimeOptions): ListServerGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.serverGroupIds)) {
    query['ServerGroupIds'] = request.serverGroupIds;
  }
  if (!Util.isUnset(request.serverGroupNames)) {
    query['ServerGroupNames'] = request.serverGroupNames;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServerGroups',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServerGroups(request: ListServerGroupsRequest): ListServerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServerGroupsWithOptions(request, runtime);
}

model ListSystemSecurityPoliciesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  securityPolicies?: [ 
    {
      ciphers?: [ string ](name='Ciphers', description='The supported cipher suites, which are determined by the **TLS protocol version**.

The specified cipher suites must be supported by at least one **TLS protocol version** that you select. For example, if you set the TLSVersions.N parameter to TLSv1.3, you can specify only cipher suites that are supported by TLSv1.3.

*   TLS 1.0 and TLS 1.1 support the following cipher suites:

    *   ECDHE-ECDSA-AES128-SHA
    *   ECDHE-ECDSA-AES256-SHA
    *   ECDHE-RSA-AES128-SHA
    *   ECDHE-RSA-AES256-SHA
    *   AES128-SHA
    *   AES256-SHA

    <!---->

    *   DES-CBC3-SHA

*   TLS 1.2 supports the following cipher suites:

    *   ECDHE-ECDSA-AES128-SHA
    *   ECDHE-ECDSA-AES256-SHA
    *   ECDHE-RSA-AES128-SHA
    *   ECDHE-RSA-AES256-SHA
    *   AES128-SHA
    *   AES256-SHA
    *   DES-CBC3-SHA
    *   ECDHE-ECDSA-AES128-GCM-SHA256
    *   ECDHE-ECDSA-AES256-GCM-SHA384
    *   ECDHE-ECDSA-AES128-SHA256
    *   ECDHE-ECDSA-AES256-SHA384
    *   ECDHE-RSA-AES128-GCM-SHA256
    *   ECDHE-RSA-AES256-GCM-SHA384
    *   ECDHE-RSA-AES128-SHA256
    *   ECDHE-RSA-AES256-SHA384
    *   AES128-GCM-SHA256
    *   AES256-GCM-SHA384
    *   AES128-SHA256
    *   AES256-SHA256

*   TLS 1.3 supports the following cipher suites:

    *   TLS_AES\\_128\\_GCM_SHA256
    *   TLS_AES\\_256\\_GCM_SHA384
    *   TLS_CHACHA20\\_POLY1305\\_SHA256
    *   TLS_AES\\_128\\_CCM_SHA256
    *   TLS_AES\\_128\\_CCM\\_8\\_SHA256'),
      securityPolicyId?: string(name='SecurityPolicyId', description='The ID of the security policy.', example='spy-n0kn923****'),
      TLSVersions?: [ string ](name='TLSVersions', description='The TLS protocol versions that are supported. Valid values: **TLSv1.0**, **TLSv1.1**, **TLSv1.2**, and **TLSv1.3**.'),
    }
  ](name='SecurityPolicies', description='The security policies.'),
}

model ListSystemSecurityPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSystemSecurityPoliciesResponseBody(name='body'),
}

async function listSystemSecurityPoliciesWithOptions(runtime: Util.RuntimeOptions): ListSystemSecurityPoliciesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListSystemSecurityPolicies',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSystemSecurityPolicies(): ListSystemSecurityPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSystemSecurityPoliciesWithOptions(runtime);
}

model ListTagKeysRequest {
  category?: string(name='Category', description='The type of the tag.

Valid values: **Custom**, **System**, and **All**.

Default value: **All**.', example='System'),
  keyword?: string(name='Keyword', description='The tag key. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='test'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.', example='20'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

*   If this is your first query or no next query is to be sent, ignore this parameter.
*   If a next query is to be sent, set the value to the value of **NextToken** that is returned from the last call.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid values:

*   **acl**: a network access control list (ACL)
*   **loadbalancer**: an ALB instance
*   **securitypolicy**: a security policy
*   **servergroup**: a server group', example='loadbalancer'),
}

model ListTagKeysResponseBody = {
  maxResults?: int32(name='MaxResults', description='The number of entries returned per page.', example='20'),
  nextToken?: string(name='NextToken', description='The token that is used for the next query. Valid values:

*   If **NextToken** is empty, it indicates that no next query is to be sent.
*   If a value of **NextToken** is returned, the value is the token that is used for the next query.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  tagKeys?: [ 
    {
      category?: string(name='Category', description='The type of the tag.

Valid values: **Custom**, **System**, and **All**.

Default value: **All**.', example='System'),
      tagKey?: string(name='TagKey', description='The tags that match all of the filter conditions.', example='test'),
    }
  ](name='TagKeys', description='The list of tag keys.'),
  totalCount?: int32(name='TotalCount', description='The number of entries returned.', example='10'),
}

model ListTagKeysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagKeysResponseBody(name='body'),
}

async function listTagKeysWithOptions(request: ListTagKeysRequest, runtime: Util.RuntimeOptions): ListTagKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagKeys',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagKeys(request: ListTagKeysRequest): ListTagKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagKeysWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  maxResults?: int32(name='MaxResults', description='The ID of the resource.', example='20'),
  nextToken?: string(name='NextToken', description='The type of the resource. Valid values:

*   **acl**: a network access control list (ACL)
*   **loadbalancer**: an Application Load Balancer (ALB) instance
*   **securitypolicy**: a security policy
*   **servergroup**: a server group', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  resourceId?: [ string ](name='ResourceId', description='The tag key. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='acl-123'),
  resourceType?: string(name='ResourceType', description='The tags.', example='loadbalancer'),
  tag?: [ 
    {
      key?: string(name='Key', description='The number of entries returned per page.', example='env'),
      value?: string(name='Value', description='The token that is used for the next query. Valid values:

*   If **NextToken** is empty, it indicates that no next query is to be sent.
*   If a value of **NextToken** is returned, the value is the token that is used for the next query.', example='product'),
    }
  ](name='Tag', description='The tag value. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='test'),
}

model ListTagResourcesResponseBody = {
  maxResults?: int32(name='MaxResults', description='The ID of the request.', example='20'),
  nextToken?: string(name='NextToken', description='The tags that match the specified keys and values.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The ID of the resource.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId', description='The tag key.', example='d-2ze1ot4ah7xjyv0d****'),
      resourceType?: string(name='ResourceType', description='The tag value.', example='loadbalancer'),
      tagKey?: string(name='TagKey', example='env'),
      tagValue?: string(name='TagValue', example='product'),
    }
  ](name='TagResources', description='The type of the resource. Valid values:

*   **acl**: a network ACL
*   **loadbalancer**: an ALB instance
*   **securitypolicy**: a security policy
*   **servergroup**: a server group'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTagValuesRequest {
  maxResults?: int32(name='MaxResults', description='The ID of the resource.', example='20'),
  nextToken?: string(name='NextToken', description='The type of the resource. Valid values:

*   **loadbalancer**: an ALB instance
*   **acl**: a network access control list (ACL)
*   **securitypolicy**: a security policy
*   **servergroup**: a server group', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  resourceId?: string(name='ResourceId', description='The number of entries returned per page.', example='eip-resource-test'),
  resourceType?: string(name='ResourceType', description='The tag key. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='loadbalancer'),
  tagKey?: string(name='TagKey', description='The token that is used for the next query. Valid values:

*   If **NextToken** is empty, it indicates that no next query is to be sent.
*   If a value of **NextToken** is returned, the value is the token that is used for the next query.', example='test'),
}

model ListTagValuesResponseBody = {
  maxResults?: int32(name='MaxResults', description='The ID of the request.', example='20'),
  nextToken?: string(name='NextToken', description='The tags that match all the filter conditions.', example='FFmyTO70tTpLG6I3FmYAXGKPd****'),
  requestId?: string(name='RequestId', description='The number of entries returned.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  tagValues?: [ string ](name='TagValues'),
  totalCount?: int32(name='TotalCount', example='10'),
}

model ListTagValuesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagValuesResponseBody(name='body'),
}

async function listTagValuesWithOptions(request: ListTagValuesRequest, runtime: Util.RuntimeOptions): ListTagValuesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagValues',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagValues(request: ListTagValuesRequest): ListTagValuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagValuesWithOptions(request, runtime);
}

model MoveResourceGroupRequest {
  newResourceGroupId?: string(name='NewResourceGroupId', description='The ID of the resource group to which the cloud resource is to be moved.

>  You can use resource groups to classify cloud resources that belong to your Apsara Stack tenant account to facilitate resource management and permission control. For more information, see [What is resource management?](~~94475~~).', example='rg-9gLOoK****'),
  resourceId?: string(name='ResourceId', description='The ID of the cloud resource that you want to move.', example='acl-hp34s2h0xx1ht4nwo****'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid values:

*   **loadbalancer**: an Application Load Balancer (ALB) instance.
*   **acl**: an access control list (ACL).
*   **securitypolicy**: a security policy.
*   **servergroup**: a server group.', example='ACL'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroupWithOptions(request: MoveResourceGroupRequest, runtime: Util.RuntimeOptions): MoveResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MoveResourceGroup',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveResourceGroupWithOptions(request, runtime);
}

model RemoveEntriesFromAclRequest {
  aclId?: string(name='AclId', description='The ID of the ACL.', example='nacl-hp34s2h0xx1ht4nwo****'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** may be different for each API request.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to check the request without performing the operation. Valid values:

*   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the check, an HTTP 2xx status code is returned and the operation is performed.', example='true'),
  entries?: [ string ](name='Entries', description='A list of removed access control entries.'),
}

model RemoveEntriesFromAclResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
}

model RemoveEntriesFromAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveEntriesFromAclResponseBody(name='body'),
}

/**
  * The **RemoveEntriesFromAcl** operation is asynchronous. After you send a request, the system returns the request ID, but the operation is still being performed in the system background. You can call the [ListAclEntries](~~213616~~) operation to query the status of an entry in an ACL:
  * *   If an ACL is in the **Removing** state, the entry is being deleted.
  * *   If an ACL cannot be found, the entry is deleted.
  *
  * @param request RemoveEntriesFromAclRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RemoveEntriesFromAclResponse
 */
async function removeEntriesFromAclWithOptions(request: RemoveEntriesFromAclRequest, runtime: Util.RuntimeOptions): RemoveEntriesFromAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.entries)) {
    query['Entries'] = request.entries;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveEntriesFromAcl',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The **RemoveEntriesFromAcl** operation is asynchronous. After you send a request, the system returns the request ID, but the operation is still being performed in the system background. You can call the [ListAclEntries](~~213616~~) operation to query the status of an entry in an ACL:
  * *   If an ACL is in the **Removing** state, the entry is being deleted.
  * *   If an ACL cannot be found, the entry is deleted.
  *
  * @param request RemoveEntriesFromAclRequest
  * @return RemoveEntriesFromAclResponse
 */
async function removeEntriesFromAcl(request: RemoveEntriesFromAclRequest): RemoveEntriesFromAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeEntriesFromAclWithOptions(request, runtime);
}

model RemoveServersFromServerGroupRequest {
  clientToken?: string(name='ClientToken', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  dryRun?: boolean(name='DryRun', example='false'),
  serverGroupId?: string(name='ServerGroupId', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.', example='sgp-atstuj3rtop****'),
  servers?: [ 
    {
      port?: int32(name='Port', description='Specifies whether only to precheck this request. Valid values:

*   **trues**: prechecks the request but does not remove the server from the server group. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, an HTTP 2xx status code is returned and the operation is performed.', example='80'),
      serverId?: string(name='ServerId', description='The ID of the asynchronous task.', example='i-bp1f9kdprbgy9uiu****'),
      serverIp?: string(name='ServerIp', description='The ID of the request.', example='192.168.1.1'),
      serverType?: string(name='ServerType', example='Ecs'),
    }
  ](name='Servers'),
}

model RemoveServersFromServerGroupResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model RemoveServersFromServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveServersFromServerGroupResponseBody(name='body'),
}

/**
  * The IP address in inclusive ENI mode. You can specify at most 40 servers in each call.
  *
  * @param request RemoveServersFromServerGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return RemoveServersFromServerGroupResponse
 */
async function removeServersFromServerGroupWithOptions(request: RemoveServersFromServerGroupRequest, runtime: Util.RuntimeOptions): RemoveServersFromServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.servers)) {
    query['Servers'] = request.servers;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveServersFromServerGroup',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The IP address in inclusive ENI mode. You can specify at most 40 servers in each call.
  *
  * @param request RemoveServersFromServerGroupRequest
  * @return RemoveServersFromServerGroupResponse
 */
async function removeServersFromServerGroup(request: RemoveServersFromServerGroupRequest): RemoveServersFromServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeServersFromServerGroupWithOptions(request, runtime);
}

model ReplaceServersInServerGroupRequest {
  addedServers?: [ 
    {
      description?: string(name='Description', description='The description of the backend server. The description must be 2 to 256 characters in length, and can contain letters, digits, periods (.), underscores (\\_), hyphens (-), commas (,), semicolons (;), forward slashes (/), and at signs (@). You can specify at most 40 servers in each call.', example='test'),
      port?: int32(name='Port', description='The port used by the server group. Valid values: **1** to **65535**. You can specify at most 40 servers in each call.', example='80'),
      serverId?: string(name='ServerId', description='The ID of the backend server. You can specify up to 40 server IDs in each call.

*   If the server group type is **Instance**, set the ServerId parameter to the ID of an ECS instance, an ENI, or an elastic container instance. These backend servers are specified by **Ecs**, **Eni**, or **Eci**.
*   If the server group type is **Ip**, set the ServerId parameter to an IP address specified in the server group.

> You cannot perform this operation on a server group of the Function type. You can call the [ListServerGroups](~~213627~~) operation to query information about the server group type so that you can set ServerId to a proper value.', example='i-bp1f9kdprbgy9uiu****'),
      serverIp?: string(name='ServerIp', description='The IP address in inclusive ENI mode. You can specify at most 40 servers in each call.', example='192.168.1.1'),
      serverType?: string(name='ServerType', description='The type of the backend server that you want to remove from the server group. You can specify up to 40 backend servers in each call. Valid values:

*   **Ecs**
*   **Eni**
*   **Eci**', example='Ecs'),
      weight?: int32(name='Weight', description='The weight of the backend server that you want to add to the server group. You can specify up to 40 backend servers in each call.

Valid values: **0** to **100**. Default value: **100**. If the weight of a backend server is set to **0**, no requests are forwarded to the backend server.', example='100'),
    }
  ](name='AddedServers', description='The backend servers that you want to add to the server group. You can specify up to 40 backend servers in each call.'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a `2xx` HTTP status code is returned and the operation is performed.', example='true'),
  removedServers?: [ 
    {
      port?: int32(name='Port', description='The port that is used by the backend server. Valid values: **1** to **65535**. You can specify at most 40 servers in each call.', example='81'),
      serverId?: string(name='ServerId', description='The ID of the backend server. You can specify up to 40 server IDs in each call.

*   If the server group type is **Instance**, set the ServerId parameter to the ID of an ECS instance, an ENI, or an elastic container instance. These backend servers are specified by **Ecs**, **Eni**, or **Eci**.
*   If the server group type is **Ip**, set the ServerId parameter to an IP address specified in the server group.

> You cannot perform this operation on a server group of the Function type. You can call the [ListServerGroups](~~213627~~) operation to query information about the server group type so that you can set ServerId to a proper value.', example='ecs-bp1ac9uozods2uc****'),
      serverIp?: string(name='ServerIp', description='The IP address in inclusive ENI mode. You can specify at most 40 servers in each call.', example='192.168.1.12'),
      serverType?: string(name='ServerType', description='The type of the backend server that you want to remove from the server group. You can specify up to 40 backend servers in each call. Valid values:

*   **Ecs**
*   **Eni**
*   **Eci**', example='ecs'),
    }
  ](name='RemovedServers', description='The backend servers that you want to remove.'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the server group.

> You cannot perform this operation on a server group of the Function type.', example='sgp-5114d593o96qxy****'),
}

model ReplaceServersInServerGroupResponseBody = {
  jobId?: string(name='JobId', description='The asynchronous task ID.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The request ID.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model ReplaceServersInServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReplaceServersInServerGroupResponseBody(name='body'),
}

/**
  * **ReplaceServersInServerGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background.
  * 1.  You can call the [ListServerGroups](~~213627~~) operation to query the status of a server group.
  *     *   If a server group is in the **Configuring** state, it indicates that the server group is being modified.
  *     *   If a server group is in the **Available** state, it indicates that the server group is running.
  * 2.  You can call the [ListServerGroupServers](~~213628~~) operation to query the status of a backend server.
  *     *   If a backend server is in the **Replacing** state, it indicates that the server is being removed from the server group and a new server is added to the server group.
  *     *   If a backend server is in the \\*\\*Available\\*\\* state, it indicates that the server is running.
  *
  * @param request ReplaceServersInServerGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ReplaceServersInServerGroupResponse
 */
async function replaceServersInServerGroupWithOptions(request: ReplaceServersInServerGroupRequest, runtime: Util.RuntimeOptions): ReplaceServersInServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addedServers)) {
    query['AddedServers'] = request.addedServers;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.removedServers)) {
    query['RemovedServers'] = request.removedServers;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReplaceServersInServerGroup',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * **ReplaceServersInServerGroup** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background.
  * 1.  You can call the [ListServerGroups](~~213627~~) operation to query the status of a server group.
  *     *   If a server group is in the **Configuring** state, it indicates that the server group is being modified.
  *     *   If a server group is in the **Available** state, it indicates that the server group is running.
  * 2.  You can call the [ListServerGroupServers](~~213628~~) operation to query the status of a backend server.
  *     *   If a backend server is in the **Replacing** state, it indicates that the server is being removed from the server group and a new server is added to the server group.
  *     *   If a backend server is in the \\*\\*Available\\*\\* state, it indicates that the server is running.
  *
  * @param request ReplaceServersInServerGroupRequest
  * @return ReplaceServersInServerGroupResponse
 */
async function replaceServersInServerGroup(request: ReplaceServersInServerGroupRequest): ReplaceServersInServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceServersInServerGroupWithOptions(request, runtime);
}

model StartListenerRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', example='true'),
  listenerId?: string(name='ListenerId', example='lsr-bp1bpn0kn908w4nbw****'),
}

model StartListenerResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model StartListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartListenerResponseBody(name='body'),
}

/**
  * The ID of the asynchronous task.
  *
  * @param request StartListenerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return StartListenerResponse
 */
async function startListenerWithOptions(request: StartListenerRequest, runtime: Util.RuntimeOptions): StartListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The ID of the asynchronous task.
  *
  * @param request StartListenerRequest
  * @return StartListenerResponse
 */
async function startListener(request: StartListenerRequest): StartListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return startListenerWithOptions(request, runtime);
}

model StopListenerRequest {
  clientToken?: string(name='ClientToken', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', example='true'),
  listenerId?: string(name='ListenerId', example='lsr-bp1bpn0kn908w4nbw****'),
}

model StopListenerResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model StopListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopListenerResponseBody(name='body'),
}

/**
  * The ID of the asynchronous task.
  *
  * @param request StopListenerRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return StopListenerResponse
 */
async function stopListenerWithOptions(request: StopListenerRequest, runtime: Util.RuntimeOptions): StopListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The ID of the asynchronous task.
  *
  * @param request StopListenerRequest
  * @return StopListenerResponse
 */
async function stopListener(request: StopListenerRequest): StopListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopListenerWithOptions(request, runtime);
}

model TagResourcesRequest {
  resourceId?: [ string ](name='ResourceId', description='The tag key. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='acl-123'),
  resourceType?: string(name='ResourceType', description='The tags.', example='loadbalancer'),
  tag?: [ 
    {
      key?: string(name='Key', description='The ID of the request.', example='env'),
      value?: string(name='Value', example='product'),
    }
  ](name='Tag', description='The tag value. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='test'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UnTagResourcesRequest {
  all?: boolean(name='All', example='false'),
  resourceId?: [ string ](name='ResourceId', description='The key of the tag that you want to remove. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='acl-123'),
  resourceType?: string(name='ResourceType', description='The tags that you want to remove.', example='loadbalancer'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag keys. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='env'),
      value?: string(name='Value', description='Specifies whether to remove all tags from the specified resource. Valid values:

*   **true**: removes all tags from the resource.
*   **false**: does not remove all tags from the specified resource. This is the default value.', example='product'),
    }
  ](name='Tag', description='The value of the tag that you want to remove. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.', example='test'),
  tagKey?: [ string ](name='TagKey', description='The ID of the request.'),
}

model UnTagResourcesResponseBody = {
  requestId?: string(name='RequestId', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
}

model UnTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnTagResourcesResponseBody(name='body'),
}

async function unTagResourcesWithOptions(request: UnTagResourcesRequest, runtime: Util.RuntimeOptions): UnTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnTagResources',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unTagResources(request: UnTagResourcesRequest): UnTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return unTagResourcesWithOptions(request, runtime);
}

model UpdateAScriptsRequest {
  AScripts?: [ 
    {
      AScriptId?: string(name='AScriptId', description='The AScript rule ID.', example='as-mhqxcanmivn4g5****'),
      AScriptName?: string(name='AScriptName', description='The name of the AScript rule.

The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.', example='Group1'),
      enabled?: boolean(name='Enabled', description='Specifies whether to enable the AScript rule. Valid values:

*   **true**
*   **false** (default)', example='true'),
      scriptContent?: string(name='ScriptContent', description='The content of the AScript rule.', example='if and(match_re($uri, \\"^/1.txt$\\"), $arg_type) { rewrite(concat(\\"/1.\\", $arg_type), \\"break\\") }'),
    }
  ](name='AScripts', description='The AScript rules.'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='b1f642ac-5558-4a36-b7d9-cf53f40ea5c8'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false**(default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='false'),
}

model UpdateAScriptsResponseBody = {
  jobId?: string(name='JobId', description='The asynchronous task ID.', example='2e82b5f4-1ba9-4d20-89c8-1082ebaa****'),
  requestId?: string(name='RequestId', description='The request ID.', example='ACA19FE1-C09E-53C7-8FDA-560F49D71891'),
}

model UpdateAScriptsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAScriptsResponseBody(name='body'),
}

/**
  * *   **UpdateAScripts** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListAScripts](~~472574~~) operation to query the status of the task.
  *     *   If an AScript rule is in the **Configuring** state, the AScript rule is being updated.
  *     *   If an AScript rule is in the **Available** state, the AScript rule is updated.
  * *   In the following table, the maximum value of **N** is **4**.
  *
  * @param request UpdateAScriptsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateAScriptsResponse
 */
async function updateAScriptsWithOptions(request: UpdateAScriptsRequest, runtime: Util.RuntimeOptions): UpdateAScriptsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.AScripts)) {
    query['AScripts'] = request.AScripts;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAScripts',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   **UpdateAScripts** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [ListAScripts](~~472574~~) operation to query the status of the task.
  *     *   If an AScript rule is in the **Configuring** state, the AScript rule is being updated.
  *     *   If an AScript rule is in the **Available** state, the AScript rule is updated.
  * *   In the following table, the maximum value of **N** is **4**.
  *
  * @param request UpdateAScriptsRequest
  * @return UpdateAScriptsResponse
 */
async function updateAScripts(request: UpdateAScriptsRequest): UpdateAScriptsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAScriptsWithOptions(request, runtime);
}

model UpdateAclAttributeRequest {
  aclId?: string(name='AclId', description='Specifies whether only to precheck the request. Valid values:

*   **true**: only prechecks the request and does not perform the requested operation. The system checks the required parameters, request format, and service limits. If the request fails the precheck, an error code is returned based on the cause of the failure. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false**: prechecks the request and performs the requested operation. After the request passes the precheck, an `HTTP 2xx` status code is returned and the system performs the operation. This is the default value.', example='nacl-hp34s2h0xx1ht4nwo****'),
  aclName?: string(name='AclName', description='The ID of the request.', example='test-acl'),
  clientToken?: string(name='ClientToken', description='The name of the ACL. The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', example='true'),
}

model UpdateAclAttributeResponseBody = {
  requestId?: string(name='RequestId', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model UpdateAclAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAclAttributeResponseBody(name='body'),
}

async function updateAclAttributeWithOptions(request: UpdateAclAttributeRequest, runtime: Util.RuntimeOptions): UpdateAclAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclName)) {
    query['AclName'] = request.aclName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAclAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAclAttribute(request: UpdateAclAttributeRequest): UpdateAclAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAclAttributeWithOptions(request, runtime);
}

model UpdateHealthCheckTemplateAttributeRequest {
  clientToken?: string(name='ClientToken', description='The port that is used for health checks. Valid values: **0 to 65535**.

Default value: **0**. If you set the value to 0, the port of the backend server is used for health checks.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='The ID of the request.', example='true'),
  healthCheckCodes?: [ string ](name='HealthCheckCodes', example='5'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The HTTP status codes that are used to determine whether the backend server passes the health check.

*   If **HealthCheckProtocol** is set to **HTTP**, **HealthCheckCodes** can be set to **http\\_2xx** (default), **http\\_3xx**, **http\\_4xx**, and **http\\_5xx**. Separate multiple HTTP status codes with a comma (,).
*   If **HealthCheckProtocol** is set to **gRPC**, **HealthCheckCodes** can be set to **0 to 99**. Default value: **0**. Value ranges are supported. You can enter 20 value ranges at most and must separate each range with a comma (,).

>  This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP** or **gRPC**.', example='80'),
  healthCheckHost?: string(name='HealthCheckHost', description='The interval between two consecutive health checks. Unit: seconds. Valid values: **1 to 50**. Default value: **2**.', example='$_ip'),
  healthCheckHttpVersion?: string(name='HealthCheckHttpVersion', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**.

Valid values: **2 to 10**.

Default value: **3**.', example='HTTP1.0'),
  healthCheckInterval?: int32(name='HealthCheckInterval', description='The URL path that is used for health checks.

The URL must be 1 to 80 characters in length and can contain only letters, digits, hyphens (-), forward slashes (/), periods (.), percent signs (%), question marks (?), number signs (#), and ampersands (&). The URL can also contain the following extended characters: `_ ; ~ ! ( ) * [ ] @ $ ^ : \\" , +`.

The URL path must start with a forward slash (/).

>  This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP** or **gRPC**.', example='5'),
  healthCheckMethod?: string(name='HealthCheckMethod', description='The HTTP version that is used for health checks.

Valid values: **HTTP1.0** and **HTTP1.1**.

Default value: **HTTP1.1**.

>  This parameter takes effect only when the `HealthCheckProtocol` parameter is set to **HTTP**.', example='HEAD'),
  healthCheckPath?: string(name='HealthCheckPath', description='The protocol that is used for health checks. Valid values:

*   **HTTP** (default): To perform HTTP health checks, ALB sends HEAD or GET requests to a backend server to check whether the backend server is healthy.
*   **TCP**: To perform TCP health checks, ALB sends SYN packets to a backend server to check whether the port of the backend server is available to receive requests.
*   **gRPC**: To perform gRPC health checks, ALB sends POST or GET requests to a backend server to check whether the backend server is healthy.', example='/test/index.html'),
  healthCheckProtocol?: string(name='HealthCheckProtocol', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**.

Valid values: **2 to 10**.

Default value: **3**.', example='HTTP'),
  healthCheckTemplateId?: string(name='HealthCheckTemplateId', example='hct-bp1qjwo61pqz3ahltv0mw'),
  healthCheckTemplateName?: string(name='HealthCheckTemplateName', description='The domain name that is used for health checks. Valid values:

*   **$SERVER_IP** (default): the private IP addresses of backend servers. If you do not set the HealthCheckHost parameter or set the parameter to $SERVER_IP, the Application Load Balancer (ALB) uses the private IP addresses of backend servers for health checks.
*   **domain**: The domain name must be 1 to 80 characters in length and can contain letters, digits, periods (.), and hyphens (-).

>  This parameter takes effect only when the `HealthCheckProtocol` parameter is set to **HTTP**.', example='HealthCheckTemplate1'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout', description='The HTTP method that is used for health checks. Valid values:

*   **HEAD**: By default, HTTP health checks use the HEAD method.
*   **GET**: If the size of a response exceeds 8 KB, the response is truncated. However, the health check result is not affected.
*   **POST**: By default, gRPC health checks use the POST method.

>  This parameter takes effect only when the **HealthCheckProtocol** parameter is set to **HTTP** or **gRPC**.', example='3'),
  healthyThreshold?: int32(name='HealthyThreshold', description='Specifies whether to only precheck this request. Valid values:

*   **true**: prechecks the request without modifying the attributes of the health check template. The system checks the required parameters, request syntax, and limits. If the request fails to pass the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the precheck, a 2xx HTTP status code is returned and the health check template is modified.', example='4'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold', description='The ID of the template.', example='4'),
}

model UpdateHealthCheckTemplateAttributeResponseBody = {
  requestId?: string(name='RequestId', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model UpdateHealthCheckTemplateAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHealthCheckTemplateAttributeResponseBody(name='body'),
}

async function updateHealthCheckTemplateAttributeWithOptions(request: UpdateHealthCheckTemplateAttributeRequest, runtime: Util.RuntimeOptions): UpdateHealthCheckTemplateAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.healthCheckCodes)) {
    query['HealthCheckCodes'] = request.healthCheckCodes;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckHost)) {
    query['HealthCheckHost'] = request.healthCheckHost;
  }
  if (!Util.isUnset(request.healthCheckHttpVersion)) {
    query['HealthCheckHttpVersion'] = request.healthCheckHttpVersion;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckMethod)) {
    query['HealthCheckMethod'] = request.healthCheckMethod;
  }
  if (!Util.isUnset(request.healthCheckPath)) {
    query['HealthCheckPath'] = request.healthCheckPath;
  }
  if (!Util.isUnset(request.healthCheckProtocol)) {
    query['HealthCheckProtocol'] = request.healthCheckProtocol;
  }
  if (!Util.isUnset(request.healthCheckTemplateId)) {
    query['HealthCheckTemplateId'] = request.healthCheckTemplateId;
  }
  if (!Util.isUnset(request.healthCheckTemplateName)) {
    query['HealthCheckTemplateName'] = request.healthCheckTemplateName;
  }
  if (!Util.isUnset(request.healthCheckTimeout)) {
    query['HealthCheckTimeout'] = request.healthCheckTimeout;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHealthCheckTemplateAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateHealthCheckTemplateAttribute(request: UpdateHealthCheckTemplateAttributeRequest): UpdateHealthCheckTemplateAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHealthCheckTemplateAttributeWithOptions(request, runtime);
}

model UpdateListenerAttributeRequest {
  caCertificates?: [ 
    {
    }
  ](name='CaCertificates', description='The certificate authority (CA) certificates.'),
  caEnabled?: boolean(name='CaEnabled', description='Specifies whether to enable mutual authentication. Valid values:

*   **true**
*   **false**', example='false'),
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId', description='The certificate ID. Only server certificates are supported. You can specify up to 20 certificate IDs.', example='12315790212_166f8204689_1714763408_70998****'),
    }
  ](name='Certificates', description='The certificates.'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  defaultActions?: [ 
    {
      forwardGroupConfig?: {
        serverGroupTuples?: [ 
          {
            serverGroupId?: string(name='ServerGroupId', description='The server group to which requests are forwarded.', example='rsp-cige6j5e7p****'),
          }
        ](name='ServerGroupTuples', description='The server groups to which requests are forwarded.'),
      }(name='ForwardGroupConfig', description='The configuration of the forwarding action. This parameter is required and takes effect when **Type** is set to **FowardGroup**. You can specify configurations for up to 20 forwarding actions.'),
      type?: string(name='Type', description='The type of the action. You can specify only one action type.

Set the value to **ForwardGroup** to forward requests to multiple vServer groups.', example='ForwardGroup'),
    }
  ](name='DefaultActions', description='The actions of the default forwarding rule.'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a `2xx HTTP` status code is returned and the operation is performed.', example='false'),
  gzipEnabled?: boolean(name='GzipEnabled', description='Specifies whether to enable GZIP compression for specific types of files. Valid values:

*   **true**
*   **false**', example='true'),
  http2Enabled?: boolean(name='Http2Enabled', description='Specifies whether to enable HTTP/2. Valid values:

*   **true**
*   **false**

> This parameter is available only when you create an HTTPS listener.', example='true'),
  idleTimeout?: int32(name='IdleTimeout', description='The timeout period of an idle connection. Unit: seconds. Valid values: **1 to 60**.

If no request is received within the specified timeout period, ALB closes the current connection. When another request is received, ALB establishes a new connection.', example='15'),
  listenerDescription?: string(name='ListenerDescription', description='The name of the listener.

The name must be 2 to 256 characters in length, and can contain letters, digits, and the following special characters: , . ; / @ \\_ -.', example='HTTP_80'),
  listenerId?: string(name='ListenerId', description='The ID of the Application Load Balancer (ALB) listener.', example='lsr-bp1bpn0kn908w4nbw****'),
  quicConfig?: {
    quicListenerId?: string(name='QuicListenerId', description='The QUIC listener ID. This parameter is required if **QuicUpgradeEnabled** is set to **true**. Only HTTPS listeners support this parameter.

> You must add the HTTPS listener and the QUIC listener to the same ALB instance. In addition, make sure that the QUIC listener has never been associated with another listener.', example='lsn-333'),
    quicUpgradeEnabled?: boolean(name='QuicUpgradeEnabled', description='Specifies whether to enable QUIC upgrade. Valid values:

*   **true**
*   **false**

> Only HTTPS listeners support this parameter.', example='false'),
  }(name='QuicConfig', description='The configuration information when the listener is associated with a QUIC listener.'),
  requestTimeout?: int32(name='RequestTimeout', description='The timeout period of a request. Unit: seconds. Valid values: **1 to 180**.

If no response is received from the backend server within the specified timeout period, ALB returns an `HTTP 504` error code to the client.', example='3'),
  securityPolicyId?: string(name='SecurityPolicyId', description='The security policy ID. System security policies and custom security policies are supported.

> This parameter is available only when you create an HTTPS listener.', example='tls_cipher_policy_1_0'),
  XForwardedForConfig?: {
    XForwardedForClientCertClientVerifyAlias?: string(name='XForwardedForClientCertClientVerifyAlias', description='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertClientVerifyEnabled** is set to **true**.

The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (\\_), and digits.

> This parameter is available only when you create an HTTPS listener.', example='test_client-verify-alias_123456'),
    XForwardedForClientCertClientVerifyEnabled?: boolean(name='XForwardedForClientCertClientVerifyEnabled', description='Specifies whether to use the `X-Forwarded-Clientcert-clientverify` header to retrieve the verification result of the client certificate. Valid values:

*   **true**
*   **false**

> This parameter is available only when you create an HTTPS listener.', example='false'),
    XForwardedForClientCertFingerprintAlias?: string(name='XForwardedForClientCertFingerprintAlias', description='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertFingerprintEnabled** is set to **true**.

The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (\\_), and digits.

> This parameter is available only when you create an HTTPS listener.', example='test_finger-print-alias_123456'),
    XForwardedForClientCertFingerprintEnabled?: boolean(name='XForwardedForClientCertFingerprintEnabled', description='Specifies whether to use the `X-Forwarded-Clientcert-fingerprint` header to retrieve the fingerprint of the client certificate. Valid values:

*   **true**
*   **false**

> This parameter is available only when you create an HTTPS listener.', example='false'),
    XForwardedForClientCertIssuerDNAlias?: string(name='XForwardedForClientCertIssuerDNAlias', description='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertIssuerDNEnabled** is set to **true**.

The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (\\_), and digits.

> This parameter is available only when you create an HTTPS listener.', example='test_issue-dn-alias_123456'),
    XForwardedForClientCertIssuerDNEnabled?: boolean(name='XForwardedForClientCertIssuerDNEnabled', description='Specifies whether to use the `X-Forwarded-Clientcert-issuerdn` header to retrieve information about the authority that issues the client certificate. Valid values:

*   **true**
*   **false**

> This parameter is available only when you create an HTTPS listener.', example='false'),
    XForwardedForClientCertSubjectDNAlias?: string(name='XForwardedForClientCertSubjectDNAlias', description='The name of the custom header. This parameter takes effect only when **XForwardedForClientCertSubjectDNEnabled** is set to **true**.

The name must be 1 to 40 characters in length, and can contain letters, hyphens (-), underscores (\\_), and digits.

> This parameter is available only when you create an HTTPS listener.', example='test_subject-dn-alias_123456'),
    XForwardedForClientCertSubjectDNEnabled?: boolean(name='XForwardedForClientCertSubjectDNEnabled', description='Specifies whether to use the `X-Forwarded-Clientcert-subjectdn` header to retrieve information about the owner of the client certificate. Valid values:

*   **true**
*   **false**

> This parameter is available only when you create an HTTPS listener.', example='false'),
    XForwardedForClientSourceIpsEnabled?: boolean(name='XForwardedForClientSourceIpsEnabled', description='Specifies whether to use the `X-Forwarded-Client-Ip` header to retrieve the source IP address. Valid values:

*   **true**
*   **false**

> HTTP, HTTPS, and QUIC listeners support this parameter. By default, the feature that corresponds to this parameter is unavailable. If you want to use this feature, contact your account manager.', example='false'),
    XForwardedForClientSourceIpsTrusted?: string(name='XForwardedForClientSourceIpsTrusted', description='The trusted proxy IP address.

ALB traverses `X-Forwarded-For` backward and selects the first IP address that is not in the trusted IP address list as the real IP address of the client. The IP address is used in source IP address throttling.', example='10.1.1.0/24'),
    XForwardedForClientSrcPortEnabled?: boolean(name='XForwardedForClientSrcPortEnabled', description='Specifies whether to use the `X-Forwarded-Client-Port` header to retrieve the client port. Valid values:

*   **true**
*   **false**

> HTTP and HTTPS listeners support this parameter.', example='false'),
    XForwardedForEnabled?: boolean(name='XForwardedForEnabled', description='Specifies whether to use the `X-Forwarded-For` header to retrieve the client IP address. Valid values:

*   **true**
*   **false**

> HTTP and HTTPS listeners support this parameter.', example='true'),
    XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled', description='Specifies whether to use the `X-Forwarded-Proto` header to retrieve the listener protocol. Valid values:

*   **true**
*   **false**

> HTTP, HTTPS, and QUIC listeners support this parameter.', example='false'),
    XForwardedForSLBIdEnabled?: boolean(name='XForwardedForSLBIdEnabled', description='Specifies whether to use the `SLB-ID` header to retrieve the ID of the ALB instance. Valid values:

*   **true**
*   **false**

> HTTP, HTTPS, and QUIC listeners support this parameter.', example='false'),
    XForwardedForSLBPortEnabled?: boolean(name='XForwardedForSLBPortEnabled', description='Specifies whether to use the `X-Forwarded-Port` header to retrieve the listener port. Valid values:

*   **true**
*   **false**

> HTTP, HTTPS, and QUIC listeners support this parameter.', example='false'),
  }(name='XForwardedForConfig', description='The configuration of the XForwardFor headers.'),
}

model UpdateListenerAttributeResponseBody = {
  jobId?: string(name='JobId', description='The asynchronous task ID.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The request ID.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model UpdateListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateListenerAttributeResponseBody(name='body'),
}

/**
  * **UpdateListenerAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetListenerAttribute](~~214353~~) operation to query the status of the task.
  * *   If a listener is in the **Configuring** state, the listener is being updated.
  * *   If a listener is in the **Running** state, the listener is updated.
  *
  * @param request UpdateListenerAttributeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateListenerAttributeResponse
 */
async function updateListenerAttributeWithOptions(request: UpdateListenerAttributeRequest, runtime: Util.RuntimeOptions): UpdateListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caCertificates)) {
    query['CaCertificates'] = request.caCertificates;
  }
  if (!Util.isUnset(request.caEnabled)) {
    query['CaEnabled'] = request.caEnabled;
  }
  if (!Util.isUnset(request.certificates)) {
    query['Certificates'] = request.certificates;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.defaultActions)) {
    query['DefaultActions'] = request.defaultActions;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.gzipEnabled)) {
    query['GzipEnabled'] = request.gzipEnabled;
  }
  if (!Util.isUnset(request.http2Enabled)) {
    query['Http2Enabled'] = request.http2Enabled;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    query['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerDescription)) {
    query['ListenerDescription'] = request.listenerDescription;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.quicConfig)) {
    query['QuicConfig'] = request.quicConfig;
  }
  if (!Util.isUnset(request.requestTimeout)) {
    query['RequestTimeout'] = request.requestTimeout;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    query['SecurityPolicyId'] = request.securityPolicyId;
  }
  if (!Util.isUnset(request.XForwardedForConfig)) {
    query['XForwardedForConfig'] = request.XForwardedForConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateListenerAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * **UpdateListenerAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call the [GetListenerAttribute](~~214353~~) operation to query the status of the task.
  * *   If a listener is in the **Configuring** state, the listener is being updated.
  * *   If a listener is in the **Running** state, the listener is updated.
  *
  * @param request UpdateListenerAttributeRequest
  * @return UpdateListenerAttributeResponse
 */
async function updateListenerAttribute(request: UpdateListenerAttributeRequest): UpdateListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateListenerAttributeWithOptions(request, runtime);
}

model UpdateListenerLogConfigRequest {
  accessLogRecordCustomizedHeadersEnabled?: boolean(name='AccessLogRecordCustomizedHeadersEnabled', description='Specifies whether to record custom headers in the access log. Valid values:

*   **true**: yes
*   **false** (default): no

>  This parameter can be set to **true** only when the access log feature of ALB is enabled by specifying **AccessLogEnabled**.', example='true'),
  accessLogTracingConfig?: {
    tracingEnabled?: boolean(name='TracingEnabled', description='Specifies whether to enable the Xtrace feature. Valid values:

*   **true**: yes
*   **false** (default): no

>  This parameter can be set to **true** only when the access log feature of ALB is enabled by specifying **AccessLogEnabled**.', example='true'),
    tracingSample?: int32(name='TracingSample', description='The sampling rate of the Xtrace feature.

Valid values: **1 to 10000**.

>  This parameter is valid only if the **TracingEnabled** parameter is set to **true**.', example='100'),
    tracingType?: string(name='TracingType', description='The type of Xtrace. Set the value to **Zipkin**.

>  This parameter is valid only if the **TracingEnabled** parameter is set to **true**.', example='Zipkin'),
  }(name='AccessLogTracingConfig', description='The configuration information about the Xtrace feature.'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** may be different for each API request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to check the request without performing the operation. Valid values:

*   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false**: sends the request. If the request passes the check, the **HTTP\\_2xx** status code is returned and the operation is performed. This is the default value.', example='true'),
  listenerId?: string(name='ListenerId', description='The ID of the listener of the ALB instance.', example='lsr-bp1bpn0kn908w4nbw****'),
}

model UpdateListenerLogConfigResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model UpdateListenerLogConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateListenerLogConfigResponseBody(name='body'),
}

/**
  * The **UpdateListenerLogConfig** operation is asynchronous. After you send a request, the system returns the request ID, but the operation is still being performed in the system background. You can call [GetListenerAttribute](~~2254865~~) to query the status of a listener:
  * *   If a listener is in the **Configuring** state, the log configuration of the listener is being modified.
  * *   If a listener is in the **Running** state, the log configuration of the listener is modified.
  * > You can call this operation only if you enable the access log feature for the ALB instance that you want to manage.
  *
  * @param request UpdateListenerLogConfigRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateListenerLogConfigResponse
 */
async function updateListenerLogConfigWithOptions(request: UpdateListenerLogConfigRequest, runtime: Util.RuntimeOptions): UpdateListenerLogConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessLogRecordCustomizedHeadersEnabled)) {
    query['AccessLogRecordCustomizedHeadersEnabled'] = request.accessLogRecordCustomizedHeadersEnabled;
  }
  if (!Util.isUnset(request.accessLogTracingConfig)) {
    query['AccessLogTracingConfig'] = request.accessLogTracingConfig;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateListenerLogConfig',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The **UpdateListenerLogConfig** operation is asynchronous. After you send a request, the system returns the request ID, but the operation is still being performed in the system background. You can call [GetListenerAttribute](~~2254865~~) to query the status of a listener:
  * *   If a listener is in the **Configuring** state, the log configuration of the listener is being modified.
  * *   If a listener is in the **Running** state, the log configuration of the listener is modified.
  * > You can call this operation only if you enable the access log feature for the ALB instance that you want to manage.
  *
  * @param request UpdateListenerLogConfigRequest
  * @return UpdateListenerLogConfigResponse
 */
async function updateListenerLogConfig(request: UpdateListenerLogConfigRequest): UpdateListenerLogConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateListenerLogConfigWithOptions(request, runtime);
}

model UpdateLoadBalancerAddressTypeConfigRequest {
  addressType?: string(name='AddressType', description='The ID of the zone where the ALB instance is deployed. You can specify up to 10 zones for an ALB instance.

You can call the [DescribeZones](~~189196~~) operation to query the most recent zone list.', example='Internet'),
  clientToken?: string(name='ClientToken', description='The ID of the ALB instance.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: string(name='DryRun', description='The new network type of the ALB instance. Valid values:

*   **Internet**: The ALB instance uses a public IP address. The domain name of the ALB instance is resolved to the public IP address. Therefore, the ALB instance can be accessed over the Internet.
*   **Intranet**: The ALB instance uses a private IP address. The domain name of the ALB instance is resolved to the private IP address. Therefore, the ALB instance can be accessed over the virtual private cloud (VPC) where the ALB instance is deployed.', example='false'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the vSwitch in the zone. You can specify only one vSwitch (subnet) in each zone of an ALB instance. You can specify up to 10 zones for an ALB instance.', example='lb-bp1o94dp5i6ea****'),
  zoneMappings?: [ 
    {
      allocationId?: string(name='AllocationId', description='The ID of the asynchronous task.', example='eip-bp1aedxso6u80u0qf****'),
      vSwitchId?: string(name='VSwitchId', description='The ID of the elastic IP address (EIP). You can specify up to 10 zones for an ALB instance.

>  This parameter is required if you want to change the network type from internal-facing to Internet-facing.', example='vsw-bp10ttov87felojcn****'),
      zoneId?: string(name='ZoneId', description='The ID of the request.', example='cn-hangzhou-a'),
    }
  ](name='ZoneMappings'),
}

model UpdateLoadBalancerAddressTypeConfigResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
}

model UpdateLoadBalancerAddressTypeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLoadBalancerAddressTypeConfigResponseBody(name='body'),
}

/**
  * The client token that is used to ensure the idempotence of the request.
  * You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
  * >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
  *
  * @param request UpdateLoadBalancerAddressTypeConfigRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateLoadBalancerAddressTypeConfigResponse
 */
async function updateLoadBalancerAddressTypeConfigWithOptions(request: UpdateLoadBalancerAddressTypeConfigRequest, runtime: Util.RuntimeOptions): UpdateLoadBalancerAddressTypeConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addressType)) {
    query['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.zoneMappings)) {
    query['ZoneMappings'] = request.zoneMappings;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoadBalancerAddressTypeConfig',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The client token that is used to ensure the idempotence of the request.
  * You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
  * >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
  *
  * @param request UpdateLoadBalancerAddressTypeConfigRequest
  * @return UpdateLoadBalancerAddressTypeConfigResponse
 */
async function updateLoadBalancerAddressTypeConfig(request: UpdateLoadBalancerAddressTypeConfigRequest): UpdateLoadBalancerAddressTypeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoadBalancerAddressTypeConfigWithOptions(request, runtime);
}

model UpdateLoadBalancerAttributeRequest {
  clientToken?: string(name='ClientToken', description='The status of the configuration read-only mode. Valid values:

*   **NonProtection**: disables the configuration read-only mode. In this case, you cannot set the **ModificationProtectionReason** parameter. If you set the **ModificationProtectionReason** parameter, the value of the parameter is cleared.
*   **ConsoleProtection**: enables the configuration read-only mode. In this case, you can set the **ModificationProtectionReason** parameter.

>  If you set this parameter to **ConsoleProtection**, you cannot modify instance configurations in the ALB console. However, you can modify instance configurations by calling API operations.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='The ID of the synchronous task.', example='true'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the request.', example='alb-o9ulmq5hgn68jk****'),
  loadBalancerName?: string(name='LoadBalancerName'),
  modificationProtectionConfig?: {
    reason?: string(name='Reason'),
    status?: string(name='Status', example='ConsoleProtection'),
  }(name='ModificationProtectionConfig'),
}

model UpdateLoadBalancerAttributeResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model UpdateLoadBalancerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLoadBalancerAttributeResponseBody(name='body'),
}

/**
  * The name of the ALB instance. The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.
  *
  * @param request UpdateLoadBalancerAttributeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateLoadBalancerAttributeResponse
 */
async function updateLoadBalancerAttributeWithOptions(request: UpdateLoadBalancerAttributeRequest, runtime: Util.RuntimeOptions): UpdateLoadBalancerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.loadBalancerName)) {
    query['LoadBalancerName'] = request.loadBalancerName;
  }
  if (!Util.isUnset(request.modificationProtectionConfig)) {
    query['ModificationProtectionConfig'] = request.modificationProtectionConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoadBalancerAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The name of the ALB instance. The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.
  *
  * @param request UpdateLoadBalancerAttributeRequest
  * @return UpdateLoadBalancerAttributeResponse
 */
async function updateLoadBalancerAttribute(request: UpdateLoadBalancerAttributeRequest): UpdateLoadBalancerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoadBalancerAttributeWithOptions(request, runtime);
}

model UpdateLoadBalancerEditionRequest {
  clientToken?: string(name='ClientToken', description='The ID of the ALB instance.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='The edition of the ALB instance. Different editions have different limits and support different billing methods.

*   **Basic**: basic
*   **Standard**: standard
*   **StandardWithWaf**: WAF-enabled', example='false'),
  loadBalancerEdition?: string(name='LoadBalancerEdition', example='Standard'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the request.', example='lb-bp1b6c719dfa08ex****'),
}

model UpdateLoadBalancerEditionResponseBody = {
  requestId?: string(name='RequestId', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
}

model UpdateLoadBalancerEditionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLoadBalancerEditionResponseBody(name='body'),
}

/**
  * The client token that is used to ensure the idempotence of the request.
  * You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
  * >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
  *
  * @param request UpdateLoadBalancerEditionRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateLoadBalancerEditionResponse
 */
async function updateLoadBalancerEditionWithOptions(request: UpdateLoadBalancerEditionRequest, runtime: Util.RuntimeOptions): UpdateLoadBalancerEditionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerEdition)) {
    query['LoadBalancerEdition'] = request.loadBalancerEdition;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoadBalancerEdition',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The client token that is used to ensure the idempotence of the request.
  * You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
  * >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
  *
  * @param request UpdateLoadBalancerEditionRequest
  * @return UpdateLoadBalancerEditionResponse
 */
async function updateLoadBalancerEdition(request: UpdateLoadBalancerEditionRequest): UpdateLoadBalancerEditionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoadBalancerEditionWithOptions(request, runtime);
}

model UpdateLoadBalancerZonesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a `2xx HTTP` status code is returned and the operation is performed.', example='true'),
  loadBalancerId?: string(name='LoadBalancerId', description='The ID of the ALB instance.', example='lb-bp1b6c719dfa08ex****'),
  zoneMappings?: [ 
    {
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch in the zone. By default, you can specify only one vSwitch (subnet) for each zone of an ALB instance. You can specify up to 10 zone IDs.', example='vsw-bp1rmcrwg3erh1fh8****'),
      zoneId?: string(name='ZoneId', description='The name of the zone. You can call the [DescribeZones](~~189196~~) operation to query the zones. You can specify up to 10 zone IDs.', example='cn-hangzhou-a'),
    }
  ](name='ZoneMappings', description='The zones and the vSwitches. You must specify at least two zones. The specified zones overwrite the existing configurations.'),
}

model UpdateLoadBalancerZonesResponseBody = {
  jobId?: string(name='JobId', description='The ID of the asynchronous task.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The request ID.', example='CEF72CEB-54B6-4AE8-B225-F876FF7BA984'),
}

model UpdateLoadBalancerZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLoadBalancerZonesResponseBody(name='body'),
}

/**
  * **UpdateLoadBalancerZones** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetLoadBalancerAttribute](~~214362~~) to query the status of the task.
  * *   If an ALB instance is in the **Configuring** state, the zones are being modified.
  * *   If an ALB instance is in the **Active** state, the zones are modified.
  * > You may be charged after you call UpdateLoadBalancerZones.
  *
  * @param request UpdateLoadBalancerZonesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateLoadBalancerZonesResponse
 */
async function updateLoadBalancerZonesWithOptions(request: UpdateLoadBalancerZonesRequest, runtime: Util.RuntimeOptions): UpdateLoadBalancerZonesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.zoneMappings)) {
    query['ZoneMappings'] = request.zoneMappings;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoadBalancerZones',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * **UpdateLoadBalancerZones** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [GetLoadBalancerAttribute](~~214362~~) to query the status of the task.
  * *   If an ALB instance is in the **Configuring** state, the zones are being modified.
  * *   If an ALB instance is in the **Active** state, the zones are modified.
  * > You may be charged after you call UpdateLoadBalancerZones.
  *
  * @param request UpdateLoadBalancerZonesRequest
  * @return UpdateLoadBalancerZonesResponse
 */
async function updateLoadBalancerZones(request: UpdateLoadBalancerZonesRequest): UpdateLoadBalancerZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoadBalancerZonesWithOptions(request, runtime);
}

model UpdateRuleAttributeRequest {
  clientToken?: string(name='ClientToken', description='The key of the header. The key must be 1 to 40 characters in length and can contain letters, digits, hyphens (-), and underscores (\\_). You cannot set Cookie or Host.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='The value of the header. The header values within a forwarding rule must be unique. The header must meet the following requirements:

*   The value must be 1 to 128 characters in length.
*   It can contain printable characters whose ASCII values are `greater than or equal to 32 and lower than 127`. You can use asterisks (\\*) and question marks (?) as wildcard characters.
*   The header value cannot start or end with a space character.', example='false'),
  priority?: int32(name='Priority', example='10'),
  ruleActions?: [ 
    {
      corsConfig?: {
        allowCredentials?: string(name='AllowCredentials', description='The ID of the asynchronous task.', example='on'),
        allowHeaders?: [ string ](name='AllowHeaders'),
        allowMethods?: [ string ](name='AllowMethods'),
        allowOrigin?: [ string ](name='AllowOrigin'),
        exposeHeaders?: [ string ](name='ExposeHeaders'),
        maxAge?: long(name='MaxAge', description='The ID of the request.', example='1000'),
      }(name='CorsConfig'),
      fixedResponseConfig?: {
        content?: string(name='Content', description='The weight of the server group. A larger value specifies a higher weight. A server group with a higher weight receives more requests. Valid values: **1** to **100**.

*   If only one destination server group exists, the weight is **100** by default.
*   If more than one destination server group exists, you must specify weights.', example='dssacav'),
        contentType?: string(name='ContentType', description='Specifies whether to enable session persistence. Valid values:

*   **true**: yes
*   **false** (default): no', example='text/plain'),
        httpCode?: string(name='HttpCode', description='The timeout period. Unit: seconds. Valid values: 1 to 86400.', example='HTTP_200'),
      }(name='FixedResponseConfig'),
      forwardGroupConfig?: {
        serverGroupStickySession?: {
          enabled?: boolean(name='Enabled', description='The type of the header. Valid values:

*   **UserDefined**: a custom header
*   **ReferenceHeader**: a header that references the request headers
*   **SystemDefined**: a system-defined header', example='false'),
          timeout?: int32(name='Timeout', description='The priority of the action. Valid values: **1 to 50000**. A lower value specifies a higher priority. The actions of a forwarding rule are applied in descending order of priority. This parameter cannot be left empty. The priority of each action within a forwarding rule must be unique. You can specify priorities for at most 20 actions.', example='2'),
        }(name='ServerGroupStickySession'),
        serverGroupTuples?: [ 
          {
            serverGroupId?: string(name='ServerGroupId', description='The key of the header to be inserted. The key must be 1 to 40 characters in length, and can contain lowercase letters, digits, underscores (\\_), and hyphens (-). The header key specified by **InsertHeaderConfig** must be unique.

>  You cannot set one of the following header keys (case-insensitive): `slb-id`, `slb-ip`, `x-forwarded-for`, `x-forwarded-proto`, `x-forwarded-eip`, `x-forwarded-port`, `x-forwarded-client-srcport`, `connection`, `upgrade`, `content-length`, `transfer-encoding`, `keep-alive`, `te`, `host`, `cookie`, `remoteip`, and `authority`.', example='sg--atstuj3rtoptyui****'),
            weight?: int32(name='Weight', description='The value of the header to be inserted.

*   If **ValueType** is set to **SystemDefined**, you can specify one of the following header values:

    *   **ClientSrcPort**: the client port.
    *   **ClientSrcIp**: the client IP address.
    *   **Protocol**: the request protocol. You can set the protocol to HTTP or HTTPS.
    *   **SLBId**: the ID of the Application Load Balancer (ALB) instance.
    *   **SLBPort**: the listening port.

*   If **ValueType** is set to **UserDefined**, you can specify a custom header. The header value must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and lower than 127`. You can use asterisks (\\*) and question marks (?) as wildcards. The header value cannot start or end with a space character.

*   If **ValueType** is set to **ReferenceHeader**, you can reference the request headers. The header value must be 1 to 128 characters in length, and can contain lowercase letters, digits, underscores (\\_), and hyphens (-).', example='30'),
          }
        ](name='ServerGroupTuples'),
      }(name='ForwardGroupConfig'),
      insertHeaderConfig?: {
        key?: string(name='Key', description='The hostname to which requests are distributed. Valid values:

*   **${host}** (default): If you set the value to ${host}, you cannot append other characters.

*   If you want to specify a custom value, make sure that the following requirements are met:

    *   The hostname must be 3 to 128 characters in length, and can contain lowercase letters, digits, hyphens (-), and periods (.). You can use asterisks (\\*) and question marks (?) as wildcard characters.
    *   The hostname must contain at least one period (.) but cannot start or end with a period (.).
    *   The rightmost domain label can contain only letters and wildcard characters. It cannot contain digits or hyphens (-).
    *   The domain labels cannot start or end with a hyphen (-).
    *   You can use an asterisk (\\*) and question mark (?) anywhere in a domain label as wildcards.', example='key'),
        value?: string(name='Value', description='The redirect type. Valid values: **301**, **302**, **303**, **307**, and **308**.', example='UserDefined'),
        valueType?: string(name='ValueType', description='The path to which requests are forwarded. Valid values:

*   Default value: **${path}**. **${host}**, **${protocol}**, and **${port}** are also supported. Each variable cannot be specified more than once. You can specify one or more of the preceding variables in each request. You can also combine them with the following characters.

*   A custom value. You must make sure that the custom value meets the following requirements:

    *   The value is 1 to 128 characters in length.
    *   It must start with a forward slash (/) and can contain letters, digits, and the following special characters: `$ - _ .+ / & ~ @ :`. It cannot contain the following special characters: `" % # ; ! ( ) [ ]^ , "`. You can use asterisks (\\*) and question marks (?) as wildcards.', example='UserDefined'),
      }(name='InsertHeaderConfig'),
      order?: int32(name='Order', description='The port to which requests are distributed. Valid values:

*   **${port}** (default): If you set the value to ${port}, you cannot append other characters.
*   Other valid values: **1 to 63335**.', example='1'),
      redirectConfig?: {
        host?: string(name='Host', description='The redirect protocol. Valid values:

*   **${protocol}** (default): If you set the value to ${protocol}, you cannot append other characters.
*   Valid values: **HTTP** and **HTTPS**.

>  HTTPS listeners do not support HTTPS to HTTP redirects.', example='www.example.com'),
        httpCode?: string(name='HttpCode', description='The query string of the URL to which requests are distributed. Valid values:

*   Default value: **${query}**. **${host}**, **${protocol}**, and **${port}** are also supported. Each variable cannot be specified more than once. You can specify one or more of the preceding variables in each request. You can also combine them with the following characters.

*   A custom value. You must make sure that the custom value meets the following requirements:

    *   The value is 1 to 128 characters in length.
    *   It can contain printable characters, except space characters, the special characters `# [ ] { } \\ | < > &`, and uppercase letters.', example='301'),
        path?: string(name='Path', description='The hostname to which requests are forwarded. Valid values:

*   **${host}** (default): If you set the value to ${host}, you cannot append other characters.

*   If you want to specify a custom value, make sure that the following requirements are met:

    *   The hostname must be 3 to 128 characters in length, and can contain lowercase letters, digits, hyphens (-), and periods (.). You can use asterisks (\\*) and question marks (?) as wildcard characters.
    *   The hostname must contain at least one period (.) but cannot start or end with a period (.).
    *   The rightmost domain label can contain only letters and wildcard characters. It cannot contain digits or hyphens (-).
    *   The domain labels cannot start or end with a hyphen (-). You can use an asterisk (\\*) and question mark (?) anywhere in a domain label as wildcards.', example='/test'),
        port?: string(name='Port', description='The path to which requests are forwarded. Valid values:

*   Default value: **${path}**. **${host}**, **${protocol}**, and **${port}** are also supported. Each variable cannot be specified more than once. You can specify one or more of the preceding variables in each request. You can also combine them with the following characters.

*   A custom value. You must make sure that the custom value meets the following requirements:

    *   The value is 1 to 128 characters in length.
    *   It must start with a forward slash (/) and can contain letters, digits, and the following special characters: `$ - _ .+ / & ~ @ :`. It cannot contain the following special characters: `" % # ; ! ( ) [ ]^ , "`. You can use asterisks (\\*) and question marks (?) as wildcards.', example='10'),
        protocol?: string(name='Protocol', description='The query string of the URL to which requests are distributed. Valid values:

*   Default value: **${query}**. **${host}**, **${protocol}**, and **${port}** are also supported. Each variable cannot be specified more than once. You can specify one or more of the preceding variables in each request. You can also combine them with the following characters.

*   A custom value. You must make sure that the custom value meets the following requirements:

    *   The value is 1 to 128 characters in length.
    *   It can contain printable characters, except space characters, the special characters `# [ ] { } \\ | < > &`, and uppercase letters.', example='HTTP'),
        query?: string(name='Query', description='The action type. You can specify at most 11 types of action. Valid values:

*   **ForwardGroup**: forwards a request to multiple vServer groups.
*   **Redirect**: redirects a request.
*   **FixedResponse**: returns a custom response.
*   **Rewrite**: rewrites a request.
*   **InsertHeader**: inserts a header.
*   **RemoveHeaderConfig**: deletes a header.
*   **TrafficLimitConfig**: throttles network traffic.
*   **TrafficMirrorConfig**: mirrors traffic.
*   **CorsConfig**: forwards requests based on CORS.

You can specify the final action and the actions that you want to perform before the final action:

*   **FinalType**: the last action to be performed in a forwarding rule. Each forwarding rule can contain only one FinalType action. You can specify a **ForwardGroup**, **Redirect**, or **FixedResponse** action as the FinalType action.
*   **ExtType**: the action to be performed before the FinalType action. A forwarding rule can contain one or more ExtType actions. To specify this parameter, you must also specify FinalType. You can specify multiple **InsertHeader** actions or one **Rewrite** action.', example='quert'),
      }(name='RedirectConfig'),
      rewriteConfig?: {
        host?: string(name='Host', description='The queries per second (QPS). Valid values: **1 to 100000**.', example='www.example.com'),
        path?: string(name='Path', description='The QPS per IP address. Valid values: **1 to 100000**.

>  If both **QPS** and **PerIpQps** are set, make sure that the **QPS** value is smaller than the PerIpQps value.', example='/tsdf'),
        query?: string(name='Query', description='The type of destination to which network traffic is mirrored. Valid values:

*   **ForwardGroupMirror**: a server group
*   **SlsMirror**: Log Service', example='quedsa'),
      }(name='RewriteConfig'),
      trafficLimitConfig?: {
        perIpQps?: int32(name='PerIpQps', description='The allowed HTTP methods for CORS requests. Valid values:

*   **GET**
*   **POST**
*   **PUT**
*   **DELETE**
*   **HEAD**
*   **OPTIONS**
*   **PATCH**', example='80'),
        QPS?: int32(name='QPS', description='The allowed origins of CORS requests. You can set this parameter to `*` or one or more values. A value cannot be `*`.

*   A value must start with a `http://` or `https://`, followed by a valid domain name or a first-level wildcard domain name, such as `*.test.abc.example.com`.
*   You can specify a port in a value. Port range: **1** to **65535**.', example='100'),
      }(name='TrafficLimitConfig'),
      trafficMirrorConfig?: {
        mirrorGroupConfig?: {
          serverGroupTuples?: [ 
            {
              serverGroupId?: string(name='ServerGroupId', description='The headers that can be exposed. You can specify `*` or specify one or more values. Separate multiple values with commas (,). A value can contain only letters and digits. It cannot start or end with underscores (\\_) or hyphens (-). It can be up to 32 characters in length.', example='srg-00mkgijak0w4qgz9****'),
            }
          ](name='ServerGroupTuples'),
        }(name='MirrorGroupConfig'),
        targetType?: string(name='TargetType', description='The allowed headers for CORS requests. You can specify `*` or specify one or more values. Separate multiple values with commas (,). A value can contain only letters and digits. It cannot start or end with underscores (\\_) or hyphens (-). It can be up to 32 characters in length.', example='ForwardGroupMirror'),
      }(name='TrafficMirrorConfig'),
      type?: string(name='Type', description='The ID of the vServer group.', example='ForwardGroup'),
    }
  ](name='RuleActions'),
  ruleConditions?: [ 
    {
      cookieConfig?: {
        values?: [ 
          {
            key?: string(name='Key', description='The hostname. The hostname must meet the following requirements:

*   The hostname must be 3 to 128 characters in length, and can contain lowercase letters, digits, hyphens (-), periods (.), asterisks (\\*), and question marks (?).
*   The hostname must contain at least one period (.) but cannot start or end with a period (.).
*   The rightmost domain label can contain only letters, asterisks (\\*), and question marks (?), and cannot contain digits or hyphens (-).
*   The domain labels cannot start or end with a hyphen (-). You can specify asterisks () and question marks (?) anywhere in a domain label.', example='test'),
            value?: string(name='Value', description='The request method.

Valid values: **HEAD**, **GET**, **POST**, **OPTIONS**, **PUT**, **PATCH**, and **DELETE**.', example='test'),
          }
        ](name='Values'),
      }(name='CookieConfig'),
      headerConfig?: {
        key?: string(name='Key', description='The path. The path must meet the following requirements:

*   It must be 1 to 128 characters in length.
*   It must start with a forward slash (/) and can contain letters, digits, and the following special characters: `$ - _ .+ / & ~ @ :`. It cannot contain the following special characters: `" % # ; ! ( ) [ ]^ , "`. You can use asterisks (\\*) and question marks (?) as wildcards.', example='Port'),
        values?: [ string ](name='Values'),
      }(name='HeaderConfig'),
      hostConfig?: {
        values?: [ string ](name='Values'),
      }(name='HostConfig'),
      methodConfig?: {
        values?: [ string ](name='Values'),
      }(name='MethodConfig'),
      pathConfig?: {
        values?: [ string ](name='Values'),
      }(name='PathConfig'),
      queryStringConfig?: {
        values?: [ 
          {
            key?: string(name='Key', description='The content of the custom response. The content can be up to 1 KB in size, and can contain only ASCII characters.', example='test'),
            value?: string(name='Value', description='The content type.

Valid values: **text/plain**, **text/css**, **text/html**, **application/javascript**, and **application/json**.', example='test'),
          }
        ](name='Values'),
      }(name='QueryStringConfig'),
      sourceIpConfig?: {
        values?: [ string ](name='Values'),
      }(name='SourceIpConfig'),
      type?: string(name='Type', description='The HTTP status code in the response. Valid values: **HTTP\\_2xx**, **HTTP\\_4xx**, and **HTTP\\_5xx**. **x** must be a digit.', example='Host'),
    }
  ](name='RuleConditions'),
  ruleId?: string(name='RuleId', description='The value of the cookie. The value must be 1 to 128 characters in length, and can contain printable characters such as lowercase letters, asterisks (\\*), and question marks (?). However, uppercase letters, space characters, and the following special characters are not supported: `# [ ] { } \\ | < > &`.', example='rule-4dp5i6ea****'),
  ruleName?: string(name='RuleName', example='rule-instance-test'),
}

model UpdateRuleAttributeResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='365F5378-41F6-4AE4-92F8-7FF34B540710'),
}

model UpdateRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRuleAttributeResponseBody(name='body'),
}

/**
  * Specifies whether to check the request without performing the operation. Valid values:
  * *   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error code is returned based on the cause of the failure. If the request passes the check, the `DryRunOperation` error code is returned.
  * *   **false**: checks the request. If the request passes the check, the system returns an `HTTP 2xx` status code and performs the operation. This is the default value.
  *
  * @param request UpdateRuleAttributeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateRuleAttributeResponse
 */
async function updateRuleAttributeWithOptions(request: UpdateRuleAttributeRequest, runtime: Util.RuntimeOptions): UpdateRuleAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.ruleActions)) {
    query['RuleActions'] = request.ruleActions;
  }
  if (!Util.isUnset(request.ruleConditions)) {
    query['RuleConditions'] = request.ruleConditions;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRuleAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Specifies whether to check the request without performing the operation. Valid values:
  * *   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error code is returned based on the cause of the failure. If the request passes the check, the `DryRunOperation` error code is returned.
  * *   **false**: checks the request. If the request passes the check, the system returns an `HTTP 2xx` status code and performs the operation. This is the default value.
  *
  * @param request UpdateRuleAttributeRequest
  * @return UpdateRuleAttributeResponse
 */
async function updateRuleAttribute(request: UpdateRuleAttributeRequest): UpdateRuleAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRuleAttributeWithOptions(request, runtime);
}

model UpdateRulesAttributeRequest {
  clientToken?: string(name='ClientToken', description='The content of the custom response. The content can be up to 1 KB in size and can contain only ASCII characters.', example='123e4567-e89b-12d3-a456-426655440000'),
  dryRun?: boolean(name='DryRun', example='false'),
  rules?: [ 
    {
      priority?: int32(name='Priority', description='The format of the response.

Valid values: **text/plain**, **text/css**, **text/html**, **application/javascript**, and **application/json**.', example='10'),
      ruleActions?: [ 
        {
          corsConfig?: {
            allowCredentials?: string(name='AllowCredentials', description='The value of the cookie. The value must be 1 to 128 characters in length, and can contain printable characters such as lowercase letters, asterisks (\\*), and question marks (?). However, the value cannot contain uppercase letters, space characters, or the following special characters: `# [ ] { } \\ | < > &`.', example='on'),
            allowHeaders?: [ string ](name='AllowHeaders'),
            allowMethods?: [ string ](name='AllowMethods'),
            allowOrigin?: [ string ](name='AllowOrigin'),
            exposeHeaders?: [ string ](name='ExposeHeaders'),
            maxAge?: long(name='MaxAge', description='The key of the header. The key must be 1 to 40 characters in length, and can contain lowercase letters, digits, hyphens (-), and underscores (\\_). Cookie and Host are not supported.', example='1000'),
          }(name='CorsConfig'),
          fixedResponseConfig?: {
            content?: string(name='Content', description='The server group to which requests are forwarded.', example='dssacav'),
            contentType?: string(name='ContentType', description='The weight of the server group. A larger value indicates a higher weight. A server group with a higher weight receives more requests. Valid values: **1** to **100**.

*   When **N** is 1, the default value **100** is used.
*   When **N** is greater than 1, you must specify the **weight** for each server group.', example='text/plain'),
            httpCode?: string(name='HttpCode', description='Specifies whether to enable session persistence. Valid values:

*   **true**: enables session persistence.
*   **false** (default): disables session persistence.', example='200'),
          }(name='FixedResponseConfig'),
          forwardGroupConfig?: {
            serverGroupStickySession?: {
              enabled?: boolean(name='Enabled', description='The key of the header to be inserted. The key must be 1 to 40 characters in length, and can contain lowercase letters, digits, underscores (\\_), and hyphens (-). The key specified in the `InsertHeader` parameter must be unique.

>  You cannot set one of the following keys (case-insensitive): `slb-id`, `slb-ip`, `x-forwarded-for`, `x-forwarded-proto`, `x-forwarded-eip`, `x-forwarded-port`, `x-forwarded-client-srcport`, `connection`, `upgrade`, `content-length`, `transfer-encoding`, `keep-alive`, `te, host`, `cookie`, `remoteip`, and `authority`.', example='false'),
              timeout?: int32(name='Timeout', description='The value of the header to be inserted.

*   If **ValueType** is set to **SystemDefined**, you can set one of the following values:

    *   **ClientSrcPort:** the port of the client.
    *   **ClientSrcIp:** the IP address of the client.
    *   **Protocol:** the request protocol. You can set the protocol to HTTP or HTTPS.
    *   **SLBId:** the ID of the ALB instance.
    *   **SLBPort:** the listening port of the ALB instance.

*   If **ValueType** is set to **UserDefined**, you can specify a custom header value. The header value must be 1 to 128 characters in length, and can contain printable characters whose ASCII values are `greater than or equal to 32 and lower than 127`. You can use asterisks (\\*) and question marks (?) as wildcard characters. The value cannot start or end with a space character.

*   If **ValueType** is set to **ReferenceHeader**, you can reference one of the request headers. The header value must be 1 to 128 characters in length, and can contain lowercase letters, digits, underscores (\\_), and hyphens (-).', example='2'),
            }(name='ServerGroupStickySession'),
            serverGroupTuples?: [ 
              {
                serverGroupId?: string(name='ServerGroupId', description='The timeout period of sessions. Unit: seconds. Valid values: **1** to **86400**.', example='sg-atstuj3rtoptyui****'),
                weight?: int32(name='Weight', description='Specifies whether to overwrite the request header. Valid values:

*   **true** overwrites the request header.
*   **false** (default): does not overwrite the request header.', example='30'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
          insertHeaderConfig?: {
            coverEnabled?: boolean(name='CoverEnabled', description='The type of header. Valid values:

*   **UserDefined:** a user-defined header.
*   **ReferenceHeader:** a header that references a field of a request header.
*   **SystemDefined:** a system-defined header.', example='false'),
            key?: string(name='Key', description='The priority of the action. Valid values: **1** to **50000**. A lower value indicates a higher priority. The actions of a forwarding rule are applied in descending order of priority. This parameter cannot be left empty. The priority of each action within a forwarding rule must be unique. You can specify priorities for at most 20 actions.', example='test'),
            value?: string(name='Value', description='The hostname to which requests are forwarded.

Take note of the following rules when you specify a hostname:

*   The hostname must be 3 to 128 characters in length, and can contain lowercase letters, digits, and the following special characters: - . \\* = ~ \\_ + \\ ^ ! $ & | ( ) \\[ ] ?.
*   The hostname must contain at least one period (.) but cannot start or end with a period (.).
*   The rightmost domain label can contain only letters, asterisks (\\*), and question marks (?), and cannot contain digits or hyphens (-). The leftmost `domain label` can be an asterisk (\\*).
*   The domain labels cannot start or end with a hyphen (-). You can specify asterisks () and question marks (?) anywhere in a domain label.', example='UserDefined'),
            valueType?: string(name='ValueType', description='The HTTP status code that indicates the redirect type. Valid values: **301**, **302**, **303**, **307**, and **308**.', example='UserDefined'),
          }(name='InsertHeaderConfig'),
          order?: int32(name='Order', description='The path to which requests are forwarded.

*   Default value: **${path}**. **${host}**, **${protocol}**, and **${port}** are also supported. Each variable can be specified only once. You can specify one or more of the preceding variables in each request. You can also concatenate them with the following characters.

*   A custom value. You must ensure that the custom value meets the following requirements:

    *   The custom value must be 1 to 128 characters in length. You can use asterisks (\\*) and question marks (?) as wildcards.
    *   The custom value can contain letters, digits, and the following special characters: `$ - _ . + / & ~ @ : \\" * ?`. The custom value must start with a forward slash (/) and cannot contain the following characters: `" % # ; ! ( ) [ ] ^ , "`.', example='1'),
          redirectConfig?: {
            host?: string(name='Host', description='The port to which requests are forwarded.

Valid values: **1** to **63335**.', example='www.example.com'),
            httpCode?: string(name='HttpCode', description='The redirect protocol.

Valid values: **HTTP** and **HTTPS**.

>  HTTPS listeners do not support HTTPS to HTTP redirection.', example='301'),
            path?: string(name='Path', description='The query string to which requests are forwarded.

The query string must be 1 to 128 characters in length, and can contain printable characters, excluding uppercase letters and the following special characters: `# [ ] { } \\ | < > &`.', example='/test'),
            port?: string(name='Port', description='The hostname to which requests are forwarded.

Take note of the following rules when you specify a hostname:

*   The hostname must be 3 to 128 characters in length, and can contain lowercase letters, digits, and the following special characters: - . \\* = ~ \\_ + \\ ^ ! $ & | ( ) \\[ ] ?.
*   The hostname must contain at least one period (.) but cannot start or end with a period (.).
*   The rightmost domain label can contain only letters, asterisks (\\*), and question marks (?), and cannot contain digits or hyphens (-). The leftmost `domain label` can be an asterisk (\\*).
*   The domain labels cannot start or end with a hyphen (-). You can specify asterisks () and question marks (?) anywhere in a domain label.', example='10'),
            protocol?: string(name='Protocol', description='The path to which requests are forwarded.

*   Default value: **${path}**. **${host}**, **${protocol}**, and **${port}** are also supported. Each variable can be specified only once. You can specify one or more of the preceding variables in each request. You can also concatenate them with the following characters.

*   A custom value. You must ensure that the custom value meets the following requirements:

    *   The custom value must be 1 to 128 characters in length. You can use asterisks (\\*) and question marks (?) as wildcards.
    *   The custom value can contain letters, digits, and the following special characters: `$ - _ . + / & ~ @ : \\" * ?`. The custom value must start with a forward slash (/) and cannot contain the following characters: `" % # ; ! ( ) [ ] ^ , "`.', example='HTTP'),
            query?: string(name='Query', description='The query string to which requests are forwarded.

The query string must be 1 to 128 characters in length, and can contain printable characters, excluding uppercase letters and the following special characters: `# [ ] { } \\ | < > &`.', example='quert'),
          }(name='RedirectConfig'),
          removeHeaderConfig?: {
            key?: string(name='Key', description='The allowed headers for CORS requests. You can specify an asterisk (`*`) or one or more values. Separate multiple values with commas (,). A value can contain only letters and digits. It cannot start or end with underscores (\\_) or hyphens (-). It can be up to 32 characters in length.', example='Port'),
          }(name='RemoveHeaderConfig'),
          rewriteConfig?: {
            host?: string(name='Host', description='The type of forwarding rule. You can specify at most seven types. Valid values:

*   **Host**: Requests are forwarded based on hosts.
*   **Path**: Requests are forwarded based on paths.
*   **Header**: Requests are forwarded based on HTTP headers.
*   **QueryString**: Requests are forwarded based on query strings.
*   **Method**: Requests are forwarded based on request methods.
*   **Cookie**: Requests are forwarded based on cookies.
*   **SourceIp**: Requests are forwarded based on source IP addresses.', example='www.example.com'),
            path?: string(name='Path', description='The number of queries per second (QPS). Valid values: **1** to **100000**.', example='/tsdf'),
            query?: string(name='Query', description='The QPS per IP address. Valid values: **1** to **100000**.

>  If both the QPS and PerIpQps properties are specified, make sure that the value of the QPS property is smaller than the value of the PerIpQps property.', example='quedsa'),
          }(name='RewriteConfig'),
          trafficLimitConfig?: {
            perIpQps?: int32(name='PerIpQps', description='The key of the header.

*   The key must be 1 to 40 characters in length,
*   and can contain lowercase letters, digits, hyphens (-), and underscores (\\_).
*   Cookie and Host are not supported.', example='80'),
            QPS?: int32(name='QPS', description='The ID of the server group.', example='2'),
          }(name='TrafficLimitConfig'),
          trafficMirrorConfig?: {
            mirrorGroupConfig?: {
              serverGroupTuples?: [ 
                {
                  serverGroupId?: string(name='ServerGroupId', description='The allowed HTTP methods for CORS requests. Valid values:

*   **GET**
*   **POST**
*   **PUT**
*   **DELETE**
*   **HEAD**
*   **OPTIONS**
*   **PATCH**', example='srg-00mkgijak0w4qgz9****'),
                }
              ](name='ServerGroupTuples'),
            }(name='MirrorGroupConfig'),
            targetType?: string(name='TargetType', description='The allowed origins of CORS requests. You can set this parameter to an asterisk (`*`) or one or more values. The values cannot be asterisks (`*`).

*   Each value must start with `http://` or `https://`, followed by a valid domain name or a first-level wildcard domain name, such as `*.test.abc.example.com`.
*   You can specify a port in a value. Port range: **1** to **65535**.', example='ForwardGroupMirror'),
          }(name='TrafficMirrorConfig'),
          type?: string(name='Type', description='The type of destination to which network traffic is mirrored. Valid values:

*   **ForwardGroupMirror:** a server group.
*   **SlsMirror:** Log Service.', example='Host'),
        }
      ](name='RuleActions'),
      ruleConditions?: [ 
        {
          cookieConfig?: {
            values?: [ 
              {
                key?: string(name='Key', description='The value of the response header. The value must be 1 to 128 characters in length. It can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. For example, lowercase letters, asterisks (\\*), and question marks (?). The value cannot start or end with a space character.', example='test'),
                value?: string(name='Value', description='The hostname.

Take note of the following rules when you specify a hostname:

*   The hostname must be 3 to 128 characters in length, and can contain lowercase letters, digits, and the following special characters: - . \\* = ~ \\_ + \\ ^ ! $ & | ( ) \\[ ] ?.
*   The hostname must contain at least one period (.) but cannot start or end with a period (.).
*   The rightmost domain label can contain only letters, asterisks (\\*), and question marks (?), and cannot contain digits or hyphens (-). The leftmost `domain label` can be an asterisk (\\*).
*   The domain labels cannot start or end with a hyphen (-). You can specify asterisks () and question marks (?) anywhere in a domain label.
*   If you specify an exact hostname or a wildcard hostname, the hostname cannot start with a tilde (~).
*   If you specify a regular expression, the regular expression cannot start with an asterisk (\\*). The regular expression is not case-sensitive.', example='test'),
              }
            ](name='Values'),
          }(name='CookieConfig'),
          headerConfig?: {
            key?: string(name='Key', description='The request methods.

Valid values: **HEAD**, **GET**, **POST**, **OPTIONS**, **PUT**, **PATCH**, and **DELETE**.', example='Port'),
            values?: [ string ](name='Values'),
          }(name='HeaderConfig'),
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
          methodConfig?: {
            values?: [ string ](name='Values'),
          }(name='MethodConfig'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          queryStringConfig?: {
            values?: [ 
              {
                key?: string(name='Key', description='The value of the response header.

*   The value must be 1 to 128 characters in length.
*   It can contain printable characters whose ASCII values are `greater than or equal to 32 and smaller than 127`. For example, lowercase letters, asterisks (\\*), and question marks (?).
*   The value cannot start or end with a space character.', example='test'),
                value?: string(name='Value', description='The status code in responses. Valid values: **100** to **599**.', example='test'),
              }
            ](name='Values'),
          }(name='QueryStringConfig'),
          responseHeaderConfig?: {
            key?: string(name='Key', description='The type of action specified in the forwarding rule. You can specify at most 11 types of actions. Valid values:

*   **ForwardGroup:** forwards a request to multiple vServer groups.
*   **Redirect:** redirects a request.
*   **FixedResponse:** returns a custom response.
*   **Rewrite:** rewrites a request.
*   **InsertHeader:** adds a header to a request.
*   **RemoveHeaderConfig:** deletes the header of a request.
*   **TrafficLimitConfig:** throttles traffic.
*   **TrafficMirrorConfig:** mirrors traffic.
*   **CorsConfig:** forwards requests based on CORS.

The preceding actions can be classified into two broad types:

*   **FinalType:** the last action to be performed in a forwarding rule. Each forwarding rule can contain only one FinalType action. You can specify a **ForwardGroup**, **Redirect**, or **FixedResponse** action as the FinalType action.
*   **ExtType:** the actions to be performed before the FinalType action. A forwarding rule can contain one or more ExtType actions. To specify this parameter, you must also specify FinalType. You can specify multiple **InsertHeader** actions or one **Rewrite** action.', example='test'),
            values?: [ string ](name='Values'),
          }(name='ResponseHeaderConfig'),
          responseStatusCodeConfig?: {
            values?: [ string ](name='Values'),
          }(name='ResponseStatusCodeConfig'),
          sourceIpConfig?: {
            values?: [ string ](name='Values'),
          }(name='SourceIpConfig'),
          type?: string(name='Type', description='Specifies whether to perform a dry run. Valid values:

*   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false**: sends the request. If the request passes the dry run, the system returns an `HTTP 2xx` status code and performs the operation. This is the default value.', example='ForwardGroup'),
        }
      ](name='RuleConditions'),
      ruleId?: string(name='RuleId', description='The ID of the asynchronous task.', example='rule-cxjh7vazn2jpnl****'),
      ruleName?: string(name='RuleName', description='The HTTP status code in the response. Valid values: **HTTP\\_2xx**, **HTTP\\_4xx**, and **HTTP\\_5xx**. **x** must be a digit.', example='rule-instance-test'),
    }
  ](name='Rules'),
}

model UpdateRulesAttributeResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model UpdateRulesAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRulesAttributeResponseBody(name='body'),
}

/**
  * The priority of the forwarding rule. Valid values: **1 to 10000**. A lower value specifies a higher priority. You can specify at most 20 forwarding rules.
  * >  The priority of each forwarding rule within a listener is unique.
  *
  * @param request UpdateRulesAttributeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateRulesAttributeResponse
 */
async function updateRulesAttributeWithOptions(request: UpdateRulesAttributeRequest, runtime: Util.RuntimeOptions): UpdateRulesAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.rules)) {
    query['Rules'] = request.rules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRulesAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The priority of the forwarding rule. Valid values: **1 to 10000**. A lower value specifies a higher priority. You can specify at most 20 forwarding rules.
  * >  The priority of each forwarding rule within a listener is unique.
  *
  * @param request UpdateRulesAttributeRequest
  * @return UpdateRulesAttributeResponse
 */
async function updateRulesAttribute(request: UpdateRulesAttributeRequest): UpdateRulesAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRulesAttributeWithOptions(request, runtime);
}

model UpdateSecurityPolicyAttributeRequest {
  ciphers?: [ string ](name='Ciphers', description='The supported cipher suites.'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.

> If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. Valid values:

*   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
*   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.', example='true'),
  securityPolicyId?: string(name='SecurityPolicyId', description='The security policy ID.', example='spy-n0kn923****'),
  securityPolicyName?: string(name='SecurityPolicyName', description='The name of the security policy.

The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.', example='test-secrity'),
  TLSVersions?: [ string ](name='TLSVersions', description='The supported TLS protocol versions.'),
}

model UpdateSecurityPolicyAttributeResponseBody = {
  jobId?: string(name='JobId', description='The asynchronous task ID.', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', description='The request ID.', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
}

model UpdateSecurityPolicyAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSecurityPolicyAttributeResponseBody(name='body'),
}

/**
  * ##
  * **UpdateSecurityPolicyAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListSecurityPolicies](~~213609~~) to query the status of the task.
  * *   If a security policy is in the **Configuring** state, the security policy is being updated.
  * *   If a security policy is in the **Available** state, the security policy is updated.
  *
  * @param request UpdateSecurityPolicyAttributeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateSecurityPolicyAttributeResponse
 */
async function updateSecurityPolicyAttributeWithOptions(request: UpdateSecurityPolicyAttributeRequest, runtime: Util.RuntimeOptions): UpdateSecurityPolicyAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ciphers)) {
    query['Ciphers'] = request.ciphers;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    query['SecurityPolicyId'] = request.securityPolicyId;
  }
  if (!Util.isUnset(request.securityPolicyName)) {
    query['SecurityPolicyName'] = request.securityPolicyName;
  }
  if (!Util.isUnset(request.TLSVersions)) {
    query['TLSVersions'] = request.TLSVersions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSecurityPolicyAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ##
  * **UpdateSecurityPolicyAttribute** is an asynchronous operation. After a request is sent, the system returns a request ID and runs the task in the background. You can call [ListSecurityPolicies](~~213609~~) to query the status of the task.
  * *   If a security policy is in the **Configuring** state, the security policy is being updated.
  * *   If a security policy is in the **Available** state, the security policy is updated.
  *
  * @param request UpdateSecurityPolicyAttributeRequest
  * @return UpdateSecurityPolicyAttributeResponse
 */
async function updateSecurityPolicyAttribute(request: UpdateSecurityPolicyAttributeRequest): UpdateSecurityPolicyAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecurityPolicyAttributeWithOptions(request, runtime);
}

model UpdateServerGroupAttributeRequest {
  clientToken?: string(name='ClientToken', description='The configuration of health checks.', example='5A2CFF0E-5718-45B5-9D4D-70B3FF3898'),
  dryRun?: boolean(name='DryRun', description='The backend port that is used for health checks.

Valid values: **0** to **65535**.

If you set the value to **0**, the ports of backend servers are used for health checks.

>  This parameter takes effect when the **HealthCheckEnabled** parameter is set to **true**.', example='true'),
  healthCheckConfig?: {
    healthCheckCodes?: [ string ](name='HealthCheckCodes', description='The interval between two consecutive health checks. Unit: seconds.

Valid values: **1** to **50**.

>  This parameter takes effect when the **HealthCheckEnabled** parameter is set to **true**.'),
    healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='The domain name that is used for health checks. The domain name must meet the following requirements:

*   The domain name must be 1 to 80 characters in length.
*   The domain name can contain lowercase letters, digits, hyphens (-), and periods (.).
*   It must contain at least one period (.) but cannot start or end with a period (.).
*   The rightmost field of the domain name can contain only letters and cannot contain digits or hyphens (-).
*   Other fields cannot start or end with a hyphen (-).

>  This parameter takes effect when the **HealthCheckEnabled** parameter is set to true and the **HealthCheckProtocol** parameter is set to **HTTP**.', example='80'),
    healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='The HTTP status codes that indicate a successful health check.

*   If **HealthCheckProtocol** is set to **HTTP**, **HealthCheckCodes** can be set to **http\\_2xx** (default), **http\\_3xx**, **http\\_4xx**, and **http\\_5xx**. Separate multiple HTTP status codes with commas (,).
*   If **HealthCheckProtocol** is set to **gRPC**, **HealthCheckCodes** can be set to **0 to 99**. Default value: **0**. Value ranges are supported. You can enter up to 20 value ranges. Separate multiple value ranges with commas (,).

>  This parameter takes effect when the **HealthCheckEnabled** parameter is set to **true** and the **HealthCheckProtocol** parameter is set to **HTTP** or **gRPC**.', example='true'),
    healthCheckHost?: string(name='HealthCheckHost', description='The version of HTTP that is used for health checks. Valid values:

*   **HTTP1.0**
*   **HTTP1.1**

>  This parameter takes effect when the **HealthCheckEnabled** parameter is set to true and the **HealthCheckProtocol** parameter is set to **HTTP**.', example='example.com'),
    healthCheckHttpVersion?: string(name='HealthCheckHttpVersion', description='The HTTP method that is used for health checks. Valid values:

*   **GET**: If the length of a response exceeds 8 KB, the response is truncated. However, the health check result is not affected.
*   **POST**: By default, gRPC health checks use the POST method.
*   **HEAD**: By default, HTTP health checks use the HEAD method.

>  This parameter takes effect when the **HealthCheckEnabled** parameter is set to true and the **HealthCheckProtocol** parameter is set to **HTTP** or **gRPC**.', example='HTTP1.1'),
    healthCheckInterval?: int32(name='HealthCheckInterval', description='The path that is used for health checks.

The path must be 1 to 80 characters in length and can contain only letters, digits, and the following special characters: `- / . % ? # & =`. It can also contain the following extended characters: `_ ; ~ ! ( ) * [ ] @ $ ^ : \\" , +`. The path must start with a forward slash (`/`).

>  This parameter takes effect when the **HealthCheckEnabled** parameter is set to **true** and the **HealthCheckProtocol** parameter is set to **HTTP**.', example='5'),
    healthCheckMethod?: string(name='HealthCheckMethod', description='The protocol that is used for health checks. Valid values:

*   **HTTP**: To perform HTTP health checks, Application Load Balancer (ALB) sends HEAD or GET requests to a backend server to check whether the backend server is healthy.
*   **TCP**: To perform TCP health checks, ALB sends SYN packets to the backend server to check whether the port of the backend server is available to receive requests.
*   **gRPC**: To perform gRPC health checks, ALB sends POST or GET requests to a backend server to check whether the backend server is healthy.', example='HEAD'),
    healthCheckPath?: string(name='HealthCheckPath', description='The timeout period of a health check response. If a backend server, such as an Elastic Compute Service (ECS) instance, does not return a health check response within the specified timeout period, the server fails the health check. Unit: seconds.

Valid values: **1** to **300**.

> 
*   If the value of the **HealthCheckTimeout** parameter is smaller than that of the **HealthCheckInterval** parameter, the timeout period specified by the **HealthCheckTimeout** parameter is ignored and the value of the **HealthCheckInterval** parameter is used as the timeout period.
*   This parameter takes effect when the **HealthCheckEnabled** parameter is set to **true**.', example='/test/index.html'),
    healthCheckProtocol?: string(name='HealthCheckProtocol', description='The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**.

Valid values: **2** to **10**.', example='HTTP'),
    healthCheckTimeout?: int32(name='HealthCheckTimeout', description='The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**.

Valid values: **2** to **10**.', example='3'),
    healthyThreshold?: int32(name='HealthyThreshold', description='The configuration of session persistence.', example='4'),
    unhealthyThreshold?: int32(name='UnhealthyThreshold', description='The cookie that is configured on the server.

The cookie must be 1 to 200 characters in length and can contain only ASCII characters and digits. It cannot contain commas (,), semicolons (;), or space characters. It cannot start with a dollar sign ($).

>  This parameter takes effect when the **StickySessionEnabled** parameter is set to **true** and the **StickySessionType** parameter is set to **Server**.', example='4'),
  }(name='HealthCheckConfig', description='Specifies whether to enable the health check feature. Valid values:

*   **true** (default): enables the feature.
*   **false**: disables the feature.'),
  scheduler?: string(name='Scheduler', description='Specifies whether to check the request without performing the operation. Valid values:

*   **true**: checks the request without performing the operation. The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the check, an HTTP `2xx` status code is returned and the operation is performed.', example='Wrr'),
  serverGroupId?: string(name='ServerGroupId', description='The ID of the asynchronous task.', example='sgp-atstuj3rtop****'),
  serverGroupName?: string(name='ServerGroupName', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, the system automatically uses RequestId as ClientToken. The value of RequestId for each API request may be different.', example='test'),
  serviceName?: string(name='ServiceName', description='The ID of the request.', example='test2'),
  stickySessionConfig?: {
    cookie?: string(name='Cookie', description='Specifies whether to enable session persistence. Valid values:

*   **true**: enables session persistence.
*   **false** (default): disables session persistence.', example='B490B5EBF6F3CD402E515D22BCDA1598'),
    cookieTimeout?: int32(name='CookieTimeout', description='The method that is used to handle a cookie. Valid values:

*   **Insert**: inserts a cookie.

    ALB inserts a cookie (SERVERID) into the first HTTP or HTTPS response packet that is sent to a client. The next request from the client contains this cookie and the listener forwards this request to the recorded backend server.

*   **Server**: rewrites a cookie.

    When ALB detects a user-defined cookie, it overwrites the original cookie with the user-defined cookie. Subsequent requests to ALB carry this user-defined cookie, and ALB determines the destination servers of the requests based on the cookies.

>  This parameter takes effect when the **StickySessionEnabled** parameter is set to **true**.', example='1000'),
    stickySessionEnabled?: boolean(name='StickySessionEnabled', description='The ID of the server group.', example='false'),
    stickySessionType?: string(name='StickySessionType', description='This parameter is available only if the ALB Ingress controller is used. In this case, set this parameter to the name of the `Kubernetes Service` that is associated with the server group.', example='Insert'),
  }(name='StickySessionConfig', description='The timeout period of a cookie. Unit: seconds.

Valid values: **1** to **86400**.

>  This parameter takes effect when the **StickySessionEnabled** parameter is set to **true** and the **StickySessionType** parameter is set to **Insert**.'),
  uchConfig?: {
    type?: string(name='Type', description='', example='QueryString'),
    value?: string(name='Value', description='hash', example='abc'),
  }(name='UchConfig', description='urlhash'),
}

model UpdateServerGroupAttributeResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model UpdateServerGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServerGroupAttributeResponseBody(name='body'),
}

/**
  * The name of the server group.
  * The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.
  *
  * @param request UpdateServerGroupAttributeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateServerGroupAttributeResponse
 */
async function updateServerGroupAttributeWithOptions(request: UpdateServerGroupAttributeRequest, runtime: Util.RuntimeOptions): UpdateServerGroupAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.healthCheckConfig)) {
    query['HealthCheckConfig'] = request.healthCheckConfig;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.serverGroupName)) {
    query['ServerGroupName'] = request.serverGroupName;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.stickySessionConfig)) {
    query['StickySessionConfig'] = request.stickySessionConfig;
  }
  if (!Util.isUnset(request.uchConfig)) {
    query['UchConfig'] = request.uchConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServerGroupAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The name of the server group.
  * The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (\\_), and hyphens (-). The name must start with a letter.
  *
  * @param request UpdateServerGroupAttributeRequest
  * @return UpdateServerGroupAttributeResponse
 */
async function updateServerGroupAttribute(request: UpdateServerGroupAttributeRequest): UpdateServerGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateServerGroupAttributeWithOptions(request, runtime);
}

model UpdateServerGroupServersAttributeRequest {
  clientToken?: string(name='ClientToken', example='593B0448-D13E-4C56-AC0D-FDF0FDE0E9A3'),
  dryRun?: boolean(name='DryRun', example='false'),
  serverGroupId?: string(name='ServerGroupId', description='The type of the backend server. You can specify at most 40 servers in each call. Valid values:

*   **Ecs**: an ECS instance
*   **Eni**: an ENI
*   **Eci**: an elastic container instance
*   **Ip**: an IP address
*   **Fc**: a function', example='sgp-atstuj3rtop****'),
  servers?: [ 
    {
      description?: string(name='Description', description='The weight of the backend server. Valid values: **0** to **100**. Default value: **100**. If the weight of a backend server is set to **0**, no requests are forwarded to the backend server. You can specify at most 40 servers in each call.

>  You do not need to set this parameter if **ServerType** is set to **Fc**.', example='test'),
      port?: int32(name='Port', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.

>  If you do not set this parameter, the system uses **RequestId** as **ClientToken**. The value of **RequestId** may be different for each API request.', example='80'),
      serverId?: string(name='ServerId', description='Specifies whether to check the request without performing the operation. Valid values:

*   **true**: checks the request without performing the operation The system checks the required parameters, request syntax, and limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
*   **false** (default): sends the request. If the request passes the check, a 2xx HTTP status code is returned and the operation is performed.', example='i-bp1f9kdprbgy9uiu****'),
      serverIp?: string(name='ServerIp', description='The ID of the asynchronous task.', example='192.168.1.1'),
      serverType?: string(name='ServerType', description='The ID of the request.', example='Ecs'),
      weight?: int32(name='Weight', example='100'),
    }
  ](name='Servers'),
}

model UpdateServerGroupServersAttributeResponseBody = {
  jobId?: string(name='JobId', example='72dcd26b-f12d-4c27-b3af-18f6aed5****'),
  requestId?: string(name='RequestId', example='365F4154-92F6-4AE4-92F8-7FF34B540710'),
}

model UpdateServerGroupServersAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServerGroupServersAttributeResponseBody(name='body'),
}

/**
  * The ID of the server. You can specify at most 40 servers in each call.
  * *   If **ServerType** is set to **Ecs**, **Eni**, or **Eci**, set the ServerId parameter to the ID of an Elastic Compute Service (ECS) instance, an elastic network interface (ENI), or an elastic container instance.
  * *   If **ServerType** is set to **Ip**, set the ServerId parameter to an IP address.
  * *   If **ServerType** is set to **Fc**, set the ServerId parameter to the Alibaba Cloud Resource Name (ARN) of a function.
  *
  * @param request UpdateServerGroupServersAttributeRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateServerGroupServersAttributeResponse
 */
async function updateServerGroupServersAttributeWithOptions(request: UpdateServerGroupServersAttributeRequest, runtime: Util.RuntimeOptions): UpdateServerGroupServersAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.servers)) {
    query['Servers'] = request.servers;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServerGroupServersAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The ID of the server. You can specify at most 40 servers in each call.
  * *   If **ServerType** is set to **Ecs**, **Eni**, or **Eci**, set the ServerId parameter to the ID of an Elastic Compute Service (ECS) instance, an elastic network interface (ENI), or an elastic container instance.
  * *   If **ServerType** is set to **Ip**, set the ServerId parameter to an IP address.
  * *   If **ServerType** is set to **Fc**, set the ServerId parameter to the Alibaba Cloud Resource Name (ARN) of a function.
  *
  * @param request UpdateServerGroupServersAttributeRequest
  * @return UpdateServerGroupServersAttributeResponse
 */
async function updateServerGroupServersAttribute(request: UpdateServerGroupServersAttributeRequest): UpdateServerGroupServersAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateServerGroupServersAttributeWithOptions(request, runtime);
}

