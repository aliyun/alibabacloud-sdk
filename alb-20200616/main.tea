/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('alb', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddEntriesToAclRequest {
  aclEntries?: [ 
    {
      description?: string(name='Description'),
      entry?: string(name='Entry'),
    }
  ](name='AclEntries'),
  aclId?: string(name='AclId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model AddEntriesToAclResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model AddEntriesToAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddEntriesToAclResponseBody(name='body'),
}

async function addEntriesToAclWithOptions(request: AddEntriesToAclRequest, runtime: Util.RuntimeOptions): AddEntriesToAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclEntries)) {
    query['AclEntries'] = request.aclEntries;
  }
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddEntriesToAcl',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addEntriesToAcl(request: AddEntriesToAclRequest): AddEntriesToAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return addEntriesToAclWithOptions(request, runtime);
}

model AddServersToServerGroupRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  serverGroupId?: string(name='ServerGroupId'),
  servers?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      serverIp?: string(name='ServerIp'),
      serverType?: string(name='ServerType'),
      weight?: int32(name='Weight'),
    }
  ](name='Servers'),
}

model AddServersToServerGroupResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model AddServersToServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddServersToServerGroupResponseBody(name='body'),
}

async function addServersToServerGroupWithOptions(request: AddServersToServerGroupRequest, runtime: Util.RuntimeOptions): AddServersToServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.servers)) {
    query['Servers'] = request.servers;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddServersToServerGroup',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addServersToServerGroup(request: AddServersToServerGroupRequest): AddServersToServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addServersToServerGroupWithOptions(request, runtime);
}

model ApplyHealthCheckTemplateToServerGroupRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  healthCheckTemplateId?: string(name='HealthCheckTemplateId'),
  serverGroupId?: string(name='ServerGroupId'),
}

model ApplyHealthCheckTemplateToServerGroupResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model ApplyHealthCheckTemplateToServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyHealthCheckTemplateToServerGroupResponseBody(name='body'),
}

async function applyHealthCheckTemplateToServerGroupWithOptions(request: ApplyHealthCheckTemplateToServerGroupRequest, runtime: Util.RuntimeOptions): ApplyHealthCheckTemplateToServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.healthCheckTemplateId)) {
    query['HealthCheckTemplateId'] = request.healthCheckTemplateId;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyHealthCheckTemplateToServerGroup',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyHealthCheckTemplateToServerGroup(request: ApplyHealthCheckTemplateToServerGroupRequest): ApplyHealthCheckTemplateToServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyHealthCheckTemplateToServerGroupWithOptions(request, runtime);
}

model AssociateAclsWithListenerRequest {
  aclIds?: [ string ](name='AclIds'),
  aclType?: string(name='AclType'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  listenerId?: string(name='ListenerId'),
}

model AssociateAclsWithListenerResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model AssociateAclsWithListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateAclsWithListenerResponseBody(name='body'),
}

async function associateAclsWithListenerWithOptions(request: AssociateAclsWithListenerRequest, runtime: Util.RuntimeOptions): AssociateAclsWithListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclIds)) {
    query['AclIds'] = request.aclIds;
  }
  if (!Util.isUnset(request.aclType)) {
    query['AclType'] = request.aclType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateAclsWithListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateAclsWithListener(request: AssociateAclsWithListenerRequest): AssociateAclsWithListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateAclsWithListenerWithOptions(request, runtime);
}

model AssociateAdditionalCertificatesWithListenerRequest {
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId'),
    }
  ](name='Certificates'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  listenerId?: string(name='ListenerId'),
}

model AssociateAdditionalCertificatesWithListenerResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model AssociateAdditionalCertificatesWithListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateAdditionalCertificatesWithListenerResponseBody(name='body'),
}

async function associateAdditionalCertificatesWithListenerWithOptions(request: AssociateAdditionalCertificatesWithListenerRequest, runtime: Util.RuntimeOptions): AssociateAdditionalCertificatesWithListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificates)) {
    query['Certificates'] = request.certificates;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateAdditionalCertificatesWithListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateAdditionalCertificatesWithListener(request: AssociateAdditionalCertificatesWithListenerRequest): AssociateAdditionalCertificatesWithListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateAdditionalCertificatesWithListenerWithOptions(request, runtime);
}

model AttachCommonBandwidthPackageToLoadBalancerRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  loadBalancerId?: string(name='LoadBalancerId'),
  regionId?: string(name='RegionId'),
}

model AttachCommonBandwidthPackageToLoadBalancerResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model AttachCommonBandwidthPackageToLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachCommonBandwidthPackageToLoadBalancerResponseBody(name='body'),
}

async function attachCommonBandwidthPackageToLoadBalancerWithOptions(request: AttachCommonBandwidthPackageToLoadBalancerRequest, runtime: Util.RuntimeOptions): AttachCommonBandwidthPackageToLoadBalancerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachCommonBandwidthPackageToLoadBalancer',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachCommonBandwidthPackageToLoadBalancer(request: AttachCommonBandwidthPackageToLoadBalancerRequest): AttachCommonBandwidthPackageToLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachCommonBandwidthPackageToLoadBalancerWithOptions(request, runtime);
}

model CreateAclRequest {
  aclName?: string(name='AclName'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateAclResponseBody = {
  aclId?: string(name='AclId'),
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model CreateAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAclResponseBody(name='body'),
}

async function createAclWithOptions(request: CreateAclRequest, runtime: Util.RuntimeOptions): CreateAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclName)) {
    query['AclName'] = request.aclName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAcl',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAcl(request: CreateAclRequest): CreateAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAclWithOptions(request, runtime);
}

model CreateHealthCheckTemplateRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  healthCheckCodes?: [ string ](name='HealthCheckCodes'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckHost?: string(name='HealthCheckHost'),
  healthCheckHttpVersion?: string(name='HealthCheckHttpVersion'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckPath?: string(name='HealthCheckPath'),
  healthCheckProtocol?: string(name='HealthCheckProtocol'),
  healthCheckTemplateName?: string(name='HealthCheckTemplateName'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
}

model CreateHealthCheckTemplateResponseBody = {
  healthCheckTemplateId?: string(name='HealthCheckTemplateId'),
  requestId?: string(name='RequestId'),
}

model CreateHealthCheckTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHealthCheckTemplateResponseBody(name='body'),
}

async function createHealthCheckTemplateWithOptions(request: CreateHealthCheckTemplateRequest, runtime: Util.RuntimeOptions): CreateHealthCheckTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.healthCheckCodes)) {
    query['HealthCheckCodes'] = request.healthCheckCodes;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckHost)) {
    query['HealthCheckHost'] = request.healthCheckHost;
  }
  if (!Util.isUnset(request.healthCheckHttpVersion)) {
    query['HealthCheckHttpVersion'] = request.healthCheckHttpVersion;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckMethod)) {
    query['HealthCheckMethod'] = request.healthCheckMethod;
  }
  if (!Util.isUnset(request.healthCheckPath)) {
    query['HealthCheckPath'] = request.healthCheckPath;
  }
  if (!Util.isUnset(request.healthCheckProtocol)) {
    query['HealthCheckProtocol'] = request.healthCheckProtocol;
  }
  if (!Util.isUnset(request.healthCheckTemplateName)) {
    query['HealthCheckTemplateName'] = request.healthCheckTemplateName;
  }
  if (!Util.isUnset(request.healthCheckTimeout)) {
    query['HealthCheckTimeout'] = request.healthCheckTimeout;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHealthCheckTemplate',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHealthCheckTemplate(request: CreateHealthCheckTemplateRequest): CreateHealthCheckTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHealthCheckTemplateWithOptions(request, runtime);
}

model CreateListenerRequest {
  caCertificates?: [ 
    {
    }
  ](name='CaCertificates'),
  caEnabled?: boolean(name='CaEnabled'),
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId'),
    }
  ](name='Certificates'),
  clientToken?: string(name='ClientToken'),
  defaultActions?: [ 
    {
      forwardGroupConfig?: {
        serverGroupTuples?: [ 
          {
            serverGroupId?: string(name='ServerGroupId'),
          }
        ](name='ServerGroupTuples'),
      }(name='ForwardGroupConfig'),
      type?: string(name='Type'),
    }
  ](name='DefaultActions'),
  dryRun?: boolean(name='DryRun'),
  gzipEnabled?: boolean(name='GzipEnabled'),
  http2Enabled?: boolean(name='Http2Enabled'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerDescription?: string(name='ListenerDescription'),
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalancerId?: string(name='LoadBalancerId'),
  quicConfig?: {
    quicListenerId?: string(name='QuicListenerId'),
    quicUpgradeEnabled?: boolean(name='QuicUpgradeEnabled'),
  }(name='QuicConfig'),
  requestTimeout?: int32(name='RequestTimeout'),
  securityPolicyId?: string(name='SecurityPolicyId'),
  XForwardedForConfig?: {
    XForwardedForClientCertClientVerifyAlias?: string(name='XForwardedForClientCertClientVerifyAlias'),
    XForwardedForClientCertClientVerifyEnabled?: boolean(name='XForwardedForClientCertClientVerifyEnabled'),
    XForwardedForClientCertFingerprintAlias?: string(name='XForwardedForClientCertFingerprintAlias'),
    XForwardedForClientCertFingerprintEnabled?: boolean(name='XForwardedForClientCertFingerprintEnabled'),
    XForwardedForClientCertIssuerDNAlias?: string(name='XForwardedForClientCertIssuerDNAlias'),
    XForwardedForClientCertIssuerDNEnabled?: boolean(name='XForwardedForClientCertIssuerDNEnabled'),
    XForwardedForClientCertSubjectDNAlias?: string(name='XForwardedForClientCertSubjectDNAlias'),
    XForwardedForClientCertSubjectDNEnabled?: boolean(name='XForwardedForClientCertSubjectDNEnabled'),
    XForwardedForClientSourceIpsEnabled?: boolean(name='XForwardedForClientSourceIpsEnabled'),
    XForwardedForClientSourceIpsTrusted?: string(name='XForwardedForClientSourceIpsTrusted'),
    XForwardedForClientSrcPortEnabled?: boolean(name='XForwardedForClientSrcPortEnabled'),
    XForwardedForEnabled?: boolean(name='XForwardedForEnabled'),
    XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled'),
    XForwardedForSLBIdEnabled?: boolean(name='XForwardedForSLBIdEnabled'),
    XForwardedForSLBPortEnabled?: boolean(name='XForwardedForSLBPortEnabled'),
  }(name='XForwardedForConfig'),
}

model CreateListenerResponseBody = {
  jobId?: string(name='JobId'),
  listenerId?: string(name='ListenerId'),
  requestId?: string(name='RequestId'),
}

model CreateListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateListenerResponseBody(name='body'),
}

async function createListenerWithOptions(request: CreateListenerRequest, runtime: Util.RuntimeOptions): CreateListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caCertificates)) {
    query['CaCertificates'] = request.caCertificates;
  }
  if (!Util.isUnset(request.caEnabled)) {
    query['CaEnabled'] = request.caEnabled;
  }
  if (!Util.isUnset(request.certificates)) {
    query['Certificates'] = request.certificates;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.defaultActions)) {
    query['DefaultActions'] = request.defaultActions;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.gzipEnabled)) {
    query['GzipEnabled'] = request.gzipEnabled;
  }
  if (!Util.isUnset(request.http2Enabled)) {
    query['Http2Enabled'] = request.http2Enabled;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    query['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerDescription)) {
    query['ListenerDescription'] = request.listenerDescription;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.quicConfig)) {
    query['QuicConfig'] = request.quicConfig;
  }
  if (!Util.isUnset(request.requestTimeout)) {
    query['RequestTimeout'] = request.requestTimeout;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    query['SecurityPolicyId'] = request.securityPolicyId;
  }
  if (!Util.isUnset(request.XForwardedForConfig)) {
    query['XForwardedForConfig'] = request.XForwardedForConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createListener(request: CreateListenerRequest): CreateListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createListenerWithOptions(request, runtime);
}

model CreateLoadBalancerRequest {
  addressAllocatedMode?: string(name='AddressAllocatedMode'),
  addressIpVersion?: string(name='AddressIpVersion'),
  addressType?: string(name='AddressType'),
  clientToken?: string(name='ClientToken'),
  deletionProtectionEnabled?: boolean(name='DeletionProtectionEnabled'),
  dryRun?: boolean(name='DryRun'),
  loadBalancerBillingConfig?: {
    bandwidthPackageId?: string(name='BandwidthPackageId'),
    payType?: string(name='PayType'),
  }(name='LoadBalancerBillingConfig'),
  loadBalancerEdition?: string(name='LoadBalancerEdition'),
  loadBalancerName?: string(name='LoadBalancerName'),
  modificationProtectionConfig?: {
    reason?: string(name='Reason'),
    status?: string(name='Status'),
  }(name='ModificationProtectionConfig'),
  resourceGroupId?: string(name='ResourceGroupId'),
  vpcId?: string(name='VpcId'),
  zoneMappings?: [ 
    {
      vSwitchId?: string(name='VSwitchId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='ZoneMappings'),
}

model CreateLoadBalancerResponseBody = {
  loadBalancerId?: string(name='LoadBalancerId'),
  requestId?: string(name='RequestId'),
}

model CreateLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLoadBalancerResponseBody(name='body'),
}

async function createLoadBalancerWithOptions(request: CreateLoadBalancerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addressAllocatedMode)) {
    query['AddressAllocatedMode'] = request.addressAllocatedMode;
  }
  if (!Util.isUnset(request.addressIpVersion)) {
    query['AddressIpVersion'] = request.addressIpVersion;
  }
  if (!Util.isUnset(request.addressType)) {
    query['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deletionProtectionEnabled)) {
    query['DeletionProtectionEnabled'] = request.deletionProtectionEnabled;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerBillingConfig)) {
    query['LoadBalancerBillingConfig'] = request.loadBalancerBillingConfig;
  }
  if (!Util.isUnset(request.loadBalancerEdition)) {
    query['LoadBalancerEdition'] = request.loadBalancerEdition;
  }
  if (!Util.isUnset(request.loadBalancerName)) {
    query['LoadBalancerName'] = request.loadBalancerName;
  }
  if (!Util.isUnset(request.modificationProtectionConfig)) {
    query['ModificationProtectionConfig'] = request.modificationProtectionConfig;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneMappings)) {
    query['ZoneMappings'] = request.zoneMappings;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoadBalancer',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLoadBalancer(request: CreateLoadBalancerRequest): CreateLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerWithOptions(request, runtime);
}

model CreateRuleRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  listenerId?: string(name='ListenerId'),
  priority?: int32(name='Priority'),
  ruleActions?: [ 
    {
      fixedResponseConfig?: {
        content?: string(name='Content'),
        contentType?: string(name='ContentType'),
        httpCode?: string(name='HttpCode'),
      }(name='FixedResponseConfig'),
      forwardGroupConfig?: {
        serverGroupStickySession?: {
          enabled?: boolean(name='Enabled'),
          timeout?: int32(name='Timeout'),
        }(name='ServerGroupStickySession'),
        serverGroupTuples?: [ 
          {
            serverGroupId?: string(name='ServerGroupId'),
            weight?: int32(name='Weight'),
          }
        ](name='ServerGroupTuples'),
      }(name='ForwardGroupConfig'),
      insertHeaderConfig?: {
        key?: string(name='Key'),
        value?: string(name='Value'),
        valueType?: string(name='ValueType'),
      }(name='InsertHeaderConfig'),
      order?: int32(name='Order'),
      redirectConfig?: {
        host?: string(name='Host'),
        httpCode?: string(name='HttpCode'),
        path?: string(name='Path'),
        port?: string(name='Port'),
        protocol?: string(name='Protocol'),
        query?: string(name='Query'),
      }(name='RedirectConfig'),
      rewriteConfig?: {
        host?: string(name='Host'),
        path?: string(name='Path'),
        query?: string(name='Query'),
      }(name='RewriteConfig'),
      trafficLimitConfig?: {
        perIpQps?: int32(name='PerIpQps'),
        QPS?: int32(name='QPS'),
      }(name='TrafficLimitConfig'),
      trafficMirrorConfig?: {
        mirrorGroupConfig?: {
          serverGroupTuples?: [ 
            {
              serverGroupId?: string(name='ServerGroupId'),
            }
          ](name='ServerGroupTuples'),
        }(name='MirrorGroupConfig'),
        targetType?: string(name='TargetType'),
      }(name='TrafficMirrorConfig'),
      type?: string(name='Type'),
    }
  ](name='RuleActions'),
  ruleConditions?: [ 
    {
      cookieConfig?: {
        values?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Values'),
      }(name='CookieConfig'),
      headerConfig?: {
        key?: string(name='Key'),
        values?: [ string ](name='Values'),
      }(name='HeaderConfig'),
      hostConfig?: {
        values?: [ string ](name='Values'),
      }(name='HostConfig'),
      methodConfig?: {
        values?: [ string ](name='Values'),
      }(name='MethodConfig'),
      pathConfig?: {
        values?: [ string ](name='Values'),
      }(name='PathConfig'),
      queryStringConfig?: {
        values?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Values'),
      }(name='QueryStringConfig'),
      sourceIpConfig?: {
        values?: [ string ](name='Values'),
      }(name='SourceIpConfig'),
      type?: string(name='Type'),
    }
  ](name='RuleConditions'),
  ruleName?: string(name='RuleName'),
}

model CreateRuleResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
  ruleId?: string(name='RuleId'),
}

model CreateRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRuleResponseBody(name='body'),
}

async function createRuleWithOptions(request: CreateRuleRequest, runtime: Util.RuntimeOptions): CreateRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.ruleActions)) {
    query['RuleActions'] = request.ruleActions;
  }
  if (!Util.isUnset(request.ruleConditions)) {
    query['RuleConditions'] = request.ruleConditions;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRule',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRule(request: CreateRuleRequest): CreateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRuleWithOptions(request, runtime);
}

model CreateRulesRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  listenerId?: string(name='ListenerId'),
  rules?: [ 
    {
      direction?: string(name='Direction'),
      priority?: int32(name='Priority'),
      ruleActions?: [ 
        {
          fixedResponseConfig?: {
            content?: string(name='Content'),
            contentType?: string(name='ContentType'),
            httpCode?: string(name='HttpCode'),
          }(name='FixedResponseConfig'),
          forwardGroupConfig?: {
            serverGroupStickySession?: {
              enabled?: boolean(name='Enabled'),
              timeout?: int32(name='Timeout'),
            }(name='ServerGroupStickySession'),
            serverGroupTuples?: [ 
              {
                serverGroupId?: string(name='ServerGroupId'),
                weight?: int32(name='Weight'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
          insertHeaderConfig?: {
            key?: string(name='Key'),
            value?: string(name='Value'),
            valueType?: string(name='ValueType'),
          }(name='InsertHeaderConfig'),
          order?: int32(name='Order'),
          redirectConfig?: {
            host?: string(name='Host'),
            httpCode?: string(name='HttpCode'),
            path?: string(name='Path'),
            port?: string(name='Port'),
            protocol?: string(name='Protocol'),
            query?: string(name='Query'),
          }(name='RedirectConfig'),
          rewriteConfig?: {
            host?: string(name='Host'),
            path?: string(name='Path'),
            query?: string(name='Query'),
          }(name='RewriteConfig'),
          trafficLimitConfig?: {
            perIpQps?: int32(name='PerIpQps'),
            QPS?: int32(name='QPS'),
          }(name='TrafficLimitConfig'),
          trafficMirrorConfig?: {
            mirrorGroupConfig?: {
              serverGroupTuples?: [ 
                {
                  serverGroupId?: string(name='ServerGroupId'),
                }
              ](name='ServerGroupTuples'),
            }(name='MirrorGroupConfig'),
            targetType?: string(name='TargetType'),
          }(name='TrafficMirrorConfig'),
          type?: string(name='Type'),
        }
      ](name='RuleActions'),
      ruleConditions?: [ 
        {
          cookieConfig?: {
            values?: [ 
              {
                key?: string(name='Key'),
                value?: string(name='Value'),
              }
            ](name='Values'),
          }(name='CookieConfig'),
          headerConfig?: {
            key?: string(name='Key'),
            values?: [ string ](name='Values'),
          }(name='HeaderConfig'),
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
          methodConfig?: {
            values?: [ string ](name='Values'),
          }(name='MethodConfig'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          queryStringConfig?: {
            values?: [ 
              {
                key?: string(name='Key'),
                value?: string(name='Value'),
              }
            ](name='Values'),
          }(name='QueryStringConfig'),
          responseHeaderConfig?: {
            key?: string(name='Key'),
            values?: [ string ](name='Values'),
          }(name='ResponseHeaderConfig'),
          sourceIpConfig?: {
            values?: [ string ](name='Values'),
          }(name='SourceIpConfig'),
          type?: string(name='Type'),
        }
      ](name='RuleConditions'),
      ruleName?: string(name='RuleName'),
    }
  ](name='Rules'),
}

model CreateRulesResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
  ruleIds?: [ 
    {
      priority?: int32(name='Priority'),
      ruleId?: string(name='RuleId'),
    }
  ](name='RuleIds'),
}

model CreateRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRulesResponseBody(name='body'),
}

async function createRulesWithOptions(request: CreateRulesRequest, runtime: Util.RuntimeOptions): CreateRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.rules)) {
    query['Rules'] = request.rules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRules',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRules(request: CreateRulesRequest): CreateRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRulesWithOptions(request, runtime);
}

model CreateSecurityPolicyRequest {
  ciphers?: [ string ](name='Ciphers'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  resourceGroupId?: string(name='ResourceGroupId'),
  securityPolicyName?: string(name='SecurityPolicyName'),
  TLSVersions?: [ string ](name='TLSVersions'),
}

model CreateSecurityPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  securityPolicyId?: string(name='SecurityPolicyId'),
}

model CreateSecurityPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSecurityPolicyResponseBody(name='body'),
}

async function createSecurityPolicyWithOptions(request: CreateSecurityPolicyRequest, runtime: Util.RuntimeOptions): CreateSecurityPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ciphers)) {
    query['Ciphers'] = request.ciphers;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityPolicyName)) {
    query['SecurityPolicyName'] = request.securityPolicyName;
  }
  if (!Util.isUnset(request.TLSVersions)) {
    query['TLSVersions'] = request.TLSVersions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSecurityPolicy',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSecurityPolicy(request: CreateSecurityPolicyRequest): CreateSecurityPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSecurityPolicyWithOptions(request, runtime);
}

model CreateServerGroupRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  healthCheckConfig?: {
    healthCheckCodes?: [ string ](name='HealthCheckCodes'),
    healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
    healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
    healthCheckHost?: string(name='HealthCheckHost'),
    healthCheckHttpVersion?: string(name='HealthCheckHttpVersion'),
    healthCheckInterval?: int32(name='HealthCheckInterval'),
    healthCheckMethod?: string(name='HealthCheckMethod'),
    healthCheckPath?: string(name='HealthCheckPath'),
    healthCheckProtocol?: string(name='HealthCheckProtocol'),
    healthCheckTimeout?: int32(name='HealthCheckTimeout'),
    healthyThreshold?: int32(name='HealthyThreshold'),
    unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  }(name='HealthCheckConfig'),
  protocol?: string(name='Protocol'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scheduler?: string(name='Scheduler'),
  serverGroupName?: string(name='ServerGroupName'),
  serverGroupType?: string(name='ServerGroupType'),
  serviceName?: string(name='ServiceName'),
  stickySessionConfig?: {
    cookie?: string(name='Cookie'),
    cookieTimeout?: int32(name='CookieTimeout'),
    stickySessionEnabled?: boolean(name='StickySessionEnabled'),
    stickySessionType?: string(name='StickySessionType'),
  }(name='StickySessionConfig'),
  vpcId?: string(name='VpcId'),
}

model CreateServerGroupResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
  serverGroupId?: string(name='ServerGroupId'),
}

model CreateServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServerGroupResponseBody(name='body'),
}

async function createServerGroupWithOptions(request: CreateServerGroupRequest, runtime: Util.RuntimeOptions): CreateServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.healthCheckConfig)) {
    query['HealthCheckConfig'] = request.healthCheckConfig;
  }
  if (!Util.isUnset(request.protocol)) {
    query['Protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.serverGroupName)) {
    query['ServerGroupName'] = request.serverGroupName;
  }
  if (!Util.isUnset(request.serverGroupType)) {
    query['ServerGroupType'] = request.serverGroupType;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.stickySessionConfig)) {
    query['StickySessionConfig'] = request.stickySessionConfig;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServerGroup',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServerGroup(request: CreateServerGroupRequest): CreateServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServerGroupWithOptions(request, runtime);
}

model DeleteAclRequest {
  aclId?: string(name='AclId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model DeleteAclResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model DeleteAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAclResponseBody(name='body'),
}

async function deleteAclWithOptions(request: DeleteAclRequest, runtime: Util.RuntimeOptions): DeleteAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAcl',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAcl(request: DeleteAclRequest): DeleteAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAclWithOptions(request, runtime);
}

model DeleteHealthCheckTemplatesRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  healthCheckTemplateIds?: [ string ](name='HealthCheckTemplateIds'),
}

model DeleteHealthCheckTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHealthCheckTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHealthCheckTemplatesResponseBody(name='body'),
}

async function deleteHealthCheckTemplatesWithOptions(request: DeleteHealthCheckTemplatesRequest, runtime: Util.RuntimeOptions): DeleteHealthCheckTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.healthCheckTemplateIds)) {
    query['HealthCheckTemplateIds'] = request.healthCheckTemplateIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHealthCheckTemplates',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHealthCheckTemplates(request: DeleteHealthCheckTemplatesRequest): DeleteHealthCheckTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHealthCheckTemplatesWithOptions(request, runtime);
}

model DeleteListenerRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  listenerId?: string(name='ListenerId'),
}

model DeleteListenerResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model DeleteListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteListenerResponseBody(name='body'),
}

async function deleteListenerWithOptions(request: DeleteListenerRequest, runtime: Util.RuntimeOptions): DeleteListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteListener(request: DeleteListenerRequest): DeleteListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteListenerWithOptions(request, runtime);
}

model DeleteLoadBalancerRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model DeleteLoadBalancerResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model DeleteLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLoadBalancerResponseBody(name='body'),
}

async function deleteLoadBalancerWithOptions(request: DeleteLoadBalancerRequest, runtime: Util.RuntimeOptions): DeleteLoadBalancerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLoadBalancer',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLoadBalancer(request: DeleteLoadBalancerRequest): DeleteLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoadBalancerWithOptions(request, runtime);
}

model DeleteRuleRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ruleId?: string(name='RuleId'),
}

model DeleteRuleResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model DeleteRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRuleResponseBody(name='body'),
}

async function deleteRuleWithOptions(request: DeleteRuleRequest, runtime: Util.RuntimeOptions): DeleteRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRule',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRule(request: DeleteRuleRequest): DeleteRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRuleWithOptions(request, runtime);
}

model DeleteRulesRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  ruleIds?: [ string ](name='RuleIds'),
}

model DeleteRulesResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model DeleteRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRulesResponseBody(name='body'),
}

async function deleteRulesWithOptions(request: DeleteRulesRequest, runtime: Util.RuntimeOptions): DeleteRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.ruleIds)) {
    query['RuleIds'] = request.ruleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRules',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRules(request: DeleteRulesRequest): DeleteRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRulesWithOptions(request, runtime);
}

model DeleteSecurityPolicyRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  securityPolicyId?: string(name='SecurityPolicyId'),
}

model DeleteSecurityPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSecurityPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSecurityPolicyResponseBody(name='body'),
}

async function deleteSecurityPolicyWithOptions(request: DeleteSecurityPolicyRequest, runtime: Util.RuntimeOptions): DeleteSecurityPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    query['SecurityPolicyId'] = request.securityPolicyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecurityPolicy',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSecurityPolicy(request: DeleteSecurityPolicyRequest): DeleteSecurityPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecurityPolicyWithOptions(request, runtime);
}

model DeleteServerGroupRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  serverGroupId?: string(name='ServerGroupId'),
}

model DeleteServerGroupResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model DeleteServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServerGroupResponseBody(name='body'),
}

async function deleteServerGroupWithOptions(request: DeleteServerGroupRequest, runtime: Util.RuntimeOptions): DeleteServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServerGroup',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServerGroup(request: DeleteServerGroupRequest): DeleteServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServerGroupWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: [ 
    {
      localName?: string(name='LocalName'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Zones'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZonesWithOptions(runtime: Util.RuntimeOptions): DescribeZonesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeZones',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeZones(): DescribeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeZonesWithOptions(runtime);
}

model DetachCommonBandwidthPackageFromLoadBalancerRequest {
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  loadBalancerId?: string(name='LoadBalancerId'),
  regionId?: string(name='RegionId'),
}

model DetachCommonBandwidthPackageFromLoadBalancerResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model DetachCommonBandwidthPackageFromLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachCommonBandwidthPackageFromLoadBalancerResponseBody(name='body'),
}

async function detachCommonBandwidthPackageFromLoadBalancerWithOptions(request: DetachCommonBandwidthPackageFromLoadBalancerRequest, runtime: Util.RuntimeOptions): DetachCommonBandwidthPackageFromLoadBalancerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bandwidthPackageId)) {
    query['BandwidthPackageId'] = request.bandwidthPackageId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachCommonBandwidthPackageFromLoadBalancer',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachCommonBandwidthPackageFromLoadBalancer(request: DetachCommonBandwidthPackageFromLoadBalancerRequest): DetachCommonBandwidthPackageFromLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachCommonBandwidthPackageFromLoadBalancerWithOptions(request, runtime);
}

model DisableDeletionProtectionRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  resourceId?: string(name='ResourceId'),
}

model DisableDeletionProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableDeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableDeletionProtectionResponseBody(name='body'),
}

async function disableDeletionProtectionWithOptions(request: DisableDeletionProtectionRequest, runtime: Util.RuntimeOptions): DisableDeletionProtectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableDeletionProtection',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableDeletionProtection(request: DisableDeletionProtectionRequest): DisableDeletionProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableDeletionProtectionWithOptions(request, runtime);
}

model DisableLoadBalancerAccessLogRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model DisableLoadBalancerAccessLogResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableLoadBalancerAccessLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableLoadBalancerAccessLogResponseBody(name='body'),
}

async function disableLoadBalancerAccessLogWithOptions(request: DisableLoadBalancerAccessLogRequest, runtime: Util.RuntimeOptions): DisableLoadBalancerAccessLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableLoadBalancerAccessLog',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableLoadBalancerAccessLog(request: DisableLoadBalancerAccessLogRequest): DisableLoadBalancerAccessLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableLoadBalancerAccessLogWithOptions(request, runtime);
}

model DissociateAclsFromListenerRequest {
  aclIds?: [ string ](name='AclIds'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  listenerId?: string(name='ListenerId'),
}

model DissociateAclsFromListenerResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model DissociateAclsFromListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DissociateAclsFromListenerResponseBody(name='body'),
}

async function dissociateAclsFromListenerWithOptions(request: DissociateAclsFromListenerRequest, runtime: Util.RuntimeOptions): DissociateAclsFromListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclIds)) {
    query['AclIds'] = request.aclIds;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DissociateAclsFromListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dissociateAclsFromListener(request: DissociateAclsFromListenerRequest): DissociateAclsFromListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateAclsFromListenerWithOptions(request, runtime);
}

model DissociateAdditionalCertificatesFromListenerRequest {
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId'),
    }
  ](name='Certificates'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  listenerId?: string(name='ListenerId'),
}

model DissociateAdditionalCertificatesFromListenerResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model DissociateAdditionalCertificatesFromListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DissociateAdditionalCertificatesFromListenerResponseBody(name='body'),
}

async function dissociateAdditionalCertificatesFromListenerWithOptions(request: DissociateAdditionalCertificatesFromListenerRequest, runtime: Util.RuntimeOptions): DissociateAdditionalCertificatesFromListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificates)) {
    query['Certificates'] = request.certificates;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DissociateAdditionalCertificatesFromListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dissociateAdditionalCertificatesFromListener(request: DissociateAdditionalCertificatesFromListenerRequest): DissociateAdditionalCertificatesFromListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return dissociateAdditionalCertificatesFromListenerWithOptions(request, runtime);
}

model EnableDeletionProtectionRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  resourceId?: string(name='ResourceId'),
}

model EnableDeletionProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableDeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableDeletionProtectionResponseBody(name='body'),
}

async function enableDeletionProtectionWithOptions(request: EnableDeletionProtectionRequest, runtime: Util.RuntimeOptions): EnableDeletionProtectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableDeletionProtection',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableDeletionProtection(request: EnableDeletionProtectionRequest): EnableDeletionProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableDeletionProtectionWithOptions(request, runtime);
}

model EnableLoadBalancerAccessLogRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  loadBalancerId?: string(name='LoadBalancerId'),
  logProject?: string(name='LogProject'),
  logStore?: string(name='LogStore'),
}

model EnableLoadBalancerAccessLogResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableLoadBalancerAccessLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableLoadBalancerAccessLogResponseBody(name='body'),
}

async function enableLoadBalancerAccessLogWithOptions(request: EnableLoadBalancerAccessLogRequest, runtime: Util.RuntimeOptions): EnableLoadBalancerAccessLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.logProject)) {
    query['LogProject'] = request.logProject;
  }
  if (!Util.isUnset(request.logStore)) {
    query['LogStore'] = request.logStore;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableLoadBalancerAccessLog',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableLoadBalancerAccessLog(request: EnableLoadBalancerAccessLogRequest): EnableLoadBalancerAccessLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableLoadBalancerAccessLogWithOptions(request, runtime);
}

model GetHealthCheckTemplateAttributeRequest {
  healthCheckTemplateId?: string(name='HealthCheckTemplateId'),
}

model GetHealthCheckTemplateAttributeResponseBody = {
  healthCheckCodes?: [ string ](name='HealthCheckCodes'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckHost?: string(name='HealthCheckHost'),
  healthCheckHttpVersion?: string(name='HealthCheckHttpVersion'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckPath?: string(name='HealthCheckPath'),
  healthCheckProtocol?: string(name='HealthCheckProtocol'),
  healthCheckTemplateId?: string(name='HealthCheckTemplateId'),
  healthCheckTemplateName?: string(name='HealthCheckTemplateName'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  requestId?: string(name='RequestId'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
}

model GetHealthCheckTemplateAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetHealthCheckTemplateAttributeResponseBody(name='body'),
}

async function getHealthCheckTemplateAttributeWithOptions(request: GetHealthCheckTemplateAttributeRequest, runtime: Util.RuntimeOptions): GetHealthCheckTemplateAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.healthCheckTemplateId)) {
    query['HealthCheckTemplateId'] = request.healthCheckTemplateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHealthCheckTemplateAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHealthCheckTemplateAttribute(request: GetHealthCheckTemplateAttributeRequest): GetHealthCheckTemplateAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHealthCheckTemplateAttributeWithOptions(request, runtime);
}

model GetListenerAttributeRequest {
  listenerId?: string(name='ListenerId'),
}

model GetListenerAttributeResponseBody = {
  aclConfig?: {
    aclRelations?: [ 
      {
        aclId?: string(name='AclId'),
        status?: string(name='Status'),
      }
    ](name='AclRelations'),
    aclType?: string(name='AclType'),
  }(name='AclConfig'),
  caEnabled?: boolean(name='CaEnabled'),
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId'),
    }
  ](name='Certificates'),
  defaultActions?: [ 
    {
      forwardGroupConfig?: {
        serverGroupTuples?: [ 
          {
            serverGroupId?: string(name='ServerGroupId'),
          }
        ](name='ServerGroupTuples'),
      }(name='ForwardGroupConfig'),
      type?: string(name='Type'),
    }
  ](name='DefaultActions'),
  gzipEnabled?: boolean(name='GzipEnabled'),
  http2Enabled?: boolean(name='Http2Enabled'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerDescription?: string(name='ListenerDescription'),
  listenerId?: string(name='ListenerId'),
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  listenerStatus?: string(name='ListenerStatus'),
  loadBalancerId?: string(name='LoadBalancerId'),
  logConfig?: {
    accessLogRecordCustomizedHeadersEnabled?: boolean(name='AccessLogRecordCustomizedHeadersEnabled'),
    accessLogTracingConfig?: {
      tracingEnabled?: boolean(name='TracingEnabled'),
      tracingSample?: int32(name='TracingSample'),
      tracingType?: string(name='TracingType'),
    }(name='AccessLogTracingConfig'),
  }(name='LogConfig'),
  quicConfig?: {
    quicListenerId?: string(name='QuicListenerId'),
    quicUpgradeEnabled?: boolean(name='QuicUpgradeEnabled'),
  }(name='QuicConfig'),
  requestId?: string(name='RequestId'),
  requestTimeout?: int32(name='RequestTimeout'),
  securityPolicyId?: string(name='SecurityPolicyId'),
  XForwardedForConfig?: {
    XForwardedForClientCertClientVerifyAlias?: string(name='XForwardedForClientCertClientVerifyAlias'),
    XForwardedForClientCertClientVerifyEnabled?: boolean(name='XForwardedForClientCertClientVerifyEnabled'),
    XForwardedForClientCertFingerprintAlias?: string(name='XForwardedForClientCertFingerprintAlias'),
    XForwardedForClientCertFingerprintEnabled?: boolean(name='XForwardedForClientCertFingerprintEnabled'),
    XForwardedForClientCertIssuerDNAlias?: string(name='XForwardedForClientCertIssuerDNAlias'),
    XForwardedForClientCertIssuerDNEnabled?: boolean(name='XForwardedForClientCertIssuerDNEnabled'),
    XForwardedForClientCertSubjectDNAlias?: string(name='XForwardedForClientCertSubjectDNAlias'),
    XForwardedForClientCertSubjectDNEnabled?: boolean(name='XForwardedForClientCertSubjectDNEnabled'),
    XForwardedForClientSourceIpsEnabled?: boolean(name='XForwardedForClientSourceIpsEnabled'),
    XForwardedForClientSourceIpsTrusted?: string(name='XForwardedForClientSourceIpsTrusted'),
    XForwardedForClientSrcPortEnabled?: boolean(name='XForwardedForClientSrcPortEnabled'),
    XForwardedForEnabled?: boolean(name='XForwardedForEnabled'),
    XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled'),
    XForwardedForSLBIdEnabled?: boolean(name='XForwardedForSLBIdEnabled'),
    XForwardedForSLBPortEnabled?: boolean(name='XForwardedForSLBPortEnabled'),
  }(name='XForwardedForConfig'),
}

model GetListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetListenerAttributeResponseBody(name='body'),
}

async function getListenerAttributeWithOptions(request: GetListenerAttributeRequest, runtime: Util.RuntimeOptions): GetListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetListenerAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getListenerAttribute(request: GetListenerAttributeRequest): GetListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getListenerAttributeWithOptions(request, runtime);
}

model GetListenerHealthStatusRequest {
  includeRule?: boolean(name='IncludeRule'),
  listenerId?: string(name='ListenerId'),
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model GetListenerHealthStatusResponseBody = {
  listenerHealthStatus?: [ 
    {
      listenerId?: string(name='ListenerId'),
      listenerPort?: int32(name='ListenerPort'),
      listenerProtocol?: string(name='ListenerProtocol'),
      serverGroupInfos?: [ 
        {
          actionType?: string(name='ActionType'),
          healthCheckEnabled?: string(name='HealthCheckEnabled'),
          nonNormalServers?: [ 
            {
              port?: int32(name='Port'),
              reason?: {
                actualResponse?: string(name='ActualResponse'),
                expectedResponse?: string(name='ExpectedResponse'),
                reasonCode?: string(name='ReasonCode'),
              }(name='Reason'),
              serverId?: string(name='ServerId'),
              serverIp?: string(name='ServerIp'),
              status?: string(name='Status'),
            }
          ](name='NonNormalServers'),
          serverGroupId?: string(name='ServerGroupId'),
        }
      ](name='ServerGroupInfos'),
    }
  ](name='ListenerHealthStatus'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  ruleHealthStatus?: [ 
    {
      ruleId?: string(name='RuleId'),
      serverGroupInfos?: [ 
        {
          actionType?: string(name='ActionType'),
          healthCheckEnabled?: string(name='HealthCheckEnabled'),
          nonNormalServers?: [ 
            {
              port?: int32(name='Port'),
              reason?: {
                actualResponse?: string(name='ActualResponse'),
                expectedResponse?: string(name='ExpectedResponse'),
                reasonCode?: string(name='ReasonCode'),
              }(name='Reason'),
              serverId?: string(name='ServerId'),
              serverIp?: string(name='ServerIp'),
              status?: string(name='Status'),
            }
          ](name='NonNormalServers'),
          serverGroupId?: string(name='ServerGroupId'),
        }
      ](name='ServerGroupInfos'),
    }
  ](name='RuleHealthStatus'),
}

model GetListenerHealthStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetListenerHealthStatusResponseBody(name='body'),
}

async function getListenerHealthStatusWithOptions(request: GetListenerHealthStatusRequest, runtime: Util.RuntimeOptions): GetListenerHealthStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.includeRule)) {
    query['IncludeRule'] = request.includeRule;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetListenerHealthStatus',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getListenerHealthStatus(request: GetListenerHealthStatusRequest): GetListenerHealthStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getListenerHealthStatusWithOptions(request, runtime);
}

model GetLoadBalancerAttributeRequest {
  loadBalancerId?: string(name='LoadBalancerId'),
}

model GetLoadBalancerAttributeResponseBody = {
  accessLogConfig?: {
    logProject?: string(name='LogProject'),
    logStore?: string(name='LogStore'),
  }(name='AccessLogConfig'),
  addressAllocatedMode?: string(name='AddressAllocatedMode'),
  addressIpVersion?: string(name='AddressIpVersion'),
  addressType?: string(name='AddressType'),
  bandwidthPackageId?: string(name='BandwidthPackageId'),
  createTime?: string(name='CreateTime'),
  DNSName?: string(name='DNSName'),
  deletionProtectionConfig?: {
    enabled?: boolean(name='Enabled'),
    enabledTime?: string(name='EnabledTime'),
  }(name='DeletionProtectionConfig'),
  ipv6AddressType?: string(name='Ipv6AddressType'),
  loadBalancerBillingConfig?: {
    payType?: string(name='PayType'),
  }(name='LoadBalancerBillingConfig'),
  loadBalancerBussinessStatus?: string(name='LoadBalancerBussinessStatus'),
  loadBalancerEdition?: string(name='LoadBalancerEdition'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  loadBalancerOperationLocks?: [ 
    {
      lockReason?: string(name='LockReason'),
      lockType?: string(name='LockType'),
    }
  ](name='LoadBalancerOperationLocks'),
  loadBalancerStatus?: string(name='LoadBalancerStatus'),
  modificationProtectionConfig?: {
    reason?: string(name='Reason'),
    status?: string(name='Status'),
  }(name='ModificationProtectionConfig'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
  vpcId?: string(name='VpcId'),
  zoneMappings?: [ 
    {
      loadBalancerAddresses?: [ 
        {
          address?: string(name='Address'),
          ipv6Address?: string(name='Ipv6Address'),
        }
      ](name='LoadBalancerAddresses'),
      vSwitchId?: string(name='VSwitchId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='ZoneMappings'),
}

model GetLoadBalancerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLoadBalancerAttributeResponseBody(name='body'),
}

async function getLoadBalancerAttributeWithOptions(request: GetLoadBalancerAttributeRequest, runtime: Util.RuntimeOptions): GetLoadBalancerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLoadBalancerAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLoadBalancerAttribute(request: GetLoadBalancerAttributeRequest): GetLoadBalancerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLoadBalancerAttributeWithOptions(request, runtime);
}

model ListAclEntriesRequest {
  aclId?: string(name='AclId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListAclEntriesResponseBody = {
  aclEntries?: [ 
    {
      description?: string(name='Description'),
      entry?: string(name='Entry'),
      status?: string(name='Status'),
    }
  ](name='AclEntries'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAclEntriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAclEntriesResponseBody(name='body'),
}

async function listAclEntriesWithOptions(request: ListAclEntriesRequest, runtime: Util.RuntimeOptions): ListAclEntriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAclEntries',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAclEntries(request: ListAclEntriesRequest): ListAclEntriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAclEntriesWithOptions(request, runtime);
}

model ListAclRelationsRequest {
  aclIds?: [ string ](name='AclIds'),
}

model ListAclRelationsResponseBody = {
  aclRelations?: [ 
    {
      aclId?: string(name='AclId'),
      relatedListeners?: [ 
        {
          listenerId?: string(name='ListenerId'),
          listenerPort?: int32(name='ListenerPort'),
          listenerProtocol?: string(name='ListenerProtocol'),
          loadBalancerId?: string(name='LoadBalancerId'),
          status?: string(name='Status'),
        }
      ](name='RelatedListeners'),
    }
  ](name='AclRelations'),
  requestId?: string(name='RequestId'),
}

model ListAclRelationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAclRelationsResponseBody(name='body'),
}

async function listAclRelationsWithOptions(request: ListAclRelationsRequest, runtime: Util.RuntimeOptions): ListAclRelationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclIds)) {
    query['AclIds'] = request.aclIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAclRelations',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAclRelations(request: ListAclRelationsRequest): ListAclRelationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAclRelationsWithOptions(request, runtime);
}

model ListAclsRequest {
  aclIds?: [ string ](name='AclIds'),
  aclNames?: [ string ](name='AclNames'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListAclsResponseBody = {
  acls?: [ 
    {
      aclId?: string(name='AclId'),
      aclName?: string(name='AclName'),
      aclStatus?: string(name='AclStatus'),
      addressIPVersion?: string(name='AddressIPVersion'),
      configManagedEnabled?: boolean(name='ConfigManagedEnabled'),
      resourceGroupId?: string(name='ResourceGroupId'),
    }
  ](name='Acls'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAclsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAclsResponseBody(name='body'),
}

async function listAclsWithOptions(request: ListAclsRequest, runtime: Util.RuntimeOptions): ListAclsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclIds)) {
    query['AclIds'] = request.aclIds;
  }
  if (!Util.isUnset(request.aclNames)) {
    query['AclNames'] = request.aclNames;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAcls',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAcls(request: ListAclsRequest): ListAclsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAclsWithOptions(request, runtime);
}

model ListAsynJobsRequest {
  apiName?: string(name='ApiName'),
  beginTime?: long(name='BeginTime'),
  endTime?: long(name='EndTime'),
  jobIds?: [ string ](name='JobIds'),
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceIds?: [ string ](name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
}

model ListAsynJobsResponseBody = {
  jobs?: [ 
    {
      apiName?: string(name='ApiName'),
      createTime?: long(name='CreateTime'),
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      id?: string(name='Id'),
      modifyTime?: long(name='ModifyTime'),
      operateType?: string(name='OperateType'),
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      status?: string(name='Status'),
    }
  ](name='Jobs'),
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListAsynJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAsynJobsResponseBody(name='body'),
}

async function listAsynJobsWithOptions(request: ListAsynJobsRequest, runtime: Util.RuntimeOptions): ListAsynJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiName)) {
    query['ApiName'] = request.apiName;
  }
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.jobIds)) {
    query['JobIds'] = request.jobIds;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAsynJobs',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAsynJobs(request: ListAsynJobsRequest): ListAsynJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAsynJobsWithOptions(request, runtime);
}

model ListHealthCheckTemplatesRequest {
  healthCheckTemplateIds?: [ string ](name='HealthCheckTemplateIds'),
  healthCheckTemplateNames?: [ string ](name='HealthCheckTemplateNames'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListHealthCheckTemplatesResponseBody = {
  healthCheckTemplates?: [ 
    {
      healthCheckCodes?: [ string ](name='HealthCheckCodes'),
      healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
      healthCheckHost?: string(name='HealthCheckHost'),
      healthCheckHttpVersion?: string(name='HealthCheckHttpVersion'),
      healthCheckInterval?: int32(name='HealthCheckInterval'),
      healthCheckMethod?: string(name='HealthCheckMethod'),
      healthCheckPath?: string(name='HealthCheckPath'),
      healthCheckProtocol?: string(name='HealthCheckProtocol'),
      healthCheckTemplateId?: string(name='HealthCheckTemplateId'),
      healthCheckTemplateName?: string(name='HealthCheckTemplateName'),
      healthCheckTimeout?: int32(name='HealthCheckTimeout'),
      healthyThreshold?: int32(name='HealthyThreshold'),
      unhealthyThreshold?: int32(name='UnhealthyThreshold'),
    }
  ](name='HealthCheckTemplates'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListHealthCheckTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListHealthCheckTemplatesResponseBody(name='body'),
}

async function listHealthCheckTemplatesWithOptions(request: ListHealthCheckTemplatesRequest, runtime: Util.RuntimeOptions): ListHealthCheckTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.healthCheckTemplateIds)) {
    query['HealthCheckTemplateIds'] = request.healthCheckTemplateIds;
  }
  if (!Util.isUnset(request.healthCheckTemplateNames)) {
    query['HealthCheckTemplateNames'] = request.healthCheckTemplateNames;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHealthCheckTemplates',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHealthCheckTemplates(request: ListHealthCheckTemplatesRequest): ListHealthCheckTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHealthCheckTemplatesWithOptions(request, runtime);
}

model ListListenerCertificatesRequest {
  certificateType?: string(name='CertificateType'),
  listenerId?: string(name='ListenerId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListListenerCertificatesResponseBody = {
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId'),
      certificateType?: string(name='CertificateType'),
      isDefault?: boolean(name='IsDefault'),
      status?: string(name='Status'),
    }
  ](name='Certificates'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListListenerCertificatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListListenerCertificatesResponseBody(name='body'),
}

async function listListenerCertificatesWithOptions(request: ListListenerCertificatesRequest, runtime: Util.RuntimeOptions): ListListenerCertificatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificateType)) {
    query['CertificateType'] = request.certificateType;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListListenerCertificates',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listListenerCertificates(request: ListListenerCertificatesRequest): ListListenerCertificatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenerCertificatesWithOptions(request, runtime);
}

model ListListenersRequest {
  listenerIds?: [ string ](name='ListenerIds'),
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalancerIds?: [ string ](name='LoadBalancerIds'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListListenersResponseBody = {
  listeners?: [ 
    {
      defaultActions?: [ 
        {
          forwardGroupConfig?: {
            serverGroupTuples?: [ 
              {
                serverGroupId?: string(name='ServerGroupId'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
          type?: string(name='Type'),
        }
      ](name='DefaultActions'),
      gzipEnabled?: boolean(name='GzipEnabled'),
      http2Enabled?: boolean(name='Http2Enabled'),
      idleTimeout?: int32(name='IdleTimeout'),
      listenerDescription?: string(name='ListenerDescription'),
      listenerId?: string(name='ListenerId'),
      listenerPort?: int32(name='ListenerPort'),
      listenerProtocol?: string(name='ListenerProtocol'),
      listenerStatus?: string(name='ListenerStatus'),
      loadBalancerId?: string(name='LoadBalancerId'),
      logConfig?: {
        accessLogRecordCustomizedHeadersEnabled?: boolean(name='AccessLogRecordCustomizedHeadersEnabled'),
        accessLogTracingConfig?: {
          tracingEnabled?: boolean(name='TracingEnabled'),
          tracingSample?: int32(name='TracingSample'),
          tracingType?: string(name='TracingType'),
        }(name='AccessLogTracingConfig'),
      }(name='LogConfig'),
      quicConfig?: {
        quicListenerId?: string(name='QuicListenerId'),
        quicUpgradeEnabled?: boolean(name='QuicUpgradeEnabled'),
      }(name='QuicConfig'),
      requestTimeout?: int32(name='RequestTimeout'),
      securityPolicyId?: string(name='SecurityPolicyId'),
      XForwardedForConfig?: {
        XForwardedForClientCertClientVerifyAlias?: string(name='XForwardedForClientCertClientVerifyAlias'),
        XForwardedForClientCertClientVerifyEnabled?: boolean(name='XForwardedForClientCertClientVerifyEnabled'),
        XForwardedForClientCertFingerprintAlias?: string(name='XForwardedForClientCertFingerprintAlias'),
        XForwardedForClientCertFingerprintEnabled?: boolean(name='XForwardedForClientCertFingerprintEnabled'),
        XForwardedForClientCertIssuerDNAlias?: string(name='XForwardedForClientCertIssuerDNAlias'),
        XForwardedForClientCertIssuerDNEnabled?: boolean(name='XForwardedForClientCertIssuerDNEnabled'),
        XForwardedForClientCertSubjectDNAlias?: string(name='XForwardedForClientCertSubjectDNAlias'),
        XForwardedForClientCertSubjectDNEnabled?: boolean(name='XForwardedForClientCertSubjectDNEnabled'),
        XForwardedForClientSourceIpsEnabled?: boolean(name='XForwardedForClientSourceIpsEnabled'),
        XForwardedForClientSourceIpsTrusted?: string(name='XForwardedForClientSourceIpsTrusted'),
        XForwardedForClientSrcPortEnabled?: boolean(name='XForwardedForClientSrcPortEnabled'),
        XForwardedForEnabled?: boolean(name='XForwardedForEnabled'),
        XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled'),
        XForwardedForSLBIdEnabled?: boolean(name='XForwardedForSLBIdEnabled'),
        XForwardedForSLBPortEnabled?: boolean(name='XForwardedForSLBPortEnabled'),
      }(name='XForwardedForConfig'),
    }
  ](name='Listeners'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListListenersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListListenersResponseBody(name='body'),
}

async function listListenersWithOptions(request: ListListenersRequest, runtime: Util.RuntimeOptions): ListListenersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerIds)) {
    query['ListenerIds'] = request.listenerIds;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerIds)) {
    query['LoadBalancerIds'] = request.loadBalancerIds;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListListeners',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listListeners(request: ListListenersRequest): ListListenersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenersWithOptions(request, runtime);
}

model ListLoadBalancersRequest {
  addressType?: string(name='AddressType'),
  loadBalancerBussinessStatus?: string(name='LoadBalancerBussinessStatus'),
  loadBalancerIds?: [ string ](name='LoadBalancerIds'),
  loadBalancerNames?: [ string ](name='LoadBalancerNames'),
  loadBalancerStatus?: string(name='LoadBalancerStatus'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  payType?: string(name='PayType'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vpcIds?: [ string ](name='VpcIds'),
  zoneId?: string(name='ZoneId'),
}

model ListLoadBalancersResponseBody = {
  loadBalancers?: [ 
    {
      accessLogConfig?: {
        logProject?: string(name='LogProject'),
        logStore?: string(name='LogStore'),
      }(name='AccessLogConfig'),
      addressAllocatedMode?: string(name='AddressAllocatedMode'),
      addressIpVersion?: string(name='AddressIpVersion'),
      addressType?: string(name='AddressType'),
      bandwidthPackageId?: string(name='BandwidthPackageId'),
      createTime?: string(name='CreateTime'),
      DNSName?: string(name='DNSName'),
      deletionProtectionConfig?: {
        enabled?: boolean(name='Enabled'),
        enabledTime?: string(name='EnabledTime'),
      }(name='DeletionProtectionConfig'),
      ipv6AddressType?: string(name='Ipv6AddressType'),
      loadBalancerBillingConfig?: {
        payType?: string(name='PayType'),
      }(name='LoadBalancerBillingConfig'),
      loadBalancerBussinessStatus?: string(name='LoadBalancerBussinessStatus'),
      loadBalancerEdition?: string(name='LoadBalancerEdition'),
      loadBalancerId?: string(name='LoadBalancerId'),
      loadBalancerName?: string(name='LoadBalancerName'),
      loadBalancerOperationLocks?: [ 
        {
          lockReason?: string(name='LockReason'),
          lockType?: string(name='LockType'),
        }
      ](name='LoadBalancerOperationLocks'),
      loadBalancerStatus?: string(name='LoadBalancerStatus'),
      modificationProtectionConfig?: {
        reason?: string(name='Reason'),
        status?: string(name='Status'),
      }(name='ModificationProtectionConfig'),
      resourceGroupId?: string(name='ResourceGroupId'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      vpcId?: string(name='VpcId'),
    }
  ](name='LoadBalancers'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListLoadBalancersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLoadBalancersResponseBody(name='body'),
}

async function listLoadBalancersWithOptions(request: ListLoadBalancersRequest, runtime: Util.RuntimeOptions): ListLoadBalancersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addressType)) {
    query['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.loadBalancerBussinessStatus)) {
    query['LoadBalancerBussinessStatus'] = request.loadBalancerBussinessStatus;
  }
  if (!Util.isUnset(request.loadBalancerIds)) {
    query['LoadBalancerIds'] = request.loadBalancerIds;
  }
  if (!Util.isUnset(request.loadBalancerNames)) {
    query['LoadBalancerNames'] = request.loadBalancerNames;
  }
  if (!Util.isUnset(request.loadBalancerStatus)) {
    query['LoadBalancerStatus'] = request.loadBalancerStatus;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vpcIds)) {
    query['VpcIds'] = request.vpcIds;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLoadBalancers',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLoadBalancers(request: ListLoadBalancersRequest): ListLoadBalancersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLoadBalancersWithOptions(request, runtime);
}

model ListRulesRequest {
  listenerIds?: [ string ](name='ListenerIds'),
  loadBalancerIds?: [ string ](name='LoadBalancerIds'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ruleIds?: [ string ](name='RuleIds'),
}

model ListRulesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  rules?: [ 
    {
      listenerId?: string(name='ListenerId'),
      loadBalancerId?: string(name='LoadBalancerId'),
      priority?: int32(name='Priority'),
      ruleActions?: [ 
        {
          fixedResponseConfig?: {
            content?: string(name='Content'),
            contentType?: string(name='ContentType'),
            httpCode?: string(name='HttpCode'),
          }(name='FixedResponseConfig'),
          forwardGroupConfig?: {
            serverGroupTuples?: [ 
              {
                serverGroupId?: string(name='ServerGroupId'),
                weight?: int32(name='Weight'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
          insertHeaderConfig?: {
            key?: string(name='Key'),
            value?: string(name='Value'),
            valueType?: string(name='ValueType'),
          }(name='InsertHeaderConfig'),
          order?: int32(name='Order'),
          redirectConfig?: {
            host?: string(name='Host'),
            httpCode?: string(name='HttpCode'),
            path?: string(name='Path'),
            port?: string(name='Port'),
            protocol?: string(name='Protocol'),
            query?: string(name='Query'),
          }(name='RedirectConfig'),
          rewriteConfig?: {
            host?: string(name='Host'),
            path?: string(name='Path'),
            query?: string(name='Query'),
          }(name='RewriteConfig'),
          trafficLimitConfig?: {
            perIpQps?: int32(name='PerIpQps'),
            QPS?: int32(name='QPS'),
          }(name='TrafficLimitConfig'),
          trafficMirrorConfig?: {
            mirrorGroupConfig?: {
              serverGroupTuples?: [ 
                {
                  serverGroupId?: string(name='ServerGroupId'),
                  weight?: int32(name='Weight'),
                }
              ](name='ServerGroupTuples'),
            }(name='MirrorGroupConfig'),
          }(name='TrafficMirrorConfig'),
          type?: string(name='Type'),
        }
      ](name='RuleActions'),
      ruleConditions?: [ 
        {
          cookieConfig?: {
            values?: [ 
              {
                key?: string(name='Key'),
                value?: string(name='Value'),
              }
            ](name='Values'),
          }(name='CookieConfig'),
          headerConfig?: {
            key?: string(name='Key'),
            values?: [ string ](name='Values'),
          }(name='HeaderConfig'),
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
          methodConfig?: {
            values?: [ string ](name='Values'),
          }(name='MethodConfig'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          queryStringConfig?: {
            values?: [ 
              {
                key?: string(name='Key'),
                value?: string(name='Value'),
              }
            ](name='Values'),
          }(name='QueryStringConfig'),
          sourceIpConfig?: {
            values?: [ string ](name='Values'),
          }(name='SourceIpConfig'),
          type?: string(name='Type'),
        }
      ](name='RuleConditions'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      ruleStatus?: string(name='RuleStatus'),
    }
  ](name='Rules'),
  totalCount?: int32(name='TotalCount'),
}

model ListRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRulesResponseBody(name='body'),
}

async function listRulesWithOptions(request: ListRulesRequest, runtime: Util.RuntimeOptions): ListRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerIds)) {
    query['ListenerIds'] = request.listenerIds;
  }
  if (!Util.isUnset(request.loadBalancerIds)) {
    query['LoadBalancerIds'] = request.loadBalancerIds;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ruleIds)) {
    query['RuleIds'] = request.ruleIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRules',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRules(request: ListRulesRequest): ListRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRulesWithOptions(request, runtime);
}

model ListSecurityPoliciesRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceGroupId?: string(name='ResourceGroupId'),
  securityPolicyIds?: [ string ](name='SecurityPolicyIds'),
  securityPolicyNames?: [ string ](name='SecurityPolicyNames'),
}

model ListSecurityPoliciesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  securityPolicies?: [ 
    {
      ciphers?: [ string ](name='Ciphers'),
      resourceGroupId?: string(name='ResourceGroupId'),
      securityPolicyId?: string(name='SecurityPolicyId'),
      securityPolicyName?: string(name='SecurityPolicyName'),
      securityPolicyStatus?: string(name='SecurityPolicyStatus'),
      TLSVersions?: [ string ](name='TLSVersions'),
    }
  ](name='SecurityPolicies'),
  totalCount?: int32(name='TotalCount'),
}

model ListSecurityPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecurityPoliciesResponseBody(name='body'),
}

async function listSecurityPoliciesWithOptions(request: ListSecurityPoliciesRequest, runtime: Util.RuntimeOptions): ListSecurityPoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityPolicyIds)) {
    query['SecurityPolicyIds'] = request.securityPolicyIds;
  }
  if (!Util.isUnset(request.securityPolicyNames)) {
    query['SecurityPolicyNames'] = request.securityPolicyNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecurityPolicies',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSecurityPolicies(request: ListSecurityPoliciesRequest): ListSecurityPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecurityPoliciesWithOptions(request, runtime);
}

model ListSecurityPolicyRelationsRequest {
  securityPolicyIds?: [ string ](name='SecurityPolicyIds'),
}

model ListSecurityPolicyRelationsResponseBody = {
  requestId?: string(name='RequestId'),
  secrityPolicyRelations?: [ 
    {
      relatedListeners?: [ 
        {
          listenerId?: string(name='ListenerId'),
          listenerPort?: long(name='ListenerPort'),
          listenerProtocol?: string(name='ListenerProtocol'),
          loadBalancerId?: string(name='LoadBalancerId'),
        }
      ](name='RelatedListeners'),
      securityPolicyId?: string(name='SecurityPolicyId'),
    }
  ](name='SecrityPolicyRelations'),
}

model ListSecurityPolicyRelationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecurityPolicyRelationsResponseBody(name='body'),
}

async function listSecurityPolicyRelationsWithOptions(request: ListSecurityPolicyRelationsRequest, runtime: Util.RuntimeOptions): ListSecurityPolicyRelationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.securityPolicyIds)) {
    query['SecurityPolicyIds'] = request.securityPolicyIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecurityPolicyRelations',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSecurityPolicyRelations(request: ListSecurityPolicyRelationsRequest): ListSecurityPolicyRelationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSecurityPolicyRelationsWithOptions(request, runtime);
}

model ListServerGroupServersRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  serverGroupId?: string(name='ServerGroupId'),
  serverIds?: [ string ](name='ServerIds'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListServerGroupServersResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  servers?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverGroupId?: string(name='ServerGroupId'),
      serverId?: string(name='ServerId'),
      serverIp?: string(name='ServerIp'),
      serverType?: string(name='ServerType'),
      status?: string(name='Status'),
      weight?: int32(name='Weight'),
    }
  ](name='Servers'),
  totalCount?: int32(name='TotalCount'),
}

model ListServerGroupServersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServerGroupServersResponseBody(name='body'),
}

async function listServerGroupServersWithOptions(request: ListServerGroupServersRequest, runtime: Util.RuntimeOptions): ListServerGroupServersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.serverIds)) {
    query['ServerIds'] = request.serverIds;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServerGroupServers',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServerGroupServers(request: ListServerGroupServersRequest): ListServerGroupServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServerGroupServersWithOptions(request, runtime);
}

model ListServerGroupsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceGroupId?: string(name='ResourceGroupId'),
  serverGroupIds?: [ string ](name='ServerGroupIds'),
  serverGroupNames?: [ string ](name='ServerGroupNames'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vpcId?: string(name='VpcId'),
}

model ListServerGroupsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  serverGroups?: [ 
    {
      configManagedEnabled?: boolean(name='ConfigManagedEnabled'),
      healthCheckConfig?: {
        healthCheckCodes?: [ string ](name='HealthCheckCodes'),
        healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
        healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
        healthCheckHost?: string(name='HealthCheckHost'),
        healthCheckHttpVersion?: string(name='HealthCheckHttpVersion'),
        healthCheckInterval?: int32(name='HealthCheckInterval'),
        healthCheckMethod?: string(name='HealthCheckMethod'),
        healthCheckPath?: string(name='HealthCheckPath'),
        healthCheckProtocol?: string(name='HealthCheckProtocol'),
        healthCheckTimeout?: int32(name='HealthCheckTimeout'),
        healthyThreshold?: int32(name='HealthyThreshold'),
        unhealthyThreshold?: int32(name='UnhealthyThreshold'),
      }(name='HealthCheckConfig'),
      ipv6Enabled?: boolean(name='Ipv6Enabled'),
      protocol?: string(name='Protocol'),
      resourceGroupId?: string(name='ResourceGroupId'),
      scheduler?: string(name='Scheduler'),
      serverCount?: int32(name='ServerCount'),
      serverGroupId?: string(name='ServerGroupId'),
      serverGroupName?: string(name='ServerGroupName'),
      serverGroupStatus?: string(name='ServerGroupStatus'),
      serverGroupType?: string(name='ServerGroupType'),
      serviceName?: string(name='ServiceName'),
      stickySessionConfig?: {
        cookie?: string(name='Cookie'),
        cookieTimeout?: int32(name='CookieTimeout'),
        stickySessionEnabled?: boolean(name='StickySessionEnabled'),
        stickySessionType?: string(name='StickySessionType'),
      }(name='StickySessionConfig'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      upstreamKeepaliveEnabled?: boolean(name='UpstreamKeepaliveEnabled'),
      vpcId?: string(name='VpcId'),
    }
  ](name='ServerGroups'),
  totalCount?: int32(name='TotalCount'),
}

model ListServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServerGroupsResponseBody(name='body'),
}

async function listServerGroupsWithOptions(request: ListServerGroupsRequest, runtime: Util.RuntimeOptions): ListServerGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.serverGroupIds)) {
    query['ServerGroupIds'] = request.serverGroupIds;
  }
  if (!Util.isUnset(request.serverGroupNames)) {
    query['ServerGroupNames'] = request.serverGroupNames;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServerGroups',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServerGroups(request: ListServerGroupsRequest): ListServerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServerGroupsWithOptions(request, runtime);
}

model ListSystemSecurityPoliciesResponseBody = {
  requestId?: string(name='RequestId'),
  securityPolicies?: [ 
    {
      ciphers?: [ string ](name='Ciphers'),
      securityPolicyId?: string(name='SecurityPolicyId'),
      TLSVersions?: [ string ](name='TLSVersions'),
    }
  ](name='SecurityPolicies'),
}

model ListSystemSecurityPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSystemSecurityPoliciesResponseBody(name='body'),
}

async function listSystemSecurityPoliciesWithOptions(runtime: Util.RuntimeOptions): ListSystemSecurityPoliciesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListSystemSecurityPolicies',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSystemSecurityPolicies(): ListSystemSecurityPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSystemSecurityPoliciesWithOptions(runtime);
}

model ListTagKeysRequest {
  category?: string(name='Category'),
  keyword?: string(name='Keyword'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceType?: string(name='ResourceType'),
}

model ListTagKeysResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagKeys?: [ 
    {
      category?: string(name='Category'),
      tagKey?: string(name='TagKey'),
    }
  ](name='TagKeys'),
  totalCount?: int32(name='TotalCount'),
}

model ListTagKeysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagKeysResponseBody(name='body'),
}

async function listTagKeysWithOptions(request: ListTagKeysRequest, runtime: Util.RuntimeOptions): ListTagKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagKeys',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagKeys(request: ListTagKeysRequest): ListTagKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagKeysWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListTagValuesRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: string(name='TagKey'),
}

model ListTagValuesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagValues?: [ string ](name='TagValues'),
  totalCount?: int32(name='TotalCount'),
}

model ListTagValuesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagValuesResponseBody(name='body'),
}

async function listTagValuesWithOptions(request: ListTagValuesRequest, runtime: Util.RuntimeOptions): ListTagValuesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagValues',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagValues(request: ListTagValuesRequest): ListTagValuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagValuesWithOptions(request, runtime);
}

model MoveResourceGroupRequest {
  newResourceGroupId?: string(name='NewResourceGroupId'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroupWithOptions(request: MoveResourceGroupRequest, runtime: Util.RuntimeOptions): MoveResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MoveResourceGroup',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveResourceGroupWithOptions(request, runtime);
}

model RemoveEntriesFromAclRequest {
  aclId?: string(name='AclId'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  entries?: [ string ](name='Entries'),
}

model RemoveEntriesFromAclResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model RemoveEntriesFromAclResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveEntriesFromAclResponseBody(name='body'),
}

async function removeEntriesFromAclWithOptions(request: RemoveEntriesFromAclRequest, runtime: Util.RuntimeOptions): RemoveEntriesFromAclResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.entries)) {
    query['Entries'] = request.entries;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveEntriesFromAcl',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeEntriesFromAcl(request: RemoveEntriesFromAclRequest): RemoveEntriesFromAclResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeEntriesFromAclWithOptions(request, runtime);
}

model RemoveServersFromServerGroupRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  serverGroupId?: string(name='ServerGroupId'),
  servers?: [ 
    {
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      serverIp?: string(name='ServerIp'),
      serverType?: string(name='ServerType'),
    }
  ](name='Servers'),
}

model RemoveServersFromServerGroupResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model RemoveServersFromServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveServersFromServerGroupResponseBody(name='body'),
}

async function removeServersFromServerGroupWithOptions(request: RemoveServersFromServerGroupRequest, runtime: Util.RuntimeOptions): RemoveServersFromServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.servers)) {
    query['Servers'] = request.servers;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveServersFromServerGroup',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeServersFromServerGroup(request: RemoveServersFromServerGroupRequest): RemoveServersFromServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeServersFromServerGroupWithOptions(request, runtime);
}

model ReplaceServersInServerGroupRequest {
  addedServers?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      serverIp?: string(name='ServerIp'),
      serverType?: string(name='ServerType'),
      weight?: int32(name='Weight'),
    }
  ](name='AddedServers'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  removedServers?: [ 
    {
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      serverIp?: string(name='ServerIp'),
      serverType?: string(name='ServerType'),
    }
  ](name='RemovedServers'),
  serverGroupId?: string(name='ServerGroupId'),
}

model ReplaceServersInServerGroupResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model ReplaceServersInServerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReplaceServersInServerGroupResponseBody(name='body'),
}

async function replaceServersInServerGroupWithOptions(request: ReplaceServersInServerGroupRequest, runtime: Util.RuntimeOptions): ReplaceServersInServerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addedServers)) {
    query['AddedServers'] = request.addedServers;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.removedServers)) {
    query['RemovedServers'] = request.removedServers;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReplaceServersInServerGroup',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function replaceServersInServerGroup(request: ReplaceServersInServerGroupRequest): ReplaceServersInServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceServersInServerGroupWithOptions(request, runtime);
}

model StartListenerRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  listenerId?: string(name='ListenerId'),
}

model StartListenerResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model StartListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartListenerResponseBody(name='body'),
}

async function startListenerWithOptions(request: StartListenerRequest, runtime: Util.RuntimeOptions): StartListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startListener(request: StartListenerRequest): StartListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return startListenerWithOptions(request, runtime);
}

model StopListenerRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  listenerId?: string(name='ListenerId'),
}

model StopListenerResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model StopListenerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopListenerResponseBody(name='body'),
}

async function stopListenerWithOptions(request: StopListenerRequest, runtime: Util.RuntimeOptions): StopListenerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopListener',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopListener(request: StopListenerRequest): StopListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopListenerWithOptions(request, runtime);
}

model TagResourcesRequest {
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UnTagResourcesRequest {
  all?: boolean(name='All'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  tagKey?: [ string ](name='TagKey'),
}

model UnTagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnTagResourcesResponseBody(name='body'),
}

async function unTagResourcesWithOptions(request: UnTagResourcesRequest, runtime: Util.RuntimeOptions): UnTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnTagResources',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unTagResources(request: UnTagResourcesRequest): UnTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return unTagResourcesWithOptions(request, runtime);
}

model UpdateAclAttributeRequest {
  aclId?: string(name='AclId'),
  aclName?: string(name='AclName'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
}

model UpdateAclAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAclAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAclAttributeResponseBody(name='body'),
}

async function updateAclAttributeWithOptions(request: UpdateAclAttributeRequest, runtime: Util.RuntimeOptions): UpdateAclAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aclId)) {
    query['AclId'] = request.aclId;
  }
  if (!Util.isUnset(request.aclName)) {
    query['AclName'] = request.aclName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAclAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAclAttribute(request: UpdateAclAttributeRequest): UpdateAclAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAclAttributeWithOptions(request, runtime);
}

model UpdateHealthCheckTemplateAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  healthCheckCodes?: [ string ](name='HealthCheckCodes'),
  healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
  healthCheckHost?: string(name='HealthCheckHost'),
  healthCheckHttpVersion?: string(name='HealthCheckHttpVersion'),
  healthCheckInterval?: int32(name='HealthCheckInterval'),
  healthCheckMethod?: string(name='HealthCheckMethod'),
  healthCheckPath?: string(name='HealthCheckPath'),
  healthCheckProtocol?: string(name='HealthCheckProtocol'),
  healthCheckTemplateId?: string(name='HealthCheckTemplateId'),
  healthCheckTemplateName?: string(name='HealthCheckTemplateName'),
  healthCheckTimeout?: int32(name='HealthCheckTimeout'),
  healthyThreshold?: int32(name='HealthyThreshold'),
  unhealthyThreshold?: int32(name='UnhealthyThreshold'),
}

model UpdateHealthCheckTemplateAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateHealthCheckTemplateAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHealthCheckTemplateAttributeResponseBody(name='body'),
}

async function updateHealthCheckTemplateAttributeWithOptions(request: UpdateHealthCheckTemplateAttributeRequest, runtime: Util.RuntimeOptions): UpdateHealthCheckTemplateAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.healthCheckCodes)) {
    query['HealthCheckCodes'] = request.healthCheckCodes;
  }
  if (!Util.isUnset(request.healthCheckConnectPort)) {
    query['HealthCheckConnectPort'] = request.healthCheckConnectPort;
  }
  if (!Util.isUnset(request.healthCheckHost)) {
    query['HealthCheckHost'] = request.healthCheckHost;
  }
  if (!Util.isUnset(request.healthCheckHttpVersion)) {
    query['HealthCheckHttpVersion'] = request.healthCheckHttpVersion;
  }
  if (!Util.isUnset(request.healthCheckInterval)) {
    query['HealthCheckInterval'] = request.healthCheckInterval;
  }
  if (!Util.isUnset(request.healthCheckMethod)) {
    query['HealthCheckMethod'] = request.healthCheckMethod;
  }
  if (!Util.isUnset(request.healthCheckPath)) {
    query['HealthCheckPath'] = request.healthCheckPath;
  }
  if (!Util.isUnset(request.healthCheckProtocol)) {
    query['HealthCheckProtocol'] = request.healthCheckProtocol;
  }
  if (!Util.isUnset(request.healthCheckTemplateId)) {
    query['HealthCheckTemplateId'] = request.healthCheckTemplateId;
  }
  if (!Util.isUnset(request.healthCheckTemplateName)) {
    query['HealthCheckTemplateName'] = request.healthCheckTemplateName;
  }
  if (!Util.isUnset(request.healthCheckTimeout)) {
    query['HealthCheckTimeout'] = request.healthCheckTimeout;
  }
  if (!Util.isUnset(request.healthyThreshold)) {
    query['HealthyThreshold'] = request.healthyThreshold;
  }
  if (!Util.isUnset(request.unhealthyThreshold)) {
    query['UnhealthyThreshold'] = request.unhealthyThreshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHealthCheckTemplateAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateHealthCheckTemplateAttribute(request: UpdateHealthCheckTemplateAttributeRequest): UpdateHealthCheckTemplateAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHealthCheckTemplateAttributeWithOptions(request, runtime);
}

model UpdateListenerAttributeRequest {
  caCertificates?: [ 
    {
    }
  ](name='CaCertificates'),
  caEnabled?: boolean(name='CaEnabled'),
  certificates?: [ 
    {
      certificateId?: string(name='CertificateId'),
    }
  ](name='Certificates'),
  clientToken?: string(name='ClientToken'),
  defaultActions?: [ 
    {
      forwardGroupConfig?: {
        serverGroupTuples?: [ 
          {
            serverGroupId?: string(name='ServerGroupId'),
          }
        ](name='ServerGroupTuples'),
      }(name='ForwardGroupConfig'),
      type?: string(name='Type'),
    }
  ](name='DefaultActions'),
  dryRun?: boolean(name='DryRun'),
  gzipEnabled?: boolean(name='GzipEnabled'),
  http2Enabled?: boolean(name='Http2Enabled'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerDescription?: string(name='ListenerDescription'),
  listenerId?: string(name='ListenerId'),
  quicConfig?: {
    quicListenerId?: string(name='QuicListenerId'),
    quicUpgradeEnabled?: boolean(name='QuicUpgradeEnabled'),
  }(name='QuicConfig'),
  requestTimeout?: int32(name='RequestTimeout'),
  securityPolicyId?: string(name='SecurityPolicyId'),
  XForwardedForConfig?: {
    XForwardedForClientCertClientVerifyAlias?: string(name='XForwardedForClientCertClientVerifyAlias'),
    XForwardedForClientCertClientVerifyEnabled?: boolean(name='XForwardedForClientCertClientVerifyEnabled'),
    XForwardedForClientCertFingerprintAlias?: string(name='XForwardedForClientCertFingerprintAlias'),
    XForwardedForClientCertFingerprintEnabled?: boolean(name='XForwardedForClientCertFingerprintEnabled'),
    XForwardedForClientCertIssuerDNAlias?: string(name='XForwardedForClientCertIssuerDNAlias'),
    XForwardedForClientCertIssuerDNEnabled?: boolean(name='XForwardedForClientCertIssuerDNEnabled'),
    XForwardedForClientCertSubjectDNAlias?: string(name='XForwardedForClientCertSubjectDNAlias'),
    XForwardedForClientCertSubjectDNEnabled?: boolean(name='XForwardedForClientCertSubjectDNEnabled'),
    XForwardedForClientSourceIpsEnabled?: boolean(name='XForwardedForClientSourceIpsEnabled'),
    XForwardedForClientSourceIpsTrusted?: string(name='XForwardedForClientSourceIpsTrusted'),
    XForwardedForClientSrcPortEnabled?: boolean(name='XForwardedForClientSrcPortEnabled'),
    XForwardedForEnabled?: boolean(name='XForwardedForEnabled'),
    XForwardedForProtoEnabled?: boolean(name='XForwardedForProtoEnabled'),
    XForwardedForSLBIdEnabled?: boolean(name='XForwardedForSLBIdEnabled'),
    XForwardedForSLBPortEnabled?: boolean(name='XForwardedForSLBPortEnabled'),
  }(name='XForwardedForConfig'),
}

model UpdateListenerAttributeResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model UpdateListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateListenerAttributeResponseBody(name='body'),
}

async function updateListenerAttributeWithOptions(request: UpdateListenerAttributeRequest, runtime: Util.RuntimeOptions): UpdateListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caCertificates)) {
    query['CaCertificates'] = request.caCertificates;
  }
  if (!Util.isUnset(request.caEnabled)) {
    query['CaEnabled'] = request.caEnabled;
  }
  if (!Util.isUnset(request.certificates)) {
    query['Certificates'] = request.certificates;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.defaultActions)) {
    query['DefaultActions'] = request.defaultActions;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.gzipEnabled)) {
    query['GzipEnabled'] = request.gzipEnabled;
  }
  if (!Util.isUnset(request.http2Enabled)) {
    query['Http2Enabled'] = request.http2Enabled;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    query['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerDescription)) {
    query['ListenerDescription'] = request.listenerDescription;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.quicConfig)) {
    query['QuicConfig'] = request.quicConfig;
  }
  if (!Util.isUnset(request.requestTimeout)) {
    query['RequestTimeout'] = request.requestTimeout;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    query['SecurityPolicyId'] = request.securityPolicyId;
  }
  if (!Util.isUnset(request.XForwardedForConfig)) {
    query['XForwardedForConfig'] = request.XForwardedForConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateListenerAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateListenerAttribute(request: UpdateListenerAttributeRequest): UpdateListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateListenerAttributeWithOptions(request, runtime);
}

model UpdateListenerLogConfigRequest {
  accessLogRecordCustomizedHeadersEnabled?: boolean(name='AccessLogRecordCustomizedHeadersEnabled'),
  accessLogTracingConfig?: {
    tracingEnabled?: boolean(name='TracingEnabled'),
    tracingSample?: int32(name='TracingSample'),
    tracingType?: string(name='TracingType'),
  }(name='AccessLogTracingConfig'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  listenerId?: string(name='ListenerId'),
}

model UpdateListenerLogConfigResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model UpdateListenerLogConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateListenerLogConfigResponseBody(name='body'),
}

async function updateListenerLogConfigWithOptions(request: UpdateListenerLogConfigRequest, runtime: Util.RuntimeOptions): UpdateListenerLogConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessLogRecordCustomizedHeadersEnabled)) {
    query['AccessLogRecordCustomizedHeadersEnabled'] = request.accessLogRecordCustomizedHeadersEnabled;
  }
  if (!Util.isUnset(request.accessLogTracingConfig)) {
    query['AccessLogTracingConfig'] = request.accessLogTracingConfig;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateListenerLogConfig',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateListenerLogConfig(request: UpdateListenerLogConfigRequest): UpdateListenerLogConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateListenerLogConfigWithOptions(request, runtime);
}

model UpdateLoadBalancerAddressTypeConfigRequest {
  addressType?: string(name='AddressType'),
  clientToken?: string(name='ClientToken'),
  dryRun?: string(name='DryRun'),
  loadBalancerId?: string(name='LoadBalancerId'),
  zoneMappings?: [ 
    {
      allocationId?: string(name='AllocationId'),
      vSwitchId?: string(name='VSwitchId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='ZoneMappings'),
}

model UpdateLoadBalancerAddressTypeConfigResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model UpdateLoadBalancerAddressTypeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLoadBalancerAddressTypeConfigResponseBody(name='body'),
}

async function updateLoadBalancerAddressTypeConfigWithOptions(request: UpdateLoadBalancerAddressTypeConfigRequest, runtime: Util.RuntimeOptions): UpdateLoadBalancerAddressTypeConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addressType)) {
    query['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.zoneMappings)) {
    query['ZoneMappings'] = request.zoneMappings;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoadBalancerAddressTypeConfig',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLoadBalancerAddressTypeConfig(request: UpdateLoadBalancerAddressTypeConfigRequest): UpdateLoadBalancerAddressTypeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoadBalancerAddressTypeConfigWithOptions(request, runtime);
}

model UpdateLoadBalancerAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  modificationProtectionConfig?: {
    reason?: string(name='Reason'),
    status?: string(name='Status'),
  }(name='ModificationProtectionConfig'),
}

model UpdateLoadBalancerAttributeResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model UpdateLoadBalancerAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLoadBalancerAttributeResponseBody(name='body'),
}

async function updateLoadBalancerAttributeWithOptions(request: UpdateLoadBalancerAttributeRequest, runtime: Util.RuntimeOptions): UpdateLoadBalancerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.loadBalancerName)) {
    query['LoadBalancerName'] = request.loadBalancerName;
  }
  if (!Util.isUnset(request.modificationProtectionConfig)) {
    query['ModificationProtectionConfig'] = request.modificationProtectionConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoadBalancerAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLoadBalancerAttribute(request: UpdateLoadBalancerAttributeRequest): UpdateLoadBalancerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoadBalancerAttributeWithOptions(request, runtime);
}

model UpdateLoadBalancerEditionRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  loadBalancerEdition?: string(name='LoadBalancerEdition'),
  loadBalancerId?: string(name='LoadBalancerId'),
}

model UpdateLoadBalancerEditionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateLoadBalancerEditionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLoadBalancerEditionResponseBody(name='body'),
}

async function updateLoadBalancerEditionWithOptions(request: UpdateLoadBalancerEditionRequest, runtime: Util.RuntimeOptions): UpdateLoadBalancerEditionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerEdition)) {
    query['LoadBalancerEdition'] = request.loadBalancerEdition;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoadBalancerEdition',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLoadBalancerEdition(request: UpdateLoadBalancerEditionRequest): UpdateLoadBalancerEditionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoadBalancerEditionWithOptions(request, runtime);
}

model UpdateLoadBalancerZonesRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  loadBalancerId?: string(name='LoadBalancerId'),
  zoneMappings?: [ 
    {
      vSwitchId?: string(name='VSwitchId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='ZoneMappings'),
}

model UpdateLoadBalancerZonesResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model UpdateLoadBalancerZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLoadBalancerZonesResponseBody(name='body'),
}

async function updateLoadBalancerZonesWithOptions(request: UpdateLoadBalancerZonesRequest, runtime: Util.RuntimeOptions): UpdateLoadBalancerZonesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.zoneMappings)) {
    query['ZoneMappings'] = request.zoneMappings;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoadBalancerZones',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLoadBalancerZones(request: UpdateLoadBalancerZonesRequest): UpdateLoadBalancerZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoadBalancerZonesWithOptions(request, runtime);
}

model UpdateRuleAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  priority?: int32(name='Priority'),
  ruleActions?: [ 
    {
      fixedResponseConfig?: {
        content?: string(name='Content'),
        contentType?: string(name='ContentType'),
        httpCode?: string(name='HttpCode'),
      }(name='FixedResponseConfig'),
      forwardGroupConfig?: {
        serverGroupStickySession?: {
          enabled?: boolean(name='Enabled'),
          timeout?: int32(name='Timeout'),
        }(name='ServerGroupStickySession'),
        serverGroupTuples?: [ 
          {
            serverGroupId?: string(name='ServerGroupId'),
            weight?: int32(name='Weight'),
          }
        ](name='ServerGroupTuples'),
      }(name='ForwardGroupConfig'),
      insertHeaderConfig?: {
        key?: string(name='Key'),
        value?: string(name='Value'),
        valueType?: string(name='ValueType'),
      }(name='InsertHeaderConfig'),
      order?: int32(name='Order'),
      redirectConfig?: {
        host?: string(name='Host'),
        httpCode?: string(name='HttpCode'),
        path?: string(name='Path'),
        port?: string(name='Port'),
        protocol?: string(name='Protocol'),
        query?: string(name='Query'),
      }(name='RedirectConfig'),
      rewriteConfig?: {
        host?: string(name='Host'),
        path?: string(name='Path'),
        query?: string(name='Query'),
      }(name='RewriteConfig'),
      trafficLimitConfig?: {
        perIpQps?: int32(name='PerIpQps'),
        QPS?: int32(name='QPS'),
      }(name='TrafficLimitConfig'),
      trafficMirrorConfig?: {
        mirrorGroupConfig?: {
          serverGroupTuples?: [ 
            {
              serverGroupId?: string(name='ServerGroupId'),
            }
          ](name='ServerGroupTuples'),
        }(name='MirrorGroupConfig'),
        targetType?: string(name='TargetType'),
      }(name='TrafficMirrorConfig'),
      type?: string(name='Type'),
    }
  ](name='RuleActions'),
  ruleConditions?: [ 
    {
      cookieConfig?: {
        values?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Values'),
      }(name='CookieConfig'),
      headerConfig?: {
        key?: string(name='Key'),
        values?: [ string ](name='Values'),
      }(name='HeaderConfig'),
      hostConfig?: {
        values?: [ string ](name='Values'),
      }(name='HostConfig'),
      methodConfig?: {
        values?: [ string ](name='Values'),
      }(name='MethodConfig'),
      pathConfig?: {
        values?: [ string ](name='Values'),
      }(name='PathConfig'),
      queryStringConfig?: {
        values?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Values'),
      }(name='QueryStringConfig'),
      sourceIpConfig?: {
        values?: [ string ](name='Values'),
      }(name='SourceIpConfig'),
      type?: string(name='Type'),
    }
  ](name='RuleConditions'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
}

model UpdateRuleAttributeResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model UpdateRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRuleAttributeResponseBody(name='body'),
}

async function updateRuleAttributeWithOptions(request: UpdateRuleAttributeRequest, runtime: Util.RuntimeOptions): UpdateRuleAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!Util.isUnset(request.ruleActions)) {
    query['RuleActions'] = request.ruleActions;
  }
  if (!Util.isUnset(request.ruleConditions)) {
    query['RuleConditions'] = request.ruleConditions;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRuleAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRuleAttribute(request: UpdateRuleAttributeRequest): UpdateRuleAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRuleAttributeWithOptions(request, runtime);
}

model UpdateRulesAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  rules?: [ 
    {
      priority?: int32(name='Priority'),
      ruleActions?: [ 
        {
          fixedResponseConfig?: {
            content?: string(name='Content'),
            contentType?: string(name='ContentType'),
            httpCode?: string(name='HttpCode'),
          }(name='FixedResponseConfig'),
          forwardGroupConfig?: {
            serverGroupStickySession?: {
              enabled?: boolean(name='Enabled'),
              timeout?: int32(name='Timeout'),
            }(name='ServerGroupStickySession'),
            serverGroupTuples?: [ 
              {
                serverGroupId?: string(name='ServerGroupId'),
                weight?: int32(name='Weight'),
              }
            ](name='ServerGroupTuples'),
          }(name='ForwardGroupConfig'),
          insertHeaderConfig?: {
            coverEnabled?: boolean(name='CoverEnabled'),
            key?: string(name='Key'),
            value?: string(name='Value'),
            valueType?: string(name='ValueType'),
          }(name='InsertHeaderConfig'),
          order?: int32(name='Order'),
          redirectConfig?: {
            host?: string(name='Host'),
            httpCode?: string(name='HttpCode'),
            path?: string(name='Path'),
            port?: string(name='Port'),
            protocol?: string(name='Protocol'),
            query?: string(name='Query'),
          }(name='RedirectConfig'),
          removeHeaderConfig?: {
            key?: string(name='Key'),
          }(name='RemoveHeaderConfig'),
          rewriteConfig?: {
            host?: string(name='Host'),
            path?: string(name='Path'),
            query?: string(name='Query'),
          }(name='RewriteConfig'),
          trafficLimitConfig?: {
            perIpQps?: int32(name='PerIpQps'),
            QPS?: int32(name='QPS'),
          }(name='TrafficLimitConfig'),
          trafficMirrorConfig?: {
            mirrorGroupConfig?: {
              serverGroupTuples?: [ 
                {
                  serverGroupId?: string(name='ServerGroupId'),
                }
              ](name='ServerGroupTuples'),
            }(name='MirrorGroupConfig'),
            targetType?: string(name='TargetType'),
          }(name='TrafficMirrorConfig'),
          type?: string(name='Type'),
        }
      ](name='RuleActions'),
      ruleConditions?: [ 
        {
          cookieConfig?: {
            values?: [ 
              {
                key?: string(name='Key'),
                value?: string(name='Value'),
              }
            ](name='Values'),
          }(name='CookieConfig'),
          headerConfig?: {
            key?: string(name='Key'),
            values?: [ string ](name='Values'),
          }(name='HeaderConfig'),
          hostConfig?: {
            values?: [ string ](name='Values'),
          }(name='HostConfig'),
          methodConfig?: {
            values?: [ string ](name='Values'),
          }(name='MethodConfig'),
          pathConfig?: {
            values?: [ string ](name='Values'),
          }(name='PathConfig'),
          queryStringConfig?: {
            values?: [ 
              {
                key?: string(name='Key'),
                value?: string(name='Value'),
              }
            ](name='Values'),
          }(name='QueryStringConfig'),
          responseHeaderConfig?: {
            key?: string(name='Key'),
            values?: [ string ](name='Values'),
          }(name='ResponseHeaderConfig'),
          responseStatusCodeConfig?: {
            values?: [ string ](name='Values'),
          }(name='ResponseStatusCodeConfig'),
          sourceIpConfig?: {
            values?: [ string ](name='Values'),
          }(name='SourceIpConfig'),
          type?: string(name='Type'),
        }
      ](name='RuleConditions'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
    }
  ](name='Rules'),
}

model UpdateRulesAttributeResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model UpdateRulesAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRulesAttributeResponseBody(name='body'),
}

async function updateRulesAttributeWithOptions(request: UpdateRulesAttributeRequest, runtime: Util.RuntimeOptions): UpdateRulesAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.rules)) {
    query['Rules'] = request.rules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRulesAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRulesAttribute(request: UpdateRulesAttributeRequest): UpdateRulesAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRulesAttributeWithOptions(request, runtime);
}

model UpdateSecurityPolicyAttributeRequest {
  ciphers?: [ string ](name='Ciphers'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  securityPolicyId?: string(name='SecurityPolicyId'),
  securityPolicyName?: string(name='SecurityPolicyName'),
  TLSVersions?: [ string ](name='TLSVersions'),
}

model UpdateSecurityPolicyAttributeResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model UpdateSecurityPolicyAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSecurityPolicyAttributeResponseBody(name='body'),
}

async function updateSecurityPolicyAttributeWithOptions(request: UpdateSecurityPolicyAttributeRequest, runtime: Util.RuntimeOptions): UpdateSecurityPolicyAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ciphers)) {
    query['Ciphers'] = request.ciphers;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    query['SecurityPolicyId'] = request.securityPolicyId;
  }
  if (!Util.isUnset(request.securityPolicyName)) {
    query['SecurityPolicyName'] = request.securityPolicyName;
  }
  if (!Util.isUnset(request.TLSVersions)) {
    query['TLSVersions'] = request.TLSVersions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSecurityPolicyAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSecurityPolicyAttribute(request: UpdateSecurityPolicyAttributeRequest): UpdateSecurityPolicyAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecurityPolicyAttributeWithOptions(request, runtime);
}

model UpdateServerGroupAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  healthCheckConfig?: {
    healthCheckCodes?: [ string ](name='HealthCheckCodes'),
    healthCheckConnectPort?: int32(name='HealthCheckConnectPort'),
    healthCheckEnabled?: boolean(name='HealthCheckEnabled'),
    healthCheckHost?: string(name='HealthCheckHost'),
    healthCheckHttpVersion?: string(name='HealthCheckHttpVersion'),
    healthCheckInterval?: int32(name='HealthCheckInterval'),
    healthCheckMethod?: string(name='HealthCheckMethod'),
    healthCheckPath?: string(name='HealthCheckPath'),
    healthCheckProtocol?: string(name='HealthCheckProtocol'),
    healthCheckTimeout?: int32(name='HealthCheckTimeout'),
    healthyThreshold?: int32(name='HealthyThreshold'),
    unhealthyThreshold?: int32(name='UnhealthyThreshold'),
  }(name='HealthCheckConfig'),
  scheduler?: string(name='Scheduler'),
  serverGroupId?: string(name='ServerGroupId'),
  serverGroupName?: string(name='ServerGroupName'),
  serviceName?: string(name='ServiceName'),
  stickySessionConfig?: {
    cookie?: string(name='Cookie'),
    cookieTimeout?: int32(name='CookieTimeout'),
    stickySessionEnabled?: boolean(name='StickySessionEnabled'),
    stickySessionType?: string(name='StickySessionType'),
  }(name='StickySessionConfig'),
}

model UpdateServerGroupAttributeResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model UpdateServerGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServerGroupAttributeResponseBody(name='body'),
}

async function updateServerGroupAttributeWithOptions(request: UpdateServerGroupAttributeRequest, runtime: Util.RuntimeOptions): UpdateServerGroupAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.healthCheckConfig)) {
    query['HealthCheckConfig'] = request.healthCheckConfig;
  }
  if (!Util.isUnset(request.scheduler)) {
    query['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.serverGroupName)) {
    query['ServerGroupName'] = request.serverGroupName;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.stickySessionConfig)) {
    query['StickySessionConfig'] = request.stickySessionConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServerGroupAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateServerGroupAttribute(request: UpdateServerGroupAttributeRequest): UpdateServerGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateServerGroupAttributeWithOptions(request, runtime);
}

model UpdateServerGroupServersAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  serverGroupId?: string(name='ServerGroupId'),
  servers?: [ 
    {
      description?: string(name='Description'),
      port?: int32(name='Port'),
      serverId?: string(name='ServerId'),
      serverIp?: string(name='ServerIp'),
      serverType?: string(name='ServerType'),
      weight?: int32(name='Weight'),
    }
  ](name='Servers'),
}

model UpdateServerGroupServersAttributeResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model UpdateServerGroupServersAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServerGroupServersAttributeResponseBody(name='body'),
}

async function updateServerGroupServersAttributeWithOptions(request: UpdateServerGroupServersAttributeRequest, runtime: Util.RuntimeOptions): UpdateServerGroupServersAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    query['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.servers)) {
    query['Servers'] = request.servers;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServerGroupServersAttribute',
    version = '2020-06-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateServerGroupServersAttribute(request: UpdateServerGroupServersAttributeRequest): UpdateServerGroupServersAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateServerGroupServersAttributeWithOptions(request, runtime);
}

