/**
 *
 */
import Util;
import OSS;
import OpenPlatform;
import OSSUtil;
import FileForm;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-hangzhou = 'mt.cn-hangzhou.aliyuncs.com',
    ap-northeast-1 = 'mt.aliyuncs.com',
    ap-northeast-2-pop = 'mt.aliyuncs.com',
    ap-south-1 = 'mt.aliyuncs.com',
    ap-southeast-1 = 'mt.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'mt.aliyuncs.com',
    ap-southeast-3 = 'mt.aliyuncs.com',
    ap-southeast-5 = 'mt.aliyuncs.com',
    cn-beijing = 'mt.aliyuncs.com',
    cn-beijing-finance-1 = 'mt.aliyuncs.com',
    cn-beijing-finance-pop = 'mt.aliyuncs.com',
    cn-beijing-gov-1 = 'mt.aliyuncs.com',
    cn-beijing-nu16-b01 = 'mt.aliyuncs.com',
    cn-chengdu = 'mt.aliyuncs.com',
    cn-edge-1 = 'mt.aliyuncs.com',
    cn-fujian = 'mt.aliyuncs.com',
    cn-haidian-cm12-c01 = 'mt.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'mt.aliyuncs.com',
    cn-hangzhou-finance = 'mt.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'mt.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'mt.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'mt.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'mt.aliyuncs.com',
    cn-hangzhou-test-306 = 'mt.aliyuncs.com',
    cn-hongkong = 'mt.aliyuncs.com',
    cn-hongkong-finance-pop = 'mt.aliyuncs.com',
    cn-huhehaote = 'mt.aliyuncs.com',
    cn-north-2-gov-1 = 'mt.aliyuncs.com',
    cn-qingdao = 'mt.aliyuncs.com',
    cn-qingdao-nebula = 'mt.aliyuncs.com',
    cn-shanghai = 'mt.aliyuncs.com',
    cn-shanghai-et15-b01 = 'mt.aliyuncs.com',
    cn-shanghai-et2-b01 = 'mt.aliyuncs.com',
    cn-shanghai-finance-1 = 'mt.aliyuncs.com',
    cn-shanghai-inner = 'mt.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'mt.aliyuncs.com',
    cn-shenzhen = 'mt.aliyuncs.com',
    cn-shenzhen-finance-1 = 'mt.aliyuncs.com',
    cn-shenzhen-inner = 'mt.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'mt.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'mt.aliyuncs.com',
    cn-wuhan = 'mt.aliyuncs.com',
    cn-yushanfang = 'mt.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'mt.aliyuncs.com',
    cn-zhangjiakou = 'mt.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'mt.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'mt.aliyuncs.com',
    eu-central-1 = 'mt.aliyuncs.com',
    eu-west-1 = 'mt.aliyuncs.com',
    eu-west-1-oxs = 'mt.aliyuncs.com',
    me-east-1 = 'mt.aliyuncs.com',
    rus-west-1-pop = 'mt.aliyuncs.com',
    us-east-1 = 'mt.aliyuncs.com',
    us-west-1 = 'mt.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('alimt', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateDocTranslateTaskRequest {
  callbackUrl?: string(name='CallbackUrl'),
  clientToken?: string(name='ClientToken'),
  fileUrl?: string(name='FileUrl'),
  scene?: string(name='Scene'),
  sourceLanguage?: string(name='SourceLanguage'),
  targetLanguage?: string(name='TargetLanguage'),
}

model CreateDocTranslateTaskAdvanceRequest {
  callbackUrl?: string(name='CallbackUrl'),
  clientToken?: string(name='ClientToken'),
  fileUrlObject?: readable(name='FileUrl'),
  scene?: string(name='Scene'),
  sourceLanguage?: string(name='SourceLanguage'),
  targetLanguage?: string(name='TargetLanguage'),
}

model CreateDocTranslateTaskResponseBody = {
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  taskId?: string(name='TaskId'),
}

model CreateDocTranslateTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDocTranslateTaskResponseBody(name='body'),
}

async function createDocTranslateTaskWithOptions(request: CreateDocTranslateTaskRequest, runtime: Util.RuntimeOptions): CreateDocTranslateTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.callbackUrl)) {
    body['CallbackUrl'] = request.callbackUrl;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.fileUrl)) {
    body['FileUrl'] = request.fileUrl;
  }
  if (!Util.isUnset(request.scene)) {
    body['Scene'] = request.scene;
  }
  if (!Util.isUnset(request.sourceLanguage)) {
    body['SourceLanguage'] = request.sourceLanguage;
  }
  if (!Util.isUnset(request.targetLanguage)) {
    body['TargetLanguage'] = request.targetLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDocTranslateTask',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDocTranslateTask(request: CreateDocTranslateTaskRequest): CreateDocTranslateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDocTranslateTaskWithOptions(request, runtime);
}

async function createDocTranslateTaskAdvance(request: CreateDocTranslateTaskAdvanceRequest, runtime: Util.RuntimeOptions): CreateDocTranslateTaskResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'alimt',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var createDocTranslateTaskReq = new CreateDocTranslateTaskRequest{};
  OpenApiUtil.convert(request, createDocTranslateTaskReq);

  if(!Util.isUnset(request.fileUrlObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.fileUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    createDocTranslateTaskReq.fileUrl = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var createDocTranslateTaskResp = createDocTranslateTaskWithOptions(createDocTranslateTaskReq, runtime);
  return createDocTranslateTaskResp;
}

model CreateImageTranslateTaskRequest {
  clientToken?: string(name='ClientToken'),
  extra?: string(name='Extra'),
  sourceLanguage?: string(name='SourceLanguage'),
  targetLanguage?: string(name='TargetLanguage'),
  urlList?: string(name='UrlList'),
}

model CreateImageTranslateTaskResponseBody = {
  code?: int32(name='Code'),
  data?: {
    taskId?: string(name='TaskId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateImageTranslateTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateImageTranslateTaskResponseBody(name='body'),
}

async function createImageTranslateTaskWithOptions(request: CreateImageTranslateTaskRequest, runtime: Util.RuntimeOptions): CreateImageTranslateTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.extra)) {
    body['Extra'] = request.extra;
  }
  if (!Util.isUnset(request.sourceLanguage)) {
    body['SourceLanguage'] = request.sourceLanguage;
  }
  if (!Util.isUnset(request.targetLanguage)) {
    body['TargetLanguage'] = request.targetLanguage;
  }
  if (!Util.isUnset(request.urlList)) {
    body['UrlList'] = request.urlList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateImageTranslateTask',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createImageTranslateTask(request: CreateImageTranslateTaskRequest): CreateImageTranslateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createImageTranslateTaskWithOptions(request, runtime);
}

model GetBatchTranslateRequest {
  apiType?: string(name='ApiType'),
  formatType?: string(name='FormatType'),
  scene?: string(name='Scene'),
  sourceLanguage?: string(name='SourceLanguage'),
  sourceText?: string(name='SourceText'),
  targetLanguage?: string(name='TargetLanguage'),
}

model GetBatchTranslateResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  translatedList?: [  map[string]any ](name='TranslatedList'),
}

model GetBatchTranslateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBatchTranslateResponseBody(name='body'),
}

async function getBatchTranslateWithOptions(request: GetBatchTranslateRequest, runtime: Util.RuntimeOptions): GetBatchTranslateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apiType)) {
    body['ApiType'] = request.apiType;
  }
  if (!Util.isUnset(request.formatType)) {
    body['FormatType'] = request.formatType;
  }
  if (!Util.isUnset(request.scene)) {
    body['Scene'] = request.scene;
  }
  if (!Util.isUnset(request.sourceLanguage)) {
    body['SourceLanguage'] = request.sourceLanguage;
  }
  if (!Util.isUnset(request.sourceText)) {
    body['SourceText'] = request.sourceText;
  }
  if (!Util.isUnset(request.targetLanguage)) {
    body['TargetLanguage'] = request.targetLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetBatchTranslate',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBatchTranslate(request: GetBatchTranslateRequest): GetBatchTranslateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBatchTranslateWithOptions(request, runtime);
}

model GetDetectLanguageRequest {
  sourceText?: string(name='SourceText'),
}

model GetDetectLanguageResponseBody = {
  detectedLanguage?: string(name='DetectedLanguage'),
  requestId?: string(name='RequestId'),
}

model GetDetectLanguageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDetectLanguageResponseBody(name='body'),
}

async function getDetectLanguageWithOptions(request: GetDetectLanguageRequest, runtime: Util.RuntimeOptions): GetDetectLanguageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.sourceText)) {
    body['SourceText'] = request.sourceText;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDetectLanguage',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDetectLanguage(request: GetDetectLanguageRequest): GetDetectLanguageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDetectLanguageWithOptions(request, runtime);
}

model GetDocTranslateTaskRequest {
  taskId?: string(name='TaskId'),
}

model GetDocTranslateTaskResponseBody = {
  pageCount?: int32(name='PageCount'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  taskId?: string(name='TaskId'),
  translateErrorCode?: string(name='TranslateErrorCode'),
  translateErrorMessage?: string(name='TranslateErrorMessage'),
  translateFileUrl?: string(name='TranslateFileUrl'),
}

model GetDocTranslateTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDocTranslateTaskResponseBody(name='body'),
}

async function getDocTranslateTaskWithOptions(request: GetDocTranslateTaskRequest, runtime: Util.RuntimeOptions): GetDocTranslateTaskResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDocTranslateTask',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDocTranslateTask(request: GetDocTranslateTaskRequest): GetDocTranslateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDocTranslateTaskWithOptions(request, runtime);
}

model GetImageDiagnoseRequest {
  extra?: string(name='Extra'),
  url?: string(name='Url'),
}

model GetImageDiagnoseResponseBody = {
  code?: int32(name='Code'),
  data?: {
    language?: string(name='Language'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetImageDiagnoseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetImageDiagnoseResponseBody(name='body'),
}

async function getImageDiagnoseWithOptions(request: GetImageDiagnoseRequest, runtime: Util.RuntimeOptions): GetImageDiagnoseResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extra)) {
    body['Extra'] = request.extra;
  }
  if (!Util.isUnset(request.url)) {
    body['Url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetImageDiagnose',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImageDiagnose(request: GetImageDiagnoseRequest): GetImageDiagnoseResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageDiagnoseWithOptions(request, runtime);
}

model GetImageTranslateRequest {
  extra?: string(name='Extra'),
  sourceLanguage?: string(name='SourceLanguage'),
  targetLanguage?: string(name='TargetLanguage'),
  url?: string(name='Url'),
}

model GetImageTranslateResponseBody = {
  code?: int32(name='Code'),
  data?: {
    orc?: string(name='Orc'),
    pictureEditor?: string(name='PictureEditor'),
    url?: string(name='Url'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetImageTranslateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetImageTranslateResponseBody(name='body'),
}

async function getImageTranslateWithOptions(request: GetImageTranslateRequest, runtime: Util.RuntimeOptions): GetImageTranslateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extra)) {
    body['Extra'] = request.extra;
  }
  if (!Util.isUnset(request.sourceLanguage)) {
    body['SourceLanguage'] = request.sourceLanguage;
  }
  if (!Util.isUnset(request.targetLanguage)) {
    body['TargetLanguage'] = request.targetLanguage;
  }
  if (!Util.isUnset(request.url)) {
    body['Url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetImageTranslate',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImageTranslate(request: GetImageTranslateRequest): GetImageTranslateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageTranslateWithOptions(request, runtime);
}

model GetImageTranslateTaskRequest {
  taskId?: string(name='TaskId'),
}

model GetImageTranslateTaskResponseBody = {
  code?: int32(name='Code'),
  data?: {
    imageData?: string(name='ImageData'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetImageTranslateTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetImageTranslateTaskResponseBody(name='body'),
}

async function getImageTranslateTaskWithOptions(request: GetImageTranslateTaskRequest, runtime: Util.RuntimeOptions): GetImageTranslateTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetImageTranslateTask',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getImageTranslateTask(request: GetImageTranslateTaskRequest): GetImageTranslateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getImageTranslateTaskWithOptions(request, runtime);
}

model GetTitleDiagnoseRequest {
  categoryId?: string(name='CategoryId'),
  extra?: string(name='Extra'),
  language?: string(name='Language'),
  platform?: string(name='Platform'),
  title?: string(name='Title'),
}

model GetTitleDiagnoseResponseBody = {
  code?: int32(name='Code'),
  data?: {
    allUppercaseWords?: string(name='AllUppercaseWords'),
    containCoreClasses?: string(name='ContainCoreClasses'),
    disableWords?: string(name='DisableWords'),
    duplicateWords?: string(name='DuplicateWords'),
    languageQualityScore?: string(name='LanguageQualityScore'),
    noFirstUppercaseList?: string(name='NoFirstUppercaseList'),
    overLengthLimit?: string(name='OverLengthLimit'),
    totalScore?: string(name='TotalScore'),
    wordCount?: string(name='WordCount'),
    wordSpelledCorrectError?: string(name='WordSpelledCorrectError'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetTitleDiagnoseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTitleDiagnoseResponseBody(name='body'),
}

async function getTitleDiagnoseWithOptions(request: GetTitleDiagnoseRequest, runtime: Util.RuntimeOptions): GetTitleDiagnoseResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.categoryId)) {
    body['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.extra)) {
    body['Extra'] = request.extra;
  }
  if (!Util.isUnset(request.language)) {
    body['Language'] = request.language;
  }
  if (!Util.isUnset(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTitleDiagnose',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTitleDiagnose(request: GetTitleDiagnoseRequest): GetTitleDiagnoseResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTitleDiagnoseWithOptions(request, runtime);
}

model GetTitleGenerateRequest {
  attributes?: string(name='Attributes'),
  categoryId?: string(name='CategoryId'),
  extra?: string(name='Extra'),
  hotWords?: string(name='HotWords'),
  language?: string(name='Language'),
  platform?: string(name='Platform'),
  title?: string(name='Title'),
}

model GetTitleGenerateResponseBody = {
  code?: int32(name='Code'),
  data?: {
    titles?: string(name='Titles'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetTitleGenerateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTitleGenerateResponseBody(name='body'),
}

async function getTitleGenerateWithOptions(request: GetTitleGenerateRequest, runtime: Util.RuntimeOptions): GetTitleGenerateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.attributes)) {
    body['Attributes'] = request.attributes;
  }
  if (!Util.isUnset(request.categoryId)) {
    body['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.extra)) {
    body['Extra'] = request.extra;
  }
  if (!Util.isUnset(request.hotWords)) {
    body['HotWords'] = request.hotWords;
  }
  if (!Util.isUnset(request.language)) {
    body['Language'] = request.language;
  }
  if (!Util.isUnset(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTitleGenerate',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTitleGenerate(request: GetTitleGenerateRequest): GetTitleGenerateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTitleGenerateWithOptions(request, runtime);
}

model GetTitleIntelligenceRequest {
  catLevelThreeId?: long(name='CatLevelThreeId'),
  catLevelTwoId?: long(name='CatLevelTwoId'),
  extra?: string(name='Extra'),
  keywords?: string(name='Keywords'),
  platform?: string(name='Platform'),
}

model GetTitleIntelligenceResponseBody = {
  code?: int32(name='Code'),
  data?: {
    titles?: string(name='Titles'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetTitleIntelligenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTitleIntelligenceResponseBody(name='body'),
}

async function getTitleIntelligenceWithOptions(request: GetTitleIntelligenceRequest, runtime: Util.RuntimeOptions): GetTitleIntelligenceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catLevelThreeId)) {
    body['CatLevelThreeId'] = request.catLevelThreeId;
  }
  if (!Util.isUnset(request.catLevelTwoId)) {
    body['CatLevelTwoId'] = request.catLevelTwoId;
  }
  if (!Util.isUnset(request.extra)) {
    body['Extra'] = request.extra;
  }
  if (!Util.isUnset(request.keywords)) {
    body['Keywords'] = request.keywords;
  }
  if (!Util.isUnset(request.platform)) {
    body['Platform'] = request.platform;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTitleIntelligence',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTitleIntelligence(request: GetTitleIntelligenceRequest): GetTitleIntelligenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTitleIntelligenceWithOptions(request, runtime);
}

model GetTranslateReportRequest {
  apiName?: string(name='ApiName'),
  beginTime?: string(name='BeginTime'),
  endTime?: string(name='EndTime'),
  group?: string(name='Group'),
}

model GetTranslateReportResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetTranslateReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTranslateReportResponseBody(name='body'),
}

async function getTranslateReportWithOptions(request: GetTranslateReportRequest, runtime: Util.RuntimeOptions): GetTranslateReportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiName)) {
    query['ApiName'] = request.apiName;
  }
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTranslateReport',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTranslateReport(request: GetTranslateReportRequest): GetTranslateReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTranslateReportWithOptions(request, runtime);
}

model OpenAlimtServiceRequest {
  ownerId?: long(name='OwnerId'),
  type?: string(name='Type'),
}

model OpenAlimtServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenAlimtServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenAlimtServiceResponseBody(name='body'),
}

async function openAlimtServiceWithOptions(request: OpenAlimtServiceRequest, runtime: Util.RuntimeOptions): OpenAlimtServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenAlimtService',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openAlimtService(request: OpenAlimtServiceRequest): OpenAlimtServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openAlimtServiceWithOptions(request, runtime);
}

model TranslateRequest {
  context?: string(name='Context'),
  formatType?: string(name='FormatType'),
  scene?: string(name='Scene'),
  sourceLanguage?: string(name='SourceLanguage'),
  sourceText?: string(name='SourceText'),
  targetLanguage?: string(name='TargetLanguage'),
}

model TranslateResponseBody = {
  code?: int32(name='Code'),
  data?: {
    translated?: string(name='Translated'),
    wordCount?: string(name='WordCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model TranslateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TranslateResponseBody(name='body'),
}

async function translateWithOptions(request: TranslateRequest, runtime: Util.RuntimeOptions): TranslateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.context)) {
    query['Context'] = request.context;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.formatType)) {
    body['FormatType'] = request.formatType;
  }
  if (!Util.isUnset(request.scene)) {
    body['Scene'] = request.scene;
  }
  if (!Util.isUnset(request.sourceLanguage)) {
    body['SourceLanguage'] = request.sourceLanguage;
  }
  if (!Util.isUnset(request.sourceText)) {
    body['SourceText'] = request.sourceText;
  }
  if (!Util.isUnset(request.targetLanguage)) {
    body['TargetLanguage'] = request.targetLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'Translate',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function translate(request: TranslateRequest): TranslateResponse {
  var runtime = new Util.RuntimeOptions{};
  return translateWithOptions(request, runtime);
}

model TranslateCertificateRequest {
  certificateType?: string(name='CertificateType'),
  imageUrl?: string(name='ImageUrl'),
  resultType?: string(name='ResultType'),
  sourceLanguage?: string(name='SourceLanguage'),
  targetLanguage?: string(name='TargetLanguage'),
}

model TranslateCertificateAdvanceRequest {
  certificateType?: string(name='CertificateType'),
  imageUrlObject?: readable(name='ImageUrl'),
  resultType?: string(name='ResultType'),
  sourceLanguage?: string(name='SourceLanguage'),
  targetLanguage?: string(name='TargetLanguage'),
}

model TranslateCertificateResponseBody = {
  data?: {
    translatedValues?: [ 
      {
        key?: string(name='Key'),
        keyTranslation?: string(name='KeyTranslation'),
        value?: string(name='Value'),
        valueTranslation?: string(name='ValueTranslation'),
      }
    ](name='TranslatedValues'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model TranslateCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TranslateCertificateResponseBody(name='body'),
}

async function translateCertificateWithOptions(request: TranslateCertificateRequest, runtime: Util.RuntimeOptions): TranslateCertificateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.certificateType)) {
    body['CertificateType'] = request.certificateType;
  }
  if (!Util.isUnset(request.imageUrl)) {
    body['ImageUrl'] = request.imageUrl;
  }
  if (!Util.isUnset(request.resultType)) {
    body['ResultType'] = request.resultType;
  }
  if (!Util.isUnset(request.sourceLanguage)) {
    body['SourceLanguage'] = request.sourceLanguage;
  }
  if (!Util.isUnset(request.targetLanguage)) {
    body['TargetLanguage'] = request.targetLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TranslateCertificate',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function translateCertificate(request: TranslateCertificateRequest): TranslateCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return translateCertificateWithOptions(request, runtime);
}

async function translateCertificateAdvance(request: TranslateCertificateAdvanceRequest, runtime: Util.RuntimeOptions): TranslateCertificateResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'alimt',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var translateCertificateReq = new TranslateCertificateRequest{};
  OpenApiUtil.convert(request, translateCertificateReq);

  if(!Util.isUnset(request.imageUrlObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.imageUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    translateCertificateReq.imageUrl = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var translateCertificateResp = translateCertificateWithOptions(translateCertificateReq, runtime);
  return translateCertificateResp;
}

model TranslateECommerceRequest {
  context?: string(name='Context'),
  formatType?: string(name='FormatType'),
  scene?: string(name='Scene'),
  sourceLanguage?: string(name='SourceLanguage'),
  sourceText?: string(name='SourceText'),
  targetLanguage?: string(name='TargetLanguage'),
}

model TranslateECommerceResponseBody = {
  code?: int32(name='Code'),
  data?: {
    translated?: string(name='Translated'),
    wordCount?: string(name='WordCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model TranslateECommerceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TranslateECommerceResponseBody(name='body'),
}

async function translateECommerceWithOptions(request: TranslateECommerceRequest, runtime: Util.RuntimeOptions): TranslateECommerceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.context)) {
    query['Context'] = request.context;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.formatType)) {
    body['FormatType'] = request.formatType;
  }
  if (!Util.isUnset(request.scene)) {
    body['Scene'] = request.scene;
  }
  if (!Util.isUnset(request.sourceLanguage)) {
    body['SourceLanguage'] = request.sourceLanguage;
  }
  if (!Util.isUnset(request.sourceText)) {
    body['SourceText'] = request.sourceText;
  }
  if (!Util.isUnset(request.targetLanguage)) {
    body['TargetLanguage'] = request.targetLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TranslateECommerce',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function translateECommerce(request: TranslateECommerceRequest): TranslateECommerceResponse {
  var runtime = new Util.RuntimeOptions{};
  return translateECommerceWithOptions(request, runtime);
}

model TranslateGeneralRequest {
  context?: string(name='Context'),
  formatType?: string(name='FormatType'),
  scene?: string(name='Scene'),
  sourceLanguage?: string(name='SourceLanguage'),
  sourceText?: string(name='SourceText'),
  targetLanguage?: string(name='TargetLanguage'),
}

model TranslateGeneralResponseBody = {
  code?: int32(name='Code'),
  data?: {
    translated?: string(name='Translated'),
    wordCount?: string(name='WordCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model TranslateGeneralResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TranslateGeneralResponseBody(name='body'),
}

async function translateGeneralWithOptions(request: TranslateGeneralRequest, runtime: Util.RuntimeOptions): TranslateGeneralResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.context)) {
    query['Context'] = request.context;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.formatType)) {
    body['FormatType'] = request.formatType;
  }
  if (!Util.isUnset(request.scene)) {
    body['Scene'] = request.scene;
  }
  if (!Util.isUnset(request.sourceLanguage)) {
    body['SourceLanguage'] = request.sourceLanguage;
  }
  if (!Util.isUnset(request.sourceText)) {
    body['SourceText'] = request.sourceText;
  }
  if (!Util.isUnset(request.targetLanguage)) {
    body['TargetLanguage'] = request.targetLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TranslateGeneral',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function translateGeneral(request: TranslateGeneralRequest): TranslateGeneralResponse {
  var runtime = new Util.RuntimeOptions{};
  return translateGeneralWithOptions(request, runtime);
}

model TranslateImageRequest {
  ext?: string(name='Ext'),
  field?: string(name='Field'),
  imageBase64?: string(name='ImageBase64'),
  imageUrl?: string(name='ImageUrl'),
  sourceLanguage?: string(name='SourceLanguage'),
  targetLanguage?: string(name='TargetLanguage'),
}

model TranslateImageResponseBody = {
  code?: int32(name='Code'),
  data?: {
    finalImageUrl?: string(name='FinalImageUrl'),
    inPaintingUrl?: string(name='InPaintingUrl'),
    templateJson?: string(name='TemplateJson'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model TranslateImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TranslateImageResponseBody(name='body'),
}

async function translateImageWithOptions(request: TranslateImageRequest, runtime: Util.RuntimeOptions): TranslateImageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.ext)) {
    body['Ext'] = request.ext;
  }
  if (!Util.isUnset(request.field)) {
    body['Field'] = request.field;
  }
  if (!Util.isUnset(request.imageBase64)) {
    body['ImageBase64'] = request.imageBase64;
  }
  if (!Util.isUnset(request.imageUrl)) {
    body['ImageUrl'] = request.imageUrl;
  }
  if (!Util.isUnset(request.sourceLanguage)) {
    body['SourceLanguage'] = request.sourceLanguage;
  }
  if (!Util.isUnset(request.targetLanguage)) {
    body['TargetLanguage'] = request.targetLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TranslateImage',
    version = '2018-10-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function translateImage(request: TranslateImageRequest): TranslateImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return translateImageWithOptions(request, runtime);
}

