/**
 *
 */
import OpenApi;
import OpenApi.OpenApiUtil;

extends OpenApi;


init(config: OpenApiUtil.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('cr', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!$isNull(endpoint)) {
    return endpoint;
  }
  
  if (!$isNull(endpointMap) && !$isNull(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CancelArtifactBuildTaskRequest {
  buildTaskId?: string(name='BuildTaskId', description='The ID of the artifact building task.

This parameter is required.', example='i2ei-12****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-shac42yvqzvq****'),
}

model CancelArtifactBuildTaskResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C4C7DD0C-C9D6-437A-A7EE-121EFD70D002'),
}

model CancelArtifactBuildTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelArtifactBuildTaskResponseBody(name='body'),
}

/**
 * @summary Cancels an artifact building task.
 *
 * @param request CancelArtifactBuildTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelArtifactBuildTaskResponse
 */
async function cancelArtifactBuildTaskWithOptions(request: CancelArtifactBuildTaskRequest, runtime: $RuntimeOptions): CancelArtifactBuildTaskResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.buildTaskId)) {
    query['BuildTaskId'] = request.buildTaskId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CancelArtifactBuildTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Cancels an artifact building task.
 *
 * @param request CancelArtifactBuildTaskRequest
 * @return CancelArtifactBuildTaskResponse
 */
async function cancelArtifactBuildTask(request: CancelArtifactBuildTaskRequest): CancelArtifactBuildTaskResponse {
  var runtime = new $RuntimeOptions{};
  return cancelArtifactBuildTaskWithOptions(request, runtime);
}

model CancelRepoBuildRecordRequest {
  buildRecordId?: string(name='BuildRecordId', description='The ID of the image building record.

This parameter is required.', example='74FDBA62-30C0-4F22-BE7B-F1D36FD1****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

This parameter is required.', example='crr-tquyps22md8p****'),
}

model CancelRepoBuildRecordResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4CE1F661-75DD-4EBD-A4AD-057B26834ABB'),
}

model CancelRepoBuildRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelRepoBuildRecordResponseBody(name='body'),
}

/**
 * @summary Cancels an image building task of a repository.
 *
 * @param request CancelRepoBuildRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelRepoBuildRecordResponse
 */
async function cancelRepoBuildRecordWithOptions(request: CancelRepoBuildRecordRequest, runtime: $RuntimeOptions): CancelRepoBuildRecordResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.buildRecordId)) {
    query['BuildRecordId'] = request.buildRecordId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CancelRepoBuildRecord',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Cancels an image building task of a repository.
 *
 * @param request CancelRepoBuildRecordRequest
 * @return CancelRepoBuildRecordResponse
 */
async function cancelRepoBuildRecord(request: CancelRepoBuildRecordRequest): CancelRepoBuildRecordResponse {
  var runtime = new $RuntimeOptions{};
  return cancelRepoBuildRecordWithOptions(request, runtime);
}

model CancelRepoSyncTaskRequest {
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  syncTaskId?: string(name='SyncTaskId', description='The ID of the replication task.

This parameter is required.', example='rst-biu4u4pm4it5****'),
}

model CancelRepoSyncTaskResponseBody = {
  code?: string(name='Code', description='The response code.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the CancelRepoSyncTask request is successful. Valid values:

*   `true`: successful
*   `false`: failed', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='EB9C5722-51E2-4497-A573-575B0CA5CE0C'),
}

model CancelRepoSyncTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelRepoSyncTaskResponseBody(name='body'),
}

/**
 * @summary Cancels a single replication task.
 *
 * @param request CancelRepoSyncTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelRepoSyncTaskResponse
 */
async function cancelRepoSyncTaskWithOptions(request: CancelRepoSyncTaskRequest, runtime: $RuntimeOptions): CancelRepoSyncTaskResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.syncTaskId)) {
    query['SyncTaskId'] = request.syncTaskId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CancelRepoSyncTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Cancels a single replication task.
 *
 * @param request CancelRepoSyncTaskRequest
 * @return CancelRepoSyncTaskResponse
 */
async function cancelRepoSyncTask(request: CancelRepoSyncTaskRequest): CancelRepoSyncTaskResponse {
  var runtime = new $RuntimeOptions{};
  return cancelRepoSyncTaskWithOptions(request, runtime);
}

model ChangeResourceGroupRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which you want to move the resource.

This parameter is required.', example='rg-aekz5nlvlaksnvi'),
  resourceId?: string(name='ResourceId', description='The ID of the resource.

This parameter is required.', example='cri-8qong6ve5p3mhlgt'),
  resourceRegionId?: string(name='ResourceRegionId', description='The ID of the region.

This parameter is required.', example='cn-shenzhen-finance-1'),
}

model ChangeResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='314CB661-35A5-5F01-A623-3EC6F87FF52F'),
}

model ChangeResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeResourceGroupResponseBody(name='body'),
}

/**
 * @summary Changes the resource group to which a resource belongs.
 *
 * @param request ChangeResourceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeResourceGroupResponse
 */
async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: $RuntimeOptions): ChangeResourceGroupResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceRegionId)) {
    query['ResourceRegionId'] = request.resourceRegionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ChangeResourceGroup',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Changes the resource group to which a resource belongs.
 *
 * @param request ChangeResourceGroupRequest
 * @return ChangeResourceGroupResponse
 */
async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new $RuntimeOptions{};
  return changeResourceGroupWithOptions(request, runtime);
}

model CreateArtifactBuildRuleRequest {
  artifactType?: string(name='ArtifactType', description='The type of the artifact.

*   `ACCELERATED_IMAGE`: accelerated images.

This parameter is required.', example='ACCELERATED_IMAGE'),
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-cxreylqvcyje****'),
  parameters?: map[string]any(name='Parameters', description='Additional parameters.', example='{}'),
  scopeId?: string(name='ScopeId', description='The ID of the effective range of the rule.

*   Set the value to the ID of the image repository.

This parameter is required.', example='crr-pmajihou6cg0****'),
  scopeType?: string(name='ScopeType', description='The effective range of the rule. Valid values:

*   `REPOSITORY`

This parameter is required.', example='REPOSITORY'),
}

model CreateArtifactBuildRuleShrinkRequest {
  artifactType?: string(name='ArtifactType', description='The type of the artifact.

*   `ACCELERATED_IMAGE`: accelerated images.

This parameter is required.', example='ACCELERATED_IMAGE'),
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-cxreylqvcyje****'),
  parametersShrink?: string(name='Parameters', description='Additional parameters.', example='{}'),
  scopeId?: string(name='ScopeId', description='The ID of the effective range of the rule.

*   Set the value to the ID of the image repository.

This parameter is required.', example='crr-pmajihou6cg0****'),
  scopeType?: string(name='ScopeType', description='The effective range of the rule. Valid values:

*   `REPOSITORY`

This parameter is required.', example='REPOSITORY'),
}

model CreateArtifactBuildRuleResponseBody = {
  buildRuleId?: string(name='BuildRuleId', description='The ID of the accelerated image building rule.', example='crabr-7dfa5qye5****'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='C8E90AB5-0A96-5D12-9E59-11EE46360642'),
}

model CreateArtifactBuildRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateArtifactBuildRuleResponseBody(name='body'),
}

/**
 * @summary Create image repository acceleration rules for image building.
 *
 * @description You can create building rules of accelerated images only for image repositories of Container Registry Advanced Edition instances. You cannot create building rules of accelerated images for image repositories of Container Registry Basic Edition instances. For more information, see [Specifications of different editions](https://www.alibabacloud.com/help/en/acr/product-overview/what-is-container-registry?spm=openapi-amp.newDocPublishment.0.0.bf82281fRj7rmV#section-n3q-ps7-x6k).
 * Accelerated images are not supported in Alibaba Finance Cloud regions or Alibaba Gov Cloud regions.
 *
 * @param tmpReq CreateArtifactBuildRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateArtifactBuildRuleResponse
 */
async function createArtifactBuildRuleWithOptions(tmpReq: CreateArtifactBuildRuleRequest, runtime: $RuntimeOptions): CreateArtifactBuildRuleResponse {
  tmpReq.validate();
  var request = new CreateArtifactBuildRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.parameters)) {
    request.parametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.parameters, 'Parameters', 'json');
  }
  var query = {};
  if (!$isNull(request.artifactType)) {
    query['ArtifactType'] = request.artifactType;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.parametersShrink)) {
    query['Parameters'] = request.parametersShrink;
  }
  if (!$isNull(request.scopeId)) {
    query['ScopeId'] = request.scopeId;
  }
  if (!$isNull(request.scopeType)) {
    query['ScopeType'] = request.scopeType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateArtifactBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Create image repository acceleration rules for image building.
 *
 * @description You can create building rules of accelerated images only for image repositories of Container Registry Advanced Edition instances. You cannot create building rules of accelerated images for image repositories of Container Registry Basic Edition instances. For more information, see [Specifications of different editions](https://www.alibabacloud.com/help/en/acr/product-overview/what-is-container-registry?spm=openapi-amp.newDocPublishment.0.0.bf82281fRj7rmV#section-n3q-ps7-x6k).
 * Accelerated images are not supported in Alibaba Finance Cloud regions or Alibaba Gov Cloud regions.
 *
 * @param request CreateArtifactBuildRuleRequest
 * @return CreateArtifactBuildRuleResponse
 */
async function createArtifactBuildRule(request: CreateArtifactBuildRuleRequest): CreateArtifactBuildRuleResponse {
  var runtime = new $RuntimeOptions{};
  return createArtifactBuildRuleWithOptions(request, runtime);
}

model CreateArtifactLifecycleRuleRequest {
  auto?: boolean(name='Auto', description='Specify whether to automatically execute the lifecycle management rule.', example='false'),
  enableDeleteTag?: boolean(name='EnableDeleteTag', description='Specify whether to enable lifecycle management for the artifact.', example='true'),
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-gbwfk7qbgrxe****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='dev-backend'),
  repoName?: string(name='RepoName', description='The name of the image repository.', example='test_1'),
  retentionTagCount?: long(name='RetentionTagCount', description='The number of images that you want to retain.', example='30'),
  scheduleTime?: string(name='ScheduleTime', description='The execution cycle of the lifecycle management rule.', example='WEEK'),
  scope?: string(name='Scope', description='The deletion scope.', example='INSTANCE'),
  tagRegexp?: string(name='TagRegexp', description='The regular expression that is used to indicate which image tags are retained.', example='release-.*'),
}

model CreateArtifactLifecycleRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='True'),
  requestId?: string(name='RequestId', description='The request ID.', example='0AA66379-B880-5123-9F6A-96BB25D****'),
  ruleId?: string(name='RuleId', description='The rule ID.', example='cralr-b6thg027zmk1****'),
}

model CreateArtifactLifecycleRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateArtifactLifecycleRuleResponseBody(name='body'),
}

/**
 * @summary Creates a lifecycle management rule for an artifact.
 *
 * @param request CreateArtifactLifecycleRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateArtifactLifecycleRuleResponse
 */
async function createArtifactLifecycleRuleWithOptions(request: CreateArtifactLifecycleRuleRequest, runtime: $RuntimeOptions): CreateArtifactLifecycleRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.auto)) {
    query['Auto'] = request.auto;
  }
  if (!$isNull(request.enableDeleteTag)) {
    query['EnableDeleteTag'] = request.enableDeleteTag;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.retentionTagCount)) {
    query['RetentionTagCount'] = request.retentionTagCount;
  }
  if (!$isNull(request.scheduleTime)) {
    query['ScheduleTime'] = request.scheduleTime;
  }
  if (!$isNull(request.scope)) {
    query['Scope'] = request.scope;
  }
  if (!$isNull(request.tagRegexp)) {
    query['TagRegexp'] = request.tagRegexp;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateArtifactLifecycleRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a lifecycle management rule for an artifact.
 *
 * @param request CreateArtifactLifecycleRuleRequest
 * @return CreateArtifactLifecycleRuleResponse
 */
async function createArtifactLifecycleRule(request: CreateArtifactLifecycleRuleRequest): CreateArtifactLifecycleRuleResponse {
  var runtime = new $RuntimeOptions{};
  return createArtifactLifecycleRuleWithOptions(request, runtime);
}

model CreateArtifactSubscriptionRuleRequest {
  accelerate?: boolean(name='Accelerate', description='Indicates whether an acceleration link is enabled for image subscription. The subscription acceleration feature is in public preview. The feature is optimized based on scheduling policies and network links to accelerate image subscription.', example='true'),
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-c0o11woew0k****'),
  namespaceName?: string(name='NamespaceName', description='The name of the Container Registry namespace.

This parameter is required.', example='test-ns'),
  override?: boolean(name='Override', description='Indicates whether the original image is overwritten.', example='true'),
  platform?: [ string ](name='Platform', description='The operating system and architecture. If the source repository contains a multi-arch image, only the specified operating system and architecture are subscribed to the destination repository of the Enterprise Edition instance. Subscribe to the destination repository of an Enterprise Edition instance

This parameter is required.'),
  repoName?: string(name='RepoName', description='The name of the Container Registry repository.

This parameter is required.', example='test-repo'),
  sourceNamespaceName?: string(name='SourceNamespaceName', description='The source namespace.', example='library'),
  sourceProvider?: string(name='SourceProvider', description='The source of the artifact.

Valid values:

*   DOCKER_HUB: Docker Hub
*   GCR: GCR
*   QUAY: Quay.io

This parameter is required.', example='DOCKER_HUB'),
  sourceRepoName?: string(name='SourceRepoName', description='The source repository.

This parameter is required.', example='nginx'),
  tagCount?: long(name='TagCount', description='The number of subscribed images.

This parameter is required.', example='1'),
  tagRegexp?: string(name='TagRegexp', description='The image tag in the subscription source repository. Regular expressions are supported.

This parameter is required.', example='release-v.*'),
}

model CreateArtifactSubscriptionRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicate whether the API request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='02B27D80-FD32-5155-931A-93700779BB9E'),
  ruleId?: string(name='RuleId', description='The ID of the artifact subscription rule.', example='crasr-lxdfele7dg4****'),
}

model CreateArtifactSubscriptionRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateArtifactSubscriptionRuleResponseBody(name='body'),
}

/**
 * @summary Creates an artifact subscription rule.
 *
 * @param request CreateArtifactSubscriptionRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateArtifactSubscriptionRuleResponse
 */
async function createArtifactSubscriptionRuleWithOptions(request: CreateArtifactSubscriptionRuleRequest, runtime: $RuntimeOptions): CreateArtifactSubscriptionRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accelerate)) {
    query['Accelerate'] = request.accelerate;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!$isNull(request.override)) {
    query['Override'] = request.override;
  }
  if (!$isNull(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.sourceNamespaceName)) {
    query['SourceNamespaceName'] = request.sourceNamespaceName;
  }
  if (!$isNull(request.sourceProvider)) {
    query['SourceProvider'] = request.sourceProvider;
  }
  if (!$isNull(request.sourceRepoName)) {
    query['SourceRepoName'] = request.sourceRepoName;
  }
  if (!$isNull(request.tagCount)) {
    query['TagCount'] = request.tagCount;
  }
  if (!$isNull(request.tagRegexp)) {
    query['TagRegexp'] = request.tagRegexp;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateArtifactSubscriptionRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an artifact subscription rule.
 *
 * @param request CreateArtifactSubscriptionRuleRequest
 * @return CreateArtifactSubscriptionRuleResponse
 */
async function createArtifactSubscriptionRule(request: CreateArtifactSubscriptionRuleRequest): CreateArtifactSubscriptionRuleResponse {
  var runtime = new $RuntimeOptions{};
  return createArtifactSubscriptionRuleWithOptions(request, runtime);
}

model CreateArtifactSubscriptionTaskRequest {
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-4ec5xvj4j0l****'),
  ruleId?: string(name='RuleId', description='The rule ID.

This parameter is required.', example='crasr-88s7vmelc3m****'),
}

model CreateArtifactSubscriptionTaskResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='132D314B-BDD4-564C-89FE-3E2BAE115239'),
  taskId?: string(name='TaskId', description='The task ID.', example='crast-40le4es9yh0p****'),
}

model CreateArtifactSubscriptionTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateArtifactSubscriptionTaskResponseBody(name='body'),
}

/**
 * @summary Creates an artifact subscription task.
 *
 * @param request CreateArtifactSubscriptionTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateArtifactSubscriptionTaskResponse
 */
async function createArtifactSubscriptionTaskWithOptions(request: CreateArtifactSubscriptionTaskRequest, runtime: $RuntimeOptions): CreateArtifactSubscriptionTaskResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateArtifactSubscriptionTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an artifact subscription task.
 *
 * @param request CreateArtifactSubscriptionTaskRequest
 * @return CreateArtifactSubscriptionTaskResponse
 */
async function createArtifactSubscriptionTask(request: CreateArtifactSubscriptionTaskRequest): CreateArtifactSubscriptionTaskResponse {
  var runtime = new $RuntimeOptions{};
  return createArtifactSubscriptionTaskWithOptions(request, runtime);
}

model CreateBuildRecordByRecordRequest {
  buildRecordId?: string(name='BuildRecordId', description='This parameter is required.', example='0A311FC5-B8C6-4332-80E4-539EB73****'),
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='cri-hpdfkc6utbaq****'),
  repoId?: string(name='RepoId', description='This parameter is required.', example='crr-hnoq7j93or3k****'),
}

model CreateBuildRecordByRecordResponseBody = {
  buildRecordId?: string(name='BuildRecordId', example='crbr-ly77w5i3t31f****'),
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='4CE1F661-75DD-4EBD-A4AD-057B26834ABB'),
}

model CreateBuildRecordByRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateBuildRecordByRecordResponseBody(name='body'),
}

/**
 * @summary Creates an image building record based on an existing record.
 *
 * @param request CreateBuildRecordByRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBuildRecordByRecordResponse
 */
async function createBuildRecordByRecordWithOptions(request: CreateBuildRecordByRecordRequest, runtime: $RuntimeOptions): CreateBuildRecordByRecordResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.buildRecordId)) {
    query['BuildRecordId'] = request.buildRecordId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateBuildRecordByRecord',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an image building record based on an existing record.
 *
 * @param request CreateBuildRecordByRecordRequest
 * @return CreateBuildRecordByRecordResponse
 */
async function createBuildRecordByRecord(request: CreateBuildRecordByRecordRequest): CreateBuildRecordByRecordResponse {
  var runtime = new $RuntimeOptions{};
  return createBuildRecordByRecordWithOptions(request, runtime);
}

model CreateBuildRecordByRuleRequest {
  buildRuleId?: string(name='BuildRuleId', description='The ID of the image building rule.

This parameter is required.', example='crbr-1j95g4bu2s1i****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-asd6vujuhay0****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

This parameter is required.', example='crr-8dz3aedjqlmk****'),
}

model CreateBuildRecordByRuleResponseBody = {
  buildRecordId?: string(name='BuildRecordId', description='The ID of the image building record.', example='0A311FC5-B8C6-4332-80E4-539EB73****'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='B01B8857-A16E-40E9-A37E-764F15776FAA'),
}

model CreateBuildRecordByRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateBuildRecordByRuleResponseBody(name='body'),
}

/**
 * @summary Creates an image building record based on a rule.
 *
 * @param request CreateBuildRecordByRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBuildRecordByRuleResponse
 */
async function createBuildRecordByRuleWithOptions(request: CreateBuildRecordByRuleRequest, runtime: $RuntimeOptions): CreateBuildRecordByRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.buildRuleId)) {
    query['BuildRuleId'] = request.buildRuleId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateBuildRecordByRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an image building record based on a rule.
 *
 * @param request CreateBuildRecordByRuleRequest
 * @return CreateBuildRecordByRuleResponse
 */
async function createBuildRecordByRule(request: CreateBuildRecordByRuleRequest): CreateBuildRecordByRuleResponse {
  var runtime = new $RuntimeOptions{};
  return createBuildRecordByRuleWithOptions(request, runtime);
}

model CreateChainRequest {
  chainConfig?: string(name='ChainConfig', description='The configuration of the delivery chain in the JSON format.', example='chainconfig'),
  description?: string(name='Description', description='The description of the delivery chain.', example='description'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-4cdrlqmhn4gm****'),
  name?: string(name='Name', description='The name of the delivery chain.

This parameter is required.', example='test'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='repo1'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.', example='ns1'),
  scopeExclude?: [ string ](name='ScopeExclude', description='Repositories in which the delivery chain does not take effect.'),
}

model CreateChainResponseBody = {
  chainId?: string(name='ChainId', description='The ID of the delivery chain.', example='chi-02ymhtwl3cq8****'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4BC03B36-E515-5806-99AC-268AE3C0****'),
}

model CreateChainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateChainResponseBody(name='body'),
}

/**
 * @summary Creates a delivery chain.
 *
 * @param request CreateChainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateChainResponse
 */
async function createChainWithOptions(request: CreateChainRequest, runtime: $RuntimeOptions): CreateChainResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.chainConfig)) {
    query['ChainConfig'] = request.chainConfig;
  }
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!$isNull(request.scopeExclude)) {
    query['ScopeExclude'] = request.scopeExclude;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateChain',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a delivery chain.
 *
 * @param request CreateChainRequest
 * @return CreateChainResponse
 */
async function createChain(request: CreateChainRequest): CreateChainResponse {
  var runtime = new $RuntimeOptions{};
  return createChainWithOptions(request, runtime);
}

model CreateChartNamespaceRequest {
  autoCreateRepo?: boolean(name='AutoCreateRepo', description='Specifies whether to automatically create repositories in the namespace. Valid values:

\\\\-`  true `: automatically creates repositories in the namespace.

\\\\-`  false `: does not automatically create repositories in the namespace.', example='true'),
  defaultRepoType?: string(name='DefaultRepoType', description='The default repository type. Valid values:

*   `PUBLIC`: a public repository
*   `PRIVATE`: a private repository', example='PUBLIC'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.

This parameter is required.', example='namespace01'),
}

model CreateChartNamespaceResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='724402D0-75CD-4794-BC20-7D3720823AE0'),
}

model CreateChartNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateChartNamespaceResponseBody(name='body'),
}

/**
 * @summary Creates a chart namespace in an instance.
 *
 * @param request CreateChartNamespaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateChartNamespaceResponse
 */
async function createChartNamespaceWithOptions(request: CreateChartNamespaceRequest, runtime: $RuntimeOptions): CreateChartNamespaceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.autoCreateRepo)) {
    query['AutoCreateRepo'] = request.autoCreateRepo;
  }
  if (!$isNull(request.defaultRepoType)) {
    query['DefaultRepoType'] = request.defaultRepoType;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateChartNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a chart namespace in an instance.
 *
 * @param request CreateChartNamespaceRequest
 * @return CreateChartNamespaceResponse
 */
async function createChartNamespace(request: CreateChartNamespaceRequest): CreateChartNamespaceResponse {
  var runtime = new $RuntimeOptions{};
  return createChartNamespaceWithOptions(request, runtime);
}

model CreateChartRepositoryRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  repoName?: string(name='RepoName', description='The name of the repository.

This parameter is required.', example='repo01'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.

This parameter is required.', example='namespace01'),
  repoType?: string(name='RepoType', description='The default repository type. Valid values:

*   `PUBLIC`: a public repository.
*   `PRIVATE`: a private repository.

You can specify the RepoType or Summary parameter. The RepoType parameter is optional.', example='PUBLIC'),
  summary?: string(name='Summary', description='The summary of the repository.', example='summary'),
}

model CreateChartRepositoryResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  repoId?: string(name='RepoId', description='The ID of the repository.', example='crcr-2micxey5ewj4****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='60390244-A483-491A-B41D-F866C95380A1'),
}

model CreateChartRepositoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateChartRepositoryResponseBody(name='body'),
}

/**
 * @summary Creates a chart repository.
 *
 * @param request CreateChartRepositoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateChartRepositoryResponse
 */
async function createChartRepositoryWithOptions(request: CreateChartRepositoryRequest, runtime: $RuntimeOptions): CreateChartRepositoryResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!$isNull(request.repoType)) {
    query['RepoType'] = request.repoType;
  }
  if (!$isNull(request.summary)) {
    query['Summary'] = request.summary;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateChartRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a chart repository.
 *
 * @param request CreateChartRepositoryRequest
 * @return CreateChartRepositoryResponse
 */
async function createChartRepository(request: CreateChartRepositoryRequest): CreateChartRepositoryResponse {
  var runtime = new $RuntimeOptions{};
  return createChartRepositoryWithOptions(request, runtime);
}

model CreateInstanceEndpointAclPolicyRequest {
  comment?: string(name='Comment', description='The description.', example='test'),
  endpointType?: string(name='EndpointType', description='The type of the endpoint. Set the value to Internet.

This parameter is required.', example='internet'),
  entry?: string(name='Entry', description='The CIDR block that is accessible.

This parameter is required.', example='192.168.1.1/32'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  moduleName?: string(name='ModuleName', description='The name of the module that you want to access. Valid values:

*   `Registry`: the image repository.
*   `Chart`: a Helm chart.', example='Registry'),
}

model CreateInstanceEndpointAclPolicyResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='D735C5EC-4206-4F48-A090-307BF56BEB99'),
}

model CreateInstanceEndpointAclPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateInstanceEndpointAclPolicyResponseBody(name='body'),
}

/**
 * @summary Creates a whitelist policy for the public endpoint of the instance.
 *
 * @param request CreateInstanceEndpointAclPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateInstanceEndpointAclPolicyResponse
 */
async function createInstanceEndpointAclPolicyWithOptions(request: CreateInstanceEndpointAclPolicyRequest, runtime: $RuntimeOptions): CreateInstanceEndpointAclPolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!$isNull(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!$isNull(request.entry)) {
    query['Entry'] = request.entry;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateInstanceEndpointAclPolicy',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a whitelist policy for the public endpoint of the instance.
 *
 * @param request CreateInstanceEndpointAclPolicyRequest
 * @return CreateInstanceEndpointAclPolicyResponse
 */
async function createInstanceEndpointAclPolicy(request: CreateInstanceEndpointAclPolicyRequest): CreateInstanceEndpointAclPolicyResponse {
  var runtime = new $RuntimeOptions{};
  return createInstanceEndpointAclPolicyWithOptions(request, runtime);
}

model CreateInstanceVpcEndpointLinkedVpcRequest {
  enableCreateDNSRecordInPvzt?: boolean(name='EnableCreateDNSRecordInPvzt', description='Specifies whether to automatically create Alibaba Cloud DNS PrivateZone records. Valid values:

>  If you enable automatic creation of PrivateZone records, a PrivateZone record is automatically created when you associate a VPC with the instance.

*   `true`
*   `false`', example='false'),
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  moduleName?: string(name='ModuleName', description='The name of the module that you want to access. Valid values:

*   `Registry`: image repositories.
*   `Chart`: Helm charts.', example='Registry'),
  vpcId?: string(name='VpcId', description='The VPC ID.

This parameter is required.', example='vpc-uf6pa68zxnnlc48dd****'),
  vswitchId?: string(name='VswitchId', description='The ID of the vSwitch that is associated with the specified VPC.

This parameter is required.', example='vsw-uf6u0kn8x2gbzxfn2****'),
}

model CreateInstanceVpcEndpointLinkedVpcResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='D4978DCC-ECBD-40B0-A714-EE6959B22C77'),
}

model CreateInstanceVpcEndpointLinkedVpcResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateInstanceVpcEndpointLinkedVpcResponseBody(name='body'),
}

/**
 * @summary Associates a virtual private cloud (VPC) with a Container Registry instance.
 *
 * @description The VPC quota must be purchased separately.
 *
 * @param request CreateInstanceVpcEndpointLinkedVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateInstanceVpcEndpointLinkedVpcResponse
 */
async function createInstanceVpcEndpointLinkedVpcWithOptions(request: CreateInstanceVpcEndpointLinkedVpcRequest, runtime: $RuntimeOptions): CreateInstanceVpcEndpointLinkedVpcResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.enableCreateDNSRecordInPvzt)) {
    query['EnableCreateDNSRecordInPvzt'] = request.enableCreateDNSRecordInPvzt;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!$isNull(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!$isNull(request.vswitchId)) {
    query['VswitchId'] = request.vswitchId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateInstanceVpcEndpointLinkedVpc',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Associates a virtual private cloud (VPC) with a Container Registry instance.
 *
 * @description The VPC quota must be purchased separately.
 *
 * @param request CreateInstanceVpcEndpointLinkedVpcRequest
 * @return CreateInstanceVpcEndpointLinkedVpcResponse
 */
async function createInstanceVpcEndpointLinkedVpc(request: CreateInstanceVpcEndpointLinkedVpcRequest): CreateInstanceVpcEndpointLinkedVpcResponse {
  var runtime = new $RuntimeOptions{};
  return createInstanceVpcEndpointLinkedVpcWithOptions(request, runtime);
}

model CreateNamespaceRequest {
  autoCreateRepo?: boolean(name='AutoCreateRepo', description='Specifies whether to automatically create an image repository in the namespace.', example='true'),
  defaultRepoType?: string(name='DefaultRepoType', description='The default type of the repository that is automatically created. Valid values:

*   `PUBLIC`: a public repository
*   `PRIVATE`: a private repository', example='PUBLIC'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace. The name must be 2 to 120 characters in length, and can contain lowercase letters, digits, and the following delimiters: underscores (_), hyphens (-), and periods (.). The name cannot start or end with a delimiter.

This parameter is required.', example='namespace1'),
}

model CreateNamespaceResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BC648259-91A7-4502-BED3-EDF64361FA83'),
}

model CreateNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateNamespaceResponseBody(name='body'),
}

/**
 * @summary Creates a namespace of image repositories.
 *
 * @param request CreateNamespaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNamespaceResponse
 */
async function createNamespaceWithOptions(request: CreateNamespaceRequest, runtime: $RuntimeOptions): CreateNamespaceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.autoCreateRepo)) {
    query['AutoCreateRepo'] = request.autoCreateRepo;
  }
  if (!$isNull(request.defaultRepoType)) {
    query['DefaultRepoType'] = request.defaultRepoType;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a namespace of image repositories.
 *
 * @param request CreateNamespaceRequest
 * @return CreateNamespaceResponse
 */
async function createNamespace(request: CreateNamespaceRequest): CreateNamespaceResponse {
  var runtime = new $RuntimeOptions{};
  return createNamespaceWithOptions(request, runtime);
}

model CreateRepoBuildRuleRequest {
  buildArgs?: [ string ](name='BuildArgs', description='Building arguments.'),
  dockerfileLocation?: string(name='DockerfileLocation', description='The path of the Dockerfile.', example='/'),
  dockerfileName?: string(name='DockerfileName', description='The name of the Dockerfile.', example='Dockerfile'),
  imageTag?: string(name='ImageTag', description='The tag of the image.

This parameter is required.', example='v0.9.5'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  platforms?: [ string ](name='Platforms', description='Architecture for image building. Valid values:

*   `linux/amd64`
*   `linux/arm64`
*   `linux/386`
*   `linux/arm/v7`
*   `inux/arm/v6`

Default value: `linux/amd64`'),
  pushName?: string(name='PushName', description='The name of the push that triggers the building rule.

This parameter is required.', example='master'),
  pushType?: string(name='PushType', description='The type of the push that triggers the building rule. Valid values:

*   `GIT_TAG`: tag push
*   `GIT_BRANCH`: branch push

This parameter is required.', example='GIT_BRANCH'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

This parameter is required.', example='crr-8dz3aedjqlmk****'),
}

model CreateRepoBuildRuleResponseBody = {
  buildRuleId?: string(name='BuildRuleId', description='The ID of the building rule.', example='crbr-ly77w5i3t31f****'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4CE1F661-75DD-4EBD-A4AD-057B26834ABB'),
}

model CreateRepoBuildRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRepoBuildRuleResponseBody(name='body'),
}

/**
 * @summary Creates an image building rule for a repository.
 *
 * @param request CreateRepoBuildRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRepoBuildRuleResponse
 */
async function createRepoBuildRuleWithOptions(request: CreateRepoBuildRuleRequest, runtime: $RuntimeOptions): CreateRepoBuildRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.buildArgs)) {
    query['BuildArgs'] = request.buildArgs;
  }
  if (!$isNull(request.dockerfileLocation)) {
    query['DockerfileLocation'] = request.dockerfileLocation;
  }
  if (!$isNull(request.dockerfileName)) {
    query['DockerfileName'] = request.dockerfileName;
  }
  if (!$isNull(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.platforms)) {
    query['Platforms'] = request.platforms;
  }
  if (!$isNull(request.pushName)) {
    query['PushName'] = request.pushName;
  }
  if (!$isNull(request.pushType)) {
    query['PushType'] = request.pushType;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateRepoBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an image building rule for a repository.
 *
 * @param request CreateRepoBuildRuleRequest
 * @return CreateRepoBuildRuleResponse
 */
async function createRepoBuildRule(request: CreateRepoBuildRuleRequest): CreateRepoBuildRuleResponse {
  var runtime = new $RuntimeOptions{};
  return createRepoBuildRuleWithOptions(request, runtime);
}

model CreateRepoSourceCodeRepoRequest {
  autoBuild?: boolean(name='AutoBuild', description='Specifies whether to trigger image building when source code is committed. Valid values:

*   `true`: triggers image building when source code is committed.
*   `false`: does not trigger image building when source code is committed.', example='true'),
  codeRepoName?: string(name='CodeRepoName', description='The name of the source code repository.

This parameter is required.', example='repo'),
  codeRepoNamespaceName?: string(name='CodeRepoNamespaceName', description='The namespace to which the source code repository belongs.

This parameter is required.', example='namespace'),
  codeRepoType?: string(name='CodeRepoType', description='The type of the source code hosting platform. Valid values: `GITHUB`, `GITLAB`, `GITEE`, `CODE`, and `CODEUP`.

This parameter is required.', example='GITHUB'),
  disableCacheBuild?: boolean(name='DisableCacheBuild', description='Specifies whether to disable building caches. Valid values:

*   `true`: disables building caches.
*   `false`: enables building caches.', example='false'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-shac42yvqzvq****'),
  overseaBuild?: boolean(name='OverseaBuild', description='Specifies whether to enable Build With Servers Deployed Outside Chinese Mainland. Valid values:

*   `true`: enables Build With Servers Deployed Outside Chinese Mainland.
*   `false`: does not enable Build With Servers Deployed Outside Chinese Mainland.', example='false'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

This parameter is required.', example='crr-gzsrlevmvoaq****'),
}

model CreateRepoSourceCodeRepoResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4CE1F661-75DD-4EBD-A4AD-057B26834ABB'),
}

model CreateRepoSourceCodeRepoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRepoSourceCodeRepoResponseBody(name='body'),
}

/**
 * @summary Binds a source code repository to an image repository.
 *
 * @param request CreateRepoSourceCodeRepoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRepoSourceCodeRepoResponse
 */
async function createRepoSourceCodeRepoWithOptions(request: CreateRepoSourceCodeRepoRequest, runtime: $RuntimeOptions): CreateRepoSourceCodeRepoResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.autoBuild)) {
    query['AutoBuild'] = request.autoBuild;
  }
  if (!$isNull(request.codeRepoName)) {
    query['CodeRepoName'] = request.codeRepoName;
  }
  if (!$isNull(request.codeRepoNamespaceName)) {
    query['CodeRepoNamespaceName'] = request.codeRepoNamespaceName;
  }
  if (!$isNull(request.codeRepoType)) {
    query['CodeRepoType'] = request.codeRepoType;
  }
  if (!$isNull(request.disableCacheBuild)) {
    query['DisableCacheBuild'] = request.disableCacheBuild;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.overseaBuild)) {
    query['OverseaBuild'] = request.overseaBuild;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateRepoSourceCodeRepo',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Binds a source code repository to an image repository.
 *
 * @param request CreateRepoSourceCodeRepoRequest
 * @return CreateRepoSourceCodeRepoResponse
 */
async function createRepoSourceCodeRepo(request: CreateRepoSourceCodeRepoRequest): CreateRepoSourceCodeRepoResponse {
  var runtime = new $RuntimeOptions{};
  return createRepoSourceCodeRepoWithOptions(request, runtime);
}

model CreateRepoSyncRuleRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='cri-hpdfkc6utbaq****'),
  namespaceName?: string(name='NamespaceName', description='This parameter is required.', example='ns1'),
  repoName?: string(name='RepoName', example='repo1'),
  repoNameFilter?: string(name='RepoNameFilter', description='The rule that is used to filter repositories.

>  This parameter is valid only when SyncScope is set to `NAMESPACE`.', example='.*'),
  syncRuleName?: string(name='SyncRuleName', description='This parameter is required.', example='rule'),
  syncScope?: string(name='SyncScope', description='This parameter is required.', example='REPO'),
  syncTrigger?: string(name='SyncTrigger', example='PASSIVE'),
  tagFilter?: string(name='TagFilter', description='This parameter is required.', example='.*'),
  targetInstanceId?: string(name='TargetInstanceId', description='This parameter is required.', example='cri-ibxs3piklys3****'),
  targetNamespaceName?: string(name='TargetNamespaceName', description='This parameter is required.', example='ns1'),
  targetRegionId?: string(name='TargetRegionId', description='This parameter is required.', example='cn-shanghai'),
  targetRepoName?: string(name='TargetRepoName', example='repo1'),
  targetUserId?: string(name='TargetUserId', example='12645940***'),
}

model CreateRepoSyncRuleResponseBody = {
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='8F8A0BA6-7F06-4BAE-B147-10BD6A25****'),
  syncRuleId?: string(name='SyncRuleId', example='crsr-gk5p2ns1kzns****'),
}

model CreateRepoSyncRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRepoSyncRuleResponseBody(name='body'),
}

/**
 * @summary Creates an image synchronization rule for an image repository.
 *
 * @param request CreateRepoSyncRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRepoSyncRuleResponse
 */
async function createRepoSyncRuleWithOptions(request: CreateRepoSyncRuleRequest, runtime: $RuntimeOptions): CreateRepoSyncRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNameFilter)) {
    query['RepoNameFilter'] = request.repoNameFilter;
  }
  if (!$isNull(request.syncRuleName)) {
    query['SyncRuleName'] = request.syncRuleName;
  }
  if (!$isNull(request.syncScope)) {
    query['SyncScope'] = request.syncScope;
  }
  if (!$isNull(request.syncTrigger)) {
    query['SyncTrigger'] = request.syncTrigger;
  }
  if (!$isNull(request.tagFilter)) {
    query['TagFilter'] = request.tagFilter;
  }
  if (!$isNull(request.targetInstanceId)) {
    query['TargetInstanceId'] = request.targetInstanceId;
  }
  if (!$isNull(request.targetNamespaceName)) {
    query['TargetNamespaceName'] = request.targetNamespaceName;
  }
  if (!$isNull(request.targetRegionId)) {
    query['TargetRegionId'] = request.targetRegionId;
  }
  if (!$isNull(request.targetRepoName)) {
    query['TargetRepoName'] = request.targetRepoName;
  }
  if (!$isNull(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateRepoSyncRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an image synchronization rule for an image repository.
 *
 * @param request CreateRepoSyncRuleRequest
 * @return CreateRepoSyncRuleResponse
 */
async function createRepoSyncRule(request: CreateRepoSyncRuleRequest): CreateRepoSyncRuleResponse {
  var runtime = new $RuntimeOptions{};
  return createRepoSyncRuleWithOptions(request, runtime);
}

model CreateRepoSyncTaskRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='cri-hpdfkc6utbaq****'),
  override?: boolean(name='Override', example='true'),
  repoId?: string(name='RepoId', description='This parameter is required.', example='crr-iql7jalx4g0****'),
  tag?: string(name='Tag', description='This parameter is required.', example='tag1'),
  targetInstanceId?: string(name='TargetInstanceId', description='This parameter is required.', example='cri-ibxs3piklys3****'),
  targetNamespace?: string(name='TargetNamespace', description='This parameter is required.', example='ns1'),
  targetRegionId?: string(name='TargetRegionId', description='This parameter is required.', example='cn-hangzhou'),
  targetRepoName?: string(name='TargetRepoName', description='This parameter is required.', example='repo1'),
  targetTag?: string(name='TargetTag', description='This parameter is required.', example='tag1'),
  targetUserId?: string(name='TargetUserId', example='12345***'),
}

model CreateRepoSyncTaskResponseBody = {
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='8F8A0BA6-7F06-4BAE-B147-10BD6A25****'),
  syncTaskId?: string(name='SyncTaskId', example='rst-gbch330f0c****'),
}

model CreateRepoSyncTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRepoSyncTaskResponseBody(name='body'),
}

/**
 * @param request CreateRepoSyncTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRepoSyncTaskResponse
 */
async function createRepoSyncTaskWithOptions(request: CreateRepoSyncTaskRequest, runtime: $RuntimeOptions): CreateRepoSyncTaskResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.override)) {
    query['Override'] = request.override;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!$isNull(request.targetInstanceId)) {
    query['TargetInstanceId'] = request.targetInstanceId;
  }
  if (!$isNull(request.targetNamespace)) {
    query['TargetNamespace'] = request.targetNamespace;
  }
  if (!$isNull(request.targetRegionId)) {
    query['TargetRegionId'] = request.targetRegionId;
  }
  if (!$isNull(request.targetRepoName)) {
    query['TargetRepoName'] = request.targetRepoName;
  }
  if (!$isNull(request.targetTag)) {
    query['TargetTag'] = request.targetTag;
  }
  if (!$isNull(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateRepoSyncTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request CreateRepoSyncTaskRequest
 * @return CreateRepoSyncTaskResponse
 */
async function createRepoSyncTask(request: CreateRepoSyncTaskRequest): CreateRepoSyncTaskResponse {
  var runtime = new $RuntimeOptions{};
  return createRepoSyncTaskWithOptions(request, runtime);
}

model CreateRepoSyncTaskByRuleRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-hpdfkc6utbaq****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

This parameter is required.', example='crr-hnoq7j93or3k****'),
  syncRuleId?: string(name='SyncRuleId', description='The ID of the synchronization rule.

This parameter is required.', example='crsr-o8n4dijbumgq****'),
  tag?: string(name='Tag', description='The version of the image to be synchronized.

This parameter is required.', example='1.24'),
}

model CreateRepoSyncTaskByRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='17A4C658-AE8F-4A08-821F-EDCB5FC74EE8'),
  syncTaskId?: string(name='SyncTaskId', description='The ID of the synchronization task.', example='rst-biu4u4pm4it5****'),
}

model CreateRepoSyncTaskByRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRepoSyncTaskByRuleResponseBody(name='body'),
}

/**
 * @summary Creates an image replication task based on a manual replication rule.
 *
 * @param request CreateRepoSyncTaskByRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRepoSyncTaskByRuleResponse
 */
async function createRepoSyncTaskByRuleWithOptions(request: CreateRepoSyncTaskByRuleRequest, runtime: $RuntimeOptions): CreateRepoSyncTaskByRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!$isNull(request.syncRuleId)) {
    query['SyncRuleId'] = request.syncRuleId;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateRepoSyncTaskByRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an image replication task based on a manual replication rule.
 *
 * @param request CreateRepoSyncTaskByRuleRequest
 * @return CreateRepoSyncTaskByRuleResponse
 */
async function createRepoSyncTaskByRule(request: CreateRepoSyncTaskByRuleRequest): CreateRepoSyncTaskByRuleResponse {
  var runtime = new $RuntimeOptions{};
  return createRepoSyncTaskByRuleWithOptions(request, runtime);
}

model CreateRepoTagRequest {
  fromTag?: string(name='FromTag', description='The source image tag.

This parameter is required.', example='v1'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-shac42yvqzv****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.

This parameter is required.', example='ns'),
  repoName?: string(name='RepoName', description='The name of the image repository.

This parameter is required.', example='repo1'),
  toTag?: string(name='ToTag', description='The image tag that you want to create.

This parameter is required.', example='v2'),
}

model CreateRepoTagResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C4C7DD0C-C9D6-437A-A7EE-8BY*****'),
}

model CreateRepoTagResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRepoTagResponseBody(name='body'),
}

/**
 * @summary Creates an image tag based on an existing image tag in an image repository.
 *
 * @param request CreateRepoTagRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRepoTagResponse
 */
async function createRepoTagWithOptions(request: CreateRepoTagRequest, runtime: $RuntimeOptions): CreateRepoTagResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fromTag)) {
    query['FromTag'] = request.fromTag;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.toTag)) {
    query['ToTag'] = request.toTag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateRepoTag',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an image tag based on an existing image tag in an image repository.
 *
 * @param request CreateRepoTagRequest
 * @return CreateRepoTagResponse
 */
async function createRepoTag(request: CreateRepoTagRequest): CreateRepoTagResponse {
  var runtime = new $RuntimeOptions{};
  return createRepoTagWithOptions(request, runtime);
}

model CreateRepoTagScanTaskRequest {
  digest?: string(name='Digest', description='The digest of the image.', example='sha256:815386ebbe9a3490f38785ab11bda34ec8dacf4634af77b8912832d4f85dca04'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

This parameter is required.', example='crr-xwvi3osiy4ff****'),
  scanService?: string(name='ScanService', description='The type of the scanning engine.

*   `SAS_SCAN_SERVICE`: Security Center scan engine (paid service)
*   `ACR_SCAN_SERVICE`: Container Registry scan engine', example='ACR_SCAN_SERVICE'),
  tag?: string(name='Tag', description='The version of the image.

This parameter is required.', example='1.24'),
}

model CreateRepoTagScanTaskResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BC648259-91A7-4502-BED3-EDF64361FA83'),
}

model CreateRepoTagScanTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRepoTagScanTaskResponseBody(name='body'),
}

/**
 * @param request CreateRepoTagScanTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRepoTagScanTaskResponse
 */
async function createRepoTagScanTaskWithOptions(request: CreateRepoTagScanTaskRequest, runtime: $RuntimeOptions): CreateRepoTagScanTaskResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!$isNull(request.scanService)) {
    query['ScanService'] = request.scanService;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateRepoTagScanTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request CreateRepoTagScanTaskRequest
 * @return CreateRepoTagScanTaskResponse
 */
async function createRepoTagScanTask(request: CreateRepoTagScanTaskRequest): CreateRepoTagScanTaskResponse {
  var runtime = new $RuntimeOptions{};
  return createRepoTagScanTaskWithOptions(request, runtime);
}

model CreateRepoTriggerRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

This parameter is required.', example='crr-xwvi3osiy4ff****'),
  triggerName?: string(name='TriggerName', description='The name of the trigger.

This parameter is required.', example='trigger1'),
  triggerTag?: string(name='TriggerTag', description='The image tag based on which the trigger is set.

> 

*   If `TriggerType` is set to `ALL`, `TriggerTag` can be set to a string or an array, for example, `*`.

*   If `TriggerType` is set to `TAG_LIST`, `TriggerTag` must be set to an array, for example, `[1]`.
*   If `TriggerType` is set to `TAG_REG_EXP`, `TriggerTag` must be set to a string, for example, `*`.', example='[1]'),
  triggerType?: string(name='TriggerType', description='The type of the trigger. Valid values:

*   `ALL`: a trigger that supports both tags and regular expressions.
*   `TAG_LIST`: a tag-based trigger.
*   `TAG_REG_EXP`: a regular expression-based trigger.

This parameter is required.', example='ALL'),
  triggerUrl?: string(name='TriggerUrl', description='The URL of the trigger.

This parameter is required.', example='http://www.mysite.com'),
}

model CreateRepoTriggerResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B79F5E0E-8770-407D-BCB6-ECF4BA9C****'),
  triggerId?: string(name='TriggerId', description='The ID of the trigger.', example='crw-0z4pf81pgz35****'),
}

model CreateRepoTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRepoTriggerResponseBody(name='body'),
}

/**
 * @summary Creates a trigger for a repository.
 *
 * @param request CreateRepoTriggerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRepoTriggerResponse
 */
async function createRepoTriggerWithOptions(request: CreateRepoTriggerRequest, runtime: $RuntimeOptions): CreateRepoTriggerResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!$isNull(request.triggerName)) {
    query['TriggerName'] = request.triggerName;
  }
  if (!$isNull(request.triggerTag)) {
    query['TriggerTag'] = request.triggerTag;
  }
  if (!$isNull(request.triggerType)) {
    query['TriggerType'] = request.triggerType;
  }
  if (!$isNull(request.triggerUrl)) {
    query['TriggerUrl'] = request.triggerUrl;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateRepoTrigger',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a trigger for a repository.
 *
 * @param request CreateRepoTriggerRequest
 * @return CreateRepoTriggerResponse
 */
async function createRepoTrigger(request: CreateRepoTriggerRequest): CreateRepoTriggerResponse {
  var runtime = new $RuntimeOptions{};
  return createRepoTriggerWithOptions(request, runtime);
}

model CreateRepositoryRequest {
  detail?: string(name='Detail', description='The description of the repository.', example='repo1'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  repoName?: string(name='RepoName', description='The name of the image repository.

This parameter is required.', example='repo1'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the image repository belongs.

This parameter is required.', example='namespace01'),
  repoType?: string(name='RepoType', description='The type of the repository. Valid values:

*   `PUBLIC`: The repository is a public repository.
*   `PRIVATE`: The repository is a private repository.

This parameter is required.', example='PRIVATE'),
  summary?: string(name='Summary', description='The summary about the repository.

This parameter is required.', example='repo1'),
  tagImmutability?: boolean(name='TagImmutability', description='Specifies whether to enable the feature of image tag immutability. Valid values:

*   `true`: enables the feature of image tag immutability.
*   `false`: disables the feature of image tag immutability.', example='true'),
}

model CreateRepositoryResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-xwvi3osiy4ff****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='886FB272-15C3-44FC-AA54-F4ABD5B93A28'),
}

model CreateRepositoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRepositoryResponseBody(name='body'),
}

/**
 * @summary Creates an image repository.
 *
 * @param request CreateRepositoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRepositoryResponse
 */
async function createRepositoryWithOptions(request: CreateRepositoryRequest, runtime: $RuntimeOptions): CreateRepositoryResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.detail)) {
    query['Detail'] = request.detail;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!$isNull(request.repoType)) {
    query['RepoType'] = request.repoType;
  }
  if (!$isNull(request.summary)) {
    query['Summary'] = request.summary;
  }
  if (!$isNull(request.tagImmutability)) {
    query['TagImmutability'] = request.tagImmutability;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an image repository.
 *
 * @param request CreateRepositoryRequest
 * @return CreateRepositoryResponse
 */
async function createRepository(request: CreateRepositoryRequest): CreateRepositoryResponse {
  var runtime = new $RuntimeOptions{};
  return createRepositoryWithOptions(request, runtime);
}

model DeleteArtifactLifecycleRuleRequest {
  instanceId?: string(name='InstanceId', description='The ID of the Container Registry instance.

This parameter is required.', example='cri-brlg4cbj2ylkrqqq'),
  ruleId?: string(name='RuleId', description='The rule ID.

This parameter is required.', example='cralr-3v8pao9k7chb8q62'),
}

model DeleteArtifactLifecycleRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='True'),
  requestId?: string(name='RequestId', description='The request ID.', example='001AB638-C99B-5A27-8AC9-B2DBABFFEBB5'),
}

model DeleteArtifactLifecycleRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteArtifactLifecycleRuleResponseBody(name='body'),
}

/**
 * @summary Deletes an artifact lifecycle management rule.
 *
 * @param request DeleteArtifactLifecycleRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteArtifactLifecycleRuleResponse
 */
async function deleteArtifactLifecycleRuleWithOptions(request: DeleteArtifactLifecycleRuleRequest, runtime: $RuntimeOptions): DeleteArtifactLifecycleRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteArtifactLifecycleRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes an artifact lifecycle management rule.
 *
 * @param request DeleteArtifactLifecycleRuleRequest
 * @return DeleteArtifactLifecycleRuleResponse
 */
async function deleteArtifactLifecycleRule(request: DeleteArtifactLifecycleRuleRequest): DeleteArtifactLifecycleRuleResponse {
  var runtime = new $RuntimeOptions{};
  return deleteArtifactLifecycleRuleWithOptions(request, runtime);
}

model DeleteArtifactSubscriptionRuleRequest {
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-c0o11woew0k****'),
  ruleId?: string(name='RuleId', description='The rule ID.

This parameter is required.', example='crasr-mdbpung4i1rm****'),
}

model DeleteArtifactSubscriptionRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='02B27D80-FD32-5155-931A-93700779BB9E'),
}

model DeleteArtifactSubscriptionRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteArtifactSubscriptionRuleResponseBody(name='body'),
}

/**
 * @summary Deletes an artifact subscription rule.
 *
 * @param request DeleteArtifactSubscriptionRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteArtifactSubscriptionRuleResponse
 */
async function deleteArtifactSubscriptionRuleWithOptions(request: DeleteArtifactSubscriptionRuleRequest, runtime: $RuntimeOptions): DeleteArtifactSubscriptionRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteArtifactSubscriptionRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes an artifact subscription rule.
 *
 * @param request DeleteArtifactSubscriptionRuleRequest
 * @return DeleteArtifactSubscriptionRuleResponse
 */
async function deleteArtifactSubscriptionRule(request: DeleteArtifactSubscriptionRuleRequest): DeleteArtifactSubscriptionRuleResponse {
  var runtime = new $RuntimeOptions{};
  return deleteArtifactSubscriptionRuleWithOptions(request, runtime);
}

model DeleteChainRequest {
  chainId?: string(name='ChainId', description='The ID of the delivery pipeline.

This parameter is required.', example='chi-02ymhtwl3cq8****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-4cdrlqmhn4gm****'),
}

model DeleteChainResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='DB1809A8-E1C8-5707-BAF8-D4FC1C11****'),
}

model DeleteChainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteChainResponseBody(name='body'),
}

/**
 * @summary Deletes a delivery pipeline.
 *
 * @param request DeleteChainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteChainResponse
 */
async function deleteChainWithOptions(request: DeleteChainRequest, runtime: $RuntimeOptions): DeleteChainResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.chainId)) {
    query['ChainId'] = request.chainId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteChain',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a delivery pipeline.
 *
 * @param request DeleteChainRequest
 * @return DeleteChainResponse
 */
async function deleteChain(request: DeleteChainRequest): DeleteChainResponse {
  var runtime = new $RuntimeOptions{};
  return deleteChainWithOptions(request, runtime);
}

model DeleteChartNamespaceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  namespaceName?: string(name='NamespaceName', description='The name of the chart namespace that you want to delete.

This parameter is required.', example='ns2'),
}

model DeleteChartNamespaceResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='FEC62DF1-1394-467F-A69F-4BC1BA29F383'),
}

model DeleteChartNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteChartNamespaceResponseBody(name='body'),
}

/**
 * @summary Deletes a chart namespace from an instance.
 *
 * @description >  If you delete a chart namespace, all repositories in the namespace and the charts in all repositories are deleted.
 *
 * @param request DeleteChartNamespaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteChartNamespaceResponse
 */
async function deleteChartNamespaceWithOptions(request: DeleteChartNamespaceRequest, runtime: $RuntimeOptions): DeleteChartNamespaceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteChartNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a chart namespace from an instance.
 *
 * @description >  If you delete a chart namespace, all repositories in the namespace and the charts in all repositories are deleted.
 *
 * @param request DeleteChartNamespaceRequest
 * @return DeleteChartNamespaceResponse
 */
async function deleteChartNamespace(request: DeleteChartNamespaceRequest): DeleteChartNamespaceResponse {
  var runtime = new $RuntimeOptions{};
  return deleteChartNamespaceWithOptions(request, runtime);
}

model DeleteChartReleaseRequest {
  chart?: string(name='Chart', description='The name of the chart.

This parameter is required.', example='chart3'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  release?: string(name='Release', description='The version of the chart that you want to delete.

This parameter is required.', example='0.1.0'),
  repoName?: string(name='RepoName', description='The name of the repository.

This parameter is required.', example='repo1'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.

This parameter is required.', example='ns1'),
}

model DeleteChartReleaseResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C2D6CE47-6DEF-45F4-A1AC-90F3AFBA751F'),
}

model DeleteChartReleaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteChartReleaseResponseBody(name='body'),
}

/**
 * @summary Deletes a chart version from a chart repository.
 *
 * @param request DeleteChartReleaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteChartReleaseResponse
 */
async function deleteChartReleaseWithOptions(request: DeleteChartReleaseRequest, runtime: $RuntimeOptions): DeleteChartReleaseResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.chart)) {
    query['Chart'] = request.chart;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.release)) {
    query['Release'] = request.release;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteChartRelease',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a chart version from a chart repository.
 *
 * @param request DeleteChartReleaseRequest
 * @return DeleteChartReleaseResponse
 */
async function deleteChartRelease(request: DeleteChartReleaseRequest): DeleteChartReleaseResponse {
  var runtime = new $RuntimeOptions{};
  return deleteChartReleaseWithOptions(request, runtime);
}

model DeleteChartRepositoryRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay****'),
  repoName?: string(name='RepoName', description='The name of the repository.

This parameter is required.', example='repo01'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.

This parameter is required.', example='namespace01'),
}

model DeleteChartRepositoryResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='12589EF7-96E2-4554-AAD7-F7209E88CAD3'),
}

model DeleteChartRepositoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteChartRepositoryResponseBody(name='body'),
}

/**
 * @summary Deletes a chart repository from an instance.
 *
 * @param request DeleteChartRepositoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteChartRepositoryResponse
 */
async function deleteChartRepositoryWithOptions(request: DeleteChartRepositoryRequest, runtime: $RuntimeOptions): DeleteChartRepositoryResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteChartRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a chart repository from an instance.
 *
 * @param request DeleteChartRepositoryRequest
 * @return DeleteChartRepositoryResponse
 */
async function deleteChartRepository(request: DeleteChartRepositoryRequest): DeleteChartRepositoryResponse {
  var runtime = new $RuntimeOptions{};
  return deleteChartRepositoryWithOptions(request, runtime);
}

model DeleteEventCenterRuleRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  ruleId?: string(name='RuleId', description='The ID of the event notification rule.', example='crecr-n6pbhgjx*****'),
}

model DeleteEventCenterRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='031572FA-7D8F-4C05-B790-1071E0E05DE6'),
}

model DeleteEventCenterRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEventCenterRuleResponseBody(name='body'),
}

/**
 * @summary Deletes an event notification rule.
 *
 * @param request DeleteEventCenterRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEventCenterRuleResponse
 */
async function deleteEventCenterRuleWithOptions(request: DeleteEventCenterRuleRequest, runtime: $RuntimeOptions): DeleteEventCenterRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteEventCenterRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes an event notification rule.
 *
 * @param request DeleteEventCenterRuleRequest
 * @return DeleteEventCenterRuleResponse
 */
async function deleteEventCenterRule(request: DeleteEventCenterRuleRequest): DeleteEventCenterRuleResponse {
  var runtime = new $RuntimeOptions{};
  return deleteEventCenterRuleWithOptions(request, runtime);
}

model DeleteInstanceEndpointAclPolicyRequest {
  endpointType?: string(name='EndpointType', description='The type of the endpoint. Set the value to Internet.

This parameter is required.', example='internet'),
  entry?: string(name='Entry', description='The CIDR block.

This parameter is required.', example='127.0.0.1/32'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  moduleName?: string(name='ModuleName', description='The name of the module that you want to access. Valid values:

*   `Registry`: the image repository.
*   `Chart`: a Helm chart.', example='Chart'),
}

model DeleteInstanceEndpointAclPolicyResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BDB1F145-F0FF-44E9-AADF-A678642A7C7D'),
}

model DeleteInstanceEndpointAclPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteInstanceEndpointAclPolicyResponseBody(name='body'),
}

/**
 * @summary Deletes a whitelist policy for the public endpoint of an instance.
 *
 * @param request DeleteInstanceEndpointAclPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteInstanceEndpointAclPolicyResponse
 */
async function deleteInstanceEndpointAclPolicyWithOptions(request: DeleteInstanceEndpointAclPolicyRequest, runtime: $RuntimeOptions): DeleteInstanceEndpointAclPolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!$isNull(request.entry)) {
    query['Entry'] = request.entry;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteInstanceEndpointAclPolicy',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a whitelist policy for the public endpoint of an instance.
 *
 * @param request DeleteInstanceEndpointAclPolicyRequest
 * @return DeleteInstanceEndpointAclPolicyResponse
 */
async function deleteInstanceEndpointAclPolicy(request: DeleteInstanceEndpointAclPolicyRequest): DeleteInstanceEndpointAclPolicyResponse {
  var runtime = new $RuntimeOptions{};
  return deleteInstanceEndpointAclPolicyWithOptions(request, runtime);
}

model DeleteInstanceVpcEndpointLinkedVpcRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  moduleName?: string(name='ModuleName', description='The name of the module that you want to access. Valid values:

*   `Registry`: the image repository.
*   `Chart`: a Helm chart.', example='Chart'),
  vpcId?: string(name='VpcId', description='The ID of the VPC.

This parameter is required.', example='vpc-uf6pa68zxnnlc48dd****'),
  vswitchId?: string(name='VswitchId', description='The ID of the vSwitch.

This parameter is required.', example='vpc-uf6pa68zxnnlc48dd****'),
}

model DeleteInstanceVpcEndpointLinkedVpcResponseBody = {
  code?: string(name='Code', description='The return value.', example='true'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='20FE7A66-0044-4E23-BBEC-C434EADBD7AF'),
}

model DeleteInstanceVpcEndpointLinkedVpcResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteInstanceVpcEndpointLinkedVpcResponseBody(name='body'),
}

/**
 * @summary Disassociates a virtual private cloud (VPC) from an instance.
 *
 * @param request DeleteInstanceVpcEndpointLinkedVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteInstanceVpcEndpointLinkedVpcResponse
 */
async function deleteInstanceVpcEndpointLinkedVpcWithOptions(request: DeleteInstanceVpcEndpointLinkedVpcRequest, runtime: $RuntimeOptions): DeleteInstanceVpcEndpointLinkedVpcResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!$isNull(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!$isNull(request.vswitchId)) {
    query['VswitchId'] = request.vswitchId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteInstanceVpcEndpointLinkedVpc',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Disassociates a virtual private cloud (VPC) from an instance.
 *
 * @param request DeleteInstanceVpcEndpointLinkedVpcRequest
 * @return DeleteInstanceVpcEndpointLinkedVpcResponse
 */
async function deleteInstanceVpcEndpointLinkedVpc(request: DeleteInstanceVpcEndpointLinkedVpcRequest): DeleteInstanceVpcEndpointLinkedVpcResponse {
  var runtime = new $RuntimeOptions{};
  return deleteInstanceVpcEndpointLinkedVpcWithOptions(request, runtime);
}

model DeleteNamespaceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.

This parameter is required.', example='ns3'),
}

model DeleteNamespaceResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BA08C185-8F76-48D7-ACB3-BA11BF2778F9'),
}

model DeleteNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteNamespaceResponseBody(name='body'),
}

/**
 * @summary Deletes a namespace.
 *
 * @description > After you delete a namespace, all repositories in the namespace and all images in these repositories are deleted as well.
 *
 * @param request DeleteNamespaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNamespaceResponse
 */
async function deleteNamespaceWithOptions(request: DeleteNamespaceRequest, runtime: $RuntimeOptions): DeleteNamespaceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a namespace.
 *
 * @description > After you delete a namespace, all repositories in the namespace and all images in these repositories are deleted as well.
 *
 * @param request DeleteNamespaceRequest
 * @return DeleteNamespaceResponse
 */
async function deleteNamespace(request: DeleteNamespaceRequest): DeleteNamespaceResponse {
  var runtime = new $RuntimeOptions{};
  return deleteNamespaceWithOptions(request, runtime);
}

model DeleteRepoBuildRuleRequest {
  buildRuleId?: string(name='BuildRuleId', description='The ID of the image building rule.

This parameter is required.', example='crbr-36tffn0kouvi****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

This parameter is required.', example='crr-xwvi3osiy4ff****'),
}

model DeleteRepoBuildRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2E3F55BF-FA7B-454E-B2C6-85265E243ADC'),
}

model DeleteRepoBuildRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRepoBuildRuleResponseBody(name='body'),
}

/**
 * @summary Deletes an image building rule of a repository.
 *
 * @param request DeleteRepoBuildRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRepoBuildRuleResponse
 */
async function deleteRepoBuildRuleWithOptions(request: DeleteRepoBuildRuleRequest, runtime: $RuntimeOptions): DeleteRepoBuildRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.buildRuleId)) {
    query['BuildRuleId'] = request.buildRuleId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteRepoBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes an image building rule of a repository.
 *
 * @param request DeleteRepoBuildRuleRequest
 * @return DeleteRepoBuildRuleResponse
 */
async function deleteRepoBuildRule(request: DeleteRepoBuildRuleRequest): DeleteRepoBuildRuleResponse {
  var runtime = new $RuntimeOptions{};
  return deleteRepoBuildRuleWithOptions(request, runtime);
}

model DeleteRepoSyncRuleRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-hpdfkc6utbaq****'),
  syncRuleId?: string(name='SyncRuleId', description='The ID of the synchronization rule.

This parameter is required.', example='crsr-gk5p2ns1kzns****'),
}

model DeleteRepoSyncRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='72DD4198-1BB9-47A3-BC01-EAD1A6D5E173'),
}

model DeleteRepoSyncRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRepoSyncRuleResponseBody(name='body'),
}

/**
 * @summary Deletes an image replication rule of an image repository.
 *
 * @param request DeleteRepoSyncRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRepoSyncRuleResponse
 */
async function deleteRepoSyncRuleWithOptions(request: DeleteRepoSyncRuleRequest, runtime: $RuntimeOptions): DeleteRepoSyncRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.syncRuleId)) {
    query['SyncRuleId'] = request.syncRuleId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteRepoSyncRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes an image replication rule of an image repository.
 *
 * @param request DeleteRepoSyncRuleRequest
 * @return DeleteRepoSyncRuleResponse
 */
async function deleteRepoSyncRule(request: DeleteRepoSyncRuleRequest): DeleteRepoSyncRuleResponse {
  var runtime = new $RuntimeOptions{};
  return deleteRepoSyncRuleWithOptions(request, runtime);
}

model DeleteRepoTagRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

This parameter is required.', example='crr-xwvi3osiy4ff****'),
  tag?: string(name='Tag', description='The tag of the image.

This parameter is required.', example='1.24'),
}

model DeleteRepoTagResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='96E66B3A-C81A-48BE-ACD6-C0AB1F9313C0'),
}

model DeleteRepoTagResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRepoTagResponseBody(name='body'),
}

/**
 * @summary Deletes an image tag.
 *
 * @param request DeleteRepoTagRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRepoTagResponse
 */
async function deleteRepoTagWithOptions(request: DeleteRepoTagRequest, runtime: $RuntimeOptions): DeleteRepoTagResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteRepoTag',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes an image tag.
 *
 * @param request DeleteRepoTagRequest
 * @return DeleteRepoTagResponse
 */
async function deleteRepoTag(request: DeleteRepoTagRequest): DeleteRepoTagResponse {
  var runtime = new $RuntimeOptions{};
  return deleteRepoTagWithOptions(request, runtime);
}

model DeleteRepoTriggerRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

This parameter is required.', example='crr-xwvi3osiy4ff****'),
  triggerId?: string(name='TriggerId', description='The ID of the trigger.

This parameter is required.', example='crw-0z4pf81pgz35****'),
}

model DeleteRepoTriggerResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='85180AE4-9A57-48F8-9EF9-68ECCE54B552'),
}

model DeleteRepoTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRepoTriggerResponseBody(name='body'),
}

/**
 * @summary Deletes a trigger of an image repository.
 *
 * @param request DeleteRepoTriggerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRepoTriggerResponse
 */
async function deleteRepoTriggerWithOptions(request: DeleteRepoTriggerRequest, runtime: $RuntimeOptions): DeleteRepoTriggerResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!$isNull(request.triggerId)) {
    query['TriggerId'] = request.triggerId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteRepoTrigger',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a trigger of an image repository.
 *
 * @param request DeleteRepoTriggerRequest
 * @return DeleteRepoTriggerResponse
 */
async function deleteRepoTrigger(request: DeleteRepoTriggerRequest): DeleteRepoTriggerResponse {
  var runtime = new $RuntimeOptions{};
  return deleteRepoTriggerWithOptions(request, runtime);
}

model DeleteRepositoryRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-l4933wbcmun2****'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='test-repo'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.', example='test-namespace'),
}

model DeleteRepositoryResponseBody = {
  code?: string(name='Code', description='Return values', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='47DD9D56-09A0-4C52-B520-C3805DBAB96B'),
}

model DeleteRepositoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRepositoryResponseBody(name='body'),
}

/**
 * @summary Deletes an image repository.
 *
 * @description If you delete a repository, all images in the repository are also deleted.
 *
 * @param request DeleteRepositoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRepositoryResponse
 */
async function deleteRepositoryWithOptions(request: DeleteRepositoryRequest, runtime: $RuntimeOptions): DeleteRepositoryResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes an image repository.
 *
 * @description If you delete a repository, all images in the repository are also deleted.
 *
 * @param request DeleteRepositoryRequest
 * @return DeleteRepositoryResponse
 */
async function deleteRepository(request: DeleteRepositoryRequest): DeleteRepositoryResponse {
  var runtime = new $RuntimeOptions{};
  return deleteRepositoryWithOptions(request, runtime);
}

model GetArtifactBuildRuleRequest {
  artifactType?: string(name='ArtifactType', example='ACCELERATED_IMAGE'),
  buildRuleId?: string(name='BuildRuleId', example='crabr-o2670wqz2n70****'),
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='cri-xkx6vujuhay0****'),
  scopeId?: string(name='ScopeId', example='crr-8dz3aedjqlmk****'),
  scopeType?: string(name='ScopeType', example='REPOSITORY'),
}

model GetArtifactBuildRuleResponseBody = {
  artifactType?: string(name='ArtifactType', example='ACCELERATED_IMAGE'),
  buildRuleId?: string(name='BuildRuleId', example='crabr-o2670wqz2n70****'),
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  parameters?: {
    imageIndexOnly?: boolean(name='ImageIndexOnly'),
    priorityFile?: string(name='PriorityFile'),
  }(name='Parameters'),
  requestId?: string(name='RequestId', example='7A3E98F6-296C-54AC-A612-B75E7777D4C1'),
  scopeId?: string(name='ScopeId', example='crr-8dz3aedjqlmk****'),
  scopeType?: string(name='ScopeType', example='REPOSITORY'),
}

model GetArtifactBuildRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetArtifactBuildRuleResponseBody(name='body'),
}

/**
 * @param request GetArtifactBuildRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetArtifactBuildRuleResponse
 */
async function getArtifactBuildRuleWithOptions(request: GetArtifactBuildRuleRequest, runtime: $RuntimeOptions): GetArtifactBuildRuleResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetArtifactBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetArtifactBuildRuleRequest
 * @return GetArtifactBuildRuleResponse
 */
async function getArtifactBuildRule(request: GetArtifactBuildRuleRequest): GetArtifactBuildRuleResponse {
  var runtime = new $RuntimeOptions{};
  return getArtifactBuildRuleWithOptions(request, runtime);
}

model GetArtifactBuildTaskRequest {
  buildTaskId?: string(name='BuildTaskId', description='The ID of the artifact building task.

This parameter is required.', example='i2a-1yu****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-shac42yvqzvq****'),
}

model GetArtifactBuildTaskResponseBody = {
  artifactBuildType?: string(name='ArtifactBuildType', description='The type of the artifact building task. Valid values:

*   `IMAGE_TO_ACCELERATED_IMAGE`: builds accelerated images for Container Service for Kubernetes (ACK) clusters.
*   `IMAGE_TO_ECI_ACCELERATED_IMAGE`: builds accelerated images for elastic container instances.', example='IMAGE_TO_ACCELERATED_IMAGE'),
  buildTaskId?: string(name='BuildTaskId', description='The ID of the artifact building task.', example='i2a-1yu****'),
  code?: string(name='Code', description='The return value.', example='success'),
  endTime?: int32(name='EndTime', description='The time when the artifact building task ends.', example='156871880'),
  instructions?: [ string ](name='Instructions'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C4C7DD0C-C9D6-437A-A7EE-121EFD70D002'),
  sourceArtifact?: {
    artifactType?: string(name='ArtifactType', description='The type of the artifact that is built in the task. The value can only be IMAGE.', example='IMAGE'),
    repoId?: string(name='RepoId', description='The ID of the repository to which the source artifact belongs. The repository can only be an image repository.', example='cri-shac42yvqzvq****'),
    version?: string(name='Version', description='The version of the artifact. The artifact can only be an image.', example='latest'),
  }(name='SourceArtifact', description='The information about the source artifact.'),
  startTime?: int32(name='StartTime', description='The time when the artifact building task starts.', example='156871881'),
  targetArtifact?: {
    artifactType?: string(name='ArtifactType', description='The type of the artifact that is built in the task. The value can only be IMAGE.', example='IMAGE'),
    repoId?: string(name='RepoId', description='The ID of the repository to which the artifact that is built in the task belongs. The repository can only be an image repository. The value is the same as the ID of the repository to which the source artifact belongs.', example='crr-1234567'),
    version?: string(name='Version', description='The version of the artifact that is built in the task. The artifact can only be an image.', example='latest_accelerated'),
  }(name='TargetArtifact', description='The artifact that is built in the task.'),
  taskStatus?: string(name='TaskStatus', description='The status of the artifact that is built in the task. Valid values:

*   `PENDING`: The artifact is being scheduled.
*   `BUILDING`: The artifact is being built.
*   `SUCCESS`: The artifact is built.
*   `FAILED`: The artifact fails to be built.', example='BUILDING'),
}

model GetArtifactBuildTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetArtifactBuildTaskResponseBody(name='body'),
}

/**
 * @summary Queries the details of an artifact building task.
 *
 * @param request GetArtifactBuildTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetArtifactBuildTaskResponse
 */
async function getArtifactBuildTaskWithOptions(request: GetArtifactBuildTaskRequest, runtime: $RuntimeOptions): GetArtifactBuildTaskResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetArtifactBuildTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of an artifact building task.
 *
 * @param request GetArtifactBuildTaskRequest
 * @return GetArtifactBuildTaskResponse
 */
async function getArtifactBuildTask(request: GetArtifactBuildTaskRequest): GetArtifactBuildTaskResponse {
  var runtime = new $RuntimeOptions{};
  return getArtifactBuildTaskWithOptions(request, runtime);
}

model GetArtifactLifecycleRuleRequest {
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-hpdfkc6utbaq****'),
  ruleId?: string(name='RuleId', description='The rule ID.

This parameter is required.', example='cralr-a18bkiajy81****'),
}

model GetArtifactLifecycleRuleResponseBody = {
  auto?: boolean(name='Auto', description='Indicates whether the lifecycle management rule is automatically executed.', example='true'),
  code?: string(name='Code', description='The return value.', example='success'),
  createTime?: long(name='CreateTime', description='The time when the lifecycle management rule was created.', example='1571926439000'),
  enableDeleteTag?: boolean(name='EnableDeleteTag', description='Indicates whether lifecycle management is enabled for the artifact.', example='true'),
  instanceId?: string(name='InstanceId', description='The instance ID.', example='cri-xkx6vujuhay0****'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  modifiedTime?: long(name='ModifiedTime', description='The time when the lifecycle management rule was last modified.', example='1638259914000'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test-namespace'),
  nextTime?: long(name='NextTime', description='The time when the lifecycle management rule is next executed.', example='1701878400000'),
  repoName?: string(name='RepoName', description='The name of the image repository.', example='test-repo'),
  requestId?: string(name='RequestId', description='The request ID.', example='724402D0-75CD-4794-BC20-7D37208****'),
  retentionTagCount?: long(name='RetentionTagCount', description='The number of retained images.', example='30'),
  ruleId?: string(name='RuleId', description='The rule ID.', example='cralr-a18bkiajy8****'),
  scheduleTime?: string(name='ScheduleTime', description='The execution cycle of the lifecycle management rule.', example='WEEK'),
  scope?: string(name='Scope', description='The deletion scope of artifacts.', example='INSTANCE'),
  tagRegexp?: string(name='TagRegexp', description='The regular expression that indicates which image tags are retained.', example='.*-alpine'),
}

model GetArtifactLifecycleRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetArtifactLifecycleRuleResponseBody(name='body'),
}

/**
 * @summary Queries the lifecycle management rules of an artifact.
 *
 * @param request GetArtifactLifecycleRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetArtifactLifecycleRuleResponse
 */
async function getArtifactLifecycleRuleWithOptions(request: GetArtifactLifecycleRuleRequest, runtime: $RuntimeOptions): GetArtifactLifecycleRuleResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetArtifactLifecycleRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the lifecycle management rules of an artifact.
 *
 * @param request GetArtifactLifecycleRuleRequest
 * @return GetArtifactLifecycleRuleResponse
 */
async function getArtifactLifecycleRule(request: GetArtifactLifecycleRuleRequest): GetArtifactLifecycleRuleResponse {
  var runtime = new $RuntimeOptions{};
  return getArtifactLifecycleRuleWithOptions(request, runtime);
}

model GetArtifactSubscriptionRuleRequest {
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-c0o11woew0k****'),
  ruleId?: string(name='RuleId', description='The rule ID.

This parameter is required.', example='crasr-mdbpung4i1rm****'),
}

model GetArtifactSubscriptionRuleResponseBody = {
  accelerate?: boolean(name='Accelerate', description='Indicates whether an acceleration link is enabled for image subscription. The subscription acceleration feature is in public preview. The feature is optimized based on scheduling policies and network links to accelerate image subscription.', example='true'),
  code?: string(name='Code', description='The return value.', example='success'),
  createTime?: long(name='CreateTime', description='The time when the subscription rule was created.', example='1570759546000'),
  instanceId?: string(name='InstanceId', description='The instance ID.', example='cri-hpdfkc6utbaq****'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  modifiedTime?: long(name='ModifiedTime', description='The time when the subscription rule was modified.', example='1638259914000'),
  namespaceName?: string(name='NamespaceName', description='The name of the Container Registry namespace.', example='test-ns'),
  override?: boolean(name='Override', description='Indicates whether the original image is overwritten.', example='true'),
  platform?: [ string ](name='Platform', description='The operating system and architecture. If the source repository contains multi-arch images, only the images with the specified operating system and architecture are subscribed to the destination repository of the Enterprise Edition instance.'),
  repoName?: string(name='RepoName', description='The name of the Container Registry repository.', example='test-repo'),
  requestId?: string(name='RequestId', description='The request ID.', example='D4978DCC-ECBD-40B0-A714-EE6959B22C77'),
  ruleId?: string(name='RuleId', description='The rule ID.', example='crasr-mdbpung4i1rm****'),
  sourceNamespaceName?: string(name='SourceNamespaceName', description='The name of the source namespace.', example='library'),
  sourceProvider?: string(name='SourceProvider', description='The source of the artifact.

Valid values:

*   DOCKER_HUB: Docker Hub
*   GCR: GCR
*   QUAY: Quay.io', example='DOCKER_HUB'),
  sourceRepoName?: string(name='SourceRepoName', description='The source repository.', example='nginx'),
  tagCount?: long(name='TagCount', description='The number of subscribed images.', example='1'),
  tagRegexp?: string(name='TagRegexp', description='The image tag in the subscription source repository. Regular expressions are supported.', example='release-v.*'),
}

model GetArtifactSubscriptionRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetArtifactSubscriptionRuleResponseBody(name='body'),
}

/**
 * @summary Queries the information about an artifact subscription rule.
 *
 * @param request GetArtifactSubscriptionRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetArtifactSubscriptionRuleResponse
 */
async function getArtifactSubscriptionRuleWithOptions(request: GetArtifactSubscriptionRuleRequest, runtime: $RuntimeOptions): GetArtifactSubscriptionRuleResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetArtifactSubscriptionRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about an artifact subscription rule.
 *
 * @param request GetArtifactSubscriptionRuleRequest
 * @return GetArtifactSubscriptionRuleResponse
 */
async function getArtifactSubscriptionRule(request: GetArtifactSubscriptionRuleRequest): GetArtifactSubscriptionRuleResponse {
  var runtime = new $RuntimeOptions{};
  return getArtifactSubscriptionRuleWithOptions(request, runtime);
}

model GetArtifactSubscriptionTaskRequest {
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  taskId?: string(name='TaskId', description='The task ID.

This parameter is required.', example='crast-40le4es9yh0p****'),
}

model GetArtifactSubscriptionTaskResponseBody = {
  artifactType?: string(name='ArtifactType', description='The artifact type.', example='IMAGE'),
  code?: string(name='Code', description='The return value.', example='success'),
  endTime?: long(name='EndTime', description='The end time of the artifact subscription task.', example='1691979202000'),
  instanceId?: string(name='InstanceId', description='The instance ID.', example='cri-xkx6vujuhay0****'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  message?: string(name='Message', description='The return message.', example='success'),
  namespaceName?: string(name='NamespaceName', description='The name of the Container Registry namespace.', example='test'),
  repoName?: string(name='RepoName', description='The name of the Container Registry repository.', example='test-repo'),
  requestId?: string(name='RequestId', description='The request ID.', example='12589EF7-96E2-4554-AAD7-F7209E88CAD3'),
  sourceNamespaceName?: string(name='SourceNamespaceName', description='The name of the source namespace.', example='library'),
  sourceProvider?: string(name='SourceProvider', description='The artifact source.', example='DOCKER_HUB'),
  sourceRepoName?: string(name='SourceRepoName', description='The name of the source repository.', example='nginx'),
  sourceRepoType?: string(name='SourceRepoType', description='The type of the source repository.', example='PUBLIC'),
  startTime?: long(name='StartTime', description='The start time of the artifact subscription task.', example='1568718468000'),
  tagSubscriptionCount?: long(name='TagSubscriptionCount', description='The total subscribed tags.', example='1'),
  tagTotalCount?: long(name='TagTotalCount', description='The total number of tags.', example='6'),
  taskId?: string(name='TaskId', description='The task ID.', example='crast-40le4es9yh0p****'),
  taskResult?: string(name='TaskResult', description='The task results.', example='SUCCESS'),
  taskStatus?: string(name='TaskStatus', description='The status of the task.', example='RUNNING'),
  taskType?: string(name='TaskType', description='The type of the task. Valid values:', example='AUTO'),
}

model GetArtifactSubscriptionTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetArtifactSubscriptionTaskResponseBody(name='body'),
}

/**
 * @summary Queries an artifact subscription task.
 *
 * @param request GetArtifactSubscriptionTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetArtifactSubscriptionTaskResponse
 */
async function getArtifactSubscriptionTaskWithOptions(request: GetArtifactSubscriptionTaskRequest, runtime: $RuntimeOptions): GetArtifactSubscriptionTaskResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetArtifactSubscriptionTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries an artifact subscription task.
 *
 * @param request GetArtifactSubscriptionTaskRequest
 * @return GetArtifactSubscriptionTaskResponse
 */
async function getArtifactSubscriptionTask(request: GetArtifactSubscriptionTaskRequest): GetArtifactSubscriptionTaskResponse {
  var runtime = new $RuntimeOptions{};
  return getArtifactSubscriptionTaskWithOptions(request, runtime);
}

model GetArtifactSubscriptionTaskResultRequest {
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-90fxryf9pwf****'),
  pageNo?: int32(name='PageNo', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
  taskId?: string(name='TaskId', description='The task ID.

This parameter is required.', example='crast-y64sq01bgad****'),
}

model GetArtifactSubscriptionTaskResultResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='0A8768F6-9B47-5127-A075-9CFB9F79181F'),
  taskResults?: [ 
    {
      endTime?: long(name='EndTime', description='The end time of the subscription task.', example='1692756630000'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='cri-isj2wgaw4z9****'),
      namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test-ns'),
      repoName?: string(name='RepoName', description='The name of the repository.', example='test-reop'),
      result?: string(name='Result', description='The result of the task.', example='SUCCESS'),
      startTime?: long(name='StartTime', description='The start time of the subscription task.', example='1691719501000'),
      status?: string(name='Status', description='The status of the task.', example='COMPLETED'),
      tag?: string(name='Tag', description='The image tag.', example='v2.0'),
      taskId?: string(name='TaskId', description='The task ID.', example='crast-wkpfwqozjiq****'),
    }
  ](name='TaskResults', description='The result of the artifact subscription task.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model GetArtifactSubscriptionTaskResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetArtifactSubscriptionTaskResultResponseBody(name='body'),
}

/**
 * @summary Queries the details of an artifact subscription task.
 *
 * @param request GetArtifactSubscriptionTaskResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetArtifactSubscriptionTaskResultResponse
 */
async function getArtifactSubscriptionTaskResultWithOptions(request: GetArtifactSubscriptionTaskResultRequest, runtime: $RuntimeOptions): GetArtifactSubscriptionTaskResultResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetArtifactSubscriptionTaskResult',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of an artifact subscription task.
 *
 * @param request GetArtifactSubscriptionTaskResultRequest
 * @return GetArtifactSubscriptionTaskResultResponse
 */
async function getArtifactSubscriptionTaskResult(request: GetArtifactSubscriptionTaskResultRequest): GetArtifactSubscriptionTaskResultResponse {
  var runtime = new $RuntimeOptions{};
  return getArtifactSubscriptionTaskResultWithOptions(request, runtime);
}

model GetAuthorizationTokenRequest {
  instanceId?: string(name='InstanceId', description='The ID of the request.

This parameter is required.', example='cri-kmsiwlxxdcvaduwb'),
}

model GetAuthorizationTokenResponseBody = {
  authorizationToken?: string(name='AuthorizationToken', description='The temporary password returned after you call this API operation is a Security Token Service (STS) token whose validity period is 1 hour. Take note of the following items when you log on to Container Registry instances by using an STS token:

*   If the STS token belongs to an Alibaba Cloud account, you can use the STS token to log on to all Container Registry instances that belong to the Alibaba Cloud account.
*   If the STS token belongs to a Resource Access Management (RAM) user, you can use the STS token to log on to all Container Registry instances that belong to the RAM user.
*   You can use an STS token to access only Container Registry instances to which the STS token is scoped.', example='shaunadadakks:uuczxnjcyeyhdjadkkajsjdjadhyucb'),
  code?: string(name='Code', description='Indicates whether the API call is successful.

*   `true`: successful
*   `false`: failed', example='success'),
  expireTime?: long(name='ExpireTime', description='The return value.', example='1571242083000'),
  isSuccess?: boolean(name='IsSuccess', description='The username that is used to log on to the Container Registry instance.', example='true'),
  requestId?: string(name='RequestId', description='The timestamp when the temporary password expires. Unit: milliseconds.', example='E069EB86-E6AD-4A98-ADDE-0E993390239A'),
  tempUsername?: string(name='TempUsername', description='The password that is used to log on to the Container Registry instance.', example='temp_user_cr'),
}

model GetAuthorizationTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAuthorizationTokenResponseBody(name='body'),
}

/**
 * @summary Queries a temporary username and a token that you can use to log on to a Container Registry instance.
 *
 * @description The ID of the Container Registry instance.
 *
 * @param request GetAuthorizationTokenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAuthorizationTokenResponse
 */
async function getAuthorizationTokenWithOptions(request: GetAuthorizationTokenRequest, runtime: $RuntimeOptions): GetAuthorizationTokenResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetAuthorizationToken',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a temporary username and a token that you can use to log on to a Container Registry instance.
 *
 * @description The ID of the Container Registry instance.
 *
 * @param request GetAuthorizationTokenRequest
 * @return GetAuthorizationTokenResponse
 */
async function getAuthorizationToken(request: GetAuthorizationTokenRequest): GetAuthorizationTokenResponse {
  var runtime = new $RuntimeOptions{};
  return getAuthorizationTokenWithOptions(request, runtime);
}

model GetChainRequest {
  chainId?: string(name='ChainId', description='This parameter is required.', example='chi-0ops0gsmw5x2****'),
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='cri-4cdrlqmhn4gm****'),
}

model GetChainResponseBody = {
  chainConfig?: {
    chainConfigId?: string(name='ChainConfigId', example='cci-lz3ycgo69ukt****'),
    isActive?: boolean(name='IsActive', example='true'),
    nodes?: [ 
      {
        enable?: boolean(name='Enable', example='true'),
        nodeConfig?: {
          denyPolicy?: {
            action?: string(name='Action', example='BLOCK'),
            baselineList?: string(name='BaselineList', example='identification,hc_image_exploit'),
            issueCount?: string(name='IssueCount', example='10'),
            issueLevel?: string(name='IssueLevel', example='HIGH'),
            issueList?: string(name='IssueList', example='CVE-2020-8286,CVE-2020-8285'),
            logic?: string(name='Logic', example='AND'),
            maliciousList?: string(name='MaliciousList', example='mutate_cockhorse,abnormal_program'),
          }(name='DenyPolicy'),
          retry?: int32(name='Retry', example='3'),
          scanEngine?: string(name='ScanEngine', example='ACR_SCAN_SERVICE'),
          timeout?: long(name='Timeout'),
        }(name='NodeConfig'),
        nodeName?: string(name='NodeName', example='VULNERABILITY_SCANNING'),
      }
    ](name='Nodes'),
    routers?: [ 
      {
        from?: {
          nodeName?: string(name='NodeName', example='DOCKER_IMAGE_BUILD'),
        }(name='From'),
        to?: {
          nodeName?: string(name='NodeName', example='DOCKER_IMAGE_PUSH'),
        }(name='To'),
      }
    ](name='Routers'),
    version?: string(name='Version', example='1'),
  }(name='ChainConfig'),
  chainId?: string(name='ChainId', example='chi-0ops0gsmw5x2****'),
  code?: string(name='Code', example='success'),
  createTime?: long(name='CreateTime', example='1638255427000'),
  description?: string(name='Description', example='description'),
  instanceId?: string(name='InstanceId', example='cri-4cdrlqmhn4gm****'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  modifiedTime?: long(name='ModifiedTime', example='1638259914000'),
  name?: string(name='Name', example='test'),
  requestId?: string(name='RequestId', example='C87993B5-7D61-5CAC-8D64-1AC732DD69FF'),
  scopeExclude?: [ string ](name='ScopeExclude'),
  scopeId?: string(name='ScopeId', example='crr-nyrh2oko32xb****'),
  scopeType?: string(name='ScopeType', example='REPOSITORY'),
}

model GetChainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetChainResponseBody(name='body'),
}

/**
 * @param request GetChainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetChainResponse
 */
async function getChainWithOptions(request: GetChainRequest, runtime: $RuntimeOptions): GetChainResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.chainId)) {
    query['ChainId'] = request.chainId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetChain',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetChainRequest
 * @return GetChainResponse
 */
async function getChain(request: GetChainRequest): GetChainResponse {
  var runtime = new $RuntimeOptions{};
  return getChainWithOptions(request, runtime);
}

model GetChartNamespaceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.

This parameter is required.', example='ns1'),
}

model GetChartNamespaceResponseBody = {
  autoCreateRepo?: boolean(name='AutoCreateRepo', description='Indicates whether a repository was automatically created in the namespace. Valid values:

*   `true`: A repository was automatically created in the namespace.
*   `false`: No repository was automatically created in the namespace.', example='true'),
  code?: string(name='Code', description='The return value.', example='success'),
  defaultRepoType?: string(name='DefaultRepoType', description='The default repository type. Valid values:

*   `PUBLIC`: a public repository.
*   `PRIVATE`: a private repository.', example='PRIVATE'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  namespaceId?: string(name='NamespaceId', description='The ID of the namespace.', example='crcn-43dhbjbyt2xl****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='ns1'),
  namespaceStatus?: string(name='NamespaceStatus', description='The status of the namespace. Valid values:

*   `NORMAL`: The namespace is normal.
*   `DELETING`: The namespace is being deleted.', example='NORMAL'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CD71CF13-93AA-4805-848B-69B2DD543A9A'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-acfmv36i4is****'),
}

model GetChartNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetChartNamespaceResponseBody(name='body'),
}

/**
 * @summary Queries a chart namespace in an instance.
 *
 * @param request GetChartNamespaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetChartNamespaceResponse
 */
async function getChartNamespaceWithOptions(request: GetChartNamespaceRequest, runtime: $RuntimeOptions): GetChartNamespaceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetChartNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries a chart namespace in an instance.
 *
 * @param request GetChartNamespaceRequest
 * @return GetChartNamespaceResponse
 */
async function getChartNamespace(request: GetChartNamespaceRequest): GetChartNamespaceResponse {
  var runtime = new $RuntimeOptions{};
  return getChartNamespaceWithOptions(request, runtime);
}

model GetChartRepositoryRequest {
  instanceId?: string(name='InstanceId', description='The ID of the Container Registry instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  repoName?: string(name='RepoName', description='The name of the repository.

This parameter is required.', example='test'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.

This parameter is required.', example='test'),
}

model GetChartRepositoryResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  createTime?: long(name='CreateTime', description='The time when the chart repository was created.', example='1563767620000'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  modifiedTime?: long(name='ModifiedTime', description='The time when the chart repository was last modified.', example='1563767700000'),
  repoId?: string(name='RepoId', description='The ID of the chart repository.', example='crcr-c7letfwev5oq****'),
  repoName?: string(name='RepoName', description='The name of the chart repository.', example='test'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the chart repository belongs.', example='test'),
  repoStatus?: string(name='RepoStatus', description='The status of the chart repository. Valid values:

*   `NORMAL`: The repository is normal.
*   `DELETING`: The repository is being deleted.', example='NORMAL'),
  repoType?: string(name='RepoType', description='The type of the chart repository. Valid values:

*   `PUBLIC`: a public repository
*   `PRIVATE`: a private repository', example='PUBLIC'),
  requestId?: string(name='RequestId', description='The request ID.', example='A3F6AB56-DEF4-4FF5-8DE4-680362C0E21F'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmv36i4is****'),
  summary?: string(name='Summary', description='The summary about the chart repository.', example='test'),
}

model GetChartRepositoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetChartRepositoryResponseBody(name='body'),
}

/**
 * @summary Queries the information about a chart repository.
 *
 * @param request GetChartRepositoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetChartRepositoryResponse
 */
async function getChartRepositoryWithOptions(request: GetChartRepositoryRequest, runtime: $RuntimeOptions): GetChartRepositoryResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetChartRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about a chart repository.
 *
 * @param request GetChartRepositoryRequest
 * @return GetChartRepositoryResponse
 */
async function getChartRepository(request: GetChartRepositoryRequest): GetChartRepositoryResponse {
  var runtime = new $RuntimeOptions{};
  return getChartRepositoryWithOptions(request, runtime);
}

model GetInstanceRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='cri-xkx6vujuhay0****'),
}

model GetInstanceResponseBody = {
  code?: string(name='Code', example='success'),
  createTime?: long(name='CreateTime', example='1571926439000'),
  instanceId?: string(name='InstanceId', example='cri-xkx6vujuhay0****'),
  instanceIssue?: string(name='InstanceIssue', description='The issue occurs on the instance.', example='The issue occurs on the instance. Valid values: OSS_TOO_MANY_BUCKETS: The number of Object Storage Service (OSS) buckets exceeds the upper limit. OSS_BUCKET_ALREADY_EXISTS: An OSS bucket that has the duplicate name already exists. OSS_SERVICE_ROLE_UNAUTHORIZED: The OSS service-linked role is not granted permissions. USER_NOT_REGISTERED_BY_REAL_NAME: The Alibaba Cloud account has not passed a real name verification.'),
  instanceName?: string(name='InstanceName', example='shanghai-instance1'),
  instanceSpecification?: string(name='InstanceSpecification', description='The edition of the instance. Valid values: Enterprise_Basic: Basic Edition instances Enterprise_Standard: Standard Edition instances Enterprise_Advanced: Advanced Edition instances', example='Enterprise_Basic'),
  instanceStatus?: string(name='InstanceStatus', example='RUNNING'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  modifiedTime?: long(name='ModifiedTime', example='1571926560000'),
  requestId?: string(name='RequestId', example='6EF34B18-4228-470C-860C-D28597CF010E'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-acfmv36i4isx****'),
  tags?: [ 
    {
      tagKey?: string(name='TagKey', description='The tag key.', example='test_key'),
      tagValue?: string(name='TagValue', description='The tag value.', example='test_value'),
    }
  ](name='Tags', description='The tags of the instance.'),
}

model GetInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInstanceResponseBody(name='body'),
}

/**
 * @summary The ID of the resource group to which the instance belongs.
 *
 * @param request GetInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceResponse
 */
async function getInstanceWithOptions(request: GetInstanceRequest, runtime: $RuntimeOptions): GetInstanceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetInstance',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary The ID of the resource group to which the instance belongs.
 *
 * @param request GetInstanceRequest
 * @return GetInstanceResponse
 */
async function getInstance(request: GetInstanceRequest): GetInstanceResponse {
  var runtime = new $RuntimeOptions{};
  return getInstanceWithOptions(request, runtime);
}

model GetInstanceCountResponseBody = {
  code?: string(name='Code', description='Return value', example='success'),
  count?: int32(name='Count', description='Number of instances', example='5'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API call was successful. Values:
- `true`: The API call was successful. 
- `false`: The API call failed.', example='true'),
  requestId?: string(name='RequestId', description='Request ID', example='BC648259-91A7-4502-BED3-EDF64361FA83'),
}

model GetInstanceCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInstanceCountResponseBody(name='body'),
}

/**
 * @summary Queries the number of instances.
 *
 * @param request GetInstanceCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceCountResponse
 */
async function getInstanceCountWithOptions(runtime: $RuntimeOptions): GetInstanceCountResponse {
  var req = new OpenApiUtil.OpenApiRequest{};
  var params = new OpenApiUtil.Params{
    action = 'GetInstanceCount',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of instances.
 *
 * @return GetInstanceCountResponse
 */
async function getInstanceCount(): GetInstanceCountResponse {
  var runtime = new $RuntimeOptions{};
  return getInstanceCountWithOptions(runtime);
}

model GetInstanceEndpointRequest {
  endpointType?: string(name='EndpointType', description='The type of the endpoint. Set the value to Internet.

This parameter is required.', example='internet'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  moduleName?: string(name='ModuleName', description='The name of the module that you want to access. Valid values:

*   `Registry`: the image repository.
*   `Chart`: a Helm chart.', example='Registry'),
}

model GetInstanceEndpointResponseBody = {
  aclEnable?: boolean(name='AclEnable', description='Indicates whether the access control list (ACL) feature is enabled.', example='true'),
  aclEntries?: [ 
    {
      comment?: string(name='Comment', description='Remarks for public IP address whitelists.', example='1'),
      entry?: string(name='Entry', description='The public IP address whitelist.', example='192.168.1.0/24'),
    }
  ](name='AclEntries', description='The ACLs.'),
  code?: string(name='Code', description='The return value.', example='success'),
  domains?: [ 
    {
      domain?: string(name='Domain', description='The domain name that is used to access the Container Registry Enterprise Edition instance.', example='shanghai-instance1-registry.cn-shanghai.cr.aliyuncs.com'),
      type?: string(name='Type', description='The type of the domain name. Valid values:

*   `SYSTEM`: a system domain name.
*   `USER`: a user domain name.', example='SYSTEM'),
    }
  ](name='Domains', description='Domain names.'),
  enable?: boolean(name='Enable', description='Indicates whether the ACL feature is enabled.', example='true'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='8F3D5EC5-39D1-4C53-A198-48C54C658FA3'),
  status?: string(name='Status', description='The status of the instance.', example='RUNNING'),
}

model GetInstanceEndpointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInstanceEndpointResponseBody(name='body'),
}

/**
 * @summary Queries the endpoint of an instance.
 *
 * @param request GetInstanceEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceEndpointResponse
 */
async function getInstanceEndpointWithOptions(request: GetInstanceEndpointRequest, runtime: $RuntimeOptions): GetInstanceEndpointResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetInstanceEndpoint',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the endpoint of an instance.
 *
 * @param request GetInstanceEndpointRequest
 * @return GetInstanceEndpointResponse
 */
async function getInstanceEndpoint(request: GetInstanceEndpointRequest): GetInstanceEndpointResponse {
  var runtime = new $RuntimeOptions{};
  return getInstanceEndpointWithOptions(request, runtime);
}

model GetInstanceUsageRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
}

model GetInstanceUsageResponseBody = {
  chartNamespaceQuota?: string(name='ChartNamespaceQuota', description='The quota of chart namespaces.', example='50'),
  chartNamespaceUsage?: string(name='ChartNamespaceUsage', description='The number of chart namespaces that are created in the instance.', example='2'),
  chartRepoQuota?: string(name='ChartRepoQuota', description='The quota of chart repositories for the instance.', example='5000'),
  chartRepoUsage?: string(name='ChartRepoUsage', description='The number of chart repositories that are created.', example='5'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  namespaceQuota?: string(name='NamespaceQuota', description='The quota of image namespaces for the instance.', example='100'),
  namespaceUsage?: string(name='NamespaceUsage', description='The number of image namespaces that are created in the instance.', example='4'),
  repoQuota?: string(name='RepoQuota', description='The quota of image repositories for the instance.', example='1000'),
  repoUsage?: string(name='RepoUsage', description='The number of image repositories that are created in the instance.', example='2'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A726E801-7FCF-43F9-AF1C-51B3E65D3E7A'),
  vpcQuota?: string(name='VpcQuota', description='VPC quota', example='5'),
  vpcUsage?: string(name='VpcUsage', description='Number of bound VPCs', example='2'),
}

model GetInstanceUsageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInstanceUsageResponseBody(name='body'),
}

/**
 * @summary Queries the quota usage of an instance.
 *
 * @param request GetInstanceUsageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceUsageResponse
 */
async function getInstanceUsageWithOptions(request: GetInstanceUsageRequest, runtime: $RuntimeOptions): GetInstanceUsageResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetInstanceUsage',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the quota usage of an instance.
 *
 * @param request GetInstanceUsageRequest
 * @return GetInstanceUsageResponse
 */
async function getInstanceUsage(request: GetInstanceUsageRequest): GetInstanceUsageResponse {
  var runtime = new $RuntimeOptions{};
  return getInstanceUsageWithOptions(request, runtime);
}

model GetInstanceVpcEndpointRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  moduleName?: string(name='ModuleName', description='The name of the module that you want to access. Valid values:

*   `Registry`: the image repository.
*   `Chart`: a Helm chart.', example='Chart'),
}

model GetInstanceVpcEndpointResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  domains?: [ string ](name='Domains', description='Domain names.'),
  enable?: boolean(name='Enable', description='Indicates whether the VPC endpoint is enabled. Valid values:

*   `true`
*   `false`', example='true'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  linkedVpcs?: [ 
    {
      defaultAccess?: boolean(name='DefaultAccess', description='Indicates whether the VPC is the default VPC over which the Container Registry instance is accessed.', example='false'),
      ip?: string(name='Ip', description='IP address.', example='192.168.10.11'),
      status?: string(name='Status', description='The status of the VPC. Valid values:

*   `CREATING`
*   `RUNNING`', example='CREATING'),
      vpcId?: string(name='VpcId', description='VPC ID', example='vpc-uf6aamu2nomfr1thd****'),
      vswitchId?: string(name='VswitchId', description='The ID of the vSwitch.', example='vsw-uf62m5vmxl2e72dk7****'),
    }
  ](name='LinkedVpcs', description='The VPCs that are added to the access control list.'),
  moduleName?: string(name='ModuleName', description='The name of the modules that can be accessed. Valid values:

*   `Registry`: image repositories.
*   `Chart`: Helm charts.', example='Registry'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BAE9349D-A587-4F9A-B574-9DA0EF2638D1'),
}

model GetInstanceVpcEndpointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInstanceVpcEndpointResponseBody(name='body'),
}

/**
 * @summary Queries the endpoints of the virtual private clouds (VPCs) in which a Container Registry instance is deployed.
 *
 * @param request GetInstanceVpcEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceVpcEndpointResponse
 */
async function getInstanceVpcEndpointWithOptions(request: GetInstanceVpcEndpointRequest, runtime: $RuntimeOptions): GetInstanceVpcEndpointResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetInstanceVpcEndpoint',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the endpoints of the virtual private clouds (VPCs) in which a Container Registry instance is deployed.
 *
 * @param request GetInstanceVpcEndpointRequest
 * @return GetInstanceVpcEndpointResponse
 */
async function getInstanceVpcEndpoint(request: GetInstanceVpcEndpointRequest): GetInstanceVpcEndpointResponse {
  var runtime = new $RuntimeOptions{};
  return getInstanceVpcEndpointWithOptions(request, runtime);
}

model GetNamespaceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  namespaceId?: string(name='NamespaceId', description='The ID of the namespace.', example='crn-tiw8t3f8i5lta****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test'),
}

model GetNamespaceResponseBody = {
  autoCreateRepo?: boolean(name='AutoCreateRepo', description='Indicates whether a repository is automatically created when an image is pushed to the namespace.', example='true'),
  code?: string(name='Code', description='The return value.', example='success'),
  defaultRepoType?: string(name='DefaultRepoType', description='The default type of repositories. Valid values:

*   PUBLIC: The repositories are public repositories.
*   PRIVATE: The repositories are private repositories.', example='PUBLIC'),
  instanceId?: string(name='InstanceId', description='The ID of the Container Registry instance.', example='cri-kmsiwlxxdcva****'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request was successful.', example='true'),
  namespaceId?: string(name='NamespaceId', description='The ID of the namespace.', example='crn-tiw8t3f8i5lt****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test'),
  namespaceStatus?: string(name='NamespaceStatus', description='The status of the namespace.

*   NORMAL
*   DELETING', example='NORMAL'),
  requestId?: string(name='RequestId', description='The request ID.', example='E4BC9E21-8AA5-4582-83C1-C1209AB8196F'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the namespace belongs.', example='rg-acfmv36i4is****'),
}

model GetNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetNamespaceResponseBody(name='body'),
}

/**
 * @summary Queries the information about a namespace.
 *
 * @param request GetNamespaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNamespaceResponse
 */
async function getNamespaceWithOptions(request: GetNamespaceRequest, runtime: $RuntimeOptions): GetNamespaceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about a namespace.
 *
 * @param request GetNamespaceRequest
 * @return GetNamespaceResponse
 */
async function getNamespace(request: GetNamespaceRequest): GetNamespaceResponse {
  var runtime = new $RuntimeOptions{};
  return getNamespaceWithOptions(request, runtime);
}

model GetRepoBuildRecordRequest {
  buildRecordId?: string(name='BuildRecordId', description='The ID of the image building record.

This parameter is required.', example='a78ec6fb-16ea-4649-93b7-f52afba7d****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
}

model GetRepoBuildRecordResponseBody = {
  buildRecordId?: string(name='BuildRecordId', description='The ID of the image building record.', example='79174CBA-8556-443A-8976-22C922D7****'),
  code?: string(name='Code', description='The return value.', example='success'),
  endTime?: long(name='EndTime', description='The time when the image building was completed.', example='1568718698000'),
  image?: {
    imageTag?: string(name='ImageTag', description='The tag of the image.', example='master'),
    repoName?: string(name='RepoName', description='The name of the image repository.', example='test'),
    repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the image repository belongs.', example='test'),
  }(name='Image', description='The information about the image.'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='a78ec6fb-16ea-4649-93b7-f52afba7d9de1'),
  startTime?: long(name='StartTime', description='The time when the image building started.', example='1568718468000'),
  status?: string(name='Status', description='The status of the instance.', example='true'),
}

model GetRepoBuildRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRepoBuildRecordResponseBody(name='body'),
}

/**
 * @summary Queries the information about image building records of a repository.
 *
 * @description ****
 *
 * @param request GetRepoBuildRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRepoBuildRecordResponse
 */
async function getRepoBuildRecordWithOptions(request: GetRepoBuildRecordRequest, runtime: $RuntimeOptions): GetRepoBuildRecordResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.buildRecordId)) {
    query['BuildRecordId'] = request.buildRecordId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetRepoBuildRecord',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about image building records of a repository.
 *
 * @description ****
 *
 * @param request GetRepoBuildRecordRequest
 * @return GetRepoBuildRecordResponse
 */
async function getRepoBuildRecord(request: GetRepoBuildRecordRequest): GetRepoBuildRecordResponse {
  var runtime = new $RuntimeOptions{};
  return getRepoBuildRecordWithOptions(request, runtime);
}

model GetRepoBuildRecordStatusRequest {
  buildRecordId?: string(name='BuildRecordId', description='The ID of the image building record.

This parameter is required.', example='a78ec6fb-16ea-4649-93b7-f52afba7d****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

This parameter is required.', example='crr-jnzm47ihjmgc****'),
}

model GetRepoBuildRecordStatusResponseBody = {
  buildStatus?: string(name='BuildStatus', description='The status of the image building.', example='success'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='79174CBA-8556-443A-8976-22C922D7BE37'),
}

model GetRepoBuildRecordStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRepoBuildRecordStatusResponseBody(name='body'),
}

/**
 * @summary Queries the status of an image building task.
 *
 * @param request GetRepoBuildRecordStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRepoBuildRecordStatusResponse
 */
async function getRepoBuildRecordStatusWithOptions(request: GetRepoBuildRecordStatusRequest, runtime: $RuntimeOptions): GetRepoBuildRecordStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.buildRecordId)) {
    query['BuildRecordId'] = request.buildRecordId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetRepoBuildRecordStatus',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the status of an image building task.
 *
 * @param request GetRepoBuildRecordStatusRequest
 * @return GetRepoBuildRecordStatusResponse
 */
async function getRepoBuildRecordStatus(request: GetRepoBuildRecordStatusRequest): GetRepoBuildRecordStatusResponse {
  var runtime = new $RuntimeOptions{};
  return getRepoBuildRecordStatusWithOptions(request, runtime);
}

model GetRepoSourceCodeRepoRequest {
  instanceId?: string(name='InstanceId', description='The ID of the Container Registry instance.

This parameter is required.', example='cri-shac42yvqzvq****'),
  repoId?: string(name='RepoId', description='The ID of the repository.

This parameter is required.', example='crr-gzsrlevmvoaq****'),
}

model GetRepoSourceCodeRepoResponseBody = {
  autoBuild?: string(name='AutoBuild', description='Indicates whether image building is automatically triggered when source code is committed. Valid values:

*   `true`: Image building is automatically triggered when source code is committed.
*   `false`: Image building is not triggered when source code is committed.', example='true'),
  code?: string(name='Code', description='The response code.', example='success'),
  codeRepoDomain?: string(name='CodeRepoDomain', description='The address of the source code repository.', example='https://github.com'),
  codeRepoName?: string(name='CodeRepoName', description='The name of the source code repository.', example='repo'),
  codeRepoNamespaceName?: string(name='CodeRepoNamespaceName', description='The namespace to which the source code repository belongs.', example='namespace'),
  codeRepoType?: string(name='CodeRepoType', description='The type of the code hosting platform. Valid values: `GITHUB`, `GITLAB`, `GITEE`, `CODE`, and `CODEUP`.', example='GITHUB'),
  disableCacheBuild?: string(name='DisableCacheBuild', description='Indicates whether build cache is disabled. Valid values:

*   `true`: Build cache is disabled.
*   `false`: Build cache is enabled.', example='false'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API call is successful. Valid values:

*   `true`: successful
*   `false`: failed', example='true'),
  overseaBuild?: string(name='OverseaBuild', description='Indicates whether image building is accelerated for servers outside the Chinese mainland. Valid values:

*   `true`: Image building is accelerated for servers outside the Chinese mainland.
*   `false`: Image building is not accelerated for servers outside the Chinese mainland.', example='false'),
  repoId?: string(name='RepoId', description='The ID of the repository.', example='crr-gzsrlevmvoaq****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4CE1F661-75DD-4EBD-A4AD-057B26834ABB'),
}

model GetRepoSourceCodeRepoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRepoSourceCodeRepoResponseBody(name='body'),
}

/**
 * @summary Queries the information about the source code repository that is bound to an image repository.
 *
 * @param request GetRepoSourceCodeRepoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRepoSourceCodeRepoResponse
 */
async function getRepoSourceCodeRepoWithOptions(request: GetRepoSourceCodeRepoRequest, runtime: $RuntimeOptions): GetRepoSourceCodeRepoResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetRepoSourceCodeRepo',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the source code repository that is bound to an image repository.
 *
 * @param request GetRepoSourceCodeRepoRequest
 * @return GetRepoSourceCodeRepoResponse
 */
async function getRepoSourceCodeRepo(request: GetRepoSourceCodeRepoRequest): GetRepoSourceCodeRepoResponse {
  var runtime = new $RuntimeOptions{};
  return getRepoSourceCodeRepoWithOptions(request, runtime);
}

model GetRepoSyncTaskRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-sgedpenzw80e****'),
  syncTaskId?: string(name='SyncTaskId', description='The ID of the synchronization task.

This parameter is required.', example='rst-zxjkiv5oil6f****'),
}

model GetRepoSyncTaskResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  crossUser?: boolean(name='CrossUser', description='Indicates whether the synchronization task is performed across Alibaba Cloud accounts.', example='true'),
  imageFrom?: {
    imageTag?: string(name='ImageTag', description='The tag of the image.', example='master'),
    instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-sgedpenzw80e****'),
    regionId?: string(name='RegionId', description='The region ID.', example='cn-shanghai'),
    repoName?: string(name='RepoName', description='The name of the image repository.', example='test'),
    repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.', example='test'),
  }(name='ImageFrom', description='The source address of the image.'),
  imageTo?: {
    imageTag?: string(name='ImageTag', description='The tag of the image.', example='master'),
    instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-leqzomz5vijc****'),
    regionId?: string(name='RegionId', description='The region ID.', example='eu-west-1'),
    repoName?: string(name='RepoName', description='The name of the image repository.', example='test'),
    repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.', example='test'),
  }(name='ImageTo', description='The destination address of the image.'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  layerTasks?: [ 
    {
      artifactDigest?: string(name='ArtifactDigest', description='The digest of the artifact.', example='sha256:36fb85fcb5e919cb60e782397a6be04201868fe7b38ef7669fc01caec1c8fc4e'),
      digest?: string(name='Digest', description='The digest of the image layer.', example='sha256:36fb85fcb5e919cb60e782397a6be04201868fe7b38ef7669fc01caec1c8fc4e'),
      size?: long(name='Size', description='The size of synchronized image layers.', example='23655489'),
      syncLayerTaskId?: string(name='SyncLayerTaskId', description='The ID of the synchronization task for the image layer.', example='rslt-074x4q20fx2d****'),
      syncedSize?: long(name='SyncedSize', description='The size of the image layer that is synchronized.', example='23655489'),
      taskStatus?: string(name='TaskStatus', description='The status of the synchronization task. Valid values:', example='SUCCESS'),
    }
  ](name='LayerTasks', description='The synchronization tasks for the image layer.'),
  progress?: long(name='Progress', description='The synchronization progress. Valid values:

*   `0`: The synchronization starts or failed.
*   `1`: The synchronization is successful.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A6DEF8B0-5D45-46D6-867D-8C7FF0966B07'),
  syncBatchTaskId?: string(name='SyncBatchTaskId', description='The ID of the synchronization task in which multiple images are synchronized at a time.', example='a9434731-95ef-4087-9cf4-369c8e90****'),
  syncRuleId?: string(name='SyncRuleId', description='The ID of the synchronization rule.', example='crsr-cllro6ho3wne****'),
  syncTaskId?: string(name='SyncTaskId', description='The ID of the synchronization task.', example='rst-zxjkiv5oil6f****'),
  syncTransAccelerate?: boolean(name='SyncTransAccelerate', description='Indicates whether transfer acceleration is enabled in the synchronization process.', example='true'),
  syncedSize?: long(name='SyncedSize', description='The size of the image layer that is synchronized. Unit: bytes.', example='23655489'),
  taskIssue?: string(name='TaskIssue'),
  taskStatus?: string(name='TaskStatus', description='The status of the task. Valid values:', example='SUCCESS'),
  taskTrigger?: string(name='TaskTrigger', description='The policy that is used to trigger the synchronization task.', example='null'),
}

model GetRepoSyncTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRepoSyncTaskResponseBody(name='body'),
}

/**
 * @summary Queries an image synchronization task in an instance.
 *
 * @param request GetRepoSyncTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRepoSyncTaskResponse
 */
async function getRepoSyncTaskWithOptions(request: GetRepoSyncTaskRequest, runtime: $RuntimeOptions): GetRepoSyncTaskResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.syncTaskId)) {
    query['SyncTaskId'] = request.syncTaskId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetRepoSyncTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries an image synchronization task in an instance.
 *
 * @param request GetRepoSyncTaskRequest
 * @return GetRepoSyncTaskResponse
 */
async function getRepoSyncTask(request: GetRepoSyncTaskRequest): GetRepoSyncTaskResponse {
  var runtime = new $RuntimeOptions{};
  return getRepoSyncTaskWithOptions(request, runtime);
}

model GetRepoTagRequest {
  instanceId?: string(name='InstanceId', description='The return value of status code.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', description='The operation that you want to perform. Set the value to **GetRepoTag**.

This parameter is required.', example='crr-tquyps22md8p****'),
  tag?: string(name='Tag', description='The number of milliseconds that have elapsed since the image was created.

This parameter is required.', example='1.0'),
}

model GetRepoTagResponseBody = {
  code?: string(name='Code', description='The ID of the image.', example='success'),
  digest?: string(name='Digest', description='The size of the image. Unit: Bytes.', example='67bfbcc12b67936ec7f867927817cbb071832b873dbcaed312a1930ba5f1****'),
  imageCreate?: long(name='ImageCreate', description='crr-tquyps22md8p****', example='1572839125000'),
  imageId?: string(name='ImageId', example='45023655bf39c382e26a8607d057c27871dee163c1ecf48cc1ebf2a1****'),
  imageSize?: long(name='ImageSize', description='The number of milliseconds that have elapsed since the image was last updated.', example='27107966'),
  imageUpdate?: long(name='ImageUpdate', description='The ID of the request.', example='1572875608000'),
  isSuccess?: boolean(name='IsSuccess', description='The status of the image. Valid values:

*   `NORMAL`: The image is normal.
*   `DELETING`: The image is being deleted.', example='true'),
  requestId?: string(name='RequestId', description='1.0', example='031572FA-7D8F-4C05-B790-1071E0E05DE6'),
  status?: string(name='Status', description='The ID of the instance.', example='NORMAL'),
  tag?: string(name='Tag', description='The version of the repository.', example='1.0'),
}

model GetRepoTagResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRepoTagResponseBody(name='body'),
}

/**
 * @summary The version of the repository.
 *
 * @param request GetRepoTagRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRepoTagResponse
 */
async function getRepoTagWithOptions(request: GetRepoTagRequest, runtime: $RuntimeOptions): GetRepoTagResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetRepoTag',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary The version of the repository.
 *
 * @param request GetRepoTagRequest
 * @return GetRepoTagResponse
 */
async function getRepoTag(request: GetRepoTagRequest): GetRepoTagResponse {
  var runtime = new $RuntimeOptions{};
  return getRepoTagWithOptions(request, runtime);
}

model GetRepoTagScanStatusRequest {
  digest?: string(name='Digest', example='67bfbcc12b67936ec7f867927817cbb071832b873dbcaed312a1930ba5f1d529'),
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='cri-2j88dtld8yel****'),
  repoId?: string(name='RepoId', example='crr-uf082u9dg8do****'),
  scanTaskId?: string(name='ScanTaskId', example='838152F9-F725-5A52-A344-8972D65AC045'),
  tag?: string(name='Tag', example='1'),
}

model GetRepoTagScanStatusResponseBody = {
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='BC648259-91A7-4502-BED3-EDF64361FA83'),
  scanService?: string(name='ScanService', example='ACR_SCAN_SERVICE'),
  status?: string(name='Status', example='COMPLETE'),
}

model GetRepoTagScanStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRepoTagScanStatusResponseBody(name='body'),
}

/**
 * @param request GetRepoTagScanStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRepoTagScanStatusResponse
 */
async function getRepoTagScanStatusWithOptions(request: GetRepoTagScanStatusRequest, runtime: $RuntimeOptions): GetRepoTagScanStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!$isNull(request.scanTaskId)) {
    query['ScanTaskId'] = request.scanTaskId;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetRepoTagScanStatus',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetRepoTagScanStatusRequest
 * @return GetRepoTagScanStatusResponse
 */
async function getRepoTagScanStatus(request: GetRepoTagScanStatusRequest): GetRepoTagScanStatusResponse {
  var runtime = new $RuntimeOptions{};
  return getRepoTagScanStatusWithOptions(request, runtime);
}

model GetRepoTagScanSummaryRequest {
  digest?: string(name='Digest', description='The number of unknown-severity vulnerabilities.', example='sha256:c9f370a4eb1c00d0b0d7212a0a9fa4a7697756c90f0f680afaf9737a25725f4c'),
  instanceId?: string(name='InstanceId', description='The ID of the image repository.

This parameter is required.', example='cri-2j88dtld8yel****'),
  repoId?: string(name='RepoId', description='The name of the image tag.', example='crr-c2i5yk6h6pu9d5o8'),
  scanTaskId?: string(name='ScanTaskId', description='The digest of the image.', example='47A3E5A3-6AD4-5F02-93B8-59F778AE25D4'),
  tag?: string(name='Tag', description='The ID of the security scan task.', example='1'),
}

model GetRepoTagScanSummaryResponseBody = {
  code?: string(name='Code', description='The number of medium-severity vulnerabilities.', example='success'),
  highSeverity?: int32(name='HighSeverity', description='The number of low-severity vulnerabilities.', example='22'),
  isSuccess?: boolean(name='IsSuccess', description='The number of high-severity vulnerabilities.', example='true'),
  lowSeverity?: int32(name='LowSeverity', example='89'),
  mediumSeverity?: int32(name='MediumSeverity', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='81'),
  requestId?: string(name='RequestId', description='The total number of vulnerabilities detected on images.', example='BC648259-91A7-4502-BED3-EDF64361FA83'),
  totalSeverity?: int32(name='TotalSeverity', description='The return value.', example='196'),
  unknownSeverity?: int32(name='UnknownSeverity', description='The ID of the request.', example='4'),
}

model GetRepoTagScanSummaryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRepoTagScanSummaryResponseBody(name='body'),
}

/**
 * @param request GetRepoTagScanSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRepoTagScanSummaryResponse
 */
async function getRepoTagScanSummaryWithOptions(request: GetRepoTagScanSummaryRequest, runtime: $RuntimeOptions): GetRepoTagScanSummaryResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!$isNull(request.scanTaskId)) {
    query['ScanTaskId'] = request.scanTaskId;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetRepoTagScanSummary',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetRepoTagScanSummaryRequest
 * @return GetRepoTagScanSummaryResponse
 */
async function getRepoTagScanSummary(request: GetRepoTagScanSummaryRequest): GetRepoTagScanSummaryResponse {
  var runtime = new $RuntimeOptions{};
  return getRepoTagScanSummaryWithOptions(request, runtime);
}

model GetRepositoryRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', description='The ID of the repository.', example='crr-03cuozrsqhkw****'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='test'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.', example='test'),
}

model GetRepositoryResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  createTime?: long(name='CreateTime', description='The time when the repository was created.', example='1570759546000'),
  detail?: string(name='Detail', description='The details of the repository.', example='test'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  modifiedTime?: long(name='ModifiedTime', description='The time when the repository was last modified.', example='1570759546100'),
  repoBuildType?: string(name='RepoBuildType', description='Indicates how the repository was created. Valid values:

*   `MANUAL`: The repository was manually created.
*   `AUTO`: The repository was automatically created.', example='MANUAL'),
  repoId?: string(name='RepoId', description='The ID of the repository.', example='crr-l5eoubonp0l****'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='test'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.', example='test'),
  repoStatus?: string(name='RepoStatus', description='The status of the repository.', example='NORMAL'),
  repoType?: string(name='RepoType', description='The type of the repository. Valid values:

*   `PUBLIC`: public repository.
*   `PRIVATE`: private repository.', example='PRIVATE'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='915E6734-3E50-4640-8DBA-126D2D94DE29'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmv36i4is****'),
  summary?: string(name='Summary', description='The summary of the repository.', example='Automatically created repository'),
  tagImmutability?: boolean(name='TagImmutability', description='Indicates whether the feature of image tag immutability is enabled. Valid values:

*   `true`: The feature of image tag immutability is enabled.
*   `false`: The feature of image tag immutability is disabled.', example='true'),
}

model GetRepositoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRepositoryResponseBody(name='body'),
}

/**
 * @summary Queries details about an image repository.
 *
 * @param request GetRepositoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRepositoryResponse
 */
async function getRepositoryWithOptions(request: GetRepositoryRequest, runtime: $RuntimeOptions): GetRepositoryResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries details about an image repository.
 *
 * @param request GetRepositoryRequest
 * @return GetRepositoryResponse
 */
async function getRepository(request: GetRepositoryRequest): GetRepositoryResponse {
  var runtime = new $RuntimeOptions{};
  return getRepositoryWithOptions(request, runtime);
}

model ListArtifactBuildTaskLogRequest {
  buildTaskId?: string(name='BuildTaskId', description='The ID of the artifact build task.

This parameter is required.', example='i2a-1yu****'),
  instanceId?: string(name='InstanceId', description='The ID of the Container Registry instance.

This parameter is required.', example='cri-shac42yvqzvq****'),
  page?: int32(name='Page', description='The number of the page to return.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 100. If you specify a value greater than 100 for this parameter, the system reports a parameter error or uses 100 as the maximum value.

This parameter is required.', example='100'),
}

model ListArtifactBuildTaskLogResponseBody = {
  buildTaskLogs?: [ 
    {
      lineNumber?: int32(name='LineNumber', description='The row number of the log entry.', example='1'),
      message?: string(name='Message', description='The log data.', example='Start Build'),
    }
  ](name='BuildTaskLogs', description='The log entries of the artifact build task.'),
  code?: string(name='Code', description='The response code.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API request is successful. Valid values:

*   `true`: successful
*   `false`: failed', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='C4C7DD0C-C9D6-437A-A7EE-121EFD70D002'),
  totalCount?: int32(name='TotalCount', description='The total number of log entries.', example='200'),
}

model ListArtifactBuildTaskLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListArtifactBuildTaskLogResponseBody(name='body'),
}

/**
 * @summary Queries the log entries of an artifact building task.
 *
 * @param request ListArtifactBuildTaskLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListArtifactBuildTaskLogResponse
 */
async function listArtifactBuildTaskLogWithOptions(request: ListArtifactBuildTaskLogRequest, runtime: $RuntimeOptions): ListArtifactBuildTaskLogResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListArtifactBuildTaskLog',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the log entries of an artifact building task.
 *
 * @param request ListArtifactBuildTaskLogRequest
 * @return ListArtifactBuildTaskLogResponse
 */
async function listArtifactBuildTaskLog(request: ListArtifactBuildTaskLogRequest): ListArtifactBuildTaskLogResponse {
  var runtime = new $RuntimeOptions{};
  return listArtifactBuildTaskLogWithOptions(request, runtime);
}

model ListArtifactLifecycleRuleRequest {
  enableDeleteTag?: boolean(name='EnableDeleteTag', description='Specifies whether to enable lifecycle management for the artifact.', example='true'),
  instanceId?: string(name='InstanceId', description='The ID of the Container Registry Enterprise Edition instance.

This parameter is required.', example='cri-eztul9ucz76q****'),
  pageNo?: int32(name='PageNo', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
}

model ListArtifactLifecycleRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='F92D82F9-A4C4-5A4A-97B9-E495BF1B****'),
  rules?: [ 
    {
      auto?: boolean(name='Auto', description='Indicates whether the lifecycle management rule is automatically executed.', example='false'),
      createTime?: long(name='CreateTime', description='The time when the lifecycle management rule was created.', example='1638187989000'),
      enableDeleteTag?: boolean(name='EnableDeleteTag', description='Indicates whether lifecycle management is enabled for the artifact.', example='true'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='cri-brlg4cbj2yl****'),
      modifiedTime?: long(name='ModifiedTime', description='The time when the lifecycle management rule was last modified.', example='1678341923385'),
      namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test-ns'),
      nextTime?: long(name='NextTime', description='The time when the lifecycle management rule is next executed.', example='1638187989000'),
      repoName?: string(name='RepoName', description='The name of the image repository.', example='test_1'),
      retentionTagCount?: long(name='RetentionTagCount', description='The number of retained images.', example='30'),
      ruleId?: string(name='RuleId', description='The rule ID.', example='cralr-yqx1q5sir6d****'),
      scheduleTime?: string(name='ScheduleTime', description='The execution cycle of the lifecycle management rule.', example='WEEK'),
      scope?: string(name='Scope', description='The deletion scope of artifacts.', example='INSTANCE'),
      tagRegexp?: string(name='TagRegexp', description='The regular expression that indicates which image tags are retained.', example='.*-alpine'),
    }
  ](name='Rules', description='_'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='39'),
}

model ListArtifactLifecycleRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListArtifactLifecycleRuleResponseBody(name='body'),
}

/**
 * @summary Queries the lifecycle management rules of an artifact.
 *
 * @param request ListArtifactLifecycleRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListArtifactLifecycleRuleResponse
 */
async function listArtifactLifecycleRuleWithOptions(request: ListArtifactLifecycleRuleRequest, runtime: $RuntimeOptions): ListArtifactLifecycleRuleResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListArtifactLifecycleRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the lifecycle management rules of an artifact.
 *
 * @param request ListArtifactLifecycleRuleRequest
 * @return ListArtifactLifecycleRuleResponse
 */
async function listArtifactLifecycleRule(request: ListArtifactLifecycleRuleRequest): ListArtifactLifecycleRuleResponse {
  var runtime = new $RuntimeOptions{};
  return listArtifactLifecycleRuleWithOptions(request, runtime);
}

model ListArtifactSubscriptionRuleRequest {
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-c0o11woew0k****'),
  pageNo?: int32(name='PageNo', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 100. If you specify a value greater than 100 for this parameter, the system reports a parameter error or uses 100 as the maximum value.', example='30'),
}

model ListArtifactSubscriptionRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`
*   `false`', example='true'),
  pageNo?: int32(name='PageNo', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='07FC5654-C82A-59FA-A9D1-78B4EE443F86'),
  rules?: [ 
    {
      accelerate?: boolean(name='Accelerate', description='Indicates whether an acceleration link is enabled for image subscription. The subscription acceleration feature is in public preview. The feature is optimized based on scheduling policies and network links to accelerate image subscription.', example='true'),
      createTime?: long(name='CreateTime', description='The time when the subscription rule was created.', example='1638187989000'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='cri-brlg4cbj2yl****'),
      modifiedTime?: long(name='ModifiedTime', description='The time when the subscription rule was modified.', example='1678341923385'),
      namespaceName?: string(name='NamespaceName', description='The name of the source namespace.', example='test-ns'),
      override?: boolean(name='Override', description='Indicates whether the original image is overwritten.', example='true'),
      platform?: [ string ](name='Platform', description='The operating system and architecture. If the source repository contains a multi-arch image, only the images with the specified operating system and architecture are subscribed to the destination repository of the Enterprise Edition instance.'),
      repoName?: string(name='RepoName', description='The name of the source repository.', example='test-repo'),
      ruleId?: string(name='RuleId', description='The rule ID.', example='crasr-mdbpung4i1rm****'),
      sourceNamespaceName?: string(name='SourceNamespaceName', description='The source namespace.', example='library'),
      sourceProvider?: string(name='SourceProvider', description='The source of the artifact.

Valid values:

*   DOCKER_HUB: Docker Hub
*   GCR: GCR
*   QUAY: Quay.io', example='DOCKER_HUB'),
      sourceRepoName?: string(name='SourceRepoName', description='The source repository.', example='nginx'),
      tagCount?: long(name='TagCount', description='The number of subscribed images.', example='1'),
      tagRegexp?: string(name='TagRegexp', description='The image tag in the subscription source repository. Regular expressions are supported.', example='release.*'),
    }
  ](name='Rules', description='The queried artifact subscription rules.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='13'),
}

model ListArtifactSubscriptionRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListArtifactSubscriptionRuleResponseBody(name='body'),
}

/**
 * @summary Lists the subscription rules of artifacts.
 *
 * @param request ListArtifactSubscriptionRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListArtifactSubscriptionRuleResponse
 */
async function listArtifactSubscriptionRuleWithOptions(request: ListArtifactSubscriptionRuleRequest, runtime: $RuntimeOptions): ListArtifactSubscriptionRuleResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListArtifactSubscriptionRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Lists the subscription rules of artifacts.
 *
 * @param request ListArtifactSubscriptionRuleRequest
 * @return ListArtifactSubscriptionRuleResponse
 */
async function listArtifactSubscriptionRule(request: ListArtifactSubscriptionRuleRequest): ListArtifactSubscriptionRuleResponse {
  var runtime = new $RuntimeOptions{};
  return listArtifactSubscriptionRuleWithOptions(request, runtime);
}

model ListArtifactSubscriptionTaskRequest {
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-m9ob8792vm****'),
  pageNo?: int32(name='PageNo', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
}

model ListArtifactSubscriptionTaskResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='81E7A039-A4EF-57D9-A100-88E5DCEF9D56'),
  tasks?: [ 
    {
      artifactType?: string(name='ArtifactType', description='The type of the artifact.', example='IMAGE'),
      endTime?: string(name='EndTime', description='The end time of the artifact subscription task.', example='1692756630000'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='cri-7pd01myak****'),
      message?: string(name='Message', description='The returned message.', example='success'),
      namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test-ns'),
      repoName?: string(name='RepoName', description='The name of the repository.', example='test-repo'),
      sourceNamespaceName?: string(name='SourceNamespaceName', description='The name of the source namespace.', example='library'),
      sourceProvider?: string(name='SourceProvider', description='The artifact source.', example='DOCKER_HUB'),
      sourceRepoName?: string(name='SourceRepoName', description='The name of the source repository.', example='nginx'),
      sourceRepoType?: string(name='SourceRepoType', description='The type of the source artifact.', example='PUBLIC'),
      startTime?: string(name='StartTime', description='The start time of the artifact subscription task.', example='1695348301000'),
      tagSubscriptionCount?: long(name='TagSubscriptionCount', description='The total number of subscribed tags.', example='3'),
      tagTotalCount?: long(name='TagTotalCount', description='The total number of tags.', example='311'),
      taskId?: string(name='TaskId', description='The task ID.', example='crast-40le4es9yh0p****'),
      taskResult?: string(name='TaskResult', description='The task result.', example='SUCCESS'),
      taskStatus?: string(name='TaskStatus', description='The status of the task.', example='RUNNING'),
      taskType?: string(name='TaskType', description='The type of the task.', example='AUTO'),
    }
  ](name='Tasks', description='The queried artifact subscription tasks.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='5'),
}

model ListArtifactSubscriptionTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListArtifactSubscriptionTaskResponseBody(name='body'),
}

/**
 * @summary Lists artifact subscription tasks.
 *
 * @param request ListArtifactSubscriptionTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListArtifactSubscriptionTaskResponse
 */
async function listArtifactSubscriptionTaskWithOptions(request: ListArtifactSubscriptionTaskRequest, runtime: $RuntimeOptions): ListArtifactSubscriptionTaskResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListArtifactSubscriptionTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Lists artifact subscription tasks.
 *
 * @param request ListArtifactSubscriptionTaskRequest
 * @return ListArtifactSubscriptionTaskResponse
 */
async function listArtifactSubscriptionTask(request: ListArtifactSubscriptionTaskRequest): ListArtifactSubscriptionTaskResponse {
  var runtime = new $RuntimeOptions{};
  return listArtifactSubscriptionTaskWithOptions(request, runtime);
}

model ListChainRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-4cdrlqmhn4gm****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='10'),
  repoName?: string(name='RepoName', description='The name of the image repository.', example='repo1'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.', example='ns1'),
}

model ListChainResponseBody = {
  chains?: [ 
    {
      chainId?: string(name='ChainId', description='The ID of the delivery chain.', example='chi-0ops0gsmw5x2****'),
      createTime?: long(name='CreateTime', description='The time when the delivery chain was created.', example='1638255427000'),
      description?: string(name='Description', description='The description of the delivery chain.', example='description'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-4cdrlqmhn4gm****'),
      modifiedTime?: long(name='ModifiedTime', description='The time when the delivery chain was last modified.', example='1638259914000'),
      name?: string(name='Name', description='The name of the delivery chain.', example='test'),
      scopeExclude?: [ string ](name='ScopeExclude', description='Repositories to which the delivery chain does not apply.'),
      scopeId?: string(name='ScopeId', description='The ID of the delivery chain scope.', example='crr-nyrh2oko32xb****'),
      scopeType?: string(name='ScopeType', description='The type of the delivery chain scope.', example='REPOSITORY'),
    }
  ](name='Chains', description='The list of delivery chains.'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='85A99B10-3926-5201-958E-C06FA47F****'),
  totalCount?: int32(name='TotalCount', description='The total number of delivery chains.', example='1'),
}

model ListChainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListChainResponseBody(name='body'),
}

/**
 * @summary Queries delivery chains.
 *
 * @param request ListChainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListChainResponse
 */
async function listChainWithOptions(request: ListChainRequest, runtime: $RuntimeOptions): ListChainResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListChain',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries delivery chains.
 *
 * @param request ListChainRequest
 * @return ListChainResponse
 */
async function listChain(request: ListChainRequest): ListChainResponse {
  var runtime = new $RuntimeOptions{};
  return listChainWithOptions(request, runtime);
}

model ListChainInstanceRequest {
  instanceId?: string(name='InstanceId', description='The operation that you want to perform. Set this parameter to **ListChainInstance**.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  pageNo?: int32(name='PageNo', description='The time when the delivery chain started.', example='1'),
  pageSize?: int32(name='PageSize', description='The name of the image repository.', example='30'),
  repoName?: string(name='RepoName', description='The time when the delivery chain is completed.', example='test-repo'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the delivery chain.', example='test-namespace'),
}

model ListChainInstanceResponseBody = {
  chainInstances?: [ 
    {
      chain?: {
        chainId?: string(name='ChainId', description='The name of the namespace.', example='chi-m42gbku0****'),
        chainName?: string(name='ChainName', description='The number of entries returned on each page.', example='test-chain'),
        version?: long(name='Version', description='The ID of the request.', example='1'),
      }(name='Chain', description='The name of the namespace.'),
      chainInstanceId?: string(name='ChainInstanceId', description='1', example='F4CF4DDB-BEF2-5575-****-*******'),
      endTime?: long(name='EndTime', description='The ID of the Container Registry instance.', example='1636685856000'),
      repoName?: string(name='RepoName', description='The ID of the delivery chain.', example='test-repo'),
      repoNamespaceName?: string(name='RepoNamespaceName', description='The execution result of the delivery chain. Valid values:

*   `SUCCESS`
*   `FAILED`
*   `CANCELED`
*   `DENIED`', example='test-ns'),
      result?: string(name='Result', description='The list of the execution records of delivery chains.', example='SUCCESS'),
      startTime?: long(name='StartTime', description='test-repo', example='1636685776000'),
      status?: string(name='Status', description='The status of the delivery chain. Valid values:

*   `RUNNING`
*   `COMPLETE`
*   `CANCELING`
*   `CANCELED`', example='COMPLETE'),
    }
  ](name='ChainInstances', description='The number of entries to return on each page.'),
  code?: string(name='Code', description='The version of the delivery chain.', example='success'),
  instanceId?: string(name='InstanceId', description='The page number of the page to return.', example='cri-kmsiwlxxdcva****'),
  isSuccess?: boolean(name='IsSuccess', description='The execution record of the delivery chain.', example='true'),
  pageNo?: int32(name='PageNo', description='30', example='1'),
  pageSize?: int32(name='PageSize', description='Indicates whether the operation is successful.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the Container Registry instance.', example='838D1602-6D8F-47FB-B60A-656645D2****'),
  totalCount?: int32(name='TotalCount', description='The name of the repository.', example='1'),
}

model ListChainInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListChainInstanceResponseBody(name='body'),
}

/**
 * @summary The response code.
 *
 * @param request ListChainInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListChainInstanceResponse
 */
async function listChainInstanceWithOptions(request: ListChainInstanceRequest, runtime: $RuntimeOptions): ListChainInstanceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListChainInstance',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary The response code.
 *
 * @param request ListChainInstanceRequest
 * @return ListChainInstanceResponse
 */
async function listChainInstance(request: ListChainInstanceRequest): ListChainInstanceResponse {
  var runtime = new $RuntimeOptions{};
  return listChainInstanceWithOptions(request, runtime);
}

model ListChartNamespaceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test'),
  namespaceStatus?: string(name='NamespaceStatus', description='The status of the namespace. Valid values:

*   `NORMAL`: The namespace is normal.
*   `DELETING`: The namespace is being deleted.', example='NORMAL'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
}

model ListChartNamespaceResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  namespaces?: [ 
    {
      autoCreateRepo?: boolean(name='AutoCreateRepo', description='Indicates whether a repository was automatically created when a chart is pushed to the namespace.', example='true'),
      defaultRepoType?: string(name='DefaultRepoType', description='The default repository type. Valid values:

*   `PUBLIC`: a public repository
*   `PRIVATE`: a private repository', example='PUBLIC'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
      namespaceId?: string(name='NamespaceId', description='The ID of the namespace.', example='null'),
      namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test'),
      namespaceStatus?: string(name='NamespaceStatus', description='The status of the namespace. Valid values:

*   `NORMAL`: The namespace is normal.
*   `DELETING`: The namespace is being deleted.', example='NORMAL'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-acfm4n5kzyf****'),
    }
  ](name='Namespaces', description='The namespaces.'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F56D589D-AF7F-4900-BA46-62C780AC2C10'),
  totalCount?: string(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListChartNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListChartNamespaceResponseBody(name='body'),
}

/**
 * @summary Queries the chart namespaces of a Container Registry instance.
 *
 * @param request ListChartNamespaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListChartNamespaceResponse
 */
async function listChartNamespaceWithOptions(request: ListChartNamespaceRequest, runtime: $RuntimeOptions): ListChartNamespaceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!$isNull(request.namespaceStatus)) {
    query['NamespaceStatus'] = request.namespaceStatus;
  }
  if (!$isNull(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListChartNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the chart namespaces of a Container Registry instance.
 *
 * @param request ListChartNamespaceRequest
 * @return ListChartNamespaceResponse
 */
async function listChartNamespace(request: ListChartNamespaceRequest): ListChartNamespaceResponse {
  var runtime = new $RuntimeOptions{};
  return listChartNamespaceWithOptions(request, runtime);
}

model ListChartReleaseRequest {
  chart?: string(name='Chart', description='The chart whose versions you want to query.', example='null'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='20'),
  repoName?: string(name='RepoName', description='The name of the repository.

This parameter is required.', example='repo1'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.

This parameter is required.', example='ns1'),
}

model ListChartReleaseResponseBody = {
  chartReleases?: [ 
    {
      chart?: string(name='Chart', description='The name of the chart version.', example='chart1'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
      modifiedTime?: long(name='ModifiedTime', description='The time when the chart was last modified.', example='1571930323000'),
      release?: string(name='Release', description='The version number of the chart.', example='0.1.0'),
      repoId?: string(name='RepoId', description='The ID of the chart repository.', example='crcr-gpsu7b8chmxk****'),
      size?: string(name='Size', description='The size of the chart of the version. Unit: bytes.', example='2826'),
      status?: string(name='Status', description='The status of the chart.', example='ENABLED'),
    }
  ](name='ChartReleases', description='The list of chart versions.'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F68823F6-F1B5-4A4E-8421-A83CAB8F2963'),
  totalCount?: string(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListChartReleaseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListChartReleaseResponseBody(name='body'),
}

/**
 * @summary Queries the versions of a chart in a chart repository.
 *
 * @param request ListChartReleaseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListChartReleaseResponse
 */
async function listChartReleaseWithOptions(request: ListChartReleaseRequest, runtime: $RuntimeOptions): ListChartReleaseResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.chart)) {
    query['Chart'] = request.chart;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListChartRelease',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the versions of a chart in a chart repository.
 *
 * @param request ListChartReleaseRequest
 * @return ListChartReleaseResponse
 */
async function listChartRelease(request: ListChartReleaseRequest): ListChartReleaseResponse {
  var runtime = new $RuntimeOptions{};
  return listChartReleaseWithOptions(request, runtime);
}

model ListChartRepositoryRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-xkx6vujuhay0****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='ns1'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.', example='repo1'),
  repoStatus?: string(name='RepoStatus', description='The status of the chart repositories that you want to query. Valid values:

*   `ALL`: query repositories of all status.
*   `NORMAL`: query normal repositories.
*   `DELETING`: query repositories that are being deleted.', example='ALL'),
}

model ListChartRepositoryResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  repositories?: [ 
    {
      createTime?: long(name='CreateTime', description='The time when the repository was created.', example='1571926644000'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
      modifiedTime?: long(name='ModifiedTime', description='The time when the repository was last modified.', example='1571930329000'),
      repoId?: string(name='RepoId', description='The ID of the repository.', example='crcr-gpsu7b8chmxk****'),
      repoName?: string(name='RepoName', description='The name of the repository.', example='repo1'),
      repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.', example='ns1'),
      repoStatus?: string(name='RepoStatus', description='The status of the repository. Valid values:

*   `NORMAL`: The repository is normal.
*   `DELETING`: The repository is being deleted.', example='NORMAL'),
      repoType?: string(name='RepoType', description='The type of the repository. Valid values:

*   `PRIVATE`: a private repository
*   `PUBLIC`: a public repository', example='PUBLIC'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the repository belongs.', example='rg-aek2ikd5rxxxxxx'),
      summary?: string(name='Summary', description='The summary about the repository.', example='test'),
    }
  ](name='Repositories', description='The queried repositories.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0AB62FB8-6873-4032-8515-4578D27523B7'),
  totalCount?: string(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListChartRepositoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListChartRepositoryResponseBody(name='body'),
}

/**
 * @summary Queries the chart repositories of a Container Registry instance.
 *
 * @param request ListChartRepositoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListChartRepositoryResponse
 */
async function listChartRepositoryWithOptions(request: ListChartRepositoryRequest, runtime: $RuntimeOptions): ListChartRepositoryResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!$isNull(request.repoStatus)) {
    query['RepoStatus'] = request.repoStatus;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListChartRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the chart repositories of a Container Registry instance.
 *
 * @param request ListChartRepositoryRequest
 * @return ListChartRepositoryResponse
 */
async function listChartRepository(request: ListChartRepositoryRequest): ListChartRepositoryResponse {
  var runtime = new $RuntimeOptions{};
  return listChartRepositoryWithOptions(request, runtime);
}

model ListEventCenterRecordRequest {
  eventType?: string(name='EventType', description='The type of the event. Valid values:

*   `cr:Artifact:DeliveryChainCompleted`: The delivery chain is processed.
*   `cr:Artifact:SynchronizationCompleted`: The image is replicated.
*   `cr:Artifact:BuildCompleted`: The image is built.
*   `cr:Artifact:ScanCompleted`: The image is scanned.
*   `cr:Artifact:SigningCompleted`: The image is signed.', example='cr:Artifact:DeliveryChainCompleted'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='test'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.', example='test'),
  ruleId?: string(name='RuleId', description='The ID of the event notification rule.', example='crecr-n6pbhgjxtla***'),
}

model ListEventCenterRecordResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  records?: [ 
    {
      createTime?: long(name='CreateTime', description='The time when the event was created.', example='1638188622000'),
      eventChannel?: string(name='EventChannel', description='The event notification channel.', example='EVENT_BRIDGE'),
      eventNotifyId?: string(name='EventNotifyId', description='The ID of the event notification.', example='7d478419-61df-49e5-b92b-30ce730c2127'),
      eventNotifyMethod?: string(name='EventNotifyMethod', description='The notification method. Valid values:

*   `http`: The notification is sent over HTTP.
*   `https`: The notification is sent over HTTPS.
*   `dingding`: The notification is sent by using DingTalk.', example='http'),
      eventType?: string(name='EventType', description='The type of the event.', example='cr:Artifact:DeliveryChainCompleted'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-gl34plsa****'),
      namespace?: string(name='Namespace', description='The namespace.', example='mychain'),
      recordId?: string(name='RecordId', description='The ID of the event record.', example='crecrr-ctdbzwtkpr*****'),
      repoName?: string(name='RepoName', description='The name of the image repository.', example='ruby-2.4.0'),
      ruleId?: string(name='RuleId', description='The ID of the event notification rule.', example='crecr-n6pbhgjxtla*****'),
      ruleName?: string(name='RuleName', description='The name of the event notification rule.', example='chain-demo'),
      tag?: string(name='Tag', description='The tags.', example='ruby-2.4.0'),
      updateTime?: long(name='UpdateTime', description='The time when the event was last updated.', example='1638188622000'),
    }
  ](name='Records', description='The list of historical events.', example='[]'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='665C7A5E-BAEC-5BCD-AF9F-5F9260D672BF'),
  totalCount?: int32(name='TotalCount', description='The total entries of historical events.', example='50'),
}

model ListEventCenterRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEventCenterRecordResponseBody(name='body'),
}

/**
 * @summary Queries the historical events of an event rule.
 *
 * @param request ListEventCenterRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListEventCenterRecordResponse
 */
async function listEventCenterRecordWithOptions(request: ListEventCenterRecordRequest, runtime: $RuntimeOptions): ListEventCenterRecordResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListEventCenterRecord',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the historical events of an event rule.
 *
 * @param request ListEventCenterRecordRequest
 * @return ListEventCenterRecordResponse
 */
async function listEventCenterRecord(request: ListEventCenterRecordRequest): ListEventCenterRecordResponse {
  var runtime = new $RuntimeOptions{};
  return listEventCenterRecordWithOptions(request, runtime);
}

model ListEventCenterRuleNameRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
}

model ListEventCenterRuleNameResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='031572FA-7D8F-4C05-B790-1071E0E05DE6'),
  ruleNames?: [ 
    {
      ruleId?: string(name='RuleId', description='The ID of the event notification rule.', example='crecr-n6pbhgjxtl*****'),
      ruleName?: string(name='RuleName', description='The name of the event notification rule.', example='test-chain'),
    }
  ](name='RuleNames', description='The list of names of event notification rules.', example='[{\\\\"RuleName\\\\": \\\\"mlf\\\\", \\\\"RuleId\\\\": \\\\"crecr-73q93pgljm1pc2fp\\\\"}]'),
}

model ListEventCenterRuleNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEventCenterRuleNameResponseBody(name='body'),
}

/**
 * @summary Queries the names of event notification rules.
 *
 * @param request ListEventCenterRuleNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListEventCenterRuleNameResponse
 */
async function listEventCenterRuleNameWithOptions(request: ListEventCenterRuleNameRequest, runtime: $RuntimeOptions): ListEventCenterRuleNameResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListEventCenterRuleName',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the names of event notification rules.
 *
 * @param request ListEventCenterRuleNameRequest
 * @return ListEventCenterRuleNameResponse
 */
async function listEventCenterRuleName(request: ListEventCenterRuleNameRequest): ListEventCenterRuleNameResponse {
  var runtime = new $RuntimeOptions{};
  return listEventCenterRuleNameWithOptions(request, runtime);
}

model ListInstanceRequest {
  instanceName?: string(name='InstanceName', description='The instance name.', example='test', deprecated=true),
  instanceStatus?: string(name='InstanceStatus', description='The status of the instance. Valid values:

*   `PENDING`: The instance is being initialized.
*   `INIT_ERROR`: The initialization of the instance fails.
*   `STARTING`: The instance is being started.
*   `RUNNING`: The instance is running.
*   `STOPPING`: The instance is being stopped.
*   `STOPPED`: The instance is stopped.
*   `DELETING`: The instance is being deleted.
*   `DELETED`: The instance is deleted.', example='RUNNING'),
  pageNo?: int32(name='PageNo', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-acfmv36i4is****'),
}

model ListInstanceResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  instances?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the instance was created.', example='1562849679000'),
      instanceId?: string(name='InstanceId', description='The instance ID.', example='cri-sgedpenzw80e****'),
      instanceIssue?: string(name='InstanceIssue', description='The issue occurs on the instance.', example='oss bucket already exists'),
      instanceName?: string(name='InstanceName', description='The name of the instance.', example='test'),
      instanceSpecification?: string(name='InstanceSpecification', description='The edition of the Container Registry Enterprise Edition instance.', example='Enterprise_Basic'),
      instanceStatus?: string(name='InstanceStatus', description='The status of the instance.', example='RUNNING'),
      modifiedTime?: string(name='ModifiedTime', description='The time when the instance was last modified.', example='1562849760000'),
      regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-shanghai'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-aek2h3aexpy****'),
      tags?: [ 
        {
          tagKey?: string(name='TagKey', description='The tag key.', example='test_key'),
          tagValue?: string(name='TagValue', description='The tag value.', example='test_value'),
        }
      ](name='Tags', description='The tags of the instance.'),
    }
  ](name='Instances', description='The queried instances.'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 30.', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='A2A9BA68-B264-4953-9154-CE61B1C03BA6'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='12121'),
}

model ListInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceResponseBody(name='body'),
}

/**
 * @summary Queries Container Registry instances.
 *
 * @param request ListInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstanceResponse
 */
async function listInstanceWithOptions(request: ListInstanceRequest, runtime: $RuntimeOptions): ListInstanceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!$isNull(request.instanceStatus)) {
    query['InstanceStatus'] = request.instanceStatus;
  }
  if (!$isNull(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListInstance',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries Container Registry instances.
 *
 * @param request ListInstanceRequest
 * @return ListInstanceResponse
 */
async function listInstance(request: ListInstanceRequest): ListInstanceResponse {
  var runtime = new $RuntimeOptions{};
  return listInstanceWithOptions(request, runtime);
}

model ListInstanceEndpointRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  moduleName?: string(name='ModuleName', description='The name of the module that you want to access. Valid values:

*   `Registry`: image repositories.
*   `Chart`: Helm charts.', example='Chart'),
  summary?: boolean(name='Summary', description='Specify whether to return endpoints in simple mode. If yes, no access control information about the endpoint is returned.', example='false'),
}

model ListInstanceEndpointResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  endpoints?: [ 
    {
      aclEnable?: boolean(name='AclEnable', description='Indicates whether the endpoint is added to an access control list (ACL).', example='true'),
      aclEntries?: [ 
        {
          entry?: string(name='Entry', description='The information about the ACL.', example='null'),
        }
      ](name='AclEntries', description='The ACLs that are configured for the instance.'),
      domains?: [ 
        {
          domain?: string(name='Domain', description='The domain name of the Container Registry instance.', example='t****-registry.cn-shanghai.cr.aliyuncs.com'),
          type?: string(name='Type', description='The type of the domain name. Valid values:

*   SYSTEM: system domain name.
*   USER: user domain name.', example='SYSTEM'),
        }
      ](name='Domains', description='The list of domain names of the Container Registry instance.'),
      enable?: boolean(name='Enable', description='Indicates whether the endpoint is added to an ACL.', example='true'),
      endpointType?: string(name='EndpointType', description='The type of the endpoint.', example='internet'),
      linkedVpcs?: [ 
        {
          vpcId?: string(name='VpcId', description='VPC ID', example='null'),
        }
      ](name='LinkedVpcs', description='The VPCs associated with the instance.'),
      status?: string(name='Status', description='The status of the endpoint.', example='RUNNING'),
    }
  ](name='Endpoints', description='The endpoints of the instance.'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='1B21A877-66A2-4095-90EB-20A7781A4A67'),
}

model ListInstanceEndpointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceEndpointResponseBody(name='body'),
}

/**
 * @summary Queries the endpoints of a Container Registry instance.
 *
 * @param request ListInstanceEndpointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstanceEndpointResponse
 */
async function listInstanceEndpointWithOptions(request: ListInstanceEndpointRequest, runtime: $RuntimeOptions): ListInstanceEndpointResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!$isNull(request.summary)) {
    query['Summary'] = request.summary;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListInstanceEndpoint',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the endpoints of a Container Registry instance.
 *
 * @param request ListInstanceEndpointRequest
 * @return ListInstanceEndpointResponse
 */
async function listInstanceEndpoint(request: ListInstanceEndpointRequest): ListInstanceEndpointResponse {
  var runtime = new $RuntimeOptions{};
  return listInstanceEndpointWithOptions(request, runtime);
}

model ListInstanceRegionRequest {
  lang?: string(name='Lang', description='The language used for response parameters. Set this parameter to `zh-CN`.', example='zh-CN'),
}

model ListInstanceRegionResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  regions?: [ 
    {
      localName?: string(name='LocalName', description='The name of the region.', example='China (Shenzhen)'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-shenzhen'),
    }
  ](name='Regions', description='The list of regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='11F182E1-0F84-4F5B-8D3B-61E991482727'),
}

model ListInstanceRegionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceRegionResponseBody(name='body'),
}

/**
 * @summary Queries regions in which you can create Container Registry instances.
 *
 * @param request ListInstanceRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstanceRegionResponse
 */
async function listInstanceRegionWithOptions(request: ListInstanceRegionRequest, runtime: $RuntimeOptions): ListInstanceRegionResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListInstanceRegion',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries regions in which you can create Container Registry instances.
 *
 * @param request ListInstanceRegionRequest
 * @return ListInstanceRegionResponse
 */
async function listInstanceRegion(request: ListInstanceRegionRequest): ListInstanceRegionResponse {
  var runtime = new $RuntimeOptions{};
  return listInstanceRegionWithOptions(request, runtime);
}

model ListNamespaceRequest {
  instanceId?: string(name='InstanceId', description='The number of the page to return.

This parameter is required.', example='cri-94klsruryslx****'),
  namespaceName?: string(name='NamespaceName', description='The number of entries returned per page.', example='test-namespace'),
  namespaceStatus?: string(name='NamespaceStatus', description='The ID of the namespace.', example='NORMAL'),
  pageNo?: int32(name='PageNo', description='The list of namespaces.', example='1'),
  pageSize?: int32(name='PageSize', description='The ID of the request.', example='30'),
}

model ListNamespaceResponseBody = {
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  namespaces?: [ 
    {
      autoCreateRepo?: boolean(name='AutoCreateRepo', example='true'),
      defaultRepoType?: string(name='DefaultRepoType', example='PUBLIC'),
      instanceId?: string(name='InstanceId', example='cri-94klsruryslx****'),
      namespaceId?: string(name='NamespaceId', example='crn-tiw8t3f8i5lt****'),
      namespaceName?: string(name='NamespaceName', example='test'),
      namespaceStatus?: string(name='NamespaceStatus', example='NORMAL'),
      resourceGroupId?: string(name='ResourceGroupId', example='rg-acfm4n5kzyf2fbi'),
    }
  ](name='Namespaces'),
  pageNo?: int32(name='PageNo', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='B7E5FCA5-55ED-451C-9649-0BB2B93387D0'),
  totalCount?: string(name='TotalCount', example='1'),
}

model ListNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListNamespaceResponseBody(name='body'),
}

/**
 * @summary cri-94klsruryslx****
 *
 * @param request ListNamespaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNamespaceResponse
 */
async function listNamespaceWithOptions(request: ListNamespaceRequest, runtime: $RuntimeOptions): ListNamespaceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!$isNull(request.namespaceStatus)) {
    query['NamespaceStatus'] = request.namespaceStatus;
  }
  if (!$isNull(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary cri-94klsruryslx****
 *
 * @param request ListNamespaceRequest
 * @return ListNamespaceResponse
 */
async function listNamespace(request: ListNamespaceRequest): ListNamespaceResponse {
  var runtime = new $RuntimeOptions{};
  return listNamespaceWithOptions(request, runtime);
}

model ListRepoBuildRecordRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
  repoId?: string(name='RepoId', description='The ID of the repository.

This parameter is required.', example='crr-tquyps22md8****'),
}

model ListRepoBuildRecordResponseBody = {
  buildRecords?: [ 
    {
      buildRecordId?: string(name='BuildRecordId', description='The ID of the image building record.', example='537e08ab-735e-415f-b7c2-160eb87f8****'),
      buildStatus?: string(name='BuildStatus', description='The status of the image building.', example='SUCCESS'),
      endTime?: string(name='EndTime', description='The time when the image building ended.', example='1572875610000'),
      image?: {
        imageTag?: string(name='ImageTag', description='The tag of the image.', example='v0.1'),
        repoId?: string(name='RepoId', description='The ID of the repository.', example='crr-gzsrlevmvoaq****'),
        repoName?: string(name='RepoName', description='The name of the repository.', example='test'),
        repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.', example='test'),
      }(name='Image', description='The information about the image.'),
      startTime?: string(name='StartTime', description='The time when the image building started.', example='1572872207000'),
    }
  ](name='BuildRecords', description='The list of image building records.'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9D23DEDF-E91D-434B-B7D5-9D12C648D166'),
  totalCount?: string(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListRepoBuildRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRepoBuildRecordResponseBody(name='body'),
}

/**
 * @summary Queries image building records of an image repository.
 *
 * @param request ListRepoBuildRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRepoBuildRecordResponse
 */
async function listRepoBuildRecordWithOptions(request: ListRepoBuildRecordRequest, runtime: $RuntimeOptions): ListRepoBuildRecordResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRepoBuildRecord',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries image building records of an image repository.
 *
 * @param request ListRepoBuildRecordRequest
 * @return ListRepoBuildRecordResponse
 */
async function listRepoBuildRecord(request: ListRepoBuildRecordRequest): ListRepoBuildRecordResponse {
  var runtime = new $RuntimeOptions{};
  return listRepoBuildRecordWithOptions(request, runtime);
}

model ListRepoBuildRecordLogRequest {
  buildRecordId?: string(name='BuildRecordId', description='The ID of the image building record.

This parameter is required.', example='C5B4D5D7-A1C6-4E9B-ABD2-401361C4****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-nmbv37dlv5d3****'),
  offset?: int32(name='Offset', description='The offset of log lines.', example='0'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-z4dvahhku9wv4****'),
}

model ListRepoBuildRecordLogResponseBody = {
  buildRecordLogs?: [ 
    {
      buildStage?: string(name='BuildStage', description='The stage of the building that is recorded in the log entry.', example='GIT_CLONE'),
      lineNumber?: int32(name='LineNumber', description='The line number of the log entry.', example='2'),
      message?: string(name='Message', description='The content of the log.', example='fetch stage begin'),
    }
  ](name='BuildRecordLogs', description='The log content of the image building record.'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='100'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4CE1F661-75DD-4EBD-A4AD-057B26834ABB'),
  totalCount?: string(name='TotalCount', description='The total number of returned entries.', example='1000'),
}

model ListRepoBuildRecordLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRepoBuildRecordLogResponseBody(name='body'),
}

/**
 * @summary Queries the log of an image building record.
 *
 * @param request ListRepoBuildRecordLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRepoBuildRecordLogResponse
 */
async function listRepoBuildRecordLogWithOptions(request: ListRepoBuildRecordLogRequest, runtime: $RuntimeOptions): ListRepoBuildRecordLogResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.buildRecordId)) {
    query['BuildRecordId'] = request.buildRecordId;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.offset)) {
    query['Offset'] = request.offset;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRepoBuildRecordLog',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the log of an image building record.
 *
 * @param request ListRepoBuildRecordLogRequest
 * @return ListRepoBuildRecordLogResponse
 */
async function listRepoBuildRecordLog(request: ListRepoBuildRecordLogRequest): ListRepoBuildRecordLogResponse {
  var runtime = new $RuntimeOptions{};
  return listRepoBuildRecordLogWithOptions(request, runtime);
}

model ListRepoBuildRuleRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

This parameter is required.', example='crr-tquyps22md8****'),
}

model ListRepoBuildRuleResponseBody = {
  buildRules?: [ 
    {
      buildArgs?: [ string ](name='BuildArgs'),
      buildRuleId?: string(name='BuildRuleId', description='The ID of the image building rule.', example='crbr-khys0nd3asbe****'),
      dockerfileLocation?: string(name='DockerfileLocation', description='The directory of the Dockerfile.', example='/'),
      dockerfileName?: string(name='DockerfileName', description='The name of the Dockerfile.', example='Dockerfile'),
      imageTag?: string(name='ImageTag', description='The tag of the image.', example='v0.1'),
      platforms?: [ string ](name='Platforms'),
      pushName?: string(name='PushName', description='The name of the push that triggers the building rule.', example='v0.1'),
      pushType?: string(name='PushType', description='The type of the push that triggers the image building rule. Valid values:

*   GIT_BRANCH: branch push
*   GIT_TAG: tag push', example='GIT_BRANCH'),
    }
  ](name='BuildRules', description='The list of image building rules.'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='42D782C8-E8F6-4A32-BEA0-6A6AC854C22A'),
  totalCount?: string(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListRepoBuildRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRepoBuildRuleResponseBody(name='body'),
}

/**
 * @summary Queries image building rules of a repository.
 *
 * @param request ListRepoBuildRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRepoBuildRuleResponse
 */
async function listRepoBuildRuleWithOptions(request: ListRepoBuildRuleRequest, runtime: $RuntimeOptions): ListRepoBuildRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRepoBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries image building rules of a repository.
 *
 * @param request ListRepoBuildRuleRequest
 * @return ListRepoBuildRuleResponse
 */
async function listRepoBuildRule(request: ListRepoBuildRuleRequest): ListRepoBuildRuleResponse {
  var runtime = new $RuntimeOptions{};
  return listRepoBuildRuleWithOptions(request, runtime);
}

model ListRepoSyncRuleRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test-namespace'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
  repoName?: string(name='RepoName', description='The name of the image repository.', example='test-repo'),
  targetInstanceId?: string(name='TargetInstanceId', description='The ID of the destination instance.', example='cri-k77rd2eo9ztt****'),
  targetRegionId?: string(name='TargetRegionId', description='The region ID of the destination instance.', example='cn-shenzhen'),
}

model ListRepoSyncRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='838D1602-6D8F-47FB-B60A-656645D2****'),
  syncRules?: [ 
    {
      createTime?: long(name='CreateTime', description='The time when the synchronization rule was created.', example='1572604642000'),
      crossUser?: boolean(name='CrossUser', description='Indicates whether the synchronization is performed across Alibaba Cloud accounts. Valid values:

*   `true`: Images are synchronized across Alibaba Cloud accounts.
*   `false`: Images are synchronized within the same Alibaba Cloud account.

Default value: `false`.', example='true'),
      localInstanceId?: string(name='LocalInstanceId', description='The ID of the source instance.', example='cri-kmsiwlxxdcva****'),
      localNamespaceName?: string(name='LocalNamespaceName', description='The name of the namespace in the source instance.', example='test'),
      localRegionId?: string(name='LocalRegionId', description='The region ID of the source instance.', example='cn-shanghai'),
      localRepoName?: string(name='LocalRepoName', description='The name of the repository in the source instance.', example='test-repo-local'),
      modifiedTime?: long(name='ModifiedTime', description='The time when the synchronization rule was last modified.', example='1572604642000'),
      repoNameFilter?: string(name='RepoNameFilter', description='The regular expression that is used to filter repositories.

>  This parameter is valid only when SyncScope is set to `NAMESPACE`.', example='.*'),
      syncDirection?: string(name='SyncDirection', description='The synchronization direction. Valid values:

*   `FROM`: Images are synchronized from the source instance to the destination instance.
*   `TO`: Images are synchronized from the destination instance to the source instance.', example='FROM'),
      syncRuleId?: string(name='SyncRuleId', description='The ID of the synchronization rule.', example='crsr-7lph66uloi6h****'),
      syncRuleName?: string(name='SyncRuleName', description='The name of the synchronization rule.', example='sync-rule-1'),
      syncScope?: string(name='SyncScope', description='The synchronization scope. Valid values:

*   `NAMESPACE`: synchronizes the image tags in a namespace that meet the synchronization rule.
*   `REPO`: synchronizes the image tags in an image repository that meet the synchronization rule.', example='NAMESPACE'),
      syncTrigger?: string(name='SyncTrigger', description='The policy that is applied to trigger the synchronization rule. Valid values:

*   `INITIATIVE`: The synchronization rule is positively triggered.
*   `PASSIVE`: The synchronization rule is passively triggered.', example='PASSIVE'),
      tagFilter?: string(name='TagFilter', description='The regular expression that is used to filter image tags.', example='.*'),
      targetInstanceId?: string(name='TargetInstanceId', description='The ID of the destination instance.', example='cri-k77rd2eo9ztt****'),
      targetNamespaceName?: string(name='TargetNamespaceName', description='The name of the namespace in the destination instance.', example='test'),
      targetRegionId?: string(name='TargetRegionId', description='The region ID of the destination instance.', example='cn-shenzhen'),
      targetRepoName?: string(name='TargetRepoName', description='The name of the repository in the destination instance.', example='test-repo-target'),
    }
  ](name='SyncRules', description='The queried synchronization rules.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListRepoSyncRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRepoSyncRuleResponseBody(name='body'),
}

/**
 * @summary Queries image synchronization rules of a repository.
 *
 * @param request ListRepoSyncRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRepoSyncRuleResponse
 */
async function listRepoSyncRuleWithOptions(request: ListRepoSyncRuleRequest, runtime: $RuntimeOptions): ListRepoSyncRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!$isNull(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.targetInstanceId)) {
    query['TargetInstanceId'] = request.targetInstanceId;
  }
  if (!$isNull(request.targetRegionId)) {
    query['TargetRegionId'] = request.targetRegionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRepoSyncRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries image synchronization rules of a repository.
 *
 * @param request ListRepoSyncRuleRequest
 * @return ListRepoSyncRuleResponse
 */
async function listRepoSyncRule(request: ListRepoSyncRuleRequest): ListRepoSyncRuleResponse {
  var runtime = new $RuntimeOptions{};
  return listRepoSyncRuleWithOptions(request, runtime);
}

model ListRepoSyncTaskRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='cri-kmsiwlxxdcva****'),
  pageNo?: int32(name='PageNo', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  repoName?: string(name='RepoName', example='test'),
  repoNamespaceName?: string(name='RepoNamespaceName', example='ns'),
  syncRecordId?: string(name='SyncRecordId', description='The ID of the synchronization task record, which is the same as SyncBatchTaskId in the response.

>  If an image meets multiple synchronization rules and multiple synchronization tasks are generated for the image, these synchronization tasks use the same SyncBatchTaskId.', example='crsr-7lph66uloi6h****'),
  tag?: string(name='Tag', example='nginx'),
}

model ListRepoSyncTaskResponseBody = {
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  pageNo?: int32(name='PageNo', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  requestId?: string(name='RequestId', example='7640819A-FB5B-4E25-A227-97717F62****'),
  syncTasks?: [ 
    {
      createTime?: long(name='CreateTime', example='1572839126000'),
      crossUser?: boolean(name='CrossUser', example='true'),
      customLink?: boolean(name='CustomLink', example='true'),
      imageFrom?: {
        imageTag?: string(name='ImageTag', example='v0.1'),
        instanceId?: string(name='InstanceId', example='cri-kmsiwlxxdcva****'),
        regionId?: string(name='RegionId', example='cn-shanghai'),
        repoName?: string(name='RepoName', example='test'),
        repoNamespaceName?: string(name='RepoNamespaceName', example='test'),
      }(name='ImageFrom'),
      imageTo?: {
        imageTag?: string(name='ImageTag', example='v0.1'),
        instanceId?: string(name='InstanceId', example='cri-k77rd2eo9zttneqo'),
        regionId?: string(name='RegionId', example='cn-shenzhen'),
        repoName?: string(name='RepoName', example='test'),
        repoNamespaceName?: string(name='RepoNamespaceName', example='test'),
      }(name='ImageTo'),
      modifedTime?: long(name='ModifedTime', example='1572839133000'),
      syncBatchTaskId?: string(name='SyncBatchTaskId', example='15DEEB56-9271-4FDD-AC4D-C3A5CC2C****'),
      syncRuleId?: string(name='SyncRuleId', example='crsr-7lph66uloi6h****'),
      syncTaskId?: string(name='SyncTaskId', example='rst-4kfd7fk6pohk****'),
      syncTransAccelerate?: boolean(name='SyncTransAccelerate', example='true'),
      taskIssue?: string(name='TaskIssue', description='The error message that is returned if the synchronization task fails.

>  The system uses this parameter to return an error message if the synchronization task fails.

Valid values:

*   OSS_POLICY_UNAUTHORIZED: Container Registry is not granted permissions to use Object Storage Service (OSS).
*   TAG_CONFLICT: The destination repository contains an image that has the same tag as the source image, and image tag immutability is enabled for the destination repository.
*   UNSUPPORTED_FORMAT: The manifest and config formats of the image to be synchronized are not supported.
*   INTERNAL_ERROR: The synchronization task failed due to internal issues on the server.
*   NETWORK_ERROR: The synchronization task failed due to unstable network connection.
*   DATA_LENGTH_EXCEEDED: The manifest or config of the image is oversized.', example='NETWORK_ERROR'),
      taskStatus?: string(name='TaskStatus', description='The status of the synchronization task.', example='SUCCESS'),
      taskTrigger?: string(name='TaskTrigger', example='PASSIVE'),
    }
  ](name='SyncTasks', description='Details about synchronization tasks.'),
  totalCount?: string(name='TotalCount', example='1'),
}

model ListRepoSyncTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRepoSyncTaskResponseBody(name='body'),
}

/**
 * @summary Indicates whether automatic link is used.
 *
 * @param request ListRepoSyncTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRepoSyncTaskResponse
 */
async function listRepoSyncTaskWithOptions(request: ListRepoSyncTaskRequest, runtime: $RuntimeOptions): ListRepoSyncTaskResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!$isNull(request.syncRecordId)) {
    query['SyncRecordId'] = request.syncRecordId;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRepoSyncTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Indicates whether automatic link is used.
 *
 * @param request ListRepoSyncTaskRequest
 * @return ListRepoSyncTaskResponse
 */
async function listRepoSyncTask(request: ListRepoSyncTaskRequest): ListRepoSyncTaskResponse {
  var runtime = new $RuntimeOptions{};
  return listRepoSyncTaskWithOptions(request, runtime);
}

model ListRepoTagRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
  repoId?: string(name='RepoId', description='The ID of the repository.

This parameter is required.', example='crr-tquyps22md8p****'),
}

model ListRepoTagResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  images?: [ 
    {
      digest?: string(name='Digest', description='The digest of the image.', example='67bfbcc12b67936ec7f867927817cbb071832b873dbcaed312a1930ba5f1****'),
      imageCreate?: string(name='ImageCreate', description='The time when the image was created.', example='1572839125000'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='45023655bf39c382e26a8607d057c27871dee163c1ecf48cc1ebf2a1****'),
      imageSize?: long(name='ImageSize', description='The size of the image.', example='27107966'),
      imageUpdate?: string(name='ImageUpdate', description='The time when the image was last updated.', example='1572875608000'),
      status?: string(name='Status', description='The status of the image.', example='NORMAL'),
      tag?: string(name='Tag', description='The tag of the image.', example='v0.1'),
    }
  ](name='Images', description='The images.'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='031572FA-7D8F-4C05-B790-1071E0E05DE6'),
  totalCount?: string(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListRepoTagResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRepoTagResponseBody(name='body'),
}

/**
 * @summary Queries image tags in a repository.
 *
 * @param request ListRepoTagRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRepoTagResponse
 */
async function listRepoTagWithOptions(request: ListRepoTagRequest, runtime: $RuntimeOptions): ListRepoTagResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRepoTag',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries image tags in a repository.
 *
 * @param request ListRepoTagRequest
 * @return ListRepoTagResponse
 */
async function listRepoTag(request: ListRepoTagRequest): ListRepoTagResponse {
  var runtime = new $RuntimeOptions{};
  return listRepoTagWithOptions(request, runtime);
}

model ListRepoTagScanResultRequest {
  digest?: string(name='Digest', description='The digest of the image.', example='sha256:6b0b094f8a904f8fb6602427aed0d1fa'),
  filterValue?: string(name='FilterValue', description='The parameter whose value that you want to query. Fox example, if the value is `FixCmd`, only the `FixCmd` parameter is returned.', example='FixCmd'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-2j88dtld8yel****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-uf082u9dg8do****'),
  scanTaskId?: string(name='ScanTaskId', description='The ID of the security scan task.', example='6b0b094f-8a90-4f8f-b660-2427aed0****'),
  scanType?: string(name='ScanType', description='The type of the vulnerability. Valid values:

*   `cve`: image system vulnerability
*   `sca`: image application vulnerability', example='sca'),
  severity?: string(name='Severity', description='The severity of the vulnerability. Valid values:

*   `High`
*   `Medium`
*   `Low`
*   `Unknown`', example='High'),
  tag?: string(name='Tag', description='The name of the image tag.', example='1'),
  vulQueryKey?: string(name='VulQueryKey', description='The keyword for fuzzy search used in scanning. The value can be a CVE name.', example='CVE-2021'),
}

model ListRepoTagScanResultResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request failed.', example='true'),
  pageNo?: int32(name='PageNo', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='56B5C92F-F5D9-46E0-823F-EC71D1892DAA'),
  totalCount?: int32(name='TotalCount', description='The total number of vulnerabilities detected on images.', example='196'),
  vulnerabilities?: [ 
    {
      addedBy?: string(name='AddedBy', description='The ID of the image layer where the vulnerability was detected.', example='sha256:123456717b8e40b6480979b739010d8d549989602bcdd07922119aec6f9dbe57'),
      aliasName?: string(name='AliasName', description='The name of the vulnerability.', example='Vulnerability'),
      cveLink?: string(name='CveLink', description='The URL of the vulnerability.', example='https://security-tracker.debian.org/tracker/CVE-2009-5155'),
      cveLocation?: string(name='CveLocation', description='The directory of the vulnerability.', example='/test.txt'),
      cveName?: string(name='CveName', description='The name of the vulnerability.', example='CVE-2009-5155'),
      description?: string(name='Description', description='The description of the vulnerability.', example='description.'),
      feature?: string(name='Feature', description='The cause of the vulnerability.', example='eglibc'),
      fixCmd?: string(name='FixCmd', description='The command used to fix the vulnerability.', example='yum install -y xxx'),
      scanType?: string(name='ScanType', description='The type of the vulnerability. Valid values:

*   `cve`: image system vulnerability
*   `sca`: image application vulnerability', example='cve'),
      severity?: string(name='Severity', description='The severity of the vulnerability.', example='Medium'),
      version?: string(name='Version', description='The version of the vulnerability.', example='2.19-6.9'),
      versionFixed?: string(name='VersionFixed', description='The version where the vulnerability was fixed.', example='2.19-18+deb8u5'),
      versionFormat?: string(name='VersionFormat', description='The format of the vulnerability.', example='dpkg'),
    }
  ](name='Vulnerabilities', description='The details about the detected vulnerabilities.'),
}

model ListRepoTagScanResultResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRepoTagScanResultResponseBody(name='body'),
}

/**
 * @summary Queries the results of a security scan that is created for an image tag.
 *
 * @param request ListRepoTagScanResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRepoTagScanResultResponse
 */
async function listRepoTagScanResultWithOptions(request: ListRepoTagScanResultRequest, runtime: $RuntimeOptions): ListRepoTagScanResultResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!$isNull(request.filterValue)) {
    query['FilterValue'] = request.filterValue;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!$isNull(request.scanTaskId)) {
    query['ScanTaskId'] = request.scanTaskId;
  }
  if (!$isNull(request.scanType)) {
    query['ScanType'] = request.scanType;
  }
  if (!$isNull(request.severity)) {
    query['Severity'] = request.severity;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!$isNull(request.vulQueryKey)) {
    query['VulQueryKey'] = request.vulQueryKey;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRepoTagScanResult',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the results of a security scan that is created for an image tag.
 *
 * @param request ListRepoTagScanResultRequest
 * @return ListRepoTagScanResultResponse
 */
async function listRepoTagScanResult(request: ListRepoTagScanResultRequest): ListRepoTagScanResultResponse {
  var runtime = new $RuntimeOptions{};
  return listRepoTagScanResultWithOptions(request, runtime);
}

model ListRepoTriggerRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', description='The ID of the repository.

This parameter is required.', example='crr-tquyps22md8p****'),
}

model ListRepoTriggerResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2CA76D52-A8F0-4D0B-854E-FBD9F6C99049'),
  triggers?: [ 
    {
      repoEvent?: string(name='RepoEvent', description='The type of the event that activates the trigger. Valid values:

*   `BUILD_SUCCESS`: The trigger is activated when an image building task is successful.
*   `BUILD_Fail`: The trigger is activated when an image building task fails.', example='BUILD_SUCCESS'),
      triggerId?: string(name='TriggerId', description='The ID of the trigger.', example='crw-vriyql9eq7ep****'),
      triggerName?: string(name='TriggerName', description='The name of the trigger.', example='test'),
      triggerTag?: string(name='TriggerTag', description='The image tag based on which the trigger is set.', example='*'),
      triggerType?: string(name='TriggerType', description='The type of the trigger. Valid values:

*   `ALL`: a trigger that supports both tags and regular expressions.
*   `TAG_LISTTAG`: a tag-based trigger.
*   `TAG_REG_EXP`: a regular expression-based trigger.', example='ALL'),
      triggerUrl?: string(name='TriggerUrl', description='The URL of the trigger.', example='https://www.test.com'),
    }
  ](name='Triggers', description='The triggers of the repository.'),
}

model ListRepoTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRepoTriggerResponseBody(name='body'),
}

/**
 * @summary Queries the triggers of a repository.
 *
 * @param request ListRepoTriggerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRepoTriggerResponse
 */
async function listRepoTriggerWithOptions(request: ListRepoTriggerRequest, runtime: $RuntimeOptions): ListRepoTriggerResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRepoTrigger',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the triggers of a repository.
 *
 * @param request ListRepoTriggerRequest
 * @return ListRepoTriggerResponse
 */
async function listRepoTrigger(request: ListRepoTriggerRequest): ListRepoTriggerResponse {
  var runtime = new $RuntimeOptions{};
  return listRepoTriggerWithOptions(request, runtime);
}

model ListRepositoryRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='cri-kmsiwlxxdcva****'),
  pageNo?: int32(name='PageNo', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 100. If you specify a value larger than 100 for this parameter, the system reports a parameter error or uses 100 as the maximum value.', example='30'),
  repoName?: string(name='RepoName', example='repo-test'),
  repoNamespaceName?: string(name='RepoNamespaceName', example='repo-namespace-test'),
  repoStatus?: string(name='RepoStatus', example='ALL'),
}

model ListRepositoryResponseBody = {
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  pageNo?: int32(name='PageNo', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  repositories?: [ 
    {
      createTime?: long(name='CreateTime', example='1564153576000'),
      instanceId?: string(name='InstanceId', example='cri-kmsiwlxxdcv****'),
      modifiedTime?: long(name='ModifiedTime', example='1564153576000'),
      repoBuildType?: string(name='RepoBuildType', example='MANUAL'),
      repoId?: string(name='RepoId', example='crr-03cuozrsqhkw****'),
      repoName?: string(name='RepoName', example='test'),
      repoNamespaceName?: string(name='RepoNamespaceName', example='test'),
      repoStatus?: string(name='RepoStatus', example='NORMAL'),
      repoType?: string(name='RepoType', example='PRIVATE'),
      resourceGroupId?: string(name='ResourceGroupId', example='rg-acfm4n5kzyfxxxx'),
      summary?: string(name='Summary', example='test OK'),
      tagImmutability?: boolean(name='TagImmutability', example='true'),
    }
  ](name='Repositories'),
  requestId?: string(name='RequestId', example='5241C090-DA69-4B0F-8E3F-2F24FDE1110E'),
  totalCount?: string(name='TotalCount', example='1'),
}

model ListRepositoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRepositoryResponseBody(name='body'),
}

/**
 * @summary Queries image repositories.
 *
 * @param request ListRepositoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRepositoryResponse
 */
async function listRepositoryWithOptions(request: ListRepositoryRequest, runtime: $RuntimeOptions): ListRepositoryResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!$isNull(request.repoStatus)) {
    query['RepoStatus'] = request.repoStatus;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries image repositories.
 *
 * @param request ListRepositoryRequest
 * @return ListRepositoryResponse
 */
async function listRepository(request: ListRepositoryRequest): ListRepositoryResponse {
  var runtime = new $RuntimeOptions{};
  return listRepositoryWithOptions(request, runtime);
}

model ListScanBaselineByTaskRequest {
  digest?: string(name='Digest', description='The image digest.', example='sha256:1c89806cfaf66d2990e2cf1131ebd56ff24b133745a33abf1228*************'),
  instanceId?: string(name='InstanceId', description='The instance ID.', example='cri-***********'),
  level?: string(name='Level', description='The severity of the risk.', example='High'),
  pageNo?: int32(name='PageNo', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
  repoId?: string(name='RepoId', description='The repository ID.', example='crr-**************'),
  scanTaskId?: string(name='ScanTaskId', description='The ID of the image scan task.', example='3e526d7e-4b45-4703-b046-***********'),
  tag?: string(name='Tag', description='The image tag.', example='1.1.36'),
}

model ListScanBaselineByTaskResponseBody = {
  code?: int32(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API request is successful. Valid values:

*   `true`: successful
*   `false`: failed', example='true'),
  pageNo?: int32(name='PageNo', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
  requestId?: string(name='RequestId', description='Id of the request', example='5259118F-79E2-57E9-9AEA-551586F4FAED'),
  scanBaselines?: [ 
    {
      baselineClassAlias?: string(name='BaselineClassAlias', description='The category of the baseline risk.'),
      baselineDetailAdvice?: string(name='BaselineDetailAdvice', description='The suggestion on handling the baseline risk.'),
      baselineDetailDescription?: string(name='BaselineDetailDescription', description='The description of the baseline risk.'),
      baselineDetailPrompt?: string(name='BaselineDetailPrompt', description='The path and content of the baseline risk.', example='usr/local/www/project/environments/dev/common/config/paramsxxx'),
      baselineItemCount?: int32(name='BaselineItemCount', description='The number of baseline risks.', example='1'),
      baselineNameAlias?: string(name='BaselineNameAlias', description='The name of the baseline risk.'),
      baselineNameKey?: string(name='BaselineNameKey', description='The name of the baseline risk.', example='ak_leak'),
      baselineNameLevel?: string(name='BaselineNameLevel', description='The severity of the baseline risk.', example='high'),
      createTime?: long(name='CreateTime', description='The time when the image was created.', example='1695090008000'),
      firstScanTime?: long(name='FirstScanTime', description='The time when the image was first scanned.', example='2024-04-10 15:33:26'),
      highRiskItemCount?: int32(name='HighRiskItemCount', description='The quantity of baseline risks whose severity is high.', example='1'),
      lowRiskItemCount?: int32(name='LowRiskItemCount', description='The quantity of baseline risks whose severity is low.', example='1'),
      middleRiskItemCount?: int32(name='MiddleRiskItemCount', description='The quantity of baseline risks whose severity is medium.', example='1'),
      scanTaskId?: string(name='ScanTaskId', description='The ID of the image scan task.', example='2328fcaa-f28a-405d-a357-asdvfrew23'),
      updateTime?: long(name='UpdateTime', description='The time when the image was updated.', example='1684220824226'),
    }
  ](name='ScanBaselines', description='The queried baseline risks.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListScanBaselineByTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListScanBaselineByTaskResponseBody(name='body'),
}

/**
 * @summary Queries the baseline risks of a scan task by page.
 *
 * @description Before you call this operation, use a Security Center scan engine to scan the image.
 *
 * @param request ListScanBaselineByTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListScanBaselineByTaskResponse
 */
async function listScanBaselineByTaskWithOptions(request: ListScanBaselineByTaskRequest, runtime: $RuntimeOptions): ListScanBaselineByTaskResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListScanBaselineByTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the baseline risks of a scan task by page.
 *
 * @description Before you call this operation, use a Security Center scan engine to scan the image.
 *
 * @param request ListScanBaselineByTaskRequest
 * @return ListScanBaselineByTaskResponse
 */
async function listScanBaselineByTask(request: ListScanBaselineByTaskRequest): ListScanBaselineByTaskResponse {
  var runtime = new $RuntimeOptions{};
  return listScanBaselineByTaskWithOptions(request, runtime);
}

model ListScanMaliciousFileByTaskRequest {
  digest?: string(name='Digest', description='The image digest.', example='sha256:aa4bffff6406785e930dab1f94c9a1297ba22xxxx71d71504a015764*********'),
  instanceId?: string(name='InstanceId', description='The instance ID.', example='cri-gu94qynvpwk*****'),
  level?: string(name='Level', description='The severity of the malicious file.', example='High'),
  pageNo?: int32(name='PageNo', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Maximum value: 100. If you specify a value greater than 100 for this parameter, the system reports a parameter error or uses 100 as the maximum value.', example='30'),
  repoId?: string(name='RepoId', description='The image repository ID.', example='crr-h1y4l279wb8*****'),
  scanTaskId?: string(name='ScanTaskId', description='The ID of the image scan task.', example='79ee6bc2-3288-4c56-b967-**********'),
  tag?: string(name='Tag', description='The image tag.', example='V6.11'),
}

model ListScanMaliciousFileByTaskResponseBody = {
  code?: int32(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API request is successful. Valid values:

*   `true`: successful
*   `false`: failed', example='true'),
  pageNo?: int32(name='PageNo', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='52AE49C8-B91A-5C1A-821F-C34324B42F7C'),
  scanMaliciousFiles?: [ 
    {
      createTime?: long(name='CreateTime', description='The time when the image was created.', example='2023-04-10 11:42:06'),
      filePath?: string(name='FilePath', description='The path of the file.', example='tenant/0000000000000000/'),
      firstScanTime?: long(name='FirstScanTime', description='The time when the image was first scanned.', example='2023-04-10 11:42:06'),
      level?: string(name='Level', description='The severity of the malicious file.', example='remind'),
      maliciousMd5?: string(name='MaliciousMd5', description='The MD5 hash value of the malicious file.', example='e76c9759783cbbc9be0ff91ca3xxxxxx'),
      maliciousName?: string(name='MaliciousName', description='The type of the malicious file.', example='Suspected to contain Webshell code'),
      scanTaskId?: string(name='ScanTaskId', description='The ID of the image scan task.', example='fe2d8980-de45-4f55-b57d-e438e6d2e972'),
      updateTime?: long(name='UpdateTime', description='The time when the image was updated.', example='2023-04-10 11:42:06'),
    }
  ](name='ScanMaliciousFiles', description='The queried malicious files.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='13'),
}

model ListScanMaliciousFileByTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListScanMaliciousFileByTaskResponseBody(name='body'),
}

/**
 * @summary Queries the malicious files of a scan task by page.
 *
 * @description Before you call this operation, use a Security Center scan engine to scan the image.
 *
 * @param request ListScanMaliciousFileByTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListScanMaliciousFileByTaskResponse
 */
async function listScanMaliciousFileByTaskWithOptions(request: ListScanMaliciousFileByTaskRequest, runtime: $RuntimeOptions): ListScanMaliciousFileByTaskResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListScanMaliciousFileByTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the malicious files of a scan task by page.
 *
 * @description Before you call this operation, use a Security Center scan engine to scan the image.
 *
 * @param request ListScanMaliciousFileByTaskRequest
 * @return ListScanMaliciousFileByTaskResponse
 */
async function listScanMaliciousFileByTask(request: ListScanMaliciousFileByTaskRequest): ListScanMaliciousFileByTaskResponse {
  var runtime = new $RuntimeOptions{};
  return listScanMaliciousFileByTaskWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request or if no next query exists. You must specify the token that is obtained from the previous query as the value of NextToken.', example='AAAAAfj+3fkqd8igM6VLaQjlaYc='),
  regionId?: string(name='RegionId', description='The ID of the region in which the resources are deployed.

This parameter is required.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs. You can specify a maximum of 20 resource IDs.'),
  resourceType?: string(name='ResourceType', description='The type of the resources. Instance resources are supported.

This parameter is required.', example='Instance'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key of the resource. You can specify up to 20 tag keys. The tag key cannot be an empty string.

A tag key can be up to 128 characters in length. It cannot start with acs: or aliyun, and cannot contain http:// or https://.', example='test-key'),
      value?: string(name='Value', description='The tag value of the resource. You can specify up to 20 tag values. The tag value can be an empty string.

It can be up to 128 characters in length. It cannot start with acs: or aliyun and cannot contain http:// or https://.', example='test-val'),
    }
  ](name='Tag', description='The tag list.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.', example='AAAAAfj+3fkqd8igM6VLaQjlaYc='),
  requestId?: string(name='RequestId', description='The request ID.', example='7FF809ED-B42F-5AC3-9A17-CFE14BE32A8E'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId', description='The resource ID.', example='cri-w19e7qr2wibl****'),
      resourceType?: string(name='ResourceType', description='The resource type.', example='Instance'),
      tagKey?: string(name='TagKey', description='The tag key.', example='test-key'),
      tagValue?: string(name='TagValue', description='The tag value.', example='test-val'),
    }
  ](name='TagResource')
  }(name='TagResources', description='The tags that are added to the resource.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
 * @summary Queries the tags that are added to cloud resources. Instance resources are supported.
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: $RuntimeOptions): ListTagResourcesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListTagResources',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the tags that are added to cloud resources. Instance resources are supported.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ResetLoginPasswordRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  password?: string(name='Password', description='The new password that you specify to log on to the instance. The password must be 8 to 32 bits in length, and must contain at least two of the following character types: letters, special characters, and digits.

This parameter is required.', example='test'),
}

model ResetLoginPasswordResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EB9C5722-51E2-4497-A573-575B0CA5CE0C'),
}

model ResetLoginPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetLoginPasswordResponseBody(name='body'),
}

/**
 * @summary Resets the logon password of a Container Registry instance.
 *
 * @param request ResetLoginPasswordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetLoginPasswordResponse
 */
async function resetLoginPasswordWithOptions(request: ResetLoginPasswordRequest, runtime: $RuntimeOptions): ResetLoginPasswordResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.password)) {
    query['Password'] = request.password;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ResetLoginPassword',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Resets the logon password of a Container Registry instance.
 *
 * @param request ResetLoginPasswordRequest
 * @return ResetLoginPasswordResponse
 */
async function resetLoginPassword(request: ResetLoginPasswordRequest): ResetLoginPasswordResponse {
  var runtime = new $RuntimeOptions{};
  return resetLoginPasswordWithOptions(request, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId', description='The region ID of the resources.

This parameter is required.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs. You can specify a maximum of 20 resource IDs.

This parameter is required.'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Instance resources are supported.

This parameter is required.', example='Instance'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key of the resource. You can specify up to 20 tag keys. The tag key cannot be an empty string.

A tag key can be up to 128 characters in length. It cannot start with acs: or aliyun, and cannot contain http:// or https://.', example='test-key'),
      value?: string(name='Value', description='The tag value of the resource. You can specify up to 20 tag values. The tag value can be an empty string.

A tag value can be up to 128 characters in length. It cannot start with acs: or aliyun, and cannot contain http:// or https://.', example='test-val'),
    }
  ](name='Tag', description='The tag list.

This parameter is required.'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='E9A586D0-3977-5C28-A44D-55D3A9CD53CC'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
 * @summary Adds tags to resources. Instance resources are supported.
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: $RuntimeOptions): TagResourcesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'TagResources',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds tags to resources. Instance resources are supported.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags from the resource. Valid values:

*   **true**
*   **false**

>If you specify both this parameter and the TagKey parameter, this parameter does not take effect.', example='true'),
  regionId?: string(name='RegionId', description='The ID of the region in which the resources are deployed.

This parameter is required.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs. You can specify a maximum of 20 resource IDs.'),
  resourceType?: string(name='ResourceType', description='The type of the resources. Instance resources are supported.

This parameter is required.', example='Instance'),
  tagKey?: [ string ](name='TagKey', description='The key of tag N added to the resource. Valid values of N: 1 to 20.'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='724402D0-75CD-4794-BC20-7D3720823AE0'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
 * @summary Removes tags from resources. Instance resources are supported.
 *
 * @param request UntagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: $RuntimeOptions): UntagResourcesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.all)) {
    query['All'] = request.all;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UntagResources',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Removes tags from resources. Instance resources are supported.
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateArtifactLifecycleRuleRequest {
  auto?: boolean(name='Auto', description='Specifies whether to automatically execute the lifecycle management rule.', example='false'),
  enableDeleteTag?: boolean(name='EnableDeleteTag', description='Specifies whether to enable lifecycle management for the artifact.', example='true'),
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-r6ym0lerldp****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test-ns'),
  repoName?: string(name='RepoName', description='The name of the image repository.', example='test_1'),
  retentionTagCount?: long(name='RetentionTagCount', description='The number of images that you want to retain.', example='30'),
  ruleId?: string(name='RuleId', description='The rule ID.

This parameter is required.', example='cralr-luq6qiegzvx****'),
  scheduleTime?: string(name='ScheduleTime', description='The execution cycle of the lifecycle management rule.', example='WEEK'),
  scope?: string(name='Scope', description='The deletion scope of artifacts.', example='REPO'),
  tagRegexp?: string(name='TagRegexp', description='The regular expression that indicates which image tags you want to retain.', example='.*production_.*'),
}

model UpdateArtifactLifecycleRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='BF92FC2E-455F-5600-A276-D2150A59****'),
}

model UpdateArtifactLifecycleRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateArtifactLifecycleRuleResponseBody(name='body'),
}

/**
 * @summary Updates a lifecycle management rule of an artifact.
 *
 * @param request UpdateArtifactLifecycleRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateArtifactLifecycleRuleResponse
 */
async function updateArtifactLifecycleRuleWithOptions(request: UpdateArtifactLifecycleRuleRequest, runtime: $RuntimeOptions): UpdateArtifactLifecycleRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.auto)) {
    query['Auto'] = request.auto;
  }
  if (!$isNull(request.enableDeleteTag)) {
    query['EnableDeleteTag'] = request.enableDeleteTag;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.retentionTagCount)) {
    query['RetentionTagCount'] = request.retentionTagCount;
  }
  if (!$isNull(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!$isNull(request.scheduleTime)) {
    query['ScheduleTime'] = request.scheduleTime;
  }
  if (!$isNull(request.scope)) {
    query['Scope'] = request.scope;
  }
  if (!$isNull(request.tagRegexp)) {
    query['TagRegexp'] = request.tagRegexp;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateArtifactLifecycleRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates a lifecycle management rule of an artifact.
 *
 * @param request UpdateArtifactLifecycleRuleRequest
 * @return UpdateArtifactLifecycleRuleResponse
 */
async function updateArtifactLifecycleRule(request: UpdateArtifactLifecycleRuleRequest): UpdateArtifactLifecycleRuleResponse {
  var runtime = new $RuntimeOptions{};
  return updateArtifactLifecycleRuleWithOptions(request, runtime);
}

model UpdateArtifactSubscriptionRuleRequest {
  accelerate?: string(name='Accelerate', description='Specifies whether to enable an acceleration link for image subscription. The subscription acceleration feature is in public preview. The feature is optimized based on scheduling policies and network links to accelerate image subscription.', example='true'),
  instanceId?: string(name='InstanceId', description='The instance ID.

This parameter is required.', example='cri-c0o11woew0k****'),
  namespaceName?: string(name='NamespaceName', description='The name of the Container Registry namespace.', example='test-ns'),
  override?: string(name='Override', description='Specifies whether to overwrite the original image.', example='true'),
  platform?: [ string ](name='Platform', description='The operating system and architecture. If the source repository contains multi-arch images, only the images with the specified operating system and architecture are subscribed to the destination repository of the Enterprise Edition instance.'),
  repoName?: string(name='RepoName', description='The name of the Container Registry repository.', example='test-repo'),
  ruleId?: string(name='RuleId', description='The rule ID.

This parameter is required.', example='crasr-mdbpung4i1rm****'),
  sourceNamespaceName?: string(name='SourceNamespaceName', description='The name of the source namespace.', example='library'),
  sourceProvider?: string(name='SourceProvider', description='The source of the artifacts.

Valid values:

*   DOCKER_HUB: Docker Hub
*   GCR: GCR
*   QUAY: Quay.io', example='DOCKER_HUB'),
  sourceRepoName?: string(name='SourceRepoName', description='The source repository.', example='nginx'),
  tagCount?: long(name='TagCount', description='The number of subscribed images.', example='1', nullable=false),
  tagRegexp?: string(name='TagRegexp', description='The image tags in the subscription source repository. Regular expressions are supported.', example='release-v.*'),
}

model UpdateArtifactSubscriptionRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='02B27D80-FD32-5155-931A-93700779BB9E'),
}

model UpdateArtifactSubscriptionRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateArtifactSubscriptionRuleResponseBody(name='body'),
}

/**
 * @summary Updates an artifact subscription rule.
 *
 * @param request UpdateArtifactSubscriptionRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateArtifactSubscriptionRuleResponse
 */
async function updateArtifactSubscriptionRuleWithOptions(request: UpdateArtifactSubscriptionRuleRequest, runtime: $RuntimeOptions): UpdateArtifactSubscriptionRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accelerate)) {
    query['Accelerate'] = request.accelerate;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!$isNull(request.override)) {
    query['Override'] = request.override;
  }
  if (!$isNull(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!$isNull(request.sourceNamespaceName)) {
    query['SourceNamespaceName'] = request.sourceNamespaceName;
  }
  if (!$isNull(request.sourceProvider)) {
    query['SourceProvider'] = request.sourceProvider;
  }
  if (!$isNull(request.sourceRepoName)) {
    query['SourceRepoName'] = request.sourceRepoName;
  }
  if (!$isNull(request.tagCount)) {
    query['TagCount'] = request.tagCount;
  }
  if (!$isNull(request.tagRegexp)) {
    query['TagRegexp'] = request.tagRegexp;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateArtifactSubscriptionRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates an artifact subscription rule.
 *
 * @param request UpdateArtifactSubscriptionRuleRequest
 * @return UpdateArtifactSubscriptionRuleResponse
 */
async function updateArtifactSubscriptionRule(request: UpdateArtifactSubscriptionRuleRequest): UpdateArtifactSubscriptionRuleResponse {
  var runtime = new $RuntimeOptions{};
  return updateArtifactSubscriptionRuleWithOptions(request, runtime);
}

model UpdateChainRequest {
  chainConfig?: string(name='ChainConfig', description='The configuration of the delivery chain in the JSON format.

This parameter is required.', example='chainconfig'),
  chainId?: string(name='ChainId', description='The ID of the delivery chain.

This parameter is required.', example='chi-02ymhtwl3cq8****'),
  description?: string(name='Description', description='The description of the delivery chain.', example='description'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-4cdrlqmhn4gm****'),
  name?: string(name='Name', description='The name of the delivery chain.

This parameter is required.', example='test'),
  scopeExclude?: [ string ](name='ScopeExclude', description='Repositories in which the delivery chain does not take effect.'),
}

model UpdateChainResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='85A99B10-3926-5201-958E-C06FA47F****'),
}

model UpdateChainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateChainResponseBody(name='body'),
}

/**
 * @summary Updates the information about a delivery chain, such as the node execution sequence of the delivery chain.
 *
 * @param request UpdateChainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateChainResponse
 */
async function updateChainWithOptions(request: UpdateChainRequest, runtime: $RuntimeOptions): UpdateChainResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.chainConfig)) {
    query['ChainConfig'] = request.chainConfig;
  }
  if (!$isNull(request.chainId)) {
    query['ChainId'] = request.chainId;
  }
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.scopeExclude)) {
    query['ScopeExclude'] = request.scopeExclude;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateChain',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates the information about a delivery chain, such as the node execution sequence of the delivery chain.
 *
 * @param request UpdateChainRequest
 * @return UpdateChainResponse
 */
async function updateChain(request: UpdateChainRequest): UpdateChainResponse {
  var runtime = new $RuntimeOptions{};
  return updateChainWithOptions(request, runtime);
}

model UpdateChartNamespaceRequest {
  autoCreateRepo?: boolean(name='AutoCreateRepo', description='Specifies whether to automatically create repositories in the namespace. Valid values:

*   `true`: automatically creates repositories in the namespace.
*   `false`: does not automatically create repositories in the namespace.', example='true'),
  defaultRepoType?: string(name='DefaultRepoType', description='The default type of the repository. Valid values:

*   `PUBLIC`: a public repository
*   `PRIVATE`: a private repository', example='PUBLIC'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace to which the repository belongs.

This parameter is required.', example='test'),
}

model UpdateChartNamespaceResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API request is successful. Valid values:

*   `true`: successful
*   `false`: failed', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='6877B80A-2895-44C4-BC9E-703B157DEE66'),
}

model UpdateChartNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateChartNamespaceResponseBody(name='body'),
}

/**
 * @summary Updates a chart namespace.
 *
 * @param request UpdateChartNamespaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateChartNamespaceResponse
 */
async function updateChartNamespaceWithOptions(request: UpdateChartNamespaceRequest, runtime: $RuntimeOptions): UpdateChartNamespaceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.autoCreateRepo)) {
    query['AutoCreateRepo'] = request.autoCreateRepo;
  }
  if (!$isNull(request.defaultRepoType)) {
    query['DefaultRepoType'] = request.defaultRepoType;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateChartNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates a chart namespace.
 *
 * @param request UpdateChartNamespaceRequest
 * @return UpdateChartNamespaceResponse
 */
async function updateChartNamespace(request: UpdateChartNamespaceRequest): UpdateChartNamespaceResponse {
  var runtime = new $RuntimeOptions{};
  return updateChartNamespaceWithOptions(request, runtime);
}

model UpdateChartRepositoryRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  repoName?: string(name='RepoName', description='The name of the repository.

This parameter is required.', example='test'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.

This parameter is required.', example='test'),
  repoType?: string(name='RepoType', description='The type of the repository. Valid values:

*   `PUBLIC`: a public repository.
*   `PRIVATE`: a private repository.', example='PUBLIC'),
  summary?: string(name='Summary', description='The summary of the repository.', example='test'),
}

model UpdateChartRepositoryResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EB9C5722-51E2-4497-A573-575B0CA5CE0C'),
}

model UpdateChartRepositoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateChartRepositoryResponseBody(name='body'),
}

/**
 * @summary Updates a chart repository of a Container Registry instance.
 *
 * @param request UpdateChartRepositoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateChartRepositoryResponse
 */
async function updateChartRepositoryWithOptions(request: UpdateChartRepositoryRequest, runtime: $RuntimeOptions): UpdateChartRepositoryResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!$isNull(request.repoType)) {
    query['RepoType'] = request.repoType;
  }
  if (!$isNull(request.summary)) {
    query['Summary'] = request.summary;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateChartRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates a chart repository of a Container Registry instance.
 *
 * @param request UpdateChartRepositoryRequest
 * @return UpdateChartRepositoryResponse
 */
async function updateChartRepository(request: UpdateChartRepositoryRequest): UpdateChartRepositoryResponse {
  var runtime = new $RuntimeOptions{};
  return updateChartRepositoryWithOptions(request, runtime);
}

model UpdateEventCenterRuleRequest {
  eventChannel?: string(name='EventChannel', description='The event notification channel.', example='EVENT_BRIDGE'),
  eventConfig?: string(name='EventConfig', description='The event configuration.', example='{
        "notifyMethod":"http",
        "notifyConfig":{
            "Url":"http://www.aliyundoc.com",
            "id":"MaAV3HgTkO5Fh8l1V********",
        },
        "notifyFilter":{}
    }'),
  eventScope?: string(name='EventScope', description='The event scope. Valid values:

*   `INSTANCE`
*   `NAMESPACE`
*   `REPO`

Default value: `INSTANCE`', example='INSTANCE'),
  eventType?: string(name='EventType', description='The type of the event. Valid values:

*   `cr:Artifact:DeliveryChainCompleted`: The delivery chain is processed.
*   `cr:Artifact:SynchronizationCompleted`: The image is replicated.
*   `cr:Artifact:BuildCompleted`: The image is built.
*   `cr:Artifact:ScanCompleted`: The image is scanned.
*   `cr:Artifact:SigningCompleted`: The image is signed.', example='cr:Artifact:DeliveryChainCompleted'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  namespaces?: [ string ](name='Namespaces', description='The namespaces to which the event notification rule applies.', example='ns'),
  repoNames?: [ string ](name='RepoNames', description='The names of the repositories to which the event notification rule applies.', example='reponame'),
  repoTagFilterPattern?: string(name='RepoTagFilterPattern', description='The regular expression for image tags.', example='.*'),
  ruleId?: string(name='RuleId', description='The ID of the event notification rule.

This parameter is required.', example='crecr-n6pbhgjxt*****'),
  ruleName?: string(name='RuleName', description='The name of the event notification rule.', example='chain-demo'),
}

model UpdateEventCenterRuleShrinkRequest {
  eventChannel?: string(name='EventChannel', description='The event notification channel.', example='EVENT_BRIDGE'),
  eventConfig?: string(name='EventConfig', description='The event configuration.', example='{
        "notifyMethod":"http",
        "notifyConfig":{
            "Url":"http://www.aliyundoc.com",
            "id":"MaAV3HgTkO5Fh8l1V********",
        },
        "notifyFilter":{}
    }'),
  eventScope?: string(name='EventScope', description='The event scope. Valid values:

*   `INSTANCE`
*   `NAMESPACE`
*   `REPO`

Default value: `INSTANCE`', example='INSTANCE'),
  eventType?: string(name='EventType', description='The type of the event. Valid values:

*   `cr:Artifact:DeliveryChainCompleted`: The delivery chain is processed.
*   `cr:Artifact:SynchronizationCompleted`: The image is replicated.
*   `cr:Artifact:BuildCompleted`: The image is built.
*   `cr:Artifact:ScanCompleted`: The image is scanned.
*   `cr:Artifact:SigningCompleted`: The image is signed.', example='cr:Artifact:DeliveryChainCompleted'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  namespacesShrink?: string(name='Namespaces', description='The namespaces to which the event notification rule applies.', example='ns'),
  repoNamesShrink?: string(name='RepoNames', description='The names of the repositories to which the event notification rule applies.', example='reponame'),
  repoTagFilterPattern?: string(name='RepoTagFilterPattern', description='The regular expression for image tags.', example='.*'),
  ruleId?: string(name='RuleId', description='The ID of the event notification rule.

This parameter is required.', example='crecr-n6pbhgjxt*****'),
  ruleName?: string(name='RuleName', description='The name of the event notification rule.', example='chain-demo'),
}

model UpdateEventCenterRuleResponseBody = {
  code?: int32(name='Code', description='The status code.', example='200'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='031572FA-7D8F-4C05-B790-1071E0E05DE6'),
  ruleId?: string(name='RuleId', description='The ID of the event notification rule.', example='crecr-n6pbhgjxt*****'),
}

model UpdateEventCenterRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEventCenterRuleResponseBody(name='body'),
}

/**
 * @summary Updates an event notification rule.
 *
 * @param tmpReq UpdateEventCenterRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEventCenterRuleResponse
 */
async function updateEventCenterRuleWithOptions(tmpReq: UpdateEventCenterRuleRequest, runtime: $RuntimeOptions): UpdateEventCenterRuleResponse {
  tmpReq.validate();
  var request = new UpdateEventCenterRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.namespaces)) {
    request.namespacesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.namespaces, 'Namespaces', 'json');
  }
  if (!$isNull(tmpReq.repoNames)) {
    request.repoNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.repoNames, 'RepoNames', 'json');
  }
  var query = {};
  if (!$isNull(request.eventChannel)) {
    query['EventChannel'] = request.eventChannel;
  }
  if (!$isNull(request.eventConfig)) {
    query['EventConfig'] = request.eventConfig;
  }
  if (!$isNull(request.eventScope)) {
    query['EventScope'] = request.eventScope;
  }
  if (!$isNull(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespacesShrink)) {
    query['Namespaces'] = request.namespacesShrink;
  }
  if (!$isNull(request.repoNamesShrink)) {
    query['RepoNames'] = request.repoNamesShrink;
  }
  if (!$isNull(request.repoTagFilterPattern)) {
    query['RepoTagFilterPattern'] = request.repoTagFilterPattern;
  }
  if (!$isNull(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!$isNull(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateEventCenterRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates an event notification rule.
 *
 * @param request UpdateEventCenterRuleRequest
 * @return UpdateEventCenterRuleResponse
 */
async function updateEventCenterRule(request: UpdateEventCenterRuleRequest): UpdateEventCenterRuleResponse {
  var runtime = new $RuntimeOptions{};
  return updateEventCenterRuleWithOptions(request, runtime);
}

model UpdateInstanceEndpointStatusRequest {
  enable?: boolean(name='Enable', description='Specifies whether to enable the instance endpoint. Valid values:

*   `true`: enables the instance endpoint.
*   `false`: disables the instance endpoint

This parameter is required.', example='false'),
  endpointType?: string(name='EndpointType', description='The type of the endpoint. Set the value to Internet.

This parameter is required.', example='internet'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  moduleName?: string(name='ModuleName', description='The name of the module that you want to access. Valid values:

*   `Registry`: the image repository.
*   `Chart`: a Helm chart.', example='Chart'),
}

model UpdateInstanceEndpointStatusResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FC14396-A16A-42BA-AAE4-BB94D956DF09'),
}

model UpdateInstanceEndpointStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateInstanceEndpointStatusResponseBody(name='body'),
}

/**
 * @summary Updates the status of an instance endpoint.
 *
 * @param request UpdateInstanceEndpointStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateInstanceEndpointStatusResponse
 */
async function updateInstanceEndpointStatusWithOptions(request: UpdateInstanceEndpointStatusRequest, runtime: $RuntimeOptions): UpdateInstanceEndpointStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!$isNull(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateInstanceEndpointStatus',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates the status of an instance endpoint.
 *
 * @param request UpdateInstanceEndpointStatusRequest
 * @return UpdateInstanceEndpointStatusResponse
 */
async function updateInstanceEndpointStatus(request: UpdateInstanceEndpointStatusRequest): UpdateInstanceEndpointStatusResponse {
  var runtime = new $RuntimeOptions{};
  return updateInstanceEndpointStatusWithOptions(request, runtime);
}

model UpdateNamespaceRequest {
  autoCreateRepo?: boolean(name='AutoCreateRepo', description='Specifies whether to automatically create a repository when an image is pushed to the namespace.', example='true'),
  defaultRepoType?: string(name='DefaultRepoType', description='The default type of the repository. Valid values:

*   `PUBLIC`: The repository is a public repository.
*   `PRIVATE`: The repository is a private repository.', example='PRIVATE'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.

This parameter is required.', example='test'),
}

model UpdateNamespaceResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='90B8475C-C066-4B92-946E-4D0DECB514E8'),
}

model UpdateNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateNamespaceResponseBody(name='body'),
}

/**
 * @summary Updates a namespace.
 *
 * @param request UpdateNamespaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNamespaceResponse
 */
async function updateNamespaceWithOptions(request: UpdateNamespaceRequest, runtime: $RuntimeOptions): UpdateNamespaceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.autoCreateRepo)) {
    query['AutoCreateRepo'] = request.autoCreateRepo;
  }
  if (!$isNull(request.defaultRepoType)) {
    query['DefaultRepoType'] = request.defaultRepoType;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates a namespace.
 *
 * @param request UpdateNamespaceRequest
 * @return UpdateNamespaceResponse
 */
async function updateNamespace(request: UpdateNamespaceRequest): UpdateNamespaceResponse {
  var runtime = new $RuntimeOptions{};
  return updateNamespaceWithOptions(request, runtime);
}

model UpdateRepoBuildRuleRequest {
  buildArgs?: [ string ](name='BuildArgs', description='Building arguments.'),
  buildRuleId?: string(name='BuildRuleId', description='The ID of the building rule.

This parameter is required.', example='crbr-ly77w5i3t31f****'),
  dockerfileLocation?: string(name='DockerfileLocation', description='The path of the Dockerfile.', example='/'),
  dockerfileName?: string(name='DockerfileName', description='The name of the Dockerfile.', example='Dockerfile'),
  imageTag?: string(name='ImageTag', description='The tag of the image.', example='v0.9.5'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  platforms?: [ string ](name='Platforms', description='Architecture for image building. Valid values:

*   `linux/amd64`
*   `linux/arm64`
*   `linux/386`
*   `linux/arm/v7`
*   `linux/arm/v6`

Default value: `linux/amd64`', example='linux/amd64'),
  pushName?: string(name='PushName', description='The name of the push that triggers the building rule.', example='master'),
  pushType?: string(name='PushType', description='The type of the push that triggers the building rule. Valid values:

*   `GIT_TAG`: tag push
*   `GIT_BRANCH`: branch push', example='GIT_BRANCH'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

This parameter is required.', example='crr-tquyps22md8p****'),
}

model UpdateRepoBuildRuleResponseBody = {
  buildRuleId?: string(name='BuildRuleId', description='The ID of the building rule.', example='crbr-ly77w5i3t31f****'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BC648259-91A7-4502-BED3-EDF64361FA83'),
}

model UpdateRepoBuildRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRepoBuildRuleResponseBody(name='body'),
}

/**
 * @summary Updates an image building rule for a repository.
 *
 * @param request UpdateRepoBuildRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRepoBuildRuleResponse
 */
async function updateRepoBuildRuleWithOptions(request: UpdateRepoBuildRuleRequest, runtime: $RuntimeOptions): UpdateRepoBuildRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.buildArgs)) {
    query['BuildArgs'] = request.buildArgs;
  }
  if (!$isNull(request.buildRuleId)) {
    query['BuildRuleId'] = request.buildRuleId;
  }
  if (!$isNull(request.dockerfileLocation)) {
    query['DockerfileLocation'] = request.dockerfileLocation;
  }
  if (!$isNull(request.dockerfileName)) {
    query['DockerfileName'] = request.dockerfileName;
  }
  if (!$isNull(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.platforms)) {
    query['Platforms'] = request.platforms;
  }
  if (!$isNull(request.pushName)) {
    query['PushName'] = request.pushName;
  }
  if (!$isNull(request.pushType)) {
    query['PushType'] = request.pushType;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateRepoBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates an image building rule for a repository.
 *
 * @param request UpdateRepoBuildRuleRequest
 * @return UpdateRepoBuildRuleResponse
 */
async function updateRepoBuildRule(request: UpdateRepoBuildRuleRequest): UpdateRepoBuildRuleResponse {
  var runtime = new $RuntimeOptions{};
  return updateRepoBuildRuleWithOptions(request, runtime);
}

model UpdateRepoSourceCodeRepoRequest {
  autoBuild?: string(name='AutoBuild', description='Specifies whether to enable automatic image building when code is committed. Valid values:

*   `true`: enables automatic image building when code is committed.
*   `false`: disables automatic image building when code is committed.', example='true'),
  codeRepoId?: string(name='CodeRepoId', description='The ID of the source code repository.', example='crr-cp7d6sget5r****'),
  codeRepoName?: string(name='CodeRepoName', description='The name of the source code repository.

This parameter is required.', example='repo'),
  codeRepoNamespaceName?: string(name='CodeRepoNamespaceName', description='The namespace to which the source code repository belongs.

This parameter is required.', example='namespace'),
  codeRepoType?: string(name='CodeRepoType', description='The type of the source code hosting platform. Valid values: GITHUB, GITLAB, GITEE, CODE, and CODEUP.

This parameter is required.', example='GITHUB'),
  disableCacheBuild?: string(name='DisableCacheBuild', description='Specifies whether to disable building caches. Valid values:

*   `true`: disables building caches.
*   `false`: enables building caches.', example='false'),
  instanceId?: string(name='InstanceId', description='The ID of the Container Registry Enterprise Edition instance.

This parameter is required.', example='cri-shac42yvqzvq****'),
  overseaBuild?: string(name='OverseaBuild', description='Specifies whether to enable Build With Servers Deployed Outside Chinese Mainland. Valid values:

*   `true`: enables Build With Servers Deployed Outside Chinese Mainland.
*   `false`: disables Build With Servers Deployed Outside Chinese Mainland.', example='false'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

This parameter is required.', example='crr-gzsrlevmvoa****'),
}

model UpdateRepoSourceCodeRepoResponseBody = {
  code?: string(name='Code', description='The return value.', example='200'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F56D589D-AF7F-4900-BA46-62C780AC2C10'),
}

model UpdateRepoSourceCodeRepoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRepoSourceCodeRepoResponseBody(name='body'),
}

/**
 * @summary Updates the URL of the source code repository that is bound to an image repository.
 *
 * @param request UpdateRepoSourceCodeRepoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRepoSourceCodeRepoResponse
 */
async function updateRepoSourceCodeRepoWithOptions(request: UpdateRepoSourceCodeRepoRequest, runtime: $RuntimeOptions): UpdateRepoSourceCodeRepoResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.autoBuild)) {
    query['AutoBuild'] = request.autoBuild;
  }
  if (!$isNull(request.codeRepoId)) {
    query['CodeRepoId'] = request.codeRepoId;
  }
  if (!$isNull(request.codeRepoName)) {
    query['CodeRepoName'] = request.codeRepoName;
  }
  if (!$isNull(request.codeRepoNamespaceName)) {
    query['CodeRepoNamespaceName'] = request.codeRepoNamespaceName;
  }
  if (!$isNull(request.codeRepoType)) {
    query['CodeRepoType'] = request.codeRepoType;
  }
  if (!$isNull(request.disableCacheBuild)) {
    query['DisableCacheBuild'] = request.disableCacheBuild;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.overseaBuild)) {
    query['OverseaBuild'] = request.overseaBuild;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateRepoSourceCodeRepo',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates the URL of the source code repository that is bound to an image repository.
 *
 * @param request UpdateRepoSourceCodeRepoRequest
 * @return UpdateRepoSourceCodeRepoResponse
 */
async function updateRepoSourceCodeRepo(request: UpdateRepoSourceCodeRepoRequest): UpdateRepoSourceCodeRepoResponse {
  var runtime = new $RuntimeOptions{};
  return updateRepoSourceCodeRepoWithOptions(request, runtime);
}

model UpdateRepoTriggerRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.

This parameter is required.', example='crr-tquyps22md8p****'),
  triggerId?: string(name='TriggerId', description='The ID of the trigger.

This parameter is required.', example='crw-k7bdx4kt52ty****'),
  triggerName?: string(name='TriggerName', description='The name of the trigger.

You can specify the TriggerName or TriggerUrl parameter. The TriggerName parameter is optional.', example='test_trigger'),
  triggerTag?: string(name='TriggerTag', description='The image tag based on which the trigger is set.', example='master'),
  triggerType?: string(name='TriggerType', description='The type of the trigger. Valid values:

*   `ALL`: a trigger that supports both tags and regular expressions.
*   `TAG_LISTTAG`: a tag-based trigger.
*   `TAG_REG_EXP`: a regular expression-based trigger.', example='TAG_LIST'),
  triggerUrl?: string(name='TriggerUrl', description='The URL of the trigger.', example='https://www.test.com'),
}

model UpdateRepoTriggerResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='32535049-ED91-4589-98C0-7C88766EDF1F'),
}

model UpdateRepoTriggerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRepoTriggerResponseBody(name='body'),
}

/**
 * @summary Updates a trigger of an image repository.
 *
 * @param request UpdateRepoTriggerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRepoTriggerResponse
 */
async function updateRepoTriggerWithOptions(request: UpdateRepoTriggerRequest, runtime: $RuntimeOptions): UpdateRepoTriggerResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!$isNull(request.triggerId)) {
    query['TriggerId'] = request.triggerId;
  }
  if (!$isNull(request.triggerName)) {
    query['TriggerName'] = request.triggerName;
  }
  if (!$isNull(request.triggerTag)) {
    query['TriggerTag'] = request.triggerTag;
  }
  if (!$isNull(request.triggerType)) {
    query['TriggerType'] = request.triggerType;
  }
  if (!$isNull(request.triggerUrl)) {
    query['TriggerUrl'] = request.triggerUrl;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateRepoTrigger',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Updates a trigger of an image repository.
 *
 * @param request UpdateRepoTriggerRequest
 * @return UpdateRepoTriggerResponse
 */
async function updateRepoTrigger(request: UpdateRepoTriggerRequest): UpdateRepoTriggerResponse {
  var runtime = new $RuntimeOptions{};
  return updateRepoTriggerWithOptions(request, runtime);
}

model UpdateRepositoryRequest {
  detail?: string(name='Detail', example='repo-for-test'),
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', example='crr-tquyps22md8p****'),
  repoName?: string(name='RepoName', example='dsp/domain-microapp'),
  repoNamespaceName?: string(name='RepoNamespaceName', example='ejiayou-other'),
  repoType?: string(name='RepoType', description='This parameter is required.', example='PUBLIC'),
  summary?: string(name='Summary', description='This parameter is required.', example='test repo'),
  tagImmutability?: boolean(name='TagImmutability', example='true'),
}

model UpdateRepositoryResponseBody = {
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='CC43EC6B-0DD4-40AE-8811-B0519617051A'),
}

model UpdateRepositoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRepositoryResponseBody(name='body'),
}

/**
 * @summary The ID of the request.
 *
 * @param request UpdateRepositoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRepositoryResponse
 */
async function updateRepositoryWithOptions(request: UpdateRepositoryRequest, runtime: $RuntimeOptions): UpdateRepositoryResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.detail)) {
    query['Detail'] = request.detail;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!$isNull(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!$isNull(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!$isNull(request.repoType)) {
    query['RepoType'] = request.repoType;
  }
  if (!$isNull(request.summary)) {
    query['Summary'] = request.summary;
  }
  if (!$isNull(request.tagImmutability)) {
    query['TagImmutability'] = request.tagImmutability;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary The ID of the request.
 *
 * @param request UpdateRepositoryRequest
 * @return UpdateRepositoryResponse
 */
async function updateRepository(request: UpdateRepositoryRequest): UpdateRepositoryResponse {
  var runtime = new $RuntimeOptions{};
  return updateRepositoryWithOptions(request, runtime);
}

