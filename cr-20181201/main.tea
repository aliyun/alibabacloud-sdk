/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('cr', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CancelArtifactBuildTaskRequest {
  buildTaskId?: string(name='BuildTaskId', description='The ID of the artifact building task.', example='i2ei-12****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-shac42yvqzvq****'),
}

model CancelArtifactBuildTaskResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C4C7DD0C-C9D6-437A-A7EE-121EFD70D002'),
}

model CancelArtifactBuildTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelArtifactBuildTaskResponseBody(name='body'),
}

async function cancelArtifactBuildTaskWithOptions(request: CancelArtifactBuildTaskRequest, runtime: Util.RuntimeOptions): CancelArtifactBuildTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildTaskId)) {
    query['BuildTaskId'] = request.buildTaskId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelArtifactBuildTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelArtifactBuildTask(request: CancelArtifactBuildTaskRequest): CancelArtifactBuildTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelArtifactBuildTaskWithOptions(request, runtime);
}

model CancelRepoBuildRecordRequest {
  buildRecordId?: string(name='BuildRecordId', description='The ID of the image building record.', example='74FDBA62-30C0-4F22-BE7B-F1D36FD1****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-tquyps22md8p****'),
}

model CancelRepoBuildRecordResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4CE1F661-75DD-4EBD-A4AD-057B26834ABB'),
}

model CancelRepoBuildRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelRepoBuildRecordResponseBody(name='body'),
}

async function cancelRepoBuildRecordWithOptions(request: CancelRepoBuildRecordRequest, runtime: Util.RuntimeOptions): CancelRepoBuildRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildRecordId)) {
    query['BuildRecordId'] = request.buildRecordId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelRepoBuildRecord',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelRepoBuildRecord(request: CancelRepoBuildRecordRequest): CancelRepoBuildRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelRepoBuildRecordWithOptions(request, runtime);
}

model ChangeResourceGroupRequest {
  resourceGroupId?: string(name='ResourceGroupId', example='rg-aekz5nlvlaksnvi'),
  resourceId?: string(name='ResourceId', description='Id of the request', example='cri-8qong6ve5p3mhlgt'),
  resourceRegionId?: string(name='ResourceRegionId', example='cn-shenzhen-finance-1'),
}

model ChangeResourceGroupResponseBody = {
  requestId?: string(name='RequestId', example='314CB661-35A5-5F01-A623-3EC6F87FF52F'),
}

model ChangeResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeResourceGroupResponseBody(name='body'),
}

async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: Util.RuntimeOptions): ChangeResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceRegionId)) {
    query['ResourceRegionId'] = request.resourceRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeResourceGroup',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeResourceGroupWithOptions(request, runtime);
}

model CreateArtifactBuildRuleRequest {
  artifactType?: string(name='ArtifactType', example='ACCELERATED_IMAGE'),
  instanceId?: string(name='InstanceId', example='cri-cxreylqvcyje****'),
  parameters?: map[string]any(name='Parameters'),
  scopeId?: string(name='ScopeId', example='crr-pmajihou6cg0****'),
  scopeType?: string(name='ScopeType', example='REPOSITORY'),
}

model CreateArtifactBuildRuleShrinkRequest {
  artifactType?: string(name='ArtifactType', example='ACCELERATED_IMAGE'),
  instanceId?: string(name='InstanceId', example='cri-cxreylqvcyje****'),
  parametersShrink?: string(name='Parameters'),
  scopeId?: string(name='ScopeId', example='crr-pmajihou6cg0****'),
  scopeType?: string(name='ScopeType', example='REPOSITORY'),
}

model CreateArtifactBuildRuleResponseBody = {
  buildRuleId?: string(name='BuildRuleId', example='crabr-7dfa5qye5****'),
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='C8E90AB5-0A96-5D12-9E59-11EE46360642'),
}

model CreateArtifactBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateArtifactBuildRuleResponseBody(name='body'),
}

/**
  * The ID of the rule.
  *
  * @param tmpReq CreateArtifactBuildRuleRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateArtifactBuildRuleResponse
 */
async function createArtifactBuildRuleWithOptions(tmpReq: CreateArtifactBuildRuleRequest, runtime: Util.RuntimeOptions): CreateArtifactBuildRuleResponse {
  Util.validateModel(tmpReq);
  var request = new CreateArtifactBuildRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.parameters)) {
    request.parametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.parameters, 'Parameters', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.artifactType)) {
    query['ArtifactType'] = request.artifactType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.parametersShrink)) {
    query['Parameters'] = request.parametersShrink;
  }
  if (!Util.isUnset(request.scopeId)) {
    query['ScopeId'] = request.scopeId;
  }
  if (!Util.isUnset(request.scopeType)) {
    query['ScopeType'] = request.scopeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateArtifactBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The ID of the rule.
  *
  * @param request CreateArtifactBuildRuleRequest
  * @return CreateArtifactBuildRuleResponse
 */
async function createArtifactBuildRule(request: CreateArtifactBuildRuleRequest): CreateArtifactBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createArtifactBuildRuleWithOptions(request, runtime);
}

model CreateBuildRecordByRecordRequest {
  buildRecordId?: string(name='BuildRecordId', example='0A311FC5-B8C6-4332-80E4-539EB73****'),
  instanceId?: string(name='InstanceId', example='cri-hpdfkc6utbaq****'),
  repoId?: string(name='RepoId', example='crr-hnoq7j93or3k****'),
}

model CreateBuildRecordByRecordResponseBody = {
  buildRecordId?: string(name='BuildRecordId', example='crbr-ly77w5i3t31f****'),
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='4CE1F661-75DD-4EBD-A4AD-057B26834ABB'),
}

model CreateBuildRecordByRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBuildRecordByRecordResponseBody(name='body'),
}

async function createBuildRecordByRecordWithOptions(request: CreateBuildRecordByRecordRequest, runtime: Util.RuntimeOptions): CreateBuildRecordByRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildRecordId)) {
    query['BuildRecordId'] = request.buildRecordId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBuildRecordByRecord',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBuildRecordByRecord(request: CreateBuildRecordByRecordRequest): CreateBuildRecordByRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBuildRecordByRecordWithOptions(request, runtime);
}

model CreateBuildRecordByRuleRequest {
  buildRuleId?: string(name='BuildRuleId', description='The ID of the image building rule.', example='crbr-1j95g4bu2s1i****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-asd6vujuhay0****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-8dz3aedjqlmk****'),
}

model CreateBuildRecordByRuleResponseBody = {
  buildRecordId?: string(name='BuildRecordId', description='The ID of the image building record.', example='0A311FC5-B8C6-4332-80E4-539EB73****'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B01B8857-A16E-40E9-A37E-764F15776FAA'),
}

model CreateBuildRecordByRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBuildRecordByRuleResponseBody(name='body'),
}

async function createBuildRecordByRuleWithOptions(request: CreateBuildRecordByRuleRequest, runtime: Util.RuntimeOptions): CreateBuildRecordByRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildRuleId)) {
    query['BuildRuleId'] = request.buildRuleId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBuildRecordByRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBuildRecordByRule(request: CreateBuildRecordByRuleRequest): CreateBuildRecordByRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBuildRecordByRuleWithOptions(request, runtime);
}

model CreateChainRequest {
  chainConfig?: string(name='ChainConfig', description='The configuration of the delivery chain in the JSON format.', example='chainconfig'),
  description?: string(name='Description', description='The description of the delivery chain.', example='description'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-4cdrlqmhn4gm****'),
  name?: string(name='Name', description='The name of the delivery chain.', example='test'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='repo1'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.', example='ns1'),
  scopeExclude?: [ string ](name='ScopeExclude', description='Repositories in which the delivery chain does not take effect.'),
}

model CreateChainResponseBody = {
  chainId?: string(name='ChainId', description='The ID of the delivery chain.', example='chi-02ymhtwl3cq8****'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4BC03B36-E515-5806-99AC-268AE3C0****'),
}

model CreateChainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateChainResponseBody(name='body'),
}

async function createChainWithOptions(request: CreateChainRequest, runtime: Util.RuntimeOptions): CreateChainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chainConfig)) {
    query['ChainConfig'] = request.chainConfig;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.scopeExclude)) {
    query['ScopeExclude'] = request.scopeExclude;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateChain',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createChain(request: CreateChainRequest): CreateChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return createChainWithOptions(request, runtime);
}

model CreateChartNamespaceRequest {
  autoCreateRepo?: boolean(name='AutoCreateRepo', description='Specifies whether to automatically create repositories in the namespace. Valid values:

\\-`  true `: automatically creates repositories in the namespace.

\\-`  false `: does not automatically create repositories in the namespace.', example='true'),
  defaultRepoType?: string(name='DefaultRepoType', description='The default repository type. Valid values:

*   `PUBLIC`: a public repository
*   `PRIVATE`: a private repository', example='PUBLIC'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='namespace01'),
}

model CreateChartNamespaceResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='724402D0-75CD-4794-BC20-7D3720823AE0'),
}

model CreateChartNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateChartNamespaceResponseBody(name='body'),
}

async function createChartNamespaceWithOptions(request: CreateChartNamespaceRequest, runtime: Util.RuntimeOptions): CreateChartNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoCreateRepo)) {
    query['AutoCreateRepo'] = request.autoCreateRepo;
  }
  if (!Util.isUnset(request.defaultRepoType)) {
    query['DefaultRepoType'] = request.defaultRepoType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateChartNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createChartNamespace(request: CreateChartNamespaceRequest): CreateChartNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createChartNamespaceWithOptions(request, runtime);
}

model CreateChartRepositoryRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='repo01'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.', example='namespace01'),
  repoType?: string(name='RepoType', description='The default repository type. Valid values:

*   `PUBLIC`: a public repository.
*   `PRIVATE`: a private repository.

You can specify the RepoType or Summary parameter. The RepoType parameter is optional.', example='PUBLIC'),
  summary?: string(name='Summary', description='The summary of the repository.', example='summary'),
}

model CreateChartRepositoryResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  repoId?: string(name='RepoId', description='The ID of the repository.', example='crcr-2micxey5ewj4****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='60390244-A483-491A-B41D-F866C95380A1'),
}

model CreateChartRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateChartRepositoryResponseBody(name='body'),
}

async function createChartRepositoryWithOptions(request: CreateChartRepositoryRequest, runtime: Util.RuntimeOptions): CreateChartRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.repoType)) {
    query['RepoType'] = request.repoType;
  }
  if (!Util.isUnset(request.summary)) {
    query['Summary'] = request.summary;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateChartRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createChartRepository(request: CreateChartRepositoryRequest): CreateChartRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createChartRepositoryWithOptions(request, runtime);
}

model CreateInstanceEndpointAclPolicyRequest {
  comment?: string(name='Comment', description='The description.', example='test'),
  endpointType?: string(name='EndpointType', description='The type of the endpoint. Set the value to Internet.', example='internet'),
  entry?: string(name='Entry', description='The CIDR block that is accessible.', example='192.168.1.1/32'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  moduleName?: string(name='ModuleName', description='The name of the module that you want to access. Valid values:

*   `Registry`: the image repository.
*   `Chart`: a Helm chart.', example='Registry'),
}

model CreateInstanceEndpointAclPolicyResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='D735C5EC-4206-4F48-A090-307BF56BEB99'),
}

model CreateInstanceEndpointAclPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInstanceEndpointAclPolicyResponseBody(name='body'),
}

async function createInstanceEndpointAclPolicyWithOptions(request: CreateInstanceEndpointAclPolicyRequest, runtime: Util.RuntimeOptions): CreateInstanceEndpointAclPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!Util.isUnset(request.entry)) {
    query['Entry'] = request.entry;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstanceEndpointAclPolicy',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createInstanceEndpointAclPolicy(request: CreateInstanceEndpointAclPolicyRequest): CreateInstanceEndpointAclPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstanceEndpointAclPolicyWithOptions(request, runtime);
}

model CreateInstanceVpcEndpointLinkedVpcRequest {
  enableCreateDNSRecordInPvzt?: boolean(name='EnableCreateDNSRecordInPvzt', example='false'),
  instanceId?: string(name='InstanceId', example='cri-xkx6vujuhay0****'),
  moduleName?: string(name='ModuleName', example='Registry'),
  vpcId?: string(name='VpcId', example='vpc-uf6pa68zxnnlc48dd****'),
  vswitchId?: string(name='VswitchId', example='vsw-uf6u0kn8x2gbzxfn2****'),
}

model CreateInstanceVpcEndpointLinkedVpcResponseBody = {
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='D4978DCC-ECBD-40B0-A714-EE6959B22C77'),
}

model CreateInstanceVpcEndpointLinkedVpcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInstanceVpcEndpointLinkedVpcResponseBody(name='body'),
}

/**
  * The ID of the request.
  *
  * @param request CreateInstanceVpcEndpointLinkedVpcRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateInstanceVpcEndpointLinkedVpcResponse
 */
async function createInstanceVpcEndpointLinkedVpcWithOptions(request: CreateInstanceVpcEndpointLinkedVpcRequest, runtime: Util.RuntimeOptions): CreateInstanceVpcEndpointLinkedVpcResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enableCreateDNSRecordInPvzt)) {
    query['EnableCreateDNSRecordInPvzt'] = request.enableCreateDNSRecordInPvzt;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.vswitchId)) {
    query['VswitchId'] = request.vswitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstanceVpcEndpointLinkedVpc',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The ID of the request.
  *
  * @param request CreateInstanceVpcEndpointLinkedVpcRequest
  * @return CreateInstanceVpcEndpointLinkedVpcResponse
 */
async function createInstanceVpcEndpointLinkedVpc(request: CreateInstanceVpcEndpointLinkedVpcRequest): CreateInstanceVpcEndpointLinkedVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstanceVpcEndpointLinkedVpcWithOptions(request, runtime);
}

model CreateNamespaceRequest {
  autoCreateRepo?: boolean(name='AutoCreateRepo', description='Specifies whether to automatically create an image repository in the namespace.', example='true'),
  defaultRepoType?: string(name='DefaultRepoType', description='The default type of the repository that is automatically created. Valid values:

*   `PUBLIC`: a public repository
*   `PRIVATE`: a private repository', example='PUBLIC'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace. The name must be 2 to 120 characters in length, and can contain lowercase letters, digits, and the following delimiters: underscores (\\_), hyphens (-), and periods (.). The name cannot start or end with a delimiter.', example='namespace1'),
}

model CreateNamespaceResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BC648259-91A7-4502-BED3-EDF64361FA83'),
}

model CreateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNamespaceResponseBody(name='body'),
}

async function createNamespaceWithOptions(request: CreateNamespaceRequest, runtime: Util.RuntimeOptions): CreateNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoCreateRepo)) {
    query['AutoCreateRepo'] = request.autoCreateRepo;
  }
  if (!Util.isUnset(request.defaultRepoType)) {
    query['DefaultRepoType'] = request.defaultRepoType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNamespace(request: CreateNamespaceRequest): CreateNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNamespaceWithOptions(request, runtime);
}

model CreateRepoBuildRuleRequest {
  buildArgs?: [ string ](name='BuildArgs', description='Building arguments.'),
  dockerfileLocation?: string(name='DockerfileLocation', description='The path of the Dockerfile.', example='/'),
  dockerfileName?: string(name='DockerfileName', description='The name of the Dockerfile.', example='Dockerfile'),
  imageTag?: string(name='ImageTag', description='The tag of the image.', example='v0.9.5'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  platforms?: [ string ](name='Platforms', description='Architecture for image building. Valid values:

*   `linux/amd64`
*   `linux/arm64`
*   `linux/386`
*   `linux/arm/v7`
*   `inux/arm/v6`

Default value: `linux/amd64`'),
  pushName?: string(name='PushName', description='The name of the push that triggers the building rule.', example='master'),
  pushType?: string(name='PushType', description='The type of the push that triggers the building rule. Valid values:

*   `GIT_TAG`: tag push
*   `GIT_BRANCH`: branch push', example='GIT_BRANCH'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-8dz3aedjqlmk****'),
}

model CreateRepoBuildRuleResponseBody = {
  buildRuleId?: string(name='BuildRuleId', description='The ID of the building rule.', example='crbr-ly77w5i3t31f****'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4CE1F661-75DD-4EBD-A4AD-057B26834ABB'),
}

model CreateRepoBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoBuildRuleResponseBody(name='body'),
}

async function createRepoBuildRuleWithOptions(request: CreateRepoBuildRuleRequest, runtime: Util.RuntimeOptions): CreateRepoBuildRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildArgs)) {
    query['BuildArgs'] = request.buildArgs;
  }
  if (!Util.isUnset(request.dockerfileLocation)) {
    query['DockerfileLocation'] = request.dockerfileLocation;
  }
  if (!Util.isUnset(request.dockerfileName)) {
    query['DockerfileName'] = request.dockerfileName;
  }
  if (!Util.isUnset(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.platforms)) {
    query['Platforms'] = request.platforms;
  }
  if (!Util.isUnset(request.pushName)) {
    query['PushName'] = request.pushName;
  }
  if (!Util.isUnset(request.pushType)) {
    query['PushType'] = request.pushType;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoBuildRule(request: CreateRepoBuildRuleRequest): CreateRepoBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoBuildRuleWithOptions(request, runtime);
}

model CreateRepoSourceCodeRepoRequest {
  autoBuild?: boolean(name='AutoBuild', description='Specifies whether to trigger image building when source code is committed. Valid values:

*   `true`: triggers image building when source code is committed.
*   `false`: does not trigger image building when source code is committed.', example='true'),
  codeRepoName?: string(name='CodeRepoName', description='The name of the source code repository.', example='repo'),
  codeRepoNamespaceName?: string(name='CodeRepoNamespaceName', description='The namespace to which the source code repository belongs.', example='namespace'),
  codeRepoType?: string(name='CodeRepoType', description='The type of the source code hosting platform. Valid values: `GITHUB`, `GITLAB`, `GITEE`, `CODE`, and `CODEUP`.', example='GITHUB'),
  disableCacheBuild?: boolean(name='DisableCacheBuild', description='Specifies whether to disable building caches. Valid values:

*   `true`: disables building caches.
*   `false`: enables building caches.', example='false'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-shac42yvqzvq****'),
  overseaBuild?: boolean(name='OverseaBuild', description='Specifies whether to enable Build With Servers Deployed Outside Chinese Mainland. Valid values:

*   `true`: enables Build With Servers Deployed Outside Chinese Mainland.
*   `false`: does not enable Build With Servers Deployed Outside Chinese Mainland.', example='false'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-gzsrlevmvoaq****'),
}

model CreateRepoSourceCodeRepoResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4CE1F661-75DD-4EBD-A4AD-057B26834ABB'),
}

model CreateRepoSourceCodeRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoSourceCodeRepoResponseBody(name='body'),
}

async function createRepoSourceCodeRepoWithOptions(request: CreateRepoSourceCodeRepoRequest, runtime: Util.RuntimeOptions): CreateRepoSourceCodeRepoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoBuild)) {
    query['AutoBuild'] = request.autoBuild;
  }
  if (!Util.isUnset(request.codeRepoName)) {
    query['CodeRepoName'] = request.codeRepoName;
  }
  if (!Util.isUnset(request.codeRepoNamespaceName)) {
    query['CodeRepoNamespaceName'] = request.codeRepoNamespaceName;
  }
  if (!Util.isUnset(request.codeRepoType)) {
    query['CodeRepoType'] = request.codeRepoType;
  }
  if (!Util.isUnset(request.disableCacheBuild)) {
    query['DisableCacheBuild'] = request.disableCacheBuild;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.overseaBuild)) {
    query['OverseaBuild'] = request.overseaBuild;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoSourceCodeRepo',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoSourceCodeRepo(request: CreateRepoSourceCodeRepoRequest): CreateRepoSourceCodeRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoSourceCodeRepoWithOptions(request, runtime);
}

model CreateRepoSyncRuleRequest {
  instanceId?: string(name='InstanceId', example='cri-hpdfkc6utbaq****'),
  namespaceName?: string(name='NamespaceName', example='ns1'),
  repoName?: string(name='RepoName', example='repo1'),
  syncRuleName?: string(name='SyncRuleName', example='rule'),
  syncScope?: string(name='SyncScope', example='REPO'),
  syncTrigger?: string(name='SyncTrigger', example='PASSIVE'),
  tagFilter?: string(name='TagFilter', example='.*'),
  targetInstanceId?: string(name='TargetInstanceId', example='cri-ibxs3piklys3****'),
  targetNamespaceName?: string(name='TargetNamespaceName', example='ns1'),
  targetRegionId?: string(name='TargetRegionId', example='cn-shanghai'),
  targetRepoName?: string(name='TargetRepoName', example='repo1'),
  targetUserId?: string(name='TargetUserId', example='12645940***'),
}

model CreateRepoSyncRuleResponseBody = {
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='8F8A0BA6-7F06-4BAE-B147-10BD6A25****'),
  syncRuleId?: string(name='SyncRuleId', example='crsr-gk5p2ns1kzns****'),
}

model CreateRepoSyncRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoSyncRuleResponseBody(name='body'),
}

async function createRepoSyncRuleWithOptions(request: CreateRepoSyncRuleRequest, runtime: Util.RuntimeOptions): CreateRepoSyncRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.syncRuleName)) {
    query['SyncRuleName'] = request.syncRuleName;
  }
  if (!Util.isUnset(request.syncScope)) {
    query['SyncScope'] = request.syncScope;
  }
  if (!Util.isUnset(request.syncTrigger)) {
    query['SyncTrigger'] = request.syncTrigger;
  }
  if (!Util.isUnset(request.tagFilter)) {
    query['TagFilter'] = request.tagFilter;
  }
  if (!Util.isUnset(request.targetInstanceId)) {
    query['TargetInstanceId'] = request.targetInstanceId;
  }
  if (!Util.isUnset(request.targetNamespaceName)) {
    query['TargetNamespaceName'] = request.targetNamespaceName;
  }
  if (!Util.isUnset(request.targetRegionId)) {
    query['TargetRegionId'] = request.targetRegionId;
  }
  if (!Util.isUnset(request.targetRepoName)) {
    query['TargetRepoName'] = request.targetRepoName;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoSyncRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoSyncRule(request: CreateRepoSyncRuleRequest): CreateRepoSyncRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoSyncRuleWithOptions(request, runtime);
}

model CreateRepoSyncTaskRequest {
  instanceId?: string(name='InstanceId', example='cri-hpdfkc6utbaq****'),
  override?: boolean(name='Override', example='true'),
  repoId?: string(name='RepoId', example='crr-iql7jalx4g0****'),
  tag?: string(name='Tag', example='tag1'),
  targetInstanceId?: string(name='TargetInstanceId', example='cri-ibxs3piklys3****'),
  targetNamespace?: string(name='TargetNamespace', example='ns1'),
  targetRegionId?: string(name='TargetRegionId', example='cn-hangzhou'),
  targetRepoName?: string(name='TargetRepoName', example='repo1'),
  targetTag?: string(name='TargetTag', example='tag1'),
  targetUserId?: string(name='TargetUserId', example='12345***'),
}

model CreateRepoSyncTaskResponseBody = {
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='8F8A0BA6-7F06-4BAE-B147-10BD6A25****'),
  syncTaskId?: string(name='SyncTaskId', example='rst-gbch330f0c****'),
}

model CreateRepoSyncTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoSyncTaskResponseBody(name='body'),
}

async function createRepoSyncTaskWithOptions(request: CreateRepoSyncTaskRequest, runtime: Util.RuntimeOptions): CreateRepoSyncTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.override)) {
    query['Override'] = request.override;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.targetInstanceId)) {
    query['TargetInstanceId'] = request.targetInstanceId;
  }
  if (!Util.isUnset(request.targetNamespace)) {
    query['TargetNamespace'] = request.targetNamespace;
  }
  if (!Util.isUnset(request.targetRegionId)) {
    query['TargetRegionId'] = request.targetRegionId;
  }
  if (!Util.isUnset(request.targetRepoName)) {
    query['TargetRepoName'] = request.targetRepoName;
  }
  if (!Util.isUnset(request.targetTag)) {
    query['TargetTag'] = request.targetTag;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoSyncTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoSyncTask(request: CreateRepoSyncTaskRequest): CreateRepoSyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoSyncTaskWithOptions(request, runtime);
}

model CreateRepoSyncTaskByRuleRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-hpdfkc6utbaq****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-hnoq7j93or3k****'),
  syncRuleId?: string(name='SyncRuleId', description='The ID of the synchronization rule.', example='crsr-o8n4dijbumgq****'),
  tag?: string(name='Tag', description='The version of the image to be synchronized.', example='1.24'),
}

model CreateRepoSyncTaskByRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='17A4C658-AE8F-4A08-821F-EDCB5FC74EE8'),
  syncTaskId?: string(name='SyncTaskId', description='The ID of the synchronization task.', example='rst-biu4u4pm4it5****'),
}

model CreateRepoSyncTaskByRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoSyncTaskByRuleResponseBody(name='body'),
}

async function createRepoSyncTaskByRuleWithOptions(request: CreateRepoSyncTaskByRuleRequest, runtime: Util.RuntimeOptions): CreateRepoSyncTaskByRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.syncRuleId)) {
    query['SyncRuleId'] = request.syncRuleId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoSyncTaskByRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoSyncTaskByRule(request: CreateRepoSyncTaskByRuleRequest): CreateRepoSyncTaskByRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoSyncTaskByRuleWithOptions(request, runtime);
}

model CreateRepoTagRequest {
  fromTag?: string(name='FromTag', description='The source image tag.', example='v1'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-shac42yvqzv****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='ns'),
  repoName?: string(name='RepoName', description='The name of the image repository.', example='repo1'),
  toTag?: string(name='ToTag', description='The image tag that you want to create.', example='v2'),
}

model CreateRepoTagResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C4C7DD0C-C9D6-437A-A7EE-8BY*****'),
}

model CreateRepoTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoTagResponseBody(name='body'),
}

async function createRepoTagWithOptions(request: CreateRepoTagRequest, runtime: Util.RuntimeOptions): CreateRepoTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fromTag)) {
    query['FromTag'] = request.fromTag;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.toTag)) {
    query['ToTag'] = request.toTag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoTag',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoTag(request: CreateRepoTagRequest): CreateRepoTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoTagWithOptions(request, runtime);
}

model CreateRepoTagScanTaskRequest {
  digest?: string(name='Digest', description='The digest of the image.', example='sha256:815386ebbe9a3490f38785ab11bda34ec8dacf4634af77b8912832d4f85dca04'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-xwvi3osiy4ff****'),
  scanService?: string(name='ScanService', description='The type of the scanning engine.

*   `SAS_SCAN_SERVICE`: Security Center scan engine (paid service)
*   `ACR_SCAN_SERVICE`: Container Registry scan engine', example='ACR_SCAN_SERVICE'),
  tag?: string(name='Tag', description='The version of the image.', example='1.24'),
}

model CreateRepoTagScanTaskResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BC648259-91A7-4502-BED3-EDF64361FA83'),
}

model CreateRepoTagScanTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoTagScanTaskResponseBody(name='body'),
}

async function createRepoTagScanTaskWithOptions(request: CreateRepoTagScanTaskRequest, runtime: Util.RuntimeOptions): CreateRepoTagScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.scanService)) {
    query['ScanService'] = request.scanService;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoTagScanTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoTagScanTask(request: CreateRepoTagScanTaskRequest): CreateRepoTagScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoTagScanTaskWithOptions(request, runtime);
}

model CreateRepoTriggerRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-xwvi3osiy4ff****'),
  triggerName?: string(name='TriggerName', description='The name of the trigger.', example='trigger1'),
  triggerTag?: string(name='TriggerTag', description='The image tag based on which the trigger is set.

> 

*   If `TriggerType` is set to `ALL`, `TriggerTag` can be set to a string or an array, for example, `*`.

*   If `TriggerType` is set to `TAG_LIST`, `TriggerTag` must be set to an array, for example, `[1]`.
*   If `TriggerType` is set to `TAG_REG_EXP`, `TriggerTag` must be set to a string, for example, `*`.', example='[1]'),
  triggerType?: string(name='TriggerType', description='The type of the trigger. Valid values:

*   `ALL`: a trigger that supports both tags and regular expressions.
*   `TAG_LIST`: a tag-based trigger.
*   `TAG_REG_EXP`: a regular expression-based trigger.', example='ALL'),
  triggerUrl?: string(name='TriggerUrl', description='The URL of the trigger.', example='http://www.mysite.com'),
}

model CreateRepoTriggerResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B79F5E0E-8770-407D-BCB6-ECF4BA9C****'),
  triggerId?: string(name='TriggerId', description='The ID of the trigger.', example='crw-0z4pf81pgz35****'),
}

model CreateRepoTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoTriggerResponseBody(name='body'),
}

async function createRepoTriggerWithOptions(request: CreateRepoTriggerRequest, runtime: Util.RuntimeOptions): CreateRepoTriggerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.triggerName)) {
    query['TriggerName'] = request.triggerName;
  }
  if (!Util.isUnset(request.triggerTag)) {
    query['TriggerTag'] = request.triggerTag;
  }
  if (!Util.isUnset(request.triggerType)) {
    query['TriggerType'] = request.triggerType;
  }
  if (!Util.isUnset(request.triggerUrl)) {
    query['TriggerUrl'] = request.triggerUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoTrigger',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoTrigger(request: CreateRepoTriggerRequest): CreateRepoTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoTriggerWithOptions(request, runtime);
}

model CreateRepositoryRequest {
  detail?: string(name='Detail', description='The description of the repository.', example='repo1'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  repoName?: string(name='RepoName', description='The name of the image repository.', example='repo1'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the image repository belongs.', example='namespace01'),
  repoType?: string(name='RepoType', description='The type of the repository. Valid values:

*   `PUBLIC`: The repository is a public repository.
*   `PRIVATE`: The repository is a private repository.', example='PRIVATE'),
  summary?: string(name='Summary', description='The summary about the repository.', example='repo1'),
  tagImmutability?: boolean(name='TagImmutability', description='Specifies whether to enable the feature of image tag immutability. Valid values:

*   `true`: enables the feature of image tag immutability.
*   `false`: disables the feature of image tag immutability.', example='true'),
}

model CreateRepositoryResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-xwvi3osiy4ff****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='886FB272-15C3-44FC-AA54-F4ABD5B93A28'),
}

model CreateRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepositoryResponseBody(name='body'),
}

async function createRepositoryWithOptions(request: CreateRepositoryRequest, runtime: Util.RuntimeOptions): CreateRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.detail)) {
    query['Detail'] = request.detail;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.repoType)) {
    query['RepoType'] = request.repoType;
  }
  if (!Util.isUnset(request.summary)) {
    query['Summary'] = request.summary;
  }
  if (!Util.isUnset(request.tagImmutability)) {
    query['TagImmutability'] = request.tagImmutability;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepository(request: CreateRepositoryRequest): CreateRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepositoryWithOptions(request, runtime);
}

model DeleteChainRequest {
  chainId?: string(name='ChainId', description='The ID of the delivery pipeline.', example='chi-02ymhtwl3cq8****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-4cdrlqmhn4gm****'),
}

model DeleteChainResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='DB1809A8-E1C8-5707-BAF8-D4FC1C11****'),
}

model DeleteChainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteChainResponseBody(name='body'),
}

async function deleteChainWithOptions(request: DeleteChainRequest, runtime: Util.RuntimeOptions): DeleteChainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chainId)) {
    query['ChainId'] = request.chainId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteChain',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteChain(request: DeleteChainRequest): DeleteChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteChainWithOptions(request, runtime);
}

model DeleteChartNamespaceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  namespaceName?: string(name='NamespaceName', description='The name of the chart namespace that you want to delete.', example='ns2'),
}

model DeleteChartNamespaceResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='FEC62DF1-1394-467F-A69F-4BC1BA29F383'),
}

model DeleteChartNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteChartNamespaceResponseBody(name='body'),
}

/**
  * >  If you delete a chart namespace, all repositories in the namespace and the charts in all repositories are deleted.
  *
  * @param request DeleteChartNamespaceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteChartNamespaceResponse
 */
async function deleteChartNamespaceWithOptions(request: DeleteChartNamespaceRequest, runtime: Util.RuntimeOptions): DeleteChartNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteChartNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  If you delete a chart namespace, all repositories in the namespace and the charts in all repositories are deleted.
  *
  * @param request DeleteChartNamespaceRequest
  * @return DeleteChartNamespaceResponse
 */
async function deleteChartNamespace(request: DeleteChartNamespaceRequest): DeleteChartNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteChartNamespaceWithOptions(request, runtime);
}

model DeleteChartReleaseRequest {
  chart?: string(name='Chart', description='The name of the chart.', example='chart3'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  release?: string(name='Release', description='The version of the chart that you want to delete.', example='0.1.0'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='repo1'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.', example='ns1'),
}

model DeleteChartReleaseResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C2D6CE47-6DEF-45F4-A1AC-90F3AFBA751F'),
}

model DeleteChartReleaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteChartReleaseResponseBody(name='body'),
}

async function deleteChartReleaseWithOptions(request: DeleteChartReleaseRequest, runtime: Util.RuntimeOptions): DeleteChartReleaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chart)) {
    query['Chart'] = request.chart;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.release)) {
    query['Release'] = request.release;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteChartRelease',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteChartRelease(request: DeleteChartReleaseRequest): DeleteChartReleaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteChartReleaseWithOptions(request, runtime);
}

model DeleteChartRepositoryRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay****'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='repo01'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.', example='namespace01'),
}

model DeleteChartRepositoryResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='12589EF7-96E2-4554-AAD7-F7209E88CAD3'),
}

model DeleteChartRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteChartRepositoryResponseBody(name='body'),
}

async function deleteChartRepositoryWithOptions(request: DeleteChartRepositoryRequest, runtime: Util.RuntimeOptions): DeleteChartRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteChartRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteChartRepository(request: DeleteChartRepositoryRequest): DeleteChartRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteChartRepositoryWithOptions(request, runtime);
}

model DeleteEventCenterRuleRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  ruleId?: string(name='RuleId', description='The ID of the event notification rule.', example='crecr-n6pbhgjx*****'),
}

model DeleteEventCenterRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='031572FA-7D8F-4C05-B790-1071E0E05DE6'),
}

model DeleteEventCenterRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEventCenterRuleResponseBody(name='body'),
}

async function deleteEventCenterRuleWithOptions(request: DeleteEventCenterRuleRequest, runtime: Util.RuntimeOptions): DeleteEventCenterRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventCenterRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEventCenterRule(request: DeleteEventCenterRuleRequest): DeleteEventCenterRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventCenterRuleWithOptions(request, runtime);
}

model DeleteInstanceEndpointAclPolicyRequest {
  endpointType?: string(name='EndpointType', description='The type of the endpoint. Set the value to Internet.', example='internet'),
  entry?: string(name='Entry', description='The CIDR block.', example='127.0.0.1/32'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  moduleName?: string(name='ModuleName', description='The name of the module that you want to access. Valid values:

*   `Registry`: the image repository.
*   `Chart`: a Helm chart.', example='Chart'),
}

model DeleteInstanceEndpointAclPolicyResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BDB1F145-F0FF-44E9-AADF-A678642A7C7D'),
}

model DeleteInstanceEndpointAclPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstanceEndpointAclPolicyResponseBody(name='body'),
}

async function deleteInstanceEndpointAclPolicyWithOptions(request: DeleteInstanceEndpointAclPolicyRequest, runtime: Util.RuntimeOptions): DeleteInstanceEndpointAclPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!Util.isUnset(request.entry)) {
    query['Entry'] = request.entry;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstanceEndpointAclPolicy',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInstanceEndpointAclPolicy(request: DeleteInstanceEndpointAclPolicyRequest): DeleteInstanceEndpointAclPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstanceEndpointAclPolicyWithOptions(request, runtime);
}

model DeleteInstanceVpcEndpointLinkedVpcRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  moduleName?: string(name='ModuleName', description='The name of the module that you want to access. Valid values:

*   `Registry`: the image repository.
*   `Chart`: a Helm chart.', example='Chart'),
  vpcId?: string(name='VpcId', description='The ID of the VPC.', example='vpc-uf6pa68zxnnlc48dd****'),
  vswitchId?: string(name='VswitchId', description='The ID of the vSwitch.', example='vpc-uf6pa68zxnnlc48dd****'),
}

model DeleteInstanceVpcEndpointLinkedVpcResponseBody = {
  code?: string(name='Code', description='The return value.', example='true'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='20FE7A66-0044-4E23-BBEC-C434EADBD7AF'),
}

model DeleteInstanceVpcEndpointLinkedVpcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstanceVpcEndpointLinkedVpcResponseBody(name='body'),
}

async function deleteInstanceVpcEndpointLinkedVpcWithOptions(request: DeleteInstanceVpcEndpointLinkedVpcRequest, runtime: Util.RuntimeOptions): DeleteInstanceVpcEndpointLinkedVpcResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.vswitchId)) {
    query['VswitchId'] = request.vswitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstanceVpcEndpointLinkedVpc',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInstanceVpcEndpointLinkedVpc(request: DeleteInstanceVpcEndpointLinkedVpcRequest): DeleteInstanceVpcEndpointLinkedVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstanceVpcEndpointLinkedVpcWithOptions(request, runtime);
}

model DeleteNamespaceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='ns3'),
}

model DeleteNamespaceResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BA08C185-8F76-48D7-ACB3-BA11BF2778F9'),
}

model DeleteNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNamespaceResponseBody(name='body'),
}

/**
  * > After you delete a namespace, all repositories in the namespace and all images in these repositories are deleted as well.
  *
  * @param request DeleteNamespaceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteNamespaceResponse
 */
async function deleteNamespaceWithOptions(request: DeleteNamespaceRequest, runtime: Util.RuntimeOptions): DeleteNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > After you delete a namespace, all repositories in the namespace and all images in these repositories are deleted as well.
  *
  * @param request DeleteNamespaceRequest
  * @return DeleteNamespaceResponse
 */
async function deleteNamespace(request: DeleteNamespaceRequest): DeleteNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNamespaceWithOptions(request, runtime);
}

model DeleteRepoBuildRuleRequest {
  buildRuleId?: string(name='BuildRuleId', description='The ID of the image building rule.', example='crbr-36tffn0kouvi****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-xwvi3osiy4ff****'),
}

model DeleteRepoBuildRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2E3F55BF-FA7B-454E-B2C6-85265E243ADC'),
}

model DeleteRepoBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepoBuildRuleResponseBody(name='body'),
}

async function deleteRepoBuildRuleWithOptions(request: DeleteRepoBuildRuleRequest, runtime: Util.RuntimeOptions): DeleteRepoBuildRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildRuleId)) {
    query['BuildRuleId'] = request.buildRuleId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepoBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRepoBuildRule(request: DeleteRepoBuildRuleRequest): DeleteRepoBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRepoBuildRuleWithOptions(request, runtime);
}

model DeleteRepoSyncRuleRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-hpdfkc6utbaq****'),
  syncRuleId?: string(name='SyncRuleId', description='The ID of the synchronization rule.', example='crsr-gk5p2ns1kzns****'),
}

model DeleteRepoSyncRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='72DD4198-1BB9-47A3-BC01-EAD1A6D5E173'),
}

model DeleteRepoSyncRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepoSyncRuleResponseBody(name='body'),
}

async function deleteRepoSyncRuleWithOptions(request: DeleteRepoSyncRuleRequest, runtime: Util.RuntimeOptions): DeleteRepoSyncRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.syncRuleId)) {
    query['SyncRuleId'] = request.syncRuleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepoSyncRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRepoSyncRule(request: DeleteRepoSyncRuleRequest): DeleteRepoSyncRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRepoSyncRuleWithOptions(request, runtime);
}

model DeleteRepoTagRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-xwvi3osiy4ff****'),
  tag?: string(name='Tag', description='The tag of the image.', example='1.24'),
}

model DeleteRepoTagResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='96E66B3A-C81A-48BE-ACD6-C0AB1F9313C0'),
}

model DeleteRepoTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepoTagResponseBody(name='body'),
}

async function deleteRepoTagWithOptions(request: DeleteRepoTagRequest, runtime: Util.RuntimeOptions): DeleteRepoTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepoTag',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRepoTag(request: DeleteRepoTagRequest): DeleteRepoTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRepoTagWithOptions(request, runtime);
}

model DeleteRepoTriggerRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-xwvi3osiy4ff****'),
  triggerId?: string(name='TriggerId', description='The ID of the trigger.', example='crw-0z4pf81pgz35****'),
}

model DeleteRepoTriggerResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='85180AE4-9A57-48F8-9EF9-68ECCE54B552'),
}

model DeleteRepoTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepoTriggerResponseBody(name='body'),
}

async function deleteRepoTriggerWithOptions(request: DeleteRepoTriggerRequest, runtime: Util.RuntimeOptions): DeleteRepoTriggerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.triggerId)) {
    query['TriggerId'] = request.triggerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepoTrigger',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRepoTrigger(request: DeleteRepoTriggerRequest): DeleteRepoTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRepoTriggerWithOptions(request, runtime);
}

model DeleteRepositoryRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-l4933wbcmun2****'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
}

model DeleteRepositoryResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='47DD9D56-09A0-4C52-B520-C3805DBAB96B'),
}

model DeleteRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepositoryResponseBody(name='body'),
}

/**
  * If you delete a repository, all images in the repository are also deleted.
  *
  * @param request DeleteRepositoryRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteRepositoryResponse
 */
async function deleteRepositoryWithOptions(request: DeleteRepositoryRequest, runtime: Util.RuntimeOptions): DeleteRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you delete a repository, all images in the repository are also deleted.
  *
  * @param request DeleteRepositoryRequest
  * @return DeleteRepositoryResponse
 */
async function deleteRepository(request: DeleteRepositoryRequest): DeleteRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRepositoryWithOptions(request, runtime);
}

model GetArtifactBuildRuleRequest {
  artifactType?: string(name='ArtifactType', example='ACCELERATED_IMAGE'),
  buildRuleId?: string(name='BuildRuleId', example='crabr-o2670wqz2n70****'),
  instanceId?: string(name='InstanceId', example='cri-xkx6vujuhay0****'),
  scopeId?: string(name='ScopeId', example='crr-8dz3aedjqlmk****'),
  scopeType?: string(name='ScopeType', example='REPOSITORY'),
}

model GetArtifactBuildRuleResponseBody = {
  artifactType?: string(name='ArtifactType', example='ACCELERATED_IMAGE'),
  buildRuleId?: string(name='BuildRuleId', example='crabr-o2670wqz2n70****'),
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='7A3E98F6-296C-54AC-A612-B75E7777D4C1'),
  scopeId?: string(name='ScopeId', example='crr-8dz3aedjqlmk****'),
  scopeType?: string(name='ScopeType', example='REPOSITORY'),
}

model GetArtifactBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetArtifactBuildRuleResponseBody(name='body'),
}

async function getArtifactBuildRuleWithOptions(request: GetArtifactBuildRuleRequest, runtime: Util.RuntimeOptions): GetArtifactBuildRuleResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetArtifactBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getArtifactBuildRule(request: GetArtifactBuildRuleRequest): GetArtifactBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getArtifactBuildRuleWithOptions(request, runtime);
}

model GetArtifactBuildTaskRequest {
  buildTaskId?: string(name='BuildTaskId', description='The ID of the artifact building task.', example='i2a-1yu****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-shac42yvqzvq****'),
}

model GetArtifactBuildTaskResponseBody = {
  artifactBuildType?: string(name='ArtifactBuildType', description='The type of the artifact building task. Valid values:

*   `IMAGE_TO_ACCELERATED_IMAGE`: builds accelerated images for Container Service for Kubernetes (ACK) clusters.
*   `IMAGE_TO_ECI_ACCELERATED_IMAGE`: builds accelerated images for elastic container instances.', example='IMAGE_TO_ACCELERATED_IMAGE'),
  buildTaskId?: string(name='BuildTaskId', description='The ID of the artifact building task.', example='i2a-1yu****'),
  code?: string(name='Code', description='The return value.', example='success'),
  endTime?: int32(name='EndTime', description='The time when the artifact building task ends.', example='156871880'),
  instructions?: [ string ](name='Instructions'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C4C7DD0C-C9D6-437A-A7EE-121EFD70D002'),
  sourceArtifact?: {
    artifactType?: string(name='ArtifactType', description='The type of the artifact that is built in the task. The value can only be IMAGE.', example='IMAGE'),
    repoId?: string(name='RepoId', description='The ID of the repository to which the source artifact belongs. The repository can only be an image repository.', example='cri-shac42yvqzvq****'),
    version?: string(name='Version', description='The version of the artifact. The artifact can only be an image.', example='latest'),
  }(name='SourceArtifact', description='The information about the source artifact.'),
  startTime?: int32(name='StartTime', description='The time when the artifact building task starts.', example='156871881'),
  targetArtifact?: {
    artifactType?: string(name='ArtifactType', description='The type of the artifact that is built in the task. The value can only be IMAGE.', example='IMAGE'),
    repoId?: string(name='RepoId', description='The ID of the repository to which the artifact that is built in the task belongs. The repository can only be an image repository. The value is the same as the ID of the repository to which the source artifact belongs.', example='crr-1234567'),
    version?: string(name='Version', description='The version of the artifact that is built in the task. The artifact can only be an image.', example='latest_accelerated'),
  }(name='TargetArtifact', description='The artifact that is built in the task.'),
  taskStatus?: string(name='TaskStatus', description='The status of the artifact that is built in the task. Valid values:

*   `PENDING`: The artifact is being scheduled.
*   `BUILDING`: The artifact is being built.
*   `SUCCESS`: The artifact is built.
*   `FAILED`: The artifact fails to be built.', example='BUILDING'),
}

model GetArtifactBuildTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetArtifactBuildTaskResponseBody(name='body'),
}

async function getArtifactBuildTaskWithOptions(request: GetArtifactBuildTaskRequest, runtime: Util.RuntimeOptions): GetArtifactBuildTaskResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetArtifactBuildTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getArtifactBuildTask(request: GetArtifactBuildTaskRequest): GetArtifactBuildTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getArtifactBuildTaskWithOptions(request, runtime);
}

model GetAuthorizationTokenRequest {
  instanceId?: string(name='InstanceId', description='The ID of the request.', example='cri-kmsiwlxxdcvaduwb'),
}

model GetAuthorizationTokenResponseBody = {
  authorizationToken?: string(name='AuthorizationToken', description='The temporary password returned after you call this API operation is a Security Token Service (STS) token whose validity period is 1 hour. Take note of the following items when you log on to Container Registry instances by using an STS token:

*   If the STS token belongs to an Alibaba Cloud account, you can use the STS token to log on to all Container Registry instances that belong to the Alibaba Cloud account.
*   If the STS token belongs to a Resource Access Management (RAM) user, you can use the STS token to log on to all Container Registry instances that belong to the RAM user.
*   You can use an STS token to access only Container Registry instances to which the STS token is scoped.', example='shaunadadakks:uuczxnjcyeyhdjadkkajsjdjadhyucb'),
  code?: string(name='Code', description='Indicates whether the API call is successful.

*   `true`: successful
*   `false`: failed', example='success'),
  expireTime?: long(name='ExpireTime', description='The return value.', example='1571242083000'),
  isSuccess?: boolean(name='IsSuccess', description='The username that is used to log on to the Container Registry instance.', example='true'),
  requestId?: string(name='RequestId', description='The timestamp when the temporary password expires. Unit: milliseconds.', example='E069EB86-E6AD-4A98-ADDE-0E993390239A'),
  tempUsername?: string(name='TempUsername', description='The password that is used to log on to the Container Registry instance.', example='temp_user_cr'),
}

model GetAuthorizationTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAuthorizationTokenResponseBody(name='body'),
}

/**
  * The ID of the Container Registry instance.
  *
  * @param request GetAuthorizationTokenRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetAuthorizationTokenResponse
 */
async function getAuthorizationTokenWithOptions(request: GetAuthorizationTokenRequest, runtime: Util.RuntimeOptions): GetAuthorizationTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAuthorizationToken',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * The ID of the Container Registry instance.
  *
  * @param request GetAuthorizationTokenRequest
  * @return GetAuthorizationTokenResponse
 */
async function getAuthorizationToken(request: GetAuthorizationTokenRequest): GetAuthorizationTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuthorizationTokenWithOptions(request, runtime);
}

model GetChainRequest {
  chainId?: string(name='ChainId', example='chi-0ops0gsmw5x2****'),
  instanceId?: string(name='InstanceId', example='cri-4cdrlqmhn4gm****'),
}

model GetChainResponseBody = {
  chainConfig?: {
    chainConfigId?: string(name='ChainConfigId', example='cci-lz3ycgo69ukt****'),
    isActive?: boolean(name='IsActive', example='true'),
    nodes?: [ 
      {
        enable?: boolean(name='Enable', example='true'),
        nodeConfig?: {
          denyPolicy?: {
            action?: string(name='Action', example='BLOCK'),
            baselineList?: string(name='BaselineList', example='identification,hc_image_exploit'),
            issueCount?: string(name='IssueCount', example='10'),
            issueLevel?: string(name='IssueLevel', example='HIGH'),
            issueList?: string(name='IssueList', example='CVE-2020-8286,CVE-2020-8285'),
            logic?: string(name='Logic', example='AND'),
            maliciousList?: string(name='MaliciousList', example='mutate_cockhorse,abnormal_program'),
          }(name='DenyPolicy'),
          retry?: int32(name='Retry', example='3'),
          scanEngine?: string(name='ScanEngine', example='ACR_SCAN_SERVICE'),
          timeout?: long(name='Timeout'),
        }(name='NodeConfig'),
        nodeName?: string(name='NodeName', example='VULNERABILITY_SCANNING'),
      }
    ](name='Nodes'),
    routers?: [ 
      {
        from?: {
          nodeName?: string(name='NodeName', example='DOCKER_IMAGE_BUILD'),
        }(name='From'),
        to?: {
          nodeName?: string(name='NodeName', example='DOCKER_IMAGE_PUSH'),
        }(name='To'),
      }
    ](name='Routers'),
    version?: string(name='Version', example='1'),
  }(name='ChainConfig'),
  chainId?: string(name='ChainId', example='chi-0ops0gsmw5x2****'),
  code?: string(name='Code', example='success'),
  createTime?: long(name='CreateTime', example='1638255427000'),
  description?: string(name='Description', example='description'),
  instanceId?: string(name='InstanceId', example='cri-4cdrlqmhn4gm****'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  modifiedTime?: long(name='ModifiedTime', example='1638259914000'),
  name?: string(name='Name', example='test'),
  requestId?: string(name='RequestId', example='C87993B5-7D61-5CAC-8D64-1AC732DD69FF'),
  scopeExclude?: [ string ](name='ScopeExclude'),
  scopeId?: string(name='ScopeId', example='crr-nyrh2oko32xb****'),
  scopeType?: string(name='ScopeType', example='REPOSITORY'),
}

model GetChainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetChainResponseBody(name='body'),
}

async function getChainWithOptions(request: GetChainRequest, runtime: Util.RuntimeOptions): GetChainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chainId)) {
    query['ChainId'] = request.chainId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetChain',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getChain(request: GetChainRequest): GetChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return getChainWithOptions(request, runtime);
}

model GetChartNamespaceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='ns1'),
}

model GetChartNamespaceResponseBody = {
  autoCreateRepo?: boolean(name='AutoCreateRepo', description='Indicates whether a repository was automatically created in the namespace. Valid values:

*   `true`: A repository was automatically created in the namespace.
*   `false`: No repository was automatically created in the namespace.', example='true'),
  code?: string(name='Code', description='The return value.', example='success'),
  defaultRepoType?: string(name='DefaultRepoType', description='The default repository type. Valid values:

*   `PUBLIC`: a public repository.
*   `PRIVATE`: a private repository.', example='PRIVATE'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  namespaceId?: string(name='NamespaceId', description='The ID of the namespace.', example='crcn-43dhbjbyt2xl****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='ns1'),
  namespaceStatus?: string(name='NamespaceStatus', description='The status of the namespace. Valid values:

*   `NORMAL`: The namespace is normal.
*   `DELETING`: The namespace is being deleted.', example='NORMAL'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CD71CF13-93AA-4805-848B-69B2DD543A9A'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model GetChartNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetChartNamespaceResponseBody(name='body'),
}

async function getChartNamespaceWithOptions(request: GetChartNamespaceRequest, runtime: Util.RuntimeOptions): GetChartNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetChartNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getChartNamespace(request: GetChartNamespaceRequest): GetChartNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getChartNamespaceWithOptions(request, runtime);
}

model GetChartRepositoryRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='test'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.', example='test'),
}

model GetChartRepositoryResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  createTime?: long(name='CreateTime', description='The time when the chart repository was created.', example='1563767620000'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  modifiedTime?: long(name='ModifiedTime', description='The time when the chart repository was last modified.', example='1563767700000'),
  repoId?: string(name='RepoId', description='The ID of the chart repository.', example='crcr-c7letfwev5oq****'),
  repoName?: string(name='RepoName', description='The name of the chart repository.', example='test'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the chart repository belongs.', example='test'),
  repoStatus?: string(name='RepoStatus', description='The status of the chart repository. Valid values:

*   `NORMAL`: The repository is normal.
*   `DELETING`: The repository is being deleted.', example='NORMAL'),
  repoType?: string(name='RepoType', description='The type of the chart repository. Valid values:

*   `PUBLIC`: a public repository
*   `PRIVATE`: a private repository', example='PUBLIC'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A3F6AB56-DEF4-4FF5-8DE4-680362C0E21F'),
  resourceGroupId?: string(name='ResourceGroupId'),
  summary?: string(name='Summary', description='The summary about the chart repository.', example='test'),
}

model GetChartRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetChartRepositoryResponseBody(name='body'),
}

async function getChartRepositoryWithOptions(request: GetChartRepositoryRequest, runtime: Util.RuntimeOptions): GetChartRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetChartRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getChartRepository(request: GetChartRepositoryRequest): GetChartRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getChartRepositoryWithOptions(request, runtime);
}

model GetInstanceRequest {
  instanceId?: string(name='InstanceId', example='cri-xkx6vujuhay0****'),
}

model GetInstanceResponseBody = {
  code?: string(name='Code', example='success'),
  createTime?: long(name='CreateTime', example='1571926439000'),
  instanceId?: string(name='InstanceId', example='cri-xkx6vujuhay0****'),
  instanceIssue?: string(name='InstanceIssue'),
  instanceName?: string(name='InstanceName', example='shanghai-instance1'),
  instanceSpecification?: string(name='InstanceSpecification', example='Enterprise_Basic'),
  instanceStatus?: string(name='InstanceStatus', example='RUNNING'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  modifiedTime?: long(name='ModifiedTime', example='1571926560000'),
  requestId?: string(name='RequestId', example='6EF34B18-4228-470C-860C-D28597CF010E'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-acfmv36i4isx****'),
}

model GetInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInstanceResponseBody(name='body'),
}

async function getInstanceWithOptions(request: GetInstanceRequest, runtime: Util.RuntimeOptions): GetInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstance',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstance(request: GetInstanceRequest): GetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceWithOptions(request, runtime);
}

model GetInstanceCountResponseBody = {
  code?: string(name='Code', example='success'),
  count?: int32(name='Count', example='5'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='BC648259-91A7-4502-BED3-EDF64361FA83'),
}

model GetInstanceCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInstanceCountResponseBody(name='body'),
}

async function getInstanceCountWithOptions(runtime: Util.RuntimeOptions): GetInstanceCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetInstanceCount',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceCount(): GetInstanceCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceCountWithOptions(runtime);
}

model GetInstanceEndpointRequest {
  endpointType?: string(name='EndpointType', description='The type of the endpoint. Set the value to Internet.', example='internet'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  moduleName?: string(name='ModuleName', description='The name of the module that you want to access. Valid values:

*   `Registry`: the image repository.
*   `Chart`: a Helm chart.', example='Registry'),
}

model GetInstanceEndpointResponseBody = {
  aclEnable?: boolean(name='AclEnable', description='Indicates whether the access control list (ACL) feature is enabled.', example='true'),
  aclEntries?: [ 
    {
      comment?: string(name='Comment', description='Remarks for public IP address whitelists.', example='1'),
      entry?: string(name='Entry', description='The public IP address whitelist.', example='192.168.1.0/24'),
    }
  ](name='AclEntries', description='The ACLs.'),
  code?: string(name='Code', description='The return value.', example='success'),
  domains?: [ 
    {
      domain?: string(name='Domain', description='The domain name that is used to access the Container Registry Enterprise Edition instance.', example='shanghai-instance1-registry.cn-shanghai.cr.aliyuncs.com'),
      type?: string(name='Type', description='The type of the domain name. Valid values:

*   `SYSTEM`: a system domain name.
*   `USER`: a user domain name.', example='SYSTEM'),
    }
  ](name='Domains', description='Domain names.'),
  enable?: boolean(name='Enable', description='Indicates whether the ACL feature is enabled.', example='true'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='8F3D5EC5-39D1-4C53-A198-48C54C658FA3'),
  status?: string(name='Status', description='The status of the instance.', example='RUNNING'),
}

model GetInstanceEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInstanceEndpointResponseBody(name='body'),
}

async function getInstanceEndpointWithOptions(request: GetInstanceEndpointRequest, runtime: Util.RuntimeOptions): GetInstanceEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceEndpoint',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceEndpoint(request: GetInstanceEndpointRequest): GetInstanceEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceEndpointWithOptions(request, runtime);
}

model GetInstanceUsageRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
}

model GetInstanceUsageResponseBody = {
  chartNamespaceQuota?: string(name='ChartNamespaceQuota', description='The quota of chart namespaces.', example='50'),
  chartNamespaceUsage?: string(name='ChartNamespaceUsage', description='The number of chart namespaces that are created in the instance.', example='2'),
  chartRepoQuota?: string(name='ChartRepoQuota', description='The quota of chart repositories for the instance.', example='5000'),
  chartRepoUsage?: string(name='ChartRepoUsage', description='The number of chart repositories that are created.', example='5'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  namespaceQuota?: string(name='NamespaceQuota', description='The quota of image namespaces for the instance.', example='100'),
  namespaceUsage?: string(name='NamespaceUsage', description='The number of image namespaces that are created in the instance.', example='4'),
  repoQuota?: string(name='RepoQuota', description='The quota of image repositories for the instance.', example='1000'),
  repoUsage?: string(name='RepoUsage', description='The number of image repositories that are created in the instance.', example='2'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A726E801-7FCF-43F9-AF1C-51B3E65D3E7A'),
}

model GetInstanceUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInstanceUsageResponseBody(name='body'),
}

async function getInstanceUsageWithOptions(request: GetInstanceUsageRequest, runtime: Util.RuntimeOptions): GetInstanceUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceUsage',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceUsage(request: GetInstanceUsageRequest): GetInstanceUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceUsageWithOptions(request, runtime);
}

model GetInstanceVpcEndpointRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  moduleName?: string(name='ModuleName', description='The name of the module that you want to access. Valid values:

*   `Registry`: the image repository.
*   `Chart`: a Helm chart.', example='Chart'),
}

model GetInstanceVpcEndpointResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  domains?: [ string ](name='Domains'),
  enable?: boolean(name='Enable', description='Indicates whether the access control list (ACL) feature is enabled. Valid values:

*   `true`: The ACL feature is enabled.
*   `false`: The ACL feature is disabled.', example='true'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  linkedVpcs?: [ 
    {
      defaultAccess?: boolean(name='DefaultAccess', description='Indicates whether the default ACL is used.', example='false'),
      ip?: string(name='Ip', description='IP address.', example='192.168.10.11'),
      status?: string(name='Status', description='The status of the VPC. Valid values:

*   `CREATING`: The VPC is being created.
*   `RUNNING`: The VPC is running.', example='CREATING'),
      vpcId?: string(name='VpcId', description='VPC ID', example='vpc-uf6aamu2nomfr1thd****'),
      vswitchId?: string(name='VswitchId', description='The ID of the vSwitch.', example='vsw-uf62m5vmxl2e72dk7****'),
    }
  ](name='LinkedVpcs', description='The VPCs in which the instance is deployed.'),
  moduleName?: string(name='ModuleName'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BAE9349D-A587-4F9A-B574-9DA0EF2638D1'),
}

model GetInstanceVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInstanceVpcEndpointResponseBody(name='body'),
}

async function getInstanceVpcEndpointWithOptions(request: GetInstanceVpcEndpointRequest, runtime: Util.RuntimeOptions): GetInstanceVpcEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceVpcEndpoint',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceVpcEndpoint(request: GetInstanceVpcEndpointRequest): GetInstanceVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceVpcEndpointWithOptions(request, runtime);
}

model GetNamespaceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  namespaceId?: string(name='NamespaceId', description='The ID of the namespace.', example='crn-tiw8t3f8i5lta****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test'),
}

model GetNamespaceResponseBody = {
  autoCreateRepo?: boolean(name='AutoCreateRepo', description='Indicates whether a repository is automatically created when an image is pushed to the namespace.', example='true'),
  code?: string(name='Code', description='The return value.', example='success'),
  defaultRepoType?: string(name='DefaultRepoType', description='The default type of the repository. Valid values:

*   PUBLIC: The repository is a public repository.
*   PRIVATE: The repository is a private repository.', example='PUBLIC'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  namespaceId?: string(name='NamespaceId', description='The ID of the namespace.', example='crn-tiw8t3f8i5lt****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test'),
  namespaceStatus?: string(name='NamespaceStatus', description='The status of the namespace.', example='NORMAL'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E4BC9E21-8AA5-4582-83C1-C1209AB8196F'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model GetNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNamespaceResponseBody(name='body'),
}

async function getNamespaceWithOptions(request: GetNamespaceRequest, runtime: Util.RuntimeOptions): GetNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNamespace(request: GetNamespaceRequest): GetNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNamespaceWithOptions(request, runtime);
}

model GetRepoBuildRecordRequest {
  buildRecordId?: string(name='BuildRecordId', description='The ID of the image building record.', example='a78ec6fb-16ea-4649-93b7-f52afba7d****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
}

model GetRepoBuildRecordResponseBody = {
  buildRecordId?: string(name='BuildRecordId', description='The ID of the image building record.', example='79174CBA-8556-443A-8976-22C922D7****'),
  code?: string(name='Code', description='The return value.', example='success'),
  endTime?: long(name='EndTime', description='The time when the image building was completed.', example='1568718698000'),
  image?: {
    imageTag?: string(name='ImageTag', description='The tag of the image.', example='master'),
    repoName?: string(name='RepoName', description='The name of the image repository.', example='test'),
    repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the image repository belongs.', example='test'),
  }(name='Image', description='The information about the image.'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='a78ec6fb-16ea-4649-93b7-f52afba7d9de1'),
  startTime?: long(name='StartTime', description='The time when the image building started.', example='1568718468000'),
  status?: string(name='Status', description='The status of the instance.', example='true'),
}

model GetRepoBuildRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoBuildRecordResponseBody(name='body'),
}

/**
  * ****
  *
  * @param request GetRepoBuildRecordRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetRepoBuildRecordResponse
 */
async function getRepoBuildRecordWithOptions(request: GetRepoBuildRecordRequest, runtime: Util.RuntimeOptions): GetRepoBuildRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildRecordId)) {
    query['BuildRecordId'] = request.buildRecordId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoBuildRecord',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * ****
  *
  * @param request GetRepoBuildRecordRequest
  * @return GetRepoBuildRecordResponse
 */
async function getRepoBuildRecord(request: GetRepoBuildRecordRequest): GetRepoBuildRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoBuildRecordWithOptions(request, runtime);
}

model GetRepoBuildRecordStatusRequest {
  buildRecordId?: string(name='BuildRecordId', description='The ID of the image building record.', example='a78ec6fb-16ea-4649-93b7-f52afba7d****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-jnzm47ihjmgc****'),
}

model GetRepoBuildRecordStatusResponseBody = {
  buildStatus?: string(name='BuildStatus', description='The status of the image building.', example='success'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='79174CBA-8556-443A-8976-22C922D7BE37'),
}

model GetRepoBuildRecordStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoBuildRecordStatusResponseBody(name='body'),
}

async function getRepoBuildRecordStatusWithOptions(request: GetRepoBuildRecordStatusRequest, runtime: Util.RuntimeOptions): GetRepoBuildRecordStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildRecordId)) {
    query['BuildRecordId'] = request.buildRecordId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoBuildRecordStatus',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoBuildRecordStatus(request: GetRepoBuildRecordStatusRequest): GetRepoBuildRecordStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoBuildRecordStatusWithOptions(request, runtime);
}

model GetRepoSourceCodeRepoRequest {
  instanceId?: string(name='InstanceId', description='The ID of the Container Registry instance.', example='cri-shac42yvqzvq****'),
  repoId?: string(name='RepoId', description='The ID of the repository.', example='crr-gzsrlevmvoaq****'),
}

model GetRepoSourceCodeRepoResponseBody = {
  autoBuild?: string(name='AutoBuild', description='Indicates whether image building is automatically triggered when source code is committed. Valid values:

*   `true`: Image building is automatically triggered when source code is committed.
*   `false`: Image building is not triggered when source code is committed.', example='true'),
  code?: string(name='Code', description='The response code.', example='success'),
  codeRepoDomain?: string(name='CodeRepoDomain', description='The address of the source code repository.', example='https://github.com'),
  codeRepoName?: string(name='CodeRepoName', description='The name of the source code repository.', example='repo'),
  codeRepoNamespaceName?: string(name='CodeRepoNamespaceName', description='The namespace to which the source code repository belongs.', example='namespace'),
  codeRepoType?: string(name='CodeRepoType', description='The type of the code hosting platform. Valid values: `GITHUB`, `GITLAB`, `GITEE`, `CODE`, and `CODEUP`.', example='GITHUB'),
  disableCacheBuild?: string(name='DisableCacheBuild', description='Indicates whether build cache is disabled. Valid values:

*   `true`: Build cache is disabled.
*   `false`: Build cache is enabled.', example='false'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API call is successful. Valid values:

*   `true`: successful
*   `false`: failed', example='true'),
  overseaBuild?: string(name='OverseaBuild', description='Indicates whether image building is accelerated for servers outside the Chinese mainland. Valid values:

*   `true`: Image building is accelerated for servers outside the Chinese mainland.
*   `false`: Image building is not accelerated for servers outside the Chinese mainland.', example='false'),
  repoId?: string(name='RepoId', description='The ID of the repository.', example='crr-gzsrlevmvoaq****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4CE1F661-75DD-4EBD-A4AD-057B26834ABB'),
}

model GetRepoSourceCodeRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoSourceCodeRepoResponseBody(name='body'),
}

async function getRepoSourceCodeRepoWithOptions(request: GetRepoSourceCodeRepoRequest, runtime: Util.RuntimeOptions): GetRepoSourceCodeRepoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoSourceCodeRepo',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoSourceCodeRepo(request: GetRepoSourceCodeRepoRequest): GetRepoSourceCodeRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoSourceCodeRepoWithOptions(request, runtime);
}

model GetRepoSyncTaskRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-sgedpenzw80e****'),
  syncTaskId?: string(name='SyncTaskId', description='The ID of the synchronization task.', example='rst-zxjkiv5oil6f****'),
}

model GetRepoSyncTaskResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  crossUser?: boolean(name='CrossUser', description='Indicates whether the synchronization task is performed across Alibaba Cloud accounts.', example='true'),
  imageFrom?: {
    imageTag?: string(name='ImageTag', description='The tag of the image.', example='master'),
    instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-sgedpenzw80e****'),
    regionId?: string(name='RegionId', description='The region ID.', example='cn-shanghai'),
    repoName?: string(name='RepoName', description='The name of the image repository.', example='test'),
    repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.', example='test'),
  }(name='ImageFrom', description='The source address of the image.'),
  imageTo?: {
    imageTag?: string(name='ImageTag', description='The tag of the image.', example='master'),
    instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-leqzomz5vijc****'),
    regionId?: string(name='RegionId', description='The region ID.', example='eu-west-1'),
    repoName?: string(name='RepoName', description='The name of the image repository.', example='test'),
    repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.', example='test'),
  }(name='ImageTo', description='The destination address of the image.'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  layerTasks?: [ 
    {
      artifactDigest?: string(name='ArtifactDigest', description='The digest of the artifact.', example='sha256:36fb85fcb5e919cb60e782397a6be04201868fe7b38ef7669fc01caec1c8fc4e'),
      digest?: string(name='Digest', description='The digest of the image layer.', example='sha256:36fb85fcb5e919cb60e782397a6be04201868fe7b38ef7669fc01caec1c8fc4e'),
      size?: long(name='Size', description='The size of synchronized image layers.', example='23655489'),
      syncLayerTaskId?: string(name='SyncLayerTaskId', description='The ID of the synchronization task for the image layer.', example='rslt-074x4q20fx2d****'),
      syncedSize?: long(name='SyncedSize', description='The size of the image layer that is synchronized.', example='23655489'),
      taskStatus?: string(name='TaskStatus', description='The status of the synchronization task. Valid values:', example='SUCCESS'),
    }
  ](name='LayerTasks', description='The synchronization tasks for the image layer.'),
  progress?: long(name='Progress', description='The synchronization progress. Valid values:

*   `0`: The synchronization starts or failed.
*   `1`: The synchronization is successful.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A6DEF8B0-5D45-46D6-867D-8C7FF0966B07'),
  syncBatchTaskId?: string(name='SyncBatchTaskId', description='The ID of the synchronization task in which multiple images are synchronized at a time.', example='a9434731-95ef-4087-9cf4-369c8e90****'),
  syncRuleId?: string(name='SyncRuleId', description='The ID of the synchronization rule.', example='crsr-cllro6ho3wne****'),
  syncTaskId?: string(name='SyncTaskId', description='The ID of the synchronization task.', example='rst-zxjkiv5oil6f****'),
  syncTransAccelerate?: boolean(name='SyncTransAccelerate', description='Indicates whether transfer acceleration is enabled in the synchronization process.', example='true'),
  syncedSize?: long(name='SyncedSize', description='The size of the image layer that is synchronized. Unit: bytes.', example='23655489'),
  taskStatus?: string(name='TaskStatus', description='The status of the task. Valid values:', example='SUCCESS'),
  taskTrigger?: string(name='TaskTrigger', description='The policy that is used to trigger the synchronization task.', example='null'),
}

model GetRepoSyncTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoSyncTaskResponseBody(name='body'),
}

async function getRepoSyncTaskWithOptions(request: GetRepoSyncTaskRequest, runtime: Util.RuntimeOptions): GetRepoSyncTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.syncTaskId)) {
    query['SyncTaskId'] = request.syncTaskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoSyncTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoSyncTask(request: GetRepoSyncTaskRequest): GetRepoSyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoSyncTaskWithOptions(request, runtime);
}

model GetRepoTagRequest {
  instanceId?: string(name='InstanceId', description='The return value of status code.', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', description='The operation that you want to perform. Set the value to **GetRepoTag**.', example='crr-tquyps22md8p****'),
  tag?: string(name='Tag', description='The number of milliseconds that have elapsed since the image was created.', example='1.0'),
}

model GetRepoTagResponseBody = {
  code?: string(name='Code', description='The ID of the image.', example='success'),
  digest?: string(name='Digest', description='The size of the image. Unit: Bytes.', example='67bfbcc12b67936ec7f867927817cbb071832b873dbcaed312a1930ba5f1****'),
  imageCreate?: long(name='ImageCreate', description='crr-tquyps22md8p****', example='1572839125000'),
  imageId?: string(name='ImageId', example='45023655bf39c382e26a8607d057c27871dee163c1ecf48cc1ebf2a1****'),
  imageSize?: long(name='ImageSize', description='The number of milliseconds that have elapsed since the image was last updated.', example='27107966'),
  imageUpdate?: long(name='ImageUpdate', description='The ID of the request.', example='1572875608000'),
  isSuccess?: boolean(name='IsSuccess', description='The status of the image. Valid values:

*   `NORMAL`: The image is normal.
*   `DELETING`: The image is being deleted.', example='true'),
  requestId?: string(name='RequestId', description='1.0', example='031572FA-7D8F-4C05-B790-1071E0E05DE6'),
  status?: string(name='Status', description='The ID of the instance.', example='NORMAL'),
  tag?: string(name='Tag', description='The version of the repository.', example='1.0'),
}

model GetRepoTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoTagResponseBody(name='body'),
}

async function getRepoTagWithOptions(request: GetRepoTagRequest, runtime: Util.RuntimeOptions): GetRepoTagResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoTag',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoTag(request: GetRepoTagRequest): GetRepoTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoTagWithOptions(request, runtime);
}

model GetRepoTagLayersRequest {
  digest?: string(name='Digest', description='The digest of the image.', example='sha256:c851258edfe02c14772a1a3c0194a8aeb2a08c0db5e51371165b3610946f0953'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-v7m9m2g0qkqjf56p'),
  tag?: string(name='Tag', description='The tag of the image.', example='master'),
}

model GetRepoTagLayersResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  layers?: [ 
    {
      blobDigest?: string(name='BlobDigest', description='The digest of a single image layer.', example='sha256:a3ed95caeb02ffe68cdd9fd84406680ae93d633cb16422d00e8a7c22955b46d4'),
      blobSize?: long(name='BlobSize', description='The size of the image layer.', example='32'),
      layerCMD?: string(name='LayerCMD', description='Operation on the image layer.', example='["bash"]'),
      layerIndex?: int32(name='LayerIndex', description='The sequence number of the layer stack.', example='1'),
      layerInstruction?: string(name='LayerInstruction', description='The command for the image layer.', example='CMD'),
    }
  ](name='Layers', description='The queried image layers.', example='[]'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BC648259-91A7-4502-BED3-EDF64361FA83'),
}

model GetRepoTagLayersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoTagLayersResponseBody(name='body'),
}

async function getRepoTagLayersWithOptions(request: GetRepoTagLayersRequest, runtime: Util.RuntimeOptions): GetRepoTagLayersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoTagLayers',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoTagLayers(request: GetRepoTagLayersRequest): GetRepoTagLayersResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoTagLayersWithOptions(request, runtime);
}

model GetRepoTagManifestRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', description='The ID of the repository.', example='crr-kwgb20p8wwmh****'),
  schemaVersion?: int32(name='SchemaVersion', description='The schema version of the manifest. Valid values: 1 and 2.', example='2'),
  tag?: string(name='Tag', description='The tag of the image.', example='master'),
}

model GetRepoTagManifestResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  manifest?: {
    architecture?: string(name='Architecture', description='Architecture.', example='null'),
    config?: {
      digest?: string(name='Digest', description='The digest of the image.', example='sha256:b5b2b2c507a0944348e0303114d8d93aaaa081732b86451d9bce1f432a537bc7'),
      mediaType?: string(name='MediaType', description='The MIME type of the configuration file.', example='application/vnd.docker.container.image.v1+json'),
      size?: long(name='Size', description='Size', example='7023'),
    }(name='Config', description='The configuration information.'),
    fsLayers?: [ 
      {
        blobSum?: string(name='BlobSum', description='A list of filesystem layer blob sums contained in this image.', example='null'),
      }
    ](name='FsLayers', description='The digest of the referenced filesystem image layer.'),
    history?: [ 
      {
        v1Compatibility?: map[string]any(name='V1Compatibility', description='The raw V1 compatibility information.', example='null'),
      }
    ](name='History', description='A list of unstructured historical data for V1 compatibility.'),
    layers?: [ 
      {
        digest?: string(name='Digest', description='The digest of the image.', example='sha256:e692418e4cbaf90ca69d05a66403747baa33ee08806650b51fab815ad7fc331f'),
        mediaType?: string(name='MediaType', description='The MIME type of the configuration file.', example='application/vnd.docker.image.rootfs.diff.tar.gzip'),
        size?: long(name='Size', description='Size.', example='32654'),
      }
    ](name='Layers', description='The information about image layers.'),
    mediaType?: string(name='MediaType', description='The type.', example='application/vnd.docker.distribution.manifest.v2+json'),
    name?: string(name='Name', description='The name.', example='null'),
    schemaVersion?: int32(name='SchemaVersion', description='The schema version of the manifest.', example='2'),
    signatures?: [ 
      {
        header?: map[string]any(name='Header', description='The header information of the signature.', example='null'),
        protected?: string(name='Protected', description='The signed protected header.', example='null'),
        signature?: string(name='Signature', description='The signature for the image manifest.', example='null'),
      }
    ](name='Signatures', description='The information about signatures.'),
    tag?: string(name='Tag', description='The tag of the image.', example='master'),
  }(name='Manifest', description='The information about the image manifest.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='D39D7151-0299-47E3-B948-E49E1EA8D406'),
}

model GetRepoTagManifestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoTagManifestResponseBody(name='body'),
}

async function getRepoTagManifestWithOptions(request: GetRepoTagManifestRequest, runtime: Util.RuntimeOptions): GetRepoTagManifestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoTagManifest',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoTagManifest(request: GetRepoTagManifestRequest): GetRepoTagManifestResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoTagManifestWithOptions(request, runtime);
}

model GetRepoTagScanStatusRequest {
  digest?: string(name='Digest', example='67bfbcc12b67936ec7f867927817cbb071832b873dbcaed312a1930ba5f1d529'),
  instanceId?: string(name='InstanceId', example='cri-2j88dtld8yel****'),
  repoId?: string(name='RepoId', example='crr-uf082u9dg8do****'),
  scanTaskId?: string(name='ScanTaskId', example='838152F9-F725-5A52-A344-8972D65AC045'),
  tag?: string(name='Tag', example='1'),
}

model GetRepoTagScanStatusResponseBody = {
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='BC648259-91A7-4502-BED3-EDF64361FA83'),
  scanService?: string(name='ScanService', example='ACR_SCAN_SERVICE'),
  status?: string(name='Status', example='COMPLETE'),
}

model GetRepoTagScanStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoTagScanStatusResponseBody(name='body'),
}

async function getRepoTagScanStatusWithOptions(request: GetRepoTagScanStatusRequest, runtime: Util.RuntimeOptions): GetRepoTagScanStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.scanTaskId)) {
    query['ScanTaskId'] = request.scanTaskId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoTagScanStatus',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoTagScanStatus(request: GetRepoTagScanStatusRequest): GetRepoTagScanStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoTagScanStatusWithOptions(request, runtime);
}

model GetRepoTagScanSummaryRequest {
  digest?: string(name='Digest', description='The number of unknown-severity vulnerabilities.', example='sha256:c9f370a4eb1c00d0b0d7212a0a9fa4a7697756c90f0f680afaf9737a25725f4c'),
  instanceId?: string(name='InstanceId', description='The ID of the image repository.', example='cri-2j88dtld8yel****'),
  repoId?: string(name='RepoId', description='The name of the image tag.', example='crr-c2i5yk6h6pu9d5o8'),
  scanTaskId?: string(name='ScanTaskId', description='The digest of the image.', example='47A3E5A3-6AD4-5F02-93B8-59F778AE25D4'),
  tag?: string(name='Tag', description='The ID of the security scan task.', example='1'),
}

model GetRepoTagScanSummaryResponseBody = {
  code?: string(name='Code', description='The number of medium-severity vulnerabilities.', example='success'),
  highSeverity?: int32(name='HighSeverity', description='The number of low-severity vulnerabilities.', example='22'),
  isSuccess?: boolean(name='IsSuccess', description='The number of high-severity vulnerabilities.', example='true'),
  lowSeverity?: int32(name='LowSeverity', example='89'),
  mediumSeverity?: int32(name='MediumSeverity', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='81'),
  requestId?: string(name='RequestId', description='The total number of vulnerabilities detected on images.', example='BC648259-91A7-4502-BED3-EDF64361FA83'),
  totalSeverity?: int32(name='TotalSeverity', description='The return value.', example='196'),
  unknownSeverity?: int32(name='UnknownSeverity', description='The ID of the request.', example='4'),
}

model GetRepoTagScanSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoTagScanSummaryResponseBody(name='body'),
}

async function getRepoTagScanSummaryWithOptions(request: GetRepoTagScanSummaryRequest, runtime: Util.RuntimeOptions): GetRepoTagScanSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.scanTaskId)) {
    query['ScanTaskId'] = request.scanTaskId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoTagScanSummary',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoTagScanSummary(request: GetRepoTagScanSummaryRequest): GetRepoTagScanSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoTagScanSummaryWithOptions(request, runtime);
}

model GetRepositoryRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', description='The ID of the repository.', example='crr-03cuozrsqhkw****'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='test'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.', example='test'),
}

model GetRepositoryResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  createTime?: long(name='CreateTime', description='The time when the repository was created.', example='1570759546000'),
  detail?: string(name='Detail', description='The details of the repository.', example='test'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  modifiedTime?: long(name='ModifiedTime', description='The time when the repository was last modified.', example='1570759546100'),
  repoBuildType?: string(name='RepoBuildType', description='Indicates how the repository was created. Valid values:

*   `MANUAL`: The repository was manually created.
*   `AUTO`: The repository was automatically created.', example='MANUAL'),
  repoId?: string(name='RepoId', description='The ID of the repository.', example='crr-l5eoubonp0l****'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='test'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.', example='test'),
  repoStatus?: string(name='RepoStatus', description='The status of the repository.', example='NORMAL'),
  repoType?: string(name='RepoType', description='The type of the repository. Valid values:

*   `PUBLIC`: public repository.
*   `PRIVATE`: private repository.', example='PRIVATE'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='915E6734-3E50-4640-8DBA-126D2D94DE29'),
  resourceGroupId?: string(name='ResourceGroupId'),
  summary?: string(name='Summary', description='The summary of the repository.', example='Automatically created repository'),
  tagImmutability?: boolean(name='TagImmutability', description='Indicates whether the feature of image tag immutability is enabled. Valid values:

*   `true`: The feature of image tag immutability is enabled.
*   `false`: The feature of image tag immutability is disabled.', example='true'),
}

model GetRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepositoryResponseBody(name='body'),
}

async function getRepositoryWithOptions(request: GetRepositoryRequest, runtime: Util.RuntimeOptions): GetRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepository(request: GetRepositoryRequest): GetRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepositoryWithOptions(request, runtime);
}

model ListArtifactBuildTaskLogRequest {
  buildTaskId?: string(name='BuildTaskId', description='The ID of the artifact build task.', example='i2a-1yu****'),
  instanceId?: string(name='InstanceId', description='The ID of the Container Registry instance.', example='cri-shac42yvqzvq****'),
  page?: int32(name='Page', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='100'),
}

model ListArtifactBuildTaskLogResponseBody = {
  buildTaskLogs?: [ 
    {
      lineNumber?: int32(name='LineNumber', description='The row number of the log entry.', example='1'),
      message?: string(name='Message', description='The content of the log entry.', example='Start Build'),
    }
  ](name='BuildTaskLogs', description='The log entries of the artifact build task.'),
  code?: string(name='Code', description='The response code.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the API call is successful.

*   `true`: successful
*   `false`: failed', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C4C7DD0C-C9D6-437A-A7EE-121EFD70D002'),
  totalCount?: int32(name='TotalCount', description='The total number of log entries.', example='200'),
}

model ListArtifactBuildTaskLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListArtifactBuildTaskLogResponseBody(name='body'),
}

async function listArtifactBuildTaskLogWithOptions(request: ListArtifactBuildTaskLogRequest, runtime: Util.RuntimeOptions): ListArtifactBuildTaskLogResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListArtifactBuildTaskLog',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listArtifactBuildTaskLog(request: ListArtifactBuildTaskLogRequest): ListArtifactBuildTaskLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return listArtifactBuildTaskLogWithOptions(request, runtime);
}

model ListChainRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-4cdrlqmhn4gm****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='10'),
  repoName?: string(name='RepoName', description='The name of the image repository.', example='repo1'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.', example='ns1'),
}

model ListChainResponseBody = {
  chains?: [ 
    {
      chainId?: string(name='ChainId', description='The ID of the delivery chain.', example='chi-0ops0gsmw5x2****'),
      createTime?: long(name='CreateTime', description='The time when the delivery chain was created.', example='1638255427000'),
      description?: string(name='Description', description='The description of the delivery chain.', example='description'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-4cdrlqmhn4gm****'),
      modifiedTime?: long(name='ModifiedTime', description='The time when the delivery chain was last modified.', example='1638259914000'),
      name?: string(name='Name', description='The name of the delivery chain.', example='test'),
      scopeExclude?: [ string ](name='ScopeExclude', description='Repositories to which the delivery chain does not apply.'),
      scopeId?: string(name='ScopeId', description='The ID of the delivery chain scope.', example='crr-nyrh2oko32xb****'),
      scopeType?: string(name='ScopeType', description='The type of the delivery chain scope.', example='REPOSITORY'),
    }
  ](name='Chains', description='The list of delivery chains.'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='85A99B10-3926-5201-958E-C06FA47F****'),
  totalCount?: int32(name='TotalCount', description='The total number of delivery chains.', example='1'),
}

model ListChainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListChainResponseBody(name='body'),
}

async function listChainWithOptions(request: ListChainRequest, runtime: Util.RuntimeOptions): ListChainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListChain',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listChain(request: ListChainRequest): ListChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChainWithOptions(request, runtime);
}

model ListChainInstanceRequest {
  instanceId?: string(name='InstanceId', description='The operation that you want to perform. Set this parameter to **ListChainInstance**.', example='cri-kmsiwlxxdcva****'),
  pageNo?: int32(name='PageNo', description='The time when the delivery chain started.', example='1'),
  pageSize?: int32(name='PageSize', description='The name of the image repository.', example='30'),
  repoName?: string(name='RepoName', description='The time when the delivery chain is completed.', example='test-repo'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the delivery chain.', example='test-namespace'),
}

model ListChainInstanceResponseBody = {
  chainInstances?: [ 
    {
      chain?: {
        chainId?: string(name='ChainId', description='The name of the namespace.', example='chi-m42gbku0****'),
        chainName?: string(name='ChainName', description='The number of entries returned on each page.', example='test-chain'),
        version?: long(name='Version', description='The ID of the request.', example='1'),
      }(name='Chain', description='The name of the namespace.'),
      chainInstanceId?: string(name='ChainInstanceId', description='1', example='F4CF4DDB-BEF2-5575-****-*******'),
      endTime?: long(name='EndTime', description='The ID of the Container Registry instance.', example='1636685856000'),
      repoName?: string(name='RepoName', description='The ID of the delivery chain.', example='test-repo'),
      repoNamespaceName?: string(name='RepoNamespaceName', description='The execution result of the delivery chain. Valid values:

*   `SUCCESS`
*   `FAILED`
*   `CANCELED`
*   `DENIED`', example='test-ns'),
      result?: string(name='Result', description='The list of the execution records of delivery chains.', example='SUCCESS'),
      startTime?: long(name='StartTime', description='test-repo', example='1636685776000'),
      status?: string(name='Status', description='The status of the delivery chain. Valid values:

*   `RUNNING`
*   `COMPLETE`
*   `CANCELING`
*   `CANCELED`', example='COMPLETE'),
    }
  ](name='ChainInstances', description='The number of entries to return on each page.'),
  code?: string(name='Code', description='The version of the delivery chain.', example='success'),
  instanceId?: string(name='InstanceId', description='The page number of the page to return.', example='cri-kmsiwlxxdcva****'),
  isSuccess?: boolean(name='IsSuccess', description='The execution record of the delivery chain.', example='true'),
  pageNo?: int32(name='PageNo', description='30', example='1'),
  pageSize?: int32(name='PageSize', description='Indicates whether the operation is successful.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the Container Registry instance.', example='838D1602-6D8F-47FB-B60A-656645D2****'),
  totalCount?: int32(name='TotalCount', description='The name of the repository.', example='1'),
}

model ListChainInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListChainInstanceResponseBody(name='body'),
}

async function listChainInstanceWithOptions(request: ListChainInstanceRequest, runtime: Util.RuntimeOptions): ListChainInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListChainInstance',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listChainInstance(request: ListChainInstanceRequest): ListChainInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChainInstanceWithOptions(request, runtime);
}

model ListChartNamespaceRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test'),
  namespaceStatus?: string(name='NamespaceStatus', description='The status of the namespace. Valid values:

*   `NORMAL`: The namespace is normal.
*   `DELETING`: The namespace is being deleted.', example='NORMAL'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
}

model ListChartNamespaceResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  namespaces?: [ 
    {
      autoCreateRepo?: boolean(name='AutoCreateRepo', description='Indicates whether a repository was automatically created when a chart is pushed to the namespace.', example='true'),
      defaultRepoType?: string(name='DefaultRepoType', description='The default repository type. Valid values:

*   `PUBLIC`: a public repository
*   `PRIVATE`: a private repository', example='PUBLIC'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
      namespaceId?: string(name='NamespaceId', description='The ID of the namespace.', example='null'),
      namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test'),
      namespaceStatus?: string(name='NamespaceStatus', description='The status of the namespace. Valid values:

*   `NORMAL`: The namespace is normal.
*   `DELETING`: The namespace is being deleted.', example='NORMAL'),
      resourceGroupId?: string(name='ResourceGroupId'),
    }
  ](name='Namespaces', description='The namespaces.'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F56D589D-AF7F-4900-BA46-62C780AC2C10'),
  totalCount?: string(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListChartNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListChartNamespaceResponseBody(name='body'),
}

async function listChartNamespaceWithOptions(request: ListChartNamespaceRequest, runtime: Util.RuntimeOptions): ListChartNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!Util.isUnset(request.namespaceStatus)) {
    query['NamespaceStatus'] = request.namespaceStatus;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListChartNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listChartNamespace(request: ListChartNamespaceRequest): ListChartNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChartNamespaceWithOptions(request, runtime);
}

model ListChartReleaseRequest {
  chart?: string(name='Chart', description='The chart whose versions you want to query.', example='null'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='20'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='repo1'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace.', example='ns1'),
}

model ListChartReleaseResponseBody = {
  chartReleases?: [ 
    {
      chart?: string(name='Chart', description='The name of the chart version.', example='chart1'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
      modifiedTime?: long(name='ModifiedTime', description='The time when the chart was last modified.', example='1571930323000'),
      release?: string(name='Release', description='The version number of the chart.', example='0.1.0'),
      repoId?: string(name='RepoId', description='The ID of the chart repository.', example='crcr-gpsu7b8chmxk****'),
      size?: string(name='Size', description='The size of the chart of the version. Unit: bytes.', example='2826'),
      status?: string(name='Status', description='The status of the chart.', example='ENABLED'),
    }
  ](name='ChartReleases', description='The list of chart versions.'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F68823F6-F1B5-4A4E-8421-A83CAB8F2963'),
  totalCount?: string(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListChartReleaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListChartReleaseResponseBody(name='body'),
}

async function listChartReleaseWithOptions(request: ListChartReleaseRequest, runtime: Util.RuntimeOptions): ListChartReleaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chart)) {
    query['Chart'] = request.chart;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListChartRelease',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listChartRelease(request: ListChartReleaseRequest): ListChartReleaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChartReleaseWithOptions(request, runtime);
}

model ListChartRepositoryRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='ns1'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.', example='repo1'),
  repoStatus?: string(name='RepoStatus', description='The status of the chart repositories that you want to query. Valid values:

*   `ALL`: query repositories of all status.
*   `NORMAL`: query normal repositories.
*   `DELETING`: query repositories that are being deleted.', example='ALL'),
}

model ListChartRepositoryResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  repositories?: [ 
    {
      createTime?: long(name='CreateTime', description='The time when the repository was created.', example='1571926644000'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-xkx6vujuhay0****'),
      modifiedTime?: long(name='ModifiedTime', description='The time when the repository was last modified.', example='1571930329000'),
      repoId?: string(name='RepoId', description='The ID of the repository.', example='crcr-gpsu7b8chmxk****'),
      repoName?: string(name='RepoName', description='The name of the repository.', example='repo1'),
      repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.', example='ns1'),
      repoStatus?: string(name='RepoStatus', description='The status of the repository. Valid values:

*   `NORMAL`: The repository is normal.
*   `DELETING`: The repository is being deleted.', example='NORMAL'),
      repoType?: string(name='RepoType', description='The type of the repository. Valid values:

*   `PRIVATE`: a private repository
*   `PUBLIC`: a public repository', example='PUBLIC'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the repository belongs.', example='rg-aek2ikd5rxxxxxx'),
      summary?: string(name='Summary', description='The summary about the repository.', example='test'),
    }
  ](name='Repositories', description='The queried repositories.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0AB62FB8-6873-4032-8515-4578D27523B7'),
  totalCount?: string(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListChartRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListChartRepositoryResponseBody(name='body'),
}

async function listChartRepositoryWithOptions(request: ListChartRepositoryRequest, runtime: Util.RuntimeOptions): ListChartRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.repoStatus)) {
    query['RepoStatus'] = request.repoStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListChartRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listChartRepository(request: ListChartRepositoryRequest): ListChartRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChartRepositoryWithOptions(request, runtime);
}

model ListEventCenterRecordRequest {
  eventType?: string(name='EventType', description='The type of the event. Valid values:

*   `cr:Artifact:DeliveryChainCompleted`: The delivery chain is processed.
*   `cr:Artifact:SynchronizationCompleted`: The image is replicated.
*   `cr:Artifact:BuildCompleted`: The image is built.
*   `cr:Artifact:ScanCompleted`: The image is scanned.
*   `cr:Artifact:SigningCompleted`: The image is signed.', example='cr:Artifact:DeliveryChainCompleted'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
  ruleId?: string(name='RuleId', description='The ID of the event notification rule.', example='crecr-n6pbhgjxtla***'),
}

model ListEventCenterRecordResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  records?: [ 
    {
      createTime?: long(name='CreateTime', description='The time when the event was created.', example='1638188622000'),
      eventChannel?: string(name='EventChannel', description='The event notification channel.', example='EVENT_BRIDGE'),
      eventNotifyId?: string(name='EventNotifyId', description='The ID of the event notification.', example='7d478419-61df-49e5-b92b-30ce730c2127'),
      eventNotifyMethod?: string(name='EventNotifyMethod', description='The notification method. Valid values:

*   `http`: The notification is sent over HTTP.
*   `https`: The notification is sent over HTTPS.
*   `dingding`: The notification is sent by using DingTalk.', example='http'),
      eventType?: string(name='EventType', description='The type of the event.', example='cr:Artifact:DeliveryChainCompleted'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-gl34plsa****'),
      namespace?: string(name='Namespace', description='The namespace.', example='mychain'),
      recordId?: string(name='RecordId', description='The ID of the event record.', example='crecrr-ctdbzwtkpr*****'),
      repoName?: string(name='RepoName', description='The name of the image repository.', example='ruby-2.4.0'),
      ruleId?: string(name='RuleId', description='The ID of the event notification rule.', example='crecr-n6pbhgjxtla*****'),
      ruleName?: string(name='RuleName', description='The name of the event notification rule.', example='chain-demo'),
      tag?: string(name='Tag', description='The tags.', example='ruby-2.4.0'),
      updateTime?: long(name='UpdateTime', description='The time when the event was last updated.', example='1638188622000'),
    }
  ](name='Records', description='The list of historical events.', example='[]'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='665C7A5E-BAEC-5BCD-AF9F-5F9260D672BF'),
  totalCount?: int32(name='TotalCount', description='The total entries of historical events.', example='50'),
}

model ListEventCenterRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventCenterRecordResponseBody(name='body'),
}

async function listEventCenterRecordWithOptions(request: ListEventCenterRecordRequest, runtime: Util.RuntimeOptions): ListEventCenterRecordResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEventCenterRecord',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEventCenterRecord(request: ListEventCenterRecordRequest): ListEventCenterRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventCenterRecordWithOptions(request, runtime);
}

model ListEventCenterRuleNameRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
}

model ListEventCenterRuleNameResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='031572FA-7D8F-4C05-B790-1071E0E05DE6'),
  ruleNames?: [ 
    {
      ruleId?: string(name='RuleId', description='The ID of the event notification rule.', example='crecr-n6pbhgjxtl*****'),
      ruleName?: string(name='RuleName', description='The name of the event notification rule.', example='test-chain'),
    }
  ](name='RuleNames', description='The list of names of event notification rules.', example='[{\\"RuleName\\": \\"mlf\\", \\"RuleId\\": \\"crecr-73q93pgljm1pc2fp\\"}]'),
}

model ListEventCenterRuleNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventCenterRuleNameResponseBody(name='body'),
}

async function listEventCenterRuleNameWithOptions(request: ListEventCenterRuleNameRequest, runtime: Util.RuntimeOptions): ListEventCenterRuleNameResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEventCenterRuleName',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEventCenterRuleName(request: ListEventCenterRuleNameRequest): ListEventCenterRuleNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventCenterRuleNameWithOptions(request, runtime);
}

model ListInstanceRequest {
  instanceName?: string(name='InstanceName', example='test'),
  instanceStatus?: string(name='InstanceStatus', example='RUNNING'),
  pageNo?: int32(name='PageNo', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-acfmv36i4is****'),
}

model ListInstanceResponseBody = {
  code?: string(name='Code', example='success'),
  instances?: [ 
    {
      createTime?: string(name='CreateTime', example='1562849679000'),
      instanceId?: string(name='InstanceId', example='cri-sgedpenzw80e****'),
      instanceIssue?: string(name='InstanceIssue'),
      instanceName?: string(name='InstanceName', example='test'),
      instanceSpecification?: string(name='InstanceSpecification', example='Enterprise_Basic'),
      instanceStatus?: string(name='InstanceStatus', example='RUNNING'),
      modifiedTime?: string(name='ModifiedTime', example='1562849760000'),
      regionId?: string(name='RegionId', example='cn-shanghai'),
      resourceGroupId?: string(name='ResourceGroupId'),
    }
  ](name='Instances'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  pageNo?: int32(name='PageNo', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  requestId?: string(name='RequestId', example='A2A9BA68-B264-4953-9154-CE61B1C03BA6'),
  totalCount?: int32(name='TotalCount', example='12121'),
}

model ListInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceResponseBody(name='body'),
}

async function listInstanceWithOptions(request: ListInstanceRequest, runtime: Util.RuntimeOptions): ListInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceStatus)) {
    query['InstanceStatus'] = request.instanceStatus;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstance',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstance(request: ListInstanceRequest): ListInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceWithOptions(request, runtime);
}

model ListInstanceEndpointRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  moduleName?: string(name='ModuleName', description='The name of the module that you want to access. Valid values:

*   `Registry`: the image repository.
*   `Chart`: a Helm chart.', example='Chart'),
}

model ListInstanceEndpointResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  endpoints?: [ 
    {
      aclEnable?: boolean(name='AclEnable', description='Indicates whether the access control list (ACL) feature is enabled.', example='true'),
      aclEntries?: [ 
        {
          entry?: string(name='Entry', description='Details about the ACL.', example='null'),
        }
      ](name='AclEntries', description='The ACL configured for the instance.'),
      domains?: [ 
        {
          domain?: string(name='Domain', description='The domain name.', example='t****-registry.cn-shanghai.cr.aliyuncs.com'),
          type?: string(name='Type', description='Type', example='SYSTEM'),
        }
      ](name='Domains', description='Domain names.'),
      enable?: boolean(name='Enable', description='Indicates whether the ACL feature is enabled.', example='true'),
      endpointType?: string(name='EndpointType', description='The type of the endpoint.', example='internet'),
      linkedVpcs?: [ 
        {
          vpcId?: string(name='VpcId', description='VPC ID', example='null'),
        }
      ](name='LinkedVpcs', description='The virtual private clouds (VPCs) that are associated with the instance.'),
      status?: string(name='Status', description='The status of the instance.', example='RUNNING'),
    }
  ](name='Endpoints', description='The endpoints of the instance.'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1B21A877-66A2-4095-90EB-20A7781A4A67'),
}

model ListInstanceEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceEndpointResponseBody(name='body'),
}

async function listInstanceEndpointWithOptions(request: ListInstanceEndpointRequest, runtime: Util.RuntimeOptions): ListInstanceEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceEndpoint',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceEndpoint(request: ListInstanceEndpointRequest): ListInstanceEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceEndpointWithOptions(request, runtime);
}

model ListInstanceRegionRequest {
  lang?: string(name='Lang', description='The language used for response parameters. Set this parameter to `zh-CN`.', example='zh-CN'),
}

model ListInstanceRegionResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  regions?: [ 
    {
      localName?: string(name='LocalName', description='The name of the region.', example='China (Shenzhen)'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-shenzhen'),
    }
  ](name='Regions', description='The list of regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='11F182E1-0F84-4F5B-8D3B-61E991482727'),
}

model ListInstanceRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceRegionResponseBody(name='body'),
}

async function listInstanceRegionWithOptions(request: ListInstanceRegionRequest, runtime: Util.RuntimeOptions): ListInstanceRegionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceRegion',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceRegion(request: ListInstanceRegionRequest): ListInstanceRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceRegionWithOptions(request, runtime);
}

model ListNamespaceRequest {
  instanceId?: string(name='InstanceId', description='The number of the page to return.', example='cri-94klsruryslx****'),
  namespaceName?: string(name='NamespaceName', description='The number of entries returned per page.', example='test-namespace'),
  namespaceStatus?: string(name='NamespaceStatus', description='The ID of the namespace.', example='NORMAL'),
  pageNo?: int32(name='PageNo', description='The list of namespaces.', example='1'),
  pageSize?: int32(name='PageSize', description='The ID of the request.', example='30'),
}

model ListNamespaceResponseBody = {
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  namespaces?: [ 
    {
      autoCreateRepo?: boolean(name='AutoCreateRepo', example='true'),
      defaultRepoType?: string(name='DefaultRepoType', example='PUBLIC'),
      instanceId?: string(name='InstanceId', example='cri-94klsruryslx****'),
      namespaceId?: string(name='NamespaceId', example='crn-tiw8t3f8i5lt****'),
      namespaceName?: string(name='NamespaceName', example='test'),
      namespaceStatus?: string(name='NamespaceStatus', example='NORMAL'),
      resourceGroupId?: string(name='ResourceGroupId', example='rg-acfm4n5kzyf2fbi'),
    }
  ](name='Namespaces'),
  pageNo?: int32(name='PageNo', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  requestId?: string(name='RequestId', example='B7E5FCA5-55ED-451C-9649-0BB2B93387D0'),
  totalCount?: string(name='TotalCount', example='1'),
}

model ListNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNamespaceResponseBody(name='body'),
}

async function listNamespaceWithOptions(request: ListNamespaceRequest, runtime: Util.RuntimeOptions): ListNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!Util.isUnset(request.namespaceStatus)) {
    query['NamespaceStatus'] = request.namespaceStatus;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNamespace(request: ListNamespaceRequest): ListNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNamespaceWithOptions(request, runtime);
}

model ListRepoBuildRecordRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
  repoId?: string(name='RepoId', description='The ID of the repository.', example='crr-tquyps22md8****'),
}

model ListRepoBuildRecordResponseBody = {
  buildRecords?: [ 
    {
      buildRecordId?: string(name='BuildRecordId', description='The ID of the image building record.', example='537e08ab-735e-415f-b7c2-160eb87f8****'),
      buildStatus?: string(name='BuildStatus', description='The status of the image building.', example='SUCCESS'),
      endTime?: string(name='EndTime', description='The time when the image building ended.', example='1572875610000'),
      image?: {
        imageTag?: string(name='ImageTag', description='The tag of the image.', example='v0.1'),
        repoId?: string(name='RepoId', description='The ID of the repository.', example='crr-gzsrlevmvoaq****'),
        repoName?: string(name='RepoName', description='The name of the repository.', example='test'),
        repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.', example='test'),
      }(name='Image', description='The information about the image.'),
      startTime?: string(name='StartTime', description='The time when the image building started.', example='1572872207000'),
    }
  ](name='BuildRecords', description='The list of image building records.'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9D23DEDF-E91D-434B-B7D5-9D12C648D166'),
  totalCount?: string(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListRepoBuildRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoBuildRecordResponseBody(name='body'),
}

async function listRepoBuildRecordWithOptions(request: ListRepoBuildRecordRequest, runtime: Util.RuntimeOptions): ListRepoBuildRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoBuildRecord',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoBuildRecord(request: ListRepoBuildRecordRequest): ListRepoBuildRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoBuildRecordWithOptions(request, runtime);
}

model ListRepoBuildRecordLogRequest {
  buildRecordId?: string(name='BuildRecordId', description='The ID of the image building record.', example='C5B4D5D7-A1C6-4E9B-ABD2-401361C4****'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-nmbv37dlv5d3****'),
  offset?: int32(name='Offset', description='The offset of log lines.', example='0'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-z4dvahhku9wv4****'),
}

model ListRepoBuildRecordLogResponseBody = {
  buildRecordLogs?: [ 
    {
      buildStage?: string(name='BuildStage', description='The stage of the building that is recorded in the log entry.', example='GIT_CLONE'),
      lineNumber?: int32(name='LineNumber', description='The line number of the log entry.', example='2'),
      message?: string(name='Message', description='The content of the log.', example='fetch stage begin'),
    }
  ](name='BuildRecordLogs', description='The log content of the image building record.'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='100'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4CE1F661-75DD-4EBD-A4AD-057B26834ABB'),
  totalCount?: string(name='TotalCount', description='The total number of returned entries.', example='1000'),
}

model ListRepoBuildRecordLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoBuildRecordLogResponseBody(name='body'),
}

async function listRepoBuildRecordLogWithOptions(request: ListRepoBuildRecordLogRequest, runtime: Util.RuntimeOptions): ListRepoBuildRecordLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildRecordId)) {
    query['BuildRecordId'] = request.buildRecordId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.offset)) {
    query['Offset'] = request.offset;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoBuildRecordLog',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoBuildRecordLog(request: ListRepoBuildRecordLogRequest): ListRepoBuildRecordLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoBuildRecordLogWithOptions(request, runtime);
}

model ListRepoBuildRuleRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-tquyps22md8****'),
}

model ListRepoBuildRuleResponseBody = {
  buildRules?: [ 
    {
      buildArgs?: [ string ](name='BuildArgs'),
      buildRuleId?: string(name='BuildRuleId', description='The ID of the image building rule.', example='crbr-khys0nd3asbe****'),
      dockerfileLocation?: string(name='DockerfileLocation', description='The directory of the Dockerfile.', example='/'),
      dockerfileName?: string(name='DockerfileName', description='The name of the Dockerfile.', example='Dockerfile'),
      imageTag?: string(name='ImageTag', description='The tag of the image.', example='v0.1'),
      platforms?: [ string ](name='Platforms'),
      pushName?: string(name='PushName', description='The name of the push that triggers the building rule.', example='v0.1'),
      pushType?: string(name='PushType', description='The type of the push that triggers the image building rule. Valid values:

*   GIT_BRANCH: branch push
*   GIT_TAG: tag push', example='GIT_BRANCH'),
    }
  ](name='BuildRules', description='The list of image building rules.'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='42D782C8-E8F6-4A32-BEA0-6A6AC854C22A'),
  totalCount?: string(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListRepoBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoBuildRuleResponseBody(name='body'),
}

async function listRepoBuildRuleWithOptions(request: ListRepoBuildRuleRequest, runtime: Util.RuntimeOptions): ListRepoBuildRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoBuildRule(request: ListRepoBuildRuleRequest): ListRepoBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoBuildRuleWithOptions(request, runtime);
}

model ListRepoSyncRuleRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test-namespace'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
  repoName?: string(name='RepoName', description='The name of the image repository.', example='test-repo'),
  targetInstanceId?: string(name='TargetInstanceId', description='The ID of the destination instance.', example='cri-k77rd2eo9ztt****'),
  targetRegionId?: string(name='TargetRegionId', description='The region ID of the destination instance.', example='cn-shenzhen'),
}

model ListRepoSyncRuleResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='838D1602-6D8F-47FB-B60A-656645D2****'),
  syncRules?: [ 
    {
      createTime?: long(name='CreateTime', description='The time when the synchronization rule was created.', example='1572604642000'),
      crossUser?: boolean(name='CrossUser', description='Indicates whether images are synchronized across Alibaba Cloud accounts. Valid values:

*   `true`: Images are synchronized across Alibaba Cloud accounts.
*   `false`: Images are synchronized within the same Alibaba Cloud account.

Default value: `false`', example='true'),
      localInstanceId?: string(name='LocalInstanceId', description='The ID of the source instance.', example='cri-kmsiwlxxdcva****'),
      localNamespaceName?: string(name='LocalNamespaceName', description='The namespace name of the source instance.', example='test'),
      localRegionId?: string(name='LocalRegionId', description='The region ID of the source instance.', example='cn-shanghai'),
      localRepoName?: string(name='LocalRepoName', description='The image repository name of the source instance.', example='test-repo-local'),
      modifiedTime?: long(name='ModifiedTime', description='The time when the synchronization rule was last modified.', example='1572604642000'),
      syncDirection?: string(name='SyncDirection', description='The synchronization direction. Valid values:

*   `FROM`: Images are synchronized from the source instance to the destination instance.
*   `TO`: Images are synchronized from the destination instance to the source instance.', example='FROM'),
      syncRuleId?: string(name='SyncRuleId', description='The ID of the synchronization rule.', example='crsr-7lph66uloi6h****'),
      syncRuleName?: string(name='SyncRuleName', description='The name of the synchronization rule.', example='sync-rule-1'),
      syncScope?: string(name='SyncScope', description='The synchronization scope. Valid values:

*   `NAMESPACE`: synchronizes the image tags in a namespace that meet the synchronization rule.
*   `REPO`: synchronizes the image tags in an image repository that meet the synchronization rule.', example='NAMESPACE'),
      syncTrigger?: string(name='SyncTrigger', description='The policy that is applied to trigger the synchronization rule. Valid values:

*   `INITIATIVE`: The synchronization rule is positively triggered.
*   `PASSIVE`: The synchronization rule is passively triggered.', example='PASSIVE'),
      tagFilter?: string(name='TagFilter', description='The regular expression that is used to filter image tags.', example='.*'),
      targetInstanceId?: string(name='TargetInstanceId', description='The ID of the destination instance.', example='cri-k77rd2eo9ztt****'),
      targetNamespaceName?: string(name='TargetNamespaceName', description='The namespace name of the destination instance.', example='test'),
      targetRegionId?: string(name='TargetRegionId', description='The region ID of the destination instance.', example='cn-shenzhen'),
      targetRepoName?: string(name='TargetRepoName', description='The image repository name of the destination instance.', example='test-repo-target'),
    }
  ](name='SyncRules', description='The synchronization rules.'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListRepoSyncRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoSyncRuleResponseBody(name='body'),
}

async function listRepoSyncRuleWithOptions(request: ListRepoSyncRuleRequest, runtime: Util.RuntimeOptions): ListRepoSyncRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.targetInstanceId)) {
    query['TargetInstanceId'] = request.targetInstanceId;
  }
  if (!Util.isUnset(request.targetRegionId)) {
    query['TargetRegionId'] = request.targetRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoSyncRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoSyncRule(request: ListRepoSyncRuleRequest): ListRepoSyncRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoSyncRuleWithOptions(request, runtime);
}

model ListRepoSyncTaskRequest {
  instanceId?: string(name='InstanceId', example='cri-kmsiwlxxdcva****'),
  pageNo?: int32(name='PageNo', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  repoName?: string(name='RepoName', example='test'),
  repoNamespaceName?: string(name='RepoNamespaceName', example='ns'),
  syncRecordId?: string(name='SyncRecordId', example='crsr-7lph66uloi6h****'),
  tag?: string(name='Tag', example='nginx'),
}

model ListRepoSyncTaskResponseBody = {
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  pageNo?: int32(name='PageNo', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  requestId?: string(name='RequestId', example='7640819A-FB5B-4E25-A227-97717F62****'),
  syncTasks?: [ 
    {
      createTime?: long(name='CreateTime', example='1572839126000'),
      crossUser?: boolean(name='CrossUser', example='true'),
      customLink?: boolean(name='CustomLink', example='true'),
      imageFrom?: {
        imageTag?: string(name='ImageTag', example='v0.1'),
        instanceId?: string(name='InstanceId', example='cri-kmsiwlxxdcva****'),
        regionId?: string(name='RegionId', example='cn-shanghai'),
        repoName?: string(name='RepoName', example='test'),
        repoNamespaceName?: string(name='RepoNamespaceName', example='test'),
      }(name='ImageFrom'),
      imageTo?: {
        imageTag?: string(name='ImageTag', example='v0.1'),
        instanceId?: string(name='InstanceId', example='cri-k77rd2eo9zttneqo'),
        regionId?: string(name='RegionId', example='cn-shenzhen'),
        repoName?: string(name='RepoName', example='test'),
        repoNamespaceName?: string(name='RepoNamespaceName', example='test'),
      }(name='ImageTo'),
      modifedTime?: long(name='ModifedTime', example='1572839133000'),
      syncBatchTaskId?: string(name='SyncBatchTaskId', example='15DEEB56-9271-4FDD-AC4D-C3A5CC2C****'),
      syncRuleId?: string(name='SyncRuleId', example='crsr-7lph66uloi6h****'),
      syncTaskId?: string(name='SyncTaskId', example='rst-4kfd7fk6pohk****'),
      syncTransAccelerate?: boolean(name='SyncTransAccelerate', example='true'),
      taskStatus?: string(name='TaskStatus', example='SUCCESS'),
      taskTrigger?: string(name='TaskTrigger', example='PASSIVE'),
    }
  ](name='SyncTasks'),
  totalCount?: string(name='TotalCount', example='1'),
}

model ListRepoSyncTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoSyncTaskResponseBody(name='body'),
}

async function listRepoSyncTaskWithOptions(request: ListRepoSyncTaskRequest, runtime: Util.RuntimeOptions): ListRepoSyncTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.syncRecordId)) {
    query['SyncRecordId'] = request.syncRecordId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoSyncTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoSyncTask(request: ListRepoSyncTaskRequest): ListRepoSyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoSyncTaskWithOptions(request, runtime);
}

model ListRepoTagRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
  repoId?: string(name='RepoId', description='The ID of the repository.', example='crr-tquyps22md8p****'),
}

model ListRepoTagResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  images?: [ 
    {
      digest?: string(name='Digest', description='The digest of the image.', example='67bfbcc12b67936ec7f867927817cbb071832b873dbcaed312a1930ba5f1****'),
      imageCreate?: string(name='ImageCreate', description='The time when the image was created.', example='1572839125000'),
      imageId?: string(name='ImageId', description='The ID of the image.', example='45023655bf39c382e26a8607d057c27871dee163c1ecf48cc1ebf2a1****'),
      imageSize?: long(name='ImageSize', description='The size of the image.', example='27107966'),
      imageUpdate?: string(name='ImageUpdate', description='The time when the image was last updated.', example='1572875608000'),
      status?: string(name='Status', description='The status of the image.', example='NORMAL'),
      tag?: string(name='Tag', description='The tag of the image.', example='v0.1'),
    }
  ](name='Images', description='The images.'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  pageNo?: int32(name='PageNo', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='031572FA-7D8F-4C05-B790-1071E0E05DE6'),
  totalCount?: string(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model ListRepoTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoTagResponseBody(name='body'),
}

async function listRepoTagWithOptions(request: ListRepoTagRequest, runtime: Util.RuntimeOptions): ListRepoTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoTag',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoTag(request: ListRepoTagRequest): ListRepoTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoTagWithOptions(request, runtime);
}

model ListRepoTagScanResultRequest {
  digest?: string(name='Digest', description='The digest of the image.', example='sha256:6b0b094f8a904f8fb6602427aed0d1fa'),
  filterValue?: string(name='FilterValue', description='The parameter whose value that you want to query. Fox example, if the value is `FixCmd`, only the `FixCmd` parameter is returned.', example='FixCmd'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-2j88dtld8yel****'),
  pageNo?: int32(name='PageNo', description='The number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.', example='30'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-uf082u9dg8do****'),
  scanTaskId?: string(name='ScanTaskId', description='The ID of the security scan task.', example='6b0b094f-8a90-4f8f-b660-2427aed0****'),
  scanType?: string(name='ScanType', description='The type of the vulnerability. Valid values:

*   `cve`: image system vulnerability
*   `sca`: image application vulnerability', example='sca'),
  severity?: string(name='Severity', description='The severity of the vulnerability. Valid values:

*   `High`
*   `Medium`
*   `Low`
*   `Unknown`', example='High'),
  tag?: string(name='Tag', description='The name of the image tag.', example='1'),
  vulQueryKey?: string(name='VulQueryKey', description='The keyword for fuzzy search used in scanning. The value can be a CVE name.', example='CVE-2021'),
}

model ListRepoTagScanResultResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request failed.', example='true'),
  pageNo?: int32(name='PageNo', description='The number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='30'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='56B5C92F-F5D9-46E0-823F-EC71D1892DAA'),
  totalCount?: int32(name='TotalCount', description='The total number of vulnerabilities detected on images.', example='196'),
  vulnerabilities?: [ 
    {
      addedBy?: string(name='AddedBy', description='The ID of the image layer where the vulnerability was detected.', example='sha256:123456717b8e40b6480979b739010d8d549989602bcdd07922119aec6f9dbe57'),
      aliasName?: string(name='AliasName', description='The name of the vulnerability.', example='Vulnerability'),
      cveLink?: string(name='CveLink', description='The URL of the vulnerability.', example='https://security-tracker.debian.org/tracker/CVE-2009-5155'),
      cveLocation?: string(name='CveLocation', description='The directory of the vulnerability.', example='/test.txt'),
      cveName?: string(name='CveName', description='The name of the vulnerability.', example='CVE-2009-5155'),
      description?: string(name='Description', description='The description of the vulnerability.', example='description.'),
      feature?: string(name='Feature', description='The cause of the vulnerability.', example='eglibc'),
      fixCmd?: string(name='FixCmd', description='The command used to fix the vulnerability.', example='yum install -y xxx'),
      scanType?: string(name='ScanType', description='The type of the vulnerability. Valid values:

*   `cve`: image system vulnerability
*   `sca`: image application vulnerability', example='cve'),
      severity?: string(name='Severity', description='The severity of the vulnerability.', example='Medium'),
      version?: string(name='Version', description='The version of the vulnerability.', example='2.19-6.9'),
      versionFixed?: string(name='VersionFixed', description='The version where the vulnerability was fixed.', example='2.19-18+deb8u5'),
      versionFormat?: string(name='VersionFormat', description='The format of the vulnerability.', example='dpkg'),
    }
  ](name='Vulnerabilities', description='The details about the detected vulnerabilities.'),
}

model ListRepoTagScanResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoTagScanResultResponseBody(name='body'),
}

async function listRepoTagScanResultWithOptions(request: ListRepoTagScanResultRequest, runtime: Util.RuntimeOptions): ListRepoTagScanResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.filterValue)) {
    query['FilterValue'] = request.filterValue;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.scanTaskId)) {
    query['ScanTaskId'] = request.scanTaskId;
  }
  if (!Util.isUnset(request.scanType)) {
    query['ScanType'] = request.scanType;
  }
  if (!Util.isUnset(request.severity)) {
    query['Severity'] = request.severity;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vulQueryKey)) {
    query['VulQueryKey'] = request.vulQueryKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoTagScanResult',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoTagScanResult(request: ListRepoTagScanResultRequest): ListRepoTagScanResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoTagScanResultWithOptions(request, runtime);
}

model ListRepoTriggerRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', description='The ID of the repository.', example='crr-tquyps22md8p****'),
}

model ListRepoTriggerResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2CA76D52-A8F0-4D0B-854E-FBD9F6C99049'),
  triggers?: [ 
    {
      repoEvent?: string(name='RepoEvent', description='The type of the event that activates the trigger. Valid values:

*   `BUILD_SUCCESS`: The trigger is activated when an image building task is successful.
*   `BUILD_Fail`: The trigger is activated when an image building task fails.', example='BUILD_SUCCESS'),
      triggerId?: string(name='TriggerId', description='The ID of the trigger.', example='crw-vriyql9eq7ep****'),
      triggerName?: string(name='TriggerName', description='The name of the trigger.', example='test'),
      triggerTag?: string(name='TriggerTag', description='The image tag based on which the trigger is set.', example='*'),
      triggerType?: string(name='TriggerType', description='The type of the trigger. Valid values:

*   `ALL`: a trigger that supports both tags and regular expressions.
*   `TAG_LISTTAG`: a tag-based trigger.
*   `TAG_REG_EXP`: a regular expression-based trigger.', example='ALL'),
      triggerUrl?: string(name='TriggerUrl', description='The URL of the trigger.', example='https://www.test.com'),
    }
  ](name='Triggers', description='The triggers of the repository.'),
}

model ListRepoTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoTriggerResponseBody(name='body'),
}

async function listRepoTriggerWithOptions(request: ListRepoTriggerRequest, runtime: Util.RuntimeOptions): ListRepoTriggerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoTrigger',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoTrigger(request: ListRepoTriggerRequest): ListRepoTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoTriggerWithOptions(request, runtime);
}

model ListRepositoryRequest {
  instanceId?: string(name='InstanceId', example='cri-kmsiwlxxdcva****'),
  pageNo?: int32(name='PageNo', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  repoName?: string(name='RepoName', example='repo-test'),
  repoNamespaceName?: string(name='RepoNamespaceName', example='repo-namespace-test'),
  repoStatus?: string(name='RepoStatus', example='ALL'),
}

model ListRepositoryResponseBody = {
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  pageNo?: int32(name='PageNo', example='1'),
  pageSize?: int32(name='PageSize', example='30'),
  repositories?: [ 
    {
      createTime?: long(name='CreateTime', example='1564153576000'),
      instanceId?: string(name='InstanceId', example='cri-kmsiwlxxdcv****'),
      modifiedTime?: long(name='ModifiedTime', example='1564153576000'),
      repoBuildType?: string(name='RepoBuildType', example='MANUAL'),
      repoId?: string(name='RepoId', example='crr-03cuozrsqhkw****'),
      repoName?: string(name='RepoName', example='test'),
      repoNamespaceName?: string(name='RepoNamespaceName', example='test'),
      repoStatus?: string(name='RepoStatus', example='NORMAL'),
      repoType?: string(name='RepoType', example='PRIVATE'),
      resourceGroupId?: string(name='ResourceGroupId'),
      summary?: string(name='Summary', example='test OK'),
      tagImmutability?: boolean(name='TagImmutability', example='true'),
    }
  ](name='Repositories'),
  requestId?: string(name='RequestId', example='5241C090-DA69-4B0F-8E3F-2F24FDE1110E'),
  totalCount?: string(name='TotalCount', example='1'),
}

model ListRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoryResponseBody(name='body'),
}

async function listRepositoryWithOptions(request: ListRepositoryRequest, runtime: Util.RuntimeOptions): ListRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.repoStatus)) {
    query['RepoStatus'] = request.repoStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepository(request: ListRepositoryRequest): ListRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepositoryWithOptions(request, runtime);
}

model ResetLoginPasswordRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  password?: string(name='Password', description='The new password that you specify to log on to the instance. The password must be 8 to 32 bits in length, and must contain at least two of the following character types: letters, special characters, and digits.', example='test'),
}

model ResetLoginPasswordResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EB9C5722-51E2-4497-A573-575B0CA5CE0C'),
}

model ResetLoginPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetLoginPasswordResponseBody(name='body'),
}

async function resetLoginPasswordWithOptions(request: ResetLoginPasswordRequest, runtime: Util.RuntimeOptions): ResetLoginPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetLoginPassword',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetLoginPassword(request: ResetLoginPasswordRequest): ResetLoginPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetLoginPasswordWithOptions(request, runtime);
}

model UpdateChainRequest {
  chainConfig?: string(name='ChainConfig', description='The configuration of the delivery chain in the JSON format.', example='chainconfig'),
  chainId?: string(name='ChainId', description='The ID of the delivery chain.', example='chi-02ymhtwl3cq8****'),
  description?: string(name='Description', description='The description of the delivery chain.', example='description'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-4cdrlqmhn4gm****'),
  name?: string(name='Name', description='The name of the delivery chain.', example='test'),
  scopeExclude?: [ string ](name='ScopeExclude', description='Repositories in which the delivery chain does not take effect.'),
}

model UpdateChainResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='85A99B10-3926-5201-958E-C06FA47F****'),
}

model UpdateChainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateChainResponseBody(name='body'),
}

async function updateChainWithOptions(request: UpdateChainRequest, runtime: Util.RuntimeOptions): UpdateChainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chainConfig)) {
    query['ChainConfig'] = request.chainConfig;
  }
  if (!Util.isUnset(request.chainId)) {
    query['ChainId'] = request.chainId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.scopeExclude)) {
    query['ScopeExclude'] = request.scopeExclude;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateChain',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateChain(request: UpdateChainRequest): UpdateChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateChainWithOptions(request, runtime);
}

model UpdateChartNamespaceRequest {
  autoCreateRepo?: boolean(name='AutoCreateRepo', description='Specifies whether to automatically create repositories in the namespace. Valid values:

*   `true`: automatically creates repositories in the namespace.
*   `false`: does not automatically create repositories in the namespace.', example='true'),
  defaultRepoType?: string(name='DefaultRepoType', description='The default type of the repository. Valid values:

*   `PUBLIC`: a public repository
*   `PRIVATE`: a private repository', example='PUBLIC'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace to which the repository belongs.', example='test'),
}

model UpdateChartNamespaceResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6877B80A-2895-44C4-BC9E-703B157DEE66'),
}

model UpdateChartNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateChartNamespaceResponseBody(name='body'),
}

async function updateChartNamespaceWithOptions(request: UpdateChartNamespaceRequest, runtime: Util.RuntimeOptions): UpdateChartNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoCreateRepo)) {
    query['AutoCreateRepo'] = request.autoCreateRepo;
  }
  if (!Util.isUnset(request.defaultRepoType)) {
    query['DefaultRepoType'] = request.defaultRepoType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateChartNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateChartNamespace(request: UpdateChartNamespaceRequest): UpdateChartNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateChartNamespaceWithOptions(request, runtime);
}

model UpdateChartRepositoryRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  repoName?: string(name='RepoName', description='The name of the repository.', example='test'),
  repoNamespaceName?: string(name='RepoNamespaceName', description='The name of the namespace to which the repository belongs.', example='test'),
  repoType?: string(name='RepoType', description='The type of the repository. Valid values:

*   `PUBLIC`: a public repository.
*   `PRIVATE`: a private repository.', example='PUBLIC'),
  summary?: string(name='Summary', description='The summary of the repository.', example='test'),
}

model UpdateChartRepositoryResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EB9C5722-51E2-4497-A573-575B0CA5CE0C'),
}

model UpdateChartRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateChartRepositoryResponseBody(name='body'),
}

async function updateChartRepositoryWithOptions(request: UpdateChartRepositoryRequest, runtime: Util.RuntimeOptions): UpdateChartRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.repoType)) {
    query['RepoType'] = request.repoType;
  }
  if (!Util.isUnset(request.summary)) {
    query['Summary'] = request.summary;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateChartRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateChartRepository(request: UpdateChartRepositoryRequest): UpdateChartRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateChartRepositoryWithOptions(request, runtime);
}

model UpdateEventCenterRuleRequest {
  eventChannel?: string(name='EventChannel', description='The event notification channel.', example='EVENT_BRIDGE'),
  eventConfig?: string(name='EventConfig', description='The event configuration.', example='{
        "notifyMethod":"http",
        "notifyConfig":{
            "Url":"http://www.aliyundoc.com",
            "id":"MaAV3HgTkO5Fh8l1V********",
        },
        "notifyFilter":{}
    }'),
  eventScope?: string(name='EventScope', description='The event scope. Valid values:

*   `INSTANCE`
*   `NAMESPACE`
*   `REPO`

Default value: `INSTANCE`', example='INSTANCE'),
  eventType?: string(name='EventType', description='The type of the event. Valid values:

*   `cr:Artifact:DeliveryChainCompleted`: The delivery chain is processed.
*   `cr:Artifact:SynchronizationCompleted`: The image is replicated.
*   `cr:Artifact:BuildCompleted`: The image is built.
*   `cr:Artifact:ScanCompleted`: The image is scanned.
*   `cr:Artifact:SigningCompleted`: The image is signed.', example='cr:Artifact:DeliveryChainCompleted'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  namespaces?: [ string ](name='Namespaces', description='The namespaces to which the event notification rule applies.', example='ns'),
  repoNames?: [ string ](name='RepoNames', description='The names of the repositories to which the event notification rule applies.', example='reponame'),
  repoTagFilterPattern?: string(name='RepoTagFilterPattern', description='The regular expression for image tags.', example='.*'),
  ruleId?: string(name='RuleId', description='The ID of the event notification rule.', example='crecr-n6pbhgjxt*****'),
  ruleName?: string(name='RuleName', description='The name of the event notification rule.', example='chain-demo'),
}

model UpdateEventCenterRuleShrinkRequest {
  eventChannel?: string(name='EventChannel', description='The event notification channel.', example='EVENT_BRIDGE'),
  eventConfig?: string(name='EventConfig', description='The event configuration.', example='{
        "notifyMethod":"http",
        "notifyConfig":{
            "Url":"http://www.aliyundoc.com",
            "id":"MaAV3HgTkO5Fh8l1V********",
        },
        "notifyFilter":{}
    }'),
  eventScope?: string(name='EventScope', description='The event scope. Valid values:

*   `INSTANCE`
*   `NAMESPACE`
*   `REPO`

Default value: `INSTANCE`', example='INSTANCE'),
  eventType?: string(name='EventType', description='The type of the event. Valid values:

*   `cr:Artifact:DeliveryChainCompleted`: The delivery chain is processed.
*   `cr:Artifact:SynchronizationCompleted`: The image is replicated.
*   `cr:Artifact:BuildCompleted`: The image is built.
*   `cr:Artifact:ScanCompleted`: The image is scanned.
*   `cr:Artifact:SigningCompleted`: The image is signed.', example='cr:Artifact:DeliveryChainCompleted'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  namespacesShrink?: string(name='Namespaces', description='The namespaces to which the event notification rule applies.', example='ns'),
  repoNamesShrink?: string(name='RepoNames', description='The names of the repositories to which the event notification rule applies.', example='reponame'),
  repoTagFilterPattern?: string(name='RepoTagFilterPattern', description='The regular expression for image tags.', example='.*'),
  ruleId?: string(name='RuleId', description='The ID of the event notification rule.', example='crecr-n6pbhgjxt*****'),
  ruleName?: string(name='RuleName', description='The name of the event notification rule.', example='chain-demo'),
}

model UpdateEventCenterRuleResponseBody = {
  code?: int32(name='Code', description='The status code.', example='200'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='031572FA-7D8F-4C05-B790-1071E0E05DE6'),
  ruleId?: string(name='RuleId', description='The ID of the event notification rule.', example='crecr-n6pbhgjxt*****'),
}

model UpdateEventCenterRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEventCenterRuleResponseBody(name='body'),
}

async function updateEventCenterRuleWithOptions(tmpReq: UpdateEventCenterRuleRequest, runtime: Util.RuntimeOptions): UpdateEventCenterRuleResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateEventCenterRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.namespaces)) {
    request.namespacesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.namespaces, 'Namespaces', 'json');
  }
  if (!Util.isUnset(tmpReq.repoNames)) {
    request.repoNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.repoNames, 'RepoNames', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.eventChannel)) {
    query['EventChannel'] = request.eventChannel;
  }
  if (!Util.isUnset(request.eventConfig)) {
    query['EventConfig'] = request.eventConfig;
  }
  if (!Util.isUnset(request.eventScope)) {
    query['EventScope'] = request.eventScope;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespacesShrink)) {
    query['Namespaces'] = request.namespacesShrink;
  }
  if (!Util.isUnset(request.repoNamesShrink)) {
    query['RepoNames'] = request.repoNamesShrink;
  }
  if (!Util.isUnset(request.repoTagFilterPattern)) {
    query['RepoTagFilterPattern'] = request.repoTagFilterPattern;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEventCenterRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateEventCenterRule(request: UpdateEventCenterRuleRequest): UpdateEventCenterRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEventCenterRuleWithOptions(request, runtime);
}

model UpdateInstanceEndpointStatusRequest {
  enable?: boolean(name='Enable', description='Specifies whether to enable the instance endpoint. Valid values:

*   `true`: enables the instance endpoint.
*   `false`: disables the instance endpoint', example='false'),
  endpointType?: string(name='EndpointType', description='The type of the endpoint. Set the value to Internet.', example='internet'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  moduleName?: string(name='ModuleName', description='The name of the module that you want to access. Valid values:

*   `Registry`: the image repository.
*   `Chart`: a Helm chart.', example='Chart'),
}

model UpdateInstanceEndpointStatusResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2FC14396-A16A-42BA-AAE4-BB94D956DF09'),
}

model UpdateInstanceEndpointStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceEndpointStatusResponseBody(name='body'),
}

async function updateInstanceEndpointStatusWithOptions(request: UpdateInstanceEndpointStatusRequest, runtime: Util.RuntimeOptions): UpdateInstanceEndpointStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstanceEndpointStatus',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateInstanceEndpointStatus(request: UpdateInstanceEndpointStatusRequest): UpdateInstanceEndpointStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInstanceEndpointStatusWithOptions(request, runtime);
}

model UpdateNamespaceRequest {
  autoCreateRepo?: boolean(name='AutoCreateRepo', description='Specifies whether to automatically create a repository when an image is pushed to the namespace.', example='true'),
  defaultRepoType?: string(name='DefaultRepoType', description='The default type of the repository. Valid values:

*   `PUBLIC`: The repository is a public repository.
*   `PRIVATE`: The repository is a private repository.', example='PRIVATE'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test'),
}

model UpdateNamespaceResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='90B8475C-C066-4B92-946E-4D0DECB514E8'),
}

model UpdateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateNamespaceResponseBody(name='body'),
}

async function updateNamespaceWithOptions(request: UpdateNamespaceRequest, runtime: Util.RuntimeOptions): UpdateNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoCreateRepo)) {
    query['AutoCreateRepo'] = request.autoCreateRepo;
  }
  if (!Util.isUnset(request.defaultRepoType)) {
    query['DefaultRepoType'] = request.defaultRepoType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNamespace(request: UpdateNamespaceRequest): UpdateNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNamespaceWithOptions(request, runtime);
}

model UpdateRepoBuildRuleRequest {
  buildArgs?: [ string ](name='BuildArgs', description='Building arguments.'),
  buildRuleId?: string(name='BuildRuleId', description='The ID of the building rule.', example='crbr-ly77w5i3t31f****'),
  dockerfileLocation?: string(name='DockerfileLocation', description='The path of the Dockerfile.', example='/'),
  dockerfileName?: string(name='DockerfileName', description='The name of the Dockerfile.', example='Dockerfile'),
  imageTag?: string(name='ImageTag', description='The tag of the image.', example='v0.9.5'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  platforms?: [ string ](name='Platforms', description='Architecture for image building. Valid values:

*   `linux/amd64`
*   `linux/arm64`
*   `linux/386`
*   `linux/arm/v7`
*   `linux/arm/v6`

Default value: `linux/amd64`', example='linux/amd64'),
  pushName?: string(name='PushName', description='The name of the push that triggers the building rule.', example='master'),
  pushType?: string(name='PushType', description='The type of the push that triggers the building rule. Valid values:

*   `GIT_TAG`: tag push
*   `GIT_BRANCH`: branch push', example='GIT_BRANCH'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-tquyps22md8p****'),
}

model UpdateRepoBuildRuleResponseBody = {
  buildRuleId?: string(name='BuildRuleId', description='The ID of the building rule.', example='crbr-ly77w5i3t31f****'),
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful. Valid values:

*   `true`: The request is successful.
*   `false`: The request fails.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BC648259-91A7-4502-BED3-EDF64361FA83'),
}

model UpdateRepoBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRepoBuildRuleResponseBody(name='body'),
}

async function updateRepoBuildRuleWithOptions(request: UpdateRepoBuildRuleRequest, runtime: Util.RuntimeOptions): UpdateRepoBuildRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildArgs)) {
    query['BuildArgs'] = request.buildArgs;
  }
  if (!Util.isUnset(request.buildRuleId)) {
    query['BuildRuleId'] = request.buildRuleId;
  }
  if (!Util.isUnset(request.dockerfileLocation)) {
    query['DockerfileLocation'] = request.dockerfileLocation;
  }
  if (!Util.isUnset(request.dockerfileName)) {
    query['DockerfileName'] = request.dockerfileName;
  }
  if (!Util.isUnset(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.platforms)) {
    query['Platforms'] = request.platforms;
  }
  if (!Util.isUnset(request.pushName)) {
    query['PushName'] = request.pushName;
  }
  if (!Util.isUnset(request.pushType)) {
    query['PushType'] = request.pushType;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRepoBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRepoBuildRule(request: UpdateRepoBuildRuleRequest): UpdateRepoBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRepoBuildRuleWithOptions(request, runtime);
}

model UpdateRepoSourceCodeRepoRequest {
  autoBuild?: string(name='AutoBuild', description='Specifies whether to enable automatic image building when code is committed. Valid values:

*   `true`: enables automatic image building when code is committed.
*   `false`: disables automatic image building when code is committed.', example='true'),
  codeRepoId?: string(name='CodeRepoId', description='The ID of the source code repository.', example='crr-cp7d6sget5r****'),
  codeRepoName?: string(name='CodeRepoName', description='The name of the source code repository.', example='repo'),
  codeRepoNamespaceName?: string(name='CodeRepoNamespaceName', description='The namespace to which the source code repository belongs.', example='namespace'),
  codeRepoType?: string(name='CodeRepoType', description='The type of the source code hosting platform. Valid values: GITHUB, GITLAB, GITEE, CODE, and CODEUP.', example='GITHUB'),
  disableCacheBuild?: string(name='DisableCacheBuild', description='Specifies whether to disable building caches. Valid values:

*   `true`: disables building caches.
*   `false`: enables building caches.', example='false'),
  instanceId?: string(name='InstanceId', description='The ID of the Container Registry Enterprise Edition instance.', example='cri-shac42yvqzvq****'),
  overseaBuild?: string(name='OverseaBuild', description='Specifies whether to enable Build With Servers Deployed Outside Chinese Mainland. Valid values:

*   `true`: enables Build With Servers Deployed Outside Chinese Mainland.
*   `false`: disables Build With Servers Deployed Outside Chinese Mainland.', example='false'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-gzsrlevmvoa****'),
}

model UpdateRepoSourceCodeRepoResponseBody = {
  code?: string(name='Code', description='The return value.', example='200'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F56D589D-AF7F-4900-BA46-62C780AC2C10'),
}

model UpdateRepoSourceCodeRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRepoSourceCodeRepoResponseBody(name='body'),
}

async function updateRepoSourceCodeRepoWithOptions(request: UpdateRepoSourceCodeRepoRequest, runtime: Util.RuntimeOptions): UpdateRepoSourceCodeRepoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoBuild)) {
    query['AutoBuild'] = request.autoBuild;
  }
  if (!Util.isUnset(request.codeRepoId)) {
    query['CodeRepoId'] = request.codeRepoId;
  }
  if (!Util.isUnset(request.codeRepoName)) {
    query['CodeRepoName'] = request.codeRepoName;
  }
  if (!Util.isUnset(request.codeRepoNamespaceName)) {
    query['CodeRepoNamespaceName'] = request.codeRepoNamespaceName;
  }
  if (!Util.isUnset(request.codeRepoType)) {
    query['CodeRepoType'] = request.codeRepoType;
  }
  if (!Util.isUnset(request.disableCacheBuild)) {
    query['DisableCacheBuild'] = request.disableCacheBuild;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.overseaBuild)) {
    query['OverseaBuild'] = request.overseaBuild;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRepoSourceCodeRepo',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRepoSourceCodeRepo(request: UpdateRepoSourceCodeRepoRequest): UpdateRepoSourceCodeRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRepoSourceCodeRepoWithOptions(request, runtime);
}

model UpdateRepoTriggerRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', description='The ID of the image repository.', example='crr-tquyps22md8p****'),
  triggerId?: string(name='TriggerId', description='The ID of the trigger.', example='crw-k7bdx4kt52ty****'),
  triggerName?: string(name='TriggerName', description='The name of the trigger.

You can specify the TriggerName or TriggerUrl parameter. The TriggerName parameter is optional.', example='test_trigger'),
  triggerTag?: string(name='TriggerTag', description='The image tag based on which the trigger is set.', example='master'),
  triggerType?: string(name='TriggerType', description='The type of the trigger. Valid values:

*   `ALL`: a trigger that supports both tags and regular expressions.
*   `TAG_LISTTAG`: a tag-based trigger.
*   `TAG_REG_EXP`: a regular expression-based trigger.', example='TAG_LIST'),
  triggerUrl?: string(name='TriggerUrl', description='The URL of the trigger.', example='https://www.test.com'),
}

model UpdateRepoTriggerResponseBody = {
  code?: string(name='Code', description='The return value.', example='success'),
  isSuccess?: boolean(name='IsSuccess', description='Indicates whether the request is successful.', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='32535049-ED91-4589-98C0-7C88766EDF1F'),
}

model UpdateRepoTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRepoTriggerResponseBody(name='body'),
}

async function updateRepoTriggerWithOptions(request: UpdateRepoTriggerRequest, runtime: Util.RuntimeOptions): UpdateRepoTriggerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.triggerId)) {
    query['TriggerId'] = request.triggerId;
  }
  if (!Util.isUnset(request.triggerName)) {
    query['TriggerName'] = request.triggerName;
  }
  if (!Util.isUnset(request.triggerTag)) {
    query['TriggerTag'] = request.triggerTag;
  }
  if (!Util.isUnset(request.triggerType)) {
    query['TriggerType'] = request.triggerType;
  }
  if (!Util.isUnset(request.triggerUrl)) {
    query['TriggerUrl'] = request.triggerUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRepoTrigger',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRepoTrigger(request: UpdateRepoTriggerRequest): UpdateRepoTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRepoTriggerWithOptions(request, runtime);
}

model UpdateRepositoryRequest {
  detail?: string(name='Detail', example='repo-for-test'),
  instanceId?: string(name='InstanceId', example='cri-kmsiwlxxdcva****'),
  repoId?: string(name='RepoId', example='crr-tquyps22md8p****'),
  repoName?: string(name='RepoName', example='dsp/domain-microapp'),
  repoNamespaceName?: string(name='RepoNamespaceName', example='ejiayou-other'),
  repoType?: string(name='RepoType', example='PUBLIC'),
  summary?: string(name='Summary', example='test repo'),
  tagImmutability?: boolean(name='TagImmutability', example='true'),
}

model UpdateRepositoryResponseBody = {
  code?: string(name='Code', example='success'),
  isSuccess?: boolean(name='IsSuccess', example='true'),
  requestId?: string(name='RequestId', example='CC43EC6B-0DD4-40AE-8811-B0519617051A'),
}

model UpdateRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRepositoryResponseBody(name='body'),
}

async function updateRepositoryWithOptions(request: UpdateRepositoryRequest, runtime: Util.RuntimeOptions): UpdateRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.detail)) {
    query['Detail'] = request.detail;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.repoType)) {
    query['RepoType'] = request.repoType;
  }
  if (!Util.isUnset(request.summary)) {
    query['Summary'] = request.summary;
  }
  if (!Util.isUnset(request.tagImmutability)) {
    query['TagImmutability'] = request.tagImmutability;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRepository(request: UpdateRepositoryRequest): UpdateRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRepositoryWithOptions(request, runtime);
}

