/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('cr', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CancelArtifactBuildTaskRequest {
  buildTaskId?: string(name='BuildTaskId'),
  instanceId?: string(name='InstanceId'),
}

model CancelArtifactBuildTaskResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model CancelArtifactBuildTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelArtifactBuildTaskResponseBody(name='body'),
}

async function cancelArtifactBuildTaskWithOptions(request: CancelArtifactBuildTaskRequest, runtime: Util.RuntimeOptions): CancelArtifactBuildTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildTaskId)) {
    query['BuildTaskId'] = request.buildTaskId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelArtifactBuildTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelArtifactBuildTask(request: CancelArtifactBuildTaskRequest): CancelArtifactBuildTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelArtifactBuildTaskWithOptions(request, runtime);
}

model CancelRepoBuildRecordRequest {
  buildRecordId?: string(name='BuildRecordId'),
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
}

model CancelRepoBuildRecordResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model CancelRepoBuildRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelRepoBuildRecordResponseBody(name='body'),
}

async function cancelRepoBuildRecordWithOptions(request: CancelRepoBuildRecordRequest, runtime: Util.RuntimeOptions): CancelRepoBuildRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildRecordId)) {
    query['BuildRecordId'] = request.buildRecordId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelRepoBuildRecord',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelRepoBuildRecord(request: CancelRepoBuildRecordRequest): CancelRepoBuildRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelRepoBuildRecordWithOptions(request, runtime);
}

model ChangeResourceGroupRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceId?: string(name='ResourceId'),
  resourceRegionId?: string(name='ResourceRegionId'),
}

model ChangeResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ChangeResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeResourceGroupResponseBody(name='body'),
}

async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: Util.RuntimeOptions): ChangeResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceRegionId)) {
    query['ResourceRegionId'] = request.resourceRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeResourceGroup',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeResourceGroupWithOptions(request, runtime);
}

model CreateBuildRecordByRuleRequest {
  buildRuleId?: string(name='BuildRuleId'),
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
}

model CreateBuildRecordByRuleResponseBody = {
  buildRecordId?: string(name='BuildRecordId'),
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model CreateBuildRecordByRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBuildRecordByRuleResponseBody(name='body'),
}

async function createBuildRecordByRuleWithOptions(request: CreateBuildRecordByRuleRequest, runtime: Util.RuntimeOptions): CreateBuildRecordByRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildRuleId)) {
    query['BuildRuleId'] = request.buildRuleId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBuildRecordByRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBuildRecordByRule(request: CreateBuildRecordByRuleRequest): CreateBuildRecordByRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBuildRecordByRuleWithOptions(request, runtime);
}

model CreateChainRequest {
  chainConfig?: string(name='ChainConfig'),
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  scopeExclude?: [ string ](name='ScopeExclude'),
}

model CreateChainResponseBody = {
  chainId?: string(name='ChainId'),
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model CreateChainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateChainResponseBody(name='body'),
}

async function createChainWithOptions(request: CreateChainRequest, runtime: Util.RuntimeOptions): CreateChainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chainConfig)) {
    query['ChainConfig'] = request.chainConfig;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.scopeExclude)) {
    query['ScopeExclude'] = request.scopeExclude;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateChain',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createChain(request: CreateChainRequest): CreateChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return createChainWithOptions(request, runtime);
}

model CreateChartNamespaceRequest {
  autoCreateRepo?: boolean(name='AutoCreateRepo'),
  defaultRepoType?: string(name='DefaultRepoType'),
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
}

model CreateChartNamespaceResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model CreateChartNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateChartNamespaceResponseBody(name='body'),
}

async function createChartNamespaceWithOptions(request: CreateChartNamespaceRequest, runtime: Util.RuntimeOptions): CreateChartNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoCreateRepo)) {
    query['AutoCreateRepo'] = request.autoCreateRepo;
  }
  if (!Util.isUnset(request.defaultRepoType)) {
    query['DefaultRepoType'] = request.defaultRepoType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateChartNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createChartNamespace(request: CreateChartNamespaceRequest): CreateChartNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createChartNamespaceWithOptions(request, runtime);
}

model CreateChartRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  repoType?: string(name='RepoType'),
  summary?: string(name='Summary'),
}

model CreateChartRepositoryResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  repoId?: string(name='RepoId'),
  requestId?: string(name='RequestId'),
}

model CreateChartRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateChartRepositoryResponseBody(name='body'),
}

async function createChartRepositoryWithOptions(request: CreateChartRepositoryRequest, runtime: Util.RuntimeOptions): CreateChartRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.repoType)) {
    query['RepoType'] = request.repoType;
  }
  if (!Util.isUnset(request.summary)) {
    query['Summary'] = request.summary;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateChartRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createChartRepository(request: CreateChartRepositoryRequest): CreateChartRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createChartRepositoryWithOptions(request, runtime);
}

model CreateInstanceEndpointAclPolicyRequest {
  comment?: string(name='Comment'),
  endpointType?: string(name='EndpointType'),
  entry?: string(name='Entry'),
  instanceId?: string(name='InstanceId'),
  moduleName?: string(name='ModuleName'),
}

model CreateInstanceEndpointAclPolicyResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model CreateInstanceEndpointAclPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInstanceEndpointAclPolicyResponseBody(name='body'),
}

async function createInstanceEndpointAclPolicyWithOptions(request: CreateInstanceEndpointAclPolicyRequest, runtime: Util.RuntimeOptions): CreateInstanceEndpointAclPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!Util.isUnset(request.entry)) {
    query['Entry'] = request.entry;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstanceEndpointAclPolicy',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createInstanceEndpointAclPolicy(request: CreateInstanceEndpointAclPolicyRequest): CreateInstanceEndpointAclPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstanceEndpointAclPolicyWithOptions(request, runtime);
}

model CreateInstanceVpcEndpointLinkedVpcRequest {
  enableCreateDNSRecordInPvzt?: boolean(name='EnableCreateDNSRecordInPvzt'),
  instanceId?: string(name='InstanceId'),
  moduleName?: string(name='ModuleName'),
  vpcId?: string(name='VpcId'),
  vswitchId?: string(name='VswitchId'),
}

model CreateInstanceVpcEndpointLinkedVpcResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model CreateInstanceVpcEndpointLinkedVpcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInstanceVpcEndpointLinkedVpcResponseBody(name='body'),
}

async function createInstanceVpcEndpointLinkedVpcWithOptions(request: CreateInstanceVpcEndpointLinkedVpcRequest, runtime: Util.RuntimeOptions): CreateInstanceVpcEndpointLinkedVpcResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enableCreateDNSRecordInPvzt)) {
    query['EnableCreateDNSRecordInPvzt'] = request.enableCreateDNSRecordInPvzt;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.vswitchId)) {
    query['VswitchId'] = request.vswitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstanceVpcEndpointLinkedVpc',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createInstanceVpcEndpointLinkedVpc(request: CreateInstanceVpcEndpointLinkedVpcRequest): CreateInstanceVpcEndpointLinkedVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstanceVpcEndpointLinkedVpcWithOptions(request, runtime);
}

model CreateNamespaceRequest {
  autoCreateRepo?: boolean(name='AutoCreateRepo'),
  defaultRepoType?: string(name='DefaultRepoType'),
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
}

model CreateNamespaceResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model CreateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNamespaceResponseBody(name='body'),
}

async function createNamespaceWithOptions(request: CreateNamespaceRequest, runtime: Util.RuntimeOptions): CreateNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoCreateRepo)) {
    query['AutoCreateRepo'] = request.autoCreateRepo;
  }
  if (!Util.isUnset(request.defaultRepoType)) {
    query['DefaultRepoType'] = request.defaultRepoType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNamespace(request: CreateNamespaceRequest): CreateNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNamespaceWithOptions(request, runtime);
}

model CreateRepoBuildRuleRequest {
  buildArgs?: [ string ](name='BuildArgs'),
  dockerfileLocation?: string(name='DockerfileLocation'),
  dockerfileName?: string(name='DockerfileName'),
  imageTag?: string(name='ImageTag'),
  instanceId?: string(name='InstanceId'),
  platforms?: [ string ](name='Platforms'),
  pushName?: string(name='PushName'),
  pushType?: string(name='PushType'),
  repoId?: string(name='RepoId'),
}

model CreateRepoBuildRuleResponseBody = {
  buildRuleId?: string(name='BuildRuleId'),
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model CreateRepoBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoBuildRuleResponseBody(name='body'),
}

async function createRepoBuildRuleWithOptions(request: CreateRepoBuildRuleRequest, runtime: Util.RuntimeOptions): CreateRepoBuildRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildArgs)) {
    query['BuildArgs'] = request.buildArgs;
  }
  if (!Util.isUnset(request.dockerfileLocation)) {
    query['DockerfileLocation'] = request.dockerfileLocation;
  }
  if (!Util.isUnset(request.dockerfileName)) {
    query['DockerfileName'] = request.dockerfileName;
  }
  if (!Util.isUnset(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.platforms)) {
    query['Platforms'] = request.platforms;
  }
  if (!Util.isUnset(request.pushName)) {
    query['PushName'] = request.pushName;
  }
  if (!Util.isUnset(request.pushType)) {
    query['PushType'] = request.pushType;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoBuildRule(request: CreateRepoBuildRuleRequest): CreateRepoBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoBuildRuleWithOptions(request, runtime);
}

model CreateRepoSourceCodeRepoRequest {
  autoBuild?: boolean(name='AutoBuild'),
  codeRepoName?: string(name='CodeRepoName'),
  codeRepoNamespaceName?: string(name='CodeRepoNamespaceName'),
  codeRepoType?: string(name='CodeRepoType'),
  disableCacheBuild?: boolean(name='DisableCacheBuild'),
  instanceId?: string(name='InstanceId'),
  overseaBuild?: boolean(name='OverseaBuild'),
  repoId?: string(name='RepoId'),
}

model CreateRepoSourceCodeRepoResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model CreateRepoSourceCodeRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoSourceCodeRepoResponseBody(name='body'),
}

async function createRepoSourceCodeRepoWithOptions(request: CreateRepoSourceCodeRepoRequest, runtime: Util.RuntimeOptions): CreateRepoSourceCodeRepoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoBuild)) {
    query['AutoBuild'] = request.autoBuild;
  }
  if (!Util.isUnset(request.codeRepoName)) {
    query['CodeRepoName'] = request.codeRepoName;
  }
  if (!Util.isUnset(request.codeRepoNamespaceName)) {
    query['CodeRepoNamespaceName'] = request.codeRepoNamespaceName;
  }
  if (!Util.isUnset(request.codeRepoType)) {
    query['CodeRepoType'] = request.codeRepoType;
  }
  if (!Util.isUnset(request.disableCacheBuild)) {
    query['DisableCacheBuild'] = request.disableCacheBuild;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.overseaBuild)) {
    query['OverseaBuild'] = request.overseaBuild;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoSourceCodeRepo',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoSourceCodeRepo(request: CreateRepoSourceCodeRepoRequest): CreateRepoSourceCodeRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoSourceCodeRepoWithOptions(request, runtime);
}

model CreateRepoSyncRuleRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
  repoName?: string(name='RepoName'),
  syncRuleName?: string(name='SyncRuleName'),
  syncScope?: string(name='SyncScope'),
  syncTrigger?: string(name='SyncTrigger'),
  tagFilter?: string(name='TagFilter'),
  targetInstanceId?: string(name='TargetInstanceId'),
  targetNamespaceName?: string(name='TargetNamespaceName'),
  targetRegionId?: string(name='TargetRegionId'),
  targetRepoName?: string(name='TargetRepoName'),
  targetUserId?: string(name='TargetUserId'),
}

model CreateRepoSyncRuleResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  syncRuleId?: string(name='SyncRuleId'),
}

model CreateRepoSyncRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoSyncRuleResponseBody(name='body'),
}

async function createRepoSyncRuleWithOptions(request: CreateRepoSyncRuleRequest, runtime: Util.RuntimeOptions): CreateRepoSyncRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.syncRuleName)) {
    query['SyncRuleName'] = request.syncRuleName;
  }
  if (!Util.isUnset(request.syncScope)) {
    query['SyncScope'] = request.syncScope;
  }
  if (!Util.isUnset(request.syncTrigger)) {
    query['SyncTrigger'] = request.syncTrigger;
  }
  if (!Util.isUnset(request.tagFilter)) {
    query['TagFilter'] = request.tagFilter;
  }
  if (!Util.isUnset(request.targetInstanceId)) {
    query['TargetInstanceId'] = request.targetInstanceId;
  }
  if (!Util.isUnset(request.targetNamespaceName)) {
    query['TargetNamespaceName'] = request.targetNamespaceName;
  }
  if (!Util.isUnset(request.targetRegionId)) {
    query['TargetRegionId'] = request.targetRegionId;
  }
  if (!Util.isUnset(request.targetRepoName)) {
    query['TargetRepoName'] = request.targetRepoName;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoSyncRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoSyncRule(request: CreateRepoSyncRuleRequest): CreateRepoSyncRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoSyncRuleWithOptions(request, runtime);
}

model CreateRepoSyncTaskRequest {
  instanceId?: string(name='InstanceId'),
  override?: boolean(name='Override'),
  repoId?: string(name='RepoId'),
  tag?: string(name='Tag'),
  targetInstanceId?: string(name='TargetInstanceId'),
  targetNamespace?: string(name='TargetNamespace'),
  targetRegionId?: string(name='TargetRegionId'),
  targetRepoName?: string(name='TargetRepoName'),
  targetTag?: string(name='TargetTag'),
  targetUserId?: string(name='TargetUserId'),
}

model CreateRepoSyncTaskResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  syncTaskId?: string(name='SyncTaskId'),
}

model CreateRepoSyncTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoSyncTaskResponseBody(name='body'),
}

async function createRepoSyncTaskWithOptions(request: CreateRepoSyncTaskRequest, runtime: Util.RuntimeOptions): CreateRepoSyncTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.override)) {
    query['Override'] = request.override;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.targetInstanceId)) {
    query['TargetInstanceId'] = request.targetInstanceId;
  }
  if (!Util.isUnset(request.targetNamespace)) {
    query['TargetNamespace'] = request.targetNamespace;
  }
  if (!Util.isUnset(request.targetRegionId)) {
    query['TargetRegionId'] = request.targetRegionId;
  }
  if (!Util.isUnset(request.targetRepoName)) {
    query['TargetRepoName'] = request.targetRepoName;
  }
  if (!Util.isUnset(request.targetTag)) {
    query['TargetTag'] = request.targetTag;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoSyncTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoSyncTask(request: CreateRepoSyncTaskRequest): CreateRepoSyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoSyncTaskWithOptions(request, runtime);
}

model CreateRepoSyncTaskByRuleRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  syncRuleId?: string(name='SyncRuleId'),
  tag?: string(name='Tag'),
}

model CreateRepoSyncTaskByRuleResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  syncTaskId?: string(name='SyncTaskId'),
}

model CreateRepoSyncTaskByRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoSyncTaskByRuleResponseBody(name='body'),
}

async function createRepoSyncTaskByRuleWithOptions(request: CreateRepoSyncTaskByRuleRequest, runtime: Util.RuntimeOptions): CreateRepoSyncTaskByRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.syncRuleId)) {
    query['SyncRuleId'] = request.syncRuleId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoSyncTaskByRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoSyncTaskByRule(request: CreateRepoSyncTaskByRuleRequest): CreateRepoSyncTaskByRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoSyncTaskByRuleWithOptions(request, runtime);
}

model CreateRepoTagRequest {
  fromTag?: string(name='FromTag'),
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
  repoName?: string(name='RepoName'),
  toTag?: string(name='ToTag'),
}

model CreateRepoTagResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model CreateRepoTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoTagResponseBody(name='body'),
}

async function createRepoTagWithOptions(request: CreateRepoTagRequest, runtime: Util.RuntimeOptions): CreateRepoTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fromTag)) {
    query['FromTag'] = request.fromTag;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.toTag)) {
    query['ToTag'] = request.toTag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoTag',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoTag(request: CreateRepoTagRequest): CreateRepoTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoTagWithOptions(request, runtime);
}

model CreateRepoTagScanTaskRequest {
  digest?: string(name='Digest'),
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  scanService?: string(name='ScanService'),
  tag?: string(name='Tag'),
}

model CreateRepoTagScanTaskResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model CreateRepoTagScanTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoTagScanTaskResponseBody(name='body'),
}

async function createRepoTagScanTaskWithOptions(request: CreateRepoTagScanTaskRequest, runtime: Util.RuntimeOptions): CreateRepoTagScanTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.scanService)) {
    query['ScanService'] = request.scanService;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoTagScanTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoTagScanTask(request: CreateRepoTagScanTaskRequest): CreateRepoTagScanTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoTagScanTaskWithOptions(request, runtime);
}

model CreateRepoTriggerRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  triggerName?: string(name='TriggerName'),
  triggerTag?: string(name='TriggerTag'),
  triggerType?: string(name='TriggerType'),
  triggerUrl?: string(name='TriggerUrl'),
}

model CreateRepoTriggerResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  triggerId?: string(name='TriggerId'),
}

model CreateRepoTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoTriggerResponseBody(name='body'),
}

async function createRepoTriggerWithOptions(request: CreateRepoTriggerRequest, runtime: Util.RuntimeOptions): CreateRepoTriggerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.triggerName)) {
    query['TriggerName'] = request.triggerName;
  }
  if (!Util.isUnset(request.triggerTag)) {
    query['TriggerTag'] = request.triggerTag;
  }
  if (!Util.isUnset(request.triggerType)) {
    query['TriggerType'] = request.triggerType;
  }
  if (!Util.isUnset(request.triggerUrl)) {
    query['TriggerUrl'] = request.triggerUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoTrigger',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoTrigger(request: CreateRepoTriggerRequest): CreateRepoTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepoTriggerWithOptions(request, runtime);
}

model CreateRepositoryRequest {
  detail?: string(name='Detail'),
  instanceId?: string(name='InstanceId'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  repoType?: string(name='RepoType'),
  summary?: string(name='Summary'),
  tagImmutability?: boolean(name='TagImmutability'),
}

model CreateRepositoryResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  repoId?: string(name='RepoId'),
  requestId?: string(name='RequestId'),
}

model CreateRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepositoryResponseBody(name='body'),
}

async function createRepositoryWithOptions(request: CreateRepositoryRequest, runtime: Util.RuntimeOptions): CreateRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.detail)) {
    query['Detail'] = request.detail;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.repoType)) {
    query['RepoType'] = request.repoType;
  }
  if (!Util.isUnset(request.summary)) {
    query['Summary'] = request.summary;
  }
  if (!Util.isUnset(request.tagImmutability)) {
    query['TagImmutability'] = request.tagImmutability;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepository(request: CreateRepositoryRequest): CreateRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRepositoryWithOptions(request, runtime);
}

model DeleteChainRequest {
  chainId?: string(name='ChainId'),
  instanceId?: string(name='InstanceId'),
}

model DeleteChainResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteChainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteChainResponseBody(name='body'),
}

async function deleteChainWithOptions(request: DeleteChainRequest, runtime: Util.RuntimeOptions): DeleteChainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chainId)) {
    query['ChainId'] = request.chainId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteChain',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteChain(request: DeleteChainRequest): DeleteChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteChainWithOptions(request, runtime);
}

model DeleteChartNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
}

model DeleteChartNamespaceResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteChartNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteChartNamespaceResponseBody(name='body'),
}

async function deleteChartNamespaceWithOptions(request: DeleteChartNamespaceRequest, runtime: Util.RuntimeOptions): DeleteChartNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteChartNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteChartNamespace(request: DeleteChartNamespaceRequest): DeleteChartNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteChartNamespaceWithOptions(request, runtime);
}

model DeleteChartReleaseRequest {
  chart?: string(name='Chart'),
  instanceId?: string(name='InstanceId'),
  release?: string(name='Release'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
}

model DeleteChartReleaseResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteChartReleaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteChartReleaseResponseBody(name='body'),
}

async function deleteChartReleaseWithOptions(request: DeleteChartReleaseRequest, runtime: Util.RuntimeOptions): DeleteChartReleaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chart)) {
    query['Chart'] = request.chart;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.release)) {
    query['Release'] = request.release;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteChartRelease',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteChartRelease(request: DeleteChartReleaseRequest): DeleteChartReleaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteChartReleaseWithOptions(request, runtime);
}

model DeleteChartRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
}

model DeleteChartRepositoryResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteChartRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteChartRepositoryResponseBody(name='body'),
}

async function deleteChartRepositoryWithOptions(request: DeleteChartRepositoryRequest, runtime: Util.RuntimeOptions): DeleteChartRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteChartRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteChartRepository(request: DeleteChartRepositoryRequest): DeleteChartRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteChartRepositoryWithOptions(request, runtime);
}

model DeleteEventCenterRuleRequest {
  instanceId?: string(name='InstanceId'),
  ruleId?: string(name='RuleId'),
}

model DeleteEventCenterRuleResponseBody = {
  code?: string(name='Code'),
  requestId?: string(name='RequestId'),
}

model DeleteEventCenterRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEventCenterRuleResponseBody(name='body'),
}

async function deleteEventCenterRuleWithOptions(request: DeleteEventCenterRuleRequest, runtime: Util.RuntimeOptions): DeleteEventCenterRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventCenterRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEventCenterRule(request: DeleteEventCenterRuleRequest): DeleteEventCenterRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventCenterRuleWithOptions(request, runtime);
}

model DeleteInstanceEndpointAclPolicyRequest {
  endpointType?: string(name='EndpointType'),
  entry?: string(name='Entry'),
  instanceId?: string(name='InstanceId'),
  moduleName?: string(name='ModuleName'),
}

model DeleteInstanceEndpointAclPolicyResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteInstanceEndpointAclPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstanceEndpointAclPolicyResponseBody(name='body'),
}

async function deleteInstanceEndpointAclPolicyWithOptions(request: DeleteInstanceEndpointAclPolicyRequest, runtime: Util.RuntimeOptions): DeleteInstanceEndpointAclPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!Util.isUnset(request.entry)) {
    query['Entry'] = request.entry;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstanceEndpointAclPolicy',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInstanceEndpointAclPolicy(request: DeleteInstanceEndpointAclPolicyRequest): DeleteInstanceEndpointAclPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstanceEndpointAclPolicyWithOptions(request, runtime);
}

model DeleteInstanceVpcEndpointLinkedVpcRequest {
  instanceId?: string(name='InstanceId'),
  moduleName?: string(name='ModuleName'),
  vpcId?: string(name='VpcId'),
  vswitchId?: string(name='VswitchId'),
}

model DeleteInstanceVpcEndpointLinkedVpcResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteInstanceVpcEndpointLinkedVpcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstanceVpcEndpointLinkedVpcResponseBody(name='body'),
}

async function deleteInstanceVpcEndpointLinkedVpcWithOptions(request: DeleteInstanceVpcEndpointLinkedVpcRequest, runtime: Util.RuntimeOptions): DeleteInstanceVpcEndpointLinkedVpcResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.vswitchId)) {
    query['VswitchId'] = request.vswitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstanceVpcEndpointLinkedVpc',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInstanceVpcEndpointLinkedVpc(request: DeleteInstanceVpcEndpointLinkedVpcRequest): DeleteInstanceVpcEndpointLinkedVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstanceVpcEndpointLinkedVpcWithOptions(request, runtime);
}

model DeleteNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
}

model DeleteNamespaceResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNamespaceResponseBody(name='body'),
}

async function deleteNamespaceWithOptions(request: DeleteNamespaceRequest, runtime: Util.RuntimeOptions): DeleteNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNamespace(request: DeleteNamespaceRequest): DeleteNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNamespaceWithOptions(request, runtime);
}

model DeleteRepoBuildRuleRequest {
  buildRuleId?: string(name='BuildRuleId'),
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
}

model DeleteRepoBuildRuleResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteRepoBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepoBuildRuleResponseBody(name='body'),
}

async function deleteRepoBuildRuleWithOptions(request: DeleteRepoBuildRuleRequest, runtime: Util.RuntimeOptions): DeleteRepoBuildRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildRuleId)) {
    query['BuildRuleId'] = request.buildRuleId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepoBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRepoBuildRule(request: DeleteRepoBuildRuleRequest): DeleteRepoBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRepoBuildRuleWithOptions(request, runtime);
}

model DeleteRepoSyncRuleRequest {
  instanceId?: string(name='InstanceId'),
  syncRuleId?: string(name='SyncRuleId'),
}

model DeleteRepoSyncRuleResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteRepoSyncRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepoSyncRuleResponseBody(name='body'),
}

async function deleteRepoSyncRuleWithOptions(request: DeleteRepoSyncRuleRequest, runtime: Util.RuntimeOptions): DeleteRepoSyncRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.syncRuleId)) {
    query['SyncRuleId'] = request.syncRuleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepoSyncRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRepoSyncRule(request: DeleteRepoSyncRuleRequest): DeleteRepoSyncRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRepoSyncRuleWithOptions(request, runtime);
}

model DeleteRepoTagRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  tag?: string(name='Tag'),
}

model DeleteRepoTagResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteRepoTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepoTagResponseBody(name='body'),
}

async function deleteRepoTagWithOptions(request: DeleteRepoTagRequest, runtime: Util.RuntimeOptions): DeleteRepoTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepoTag',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRepoTag(request: DeleteRepoTagRequest): DeleteRepoTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRepoTagWithOptions(request, runtime);
}

model DeleteRepoTriggerRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  triggerId?: string(name='TriggerId'),
}

model DeleteRepoTriggerResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteRepoTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepoTriggerResponseBody(name='body'),
}

async function deleteRepoTriggerWithOptions(request: DeleteRepoTriggerRequest, runtime: Util.RuntimeOptions): DeleteRepoTriggerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.triggerId)) {
    query['TriggerId'] = request.triggerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepoTrigger',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRepoTrigger(request: DeleteRepoTriggerRequest): DeleteRepoTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRepoTriggerWithOptions(request, runtime);
}

model DeleteRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
}

model DeleteRepositoryResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model DeleteRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRepositoryResponseBody(name='body'),
}

async function deleteRepositoryWithOptions(request: DeleteRepositoryRequest, runtime: Util.RuntimeOptions): DeleteRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRepository(request: DeleteRepositoryRequest): DeleteRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRepositoryWithOptions(request, runtime);
}

model GetArtifactBuildTaskRequest {
  buildTaskId?: string(name='BuildTaskId'),
  instanceId?: string(name='InstanceId'),
}

model GetArtifactBuildTaskResponseBody = {
  artifactBuildType?: string(name='ArtifactBuildType'),
  buildTaskId?: string(name='BuildTaskId'),
  code?: string(name='Code'),
  endTime?: int32(name='EndTime'),
  instructions?: [ string ](name='Instructions'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  sourceArtifact?: {
    artifactType?: string(name='ArtifactType'),
    repoId?: string(name='RepoId'),
    version?: string(name='Version'),
  }(name='SourceArtifact'),
  startTime?: int32(name='StartTime'),
  targetArtifact?: {
    artifactType?: string(name='ArtifactType'),
    repoId?: string(name='RepoId'),
    version?: string(name='Version'),
  }(name='TargetArtifact'),
  taskStatus?: string(name='TaskStatus'),
}

model GetArtifactBuildTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetArtifactBuildTaskResponseBody(name='body'),
}

async function getArtifactBuildTaskWithOptions(request: GetArtifactBuildTaskRequest, runtime: Util.RuntimeOptions): GetArtifactBuildTaskResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetArtifactBuildTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getArtifactBuildTask(request: GetArtifactBuildTaskRequest): GetArtifactBuildTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getArtifactBuildTaskWithOptions(request, runtime);
}

model GetAuthorizationTokenRequest {
  instanceId?: string(name='InstanceId'),
}

model GetAuthorizationTokenResponseBody = {
  authorizationToken?: string(name='AuthorizationToken'),
  code?: string(name='Code'),
  expireTime?: long(name='ExpireTime'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  tempUsername?: string(name='TempUsername'),
}

model GetAuthorizationTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAuthorizationTokenResponseBody(name='body'),
}

async function getAuthorizationTokenWithOptions(request: GetAuthorizationTokenRequest, runtime: Util.RuntimeOptions): GetAuthorizationTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAuthorizationToken',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAuthorizationToken(request: GetAuthorizationTokenRequest): GetAuthorizationTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuthorizationTokenWithOptions(request, runtime);
}

model GetChainRequest {
  chainId?: string(name='ChainId'),
  instanceId?: string(name='InstanceId'),
}

model GetChainResponseBody = {
  chainConfig?: {
    chainConfigId?: string(name='ChainConfigId'),
    isActive?: boolean(name='IsActive'),
    nodes?: [ 
      {
        enable?: boolean(name='Enable'),
        nodeConfig?: {
          denyPolicy?: {
            action?: string(name='Action'),
            baselineList?: string(name='BaselineList'),
            issueCount?: string(name='IssueCount'),
            issueLevel?: string(name='IssueLevel'),
            issueList?: string(name='IssueList'),
            logic?: string(name='Logic'),
            maliciousList?: string(name='MaliciousList'),
          }(name='DenyPolicy'),
          retry?: int32(name='Retry'),
          scanEngine?: string(name='ScanEngine'),
          timeout?: long(name='Timeout'),
        }(name='NodeConfig'),
        nodeName?: string(name='NodeName'),
      }
    ](name='Nodes'),
    routers?: [ 
      {
        from?: {
          nodeName?: string(name='NodeName'),
        }(name='From'),
        to?: {
          nodeName?: string(name='NodeName'),
        }(name='To'),
      }
    ](name='Routers'),
    version?: string(name='Version'),
  }(name='ChainConfig'),
  chainId?: string(name='ChainId'),
  code?: string(name='Code'),
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  isSuccess?: boolean(name='IsSuccess'),
  modifiedTime?: long(name='ModifiedTime'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  scopeExclude?: [ string ](name='ScopeExclude'),
  scopeId?: string(name='ScopeId'),
  scopeType?: string(name='ScopeType'),
}

model GetChainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetChainResponseBody(name='body'),
}

async function getChainWithOptions(request: GetChainRequest, runtime: Util.RuntimeOptions): GetChainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chainId)) {
    query['ChainId'] = request.chainId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetChain',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getChain(request: GetChainRequest): GetChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return getChainWithOptions(request, runtime);
}

model GetChartNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
}

model GetChartNamespaceResponseBody = {
  autoCreateRepo?: boolean(name='AutoCreateRepo'),
  code?: string(name='Code'),
  defaultRepoType?: string(name='DefaultRepoType'),
  instanceId?: string(name='InstanceId'),
  isSuccess?: boolean(name='IsSuccess'),
  namespaceId?: string(name='NamespaceId'),
  namespaceName?: string(name='NamespaceName'),
  namespaceStatus?: string(name='NamespaceStatus'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model GetChartNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetChartNamespaceResponseBody(name='body'),
}

async function getChartNamespaceWithOptions(request: GetChartNamespaceRequest, runtime: Util.RuntimeOptions): GetChartNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetChartNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getChartNamespace(request: GetChartNamespaceRequest): GetChartNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getChartNamespaceWithOptions(request, runtime);
}

model GetChartRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
}

model GetChartRepositoryResponseBody = {
  code?: string(name='Code'),
  createTime?: long(name='CreateTime'),
  instanceId?: string(name='InstanceId'),
  isSuccess?: boolean(name='IsSuccess'),
  modifiedTime?: long(name='ModifiedTime'),
  repoId?: string(name='RepoId'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  repoStatus?: string(name='RepoStatus'),
  repoType?: string(name='RepoType'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  summary?: string(name='Summary'),
}

model GetChartRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetChartRepositoryResponseBody(name='body'),
}

async function getChartRepositoryWithOptions(request: GetChartRepositoryRequest, runtime: Util.RuntimeOptions): GetChartRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetChartRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getChartRepository(request: GetChartRepositoryRequest): GetChartRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getChartRepositoryWithOptions(request, runtime);
}

model GetInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model GetInstanceResponseBody = {
  code?: string(name='Code'),
  createTime?: long(name='CreateTime'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  instanceSpecification?: string(name='InstanceSpecification'),
  instanceStatus?: string(name='InstanceStatus'),
  isSuccess?: boolean(name='IsSuccess'),
  modifiedTime?: long(name='ModifiedTime'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model GetInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInstanceResponseBody(name='body'),
}

async function getInstanceWithOptions(request: GetInstanceRequest, runtime: Util.RuntimeOptions): GetInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstance',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstance(request: GetInstanceRequest): GetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceWithOptions(request, runtime);
}

model GetInstanceCountResponseBody = {
  code?: string(name='Code'),
  count?: int32(name='Count'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model GetInstanceCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInstanceCountResponseBody(name='body'),
}

async function getInstanceCountWithOptions(runtime: Util.RuntimeOptions): GetInstanceCountResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetInstanceCount',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceCount(): GetInstanceCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceCountWithOptions(runtime);
}

model GetInstanceEndpointRequest {
  endpointType?: string(name='EndpointType'),
  instanceId?: string(name='InstanceId'),
  moduleName?: string(name='ModuleName'),
}

model GetInstanceEndpointResponseBody = {
  aclEnable?: boolean(name='AclEnable'),
  aclEntries?: [ 
    {
      comment?: string(name='Comment'),
      entry?: string(name='Entry'),
    }
  ](name='AclEntries'),
  code?: string(name='Code'),
  domains?: [ 
    {
      domain?: string(name='Domain'),
      type?: string(name='Type'),
    }
  ](name='Domains'),
  enable?: boolean(name='Enable'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model GetInstanceEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInstanceEndpointResponseBody(name='body'),
}

async function getInstanceEndpointWithOptions(request: GetInstanceEndpointRequest, runtime: Util.RuntimeOptions): GetInstanceEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceEndpoint',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceEndpoint(request: GetInstanceEndpointRequest): GetInstanceEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceEndpointWithOptions(request, runtime);
}

model GetInstanceUsageRequest {
  instanceId?: string(name='InstanceId'),
}

model GetInstanceUsageResponseBody = {
  chartNamespaceQuota?: string(name='ChartNamespaceQuota'),
  chartNamespaceUsage?: string(name='ChartNamespaceUsage'),
  chartRepoQuota?: string(name='ChartRepoQuota'),
  chartRepoUsage?: string(name='ChartRepoUsage'),
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  namespaceQuota?: string(name='NamespaceQuota'),
  namespaceUsage?: string(name='NamespaceUsage'),
  repoQuota?: string(name='RepoQuota'),
  repoUsage?: string(name='RepoUsage'),
  requestId?: string(name='RequestId'),
}

model GetInstanceUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInstanceUsageResponseBody(name='body'),
}

async function getInstanceUsageWithOptions(request: GetInstanceUsageRequest, runtime: Util.RuntimeOptions): GetInstanceUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceUsage',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceUsage(request: GetInstanceUsageRequest): GetInstanceUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceUsageWithOptions(request, runtime);
}

model GetInstanceVpcEndpointRequest {
  instanceId?: string(name='InstanceId'),
  moduleName?: string(name='ModuleName'),
}

model GetInstanceVpcEndpointResponseBody = {
  code?: string(name='Code'),
  domains?: [ string ](name='Domains'),
  enable?: boolean(name='Enable'),
  isSuccess?: boolean(name='IsSuccess'),
  linkedVpcs?: [ 
    {
      defaultAccess?: boolean(name='DefaultAccess'),
      ip?: string(name='Ip'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      vswitchId?: string(name='VswitchId'),
    }
  ](name='LinkedVpcs'),
  requestId?: string(name='RequestId'),
}

model GetInstanceVpcEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInstanceVpcEndpointResponseBody(name='body'),
}

async function getInstanceVpcEndpointWithOptions(request: GetInstanceVpcEndpointRequest, runtime: Util.RuntimeOptions): GetInstanceVpcEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceVpcEndpoint',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceVpcEndpoint(request: GetInstanceVpcEndpointRequest): GetInstanceVpcEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceVpcEndpointWithOptions(request, runtime);
}

model GetNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceId?: string(name='NamespaceId'),
  namespaceName?: string(name='NamespaceName'),
}

model GetNamespaceResponseBody = {
  autoCreateRepo?: boolean(name='AutoCreateRepo'),
  code?: string(name='Code'),
  defaultRepoType?: string(name='DefaultRepoType'),
  instanceId?: string(name='InstanceId'),
  isSuccess?: boolean(name='IsSuccess'),
  namespaceId?: string(name='NamespaceId'),
  namespaceName?: string(name='NamespaceName'),
  namespaceStatus?: string(name='NamespaceStatus'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model GetNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNamespaceResponseBody(name='body'),
}

async function getNamespaceWithOptions(request: GetNamespaceRequest, runtime: Util.RuntimeOptions): GetNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNamespace(request: GetNamespaceRequest): GetNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNamespaceWithOptions(request, runtime);
}

model GetRepoBuildRecordRequest {
  buildRecordId?: string(name='BuildRecordId'),
  instanceId?: string(name='InstanceId'),
}

model GetRepoBuildRecordResponseBody = {
  buildRecordId?: string(name='BuildRecordId'),
  code?: string(name='Code'),
  endTime?: long(name='EndTime'),
  image?: {
    imageTag?: string(name='ImageTag'),
    repoName?: string(name='RepoName'),
    repoNamespaceName?: string(name='RepoNamespaceName'),
  }(name='Image'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  startTime?: long(name='StartTime'),
  status?: string(name='Status'),
}

model GetRepoBuildRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoBuildRecordResponseBody(name='body'),
}

async function getRepoBuildRecordWithOptions(request: GetRepoBuildRecordRequest, runtime: Util.RuntimeOptions): GetRepoBuildRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildRecordId)) {
    query['BuildRecordId'] = request.buildRecordId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoBuildRecord',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoBuildRecord(request: GetRepoBuildRecordRequest): GetRepoBuildRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoBuildRecordWithOptions(request, runtime);
}

model GetRepoBuildRecordStatusRequest {
  buildRecordId?: string(name='BuildRecordId'),
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
}

model GetRepoBuildRecordStatusResponseBody = {
  buildStatus?: string(name='BuildStatus'),
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model GetRepoBuildRecordStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoBuildRecordStatusResponseBody(name='body'),
}

async function getRepoBuildRecordStatusWithOptions(request: GetRepoBuildRecordStatusRequest, runtime: Util.RuntimeOptions): GetRepoBuildRecordStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildRecordId)) {
    query['BuildRecordId'] = request.buildRecordId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoBuildRecordStatus',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoBuildRecordStatus(request: GetRepoBuildRecordStatusRequest): GetRepoBuildRecordStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoBuildRecordStatusWithOptions(request, runtime);
}

model GetRepoSourceCodeRepoRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
}

model GetRepoSourceCodeRepoResponseBody = {
  autoBuild?: string(name='AutoBuild'),
  code?: string(name='Code'),
  codeRepoDomain?: string(name='CodeRepoDomain'),
  codeRepoName?: string(name='CodeRepoName'),
  codeRepoNamespaceName?: string(name='CodeRepoNamespaceName'),
  codeRepoType?: string(name='CodeRepoType'),
  disableCacheBuild?: string(name='DisableCacheBuild'),
  isSuccess?: boolean(name='IsSuccess'),
  overseaBuild?: string(name='OverseaBuild'),
  repoId?: string(name='RepoId'),
  requestId?: string(name='RequestId'),
}

model GetRepoSourceCodeRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoSourceCodeRepoResponseBody(name='body'),
}

async function getRepoSourceCodeRepoWithOptions(request: GetRepoSourceCodeRepoRequest, runtime: Util.RuntimeOptions): GetRepoSourceCodeRepoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoSourceCodeRepo',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoSourceCodeRepo(request: GetRepoSourceCodeRepoRequest): GetRepoSourceCodeRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoSourceCodeRepoWithOptions(request, runtime);
}

model GetRepoSyncTaskRequest {
  instanceId?: string(name='InstanceId'),
  syncTaskId?: string(name='SyncTaskId'),
}

model GetRepoSyncTaskResponseBody = {
  code?: string(name='Code'),
  crossUser?: boolean(name='CrossUser'),
  imageFrom?: {
    imageTag?: string(name='ImageTag'),
    instanceId?: string(name='InstanceId'),
    regionId?: string(name='RegionId'),
    repoName?: string(name='RepoName'),
    repoNamespaceName?: string(name='RepoNamespaceName'),
  }(name='ImageFrom'),
  imageTo?: {
    imageTag?: string(name='ImageTag'),
    instanceId?: string(name='InstanceId'),
    regionId?: string(name='RegionId'),
    repoName?: string(name='RepoName'),
    repoNamespaceName?: string(name='RepoNamespaceName'),
  }(name='ImageTo'),
  isSuccess?: boolean(name='IsSuccess'),
  layerTasks?: [ 
    {
      artifactDigest?: string(name='ArtifactDigest'),
      digest?: string(name='Digest'),
      size?: long(name='Size'),
      syncLayerTaskId?: string(name='SyncLayerTaskId'),
      syncedSize?: long(name='SyncedSize'),
      taskStatus?: string(name='TaskStatus'),
    }
  ](name='LayerTasks'),
  progress?: long(name='Progress'),
  requestId?: string(name='RequestId'),
  syncBatchTaskId?: string(name='SyncBatchTaskId'),
  syncRuleId?: string(name='SyncRuleId'),
  syncTaskId?: string(name='SyncTaskId'),
  syncTransAccelerate?: boolean(name='SyncTransAccelerate'),
  syncedSize?: long(name='SyncedSize'),
  taskStatus?: string(name='TaskStatus'),
  taskTrigger?: string(name='TaskTrigger'),
}

model GetRepoSyncTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoSyncTaskResponseBody(name='body'),
}

async function getRepoSyncTaskWithOptions(request: GetRepoSyncTaskRequest, runtime: Util.RuntimeOptions): GetRepoSyncTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.syncTaskId)) {
    query['SyncTaskId'] = request.syncTaskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoSyncTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoSyncTask(request: GetRepoSyncTaskRequest): GetRepoSyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoSyncTaskWithOptions(request, runtime);
}

model GetRepoTagRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  tag?: string(name='Tag'),
}

model GetRepoTagResponseBody = {
  code?: string(name='Code'),
  digest?: string(name='Digest'),
  imageCreate?: long(name='ImageCreate'),
  imageId?: string(name='ImageId'),
  imageSize?: long(name='ImageSize'),
  imageUpdate?: long(name='ImageUpdate'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  tag?: string(name='Tag'),
}

model GetRepoTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoTagResponseBody(name='body'),
}

async function getRepoTagWithOptions(request: GetRepoTagRequest, runtime: Util.RuntimeOptions): GetRepoTagResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoTag',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoTag(request: GetRepoTagRequest): GetRepoTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoTagWithOptions(request, runtime);
}

model GetRepoTagLayersRequest {
  digest?: string(name='Digest'),
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  tag?: string(name='Tag'),
}

model GetRepoTagLayersResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  layers?: [ 
    {
      blobDigest?: string(name='BlobDigest'),
      blobSize?: long(name='BlobSize'),
      layerCMD?: string(name='LayerCMD'),
      layerIndex?: int32(name='LayerIndex'),
      layerInstruction?: string(name='LayerInstruction'),
    }
  ](name='Layers'),
  requestId?: string(name='RequestId'),
}

model GetRepoTagLayersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoTagLayersResponseBody(name='body'),
}

async function getRepoTagLayersWithOptions(request: GetRepoTagLayersRequest, runtime: Util.RuntimeOptions): GetRepoTagLayersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoTagLayers',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoTagLayers(request: GetRepoTagLayersRequest): GetRepoTagLayersResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoTagLayersWithOptions(request, runtime);
}

model GetRepoTagManifestRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  schemaVersion?: int32(name='SchemaVersion'),
  tag?: string(name='Tag'),
}

model GetRepoTagManifestResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  manifest?: {
    architecture?: string(name='Architecture'),
    config?: {
      digest?: string(name='Digest'),
      mediaType?: string(name='MediaType'),
      size?: long(name='Size'),
    }(name='Config'),
    fsLayers?: [ 
      {
        blobSum?: string(name='BlobSum'),
      }
    ](name='FsLayers'),
    history?: [ 
      {
        v1Compatibility?: map[string]any(name='V1Compatibility'),
      }
    ](name='History'),
    layers?: [ 
      {
        digest?: string(name='Digest'),
        mediaType?: string(name='MediaType'),
        size?: long(name='Size'),
      }
    ](name='Layers'),
    mediaType?: string(name='MediaType'),
    name?: string(name='Name'),
    schemaVersion?: int32(name='SchemaVersion'),
    signatures?: [ 
      {
        header?: map[string]any(name='Header'),
        protected?: string(name='Protected'),
        signature?: string(name='Signature'),
      }
    ](name='Signatures'),
    tag?: string(name='Tag'),
  }(name='Manifest'),
  requestId?: string(name='RequestId'),
}

model GetRepoTagManifestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoTagManifestResponseBody(name='body'),
}

async function getRepoTagManifestWithOptions(request: GetRepoTagManifestRequest, runtime: Util.RuntimeOptions): GetRepoTagManifestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoTagManifest',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoTagManifest(request: GetRepoTagManifestRequest): GetRepoTagManifestResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoTagManifestWithOptions(request, runtime);
}

model GetRepoTagScanStatusRequest {
  digest?: string(name='Digest'),
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  scanTaskId?: string(name='ScanTaskId'),
  tag?: string(name='Tag'),
}

model GetRepoTagScanStatusResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  scanService?: string(name='ScanService'),
  status?: string(name='Status'),
}

model GetRepoTagScanStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoTagScanStatusResponseBody(name='body'),
}

async function getRepoTagScanStatusWithOptions(request: GetRepoTagScanStatusRequest, runtime: Util.RuntimeOptions): GetRepoTagScanStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.scanTaskId)) {
    query['ScanTaskId'] = request.scanTaskId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoTagScanStatus',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoTagScanStatus(request: GetRepoTagScanStatusRequest): GetRepoTagScanStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoTagScanStatusWithOptions(request, runtime);
}

model GetRepoTagScanSummaryRequest {
  digest?: string(name='Digest'),
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  scanTaskId?: string(name='ScanTaskId'),
  tag?: string(name='Tag'),
}

model GetRepoTagScanSummaryResponseBody = {
  code?: string(name='Code'),
  highSeverity?: int32(name='HighSeverity'),
  isSuccess?: boolean(name='IsSuccess'),
  lowSeverity?: int32(name='LowSeverity'),
  mediumSeverity?: int32(name='MediumSeverity'),
  requestId?: string(name='RequestId'),
  totalSeverity?: int32(name='TotalSeverity'),
  unknownSeverity?: int32(name='UnknownSeverity'),
}

model GetRepoTagScanSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoTagScanSummaryResponseBody(name='body'),
}

async function getRepoTagScanSummaryWithOptions(request: GetRepoTagScanSummaryRequest, runtime: Util.RuntimeOptions): GetRepoTagScanSummaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.scanTaskId)) {
    query['ScanTaskId'] = request.scanTaskId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoTagScanSummary',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoTagScanSummary(request: GetRepoTagScanSummaryRequest): GetRepoTagScanSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepoTagScanSummaryWithOptions(request, runtime);
}

model GetRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
}

model GetRepositoryResponseBody = {
  code?: string(name='Code'),
  createTime?: long(name='CreateTime'),
  detail?: string(name='Detail'),
  instanceId?: string(name='InstanceId'),
  isSuccess?: boolean(name='IsSuccess'),
  modifiedTime?: long(name='ModifiedTime'),
  repoBuildType?: string(name='RepoBuildType'),
  repoId?: string(name='RepoId'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  repoStatus?: string(name='RepoStatus'),
  repoType?: string(name='RepoType'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  summary?: string(name='Summary'),
  tagImmutability?: boolean(name='TagImmutability'),
}

model GetRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepositoryResponseBody(name='body'),
}

async function getRepositoryWithOptions(request: GetRepositoryRequest, runtime: Util.RuntimeOptions): GetRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepository(request: GetRepositoryRequest): GetRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRepositoryWithOptions(request, runtime);
}

model ListArtifactBuildTaskLogRequest {
  buildTaskId?: string(name='BuildTaskId'),
  instanceId?: string(name='InstanceId'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
}

model ListArtifactBuildTaskLogResponseBody = {
  buildTaskLogs?: [ 
    {
      lineNumber?: int32(name='LineNumber'),
      message?: string(name='Message'),
    }
  ](name='BuildTaskLogs'),
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListArtifactBuildTaskLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListArtifactBuildTaskLogResponseBody(name='body'),
}

async function listArtifactBuildTaskLogWithOptions(request: ListArtifactBuildTaskLogRequest, runtime: Util.RuntimeOptions): ListArtifactBuildTaskLogResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListArtifactBuildTaskLog',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listArtifactBuildTaskLog(request: ListArtifactBuildTaskLogRequest): ListArtifactBuildTaskLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return listArtifactBuildTaskLogWithOptions(request, runtime);
}

model ListChainRequest {
  instanceId?: string(name='InstanceId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
}

model ListChainResponseBody = {
  chains?: [ 
    {
      chainId?: string(name='ChainId'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      instanceId?: string(name='InstanceId'),
      modifiedTime?: long(name='ModifiedTime'),
      name?: string(name='Name'),
      scopeExclude?: [ string ](name='ScopeExclude'),
      scopeId?: string(name='ScopeId'),
      scopeType?: string(name='ScopeType'),
    }
  ](name='Chains'),
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListChainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListChainResponseBody(name='body'),
}

async function listChainWithOptions(request: ListChainRequest, runtime: Util.RuntimeOptions): ListChainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListChain',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listChain(request: ListChainRequest): ListChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChainWithOptions(request, runtime);
}

model ListChainInstanceRequest {
  instanceId?: string(name='InstanceId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
}

model ListChainInstanceResponseBody = {
  chainInstances?: [ 
    {
      chain?: {
        chainId?: string(name='ChainId'),
        chainName?: string(name='ChainName'),
        version?: long(name='Version'),
      }(name='Chain'),
      chainInstanceId?: string(name='ChainInstanceId'),
      endTime?: long(name='EndTime'),
      repoName?: string(name='RepoName'),
      repoNamespaceName?: string(name='RepoNamespaceName'),
      result?: string(name='Result'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
    }
  ](name='ChainInstances'),
  code?: string(name='Code'),
  instanceId?: string(name='InstanceId'),
  isSuccess?: boolean(name='IsSuccess'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListChainInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListChainInstanceResponseBody(name='body'),
}

async function listChainInstanceWithOptions(request: ListChainInstanceRequest, runtime: Util.RuntimeOptions): ListChainInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListChainInstance',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listChainInstance(request: ListChainInstanceRequest): ListChainInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChainInstanceWithOptions(request, runtime);
}

model ListChartNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
  namespaceStatus?: string(name='NamespaceStatus'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
}

model ListChartNamespaceResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  namespaces?: [ 
    {
      autoCreateRepo?: boolean(name='AutoCreateRepo'),
      defaultRepoType?: string(name='DefaultRepoType'),
      instanceId?: string(name='InstanceId'),
      namespaceId?: string(name='NamespaceId'),
      namespaceName?: string(name='NamespaceName'),
      namespaceStatus?: string(name='NamespaceStatus'),
      resourceGroupId?: string(name='ResourceGroupId'),
    }
  ](name='Namespaces'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListChartNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListChartNamespaceResponseBody(name='body'),
}

async function listChartNamespaceWithOptions(request: ListChartNamespaceRequest, runtime: Util.RuntimeOptions): ListChartNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!Util.isUnset(request.namespaceStatus)) {
    query['NamespaceStatus'] = request.namespaceStatus;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListChartNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listChartNamespace(request: ListChartNamespaceRequest): ListChartNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChartNamespaceWithOptions(request, runtime);
}

model ListChartReleaseRequest {
  chart?: string(name='Chart'),
  instanceId?: string(name='InstanceId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
}

model ListChartReleaseResponseBody = {
  chartReleases?: [ 
    {
      chart?: string(name='Chart'),
      instanceId?: string(name='InstanceId'),
      modifiedTime?: long(name='ModifiedTime'),
      release?: string(name='Release'),
      repoId?: string(name='RepoId'),
      size?: string(name='Size'),
      status?: string(name='Status'),
    }
  ](name='ChartReleases'),
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListChartReleaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListChartReleaseResponseBody(name='body'),
}

async function listChartReleaseWithOptions(request: ListChartReleaseRequest, runtime: Util.RuntimeOptions): ListChartReleaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chart)) {
    query['Chart'] = request.chart;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListChartRelease',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listChartRelease(request: ListChartReleaseRequest): ListChartReleaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChartReleaseWithOptions(request, runtime);
}

model ListChartRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  repoStatus?: string(name='RepoStatus'),
}

model ListChartRepositoryResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  repositories?: [ 
    {
      createTime?: long(name='CreateTime'),
      instanceId?: string(name='InstanceId'),
      modifiedTime?: long(name='ModifiedTime'),
      repoId?: string(name='RepoId'),
      repoName?: string(name='RepoName'),
      repoNamespaceName?: string(name='RepoNamespaceName'),
      repoStatus?: string(name='RepoStatus'),
      repoType?: string(name='RepoType'),
      resourceGroupId?: string(name='ResourceGroupId'),
      summary?: string(name='Summary'),
    }
  ](name='Repositories'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListChartRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListChartRepositoryResponseBody(name='body'),
}

async function listChartRepositoryWithOptions(request: ListChartRepositoryRequest, runtime: Util.RuntimeOptions): ListChartRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.repoStatus)) {
    query['RepoStatus'] = request.repoStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListChartRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listChartRepository(request: ListChartRepositoryRequest): ListChartRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listChartRepositoryWithOptions(request, runtime);
}

model ListEventCenterRecordRequest {
  eventType?: string(name='EventType'),
  instanceId?: string(name='InstanceId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  ruleId?: string(name='RuleId'),
}

model ListEventCenterRecordResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  records?: [ 
    {
      createTime?: long(name='CreateTime'),
      eventChannel?: string(name='EventChannel'),
      eventNotifyId?: string(name='EventNotifyId'),
      eventNotifyMethod?: string(name='EventNotifyMethod'),
      eventType?: string(name='EventType'),
      instanceId?: string(name='InstanceId'),
      namespace?: string(name='Namespace'),
      recordId?: string(name='RecordId'),
      repoName?: string(name='RepoName'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      tag?: string(name='Tag'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='Records'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListEventCenterRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventCenterRecordResponseBody(name='body'),
}

async function listEventCenterRecordWithOptions(request: ListEventCenterRecordRequest, runtime: Util.RuntimeOptions): ListEventCenterRecordResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEventCenterRecord',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEventCenterRecord(request: ListEventCenterRecordRequest): ListEventCenterRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventCenterRecordWithOptions(request, runtime);
}

model ListEventCenterRuleNameRequest {
  instanceId?: string(name='InstanceId'),
}

model ListEventCenterRuleNameResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  ruleNames?: [ 
    {
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
    }
  ](name='RuleNames'),
}

model ListEventCenterRuleNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventCenterRuleNameResponseBody(name='body'),
}

async function listEventCenterRuleNameWithOptions(request: ListEventCenterRuleNameRequest, runtime: Util.RuntimeOptions): ListEventCenterRuleNameResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEventCenterRuleName',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEventCenterRuleName(request: ListEventCenterRuleNameRequest): ListEventCenterRuleNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventCenterRuleNameWithOptions(request, runtime);
}

model ListInstanceRequest {
  instanceName?: string(name='InstanceName'),
  instanceStatus?: string(name='InstanceStatus'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListInstanceResponseBody = {
  code?: string(name='Code'),
  instances?: [ 
    {
      createTime?: string(name='CreateTime'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      instanceSpecification?: string(name='InstanceSpecification'),
      instanceStatus?: string(name='InstanceStatus'),
      modifiedTime?: string(name='ModifiedTime'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
    }
  ](name='Instances'),
  isSuccess?: boolean(name='IsSuccess'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceResponseBody(name='body'),
}

async function listInstanceWithOptions(request: ListInstanceRequest, runtime: Util.RuntimeOptions): ListInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceStatus)) {
    query['InstanceStatus'] = request.instanceStatus;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstance',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstance(request: ListInstanceRequest): ListInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceWithOptions(request, runtime);
}

model ListInstanceEndpointRequest {
  instanceId?: string(name='InstanceId'),
  moduleName?: string(name='ModuleName'),
}

model ListInstanceEndpointResponseBody = {
  code?: string(name='Code'),
  endpoints?: [ 
    {
      aclEnable?: boolean(name='AclEnable'),
      aclEntries?: [ 
        {
          entry?: string(name='Entry'),
        }
      ](name='AclEntries'),
      domains?: [ 
        {
          domain?: string(name='Domain'),
          type?: string(name='Type'),
        }
      ](name='Domains'),
      enable?: boolean(name='Enable'),
      endpointType?: string(name='EndpointType'),
      linkedVpcs?: [ 
        {
          vpcId?: string(name='VpcId'),
        }
      ](name='LinkedVpcs'),
      status?: string(name='Status'),
    }
  ](name='Endpoints'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model ListInstanceEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceEndpointResponseBody(name='body'),
}

async function listInstanceEndpointWithOptions(request: ListInstanceEndpointRequest, runtime: Util.RuntimeOptions): ListInstanceEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceEndpoint',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceEndpoint(request: ListInstanceEndpointRequest): ListInstanceEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceEndpointWithOptions(request, runtime);
}

model ListInstanceRegionRequest {
  lang?: string(name='Lang'),
}

model ListInstanceRegionResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model ListInstanceRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceRegionResponseBody(name='body'),
}

async function listInstanceRegionWithOptions(request: ListInstanceRegionRequest, runtime: Util.RuntimeOptions): ListInstanceRegionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceRegion',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceRegion(request: ListInstanceRegionRequest): ListInstanceRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceRegionWithOptions(request, runtime);
}

model ListNamespaceRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
  namespaceStatus?: string(name='NamespaceStatus'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
}

model ListNamespaceResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  namespaces?: [ 
    {
      autoCreateRepo?: boolean(name='AutoCreateRepo'),
      defaultRepoType?: string(name='DefaultRepoType'),
      instanceId?: string(name='InstanceId'),
      namespaceId?: string(name='NamespaceId'),
      namespaceName?: string(name='NamespaceName'),
      namespaceStatus?: string(name='NamespaceStatus'),
      resourceGroupId?: string(name='ResourceGroupId'),
    }
  ](name='Namespaces'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNamespaceResponseBody(name='body'),
}

async function listNamespaceWithOptions(request: ListNamespaceRequest, runtime: Util.RuntimeOptions): ListNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!Util.isUnset(request.namespaceStatus)) {
    query['NamespaceStatus'] = request.namespaceStatus;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNamespace(request: ListNamespaceRequest): ListNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNamespaceWithOptions(request, runtime);
}

model ListRepoBuildRecordRequest {
  instanceId?: string(name='InstanceId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  repoId?: string(name='RepoId'),
}

model ListRepoBuildRecordResponseBody = {
  buildRecords?: [ 
    {
      buildRecordId?: string(name='BuildRecordId'),
      buildStatus?: string(name='BuildStatus'),
      endTime?: string(name='EndTime'),
      image?: {
        imageTag?: string(name='ImageTag'),
        repoId?: string(name='RepoId'),
        repoName?: string(name='RepoName'),
        repoNamespaceName?: string(name='RepoNamespaceName'),
      }(name='Image'),
      startTime?: string(name='StartTime'),
    }
  ](name='BuildRecords'),
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListRepoBuildRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoBuildRecordResponseBody(name='body'),
}

async function listRepoBuildRecordWithOptions(request: ListRepoBuildRecordRequest, runtime: Util.RuntimeOptions): ListRepoBuildRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoBuildRecord',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoBuildRecord(request: ListRepoBuildRecordRequest): ListRepoBuildRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoBuildRecordWithOptions(request, runtime);
}

model ListRepoBuildRecordLogRequest {
  buildRecordId?: string(name='BuildRecordId'),
  instanceId?: string(name='InstanceId'),
  offset?: int32(name='Offset'),
  repoId?: string(name='RepoId'),
}

model ListRepoBuildRecordLogResponseBody = {
  buildRecordLogs?: [ 
    {
      buildStage?: string(name='BuildStage'),
      lineNumber?: int32(name='LineNumber'),
      message?: string(name='Message'),
    }
  ](name='BuildRecordLogs'),
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListRepoBuildRecordLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoBuildRecordLogResponseBody(name='body'),
}

async function listRepoBuildRecordLogWithOptions(request: ListRepoBuildRecordLogRequest, runtime: Util.RuntimeOptions): ListRepoBuildRecordLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildRecordId)) {
    query['BuildRecordId'] = request.buildRecordId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.offset)) {
    query['Offset'] = request.offset;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoBuildRecordLog',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoBuildRecordLog(request: ListRepoBuildRecordLogRequest): ListRepoBuildRecordLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoBuildRecordLogWithOptions(request, runtime);
}

model ListRepoBuildRuleRequest {
  instanceId?: string(name='InstanceId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  repoId?: string(name='RepoId'),
}

model ListRepoBuildRuleResponseBody = {
  buildRules?: [ 
    {
      buildArgs?: [ string ](name='BuildArgs'),
      buildRuleId?: string(name='BuildRuleId'),
      dockerfileLocation?: string(name='DockerfileLocation'),
      dockerfileName?: string(name='DockerfileName'),
      imageTag?: string(name='ImageTag'),
      platforms?: [ string ](name='Platforms'),
      pushName?: string(name='PushName'),
      pushType?: string(name='PushType'),
    }
  ](name='BuildRules'),
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListRepoBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoBuildRuleResponseBody(name='body'),
}

async function listRepoBuildRuleWithOptions(request: ListRepoBuildRuleRequest, runtime: Util.RuntimeOptions): ListRepoBuildRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoBuildRule(request: ListRepoBuildRuleRequest): ListRepoBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoBuildRuleWithOptions(request, runtime);
}

model ListRepoSyncRuleRequest {
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  repoName?: string(name='RepoName'),
  targetInstanceId?: string(name='TargetInstanceId'),
  targetRegionId?: string(name='TargetRegionId'),
}

model ListRepoSyncRuleResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  syncRules?: [ 
    {
      createTime?: long(name='CreateTime'),
      crossUser?: boolean(name='CrossUser'),
      localInstanceId?: string(name='LocalInstanceId'),
      localNamespaceName?: string(name='LocalNamespaceName'),
      localRegionId?: string(name='LocalRegionId'),
      localRepoName?: string(name='LocalRepoName'),
      modifiedTime?: long(name='ModifiedTime'),
      syncDirection?: string(name='SyncDirection'),
      syncRuleId?: string(name='SyncRuleId'),
      syncRuleName?: string(name='SyncRuleName'),
      syncScope?: string(name='SyncScope'),
      syncTrigger?: string(name='SyncTrigger'),
      tagFilter?: string(name='TagFilter'),
      targetInstanceId?: string(name='TargetInstanceId'),
      targetNamespaceName?: string(name='TargetNamespaceName'),
      targetRegionId?: string(name='TargetRegionId'),
      targetRepoName?: string(name='TargetRepoName'),
    }
  ](name='SyncRules'),
  totalCount?: int32(name='TotalCount'),
}

model ListRepoSyncRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoSyncRuleResponseBody(name='body'),
}

async function listRepoSyncRuleWithOptions(request: ListRepoSyncRuleRequest, runtime: Util.RuntimeOptions): ListRepoSyncRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.targetInstanceId)) {
    query['TargetInstanceId'] = request.targetInstanceId;
  }
  if (!Util.isUnset(request.targetRegionId)) {
    query['TargetRegionId'] = request.targetRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoSyncRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoSyncRule(request: ListRepoSyncRuleRequest): ListRepoSyncRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoSyncRuleWithOptions(request, runtime);
}

model ListRepoSyncTaskRequest {
  instanceId?: string(name='InstanceId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  syncRecordId?: string(name='SyncRecordId'),
  tag?: string(name='Tag'),
}

model ListRepoSyncTaskResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  syncTasks?: [ 
    {
      createTime?: long(name='CreateTime'),
      crossUser?: boolean(name='CrossUser'),
      customLink?: boolean(name='CustomLink'),
      imageFrom?: {
        imageTag?: string(name='ImageTag'),
        instanceId?: string(name='InstanceId'),
        regionId?: string(name='RegionId'),
        repoName?: string(name='RepoName'),
        repoNamespaceName?: string(name='RepoNamespaceName'),
      }(name='ImageFrom'),
      imageTo?: {
        imageTag?: string(name='ImageTag'),
        instanceId?: string(name='InstanceId'),
        regionId?: string(name='RegionId'),
        repoName?: string(name='RepoName'),
        repoNamespaceName?: string(name='RepoNamespaceName'),
      }(name='ImageTo'),
      modifedTime?: long(name='ModifedTime'),
      syncBatchTaskId?: string(name='SyncBatchTaskId'),
      syncRuleId?: string(name='SyncRuleId'),
      syncTaskId?: string(name='SyncTaskId'),
      syncTransAccelerate?: boolean(name='SyncTransAccelerate'),
      taskStatus?: string(name='TaskStatus'),
      taskTrigger?: string(name='TaskTrigger'),
    }
  ](name='SyncTasks'),
  totalCount?: string(name='TotalCount'),
}

model ListRepoSyncTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoSyncTaskResponseBody(name='body'),
}

async function listRepoSyncTaskWithOptions(request: ListRepoSyncTaskRequest, runtime: Util.RuntimeOptions): ListRepoSyncTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.syncRecordId)) {
    query['SyncRecordId'] = request.syncRecordId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoSyncTask',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoSyncTask(request: ListRepoSyncTaskRequest): ListRepoSyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoSyncTaskWithOptions(request, runtime);
}

model ListRepoTagRequest {
  instanceId?: string(name='InstanceId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  repoId?: string(name='RepoId'),
}

model ListRepoTagResponseBody = {
  code?: string(name='Code'),
  images?: [ 
    {
      digest?: string(name='Digest'),
      imageCreate?: string(name='ImageCreate'),
      imageId?: string(name='ImageId'),
      imageSize?: long(name='ImageSize'),
      imageUpdate?: string(name='ImageUpdate'),
      status?: string(name='Status'),
      tag?: string(name='Tag'),
    }
  ](name='Images'),
  isSuccess?: boolean(name='IsSuccess'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListRepoTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoTagResponseBody(name='body'),
}

async function listRepoTagWithOptions(request: ListRepoTagRequest, runtime: Util.RuntimeOptions): ListRepoTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoTag',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoTag(request: ListRepoTagRequest): ListRepoTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoTagWithOptions(request, runtime);
}

model ListRepoTagScanResultRequest {
  digest?: string(name='Digest'),
  filterValue?: string(name='FilterValue'),
  instanceId?: string(name='InstanceId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  repoId?: string(name='RepoId'),
  scanTaskId?: string(name='ScanTaskId'),
  scanType?: string(name='ScanType'),
  severity?: string(name='Severity'),
  tag?: string(name='Tag'),
  vulQueryKey?: string(name='VulQueryKey'),
}

model ListRepoTagScanResultResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vulnerabilities?: [ 
    {
      addedBy?: string(name='AddedBy'),
      aliasName?: string(name='AliasName'),
      cveLink?: string(name='CveLink'),
      cveLocation?: string(name='CveLocation'),
      cveName?: string(name='CveName'),
      description?: string(name='Description'),
      feature?: string(name='Feature'),
      fixCmd?: string(name='FixCmd'),
      scanType?: string(name='ScanType'),
      severity?: string(name='Severity'),
      version?: string(name='Version'),
      versionFixed?: string(name='VersionFixed'),
      versionFormat?: string(name='VersionFormat'),
    }
  ](name='Vulnerabilities'),
}

model ListRepoTagScanResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoTagScanResultResponseBody(name='body'),
}

async function listRepoTagScanResultWithOptions(request: ListRepoTagScanResultRequest, runtime: Util.RuntimeOptions): ListRepoTagScanResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.filterValue)) {
    query['FilterValue'] = request.filterValue;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.scanTaskId)) {
    query['ScanTaskId'] = request.scanTaskId;
  }
  if (!Util.isUnset(request.scanType)) {
    query['ScanType'] = request.scanType;
  }
  if (!Util.isUnset(request.severity)) {
    query['Severity'] = request.severity;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vulQueryKey)) {
    query['VulQueryKey'] = request.vulQueryKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoTagScanResult',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoTagScanResult(request: ListRepoTagScanResultRequest): ListRepoTagScanResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoTagScanResultWithOptions(request, runtime);
}

model ListRepoTriggerRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
}

model ListRepoTriggerResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
  triggers?: [ 
    {
      repoEvent?: string(name='RepoEvent'),
      triggerId?: string(name='TriggerId'),
      triggerName?: string(name='TriggerName'),
      triggerTag?: string(name='TriggerTag'),
      triggerType?: string(name='TriggerType'),
      triggerUrl?: string(name='TriggerUrl'),
    }
  ](name='Triggers'),
}

model ListRepoTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoTriggerResponseBody(name='body'),
}

async function listRepoTriggerWithOptions(request: ListRepoTriggerRequest, runtime: Util.RuntimeOptions): ListRepoTriggerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoTrigger',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoTrigger(request: ListRepoTriggerRequest): ListRepoTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepoTriggerWithOptions(request, runtime);
}

model ListRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  repoStatus?: string(name='RepoStatus'),
}

model ListRepositoryResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  repositories?: [ 
    {
      createTime?: long(name='CreateTime'),
      instanceId?: string(name='InstanceId'),
      modifiedTime?: long(name='ModifiedTime'),
      repoBuildType?: string(name='RepoBuildType'),
      repoId?: string(name='RepoId'),
      repoName?: string(name='RepoName'),
      repoNamespaceName?: string(name='RepoNamespaceName'),
      repoStatus?: string(name='RepoStatus'),
      repoType?: string(name='RepoType'),
      resourceGroupId?: string(name='ResourceGroupId'),
      summary?: string(name='Summary'),
      tagImmutability?: boolean(name='TagImmutability'),
    }
  ](name='Repositories'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepositoryResponseBody(name='body'),
}

async function listRepositoryWithOptions(request: ListRepositoryRequest, runtime: Util.RuntimeOptions): ListRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.repoStatus)) {
    query['RepoStatus'] = request.repoStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepository(request: ListRepositoryRequest): ListRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRepositoryWithOptions(request, runtime);
}

model ResetLoginPasswordRequest {
  instanceId?: string(name='InstanceId'),
  password?: string(name='Password'),
}

model ResetLoginPasswordResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model ResetLoginPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetLoginPasswordResponseBody(name='body'),
}

async function resetLoginPasswordWithOptions(request: ResetLoginPasswordRequest, runtime: Util.RuntimeOptions): ResetLoginPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetLoginPassword',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetLoginPassword(request: ResetLoginPasswordRequest): ResetLoginPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetLoginPasswordWithOptions(request, runtime);
}

model UpdateChainRequest {
  chainConfig?: string(name='ChainConfig'),
  chainId?: string(name='ChainId'),
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
  scopeExclude?: [ string ](name='ScopeExclude'),
}

model UpdateChainResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateChainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateChainResponseBody(name='body'),
}

async function updateChainWithOptions(request: UpdateChainRequest, runtime: Util.RuntimeOptions): UpdateChainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chainConfig)) {
    query['ChainConfig'] = request.chainConfig;
  }
  if (!Util.isUnset(request.chainId)) {
    query['ChainId'] = request.chainId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.scopeExclude)) {
    query['ScopeExclude'] = request.scopeExclude;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateChain',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateChain(request: UpdateChainRequest): UpdateChainResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateChainWithOptions(request, runtime);
}

model UpdateChartNamespaceRequest {
  autoCreateRepo?: boolean(name='AutoCreateRepo'),
  defaultRepoType?: string(name='DefaultRepoType'),
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
}

model UpdateChartNamespaceResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateChartNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateChartNamespaceResponseBody(name='body'),
}

async function updateChartNamespaceWithOptions(request: UpdateChartNamespaceRequest, runtime: Util.RuntimeOptions): UpdateChartNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoCreateRepo)) {
    query['AutoCreateRepo'] = request.autoCreateRepo;
  }
  if (!Util.isUnset(request.defaultRepoType)) {
    query['DefaultRepoType'] = request.defaultRepoType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateChartNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateChartNamespace(request: UpdateChartNamespaceRequest): UpdateChartNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateChartNamespaceWithOptions(request, runtime);
}

model UpdateChartRepositoryRequest {
  instanceId?: string(name='InstanceId'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  repoType?: string(name='RepoType'),
  summary?: string(name='Summary'),
}

model UpdateChartRepositoryResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateChartRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateChartRepositoryResponseBody(name='body'),
}

async function updateChartRepositoryWithOptions(request: UpdateChartRepositoryRequest, runtime: Util.RuntimeOptions): UpdateChartRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.repoType)) {
    query['RepoType'] = request.repoType;
  }
  if (!Util.isUnset(request.summary)) {
    query['Summary'] = request.summary;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateChartRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateChartRepository(request: UpdateChartRepositoryRequest): UpdateChartRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateChartRepositoryWithOptions(request, runtime);
}

model UpdateEventCenterRuleRequest {
  eventChannel?: string(name='EventChannel'),
  eventConfig?: string(name='EventConfig'),
  eventScope?: string(name='EventScope'),
  eventType?: string(name='EventType'),
  instanceId?: string(name='InstanceId'),
  namespaces?: [ string ](name='Namespaces'),
  repoNames?: [ string ](name='RepoNames'),
  repoTagFilterPattern?: string(name='RepoTagFilterPattern'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
}

model UpdateEventCenterRuleShrinkRequest {
  eventChannel?: string(name='EventChannel'),
  eventConfig?: string(name='EventConfig'),
  eventScope?: string(name='EventScope'),
  eventType?: string(name='EventType'),
  instanceId?: string(name='InstanceId'),
  namespacesShrink?: string(name='Namespaces'),
  repoNamesShrink?: string(name='RepoNames'),
  repoTagFilterPattern?: string(name='RepoTagFilterPattern'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
}

model UpdateEventCenterRuleResponseBody = {
  code?: int32(name='Code'),
  requestId?: string(name='RequestId'),
  ruleId?: string(name='RuleId'),
}

model UpdateEventCenterRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEventCenterRuleResponseBody(name='body'),
}

async function updateEventCenterRuleWithOptions(tmpReq: UpdateEventCenterRuleRequest, runtime: Util.RuntimeOptions): UpdateEventCenterRuleResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateEventCenterRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.namespaces)) {
    request.namespacesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.namespaces, 'Namespaces', 'json');
  }
  if (!Util.isUnset(tmpReq.repoNames)) {
    request.repoNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.repoNames, 'RepoNames', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.eventChannel)) {
    query['EventChannel'] = request.eventChannel;
  }
  if (!Util.isUnset(request.eventConfig)) {
    query['EventConfig'] = request.eventConfig;
  }
  if (!Util.isUnset(request.eventScope)) {
    query['EventScope'] = request.eventScope;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespacesShrink)) {
    query['Namespaces'] = request.namespacesShrink;
  }
  if (!Util.isUnset(request.repoNamesShrink)) {
    query['RepoNames'] = request.repoNamesShrink;
  }
  if (!Util.isUnset(request.repoTagFilterPattern)) {
    query['RepoTagFilterPattern'] = request.repoTagFilterPattern;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEventCenterRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateEventCenterRule(request: UpdateEventCenterRuleRequest): UpdateEventCenterRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEventCenterRuleWithOptions(request, runtime);
}

model UpdateInstanceEndpointStatusRequest {
  enable?: boolean(name='Enable'),
  endpointType?: string(name='EndpointType'),
  instanceId?: string(name='InstanceId'),
  moduleName?: string(name='ModuleName'),
}

model UpdateInstanceEndpointStatusResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateInstanceEndpointStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceEndpointStatusResponseBody(name='body'),
}

async function updateInstanceEndpointStatusWithOptions(request: UpdateInstanceEndpointStatusRequest, runtime: Util.RuntimeOptions): UpdateInstanceEndpointStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.endpointType)) {
    query['EndpointType'] = request.endpointType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstanceEndpointStatus',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateInstanceEndpointStatus(request: UpdateInstanceEndpointStatusRequest): UpdateInstanceEndpointStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInstanceEndpointStatusWithOptions(request, runtime);
}

model UpdateNamespaceRequest {
  autoCreateRepo?: boolean(name='AutoCreateRepo'),
  defaultRepoType?: string(name='DefaultRepoType'),
  instanceId?: string(name='InstanceId'),
  namespaceName?: string(name='NamespaceName'),
}

model UpdateNamespaceResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateNamespaceResponseBody(name='body'),
}

async function updateNamespaceWithOptions(request: UpdateNamespaceRequest, runtime: Util.RuntimeOptions): UpdateNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoCreateRepo)) {
    query['AutoCreateRepo'] = request.autoCreateRepo;
  }
  if (!Util.isUnset(request.defaultRepoType)) {
    query['DefaultRepoType'] = request.defaultRepoType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNamespace',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateNamespace(request: UpdateNamespaceRequest): UpdateNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNamespaceWithOptions(request, runtime);
}

model UpdateRepoBuildRuleRequest {
  buildArgs?: [ string ](name='BuildArgs'),
  buildRuleId?: string(name='BuildRuleId'),
  dockerfileLocation?: string(name='DockerfileLocation'),
  dockerfileName?: string(name='DockerfileName'),
  imageTag?: string(name='ImageTag'),
  instanceId?: string(name='InstanceId'),
  platforms?: [ string ](name='Platforms'),
  pushName?: string(name='PushName'),
  pushType?: string(name='PushType'),
  repoId?: string(name='RepoId'),
}

model UpdateRepoBuildRuleResponseBody = {
  buildRuleId?: string(name='BuildRuleId'),
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateRepoBuildRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRepoBuildRuleResponseBody(name='body'),
}

async function updateRepoBuildRuleWithOptions(request: UpdateRepoBuildRuleRequest, runtime: Util.RuntimeOptions): UpdateRepoBuildRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buildArgs)) {
    query['BuildArgs'] = request.buildArgs;
  }
  if (!Util.isUnset(request.buildRuleId)) {
    query['BuildRuleId'] = request.buildRuleId;
  }
  if (!Util.isUnset(request.dockerfileLocation)) {
    query['DockerfileLocation'] = request.dockerfileLocation;
  }
  if (!Util.isUnset(request.dockerfileName)) {
    query['DockerfileName'] = request.dockerfileName;
  }
  if (!Util.isUnset(request.imageTag)) {
    query['ImageTag'] = request.imageTag;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.platforms)) {
    query['Platforms'] = request.platforms;
  }
  if (!Util.isUnset(request.pushName)) {
    query['PushName'] = request.pushName;
  }
  if (!Util.isUnset(request.pushType)) {
    query['PushType'] = request.pushType;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRepoBuildRule',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRepoBuildRule(request: UpdateRepoBuildRuleRequest): UpdateRepoBuildRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRepoBuildRuleWithOptions(request, runtime);
}

model UpdateRepoSourceCodeRepoRequest {
  autoBuild?: string(name='AutoBuild'),
  codeRepoId?: string(name='CodeRepoId'),
  codeRepoName?: string(name='CodeRepoName'),
  codeRepoNamespaceName?: string(name='CodeRepoNamespaceName'),
  codeRepoType?: string(name='CodeRepoType'),
  disableCacheBuild?: string(name='DisableCacheBuild'),
  instanceId?: string(name='InstanceId'),
  overseaBuild?: string(name='OverseaBuild'),
  repoId?: string(name='RepoId'),
}

model UpdateRepoSourceCodeRepoResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateRepoSourceCodeRepoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRepoSourceCodeRepoResponseBody(name='body'),
}

async function updateRepoSourceCodeRepoWithOptions(request: UpdateRepoSourceCodeRepoRequest, runtime: Util.RuntimeOptions): UpdateRepoSourceCodeRepoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoBuild)) {
    query['AutoBuild'] = request.autoBuild;
  }
  if (!Util.isUnset(request.codeRepoId)) {
    query['CodeRepoId'] = request.codeRepoId;
  }
  if (!Util.isUnset(request.codeRepoName)) {
    query['CodeRepoName'] = request.codeRepoName;
  }
  if (!Util.isUnset(request.codeRepoNamespaceName)) {
    query['CodeRepoNamespaceName'] = request.codeRepoNamespaceName;
  }
  if (!Util.isUnset(request.codeRepoType)) {
    query['CodeRepoType'] = request.codeRepoType;
  }
  if (!Util.isUnset(request.disableCacheBuild)) {
    query['DisableCacheBuild'] = request.disableCacheBuild;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.overseaBuild)) {
    query['OverseaBuild'] = request.overseaBuild;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRepoSourceCodeRepo',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRepoSourceCodeRepo(request: UpdateRepoSourceCodeRepoRequest): UpdateRepoSourceCodeRepoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRepoSourceCodeRepoWithOptions(request, runtime);
}

model UpdateRepoTriggerRequest {
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  triggerId?: string(name='TriggerId'),
  triggerName?: string(name='TriggerName'),
  triggerTag?: string(name='TriggerTag'),
  triggerType?: string(name='TriggerType'),
  triggerUrl?: string(name='TriggerUrl'),
}

model UpdateRepoTriggerResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateRepoTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRepoTriggerResponseBody(name='body'),
}

async function updateRepoTriggerWithOptions(request: UpdateRepoTriggerRequest, runtime: Util.RuntimeOptions): UpdateRepoTriggerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.triggerId)) {
    query['TriggerId'] = request.triggerId;
  }
  if (!Util.isUnset(request.triggerName)) {
    query['TriggerName'] = request.triggerName;
  }
  if (!Util.isUnset(request.triggerTag)) {
    query['TriggerTag'] = request.triggerTag;
  }
  if (!Util.isUnset(request.triggerType)) {
    query['TriggerType'] = request.triggerType;
  }
  if (!Util.isUnset(request.triggerUrl)) {
    query['TriggerUrl'] = request.triggerUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRepoTrigger',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRepoTrigger(request: UpdateRepoTriggerRequest): UpdateRepoTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRepoTriggerWithOptions(request, runtime);
}

model UpdateRepositoryRequest {
  detail?: string(name='Detail'),
  instanceId?: string(name='InstanceId'),
  repoId?: string(name='RepoId'),
  repoName?: string(name='RepoName'),
  repoNamespaceName?: string(name='RepoNamespaceName'),
  repoType?: string(name='RepoType'),
  summary?: string(name='Summary'),
  tagImmutability?: boolean(name='TagImmutability'),
}

model UpdateRepositoryResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  requestId?: string(name='RequestId'),
}

model UpdateRepositoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRepositoryResponseBody(name='body'),
}

async function updateRepositoryWithOptions(request: UpdateRepositoryRequest, runtime: Util.RuntimeOptions): UpdateRepositoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.detail)) {
    query['Detail'] = request.detail;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.repoId)) {
    query['RepoId'] = request.repoId;
  }
  if (!Util.isUnset(request.repoName)) {
    query['RepoName'] = request.repoName;
  }
  if (!Util.isUnset(request.repoNamespaceName)) {
    query['RepoNamespaceName'] = request.repoNamespaceName;
  }
  if (!Util.isUnset(request.repoType)) {
    query['RepoType'] = request.repoType;
  }
  if (!Util.isUnset(request.summary)) {
    query['Summary'] = request.summary;
  }
  if (!Util.isUnset(request.tagImmutability)) {
    query['TagImmutability'] = request.tagImmutability;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRepository',
    version = '2018-12-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRepository(request: UpdateRepositoryRequest): UpdateRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRepositoryWithOptions(request, runtime);
}

