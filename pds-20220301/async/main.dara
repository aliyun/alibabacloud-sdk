/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'pds';
  @version = '2022-03-01';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AIAssistantChatConstraint {
  language?: string(name='language', example='zh-Hans'),
  tone?: string(name='tone', example='professional'),
}

model AIAssistantChatReference {
  category?: string(name='category', example='image'),
  driveId?: string(name='drive_id', example='1'),
  fileId?: string(name='file_id', example='abcxxx'),
  revisionId?: string(name='revision_id', example='xyzxxx'),
  semanticResult?: SemanticResult(name='semantic_result'),
  url?: string(name='url', example='http://aliyun.com'),
}

model AIAssistantChatScope {
  driveIds?: [ string ](name='drive_ids'),
  files?: [
    CommonFileItem
  ](name='files'),
}

model AIAssistantChatTool {
  description?: string(name='description', example='简历编写'),
  name?: string(name='name', example='work/resume'),
}

model AccountAccessTokenResponse {
  accessToken?: string(name='access_token'),
  avatar?: string(name='avatar'),
  defaultDriveId?: string(name='default_drive_id'),
  defaultSboxDriveId?: string(name='default_sbox_drive_id'),
  deviceId?: string(name='device_id'),
  deviceName?: string(name='device_name'),
  domainId?: string(name='domain_id'),
  existLink?: [
    LinkInfo
  ](name='exist_link'),
  expireTime?: string(name='expire_time'),
  expiresIn?: long(name='expires_in'),
  isFirstLogin?: boolean(name='is_first_login'),
  needLink?: boolean(name='need_link'),
  needRpVerify?: boolean(name='need_rp_verify'),
  nickName?: string(name='nick_name'),
  pathStatus?: string(name='path_status'),
  pinSetup?: boolean(name='pin_setup'),
  refreshToken?: string(name='refresh_token'),
  role?: string(name='role'),
  state?: string(name='state'),
  status?: string(name='status'),
  tokenType?: string(name='token_type'),
  userData?: map[string]string(name='user_data'),
  userId?: string(name='user_id'),
  userName?: string(name='user_name'),
}

model AccountLinkInfo {
  authenticationType?: string(name='authentication_type'),
  createdAt?: long(name='created_at'),
  displayName?: string(name='display_name'),
  domainId?: string(name='domain_id'),
  extra?: string(name='extra'),
  identity?: string(name='identity'),
  userId?: string(name='user_id'),
}

model Activity {
  activityId?: string(name='activity_id'),
  device?: string(name='device'),
  driveId?: string(name='drive_id'),
  eventType?: int32(name='event_type'),
  latestEventTime?: string(name='latest_event_time'),
  resourceCategory?: int32(name='resource_category'),
  resourceList?: [  map[string]any ](name='resource_list'),
  totalResourceCount?: long(name='total_resource_count'),
  userId?: string(name='user_id'),
}

model Address {
  city?: string(name='city', example='杭州市'),
  country?: string(name='country', example='中国'),
  district?: string(name='district', example='余杭区'),
  province?: string(name='province', example='浙江省'),
  township?: string(name='township', example='文一西路'),
}

model AddressGroup {
  addressDetail?: Address(name='address_detail'),
  count?: long(name='count'),
  coverFileId?: string(name='cover_file_id'),
  coverUrl?: string(name='cover_url'),
  location?: string(name='location'),
  name?: string(name='name'),
}

model Aggregation {
  field?: bytes(name='field'),
  groups?: [
    AggregationsGroup
  ](name='groups'),
  operation?: bytes(name='operation'),
  value?: double(name='value'),
}

model AggregationsGroup {
  count?: long(name='count'),
  value?: bytes(name='value'),
}

model Album {
  albumId?: string(name='album_id'),
  baseFaceFile?: File(name='base_face_file'),
  baseFaceGroupId?: string(name='base_face_group_id'),
  coverFile?: File(name='cover_file'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  fileCount?: long(name='file_count'),
  name?: string(name='name'),
  owner?: string(name='owner'),
  updatedAt?: string(name='updated_at'),
  userTags?: map[string]string(name='user_tags'),
}

model AlbumFile {
  albumId?: string(name='album_id'),
  category?: string(name='category'),
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  contentType?: string(name='content_type'),
  crc64Hash?: string(name='crc64_hash'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  downloadUrl?: string(name='download_url'),
  driveId?: string(name='drive_id'),
  exFieldsInfo?: map[string]any(name='ex_fields_info'),
  fileExtension?: string(name='file_extension'),
  fileId?: string(name='file_id'),
  hidden?: boolean(name='hidden'),
  imageMediaMetadata?: ImageMediaMetadata(name='image_media_metadata'),
  investigationInfo?: InvestigationInfo(name='investigation_info'),
  joinedAt?: long(name='joined_at'),
  labels?: [ string ](name='labels'),
  localCreatedAt?: string(name='local_created_at'),
  localModifiedAt?: string(name='local_modified_at'),
  mimeType?: string(name='mime_type'),
  name?: string(name='name'),
  objectUri?: string(name='object_uri'),
  parentFileId?: string(name='parent_file_id'),
  revisionId?: string(name='revision_id'),
  size?: long(name='size'),
  starred?: boolean(name='starred'),
  status?: string(name='status'),
  thumbnail?: string(name='thumbnail'),
  thumbnailUrls?: map[string]string(name='thumbnail_urls'),
  transhedAt?: string(name='transhed_at'),
  type?: string(name='type'),
  updatedAt?: string(name='updated_at'),
  uploadId?: string(name='upload_id'),
  userMeta?: string(name='user_meta'),
}

model App {
  appId?: string(name='app_id'),
  appName?: string(name='app_name'),
  appSecret?: string(name='app_secret'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  logo?: string(name='logo'),
  provider?: string(name='provider'),
  redirectUri?: string(name='redirect_uri'),
  scope?: [ string ](name='scope'),
  stage?: string(name='stage'),
  type?: string(name='type'),
  updatedAt?: string(name='updated_at'),
}

model AppAccessStrategy {
  effect?: string(name='effect'),
  exceptAppIdList?: [ string ](name='except_app_id_list'),
}

model ArchiveFilesConfig {
  enable?: boolean(name='enable'),
  version?: string(name='version'),
}

model ArchiveFilesConfigResponse {
  enabled?: boolean(name='enabled'),
  version?: string(name='version'),
}

model AsyncTask {
  asyncTaskId?: string(name='async_task_id'),
  category?: string(name='category'),
  consumedProcess?: long(name='consumed_process'),
  createdAt?: string(name='created_at'),
  errorCode?: string(name='error_code'),
  errorMessage?: string(name='error_message'),
  finishedAt?: string(name='finished_at'),
  startedAt?: string(name='started_at'),
  state?: string(name='state'),
  taskType?: string(name='task_type'),
  totalProcess?: long(name='total_process'),
  userId?: string(name='user_id'),
}

model AudioPreviewPlayInfo {
  meta?: {
    bitrate?: long(name='bitrate'),
    channels?: long(name='channels'),
    duration?: double(name='duration'),
    sampleRate?: long(name='sample_rate'),
  }(name='meta'),
  offlineAudioList?: [ 
    {
      status?: string(name='status'),
      templateId?: string(name='template_id'),
      url?: string(name='url'),
    }
  ](name='offline_audio_list'),
}

model AuditLog {
  actedAt?: string(name='acted_at'),
  actionCategory?: string(name='action_category'),
  actionType?: string(name='action_type'),
  actorId?: string(name='actor_id'),
  actorName?: string(name='actor_name'),
  actorType?: string(name='actor_type'),
  clientDevice?: string(name='client_device'),
  clientIp?: string(name='client_ip'),
  clientType?: string(name='client_type'),
  clientVersion?: string(name='client_version'),
  detail?: AuditLogDetail(name='detail'),
  filePathType?: string(name='file_path_type'),
  logId?: string(name='log_id'),
  objectId?: string(name='object_id'),
  objectName?: string(name='object_name'),
}

model AuditLogDetail {
  driveLogDetail?: DriveLogDetail(name='drive_log_detail'),
  fileLogDetail?: FileLogDetail(name='file_log_detail'),
  userLogDetail?: UserLogDetail(name='user_log_detail'),
}

model AuthenticationInfo {
  authenticationDisplayName?: string(name='authentication_display_name'),
  authenticationType?: string(name='authentication_type'),
  extra?: string(name='extra'),
  identity?: string(name='identity'),
}

model BaseAlbumFileOperationResult {
  errorCode?: string(name='error_code'),
  errorMessage?: string(name='error_message'),
  file?: CommonFileItem(name='file'),
  isSucceed?: boolean(name='is_succeed'),
}

model BaseAssignmentResponse {
  associatedRoleTagId?: string(name='associated_role_tag_id'),
  createdAt?: string(name='created_at'),
  creator?: string(name='creator'),
  disinheritSubGroup?: boolean(name='disinherit_sub_group'),
  domainId?: string(name='domain_id'),
  identity?: Identity(name='identity'),
  manageResourceId?: string(name='manage_resource_id'),
  manageResourceType?: string(name='manage_resource_type'),
  roleId?: string(name='role_id'),
  updatedAt?: string(name='updated_at'),
}

model BaseDomainResponse {
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  domainName?: string(name='domain_name'),
  initDriveEnable?: boolean(name='init_drive_enable'),
  initDriveSize?: long(name='init_drive_size'),
  parentDomainId?: string(name='parent_domain_id'),
  publishedAppAccessStrategy?: AppAccessStrategy(name='published_app_access_strategy'),
  shareLinkEnabled?: boolean(name='share_link_enabled'),
  sizeQuota?: long(name='size_quota'),
  sizeQuotaUsed?: long(name='size_quota_used'),
  status?: long(name='status'),
  updatedAt?: string(name='updated_at'),
  usedSize?: long(name='used_size'),
}

model BaseDriveResponse {
  actionList?: [ string ](name='action_list'),
  category?: string(name='category'),
  createdAt?: string(name='created_at'),
  creator?: string(name='creator', example='ccp'),
  deltaEnabled?: boolean(name='delta_enabled'),
  description?: string(name='description', example='ccp team drive'),
  domainId?: string(name='domain_id', example='hz999'),
  driveId?: string(name='drive_id', example='123'),
  driveName?: string(name='drive_name', example='ccpdrive'),
  driveType?: string(name='drive_type', example='normal'),
  encryptDataAccess?: boolean(name='encrypt_data_access'),
  encryptMode?: string(name='encrypt_mode'),
  isHandover?: boolean(name='is_handover'),
  owner?: string(name='owner', example='ccp'),
  ownerType?: string(name='owner_type', example='user'),
  pathStatus?: string(name='path_status'),
  permission?: map[string]IDPermission(name='permission'),
  relativePath?: string(name='relative_path'),
  status?: string(name='status', example='enabled'),
  storeId?: string(name='store_id', example='123'),
  totalSize?: long(name='total_size', example='102400'),
  updatedAt?: string(name='updated_at'),
  usedSize?: long(name='used_size', example='1024'),
}

model BaseGroupResponse {
  createdAt?: long(name='created_at', example='111111'),
  creator?: string(name='creator', example='system'),
  description?: string(name='description', example='desc-111'),
  domainId?: string(name='domain_id', example='bj123'),
  groupId?: string(name='group_id', example='b38b5681bd964950ad8bc0f8ea504793'),
  groupName?: string(name='group_name', example='name-111'),
  isSync?: boolean(name='is_sync'),
  permission?: map[string]IDPermission(name='permission'),
  updatedAt?: string(name='updated_at', example='111111'),
}

model BasePunishLogResponse {
  errorCode?: string(name='error_code'),
  errorMessage?: string(name='error_message'),
  punishedAt?: string(name='punished_at'),
  punishee?: {
    contentHash?: {
      hashHexStr?: string(name='hash_hex_str'),
      hashName?: string(name='hash_name'),
      size?: long(name='size'),
    }(name='content_hash'),
    driveId?: string(name='drive_id'),
    faceGroupId?: string(name='face_group_id'),
    fileId?: string(name='file_id'),
    revisionId?: string(name='revision_id'),
    shareId?: string(name='share_id'),
    userId?: string(name='user_id'),
  }(name='punishee'),
  punishmentDetail?: {
    actionCode?: string(name='action_code'),
    investigationStatus?: long(name='investigation_status'),
    method?: string(name='method'),
    punishReason?: string(name='punish_reason'),
    punishments?: [
      PunishRule
    ](name='punishments'),
    source?: string(name='source'),
  }(name='punishment_detail'),
  punishmentId?: string(name='punishment_id'),
  punishmentOperation?: string(name='punishment_operation'),
  status?: string(name='status'),
}

model BaseRoleMemberResponse {
  assignmentList?: [
    BaseAssignmentResponse
  ](name='assignment_list'),
  createdAt?: string(name='created_at'),
  creator?: string(name='creator'),
  domainId?: string(name='domain_id'),
  identity?: Identity(name='identity'),
  identityName?: string(name='identity_name'),
  isAdmin?: boolean(name='is_admin'),
  subdomainId?: string(name='subdomain_id'),
}

model BaseUserPunishRuleResponse {
  results?: [ 
    {
      success?: boolean(name='success'),
      userId?: string(name='user_id'),
    }
  ](name='results'),
}

model BaseUserResponse {
  avatar?: string(name='avatar', example='http://a.b.c/ccp.jpg'),
  createdAt?: string(name='created_at', example='1567407718386'),
  creator?: string(name='creator', example='system'),
  defaultDriveId?: string(name='default_drive_id', example='123'),
  defaultLocation?: string(name='default_location'),
  denyChangePasswordBySelf?: boolean(name='deny_change_password_by_self'),
  description?: string(name='description', example='ccp team user'),
  domainId?: string(name='domain_id', example='hz999'),
  email?: string(name='email', example='123@ccp.com'),
  expiredAt?: long(name='expired_at', example='0'),
  isSync?: boolean(name='is_sync'),
  lastLoginTime?: long(name='last_login_time'),
  needChangePasswordNextLogin?: boolean(name='need_change_password_next_login'),
  nickName?: string(name='nick_name', example='abc'),
  pathStatus?: string(name='path_status'),
  permission?: map[string]IDPermission(name='permission'),
  phone?: string(name='phone', example='13700000000'),
  phoneRegion?: string(name='phone_region'),
  role?: string(name='role', example='user'),
  status?: string(name='status', example='enabled'),
  updatedAt?: string(name='updated_at', example='1567407718386'),
  userData?: map[string]any(name='user_data'),
  userId?: string(name='user_id', example='ccpuserid'),
  userName?: string(name='user_name', example='name'),
}

model BenefitMeta {
  config?: string(name='config'),
  enabled?: boolean(name='enabled'),
  quota?: long(name='quota'),
}

model BenefitPkgDeliveryInfo {
  amount?: long(name='amount'),
  createdAt?: string(name='created_at'),
  expireTime?: string(name='expire_time'),
  isPermanent?: boolean(name='is_permanent'),
}

model CNameStatus {
  bingdingState?: string(name='bingding_state', example='BINDING/BOUND'),
  legalState?: string(name='legal_state', example='NORMAL/ABNORMAL'),
  remark?: string(name='remark', example='beian'),
}

model CdnFileDownloadCallbackInfo {
  bucket: string(name='bucket', example='ccp-bj1-bj-1234'),
  domainId: string(name='domain_id'),
  driveId: string(name='drive_id'),
  expire: long(name='expire'),
  fileId: string(name='file_id'),
  object: string(name='object'),
  token: string(name='token', example='md5.Sum([]byte(fmt.Sprintf("%v%v%v%v%v%v...%v", 		req.Object, req.Range, req.DomainID, req.DriveID, req.UserID, req.FileID, req.Expire)))'),
  userId: string(name='user_id'),
}

model CertInfo {
  certBody?: string(name='cert_body', example='xxx'),
  certName?: string(name='cert_name', example='xxx'),
  certPrivatekey?: string(name='cert_privatekey', example='xxx'),
}

model ClearRecycleBinItem {
  asyncTaskId?: string(name='async_task_id'),
  domainId?: string(name='domain_id'),
  driveId?: string(name='drive_id'),
  taskId?: string(name='task_id'),
}

model CommonFileItem {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  revisionId?: string(name='revision_id'),
}

model Condition {
  intEquals?: [ long ](name='int_equals'),
  intNotEquals?: [ long ](name='int_not_equals'),
  stringEquals?: [ string ](name='string_equals'),
  stringNotEquals?: [ string ](name='string_not_equals'),
}

model CsiCondition {
  fileDataPunish?: Condition(name='file_data_punish'),
}

model CssCreateOrderParam {
  agentId?: string(name='agentId'),
  autoPay?: boolean(name='autoPay'),
  autoUseCoupon?: boolean(name='autoUseCoupon'),
  bid?: string(name='bid'),
  buyerId?: long(name='buyerId'),
  certificate?: string(name='certificate'),
  childId?: long(name='childId'),
  cilentIp?: string(name='cilentIp'),
  commodities?: [
    CssInstanceCommodity
  ](name='commodities'),
  createrNick?: string(name='createrNick'),
  cssAuthRequestParam?: any(name='cssAuthRequestParam'),
  fromApp?: string(name='fromApp'),
  language?: string(name='language'),
  marketType?: long(name='marketType'),
  memo?: string(name='memo'),
  orderOrigin?: string(name='orderOrigin'),
  orderParams?: map[string]string(name='orderParams'),
  payerId?: long(name='payerId'),
  planGroupId?: long(name='planGroupId'),
  planId?: long(name='planId'),
  planInstanceId?: string(name='planInstanceId'),
  promotionCode?: string(name='promotionCode'),
  promotionInputParam?: any(name='promotionInputParam'),
  requestId?: string(name='requestId'),
  skipChannel?: boolean(name='skipChannel'),
  token?: string(name='token'),
  transientAccess?: any(name='transientAccess'),
  umidToken?: string(name='umidToken'),
  userId?: long(name='userId'),
}

model CssInstanceCommodity {
  activityId?: long(name='activityId'),
  aliyunProduceCode?: string(name='aliyunProduceCode'),
  chargeType?: string(name='chargeType'),
  commodityCode?: string(name='commodityCode'),
  components?: [
    CssInstanceComponent
  ](name='components'),
  duration?: long(name='duration'),
  instanceId?: string(name='instanceId'),
  isFree?: boolean(name='isFree'),
  isPrePayPostCharge?: boolean(name='isPrePayPostCharge'),
  isRenewChange?: boolean(name='isRenewChange'),
  isSyncToSubscription?: boolean(name='isSyncToSubscription'),
  orderParams?: map[string]string(name='orderParams'),
  orderType?: string(name='orderType'),
  planItemId?: long(name='planItemId'),
  pricingCycle?: string(name='pricingCycle'),
  quantity?: long(name='quantity'),
  redeemNoList?: [ string ](name='redeemNoList'),
  redeemOrderType?: string(name='redeemOrderType'),
  refundSpecCode?: string(name='refundSpecCode'),
  specCode?: string(name='specCode'),
  specUpgradeOriginSpecCodes?: [ string ](name='specUpgradeOriginSpecCodes'),
  specifyStartDate?: long(name='specifyStartDate'),
  upgradeInquireFinancialValue?: boolean(name='upgradeInquireFinancialValue'),
}

model CssInstanceComponent {
  componentCode?: string(name='componentCode'),
  componentName?: string(name='componentName'),
  globalKey?: string(name='globalKey'),
  instanceProperty?: [
    CssInstanceProperty
  ](name='instanceProperty'),
  moduleAttrStatus?: long(name='moduleAttrStatus'),
  tag?: string(name='tag'),
}

model CssInstanceProperty {
  code?: string(name='code'),
  globalKey?: string(name='globalKey'),
  name?: string(name='name'),
  unit?: string(name='unit'),
  value?: string(name='value'),
}

model CssProduce {
  bid?: string(name='bid'),
  buyerId?: long(name='buyerId'),
  childId?: long(name='childId'),
  fromApp?: string(name='fromApp'),
  orderId?: long(name='orderId'),
  payerId?: long(name='payerId'),
  purchases?: [
    CssPurchase
  ](name='purchases'),
  requestId?: string(name='requestId'),
  skipChannel?: boolean(name='skipChannel'),
  token?: string(name='token'),
  userId?: long(name='userId'),
}

model CssPurchase {
  chargeType?: string(name='chargeType'),
  commodityCode?: string(name='commodityCode'),
  endDate?: long(name='endDate'),
  gmtCreate?: long(name='gmtCreate'),
  instanceComponents?: [
    CssInstanceComponent
  ](name='instanceComponents'),
  instanceId?: string(name='instanceId'),
  orderType?: string(name='orderType'),
  purchaseParams?: map[string]string(name='purchaseParams'),
  startDate?: long(name='startDate'),
}

model CustomSideLinkConfig {
  icon?: string(name='icon'),
  link?: string(name='link'),
  text?: string(name='text'),
}

model DataBoxPrivileges {
  featureAttrId?: string(name='feature_attr_id'),
  featureId?: string(name='feature_id'),
  quota?: long(name='quota'),
}

model DataCName {
  certExpireTime?: long(name='cert_expire_time'),
  certName?: string(name='cert_name'),
  cname?: string(name='cname'),
  cnameType?: string(name='cname_type'),
  location?: string(name='location'),
  storeId?: string(name='store_id'),
}

model DocumentContent {
  elementContents?: [
    ElementContent
  ](name='element_contents'),
}

model Domain {
  createdAt?: string(name='created_at'),
  dataHashName?: string(name='data_hash_name'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  domainName?: string(name='domain_name'),
  initDriveEnable?: boolean(name='init_drive_enable'),
  initDriveSize?: long(name='init_drive_size'),
  parentDomainId?: string(name='parent_domain_id'),
  publishedAppAccessStrategy?: AppAccessStrategy(name='published_app_access_strategy'),
  sharable?: boolean(name='sharable'),
  sizeQuota?: long(name='size_quota'),
  sizeQuotaUsed?: long(name='size_quota_used'),
  status?: long(name='status'),
  updatedAt?: string(name='updated_at'),
  usedSize?: long(name='used_size'),
  userCountQuota?: long(name='user_count_quota'),
}

model DomainAppConfig {
  allowUploadCustomFileExtList?: [ string ](name='allow_upload_custom_file_ext_list'),
  allowUploadFileCategoryList?: [ string ](name='allow_upload_file_category_list'),
  sameNameFileUploadMode?: string(name='same_name_file_upload_mode'),
  singleFileUploadSizeLimit?: long(name='single_file_upload_size_limit'),
  webClientDownloadMode?: string(name='web_client_download_mode'),
}

model DomainBuildClientConfig {
  copyright?: string(name='copyright'),
  name?: string(name='name'),
}

model DomainEndpoints {
}

model DomainSeniorConfig {
  clientDownloadEnable?: boolean(name='client_download_enable'),
  cspFrameAncestors?: string(name='csp_frame_ancestors'),
  customLoginAppid?: string(name='custom_login_appid'),
  customLoginUrl?: string(name='custom_login_url'),
  customLogoutUrl?: string(name='custom_logout_url'),
  customSideLinkList?: [
    CustomSideLinkConfig
  ](name='custom_side_link_list'),
  homePageBgImageUrl?: string(name='home_page_bg_image_url'),
  homePageFooter?: string(name='home_page_footer'),
  homePageFooter2?: string(name='home_page_footer2'),
  homePageSlogan?: string(name='home_page_slogan'),
  refererEnable?: boolean(name='referer_enable'),
  wxTxtList?: WxTrustedDomainConfig(name='wx_txt_list'),
}

model Drive {
  createdAt?: string(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  driveId?: string(name='drive_id'),
  driveName?: string(name='drive_name'),
  driveType?: string(name='drive_type'),
  owner?: string(name='owner'),
  ownerType?: string(name='owner_type'),
  status?: string(name='status'),
  totalSize?: long(name='total_size'),
  usedSize?: long(name='used_size'),
}

model DriveLogDetail {
  forceDelete?: boolean(name='force_delete'),
  handoverOwnerName?: string(name='handover_owner_name'),
  name?: string(name='name'),
  ownerId?: string(name='owner_id'),
  ownerName?: string(name='owner_name'),
  ownerType?: string(name='owner_type'),
  totalSize?: long(name='total_size'),
  updateTo?: {
    name?: string(name='name'),
    ownerId?: string(name='owner_id'),
    ownerName?: string(name='owner_name'),
    ownerType?: string(name='owner_type'),
    totalSize?: long(name='total_size'),
  }(name='update_to'),
}

model ElementContent {
  content?: string(name='content', example='文本片段'),
  timeRange?: [ long ](name='time_range'),
  type?: string(name='type', example='text'),
  url?: string(name='url', example='http://aliyun.com'),
}

model ExternalMultiFileRevisionConfig {
  revisionCount?: long(name='revision_count'),
  revisionMergeEnabled?: boolean(name='revision_merge_enabled'),
  revisionRecyclePeriod?: long(name='revision_recycle_period'),
}

model FaceGroup {
  createdAt?: string(name='created_at', example='2022-01-14T10:10:52.83948013+08:00'),
  groupCoverFaceBoundary?: {
    height?: int32(name='Height', example='300'),
    left?: int32(name='Left', example='10'),
    top?: int32(name='Top', example='30'),
    width?: int32(name='Width', example='200'),
  }(name='group_cover_face_boundary'),
  groupCoverFileId?: string(name='group_cover_file_id', example='6549c959640fbd517c9b4d93b3b36aecc45xxxxx'),
  groupCoverHeight?: long(name='group_cover_height', example='1080'),
  groupCoverUrl?: string(name='group_cover_url', example='https://xxx'),
  groupCoverWidth?: long(name='group_cover_width', example='1920'),
  groupId?: string(name='group_id', example='Cluster-ae6e3472-999e-410b-b54e-cd5dba****'),
  groupName?: string(name='group_name', example='name'),
  imageCount?: long(name='image_count', example='10'),
  remarks?: string(name='remarks'),
  updatedAt?: string(name='updated_at', example='2022-01-14T10:10:52.83948013+08:00'),
}

model FaceThumbnail {
  faceGroupId?: string(name='face_group_id', example='Cluster-e3b7fb52-22b3-44f2-9746-8c1804bd6af0'),
  faceId?: string(name='face_id', example='a9a66a86-73dd-4c95-8b79-1d8a49db5226'),
  faceThumbnail?: string(name='face_thumbnail', example='https://pds-domain.region.aliyuncs.com/QieGeH98%2F1001%2F63e5e551ee621482ab934a0687c6cda75fc07864%2F642a8a40c00f1ad379df421694713ee65170f09b?security-token=CAIS%2BgF1q6Ft5B2yfSjIr5bjHPCNnrdR8aSaSW7woVlmVd1Bt5HorDz2IHpPfHdoBe0btvU%2BlWxX6fwZlq5rR4QAXlDfNSyFeX20qFHPWZHInuDox55m4cTXNAr%2BIhr%2F29CoEIedZdjBe%2FCrRknZnytou9XTfimjWFrXWv%2Fgy%2BQQDLItUxK%2FcCBNCfpPOwJms7V6D3bKMuu3OROY6Qi5TmgQ41En1DIlt%2FXuk5DCtkqB12eXkLFF%2B97DRbG%2FdNRpMZtFVNO44fd7bKKp0lQLsUMSqv8q0fEcqGaW4o7CWQJLnzyCMvvJ9OVDFyN0aKEnH7J%2Bq%2FzxhTPrMnpkSlacGoABPMvZ8rSESUEP96Vbf%2Bk0JRg9Qb1MnaIJqWAgo8K6K0UP1CtqL2zrUtugpKKDHOYiKbq2O0S5yLUPVX5vBHqEi%2FFc7i6ZnHCMcXLJs4rKDKwRBEhovUXXlklq2q43OSVtLrXkBy9Xs1ers%2FhJhcxpNA0Vl3EWfJxa2BTylEdnLOQ%3D&x-oss-access-key-id=STS.NUVWJ9shpFfqKHAEY3YRmXTCN&x-oss-expires=1686455451&x-oss-process=image%2Fcrop%2Cx_1128%2Cy_1211%2Cw_914%2Ch_914%2Fformat%2Cjpg&x-oss-signature=jmhOz91Tww1ciMEwadDiioU7d93FDiBNr8s8mHyMqW0%3D&x-oss-signature-version=OSS2', deprecated='true'),
}

model File {
  category?: string(name='category'),
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  contentType?: string(name='content_type'),
  crc64Hash?: string(name='crc64_hash'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  downloadUrl?: string(name='download_url'),
  driveId?: string(name='drive_id'),
  fileExtension?: string(name='file_extension'),
  fileId?: string(name='file_id'),
  hidden?: boolean(name='hidden'),
  imageMediaMetadata?: ImageMediaMetadata(name='image_media_metadata'),
  labels?: [ string ](name='labels'),
  localCreatedAt?: string(name='local_created_at'),
  localModifiedAt?: string(name='local_modified_at'),
  name?: string(name='name'),
  parentFileId?: string(name='parent_file_id'),
  revisionId?: string(name='revision_id'),
  size?: long(name='size'),
  starred?: boolean(name='starred'),
  status?: string(name='status'),
  thumbnail?: string(name='thumbnail'),
  thumbnailUrls?: map[string]string(name='thumbnail_urls'),
  trashedAt?: string(name='trashed_at'),
  type?: string(name='type'),
  updatedAt?: string(name='updated_at'),
  uploadId?: string(name='upload_id'),
  userTags?: map[string]string(name='user_tags'),
  videoMediaMetadata?: VideoMediaMetadata(name='video_media_metadata'),
}

model FileDownloadCallbackInfo {
  bucket: string(name='bucket', example='ccp-bj1-bj-1234'),
  domainId: string(name='domain_id'),
  driveId: string(name='drive_id'),
  fileId: string(name='file_id'),
  object: string(name='object'),
  userId: string(name='user_id'),
}

model FileLogDetail {
  decompressFileList?: [ string ](name='decompress_file_list'),
  newName?: string(name='new_name'),
  parentPath?: string(name='parent_path'),
  revVersion?: long(name='rev_version'),
  revisionId?: string(name='revision_id'),
  size?: long(name='size'),
  toParentPath?: string(name='to_parent_path'),
  toParentPathType?: string(name='to_parent_path_type'),
  type?: string(name='type'),
}

model FilePermissionMember {
  actionList?: [ string ](name='action_list'),
  disinheritSubGroup?: boolean(name='disinherit_sub_group'),
  expireTime?: long(name='expire_time'),
  identity?: Identity(name='identity'),
  roleId?: string(name='role_id'),
}

model FileStreamInfo {
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  contentMd5?: string(name='content_md5'),
  partInfoList?: UploadPartInfo(name='part_info_list'),
  preHash?: string(name='pre_hash'),
  proofCode?: string(name='proof_code'),
  proofVersion?: string(name='proof_version'),
  size?: long(name='size'),
}

model FrameContent {
  frameTime?: long(name='frame_time', example='1000'),
  thumbnailUrl?: string(name='thumbnail_url', example='http://aliyun.com'),
}

model GetOfficeEditUrlOption {
  copy?: boolean(name='copy'),
  print?: boolean(name='print'),
  readonly?: boolean(name='readonly'),
}

model GetOfficeEditUrlWatermark {
  fillstyle?: string(name='fillstyle'),
  font?: string(name='font'),
  horizontal?: long(name='horizontal'),
  rotate?: double(name='rotate'),
  type?: int32(name='type'),
  value?: string(name='value'),
  vertical?: long(name='vertical'),
}

model GetOfficePreviewUrlOption {
  copy?: boolean(name='copy'),
  print?: boolean(name='print'),
}

model Group {
  createdAt?: long(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  groupId?: string(name='group_id'),
  groupName?: string(name='group_name'),
  updatedAt?: long(name='updated_at'),
}

model IDPermission {
  disinheritSubGroup?: boolean(name='disinherit_sub_group'),
  expireTime?: long(name='expire_time'),
  permission?: Permission(name='permission'),
  roles?: [ string ](name='roles'),
}

model Identity {
  identityId?: string(name='identity_id'),
  identityType?: string(name='identity_type', example='IT_User'),
}

model IdentityBenefitPkg {
  benefitPkgId?: string(name='benefit_pkg_id'),
  name?: string(name='name'),
}

model IdentityToBenefitPkgMapping {
  benefitPkgComputationRule?: string(name='benefit_pkg_computation_rule'),
  benefitPkgId?: string(name='benefit_pkg_id'),
  benefitPkgName?: string(name='benefit_pkg_name'),
  benefitPkgOwnerId?: string(name='benefit_pkg_owner_id'),
  benefitPkgPriority?: long(name='benefit_pkg_priority'),
  benefitPkgType?: string(name='benefit_pkg_type'),
  createdAt?: string(name='created_at'),
  deliveryInfoList?: [
    BenefitPkgDeliveryInfo
  ](name='delivery_info_list'),
  identityId?: string(name='identity_id'),
  identityType?: string(name='identity_type'),
  updatedAt?: string(name='updated_at'),
}

model ImageMediaMetadata {
  addressLine?: string(name='address_line', example='浙江省杭州市滨江区西兴街道江陵路'),
  city?: string(name='city', example='杭州市'),
  country?: string(name='country', example='中国'),
  district?: string(name='district', example='滨江区'),
  exif?: string(name='exif', example='{"Compression":{"value":"6"},"DateTime":{"value":"2020:08:19 17:11:11"}}'),
  facesThumbnail?: [
    FaceThumbnail
  ](name='faces_thumbnail'),
  height?: long(name='height', example='1080'),
  imageQuality?: ImageQuality(name='image_quality'),
  imageTags?: [
    SystemTag
  ](name='image_tags'),
  location?: string(name='location', example='30.185453,120.218522'),
  province?: string(name='province', example='浙江省'),
  time?: string(name='time', example='2006-01-02T15:04:05.000Z07:00'),
  township?: string(name='township', example='西兴街道'),
  width?: long(name='width', example='1920'),
}

model ImageProcess {
  imageThumbnailProcess?: string(name='image_thumbnail_process'),
  officeThumbnailProcess?: string(name='office_thumbnail_process'),
  videoThumbnailProcess?: string(name='video_thumbnail_process'),
}

model ImageQuality {
  overallScore?: double(name='overall_score', example='0.736'),
}

model ImageTag {
  count?: long(name='count', example='10'),
  coverFileCategory?: string(name='cover_file_category', example='image'),
  coverFileId?: string(name='cover_file_id', example='5d79206586bb5dd69fb34c349282718146c55da7'),
  coverOverallScore?: float(name='cover_overall_score', example='0.736'),
  coverTagConfidence?: float(name='cover_tag_confidence', example='1'),
  coverUrl?: string(name='cover_url', example='https://data.aliyunpds.com/hz22%2F5d5b986facbec311ef844c25954f96821497b383%2F5d5b986f955410dd991646bb87c6b4e899eff525?Expires=xxx&OSSAccessKeyId=xxx&Signature=xxx'),
  name?: string(name='name', example='动物'),
}

model Int64Range {
  from?: long(name='from'),
  to?: long(name='to'),
}

model InvestigationInfo {
  status?: long(name='status'),
  suggestion?: string(name='suggestion'),
  videoDetail?: {
    blockFrames?: [ 
      {
        label?: string(name='label'),
        offset?: long(name='offset'),
        rate?: double(name='rate'),
      }
    ](name='block_frames'),
  }(name='video_detail'),
}

model JWTPayload {
  aud?: string(name='aud'),
  autoCreate?: boolean(name='auto_create'),
  exp?: long(name='exp'),
  iat?: long(name='iat'),
  iss?: string(name='iss'),
  jti?: string(name='jti'),
  nbf?: long(name='nbf'),
  sub?: string(name='sub'),
  subType?: string(name='sub_type'),
}

model KnowledgeFile {
  creatorId?: string(name='creator_id'),
  driveId?: string(name='drive_id'),
  fileCategory?: string(name='file_category'),
  fileCreatedAt?: long(name='file_created_at'),
  fileCreatorId?: string(name='file_creator_id'),
  fileId?: string(name='file_id'),
  fileImageTime?: long(name='file_image_time'),
  fileName?: string(name='file_name'),
  fileNamePath?: string(name='file_name_path'),
  fileSize?: long(name='file_size'),
  fileUpdatedAt?: long(name='file_updated_at'),
  joinedAt?: long(name='joined_at'),
  knowledgeBaseId?: string(name='knowledge_base_id'),
  knowledgeCategoryId?: string(name='knowledge_category_id'),
  revisionId?: string(name='revision_id'),
}

model KnowledgeFileItem {
  driveId: string(name='drive_id'),
  fileId: string(name='file_id'),
}

model LinkInfo {
  extra?: string(name='extra'),
  identity?: string(name='identity'),
  type?: string(name='type'),
}

model LocationDateCluster {
  address?: Address(name='address'),
  clusterId?: string(name='cluster_id'),
  createdAt?: string(name='created_at'),
  customLabels?: map[string]string(name='custom_labels'),
  driveId?: string(name='drive_id'),
  endTime?: string(name='end_time'),
  level?: string(name='level'),
  startTime?: string(name='start_time'),
  title?: string(name='title'),
  updatedAt?: string(name='updated_at'),
}

model Membership {
  createdAt?: long(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  groupId?: string(name='group_id'),
  memberRole?: string(name='member_role'),
  memberType?: string(name='member_type'),
  subGroupId?: string(name='sub_group_id'),
  updatedAt?: long(name='updated_at'),
  userId?: string(name='user_id'),
}

model NameCheckResult {
  existFileId?: string(name='exist_file_id'),
  existFileType?: string(name='exist_file_type'),
}

model OfficeEditConfig {
  enabled?: boolean(name='enabled'),
}

model OfficePreviewConfig {
  enabled?: boolean(name='enabled'),
}

model Permission {
  actionList?: [ 
    {
      action?: string(name='action'),
    }
  ](name='action_list'),
  collection?: string(name='collection'),
  condition?: PermissionCondition(name='condition'),
  createdAt?: long(name='created_at'),
  effect?: string(name='effect'),
  identityId?: string(name='identity_id'),
  identityType?: string(name='identity_type'),
  resource?: string(name='resource'),
  resourceType?: string(name='resource_type'),
  updatedAt?: long(name='updated_at'),
  userTags?: [ string ](name='user_tags'),
}

model PermissionCondition {
  ipEquals?: {
    clientIp?: [ string ](name='client_ip'),
  }(name='ip_equals'),
  ipNotEquals?: {
    clientIp?: [ string ](name='client_ip'),
  }(name='ip_not_equals'),
  stringLike?: {
    vpcId?: [ string ](name='vpc_id'),
  }(name='string_like'),
  stringNotLike?: {
    vpcId?: [ string ](name='vpc_id'),
  }(name='string_not_like'),
}

model PersonalRightsInfoResponse {
  expiresTime?: string(name='expires_time'),
  historyLatestRights?: PersonalRightsInfoResponse(name='history_latest_rights'),
  icon?: string(name='icon'),
  isExpires?: boolean(name='is_expires'),
  name?: string(name='name'),
  otherRights?: PersonalRightsInfoResponse(name='other_rights'),
  privileges?: [
    DataBoxPrivileges
  ](name='privileges'),
  spuId?: string(name='spu_id'),
  title?: string(name='title'),
}

model PersonalSpaceInfo {
  totalSize?: long(name='total_size'),
  usedSize?: long(name='used_size'),
}

model PunishRule {
  actionCode?: string(name='action_code'),
  endsAt?: string(name='ends_at'),
  impermanent?: boolean(name='impermanent'),
  startsAt?: string(name='starts_at'),
}

model RecycleBinConfig {
  autoDeleteEnabled?: boolean(name='auto_delete_enabled'),
  autoDeleteKeepSecond?: int32(name='auto_delete_keep_second'),
  deleteTrashNormalFileDisabled?: boolean(name='delete_trash_normal_file_disabled'),
}

model RefundNoticeParam {
  aliuid?: long(name='aliuid'),
  aliyunProduceCode?: string(name='aliyunProduceCode'),
  commodityCode?: string(name='commodityCode'),
  instanceId?: string(name='instanceId'),
  newExpireTime?: any(name='newExpireTime'),
  orderIds?: [ long ](name='orderIds'),
  refundParamMap?: map[string]string(name='refundParamMap'),
  refundType?: string(name='refundType'),
}

model Revision {
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  crc64Hash?: string(name='crc64_hash'),
  createdAt?: string(name='created_at'),
  creatorId?: string(name='creator_id'),
  creatorName?: string(name='creator_name'),
  domainId?: string(name='domain_id'),
  downloadUrl?: string(name='download_url'),
  driveId?: string(name='drive_id'),
  fileExtension?: string(name='file_extension'),
  fileId?: string(name='file_id'),
  isLatestVersion?: boolean(name='is_latest_version'),
  keepForever?: boolean(name='keep_forever'),
  revisionDescription?: string(name='revision_description'),
  revisionId?: string(name='revision_id'),
  revisionName?: string(name='revision_name'),
  revisionVersion?: long(name='revision_version'),
  size?: long(name='size'),
  thumbnail?: string(name='thumbnail'),
  updatedAt?: string(name='updated_at'),
  url?: string(name='url'),
}

model Role {
  createdAt?: long(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  manageResourceType?: string(name='manage_resource_type'),
  name?: string(name='name'),
  permissions?: [
    Permission
  ](name='permissions'),
  roleId?: string(name='role_id'),
  status?: string(name='status'),
  updatedAt?: long(name='updated_at'),
}

model SceneContent {
  keyFrames?: [
    FrameContent
  ](name='key_frames'),
  thumbnailUrl?: string(name='thumbnail_url', example='http://aliyun.com'),
  timeRange?: [ long ](name='time_range'),
}

model SearchFromThirdPartyItem {
  authenticationType?: string(name='authentication_type'),
  extra?: string(name='extra'),
  identity?: string(name='identity'),
  others?: map[string]any(name='others'),
}

model SemanticResult {
  documentContents?: [
    DocumentContent
  ](name='document_contents'),
  sceneContents?: [
    SceneContent
  ](name='scene_contents'),
  semanticSimilarity?: double(name='semantic_similarity', example='0.879'),
}

model ShareLink {
  accessCount?: long(name='access_count'),
  createdAt?: string(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  disableDownload?: boolean(name='disable_download'),
  disablePreview?: boolean(name='disable_preview'),
  disableSave?: boolean(name='disable_save'),
  downloadCount?: long(name='download_count'),
  downloadLimit?: long(name='download_limit'),
  driveId?: string(name='drive_id'),
  expiration?: string(name='expiration'),
  expired?: boolean(name='expired'),
  fileIdList?: [ string ](name='file_id_list'),
  previewCount?: long(name='preview_count'),
  previewLimit?: long(name='preview_limit'),
  reportCount?: long(name='report_count'),
  saveCount?: long(name='save_count'),
  saveDownloadLimit?: long(name='save_download_limit'),
  saveLimit?: long(name='save_limit'),
  shareAllFiles?: boolean(name='share_all_files'),
  shareId?: string(name='share_id'),
  shareName?: string(name='share_name'),
  sharePwd?: string(name='share_pwd'),
  status?: string(name='status'),
  updatedAt?: string(name='updated_at'),
  videoPreviewCount?: long(name='video_preview_count'),
}

model ShareLinkConfig {
  enableShareLinkOfficeEdit?: boolean(name='enable_share_link_office_edit'),
}

model ShareLinkDetail {
  enableOfficeEditable?: boolean(name='enable_office_editable'),
}

model SimpleQuery {
  field?: bytes(name='field'),
  operation?: bytes(name='operation'),
  subQueries?: [
    SimpleQuery
  ](name='sub_queries'),
  value?: bytes(name='value'),
}

model SimpleStreamInfo {
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  crc64Hash?: string(name='crc64_hash'),
  downloadUrl?: string(name='download_url'),
  size?: long(name='size'),
  thumbnail?: string(name='thumbnail'),
  url?: string(name='url'),
}

model Store {
  basePath?: string(name='base_path'),
  bucket?: string(name='bucket'),
  endpoint?: string(name='endpoint'),
  location?: string(name='location'),
  ownership?: string(name='ownership'),
  roleArn?: string(name='role_arn'),
  storeId?: string(name='store_id'),
  type?: string(name='type'),
}

model Story {
  coverFileId?: string(name='cover_file_id'),
  coverFileThumbnailUrl?: string(name='cover_file_thumbnail_url'),
  createdAt?: string(name='created_at'),
  customLabels?: map[string]any(name='custom_labels'),
  faceGroupIds?: [ string ](name='face_group_ids'),
  storyEndTime?: string(name='story_end_time'),
  storyFileList?: [
    File
  ](name='story_file_list'),
  storyId?: string(name='story_id'),
  storyName?: string(name='story_name'),
  storyStartTime?: string(name='story_start_time'),
  storySubType?: string(name='story_sub_type'),
  storyType?: string(name='story_type'),
  updatedAt?: string(name='updated_at'),
}

model StreamUploadInfo {
  location?: string(name='location', example='cn-beijing'),
  partInfoList?: [
    UploadPartInfo
  ](name='part_info_list'),
  preRapidUpload?: boolean(name='pre_rapid_upload', example='false'),
  rapidUpload?: boolean(name='rapid_upload', example='false'),
  uploadId?: string(name='upload_id', example='abcd'),
}

model SystemTag {
  centricScore?: float(name='centric_score', example='0.877'),
  confidence?: float(name='confidence', example='0.98'),
  name?: string(name='name', example='篮球'),
  parentName?: string(name='parent_name', example='运动'),
  tagLevel?: int32(name='tag_level', example='3'),
}

model TimeRange {
  end?: string(name='end'),
  start?: string(name='start'),
}

model Token {
  accessToken?: string(name='access_token'),
  avatar?: string(name='avatar'),
  defaultDriveId?: string(name='default_drive_id'),
  deviceId?: string(name='device_id'),
  deviceName?: string(name='device_name'),
  domainId?: string(name='domain_id'),
  expireTime?: string(name='expire_time'),
  expiresIn?: long(name='expires_in'),
  isFirstLogin?: boolean(name='is_first_login'),
  nickName?: string(name='nick_name'),
  refreshToken?: string(name='refresh_token'),
  role?: string(name='role'),
  status?: string(name='status'),
  tokenType?: string(name='token_type'),
  userId?: string(name='user_id'),
  userName?: string(name='user_name'),
}

model UCDataRefFileInfo {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  revisionId?: string(name='revision_id'),
}

model UCObjectInfo {
  bucket?: string(name='bucket'),
  md5?: string(name='md5'),
  objectKey?: string(name='object_key'),
  region?: string(name='region'),
  sha1?: string(name='sha1'),
  size?: long(name='size'),
}

model UncompressConfig {
  enable?: boolean(name='enable'),
  version?: string(name='version'),
}

model UncompressConfigResponse {
  enabled?: boolean(name='enabled'),
  version?: string(name='version'),
}

model UncompressedFileInfo {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  isFolder?: boolean(name='is_folder'),
  items?: [
    UncompressedFileInfo
  ](name='items'),
  name?: string(name='name'),
  size?: long(name='size'),
  updatedAt?: long(name='updated_at'),
}

model UploadFormInfo {
  bucketName?: string(name='bucket_name'),
  endpoint?: string(name='endpoint'),
  formData?: map[string]string(name='form_data'),
  objectKey?: string(name='object_key'),
  ossAccessKeyId?: string(name='oss_access_key_id'),
  ossEndPoint?: string(name='oss_end_point'),
  ossSecurityToken?: string(name='oss_security_token'),
  policy?: string(name='policy'),
  signature?: string(name='signature'),
}

model UploadPartInfo {
  etag?: string(name='etag', example='0CC175B9C0F1B6A831C399E269772661'),
  internalUploadUrl?: string(name='internal_upload_url'),
  parallelSha1Ctx?: {
    h?: [ long ](name='h'),
    partOffset?: long(name='part_offset'),
  }(name='parallel_sha1_ctx'),
  parallelSha256Ctx?: {
    h?: [ long ](name='h'),
    partOffset?: long(name='part_offset'),
  }(name='parallel_sha256_ctx'),
  partNumber: int32(name='part_number', example='1'),
  partSize?: long(name='part_size', example='1024'),
  uploadUrl: string(name='upload_url'),
}

model User {
  avatar?: string(name='avatar'),
  createdAt?: long(name='created_at'),
  creator?: string(name='creator'),
  defaultDriveId?: string(name='default_drive_id'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  email?: string(name='email'),
  nickName?: string(name='nick_name'),
  phone?: string(name='phone'),
  role?: string(name='role'),
  status?: string(name='status'),
  updatedAt?: long(name='updated_at'),
  userData?: map[string]string(name='user_data'),
  userId?: string(name='user_id'),
  userName?: string(name='user_name'),
}

model UserExtraItem {
  account?: [
    AccountLinkInfo
  ](name='account'),
  avatar?: string(name='avatar', example='http://a.b.c/ccp.jpg'),
  createdAt?: string(name='created_at', example='1567407718386'),
  creator?: string(name='creator', example='system'),
  defaultDrive?: BaseDriveResponse(name='default_drive'),
  defaultDriveId?: string(name='default_drive_id', example='123'),
  defaultLocation?: string(name='default_location'),
  denyChangePasswordBySelf?: boolean(name='deny_change_password_by_self'),
  description?: string(name='description', example='ccp team user'),
  domainId?: string(name='domain_id', example='hz999'),
  email?: string(name='email', example='123@ccp.com'),
  expiredAt?: long(name='expired_at', example='0'),
  isSync?: boolean(name='is_sync'),
  lastLoginTime?: long(name='last_login_time'),
  needChangePasswordNextLogin?: boolean(name='need_change_password_next_login'),
  nickName?: string(name='nick_name', example='abc'),
  parentGroup?: [
    BaseDriveResponse
  ](name='parent_group'),
  pathStatus?: string(name='path_status'),
  permission?: map[string]IDPermission(name='permission'),
  phone?: string(name='phone', example='13700000000'),
  phoneRegion?: string(name='phone_region'),
  role?: string(name='role', example='user'),
  status?: string(name='status', example='enabled'),
  updatedAt?: string(name='updated_at', example='1567407718386'),
  userData?: map[string]any(name='user_data'),
  userId?: string(name='user_id', example='ccpuserid'),
  userName?: string(name='user_name', example='name'),
}

model UserLogDetail {
  email?: string(name='email'),
  expiredAt?: long(name='expired_at'),
  name?: string(name='name'),
  phone?: string(name='phone'),
  roleId?: string(name='role_id'),
  updateTo?: {
    email?: string(name='email'),
    expiredAt?: long(name='expired_at'),
    name?: string(name='name'),
    phone?: string(name='phone'),
    roleId?: string(name='role_id'),
  }(name='update_to'),
}

model UserTag {
  key: string(name='key'),
  value: string(name='value'),
}

model VideoMediaAudioStream {
  bitRate?: string(name='bit_rate', example='129280'),
  codeName?: string(name='code_name', example='aac'),
  duration?: string(name='duration', example='7704.573000'),
}

model VideoMediaMetadata {
  height?: long(name='height', example='1080'),
  videoMediaAudioStream?: [
    VideoMediaAudioStream
  ](name='video_media_audio_stream'),
  videoMediaVideoStream?: [
    VideoMediaVideoStream
  ](name='video_media_video_stream'),
  width?: long(name='width', example='1920'),
}

model VideoMediaVideoStream {
  bitrate?: string(name='bitrate', example='108420'),
  codeName?: string(name='code_name', example='h264'),
  duration?: string(name='duration', example='22.88'),
  frameCount?: string(name='frame_count', example='90'),
}

model VideoPreviewPlayInfo {
  category?: string(name='category', example='live_transcoding'),
  liveTranscodingTaskList?: [ 
    {
      keepOriginalResolution?: boolean(name='keep_original_resolution'),
      status?: string(name='status'),
      templateId?: string(name='template_id'),
      url?: string(name='url'),
    }
  ](name='live_transcoding_task_list'),
  meta?: {
    duration?: double(name='duration'),
    height?: long(name='height'),
    width?: long(name='width'),
  }(name='meta'),
  offlineVideoTranscodingList?: [ 
    {
      keepOriginalResolution?: boolean(name='keep_original_resolution'),
      status?: string(name='status'),
      templateId?: string(name='template_id'),
      url?: string(name='url'),
    }
  ](name='offline_video_transcoding_list'),
}

model VideoPreviewPlayMeta {
  category?: string(name='category', example='live_transcoding'),
  liveTranscodingTaskList?: [ 
    {
      keepOriginalResolution?: boolean(name='keep_original_resolution'),
      status?: string(name='status'),
      templateId?: string(name='template_id', example='264_720p'),
    }
  ](name='live_transcoding_task_list'),
  meta?: {
    duration?: double(name='duration', example='10'),
    height?: long(name='height', example='720'),
    width?: long(name='width', example='1280'),
  }(name='meta'),
}

model View {
  category?: string(name='category'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  exFieldsInfo?: map[string]any(name='ex_fields_info'),
  fileCount?: long(name='file_count'),
  name?: string(name='name'),
  owner?: string(name='owner'),
  updatedAt?: string(name='updated_at'),
  viewId?: string(name='view_id'),
}

model ViewFile {
  category?: string(name='category'),
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  contentType?: string(name='content_type'),
  crc64Hash?: string(name='crc64_hash'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  downloadUrl?: string(name='download_url'),
  driveId?: string(name='drive_id'),
  fields?: map[string]any(name='fields'),
  fileExtension?: string(name='file_extension'),
  fileId?: string(name='file_id'),
  fileRevisionId?: string(name='file_revision_id'),
  hidden?: boolean(name='hidden'),
  investigationInfo?: {
    status?: long(name='status'),
    suggestion?: string(name='suggestion'),
  }(name='investigation_info'),
  joinedAt?: long(name='joined_at'),
  labels?: [ string ](name='labels'),
  localCreatedAt?: string(name='local_created_at'),
  localModifiedAt?: string(name='local_modified_at'),
  name?: string(name='name'),
  parentFileId?: string(name='parent_file_id'),
  revisionId?: string(name='revision_id'),
  size?: long(name='size'),
  starred?: boolean(name='starred'),
  status?: string(name='status'),
  thumbnail?: string(name='thumbnail'),
  thumbnailUrls?: map[string]string(name='thumbnail_urls'),
  trashedAt?: string(name='trashed_at'),
  type?: string(name='type'),
  updatedAt?: string(name='updated_at'),
  uploadId?: string(name='upload_id'),
  viewId?: string(name='view_id'),
}

model WatermarkConfig {
  displayAccessUserName?: boolean(name='display_access_user_name'),
  displayShareLinkCreatorName?: boolean(name='display_shareLink_creator_name'),
  enableDocPreview?: boolean(name='enable_doc_preview'),
  enableOnPreview?: boolean(name='enable_on_preview'),
}

model WatermarkEnableConfig {
  displayAccessUserName?: boolean(name='display_access_user_name'),
  displayCustomText?: string(name='display_custom_text'),
  displayShareLinkCreatorName?: boolean(name='display_shareLink_creator_name'),
  enableDocPreview?: boolean(name='enable_doc_preview'),
}

model WxTrustedDomainConfig {
  content?: string(name='content'),
  name?: string(name='name'),
  show?: boolean(name='show'),
}

model AddGroupMemberRequest {
  domainId?: string(name='domain_id', description='A short description of struct', position='Host'),
  groupId: string(name='group_id', description='The ID of the destination group to which the member is added.', example='3e5***2c2', position='Body'),
  memberId: string(name='member_id', description='The member ID. If member_type is set to user, set this parameter to a user ID.', example='2e4***1b1', position='Body'),
  memberType: string(name='member_type', description='The type of the member. Set the value to user. When you create a group, you can directly add the group to a parent group.

* user

Note: A group can be added to only one group. A user can be added to multiple groups.', example='user', position='Body'),
}

model AddGroupMemberResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function addGroupMember(request: AddGroupMemberRequest): AddGroupMemberResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AddGroupMember', 'POST', '/v2/group/add_member', 'none', false, 'json', request);
}

model AddStoryFilesRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', example='1', position='Body'),
  files?: [ 
    {
      fileId: string(name='file_id', example='63e5e4340f76cb3ead5f40f68163f0f967c1a7bf'),
      revisionId?: string(name='revision_id', example='642a88dd06e49d9c0a14411ebae606f70edd9a59'),
    }
  ](name='files', position='Body'),
  storyId: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003', position='Body'),
}

model AddStoryFilesResponseBody = {
  driveId?: string(name='drive_id', example='1'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model AddStoryFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddStoryFilesResponseBody(name='body'),
}

async function addStoryFiles(request: AddStoryFilesRequest): AddStoryFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AddStoryFiles', 'POST', '/v2/image/add_story_files', 'json', false, 'json', request);
}

model AssignRoleRequest {
  domainId?: string(name='domain_id', description='A short description of struct', position='Host'),
  identity: Identity(name='identity', description='The unique identifier of a user. The group administrator role can only be assigned to a user.', position='Body'),
  manageResourceId: string(name='manage_resource_id', description='The ID of the resource that the role can manage. You can only set this parameter to the ID of a group.', example='105***b82', position='Body'),
  manageResourceType: string(name='manage_resource_type', description='The type of the resource that the role can manage. Valid value: RT_Group.', example='RT_Group', position='Body'),
  roleId: string(name='role_id', description='The ID of the role that is assigned to a user. Valid value: SystemGroupAdmin.', example='SystemGroupAdmin', position='Body'),
}

model AssignRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * You can call this operation to assign a group administrator role to a user.
  *
 * @tags api
 */
async function assignRole(request: AssignRoleRequest): AssignRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AssignRole', 'POST', '/v2/role/assign', 'none', false, 'json', request);
}

model AuthorizeRequest {
  domainId?: string(name='domain_id', position='Host'),
  clientId: string(name='client_id', description='The application ID returned when the application was created.', example='47eUHhrzgWBvlLWj', position='Query'),
  hideConsent?: boolean(name='hide_consent', description='Specifies whether to hide the consent page.', example='true', position='Query'),
  loginType: string(name='login_type', description='The authentication method. Valid values:

*   default: all logon methods that are integrated on the default logon page provided by Drive and Photo Service.
*   ding: logs on by scanning a DingTalk QR code.
*   ding_sns: logs on by entering a DingTalk account and its password.
*   ram: logs on as an Alibaba Cloud Resource Access Management (RAM) user.
*   wechat: logs on by scanning a WeCom QR code.
*   wechat_app: logs on without authentication in WeCom.', example='default', position='Query'),
  redirectUri: string(name='redirect_uri', description='The callback URL specified when the application was created.', example='https://www.aliyunpds.com/sign/callback', position='Query'),
  responseType: string(name='response_type', description='The format in which to return the response. Set the value to code.', example='code', position='Query'),
  scope?: [ string ](name='scope', description='The requested permissions. By default, all permissions are requested.', shrink='simple', position='Query'),
  state?: string(name='state', description='The user-defined parameter to return in the callback URL after the requested permissions are granted.', example='customdata', position='Query'),
}

model AuthorizeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * For more information, see "OAuth 2.0 For Web Server Applications" at [OAuth 2.0 For Web Server Applications](https://www.alibabacloud.com/help/en/pds/drive-and-photo-service-dev/user-guide/oauth-2-0-access-process-for-web-server-applications) in User Guide.
  *
 * @tags api
 */
async function authorize(request: AuthorizeRequest): AuthorizeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'Authorize', 'GET', '/v2/oauth/authorize', 'none', false, 'json', request);
}

async function authorizeWithAsyncResponseHandler(request: AuthorizeRequest, responseHandler: AsyncResponseHandler): AuthorizeResponse {
  @handler.validateRequestModel(request);
  return @handler.doResponseHandler('RESTFUL', 'Authorize', 'GET', '/v2/oauth/authorize', 'none', false, 'json', request, responseHandler);
}

model BatchRequest {
  domainId?: string(name='domain_id', position='Host'),
  requests: [ 
    {
      body?: map[string]any(name='body', description='The request parameters of a child request. The parameter value must be a JSON string. For more information, see the topic of the corresponding child request.

Before you specify the request body, you must specify a header by using Content-Type. Content-Type can only be set to application/json.'),
      headers?: map[string]string(name='headers', description='The header of a child request, which indicates the type of the data specified in the request body.'),
      id: string(name='id', description='The ID of the child request. The ID is used to associate a child request with a response. The ID of a child request must be unique.', example='93433894994ad2e1'),
      method: string(name='method', description='The method of a child request. Valid values:

*   POST
*   GET
*   PUT
*   DELETE
*   HEAD', example='POST'),
      url: string(name='url', description='The API path of a child request. Valid values:

*   /file/get: queries the information about a file.
*   /file/update: modifies the information about a file.
*   /file/search: searches for a file.
*   /file/copy: copies a file or folder.
*   /file/move: moves a file or folder.
*   /file/delete: deletes a file or folder.
*   /file/get_download_url: queries the download URL of a file.
*   /file/get_share_link_download_url: queries the download URL of a file in a share.
*   /recyclebin/trash: moves a file or folder to the recycle bin.
*   /recyclebin/restore: restores a file or folder.
*   /file/put_usertags: adds tags to a user.
*   /file/delete_usertags: removes tags from a user.
*   /drive/get: queries the information about a drive.
*   /user/get: queries the information about a user.
*   /group/get: queries the information about a group.
*   /share_link/create: creates a share.
*   /share_link/update: modifies a share.
*   /share_link/cancel: cancels a share.
*   /share_link/list: queries shares.
*   /share_link/get: queries the information about a share.
*   /share_link/get_share_token: queries an access token of a share.
*   /async_task/get: queries the information about an asynchronous task.', example='/file/get'),
    }
  ](name='requests', description='The child requests.

The number of child requests. Valid value: 1 to 100.', position='Body'),
  resource: string(name='resource', description='The type of the resource that you want to manage. Valid values:

*   file: a file.
*   drive: an individual drive or a team drive.
*   user: a user.
*   group: a group.
*   membership: a group member.
*   share_link: a share.
*   async_task: an asynchronous task.', example='file', position='Body'),
}

model BatchResponseBody = {
  responses?: [ 
    {
      body?: map[string]any(name='body', description='The response parameters of a child request. For more information, see the topic of the corresponding child request.'),
      id?: string(name='id', description='The ID of the child request. The ID is used to associate a child request with a response.', example='93433894994ad2e1'),
      status?: int32(name='status', description='The returned HTTP status code of a child request. For more information, see the topic of the corresponding child request.', example='200'),
    }
  ](name='responses', description='All responses of the child requests.'),
}

model BatchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchResponseBody(name='body'),
}

async function batch(request: BatchRequest): BatchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'Batch', 'POST', '/v2/batch', 'json', false, 'json', request);
}

model CancelAssignRoleRequest {
  domainId?: string(name='domain_id', description='A short description of struct', position='Host'),
  identity: Identity(name='identity', description='The unique identifier. You can cancel only the role assigned to a user.', position='Body'),
  manageResourceId: string(name='manage_resource_id', description='The ID of the resource that the role manages. Set the value to a group ID.', example='105***b82', position='Body'),
  manageResourceType: string(name='manage_resource_type', description='The type of the resource that the role manages. Set the value to RT_Group, which specifies group.', example='RT_Group', position='Body'),
  roleId: string(name='role_id', description='The ID of the role to be canceled. Set the value to SystemGroupAdmin, which is the ID of the group administrator role.', example='SystemGroupAdmin', position='Body'),
}

model CancelAssignRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * You can cancel only the group administrator role.
  *
 * @tags api
 */
async function cancelAssignRole(request: CancelAssignRoleRequest): CancelAssignRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CancelAssignRole', 'POST', '/v2/role/cancel_assign', 'none', false, 'json', request);
}

model CancelShareLinkRequest {
  domainId?: string(name='domain_id', position='Host'),
  shareId: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8', position='Body'),
}

model CancelShareLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function cancelShareLink(request: CancelShareLinkRequest): CancelShareLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CancelShareLink', 'POST', '/v2/share_link/cancel', 'none', false, 'json', request);
}

model ClearRecyclebinRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
}

model ClearRecyclebinResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

You can call the GetAsyncTask operation to query the information about the asynchronous task based on the task ID.', example='13ebd3a24dba4166b1527add676ef2866051b4d5dele16'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
}

model ClearRecyclebinResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ClearRecyclebinResponseBody(name='body'),
}

async function clearRecyclebin(request: ClearRecyclebinRequest): ClearRecyclebinResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ClearRecyclebin', 'POST', '/v2/recyclebin/clear', 'json', false, 'json', request);
}

model CompleteFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264', position='Body'),
  uploadId: string(name='upload_id', description='The upload ID.', example='C9DCFE5A82644AC7A02DB74C30C934A6', position='Body'),
}

model CompleteFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: File  
}

async function completeFile(request: CompleteFileRequest): CompleteFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CompleteFile', 'POST', '/v2/file/complete', 'json', false, 'json', request);
}

model CopyFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  autoRename?: boolean(name='auto_rename', description='Specifies whether to automatically rename the file if the file name already exists in the destination folder. Default value: false.', example='true', position='Body'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The file ID or folder ID.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406', position='Body'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a share link, carry the `x-share-token` header for authentication in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify one of `share_id` and `drive_id`.', example='7JQX1FswpQ8', position='Body'),
  toDriveId?: string(name='to_drive_id', description='The ID of the drive to which you want to copy the file or folder. Default value: the value of drive_id.', example='1', position='Body'),
  toParentFileId: string(name='to_parent_file_id', description='The ID of the destination parent folder. If you want to copy the file or folder to a root directory, set this parameter to root.', example='6520943DC261', position='Body'),
}

model CopyFileResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

If a file is copied, this parameter is not returned. If a folder is copied, the folder is asynchronously copied in the background and this parameter is returned. You can call the GetAsyncTask operation to query the information about the asynchronous task based on the task ID.', example='000e89fb-cf8f-11e9-8ab4-b6e980803a3b'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The ID of the copied file or folder.', example='4221bf6e6ab43a255edc4463bffa6f5f5d317401'),
}

model CopyFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CopyFileResponseBody(name='body'),
}

async function copyFile(request: CopyFileRequest): CopyFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CopyFile', 'POST', '/v2/file/copy', 'json', false, 'json', request);
}

model CreateCustomizedStoryRequest {
  domainId?: string(name='domain_id', position='Host'),
  customLabels?: map[string]string(name='custom_labels', deprecated='true', position='Body'),
  driveId: string(name='drive_id', example='1', position='Body'),
  storyCover: {
    fileId: string(name='file_id', example='63e5e4340f76cb3ead5f40f68163f0f967c1a7bf'),
    revisionId?: string(name='revision_id', example='642a88d4aff041ee68fd4fc89beb80e1119da343'),
  }(name='story_cover', position='Body'),
  storyFiles: [ 
    {
      fileId: string(name='file_id', example='63e5e4340f76cb3ead5f40f68163f0f967c1a7bf'),
      revisionId?: string(name='revision_id', example='642a88d4aff041ee68fd4fc89beb80e1119da343'),
    }
  ](name='story_files', position='Body'),
  storyName: string(name='story_name', example='test_name', position='Body'),
  storySubType: string(name='story_sub_type', example='user_created', position='Body'),
  storyType: string(name='story_type', example='user_created', position='Body'),
}

model CreateCustomizedStoryResponseBody = {
  driveId?: string(name='drive_id', example='1'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model CreateCustomizedStoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCustomizedStoryResponseBody(name='body'),
}

async function createCustomizedStory(request: CreateCustomizedStoryRequest): CreateCustomizedStoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateCustomizedStory', 'POST', '/v2/image/create_customized_story', 'json', false, 'json', request);
}

model CreateDomainRequest {
  description?: string(name='description', description='The description of the domain.', example='domain for test', position='Body'),
  domainName: string(name='domain_name', description='The name of the domain.', example='test_domain', position='Body'),
  initDriveEnable?: boolean(name='init_drive_enable', description='Specifies whether to enable the default drive feature. A value of true specifies that all users are assigned a drive by default on the first logon. Default value: false.', example='true', position='Body'),
  initDriveSize?: long(name='init_drive_size', description='The size of the default drive. Unit: bytes. You must specify init_drive_size if you set init_drive_enable to true. Default value: 0. A value of 0 specifies that the size of the default drive is 0 bytes and you cannot upload files to the drive. To initialize the default drive, set init_drive_size to 0. A value of -1 specifies that the size is unlimited.', example='1073741824', position='Body'),
  parentDomainId?: string(name='parent_domain_id', description='The ID of the parent domain. If you want to create a child domain, specify parent_domain_id. In most cases, you do not need to create a child domain. If you want to perform secondary operations based on Drive and Photo Service, contact the customer service.', example='bj1', position='Body'),
  sizeQuota?: long(name='size_quota', description='The total storage quota for all drives in the domain. A value of 0 specifies that the quota is unlimited.', example='1099511627776', position='Body'),
  userCountQuota?: long(name='user_count_quota', description='The largest number of users that can be created in the domain. A value of 0 specifies that the number is unlimited.', example='50', position='Body'),
}

model CreateDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Domain  
}

/**
  * If you want to perform secondary operations based on Drive and Photo Service and perform fine-grained control on your tenants, you can use the parent-child domain feature of Drive and Photo Service. For more information, join the DingTalk group whose ID is 23146118.
  *
 * @tags admin
 */
async function createDomain(request: CreateDomainRequest): CreateDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateDomain', 'POST', '/v2/domain/create', 'json', false, 'json', request);
}

model CreateDriveRequest {
  domainId?: string(name='domain_id', position='Host'),
  default?: boolean(name='default', description='Specifies whether the drive is the default drive. Default value: false.', example='true', position='Body'),
  description?: string(name='description', description='The description of the drive. The description can be up to 1,024 characters in length.', example='drive for test', maxLength=1024, position='Body'),
  driveName: string(name='drive_name', description='The name of the drive. The name can be up to 128 characters in length.', example='test_drive', minLength=1, maxLength=1024, position='Body'),
  driveType?: string(name='drive_type', description='The type of the drive. Set the value to normal.', example='normal', position='Body'),
  owner: string(name='owner', description='The owner of the drive.', example='3b3d7245c159488da17d081ad6c64687', position='Body'),
  ownerType: string(name='owner_type', description='The type of the owner. Valid values:

user and group.', example='user', position='Body'),
  status?: string(name='status', description='The state of the drive. Valid values:

enabled and disabled.

Default value: enabled.', example='enabled', position='Body'),
  totalSize?: long(name='total_size', description='The total size of the drive. Unit: bytes. By default, the size is unlimited.', example='1024', position='Body'),
}

model CreateDriveResponseBody = {
  createdAt?: string(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  driveName?: string(name='drive_name'),
  driveType?: string(name='drive_type'),
  owner?: string(name='owner'),
  ownerType?: string(name='owner_type'),
  status?: string(name='status'),
  totalSize?: long(name='total_size'),
  usedSize?: long(name='used_size'),
}

model CreateDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDriveResponseBody(name='body'),
}

async function createDrive(request: CreateDriveRequest): CreateDriveResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateDrive', 'POST', '/v2/drive/create', 'json', false, 'json', request);
}

model CreateFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  checkNameMode?: string(name='check_name_mode', description='The processing method that is used if the file that you want to create has the same name as an existing file in the cloud. Valid values:

ignore: allows you to create the file by using the same name as an existing file in the cloud.

auto_rename: automatically renames the file that you want to create. By default, the current point in time is added to the end of the file name. Example: xxx\\_20060102\\_150405.

refuse: does not create the file that you want to create but returns the information about the file that has the same name in the cloud.

Default value: ignore.', example='ignore', position='Body'),
  contentHash?: string(name='content_hash', description='The hash value of the file content. The value is calculated based on the algorithm specified by content_hash_name.', example='7C4A8D09CA3762AF61E59520943DC26494F8941B', position='Body'),
  contentHashName?: string(name='content_hash_name', description='The name of the algorithm that is used to calculate the hash value of the file content. Only SHA1 is supported.', example='sha1', position='Body'),
  contentType?: string(name='content_type', description='The type of the file content. Default value: application/oct-stream.', example='application/json', position='Body'),
  description?: string(name='description', description='The description of the file. The description can be up to 1,024 characters in length. By default, this parameter is left empty.', example='重要文件', maxLength=1024, position='Body'),
  driveId?: string(name='drive_id', description='The drive ID. This parameter is required if the file is not uploaded by using the share URL of the file.', example='1', position='Body'),
  fileId?: string(name='file_id', description='The file ID. This parameter is required if check_name_mode is set to ignore.', example='9520943DC264', position='Body'),
  hidden?: boolean(name='hidden', description='Specifies whether to hide the file or folder. By default, the file or folder is not hidden.', example='false', position='Body'),
  imageMediaMetadata?: ImageMediaMetadata(name='image_media_metadata', description='The information about the image specified by the client.', position='Body'),
  localCreatedAt?: string(name='local_created_at', description='The time when the local file was created. By default, this parameter is left empty. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format based on the UTC+0 time zone.', example='2019-08-20T06:51:27.292Z', position='Body'),
  localModifiedAt?: string(name='local_modified_at', description='The time when the local file was modified. By default, this parameter is left empty. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format based on the UTC+0 time zone.', example='2019-08-20T06:51:27.292Z', position='Body'),
  name: string(name='name', description='The name of the file. The name can be up to 1,024 bytes in length based on the UTF-8 encoding rule and cannot end with a forward slash (/).', example='a.txt', minLength=1, maxLength=1024, position='Body'),
  parallelUpload?: boolean(name='parallel_upload', description='Specifies whether to enable the parallel upload feature.', example='true', position='Body'),
  parentFileId: string(name='parent_file_id', description='The ID of the parent directory. If you want to create a file or folder in the root directory, set this parameter to root.', example='fileid1', position='Body'),
  partInfoList?: [ 
    {
      contentMd5?: string(name='content_md5', description='The MD5 hash value of the file part. This parameter is required when the MD5 hash value of the file part needs to be verified during part upload.', example='ASKJDJSKDJJSJDJS'),
      parallelSha1Ctx?: {
        h?: [ long ](name='h', description='The first to fifth 32-bit variables of the SHA-1 hash value of the file content before the file part. This parameter takes effect only if the parallel upload feature is enabled.'),
        partOffset?: long(name='part_offset', description='The size of the file content before the file part. Unit: bytes. The value must be a multiple of 64. This parameter takes effect only if the parallel upload feature is enabled.', example='10240'),
      }(name='parallel_sha1_ctx', description='The SHA-1 hash value of the file content before the file part. This parameter takes effect only if the parallel upload feature is enabled.'),
      partNumber?: int32(name='part_number', description='The serial number of a file part. The number starts from 1.', example='1'),
    }
  ](name='part_info_list', description='The information about the file parts. You can specify up to 10,000 parts. By default, if you do not specify this parameter, only one part is returned.', position='Body'),
  preHash?: string(name='pre_hash', description='The SHA-1 hash value of the first 1 KB data of the file. This parameter is required if you perform instant file upload by using the pre-hashing feature. If the SHA-1 hash value is not matched on the cloud, the client does not need to calculate the SHA-1 hash value of the entire file.', example='7C4A8D09CA3762AF61E59520943DC26494F89411', position='Body'),
  shareId?: string(name='share_id', description='The share ID. This parameter is required if the file is uploaded by using the share URL of the file.', example='7JQX1FswpQ8', position='Body'),
  size?: long(name='size', description='The size of the file. Unit: bytes.', example='1024', position='Body'),
  type: string(name='type', description='The type of the file. Valid values:

file folder', example='file', position='Body'),
  userTags?: [
    UserTag
  ](name='user_tags', description='The custom tags. You can specify up to 1,000 tags.', position='Body'),
  videoMediaMetadata?: VideoMediaMetadata(name='video_media_metadata', description='The information about the video specified by the client.', position='Body'),
}

model CreateFileResponseBody = {
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  exist?: boolean(name='exist', description='Indicates whether the file exists.', example='false'),
  fileId?: string(name='file_id', description='The file ID.', example='fileid1'),
  fileName?: string(name='file_name', description='The file name.', example='a.txt'),
  parentFileId?: string(name='parent_file_id', description='The ID of the parent directory.', example='fileid5'),
  partInfoList?: [
    UploadPartInfo
  ](name='part_info_list', description='The information about the file parts.'),
  rapidUpload?: boolean(name='rapid_upload', description='Indicates whether the file is instantly uploaded.', example='true'),
  status?: string(name='status', description='The state of the file.', example='uploading'),
  type?: string(name='type', description='The type of the file.', example='file'),
  uploadId?: string(name='upload_id', description='The ID of the upload task.', example='uploadid1'),
}

model CreateFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFileResponseBody(name='body'),
}

async function createFile(request: CreateFileRequest): CreateFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateFile', 'POST', '/v2/file/create', 'json', false, 'json', request);
}

model CreateGroupRequest {
  domainId?: string(name='domain_id', position='Host'),
  description?: string(name='description', description='The description of the group. The description can be up to 1,024 characters in length.', example='test group description', position='Body'),
  groupName: string(name='group_name', description='The name of the group. The name must be 1 to 128 characters in length.', example='test group', position='Body'),
  isRoot?: boolean(name='is_root', description='Specifies whether the group is a root group. A root group cannot be added to any other group. In most cases, a root group is the top-level organization in the organizational structure.', example='false', position='Body'),
  parentGroupId?: string(name='parent_group_id', description='The ID of the parent group to which the group is added. If this parameter is specified, the system automatically adds the group to the specified parent group after the group is created.', example='2e43ec8427dd45f19431b7504649a1b3', position='Body'),
}

model CreateGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Group  
}

async function createGroup(request: CreateGroupRequest): CreateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateGroup', 'POST', '/v2/group/create', 'json', false, 'json', request);
}

model CreateIdentityToBenefitPkgMappingRequest {
  domainId?: string(name='domain_id', position='Host'),
  amount?: long(name='amount', description='The number of benefit packages.

This parameter takes effect only for the benefit packages of the resource type. Default value: 1.', example='1', position='Body'),
  benefitPkgId: string(name='benefit_pkg_id', description='The unique identifier of the benefit package.', example='40cb7794c9294', position='Body'),
  expireTime?: long(name='expire_time', description='The time when the benefit package expires. Set the value to a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.

By default, the benefit package never expires.', example='1633167071000', position='Body'),
  identityId: string(name='identity_id', description='The unique identifier of the entity.

If you want to manage the benefits of a user, set this parameter to a user ID.', example='user123', position='Body'),
  identityType: string(name='identity_type', description='The type of the entity.

If you want to manage the benefits of a user, set this parameter to user.', example='user', position='Body'),
}

model CreateIdentityToBenefitPkgMappingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * If you need to manage a large number of users based on Drive and Photo Service, you can control the features and quotas that users can use based on the benefits to which they are entitled. For more information, join the DingTalk group (ID 23146118).
  *
 * @tags api
 */
async function createIdentityToBenefitPkgMapping(request: CreateIdentityToBenefitPkgMappingRequest): CreateIdentityToBenefitPkgMappingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateIdentityToBenefitPkgMapping', 'POST', '/v2/benefit/identity_to_benefit_pkg_mapping/create', 'none', false, 'json', request);
}

model CreateOrderRequest {
  autoPay?: boolean(name='auto_pay', position='Body'),
  autoRenew?: boolean(name='auto_renew', position='Body'),
  code: string(name='code', position='Body'),
  instanceId: string(name='instance_id', position='Body'),
  orderType: string(name='order_type', position='Body'),
  package: string(name='package', position='Body'),
  period: long(name='period', position='Body'),
  periodUnit: string(name='period_unit', position='Body'),
  totalSize: long(name='total_size', position='Body'),
  userCount: long(name='user_count', position='Body'),
}

model CreateOrderResponseBody = {
  instanceId?: string(name='instance_id'),
  orderId?: string(name='order_id'),
}

model CreateOrderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOrderResponseBody(name='body'),
}

async function createOrder(request: CreateOrderRequest): CreateOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateOrder', 'POST', '/v2/domain/create_order', 'json', false, 'json', request);
}

model CreateShareLinkRequest {
  domainId?: string(name='domain_id', position='Host'),
  creatable?: boolean(name='creatable', position='Body'),
  creatableFileIdList?: [ string ](name='creatable_file_id_list', position='Body'),
  description?: string(name='description', description='The description of the share. The description must be 0 to 1,024 characters in length.', position='Body'),
  disableDownload?: boolean(name='disable_download', description='Specifies whether to disable the download feature.', example='false', position='Body'),
  disablePreview?: boolean(name='disable_preview', description='Specifies whether to disable the preview feature.', example='false', position='Body'),
  disableSave?: boolean(name='disable_save', description='Specifies whether to disable the dump feature.', example='false', position='Body'),
  downloadLimit?: long(name='download_limit', description='The limit on the number of times that the shared files can be downloaded. The value of this parameter must be equal to or greater than 0. A value of 0 indicates no limit.', example='100', position='Body'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  expiration?: string(name='expiration', description='The time when the share URL expires. The value of this parameter follows the RFC 3339 standard. Example: "2020-06-28T11:33:00.000+08:00". If expiration is set to "", the share URL never expires.', example='2020-06-28T11:33:00.000+08:00', position='Body'),
  fileIdList?: [ string ](name='file_id_list', description='The IDs of the files to share in the parent path. The number of files in the parent path ranges from 1 to 100. If share_all_files is set to true, this parameter does not take effect. Otherwise, you must specify this parameter.``', example='["520b217f13adf4fc24f2191991b1664ce045b393"]', position='Body'),
  previewLimit?: long(name='preview_limit', description='The limit on the number of times that the shared files can be previewed. The value of this parameter must be equal to or greater than 0. A value of 0 indicates no limit.', example='100', position='Body'),
  saveLimit?: long(name='save_limit', description='The limit on the number of times that the shared files can be dumped. The value of this parameter must be equal to or greater than 0. A value of 0 indicates no limit.', example='100', position='Body'),
  shareAllFiles?: boolean(name='share_all_files', description='Specifies whether to share all files in the drive.', example='true', position='Body'),
  shareName?: string(name='share_name', description='The name of the share. If you leave this parameter empty, the file name that corresponds to the first ID in the file ID list is used. The name must be 0 to 128 characters in length.', position='Body'),
  sharePwd?: string(name='share_pwd', description='The access code. An access code must be 0 to 64 bytes in length. If you do not specify this parameter or leave this parameter empty, the files can be accessed without an access code. In this case, you do not need to specify the share_pwd parameter when you call an operation to query the share URL. The access code can contain only visible ASCII characters.', example='abcF123x', position='Body'),
  userId?: string(name='user_id', description='The user ID.', example='u123', position='Body'),
}

model CreateShareLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ShareLink  
}

/**
  * A share is a file view container. You can grant anonymous users the permissions to access files in the user drive by using the share URL. Anonymous users can access the files based on the granted permissions.
  *
 * @tags api
 */
async function createShareLink(request: CreateShareLinkRequest): CreateShareLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateShareLink', 'POST', '/v2/share_link/create', 'json', false, 'json', request);
}

model CreateSimilarImageClusterTaskRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', example='123', position='Body'),
}

model CreateSimilarImageClusterTaskResponseBody = {
  taskId?: string(name='task_id', example='i:SimilarImageClustering-b67d53e7-2fe8-460f-9b95-1e93636923eb'),
}

model CreateSimilarImageClusterTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSimilarImageClusterTaskResponseBody(name='body'),
}

async function createSimilarImageClusterTask(request: CreateSimilarImageClusterTaskRequest): CreateSimilarImageClusterTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateSimilarImageClusterTask', 'POST', '/v2/image/create_similar_image_cluster_task', 'json', false, 'json', request);
}

model CreateStoryRequest {
  domainId?: string(name='domain_id', position='Host'),
  address?: Address(name='address', position='Body'),
  customLabels?: map[string]string(name='custom_labels', deprecated='true', position='Body'),
  driveId: string(name='drive_id', example='1', position='Body'),
  maxImageCount?: long(name='max_image_count', example='30', maximum=100, position='Body'),
  minImageCount?: long(name='min_image_count', example='1', minimum=1, position='Body'),
  storyEndTime?: string(name='story_end_time', example='2022-12-30T16:00:00Z', position='Body'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003', position='Body'),
  storyName?: string(name='story_name', position='Body'),
  storyStartTime?: string(name='story_start_time', example='2016-12-30T16:00:00Z', position='Body'),
  storySubType?: string(name='story_sub_type', example='Food', position='Body'),
  storyType: string(name='story_type', example='TagMemory', position='Body'),
}

model CreateStoryResponseBody = {
  driveId?: string(name='drive_id', example='1'),
}

model CreateStoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateStoryResponseBody(name='body'),
}

async function createStory(request: CreateStoryRequest): CreateStoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateStory', 'POST', '/v2/image/create_story', 'json', false, 'json', request);
}

model CreateUserRequest {
  domainId?: string(name='domain_id', position='Host'),
  avatar?: string(name='avatar', description='The URL of the profile picture.

If you specify the parameter in the HTTP URL format, the URL must start with http:// or https:// and can be up to 4 KB in size.

If you specify the parameter in the data URL format, the URL must start with data:// and be encoded in Base64. The URL can be up to 300 KB in size.', example='http://a.b.c/pds.jpg', position='Body'),
  description?: string(name='description', description='The description of the user. The description can be up to 1,024 characters in length.', example='The VIP user', maxLength=1024, position='Body'),
  email?: string(name='email', description='The email address.', example='123@pds.com', position='Body'),
  groupInfoList?: [ 
    {
      groupId?: string(name='group_id', description='The group ID.', example='g123'),
    }
  ](name='group_info_list', description='The information about the group.', position='Body'),
  nickName?: string(name='nick_name', description='The nickname of the user. The nickname can be up to 128 characters in length.', example='pdsuer', maxLength=128, position='Body'),
  phone?: string(name='phone', description='The phone number.', example='13900001111', position='Body'),
  role?: string(name='role', description='The role of the user. Default value: user. Valid values:

*   superadmin
*   admin
*   user

If the domain can be divided into subdomains, the subdomain_super_admin and subdomain_admin roles are also supported.

Valid values:

*   subdomain_super_admin

    <!-- -->

    <!-- -->

    <!-- -->

*   subdomain_admin

    <!-- -->

    <!-- -->

    <!-- -->

*   superadmin

    <!-- -->

    <!-- -->

    <!-- -->

*   admin

    <!-- -->

    <!-- -->

    <!-- -->

*   user

    <!-- -->

    <!-- -->

    <!-- -->', example='user', position='Body'),
  status?: string(name='status', description='The state of the user. Default value: enabled. Valid values:

*   enabled: The user is in a normal state.
*   disabled: The user is prohibited from logon.', example='enabled', position='Body'),
  userData?: map[string]any(name='user_data', description='The custom data. The data can be up to 1,024 characters in length.', example='md', position='Body'),
  userId: string(name='user_id', description='The user ID. The ID can be up to 64 characters in length and cannot contain number signs (#).', example='pdsuserid1', minLength=1, maxLength=1024, position='Body'),
  userName?: string(name='user_name', description='The username. The username can be up to 128 characters in length.', example='pdsusername', maxLength=128, position='Body'),
}

model CreateUserResponseBody = {
  avatar?: string(name='avatar', description='The URL of the profile picture.', example='http://aa.com/1.jpg'),
  createdAt?: long(name='created_at', description='The time when the user was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1639762579768'),
  creator?: string(name='creator', description='The user who created the user.', example='user1'),
  defaultDriveId?: string(name='default_drive_id', description='The ID of the default drive.', example='1'),
  description?: string(name='description', description='The description of the user.', example='vipuser'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  email?: string(name='email', description='The email address.', example='a@a.com'),
  nickName?: string(name='nick_name', description='The nickname of the user.', example='001'),
  phone?: string(name='phone', description='The phone number.', example='13900001111'),
  role?: string(name='role', description='The role of the user. Valid values:

*   superadmin
*   admin
*   user', example='admin'),
  status?: string(name='status', description='The state of the user. Valid values:

*   disabled: The user is prohibited from logon.
*   enabled: The user is in a normal state.', example='enabled'),
  updatedAt?: long(name='updated_at', description='The time when the user was modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1639762579768'),
  userData?: map[string]any(name='user_data', description='The custom data.'),
  userId?: string(name='user_id', description='The user ID.', example='dingding_abc001'),
  userName?: string(name='user_name', description='The username.', example='pds'),
}

model CreateUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateUserResponseBody(name='body'),
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateUser', 'POST', '/v2/user/create', 'json', false, 'json', request);
}

model CsiGetFileInfoRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', example='1', position='Body'),
  fileId: string(name='file_id', example='9520943DC264', position='Body'),
  urlExpireSec?: int32(name='url_expire_sec', example='100', minimum=10, maximum=14400, position='Body'),
}

model CsiGetFileInfoResponseBody = {
  investigationInfo?: InvestigationInfo(name='investigation_info'),
  url?: string(name='url', example='https://data.aliyunpds.com/hz22%2F5d5b986facbec311ef844c25954f96821497b383%2F5d5b986f955410dd991646bb87c6b4e899eff525?Expires=xxx&OSSAccessKeyId=xxx&Signature=xxx'),
}

model CsiGetFileInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CsiGetFileInfoResponseBody(name='body'),
}

async function csiGetFileInfo(request: CsiGetFileInfoRequest): CsiGetFileInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CsiGetFileInfo', 'POST', '/v2/csi/get_file_info', 'json', false, 'json', request);
}

model DeleteDomainRequest {
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1', position='Body'),
}

model DeleteDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteDomain(request: DeleteDomainRequest): DeleteDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteDomain', 'POST', '/v2/domain/delete', 'none', false, 'json', request);
}

model DeleteDriveRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
}

model DeleteDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteDrive(request: DeleteDriveRequest): DeleteDriveResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteDrive', 'POST', '/v2/drive/delete', 'none', false, 'json', request);
}

model DeleteFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The file ID or folder ID.', example='9520943DC264', position='Body'),
}

model DeleteFileResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task. This parameter is returned only in asynchronous processing scenarios. You can call the [GetAsyncTask](~~440456~~) operation to query the information about the asynchronous task based on the task ID.', example='000e89fb-cf8f-11e9-8ab4-b6e980803a3b'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
}

model DeleteFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFileResponseBody(name='body'),
}

async function deleteFile(request: DeleteFileRequest): DeleteFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFile', 'POST', '/v2/file/delete', 'json', false, 'json', request);
}

model DeleteGroupRequest {
  domainId?: string(name='domain_id', position='Host'),
  groupId: string(name='group_id', description='The group ID.', example='g123', position='Body'),
}

model DeleteGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteGroup(request: DeleteGroupRequest): DeleteGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteGroup', 'POST', '/v2/group/delete', 'none', false, 'json', request);
}

model DeleteRevisionRequest {
  domainId?: string(name='domain_id', description='A short description of struct', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264', position='Body'),
  revisionId: string(name='revision_id', description='The version ID.', example='40CB7794C929', position='Body'),
}

model DeleteRevisionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteRevision(request: DeleteRevisionRequest): DeleteRevisionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteRevision', 'POST', '/v2/file/revision/delete', 'none', false, 'json', request);
}

model DeleteStoryRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', example='1', position='Body'),
  storyId: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003', position='Body'),
}

model DeleteStoryResponseBody = {
  driveId?: string(name='drive_id', example='1'),
}

model DeleteStoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteStoryResponseBody(name='body'),
}

async function deleteStory(request: DeleteStoryRequest): DeleteStoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteStory', 'POST', '/v2/image/delete_story', 'json', false, 'json', request);
}

model DeleteUserRequest {
  domainId?: string(name='domain_id', position='Host'),
  userId: string(name='user_id', description='The user ID.', example='c9b7a5aa04d14ae3867fdc886fa01da4', position='Body'),
}

model DeleteUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteUser', 'POST', '/v2/user/delete', 'none', false, 'json', request);
}

model DeltaGetLastCursorRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  syncRootId?: string(name='sync_root_id', description='The ID of the root file of the synced folder.', example='622fb09598ae66777c7040109a16f49381f6abe1', position='Body'),
}

model DeltaGetLastCursorResponseBody = {
  cursor?: string(name='cursor', description='The latest cursor of incremental information in the specified drive or synced folder.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model DeltaGetLastCursorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeltaGetLastCursorResponseBody(name='body'),
}

async function deltaGetLastCursor(request: DeltaGetLastCursorRequest): DeltaGetLastCursorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeltaGetLastCursor', 'POST', '/v2/file/get_last_cursor', 'json', false, 'json', request);
}

model DownloadFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1', position='Query'),
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264', position='Query'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', description='The method used to generate the thumbnail of an image. If this parameter is specified, you are redirected to the URL of the generated thumbnail.', example='image/resize,m_fill,h_128,w_128,limit_0', position='Query'),
  officeThumbnailProcess?: string(name='office_thumbnail_process', description='The method used to generate the thumbnail of a document. If this parameter is specified, you are redirected to the URL of the generated thumbnail.', example='image/resize,w_200', position='Query'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a share link, carry the `x-share-token` header for authentication in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify one of `share_id` and `drive_id`.', example='7JQX1FswpQ8', position='Query'),
  videoThumbnailProcess?: string(name='video_thumbnail_process', description='The method used to generate the thumbnail of a video. If this parameter is specified, you are redirected to the URL of the generated thumbnail.', example='video/snapshot,t_7000,f_jpg,w_800,h_600,m_fast', position='Query'),
}

model DownloadFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
  * For information about best practices for downloading a file.
  *
 * @tags api
 */
async function downloadFile(request: DownloadFileRequest): DownloadFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DownloadFile', 'GET', '/v2/file/download', 'none', false, 'json', request);
}

async function downloadFileWithAsyncResponseHandler(request: DownloadFileRequest, responseHandler: AsyncResponseHandler): DownloadFileResponse {
  @handler.validateRequestModel(request);
  return @handler.doResponseHandler('RESTFUL', 'DownloadFile', 'GET', '/v2/file/download', 'none', false, 'json', request, responseHandler);
}

model FileAddPermissionRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The ID of the folder. If you want to authorize a user or group to access a team drive, set this parameter to root. If you want to authorize a user or group to access an individual drive, you cannot set this parameter to root.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406', position='Body'),
  memberList: [
    FilePermissionMember
  ](name='member_list', description='The members that are authorized to access files.', position='Body'),
}

model FileAddPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function fileAddPermission(request: FileAddPermissionRequest): FileAddPermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'FileAddPermission', 'POST', '/v2/file/add_permission', 'none', false, 'json', request);
}

model FileDeleteUserTagsRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264', position='Body'),
  keyList: [ string ](name='key_list', description='The tags that you want to remove from a file. You cannot leave this parameter empty. You can specify up to 1,000 tags.', position='Body'),
}

model FileDeleteUserTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function fileDeleteUserTags(request: FileDeleteUserTagsRequest): FileDeleteUserTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'FileDeleteUserTags', 'POST', '/v2/file/delete_usertags', 'none', false, 'json', request);
}

model FileListPermissionRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId?: string(name='file_id', description='The file ID.', example='4221bf6e6ab43a255edc4463bffa6f5f5d317401', position='Body'),
}

model FileListPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [
    FilePermissionMember
  ](name='body'),
}

async function fileListPermission(request: FileListPermissionRequest): FileListPermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'FileListPermission', 'POST', '/v2/file/list_permission', 'array', false, 'json', request);
}

model FilePutUserTagsRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264', position='Body'),
  userTags: [ 
    {
      key: string(name='key', description='The name of the tag. The tag name cannot be empty and cannot contain number signs (#).', example='tag'),
      value?: string(name='value', description='The value of the tag. The tag value cannot contain number signs (#).', example='value'),
    }
  ](name='user_tags', description='The tags to be added to the file. You cannot leave this parameter empty. You can specify up to 1,000 tags. You cannot specify tags that have the same name.', position='Body'),
}

model FilePutUserTagsResponseBody = {
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264'),
}

model FilePutUserTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: FilePutUserTagsResponseBody(name='body'),
}

/**
  * This operation is an incremental update operation. Take note of the following items:
  * *   If a tag name specified in the request is the same as an existing tag name, the existing tag is overwritten.
  * *   If a tag name specified in the request is different from the existing tag names, the specified tag is added.
  * *   The existing tags with unique names are not affected.
  *
 * @tags api
 */
async function filePutUserTags(request: FilePutUserTagsRequest): FilePutUserTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'FilePutUserTags', 'POST', '/v2/file/put_usertags', 'json', false, 'json', request);
}

model FileRemovePermissionRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406', position='Body'),
  memberList: [ 
    {
      identity: Identity(name='identity', description='The identity to whom the permissions are granted, which is a user or a group.'),
      roleId: string(name='role_id', description='The role ID. You can grant permissions by assigning roles to identities, or you can customize the permissions. To grant permissions by assigning roles to identities, specify role_id. role_id and action_list are mutually exclusive. If both parameters are specified, role_id has a higher priority.

Valid values:

SystemFileOwner: collaborator.

SystemFileDownloader: downloader.

SystemFileEditor: editor.

SystemFileEditorWithoutDelete: editor without permissions to delete the file.

SystemFileEditorWithoutShareLink: editor without permissions to share the file.

SystemFileMetaViewer: viewer of lists.

SystemFileUploader: uploader. SystemFileUploaderAndDownloader: uploader and downloader.

SystemFileDownloaderWithShareLink: downloader and sharer.

SystemFileUploaderAndDownloaderWithShareLink: uploader, downloader, and sharer.

SystemFileUploaderAndViewer: viewer and uploader.

SystemFileUploaderWithShareLink: uploader and sharer.

SystemFileViewer: viewer.', example='SystemFileDownloader'),
    }
  ](name='member_list', description='The identities with whom the file is shared.', position='Body'),
}

model FileRemovePermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function fileRemovePermission(request: FileRemovePermissionRequest): FileRemovePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'FileRemovePermission', 'POST', '/v2/file/remove_permission', 'none', false, 'json', request);
}

model GetAsyncTaskRequest {
  domainId?: string(name='domain_id', position='Host'),
  asyncTaskId: string(name='async_task_id', description='The ID of the asynchronous task.', example='000e89fb-cf8f-11e9-8ab4-b6e980803a3b', position='Body'),
}

model GetAsyncTaskResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.', example='000e89fb-cf8f-11e9-8ab4-b6e980803a3b'),
  category?: string(name='category', description='The custom category of the task.', example='album'),
  consumedProcess?: long(name='consumed_process', description='The total amount of work that is done in the asynchronous task, such as the number of files that are packaged for package download on the server.', example='100'),
  createdAt?: string(name='created_at', description='The time when the task was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. Example: 2019-03-28T13:03:29.298Z.', example='2019-08-20T06:51:27.292Z'),
  errCode?: long(name='err_code', description='<warning>This parameter is no longer used. We recommend that you use error_code instead.</warning>

The error code returned if the asynchronous task failed.', example='InternalError'),
  errorCode?: string(name='error_code', description='The error code returned if the asynchronous task failed.', example='InternalError'),
  errorMessage?: string(name='error_message', description='The error message returned if the asynchronous task failed.', example='The request has been failed due to some unknown error. Please try again later.'),
  failedProcess?: long(name='failed_process'),
  finishedAt?: string(name='finished_at', description='The time when the task was complete. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. Example: 2019-03-28T13:03:29.298Z.', example='2019-08-20T06:51:27.292Z'),
  message?: string(name='message', description='<warning>This parameter is no longer used. We recommend that you use error_message instead.</warning>

The error message returned if the asynchronous task failed.', example='The request has been failed due to some unknown error. Please try again later.'),
  skippedProcess?: long(name='skipped_process'),
  startedAt?: string(name='started_at', description='The time when the task was started. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. Example: 2019-03-28T13:03:29.298Z.', example='2019-08-20T06:51:27.292Z'),
  state?: string(name='state', description='The state of the task. Valid values:

*   Failed
*   Running
*   PartialSucceed
*   Succeed', example='Succeed'),
  status?: string(name='status', description='<warning>This parameter is no longer used. We recommend that you use state instead.</warning>

The state of the task. Valid values:

*   Failed
*   Running
*   PartialSucceed
*   Succeed', example='Succeed'),
  totalProcess?: long(name='total_process', description='The total amount of work to be done in the asynchronous task, such as the number of files to be packaged for package download on the server.', example='1000'),
  uncompressFileList?: [
    UncompressedFileInfo
  ](name='uncompress_file_list', description='The extracted files.'),
  url?: string(name='url', description='The download URL of the data generated by the asynchronous task, such as the download URL of the packaged files generated by the task of package download on the server.', example='https://data.aliyunpds.com/hz22%2F5d5b986facbec311ef844c25954f96821497b383%2F5d5b986f955410dd991646bb87c6b4e899eff525?Expires=xxx&OSSAccessKeyId=xxx&Signature=xxx'),
}

model GetAsyncTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAsyncTaskResponseBody(name='body'),
}

async function getAsyncTask(request: GetAsyncTaskRequest): GetAsyncTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetAsyncTask', 'POST', '/v2/async_task/get', 'json', false, 'json', request);
}

model GetDefaultDriveRequest {
  domainId?: string(name='domain_id', position='Host'),
  userId?: string(name='user_id', description='The user ID. If you use an AccessKey pair for authentication, you must specify this parameter. If you use an access token for authentication, this parameter is optional. By default, the user ID associated with the access token is used.', example='c9b7a5aa04d14ae3867fdc886fa01da4', position='Body'),
}

model GetDefaultDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Drive  
}

async function getDefaultDrive(request: GetDefaultDriveRequest): GetDefaultDriveResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetDefaultDrive', 'POST', '/v2/drive/get_default_drive', 'json', false, 'json', request);
}

model GetDomainRequest {
  domainId: string(name='domain_id', description='The ID of the domain.', example='bj1', position='Body'),
  fields?: string(name='fields', position='Body'),
  getQuotaUsed?: boolean(name='get_quota_used', description='Specifies whether to return the used quota of the domain. Default value: false. If the quota of the domain is greater than 0 and you set this parameter to true, the used quota of the domain is returned.', example='true', position='Body'),
}

model GetDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Domain  
}

async function getDomain(request: GetDomainRequest): GetDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetDomain', 'POST', '/v2/domain/get', 'json', false, 'json', request);
}

model GetDomainQuotaRequest {
}

model GetDomainQuotaResponseBody = {
  sizeQuota?: long(name='size_quota'),
  sizeUsed?: long(name='size_used'),
  userCountQuota?: long(name='user_count_quota'),
  userCountUsed?: long(name='user_count_used'),
}

model GetDomainQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDomainQuotaResponseBody(name='body'),
}

async function getDomainQuota(request: GetDomainQuotaRequest): GetDomainQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetDomainQuota', 'POST', '/v2/domain/get_quota', 'json', false, 'json', request);
}

model GetDownloadUrlRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  expireSec?: int32(name='expire_sec', description='The validity period of the download URL. Maximum value: 115200. Default value: 900. Unit: seconds.', example='100', minimum=1, maximum=115200, position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264', position='Body'),
  fileName?: string(name='file_name', description='The name of the file. The name can be up to 1,024 characters in length.', example='1.txt', minLength=1, maxLength=1024, position='Body'),
  responseContentType?: string(name='response_content_type', example='video/mp4', position='Body'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a sharing link, carry the `x-share-token` header in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify at least either `share_id` or `drive_id`.', example='7JQX1FswpQ8', position='Body'),
}

model GetDownloadUrlResponseBody = {
  cdnUrl?: string(name='cdn_url', description='The download URL of a file that is downloaded by using Alibaba Cloud CDN.', example='https://data-cdn.aliyunpds.com/hz22%2F5d79219b0aa9a7c995a94a96993ba3205cd91c5a%2F5d79219bf3261a5d38744da0834ed489b677a27a?Expires=xxxOSSAccessKeyId=xxx&Signature=xxx&response-content-disposition=attachment%3Bfilename%3DtBiZAoJPC2c8b13450eda4292b7f5f8010618e078.txt'),
  contentHash?: string(name='content_hash', description='The hash value of the file content.', example='EA4942AA8761213890A5C386F88E6464D2C31CA1'),
  contentHashName?: string(name='content_hash_name', description='The name of the algorithm that is used to calculate the hash value of the file content.', example='sha1'),
  crc64Hash?: string(name='crc64_hash', description='The hash value calculated by using 64-bit cyclic redundancy check (CRC-64).', example='5498595269368962671'),
  expiration?: string(name='expiration', description='The time when the download URL expires.', example='2022-01-02T15:04:05.999Z07:00'),
  internalUrl?: string(name='internal_url', description='The download URL of a file that is downloaded over a virtual private cloud (VPC).', example='https://data-vpc.aliyunpds.com/hz22%2F5d79219b0aa9a7c995a94a96993ba3205cd91c5a%2F5d79219bf3261a5d38744da0834ed489b677a27a?Expires=xxxOSSAccessKeyId=xxx&Signature=xxx&response-content-disposition=attachment%3Bfilename%3DtBiZAoJPC2c8b13450eda4292b7f5f8010618e078.txt'),
  size?: long(name='size', description='The size of the file. Unit: bytes.', example='10'),
  url?: string(name='url', description='The download URL of a file that is downloaded over the Internet.', example='https://data.aliyunpds.com/hz22%2F5d79219b0aa9a7c995a94a96993ba3205cd91c5a%2F5d79219bf3261a5d38744da0834ed489b677a27a?Expires=xxxOSSAccessKeyId=xxx&Signature=xxx&response-content-disposition=attachment%3Bfilename%3DtBiZAoJPC2c8b13450eda4292b7f5f8010618e078.txt'),
}

model GetDownloadUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDownloadUrlResponseBody(name='body'),
}

async function getDownloadUrl(request: GetDownloadUrlRequest): GetDownloadUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetDownloadUrl', 'POST', '/v2/file/get_download_url', 'json', false, 'json', request);
}

model GetDriveRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
}

model GetDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Drive  
}

async function getDrive(request: GetDriveRequest): GetDriveResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetDrive', 'POST', '/v2/drive/get', 'json', false, 'json', request);
}

model GetFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fields?: string(name='fields', description='The fields to return.

1.  If this parameter is set to \\*, all fields of the file except the fields that must be specified are returned.
2.  If only specific fields are required, you can specify the following fields: url, thumbnail, exif, cropping_suggestion, characteristic_hash, video_metadata, and video_preview_metadata. If multiple fields are required, separate them with commas (,). Example: url,thumbnail.
3.  The investigation_info field is returned only if you specify this field.

By default, all fields except the fields that must be specified are returned.', example='*', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264', position='Body'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a share link, carry the `x-share-token` header for authentication in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify one of `share_id` and `drive_id`.', example='7JQX1FswpQ8', position='Body'),
  thumbnailProcesses?: map[string]ImageProcess(name='thumbnail_processes', description='缩略图配置，可一次性返回最多5个缩略图，map的key可以自定义，返回时按key返回对应的缩略图链接', position='Body'),
  urlExpireSec?: int32(name='url_expire_sec', description='The time when the file expires. Unit: seconds. Valid values: 10 to 14400.', example='100', minimum=10, maximum=14400, position='Body'),
}

model GetFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: File  
}

async function getFile(request: GetFileRequest): GetFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFile', 'POST', '/v2/file/get', 'json', false, 'json', request);
}

model GetGroupRequest {
  domainId?: string(name='domain_id', position='Host'),
  groupId: string(name='group_id', description='The group ID.', example='2e43ec8427dd45f19431b7504649a1b1', position='Body'),
}

model GetGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Group  
}

async function getGroup(request: GetGroupRequest): GetGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetGroup', 'POST', '/v2/group/get', 'json', false, 'json', request);
}

model GetIdentityToBenefitPkgMappingRequest {
  domainId?: string(name='domain_id', position='Host'),
  benefitPkgId: string(name='benefit_pkg_id', description='The unique identifier of the benefit package.', example='40cb7794c9294', position='Body'),
  identityId: string(name='identity_id', description='The unique identifier of the entity.

If you want to manage the benefits of a user, set this parameter to a user ID.', example='user123', position='Body'),
  identityType: string(name='identity_type', description='The type of the entity. If you want to manage the benefits of a user, set this parameter to user.', example='user', position='Body'),
}

model GetIdentityToBenefitPkgMappingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: IdentityToBenefitPkgMapping  
}

async function getIdentityToBenefitPkgMapping(request: GetIdentityToBenefitPkgMappingRequest): GetIdentityToBenefitPkgMappingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetIdentityToBenefitPkgMapping', 'POST', '/v2/benefit/identity_to_benefit_pkg_mapping/get', 'json', false, 'json', request);
}

model GetLinkInfoRequest {
  domainId?: string(name='domain_id', position='Host'),
  extra?: string(name='extra', position='Body'),
  identity: string(name='identity', example='130***', position='Body'),
  type: string(name='type', example='mobile', position='Body'),
}

model GetLinkInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AccountLinkInfo  
}

async function getLinkInfo(request: GetLinkInfoRequest): GetLinkInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLinkInfo', 'POST', '/v2/account/get_link_info', 'json', false, 'json', request);
}

model GetLinkInfoByUserIdRequest {
  domainId?: string(name='domain_id', position='Host'),
  userId?: string(name='user_id', description='The user ID.', example='xxx', position='Body'),
}

model GetLinkInfoByUserIdResponseBody = {
  items?: [
    AccountLinkInfo
  ](name='items', description='The information about the users.'),
}

model GetLinkInfoByUserIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLinkInfoByUserIdResponseBody(name='body'),
}

async function getLinkInfoByUserId(request: GetLinkInfoByUserIdRequest): GetLinkInfoByUserIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLinkInfoByUserId', 'POST', '/v2/account/get_link_info_by_user_id', 'json', false, 'json', request);
}

model GetRevisionRequest {
  domainId?: string(name='domain_id', description='A short description of struct', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fields?: string(name='fields', description='Specifies the returned fields.

By default, this parameter is left empty. If you set this parameter to \\*, all fields are returned. If you leave this parameter empty, the creator of the file is not returned.', example='*', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264', position='Body'),
  revisionId: string(name='revision_id', description='The version ID.', example='40CB7794C929', position='Body'),
  urlExpireSec?: long(name='url_expire_sec', description='The validity period of the file download or preview. Valid values: 10 to 86400.

Default value: 900. Unit: seconds.', example='900', position='Body'),
}

model GetRevisionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Revision  
}

async function getRevision(request: GetRevisionRequest): GetRevisionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetRevision', 'POST', '/v2/file/revision/get', 'json', false, 'json', request);
}

model GetShareLinkRequest {
  domainId?: string(name='domain_id', position='Host'),
  shareId: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8', position='Body'),
}

model GetShareLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ShareLink  
}

async function getShareLink(request: GetShareLinkRequest): GetShareLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetShareLink', 'POST', '/v2/share_link/get', 'json', false, 'json', request);
}

model GetShareLinkByAnonymousRequest {
  domainId?: string(name='domain_id', position='Host'),
  shareId: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8', position='Body'),
}

model GetShareLinkByAnonymousResponseBody = {
  accessCount?: long(name='access_count', description='The number of times that the shared files are visited.', example='30'),
  avatar?: string(name='avatar', description='The profile picture of the user who created the share link.', example='https://aliyunpds.com/a.jpg'),
  creatorId?: string(name='creator_id', description='The ID of the user who created the share link.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
  creatorName?: string(name='creator_name', description='The name of the user who created the share link. The value is masked.', example='AB***CD'),
  creatorPhone?: string(name='creator_phone', description='The mobile number of the user who created the share link. The value is masked.', example='136****00'),
  disableDownload?: boolean(name='disable_download', description='Indicates whether the downloads of the shared files are prohibited.', example='false'),
  disablePreview?: boolean(name='disable_preview', description='Indicates whether the previews of the shared files are prohibited.', example='false'),
  disableSave?: boolean(name='disable_save', description='Indicates whether the saves of the shared files are prohibited.', example='false'),
  downloadCount?: long(name='download_count', description='The number of times that the shared files are downloaded.', example='50'),
  downloadLimit?: long(name='download_limit', description='The maximum number of times that the shared files can be downloaded.', example='100'),
  expiration?: string(name='expiration', description='The time when the share link expires.', example='2020-08-20T06:51:27.292Z'),
  previewCount?: long(name='preview_count', description='The number of times that the shared files are previewed.', example='80'),
  previewLimit?: long(name='preview_limit', description='The maximum number of times that the shared files can be previewed.', example='100'),
  reportCount?: long(name='report_count', description='The number of times that the shared files are reported.', example='0'),
  saveCount?: long(name='save_count', description='The number of times that the shared files are saved.', example='2'),
  saveDownloadLimit?: long(name='save_download_limit', description='The maximum number of times that the shared files can be saved and downloaded.', example='200'),
  saveLimit?: long(name='save_limit', description='The maximum number of times that the shared files can be saved.', example='100'),
  shareName?: string(name='share_name', description='The name of the share link.'),
  updatedAt?: string(name='updated_at', description='The time when the share link was last modified.', example='2019-08-20T06:51:27.292Z'),
  videoPreviewCount?: long(name='video_preview_count', description='The number of times that the videos are previewed in the shared files.', example='5'),
}

model GetShareLinkByAnonymousResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetShareLinkByAnonymousResponseBody(name='body'),
}

async function getShareLinkByAnonymous(request: GetShareLinkByAnonymousRequest): GetShareLinkByAnonymousResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetShareLinkByAnonymous', 'POST', '/v2/share_link/get_by_anonymous', 'json', false, 'json', request);
}

model GetShareLinkTokenRequest {
  domainId?: string(name='domain_id', position='Host'),
  expireSec?: int32(name='expire_sec', description='The validity period of the token. Valid values: (0,7200]. Default value: 7200. Unit: seconds.', example='7200', position='Body'),
  shareId: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8', position='Body'),
  sharePwd?: string(name='share_pwd', description='The access code.', example='abcF123x', position='Body'),
}

model GetShareLinkTokenResponseBody = {
  expiresIn?: long(name='expires_in', description='The validity period of the token. Unit: seconds. For example, a value of 7200 indicates two hours.', example='7200'),
  shareToken?: string(name='share_token', description='The JSON Web Token (JWT).', example='eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJjOWI3YTVhYTA0ZDE0YWUzODY3ZmRjODg2ZmEwMWRhNCIsImN1c3RvbUpzb24iOiJ7XCJjbGllbnRJZFwiOlwiMjVkelgzdmJZcWt0Vnh5WFwiLFwiZG9tYWluSWRcIjpcImJqMjlcIixcInNjb3BlXCI6W1wiRFJJVkUuQUxMXCIsXCJTSEFSRS5BTExcIixcIkZJTEUuQUxMXCIsXCJVU0VSLkFMTFwiLFwiVklFVy5BTExcIixcIlNUT1JBR0UuQUxMXCIsXCJTVE9SQUdFRklMRS5MSVNUXCIsXCJCQVRDSFwiLFwiT0FVVEguQUxMXCIsXCJJTUFHRS5BTExcIixcIklOVklURS5BTExcIixcIkFDQ09VTlQuQUxMXCJdLFwicm9sZVwiOlwidXNlclwiLFwicmVmXCI6XCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vXCIsXCJkZXZpY2VfaWRcIjpcImIyODIwNWU1YzU5NzRjY2JiODI3MDNiNjhkYjhjNDUxXCJ9IiwiZXhwIjoxNjQ4NjE0NDkzLCJpYXQiOjE2NDg2MDcyMzN9.d3HVLvv_LFw2QhPrhvjH_kICWQJX9sKKt7NjQEqI_xE2JO_b7D8rPsFTZz93PLvZ7MhCmudTjGImUpd-ehFnI4Go-1S7BGaKaHFILvP-sWy18Wpikowjxx9mSbzBM_cO6D1LI-kyYhXKWHgVdADfVIPniTDA7-ffhUpi7cAebEs'),
}

model GetShareLinkTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetShareLinkTokenResponseBody(name='body'),
}

/**
  * To access a file by using a share link, you must first obtain a share token, even if the value of share_pwd of this share is an empty string, which specifies that the share is not private.
  *
 * @tags api
 */
async function getShareLinkToken(request: GetShareLinkTokenRequest): GetShareLinkTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetShareLinkToken', 'POST', '/v2/share_link/get_share_token', 'json', false, 'json', request);
}

model GetStoryRequest {
  domainId?: string(name='domain_id', position='Host'),
  coverImageThumbnailProcess?: string(name='cover_image_thumbnail_process', example='image/resize,m_fill,h_128,w_128,limit_0/format,jpg', deprecated='true', position='Body'),
  coverVideoThumbnailProcess?: string(name='cover_video_thumbnail_process', example='video/snapshot,t_1000,f_jpg,w_0,h_0,m_fast,ar_auto', deprecated='true', position='Body'),
  driveId: string(name='drive_id', example='1', position='Body'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', example='image/resize,m_fill,h_128,w_128,limit_0/format,jpg', deprecated='true', position='Body'),
  imageUrlProcess?: string(name='image_url_process', example='image/resize,m_fill,h_128,w_128,limit_0/format,jpg', deprecated='true', position='Body'),
  storyId: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003', position='Body'),
  urlExpireSec?: long(name='url_expire_sec', example='900', deprecated='true', minimum=10, maximum=86400, position='Body'),
  videoThumbnailProcess?: string(name='video_thumbnail_process', example='video/snapshot,t_1000,f_jpg,w_0,h_0,m_fast,ar_auto', deprecated='true', position='Body'),
}

model GetStoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Story  
}

async function getStory(request: GetStoryRequest): GetStoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetStory', 'POST', '/v2/image/get_story', 'json', false, 'json', request);
}

model GetTaskStatusRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  taskId: string(name='task_id', description='The ID of the task.', example='i:SimilarImageClustering-b67d53e7-2fe8-460f-9b95-1e93636923eb', position='Body'),
}

model GetTaskStatusResponseBody = {
  status?: string(name='status', description='The state of the task.

Valid values:

*   running

    <!-- -->

    : The task is

    <!-- -->

    running

    <!-- -->

    .

*   failed

    <!-- -->

    : The task

    <!-- -->

    fails

    <!-- -->

    .

*   succeeded

    <!-- -->

    : The task is

    <!-- -->

    successful

    <!-- -->

    .', example='running'),
}

model GetTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTaskStatusResponseBody(name='body'),
}

/**
  * **Before you call this operation, make sure that you are familiar with the [billing](~~425220~~) of Drive and Photo Service**.
  * To call this operation, make sure that the value-added image processing feature is enabled.
  * Before you call this operation, a value-added asynchronous task must be created. For example, you can call the CreateSimilarImageClusterTask operation to create an asynchronous task. Then, you can call this operation to query the execution status of the asynchronous task based on the task ID.
  *
 * @tags api
 */
async function getTaskStatus(request: GetTaskStatusRequest): GetTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTaskStatus', 'POST', '/v2/image/get_task_status', 'json', false, 'json', request);
}

model GetUploadUrlRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='5d5b846942cf94fa72324c14a4bda34e81da635d', position='Body'),
  partInfoList: [ 
    {
      contentMd5?: string(name='content_md5'),
      contentType?: string(name='content_type'),
      parallelSha1Ctx?: {
        h?: [ long ](name='h', description='The first to fifth 32-bit variables of the SHA-1 hash value of the file content before the file part. This parameter takes effect only if the parallel upload feature is enabled.'),
        partOffset?: long(name='part_offset', description='The size of the file part. Unit: bytes. The value must be a multiple of 64. This parameter takes effect only if the parallel upload feature is enabled.', example='10240'),
      }(name='parallel_sha1_ctx', description='The SHA-1 hash value of the file content before the file part. This parameter takes effect only if the parallel upload feature is enabled.'),
      parallelSha256Ctx?: {
        h?: [ long ](name='h'),
        partOffset?: long(name='part_offset'),
      }(name='parallel_sha256_ctx'),
      partNumber?: int32(name='part_number', description='The serial number of a part.', example='1'),
    }
  ](name='part_info_list', description='The information about the file parts.', position='Body'),
  shareId?: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8', position='Body'),
  uploadId: string(name='upload_id', description='The ID of the upload task.', example='10166D06127B413BA1EC8ABB1144D111', position='Body'),
}

model GetUploadUrlResponseBody = {
  createAt?: string(name='create_at', description='The time when the upload task was created.', example='2019-09-11T16:34:36.977Z'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='5d5b846942cf94fa72324c14a4bda34e81da635d'),
  partInfoList?: [
    UploadPartInfo
  ](name='part_info_list', description='The information about the file parts.'),
  uploadId?: string(name='upload_id', description='The ID of the upload task.', example='10166D06127B413BA1EC8ABB1144D111'),
}

model GetUploadUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUploadUrlResponseBody(name='body'),
}

async function getUploadUrl(request: GetUploadUrlRequest): GetUploadUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetUploadUrl', 'POST', '/v2/file/get_upload_url', 'json', false, 'json', request);
}

model GetUserRequest {
  domainId?: string(name='domain_id', position='Host'),
  userId?: string(name='user_id', description='The user ID. If you use an AccessKey pair to access Drive and Photo Service, you must specify this parameter. If you use an access token to access Drive and Photo Service, you do not need to specify this parameter, and Drive and Photo Service automatically finds the user ID contained in the access token.', example='c9b7a5aa04d14ae3867fdc886fa01da4', position='Body'),
}

model GetUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: User  
}

async function getUser(request: GetUserRequest): GetUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetUser', 'POST', '/v2/user/get', 'json', false, 'json', request);
}

model GetVideoPreviewPlayInfoRequest {
  domainId?: string(name='domain_id', position='Host'),
  category: string(name='category', description='The preview type. You must enable the corresponding video transcoding feature. Valid values:

*   live_transcoding: previews a live stream while transcoding is in progress.
*   quick_video: previews a video while transcoding is in progress.
*   offline_audio: previews a piece of audio after the audio is transcoded offline.
*   offline_video: previews a video after the video is transcoded offline.', example='live_transcoding', position='Body'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264', position='Body'),
  getMasterUrl?: boolean(name='get_master_url', position='Body'),
  getWithoutUrl?: boolean(name='get_without_url', description='Specifies whether not to query the playback URL. If you set this parameter to true, only transcoding metadata is returned. The video is not transcoded in the TS format, and the playback URL is not returned. If you set this parameter to false, the playback URL is returned. If the video has not been transcoded by using the template specified by template_id, the transcoding process is triggered. You are charged for the value-added service fees generated for transcoding.', example='true', position='Body'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a sharing link, carry the `x-share-token` header in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify at least either `share_id` or `drive_id`.', example='7JQX1FswpQ8', position='Body'),
  templateId?: string(name='template_id', description='The ID of the definition template. If you leave this parameter empty, all definition templates are available.', example='264_480p', position='Body'),
  urlExpireSec?: long(name='url_expire_sec', description='The validity period of the video preview. Unit: seconds. Default value: 900. Maximum value: 14400.', example='3600', position='Body'),
}

model GetVideoPreviewPlayInfoResponseBody = {
  code?: string(name='code', example='VideoPreviewWaitAndRetry'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='fileid1'),
  masterUrl?: string(name='master_url'),
  message?: string(name='message', example='media is transcoding, please wait and retry.'),
  shareId?: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8'),
  videoPreviewPlayInfo?: VideoPreviewPlayInfo(name='video_preview_play_info', description='The information about video playback.'),
}

model GetVideoPreviewPlayInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetVideoPreviewPlayInfoResponseBody(name='body'),
}

/**
  * For more information about best practices, see [Preview videos online](~~427477~~).
  *
 * @tags api
 */
async function getVideoPreviewPlayInfo(request: GetVideoPreviewPlayInfoRequest): GetVideoPreviewPlayInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetVideoPreviewPlayInfo', 'POST', '/v2/file/get_video_preview_play_info', 'json', false, 'json', request);
}

model GetVideoPreviewPlayMetaRequest {
  domainId?: string(name='domain_id', position='Host'),
  category: string(name='category', description='The preview type. You must enable the corresponding video transcoding feature. Valid values:

*   live_transcoding: previews a live stream while transcoding is in progress.
*   quick_video: previews a video while transcoding is in progress.
*   offline_audio: previews a piece of audio after the audio is transcoded offline.
*   offline_video: previews a video after the video is transcoded offline.', example='live_transcoding', position='Body'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264', position='Body'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a sharing link, carry the `x-share-token` header in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify at least either `share_id` or `drive_id`.', example='7JQX1FswpQ8', position='Body'),
}

model GetVideoPreviewPlayMetaResponseBody = {
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='fileid1'),
  shareId?: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8'),
  videoPreviewPlayMeta?: VideoPreviewPlayMeta(name='video_preview_play_meta', description='The preview metadata of the video.'),
}

model GetVideoPreviewPlayMetaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetVideoPreviewPlayMetaResponseBody(name='body'),
}

/**
  * For more information about best practices, see [Preview videos online](~~427477~~).
  *
 * @tags api
 */
async function getVideoPreviewPlayMeta(request: GetVideoPreviewPlayMetaRequest): GetVideoPreviewPlayMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetVideoPreviewPlayMeta', 'POST', '/v2/file/get_video_preview_play_meta', 'json', false, 'json', request);
}

model GroupUpdateNameRequest {
  domainId?: string(name='domain_id', position='Host'),
  groupId: string(name='group_id', position='Body'),
  name?: string(name='name', position='Body'),
}

model GroupUpdateNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function groupUpdateName(request: GroupUpdateNameRequest): GroupUpdateNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GroupUpdateName', 'POST', '/v2/group/update_name', 'none', false, 'json', request);
}

model ImportUserRequest {
  domainId?: string(name='domain_id', position='Host'),
  authenticationDisplayName?: string(name='authentication_display_name', description='The display name of the authentication type.', example='10000', position='Body'),
  authenticationType: string(name='authentication_type', description='The authentication type. Valid values:

*   mobile: mobile number.
*   email: email address.
*   ding: DingTalk account.
*   ram: Alibaba Cloud Resource Access Management (RAM) user.
*   wechat: WeCom account.
*   ldap: Lightweight Directory Access Protocol (LDAP) account.
*   custom: custom account.', example='mobile', position='Body'),
  autoCreateDrive?: boolean(name='auto_create_drive', description='Specifies whether to automatically create a drive.', example='false', position='Body'),
  driveTotalSize?: long(name='drive_total_size', description='The size of the drive. The value cannot be smaller than -1. A value of -1 specifies that the size is unlimited.', example='10240', position='Body'),
  extra?: string(name='extra', description='The additional information.

If authentication_type is set to mobile, set this parameter to a country code. If you do not specify this parameter, 86 is used by default.', example='1', position='Body'),
  identity: string(name='identity', description='The unique identifier.', example='130****', position='Body'),
  nickName: string(name='nick_name', description='The nickname of the user.', example='pdsuer', position='Body'),
  parentGroupId?: string(name='parent_group_id', description='The ID of the group to which the user is added.', example='g12', position='Body'),
}

model ImportUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: User  
}

async function importUser(request: ImportUserRequest): ImportUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ImportUser', 'POST', '/v2/user/import', 'json', false, 'json', request);
}

model InvestigateFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveFileIds: [ 
    {
      driveId: string(name='drive_id', example='1'),
      fileId: string(name='file_id', example='9520943DC264'),
    }
  ](name='drive_file_ids', position='Body'),
  policy?: {
    firstProductName?: string(name='first_product_name'),
    mteeCode?: string(name='mtee_code'),
    provider?: string(name='provider'),
  }(name='policy', position='Body'),
  recursive?: boolean(name='recursive', position='Body'),
  userData?: string(name='user_data', position='Body'),
}

model InvestigateFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function investigateFile(request: InvestigateFileRequest): InvestigateFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InvestigateFile', 'POST', '/v2/csi/investigate_file', 'none', false, 'json', request);
}

model LinkAccountRequest {
  domainId?: string(name='domain_id', position='Host'),
  extra?: string(name='extra', description='The additional information about the unique identifier of the account. For example, if type is set to mobile, set the value of extra to a country code. For example, a value of 86 specifies a mobile number in the Chinese mainland. If you do not specify this parameter, 86 is used by default.', example='86', position='Body'),
  identity: string(name='identity', description='The unique identifier of the account, such as a mobile number.', example='eyy***', position='Body'),
  type: string(name='type', description='The account type. Valid values:

*   mobile: a mobile number.
*   email: an email address.
*   ding: a DingTalk account.
*   ram: an Alibaba Cloud Resource Access Management (RAM) user.
*   wechat: a WeCom account.
*   ldap: a Lightweight Directory Access Protocol (LDAP) account.
*   custom: a custom account.', example='ding', position='Body'),
  userId: string(name='user_id', description='The ID of the user with which you want to associate an account.', example='xxx', position='Body'),
}

model LinkAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Token  
}

async function linkAccount(request: LinkAccountRequest): LinkAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'LinkAccount', 'POST', '/v2/account/link', 'json', false, 'json', request);
}

model ListAddressGroupsRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', description='The method that is used to generate a thumbnail of an image.', example='image/resize,w_200', position='Body'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100', position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
  videoThumbnailProcess?: string(name='video_thumbnail_process', description='The method that is used to generate a thumbnail of a video.', example='video_thumbnail_process', position='Body'),
}

model ListAddressGroupsResponseBody = {
  items?: [
    AddressGroup
  ](name='items', description='The information about the location-based groups.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListAddressGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAddressGroupsResponseBody(name='body'),
}

async function listAddressGroups(request: ListAddressGroupsRequest): ListAddressGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAddressGroups', 'POST', '/v2/image/list_address_groups', 'json', false, 'json', request);
}

model ListAssignmentRequest {
  domainId?: string(name='domain_id', description='A short description of struct', position='Host'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.

The number of returned results must be less than or equal to the specified number.', example='50', position='Body'),
  manageResourceId?: string(name='manage_resource_id', description='The ID of the managed resource, such as a group ID.', example='105***b82', position='Body'),
  manageResourceType?: string(name='manage_resource_type', description='The type of the managed resource. Set the value to RT_Group, which specifies that the administrators of a group are queried.', example='RT_Group', position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
}

model ListAssignmentResponseBody = {
  assignmentList?: [ 
    {
      createdAt?: long(name='created_at', description='The time when the role was assigned. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1622682267564'),
      creator?: string(name='creator', description='The ID of the user who assigned the role.', example='216***c83'),
      domainId?: string(name='domain_id', description='The domain ID.', example='hz1'),
      identity?: Identity(name='identity', description='The identity to whom the role is assigned, which is a user or a group.'),
      manageResourceId?: string(name='manage_resource_id', description='The ID of the managed resource, such as a group ID.', example='105***b82'),
      manageResourceType?: string(name='manage_resource_type', description='The type of the managed resource. For example, a value of RT_Group indicates group.', example='RT_Group'),
      roleId?: string(name='role_id', description='The ID of the role assigned to the identity.', example='SystemGroupAdmin'),
    }
  ](name='assignment_list', description='The assigned roles.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListAssignmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAssignmentResponseBody(name='body'),
}

async function listAssignment(request: ListAssignmentRequest): ListAssignmentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAssignment', 'POST', '/v2/role/list_assignment', 'json', false, 'json', request);
}

model ListDeltaRequest {
  domainId?: string(name='domain_id', position='Host'),
  cursor?: string(name='cursor', description='The cursor of the incremental information.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 0 to 100. Default value: 100.

The number of returned results must be less than or equal to the specified number.', example='50', position='Body'),
  syncRootId?: string(name='sync_root_id', description='The ID of the root file of the synced folder.', example='622fb09598ae66777c7040109a16f49381f6abe1', position='Body'),
}

model ListDeltaResponseBody = {
  cursor?: string(name='cursor', description='The cursor of the incremental information.', example='1WQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  hasMore?: boolean(name='has_more', description='Indicates whether more information is returned.', example='true'),
  items?: [ 
    {
      file?: File(name='file', description='The information about the file.'),
      fileId?: string(name='file_id', description='The file ID.', example='122fb09598ae66777c7040109a16f49381f6abe2'),
      op?: string(name='op', description='The operation that is performed. Valid values: Valid values:

*   create
*   overwrite
*   delete
*   update
*   move
*   trash
*   restore
*   rename', example='create'),
    }
  ](name='items', description='The incremental information returned.'),
}

model ListDeltaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDeltaResponseBody(name='body'),
}

async function listDelta(request: ListDeltaRequest): ListDeltaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDelta', 'POST', '/v2/file/list_delta', 'json', false, 'json', request);
}

model ListDomainsRequest {
  limit?: long(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 50.', example='60', position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
  parentDomainId?: string(name='parent_domain_id', description='The ID of the parent domain.', example='bj1', position='Body'),
  serviceCode?: string(name='service_code', position='Body'),
}

model ListDomainsResponseBody = {
  items?: [
    Domain
  ](name='items', description='The information about the domains.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDomainsResponseBody(name='body'),
}

async function listDomains(request: ListDomainsRequest): ListDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDomains', 'POST', '/v2/domain/list', 'json', false, 'json', request);
}

model ListDriveRequest {
  domainId?: string(name='domain_id', position='Host'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100', minimum=0, maximum=100, position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
  owner?: string(name='owner', description='The owner of the drive. If this parameter is not specified, all drives are returned.', example='c9b7a5aa04d14ae3867fdc886fa01da4', position='Body'),
  ownerType?: string(name='owner_type', description='The type of the owner. Valid values:

user and group.

By default, drives of all owner types are returned.', example='user', position='Body'),
}

model ListDriveResponseBody = {
  items?: [
    Drive
  ](name='items', description='The queried drives.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDriveResponseBody(name='body'),
}

async function listDrive(request: ListDriveRequest): ListDriveResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDrive', 'POST', '/v2/drive/list', 'json', false, 'json', request);
}

model ListFacegroupsRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100', position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
  remarks?: string(name='remarks', description='The filter condition that is used to query groups. The value can be up to 128 characters in length. An exact match is used.', minLength=1, maxLength=128, position='Body'),
  returnTotalCount?: boolean(name='return_total_count', position='Body'),
}

model ListFacegroupsResponseBody = {
  items?: [
    FaceGroup
  ](name='items', description='The information about the face-based groups.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  totalCount?: long(name='total_count'),
}

model ListFacegroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFacegroupsResponseBody(name='body'),
}

async function listFacegroups(request: ListFacegroupsRequest): ListFacegroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFacegroups', 'POST', '/v2/image/list_facegroups', 'json', false, 'json', request);
}

model ListFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  category?: string(name='category', description='The category of the file. Valid values:

app: installation package. zip: compressed package. image: image. doc: document. video: video. audio: audio. others: other files.

By default, files of all categories are returned.', example='image', position='Body'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fields?: string(name='fields', description='The fields to return.

1.  If this parameter is set to \\*, all fields of the file except the fields that must be specified are returned.
2.  If only specific fields are required, you can specify the following fields: url, exif, cropping_suggestion, characteristic_hash, video_metadata, and video_preview_metadata. If multiple fields are required, separate them with commas (,). Example: url,exif.
3.  The investigation_info field is returned only if you specify this field.

By default, all fields except the fields that must be specified are returned.', example='*', position='Body'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.

The number of returned results must be less than or equal to the specified number.', example='50', position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
  orderBy?: string(name='order_by', description='The sorting field.

Default value: created_at.

Valid values:

*   updated_at

    <!-- -->

    :

    <!-- -->

    sorts the results based on the time when the file was last modified

    <!-- -->

    .

*   size

    <!-- -->

    :

    <!-- -->

    sorts the results based on the size of the file

    <!-- -->

    .

*   name

    <!-- -->

    :

    <!-- -->

    sorts the results based on the name of the file

    <!-- -->

    .

*   created_at

    <!-- -->

    :

    <!-- -->

    sorts the results based on the time when the file was created

    <!-- -->

    .', example='updated_at', position='Body'),
  orderDirection?: string(name='order_direction', description='The sorting direction. Valid values:

ASC: ascending order. DESC: descending order.

Default value: ASC.', example='ASC', position='Body'),
  parentFileId: string(name='parent_file_id', description='The ID of the parent folder. If the parent folder is a root directory, set this parameter to root.', example='root', position='Body'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a share link, carry the `x-share-token` header for authentication in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify one of `share_id` and `drive_id`.', example='7JQX1FswpQ8', position='Body'),
  status?: string(name='status', description='The state of the file. Valid values:

available: Only normal files are returned. uploading: Only files that are being uploaded are returned.

By default, only files in the available state are returned.', example='available', position='Body'),
  thumbnailProcesses?: map[string]ImageProcess(name='thumbnail_processes', description='The thumbnail configurations. Up to five thumbnails can be returned at a time. The value contains key-value pairs. You can customize the keys. The URL of a thumbnail is returned based on the key.', position='Body'),
  type?: string(name='type', description='The type of the file. Valid values:

file: Only files are returned. folder: Only folders are returned.

By default, files of all types are returned.', example='file', position='Body'),
}

model ListFileResponseBody = {
  items?: [
    File
  ](name='items', description='The queried files.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFileResponseBody(name='body'),
}

async function listFile(request: ListFileRequest): ListFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFile', 'POST', '/v2/file/list', 'json', false, 'json', request);
}

model ListGroupRequest {
  domainId?: string(name='domain_id', position='Host'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100', position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
}

model ListGroupResponseBody = {
  items?: [
    Group
  ](name='items', description='The information about the groups.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListGroupResponseBody(name='body'),
}

async function listGroup(request: ListGroupRequest): ListGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListGroup', 'POST', '/v2/group/list', 'json', false, 'json', request);
}

model ListGroupMemberRequest {
  domainId?: string(name='domain_id', description='A short description of struct', position='Host'),
  groupId: string(name='group_id', description='The ID of the group of which you want to query members.', example='3e5***2c2', position='Body'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='50', position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
  memberType?: string(name='member_type', description='The member type. If you do not specify this parameter, both types of members are returned. Valid values:

*   user
*   group

Note: A group can be a member of only one group. It cannot be a member of multiple groups. A user can be a member of multiple groups.', example='user', position='Body'),
}

model ListGroupMemberResponseBody = {
  groupItems?: [
    Group
  ](name='group_items', description='The information about the groups.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhM1'),
  userItems?: [
    User
  ](name='user_items', description='The information about the users.'),
}

model ListGroupMemberResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListGroupMemberResponseBody(name='body'),
}

async function listGroupMember(request: ListGroupMemberRequest): ListGroupMemberResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListGroupMember', 'POST', '/v2/group/list_member', 'json', false, 'json', request);
}

model ListIdentityRoleRequest {
  domainId?: string(name='domain_id', position='Host'),
  identity: Identity(name='identity', position='Body'),
}

model ListIdentityRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BaseRoleMemberResponse  
}

async function listIdentityRole(request: ListIdentityRoleRequest): ListIdentityRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListIdentityRole', 'POST', '/v2/role/list_identity_role', 'json', false, 'json', request);
}

model ListIdentityToBenefitPkgMappingRequest {
  domainId?: string(name='domain_id', position='Host'),
  identityId: string(name='identity_id', description='The unique identifier of the entity.

If you call this operation to manage the benefits of a user, set this parameter to the ID of the user.', example='user123', position='Body'),
  identityType: string(name='identity_type', description='The type of the entity. If you call this operation to manage the benefits of a user, set this parameter to user.', example='user', position='Body'),
  includeExpired?: boolean(name='include_expired', description='Specifies whether to return the benefit packages that expire. Default value: false.', example='false', position='Body'),
}

model ListIdentityToBenefitPkgMappingResponseBody = {
  items?: [
    IdentityToBenefitPkgMapping
  ](name='items', description='The information about the benefit packages that are associated with an entity.'),
}

model ListIdentityToBenefitPkgMappingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListIdentityToBenefitPkgMappingResponseBody(name='body'),
}

async function listIdentityToBenefitPkgMapping(request: ListIdentityToBenefitPkgMappingRequest): ListIdentityToBenefitPkgMappingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListIdentityToBenefitPkgMapping', 'POST', '/v2/benefit/identity_to_benefit_pkg_mapping/list', 'json', false, 'json', request);
}

model ListMyDrivesRequest {
  domainId?: string(name='domain_id', position='Host'),
  limit?: int32(name='limit', description='The maximum number of results to return. Default value: 100. Valid values: 1 to 100.', example='100', minimum=0, maximum=100, position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
}

model ListMyDrivesResponseBody = {
  items?: [
    Drive
  ](name='items', description='The queried drives.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListMyDrivesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMyDrivesResponseBody(name='body'),
}

async function listMyDrives(request: ListMyDrivesRequest): ListMyDrivesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListMyDrives', 'POST', '/v2/drive/list_my_drives', 'json', false, 'json', request);
}

model ListMyGroupDriveRequest {
  domainId?: string(name='domain_id', description='A short description of struct', position='Host'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100', position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
}

model ListMyGroupDriveResponseBody = {
  items?: [
    Drive
  ](name='items', description='The information about the team drives.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  rootGroupDrive?: Drive(name='root_group_drive'),
}

model ListMyGroupDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMyGroupDriveResponseBody(name='body'),
}

async function listMyGroupDrive(request: ListMyGroupDriveRequest): ListMyGroupDriveResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListMyGroupDrive', 'POST', '/v2/drive/list_my_group_drive', 'json', false, 'json', request);
}

model ListReceivedFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100', position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is empty.', example='eym***', position='Body'),
}

model ListReceivedFileResponseBody = {
  items?: [
    File
  ](name='items', description='The queried files.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='eym***'),
}

model ListReceivedFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListReceivedFileResponseBody(name='body'),
}

async function listReceivedFile(request: ListReceivedFileRequest): ListReceivedFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListReceivedFile', 'POST', '/v2/file/list_received_file', 'json', false, 'json', request);
}

model ListRecyclebinRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fields?: string(name='fields', description='Specifies the returned fields.

1\\. If you set this parameter to \\*, all fields of the file are returned.

2\\. If you set this parameter to a null value or leave this parameter empty, the fields, such as file creator, file modifier, and custom tags, are not returned.

The default value is a null value, which indicates that only some fields are returned.', example='*', position='Body'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 200. Default value: 50.

The number of returned results must be less than or equal to the specified number.', example='50', position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
}

model ListRecyclebinResponseBody = {
  items?: [
    File
  ](name='items', description='The information about the files and folders in the recycle bin.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhM1'),
}

model ListRecyclebinResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRecyclebinResponseBody(name='body'),
}

async function listRecyclebin(request: ListRecyclebinRequest): ListRecyclebinResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListRecyclebin', 'POST', '/v2/recyclebin/list', 'json', false, 'json', request);
}

model ListRevisionRequest {
  domainId?: string(name='domain_id', description='A short description of struct', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fields?: string(name='fields', description='Specifies the returned fields.

By default, this parameter is left empty. If you set this parameter to \\*, all fields are returned. If you leave this parameter empty, the creator of the file is not returned.', example='*', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264', position='Body'),
  limit?: long(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.

Default value: 50.

The number of returned results must be less than or equal to the specified number.', example='100', minimum=1, maximum=200, position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.

By default, this parameter is left empty.', example='40CB7794C929', position='Body'),
}

model ListRevisionResponseBody = {
  items?: [
    Revision
  ](name='items', description='The information about the versions.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListRevisionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRevisionResponseBody(name='body'),
}

async function listRevision(request: ListRevisionRequest): ListRevisionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListRevision', 'POST', '/v2/file/revision/list', 'json', false, 'json', request);
}

model ListShareLinkRequest {
  domainId?: string(name='domain_id', position='Host'),
  creator?: string(name='creator', description='The creator of the share.', example='c9b7a5aa04d14ae3867fdc886fa01da4', position='Body'),
  includeCancelled?: boolean(name='include_cancelled', description='Specifies whether to return the shares that are canceled.', example='true', position='Body'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 0 to 100.

The number of returned results must be less than or equal to the specified number.', example='50', position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
  orderBy?: string(name='order_by', description='The field by which to sort the returned results. Default value: created_at. Valid values:

*   share_name: sorts the results by the name of the share.
*   updated_at: sorts the results by the time when the share was modified.
*   description: sorts the results by the description of the share.
*   created_at: sorts the results by the time when the share was created.', example='share_name', position='Body'),
  orderDirection?: string(name='order_direction', description='The order in which you want to sort the returned results. By default, order_direction is set to DESC if order_by is set to created_at or updated_at, and is set to ASC if order_by is set to other values. Valid values:

*   ASC: sorts the results in ascending order.
*   DESC: sorts the results in descending order.', example='ASC', position='Body'),
}

model ListShareLinkResponseBody = {
  items?: [
    ShareLink
  ](name='items', description='The information about the shares.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListShareLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListShareLinkResponseBody(name='body'),
}

/**
  * This operation is discontinued. To query shares, you can call the SearchShareLink operation.
  *
 * @tags api
 */
async function listShareLink(request: ListShareLinkRequest): ListShareLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListShareLink', 'POST', '/v2/share_link/list', 'json', false, 'json', request);
}

model ListTagsRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', description='The method that is used to generate the thumbnail of an image.', example='image/resize,w_200', position='Body'),
  videoThumbnailProcess?: string(name='video_thumbnail_process', description='The method that is used to generate the thumbnail of a video.', example='video/snapshot,t_7000,f_jpg,w_800,h_600,m_fast', position='Body'),
}

model ListTagsResponseBody = {
  tags?: [
    ImageTag
  ](name='tags', description='The information about the tags.'),
}

model ListTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagsResponseBody(name='body'),
}

/**
  * You can call this operation to query the tags within the specified drive at a time. The top 2,000 tags of the images are returned.
  *
 * @tags api
 */
async function listTags(request: ListTagsRequest): ListTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTags', 'POST', '/v2/image/list_tags', 'json', false, 'json', request);
}

model ListUploadedPartsRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId?: string(name='drive_id', description='The drive ID. This parameter is required if the file is not uploaded by using the share URL of the file.', example='1', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='322fb07b975f4b0ae1b543fe8475eee4c19eb2b2', position='Body'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100', position='Body'),
  partNumberMarker?: int32(name='part_number_marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
  shareId?: string(name='share_id', description='The share ID. This parameter is required if the file is uploaded by using the share URL of the file.', example='7JQX1FswpQ8', position='Body'),
  uploadId: string(name='upload_id', description='The ID of the upload task.', example='00166D06127B413BA1EC8ABB1144D101', position='Body'),
}

model ListUploadedPartsResponseBody = {
  fileId?: string(name='file_id', description='The file ID.', example='322fb07b975f4b0ae1b543fe8475eee4c19eb2b2'),
  nextPartNumberMarker?: string(name='next_part_number_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  parallelUpload?: boolean(name='parallel_upload', description='Indicates whether the parallel upload feature is enabled.', example='false'),
  uploadId?: string(name='upload_id', description='The ID of the upload task.', example='00166D06127B413BA1EC8ABB1144D101'),
  uploadedParts?: [
    UploadPartInfo
  ](name='uploaded_parts', description='The information about the file parts.'),
}

model ListUploadedPartsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUploadedPartsResponseBody(name='body'),
}

async function listUploadedParts(request: ListUploadedPartsRequest): ListUploadedPartsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListUploadedParts', 'POST', '/v2/file/list_uploaded_parts', 'json', false, 'json', request);
}

model ListUserRequest {
  domainId?: string(name='domain_id', position='Host'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100', position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
}

model ListUserResponseBody = {
  items?: [
    User
  ](name='items', description='The information about the users.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserResponseBody(name='body'),
}

async function listUser(request: ListUserRequest): ListUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListUser', 'POST', '/v2/user/list', 'json', false, 'json', request);
}

model MoveFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  checkNameMode?: string(name='check_name_mode', description='The processing method that is used if the file that you want to move has the same name as an existing file in the destination directory. Valid values:

ignore: allows you to move the file by using the same name as an existing file in the destination directory.

auto_rename: automatically renames the file that has the same name exists in the destination directory. By default, the current point in time is added to the end of the file name. Example: xxx\\_20060102\\_150405.

refuse: does not move the file that you want to move but returns the information about the file that has the same name in the destination directory.

Default value: ignore.', example='ignore', position='Body'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264', position='Body'),
  toParentFileId: string(name='to_parent_file_id', description='The ID of the destination parent directory to which you want to move a file or folder. If you want to move a file or folder to the root directory, set this parameter to root.', example='6520943DC261', position='Body'),
}

model MoveFileResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

If an empty string is returned, the file is moved.

If a non-empty string is returned, an asynchronous task is required. You can call the GetAsyncTask operation to obtain the information about an asynchronous task based on the task ID.', example='23ebd1a24dba4166b1527add476ef2866051b4d5del106'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  exist?: boolean(name='exist', description='Indicates whether the file already exists in the destination directory.', example='false'),
  fileId?: string(name='file_id', description='The file ID.', example='fileid1'),
}

model MoveFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MoveFileResponseBody(name='body'),
}

async function moveFile(request: MoveFileRequest): MoveFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'MoveFile', 'POST', '/v2/file/move', 'json', false, 'json', request);
}

model QueryOrderPriceRequest {
  code: string(name='code', position='Body'),
  instanceId: string(name='instance_id', position='Body'),
  orderType: string(name='order_type', position='Body'),
  package: string(name='package', position='Body'),
  period: long(name='period', position='Body'),
  periodUnit: string(name='period_unit', position='Body'),
  totalSize: long(name='total_size', position='Body'),
  userCount: long(name='user_count', position='Body'),
}

model QueryOrderPriceResponseBody = {
  discountPrice?: double(name='discount_price'),
  originalPrice?: double(name='original_price'),
  tradePrice?: double(name='trade_price'),
}

model QueryOrderPriceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryOrderPriceResponseBody(name='body'),
}

async function queryOrderPrice(request: QueryOrderPriceRequest): QueryOrderPriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'QueryOrderPrice', 'POST', '/v2/domain/query_order_price', 'json', false, 'json', request);
}

model RemoveFaceGroupFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', example='123', position='Body'),
  faceGroupId: string(name='face_group_id', example='Cluster-abc', position='Body'),
  fileId: string(name='file_id', example='abcd', position='Body'),
}

model RemoveFaceGroupFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function removeFaceGroupFile(request: RemoveFaceGroupFileRequest): RemoveFaceGroupFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveFaceGroupFile', 'POST', '/v2/albums/unassign_facegroup_item', 'none', false, 'json', request);
}

model RemoveGroupMemberRequest {
  domainId?: string(name='domain_id', description='A short description of struct', position='Host'),
  groupId: string(name='group_id', description='The ID of the group from which you want to remove a member.', example='3e5***2c2', position='Body'),
  memberId: string(name='member_id', description='The ID of the member. If member_type is set to user, set this parameter to the ID of the corresponding user.', example='2e4***1b1', position='Body'),
  memberType: string(name='member_type', description='The type of the member that you want to remove from the group. Only common users can be removed. If you want to remove all members from a group, you can directly delete the group. Valid value:

*   user

Note: A group can be a member of only one group. It cannot be a member of multiple groups. A user can be a member of multiple groups.', example='user', position='Body'),
}

model RemoveGroupMemberResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function removeGroupMember(request: RemoveGroupMemberRequest): RemoveGroupMemberResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveGroupMember', 'POST', '/v2/group/remove_member', 'none', false, 'json', request);
}

model RemoveStoryFilesRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', example='1', position='Body'),
  files?: [ 
    {
      fileId: string(name='file_id', example='63e5e4340f76cb3ead5f40f68163f0f967c1a7bf'),
      revisionId?: string(name='revision_id', example='642a88dd06e49d9c0a14411ebae606f70edd9a59'),
    }
  ](name='files', position='Body'),
  storyId: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003', position='Body'),
}

model RemoveStoryFilesResponseBody = {
  driveId?: string(name='drive_id', example='1'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model RemoveStoryFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveStoryFilesResponseBody(name='body'),
}

async function removeStoryFiles(request: RemoveStoryFilesRequest): RemoveStoryFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RemoveStoryFiles', 'POST', '/v2/image/remove_story_files', 'json', false, 'json', request);
}

model RestoreFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The ID of the file or folder.', example='4221bf6e6ab43a255edc4463bffa6f5f5d317401', position='Body'),
}

model RestoreFileResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

If an empty string is returned, the file or folder is restored.

If a non-empty string is returned, an asynchronous task is required. You can call the GetAsyncTask operation to obtain the information about an asynchronous task based on the task ID.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The ID of the file or folder.', example='4221bf6e6ab43a255edc4463bffa6f5f5d317401'),
}

model RestoreFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestoreFileResponseBody(name='body'),
}

async function restoreFile(request: RestoreFileRequest): RestoreFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RestoreFile', 'POST', '/v2/recyclebin/restore', 'json', false, 'json', request);
}

model RestoreRevisionRequest {
  domainId?: string(name='domain_id', description='A short description of struct', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264', position='Body'),
  revisionId: string(name='revision_id', description='The version ID.', example='40CB7794C929', position='Body'),
}

model RestoreRevisionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Revision  
}

async function restoreRevision(request: RestoreRevisionRequest): RestoreRevisionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RestoreRevision', 'POST', '/v2/file/revision/restore', 'json', false, 'json', request);
}

model ScanFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fields?: string(name='fields', description='The file properties to return.

*   If you want to return all file properties, set this parameter to \\*.
*   By default, if you do not specify this parameter, the following properties of a file are returned: - file_id, - drive_id, - parent_file_id, - type, - created_at, - updated_at, - file_extention, - size, - starred, - status, - category, and - permissions.
*   You can also specify properties to return. Separate multiple properties with commas (,).', example='*', position='Body'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.

The number of returned results must be less than or equal to the specified number.', example='50', minimum=1, maximum=100, position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
}

model ScanFileResponseBody = {
  items?: [
    File
  ](name='items', description='The information about the files.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ScanFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ScanFileResponseBody(name='body'),
}

async function scanFile(request: ScanFileRequest): ScanFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ScanFile', 'POST', '/v2/file/scan', 'json', false, 'json', request);
}

model SearchAddressGroupsRequest {
  domainId?: string(name='domain_id', position='Host'),
  addressLevel?: string(name='address_level', description='The level of the location.

Valid values:

*   country

    <!-- -->

    <!-- -->

    <!-- -->

*   province

    <!-- -->

    <!-- -->

    <!-- -->

*   city

    <!-- -->

    <!-- -->

    <!-- -->

*   district

    <!-- -->

    <!-- -->

    <!-- -->

*   township

    <!-- -->

    <!-- -->

    <!-- -->', position='Body'),
  addressNames?: [ string ](name='address_names', description='The locations.', position='Body'),
  brGeoPoint?: string(name='br_geo_point', description='The coordinates of the bottom right vertex of the rectangle. Set the value in the format of latitude,longitude.', example='40.121,105.2121', position='Body'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', description='The method used to generate the thumbnail of an image.', example='image/resize,w_200', position='Body'),
  tlGeoPoint?: string(name='tl_geo_point', description='The coordinates of the top left vertex of the rectangle. Set the value in the format of latitude,longitude.', example='39.121,101.2121', position='Body'),
  videoThumbnailProcess?: string(name='video_thumbnail_process', description='The method used to generate the thumbnail of a video.', example='video/snapshot,t_7000,f_jpg,w_800,h_600,m_fast', position='Body'),
}

model SearchAddressGroupsResponseBody = {
  items?: [
    AddressGroup
  ](name='items', description='The location-based groups.'),
}

model SearchAddressGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchAddressGroupsResponseBody(name='body'),
}

async function searchAddressGroups(request: SearchAddressGroupsRequest): SearchAddressGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SearchAddressGroups', 'POST', '/v2/image/search_address_groups', 'json', false, 'json', request);
}

model SearchDomainsRequest {
  limit?: long(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.

The number of returned results must be less than or equal to the specified number.', example='50', position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
  name?: string(name='name', description='The name of the domain. Fuzzy search is supported.', position='Body'),
  orderBy?: string(name='order_by', description='The sorting rule. Set the value to created_at, which specifies that the results are sorted based on the time when the domain was created.', example='created_at', position='Body'),
}

model SearchDomainsResponseBody = {
  items?: [
    Domain
  ](name='items', description='The queried domains.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model SearchDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchDomainsResponseBody(name='body'),
}

async function searchDomains(request: SearchDomainsRequest): SearchDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SearchDomains', 'POST', '/v2/domain/search', 'json', false, 'json', request);
}

model SearchDriveRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveName?: string(name='drive_name', description='The drive name.', position='Body'),
  limit?: int32(name='limit', description='The maximum number of asynchronous tasks to return. Valid values: 1 to 100. Default value: 100.', example='100', minimum=0, maximum=100, position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
  owner?: string(name='owner', description='The owner of the drive.', example='c9b7a5aa04d14ae3867fdc886fa01da4', position='Body'),
  ownerType?: string(name='owner_type', description='The type of the owner. Valid values:

user group', example='user', position='Body'),
}

model SearchDriveResponseBody = {
  items?: [
    Drive
  ](name='items', description='The information about the drives.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model SearchDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchDriveResponseBody(name='body'),
}

async function searchDrive(request: SearchDriveRequest): SearchDriveResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SearchDrive', 'POST', '/v2/drive/search', 'json', false, 'json', request);
}

model SearchFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fields?: string(name='fields', example='url,thumbnail', deprecated='true', position='Body'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.

The number of returned results must be less than or equal to the specified number.', example='50', minimum=1, maximum=100, position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
  orderBy?: string(name='order_by', description='The field by which to sort the returned results. Default value: created_at. Valid values:

*   created_at: sorts the results by the time when the file was created.
*   updated_at: sorts the results by the time when the file was modified.
*   size: sorts the results by the size of the file.
*   name: sorts the results by the name of the file.

The order in which you want to sort the returned results. Valid values:

*   ASC: sorts the results in ascending order.
*   DESC: sorts the results in descending order.

You must specify this parameter in the \\<field name> \\<ASC or DESC> format. Separate multiple field names with commas (,). A preceding field has a higher priority than a following field. Examples:

*   If you want to sort the results based on the file name in ascending order, set this parameter to "name ASC".
*   If you want to sort the results based on the creation time in descending order, set this parameter to "created_at DESC".
*   If you want to sort the results based on the creation time in descending order first, and then sort the results based on the file name in ascending order if the creation time is the same, set this parameter to "created_at DESC,name ASC".', example='name', position='Body'),
  query: string(name='query', description='The search condition. Fuzzy searches based on the file name or directory name are supported. The search condition can be up to 4,096 characters in length.', example='not name=123', maxLength=4096, position='Body'),
  recursive?: boolean(name='recursive', position='Body'),
  returnTotalCount?: boolean(name='return_total_count', description='Specifies whether to return the total number of retrieved files.', example='true', position='Body'),
}

model SearchFileResponseBody = {
  items?: [
    File
  ](name='items', description='The information about the files.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  totalCount?: long(name='total_count', description='The total number of retrieved files.', example='1022'),
}

model SearchFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchFileResponseBody(name='body'),
}

async function searchFile(request: SearchFileRequest): SearchFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SearchFile', 'POST', '/v2/file/search', 'json', false, 'json', request);
}

model SearchShareLinkRequest {
  domainId?: string(name='domain_id', position='Host'),
  creators?: [ string ](name='creators', description='The creators of shares. Set this parameter to a user ID. If you do not specify this parameter, Drive and Photo Service automatically queries shares based on your permissions. If you are a drive administrator or the super administrator, the shares created by all members are queried. If you are a team administrator, the shares created by all team members are queried. If you are a common user, only the shares created by yourself are queried.

If you specify this parameter, this parameter must be set to the ID of the super administrator, a drive administrator, or a team administrator.', position='Body'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.

The number of returned results must be less than or equal to the specified number.', example='50', position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
  orderBy?: string(name='order_by', description='The field by which to sort the returned results. Default value: created_at. Valid values:

*   share_name: sorts the results by the name of the share.
*   updated_at: sorts the results by the time when the share was modified.
*   description: sorts the results by the description of the share.
*   created_at: sorts the results by the time when the share was created.', example='created_at', position='Body'),
  orderDirection?: string(name='order_direction', description='The order in which you want to sort the returned results. By default, order_direction is set to DESC if order_by is set to created_at or updated_at, and is set to ASC if order_by is set to other values. Valid values:

*   ASC: sorts the results in ascending order.
*   DESC: sorts the results in descending order.', example='ASC', position='Body'),
  query?: string(name='query', description='The query condition that is used to search for share URLs. You can use the following fields to specify query conditions: created_at: queries a share URL based on the time when the share URL was created. updated_at: queries a share URL based on the time when the share URL was modified. share_name_for_fuzzy: queries a share URL based on the name of the share. A fuzzy match is supported. status: queries a share URL based on the status of the share. Valid values: enabled and disabled. A value of enabled indicates that the share is valid. A value of disabled indicates that the share is canceled. expired_time: queries a share URL based on the expiration time of the share. If the share never expires, set this field to 1970-01-01T00:00:00. Otherwise, set this field to 1970-01-02T00:00:00.', example='created_at>=\\"2022-01-18T02:50:00\\" and created_at<\\"2022-01-19T09:45:28\\" and share_name_for_fuzzy match \\"HD.mp4\\" and status in [\\"enabled\\", \\"disabled\\"] and expired_time=\\"1970-01-01T00:00:00\\"', position='Body'),
  returnTotalCount?: boolean(name='return_total_count', description='Specifies whether to return the total number of returned results.', example='false', position='Body'),
}

model SearchShareLinkResponseBody = {
  items?: [
    ShareLink
  ](name='items', description='The share URLs.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  totalCount?: long(name='total_count', description='The total number of entries returned.', example='101'),
}

model SearchShareLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchShareLinkResponseBody(name='body'),
}

async function searchShareLink(request: SearchShareLinkRequest): SearchShareLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SearchShareLink', 'POST', '/v2/share_link/search', 'json', false, 'json', request);
}

model SearchSimilarImageClustersRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', example='1', position='Body'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', example='image/resize,m_fill,h_128,w_128,limit_0/format,jpg', deprecated='true', position='Body'),
  limit?: long(name='limit', example='50', minimum=0, maximum=100, position='Body'),
  marker?: string(name='marker', example='YWRzX3VzZXJfcHJvZmlsZV9je1bnQh***', position='Body'),
  order?: string(name='order', example='desc', position='Body'),
}

model SearchSimilarImageClustersResponseBody = {
  nextMarker?: string(name='next_marker', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0***'),
  similarImageClusters?: [ 
    {
      files?: [
        File
      ](name='files'),
    }
  ](name='similar_image_clusters'),
}

model SearchSimilarImageClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchSimilarImageClustersResponseBody(name='body'),
}

async function searchSimilarImageClusters(request: SearchSimilarImageClustersRequest): SearchSimilarImageClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SearchSimilarImageClusters', 'POST', '/v2/image/query_similar_image_clusters', 'json', false, 'json', request);
}

model SearchStoriesRequest {
  domainId?: string(name='domain_id', position='Host'),
  coverImageThumbnailProcess?: string(name='cover_image_thumbnail_process', example='image/resize,m_fill,h_128,w_128,limit_0/format,jpg', deprecated='true', position='Body'),
  coverVideoThumbnailProcess?: string(name='cover_video_thumbnail_process', example='video/snapshot,t_1000,f_jpg,w_0,h_0,m_fast,ar_auto', deprecated='true', position='Body'),
  createTimeRange?: {
    end?: string(name='end', example='2022-12-31T00:00:00+08:00'),
    start?: string(name='start', example='2016-12-31T00:00:00+08:00'),
  }(name='create_time_range', position='Body'),
  customLabels?: string(name='custom_labels', example='key1=value1,key2!=value2', deprecated='true', position='Body'),
  driveId: string(name='drive_id', example='1', position='Body'),
  faceGroupIds?: [ string ](name='face_group_ids', position='Body'),
  limit?: long(name='limit', example='100', position='Body'),
  marker?: string(name='marker', example='NWQ1Yjk4YmI1ZDODBhNDQ2Nzhl***', position='Body'),
  order?: string(name='order', example='desc', position='Body'),
  sort?: string(name='sort', example='CreateTime', position='Body'),
  storyEndTimeRange?: {
    end?: string(name='end', example='2022-12-31T00:00:00+08:00'),
    start?: string(name='start', example='2016-12-31T00:00:00+08:00'),
  }(name='story_end_time_range', position='Body'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003', position='Body'),
  storyName?: string(name='story_name', position='Body'),
  storyStartTimeRange?: {
    end?: string(name='end', example='2022-12-31T00:00:00+08:00'),
    start?: string(name='start', example='2016-12-31T00:00:00+08:00'),
  }(name='story_start_time_range', position='Body'),
  storyType?: string(name='story_type', example='PeopleMemory', position='Body'),
  urlExpireSec?: long(name='url_expire_sec', example='900', deprecated='true', minimum=10, maximum=86400, position='Body'),
  withEmptyStories?: boolean(name='with_empty_stories', example='false', position='Body'),
}

model SearchStoriesResponseBody = {
  items?: [
    Story
  ](name='items'),
  nextMarker?: string(name='next_marker', example='Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJ***'),
}

model SearchStoriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchStoriesResponseBody(name='body'),
}

async function searchStories(request: SearchStoriesRequest): SearchStoriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SearchStories', 'POST', '/v2/image/find_stories', 'json', false, 'json', request);
}

model SearchUserRequest {
  domainId?: string(name='domain_id', position='Host'),
  email?: string(name='email', description='The email address of the user.', example='123@pds.com', position='Body'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100', position='Body'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg', position='Body'),
  nickName?: string(name='nick_name', description='The nickname of the user. The nickname can be up to 128 characters in length.', example='pdsuer', maxLength=128, position='Body'),
  nickNameForFuzzy?: string(name='nick_name_for_fuzzy', description='The nickname used for fuzzy searches. The nickname can be up to 128 characters in length.', example='la', maxLength=128, position='Body'),
  phone?: string(name='phone', description='The mobile number of the user.', example='13900001111', position='Body'),
  role?: string(name='role', description='The role of the user. Valid values:

*   superadmin
*   admin
*   user', example='user', position='Body'),
  status?: string(name='status', description='The state of the user. Valid values:

*   disabled: The user is prohibited from logon.
*   enabled: The user is in a normal state.', example='enabled', position='Body'),
  userName?: string(name='user_name', description='The name of the user. The name can be up to 128 characters in length.', example='pds', maxLength=128, position='Body'),
}

model SearchUserResponseBody = {
  items?: [
    User
  ](name='items', description='The information about the users.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model SearchUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchUserResponseBody(name='body'),
}

async function searchUser(request: SearchUserRequest): SearchUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'SearchUser', 'POST', '/v2/user/search', 'json', false, 'json', request);
}

model TokenRequest {
  domainId?: string(name='domain_id', position='Host'),
  assertion?: string(name='assertion', description='The JWT assertion that is signed by using the JWT private key. The JWT assertion contains the information about the user to be authorized and the authorization parameters. For more information about the structure of the JWT assertion, see JWTPayload. This parameter is required if grant_type is set to urn:ietf:params:oauth:grant-type:jwt-bearer.', example='ey***asd', position='Body'),
  clientId: string(name='client_id', description='The AppId of the application that is created in the Drive and Photo Service console.', example='1Zu***flH', position='Body'),
  clientSecret?: string(name='client_secret', description='The AppSecret of the application that is created in the Drive and Photo Service console. This parameter is required if the application is of the WebServer type.', example='80D***3i5', position='Body'),
  code?: string(name='code', description='The authorization code in the redirect URI that is specified after the authorization process is complete. This parameter is required if grant_type is set to authorization_code.', example='0045157fa8e24f4f9a0d9e3ff158c1e0', position='Body'),
  grantType: string(name='grant_type', description='The method that is used to generate an access token. Valid values:

authorization_code: generates an access token by using the authorization code that is returned after the authorization process is complete.

refresh_token: generates an access token by using the refresh token that is returned after the authorization process is complete.

urn:ietf:params:oauth:grant-type:jwt-bearer: generates an access token by using a JWT assertion.', example='refresh_token', position='Body'),
  redirectUri?: string(name='redirect_uri', description='The redirect URI that is specified when you initiate the authorization request. This parameter is required if grant_type is set to authorization_code.', example='https://aliyun.com/pds', position='Body'),
  refreshToken?: string(name='refresh_token', description='The refresh token that is used to refresh the access token. This parameter is required if grant_type is set to refresh_token.', example='399623e13353490391266c7d48a13ed1', position='Body'),
}

model TokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Token  
}

/**
  * For more information about how to access Drive and Photo Service from a web server application by using OAuth 2.0, visit [OAuth 2.0 For Web Server Applications](https://www.alibabacloud.com/help/zh/pds/drive-and-photo-service-dev/user-guide/oauth-2-0-access-process-for-web-server-applications).
  * For more information about how to access Drive and Photo Service by using a JSON Web Token (JWT) application, visit [Access process for JWT applications](https://www.alibabacloud.com/help/zh/pds/drive-and-photo-service-dev/user-guide/access-process-for-jwt-applications).
  *
 * @tags api
 */
async function token(request: TokenRequest): TokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'Token', 'POST', '/v2/oauth/token', 'json', true, 'form', request);
}

model TrashFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The ID of the file or folder.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406', position='Body'),
}

model TrashFileResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

If an empty string is returned, the file or folder is moved to the recycle bin.

If a non-empty string is returned, an asynchronous task is required. You can call the GetAsyncTask operation to obtain the information about an asynchronous task based on the task ID.', example='13ebd3a24dba4166b1527add676ef2866051b4d5dele16'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The ID of the file or folder.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406'),
}

model TrashFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TrashFileResponseBody(name='body'),
}

async function trashFile(request: TrashFileRequest): TrashFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'TrashFile', 'POST', '/v2/recyclebin/trash', 'json', false, 'json', request);
}

model UnLinkAccountRequest {
  domainId?: string(name='domain_id', description='A short description of struct', position='Host'),
  extra?: string(name='extra', example='1', position='Body'),
  identity: string(name='identity', example='139****', position='Body'),
  type: string(name='type', example='mobile', position='Body'),
  userId: string(name='user_id', example='uid1', position='Body'),
}

model UnLinkAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function unLinkAccount(request: UnLinkAccountRequest): UnLinkAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UnLinkAccount', 'POST', '/v2/account/unlink', 'none', false, 'json', request);
}

model UpdateDomainRequest {
  description?: string(name='description', description='The description of the domain.', position='Body'),
  domainId: string(name='domain_id', description='The domain ID.', example='bj1', position='Body'),
  domainName?: string(name='domain_name', description='The name of the domain.', position='Body'),
  initDriveEnable?: boolean(name='init_drive_enable', description='Specifies whether to enable the default drive feature. A value of true specifies that all users are assigned a drive by default on the first logon. Default value: false.', example='true', position='Body'),
  initDriveSize?: long(name='init_drive_size', description='The size of the default drive. Unit: bytes. You must specify init_drive_size if you set init_drive_enable to true. Default value: 0. A value of 0 specifies that the size of the default drive is 0 bytes and you cannot upload files to the drive. To initialize the default drive, set init_drive_size to 0. A value of -1 specifies that the size is unlimited.', example='1073741824', position='Body'),
  publishedAppAccessStrategy?: AppAccessStrategy(name='published_app_access_strategy', description='The access policy of the application.', position='Body'),
  sizeQuota?: long(name='size_quota', description='The total storage quota for all drives in the domain. A value of 0 specifies that the quota is unlimited.', example='1099511627776', position='Body'),
  userCountQuota?: long(name='user_count_quota', description='The maximum number of users that can be created in the domain.', example='50', position='Body'),
}

model UpdateDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Domain  
}

async function updateDomain(request: UpdateDomainRequest): UpdateDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateDomain', 'POST', '/v2/domain/update', 'json', false, 'json', request);
}

model UpdateDriveRequest {
  domainId?: string(name='domain_id', position='Host'),
  description?: string(name='description', description='The description of the drive. The description can be up to 1,024 characters in length.', maxLength=1024, position='Body'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  driveName?: string(name='drive_name', description='The name of the drive. The name can be up to 128 characters in length.', example='my_drive', maxLength=128, position='Body'),
  owner?: string(name='owner', description='The owner of the drive. Note: You can modify the owner of a personal drive only by using an AccessKey pair.', example='user1', position='Body'),
  status?: string(name='status', description='The state of the drive. Valid values:

enabled and disabled.', example='enabled', position='Body'),
  totalSize?: long(name='total_size', description='The total size of the drive. Unit: bytes. A value of -1 specifies that the size is unlimited.', example='10240', position='Body'),
}

model UpdateDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Drive  
}

async function updateDrive(request: UpdateDriveRequest): UpdateDriveResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateDrive', 'POST', '/v2/drive/update', 'json', false, 'json', request);
}

model UpdateFacegroupRequest {
  domainId?: string(name='domain_id', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  groupCoverFaceId?: string(name='group_cover_face_id', description='The face ID of the thumbnail of the face-based group. You can obtain the face ID from the **image_media_metadata** parameter in the returned results of the GetFile, ListFile, or SearchFile operation.', example='face1', position='Body'),
  groupId: string(name='group_id', description='The ID of the face-based group. You can call the ListFacegroups operation to query the group ID.', example='group-abc', position='Body'),
  groupName?: string(name='group_name', description='The name of the face-based group. The name can be up to 128 characters in length.', minLength=1, maxLength=128, position='Body'),
  remarks?: string(name='remarks', description='The remarks. The remarks can be up to 128 characters in length.', minLength=1, maxLength=128, position='Body'),
}

model UpdateFacegroupResponseBody = {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  groupId?: string(name='group_id', description='The group ID.', example='group-abc'),
}

model UpdateFacegroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFacegroupResponseBody(name='body'),
}

async function updateFacegroup(request: UpdateFacegroupRequest): UpdateFacegroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateFacegroup', 'POST', '/v2/image/update_facegroup_info', 'json', false, 'json', request);
}

model UpdateFileRequest {
  domainId?: string(name='domain_id', position='Host'),
  checkNameMode?: string(name='check_name_mode', description='The processing method that is used if the file that you want to modify has the same name as an existing file on the cloud. Valid values:

ignore: allows you to modify the file by using the same name as an existing file on the cloud.

auto_rename: automatically renames the file that has the same name on the cloud. By default, the current point in time is added to the end of the file name. Example: xxx\\_20060102\\_150405.

refuse: does not modify the file that you want to modify but returns the information about the file that has the same name on the cloud.

Default value: ignore.', example='ignore', position='Body'),
  description?: string(name='description', description='The description of the file. The description can be up to 1,024 characters in length.', maxLength=1024, position='Body'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264', position='Body'),
  hidden?: boolean(name='hidden', description='Specifies whether to hide the file.', example='true', position='Body'),
  labels?: [ string ](name='labels', description='The tags of the file. You can specify up to 100 tags.', position='Body'),
  localModifiedAt?: string(name='local_modified_at', description='The local time when the file was modified. The time is in the yyyy-MM-ddTHH:mm:ssZ format based on the UTC+0 time zone.', example='2019-08-20T06:51:27.292Z', position='Body'),
  name?: string(name='name', description='The name of the file. The name can be up to 1,024 bytes in length based on the UTF-8 encoding rule.', example='a.jpg', minLength=1, maxLength=102, position='Body'),
  starred?: boolean(name='starred', description='Specifies whether to add the file to favorites.', example='true', position='Body'),
}

model UpdateFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: File  
}

async function updateFile(request: UpdateFileRequest): UpdateFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateFile', 'POST', '/v2/file/update', 'json', false, 'json', request);
}

model UpdateGroupRequest {
  domainId?: string(name='domain_id', position='Host'),
  description?: string(name='description', description='The description of the group after modification.', example='test group description', position='Body'),
  groupId: string(name='group_id', description='The ID of the group that you want to modify.', example='2e43ec8427dd45f19431b7504649a1b4', position='Body'),
  groupName?: string(name='group_name', description='The name of the group after modification.', example='test group', position='Body'),
}

model UpdateGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Group  
}

async function updateGroup(request: UpdateGroupRequest): UpdateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateGroup', 'POST', '/v2/group/update', 'json', false, 'json', request);
}

model UpdateIdentityToBenefitPkgMappingRequest {
  domainId?: string(name='domain_id', position='Host'),
  amount?: long(name='amount', description='The number of benefit packages.

This parameter specifies the number of benefit packages of the resource type. Default value: 1.', example='1', position='Body'),
  benefitPkgId: string(name='benefit_pkg_id', description='The unique identifier of the benefit package.', example='40cb7794c9294', position='Body'),
  expireTime?: long(name='expire_time', description='The expiration time of the benefit package. Set this parameter to a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.

By default, the benefit package never expires.', example='1633167071000', position='Body'),
  identityId: string(name='identity_id', description='The unique identifier of the entity.

If you call this operation to manage the benefits of a user, set this parameter to the ID of the user.', example='user123', position='Body'),
  identityType: string(name='identity_type', description='The type of the entity. If you call this operation to manage the benefits of a user, set this parameter to user.', example='user', position='Body'),
}

model UpdateIdentityToBenefitPkgMappingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

async function updateIdentityToBenefitPkgMapping(request: UpdateIdentityToBenefitPkgMappingRequest): UpdateIdentityToBenefitPkgMappingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateIdentityToBenefitPkgMapping', 'POST', '/v2/benefit/identity_to_benefit_pkg_mapping/update', 'none', false, 'json', request);
}

model UpdateRevisionRequest {
  domainId?: string(name='domain_id', description='A short description of struct', position='Host'),
  driveId: string(name='drive_id', description='The drive ID.', example='1', position='Body'),
  fileId: string(name='file_id', description='The file ID.', example='9520943DC264', position='Body'),
  keepForever?: boolean(name='keep_forever', description='Specifies whether to permanently retain a version.

By default, this parameter is not specified, which indicates that you do not modify the permanent retention configuration of the version.', example='true', position='Body'),
  revisionDescription?: string(name='revision_description', description='The description of the version. The description can be up to 1,024 characters in length.

By default, this parameter is not specified, which indicates that you do not modify the description of the version.', example='aaa', position='Body'),
  revisionId: string(name='revision_id', description='The version ID.', example='40CB7794C929', position='Body'),
}

model UpdateRevisionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Revision  
}

async function updateRevision(request: UpdateRevisionRequest): UpdateRevisionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateRevision', 'POST', '/v2/file/revision/update', 'json', false, 'json', request);
}

model UpdateShareLinkRequest {
  domainId?: string(name='domain_id', position='Host'),
  description?: string(name='description', description='The description of the share link. The description can be up to 1,024 characters in length.', position='Body'),
  disableDownload?: boolean(name='disable_download', description='Specifies whether to prohibit the downloads of the shared files.', example='false', position='Body'),
  disablePreview?: boolean(name='disable_preview', description='Specifies whether to prohibit the previews of the shared files.', example='false', position='Body'),
  disableSave?: boolean(name='disable_save', description='Specifies whether to prohibit the saves of the shared files.', example='false', position='Body'),
  downloadCount?: long(name='download_count', description='The number of times that the shared files are downloaded. The value must be greater than or equal to 0.', example='30', position='Body'),
  downloadLimit?: long(name='download_limit', description='The maximum number of times that the shared files can be downloaded. The value must be greater than or equal to 0. A value of 0 specifies that the number is unlimited.', example='100', position='Body'),
  expiration?: string(name='expiration', description='The time when the share link expires. The time follows the RFC 3339 standard. Example: 2020-06-28T11:33:00.000+08:00. If you leave this parameter empty, the share link never expires.', example='2020-06-28T11:33:00.000+08:00', position='Body'),
  previewCount?: long(name='preview_count', description='The number of times that the shared files are previewed. The value must be greater than or equal to 0.', example='3', position='Body'),
  previewLimit?: long(name='preview_limit', description='The maximum number of times that the shared files can be previewed. The value must be greater than or equal to 0. A value of 0 specifies that the number is unlimited.', example='100', position='Body'),
  reportCount?: long(name='report_count', description='The number of times that the shared files are reported. The value must be greater than or equal to 0.', example='1', position='Body'),
  saveCount?: long(name='save_count', description='The number of times that the shared files are saved. The value must be greater than or equal to 0.', example='5', position='Body'),
  saveLimit?: long(name='save_limit', description='The maximum number of times that the shared files can be saved. The value must be greater than or equal to 0. A value of 0 specifies that the number is unlimited.', example='100', position='Body'),
  shareId: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8', position='Body'),
  shareName?: string(name='share_name', description='The name of the share link. By default, the name of the first file is used. The name can be up to 128 characters in length.', position='Body'),
  sharePwd?: string(name='share_pwd', description='The access code. The access code can be up to 64 characters in length. A value of 0 specifies an empty string.', example='abcF123x', position='Body'),
  status?: string(name='status', description='The state of the share link. Valid values:

*   disabled: The share link is canceled.
*   enabled: The share link is effective.', example='enabled', position='Body'),
  videoPreviewCount?: long(name='video_preview_count', description='The number of times that the videos are previewed in the shared files. The value must be greater than or equal to 0.', example='100', position='Body'),
}

model UpdateShareLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ShareLink  
}

async function updateShareLink(request: UpdateShareLinkRequest): UpdateShareLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateShareLink', 'POST', '/v2/share_link/update', 'json', false, 'json', request);
}

model UpdateStoryRequest {
  domainId?: string(name='domain_id', position='Host'),
  cover?: {
    fileId?: string(name='file_id', example='63e5e4340f76cb3ead5f40f68163f0f967c1a7bf'),
    revisionId?: string(name='revision_id', example='642a88dd06e49d9c0a14411ebae606f70edd9a59'),
  }(name='cover', position='Body'),
  customLabels?: map[string]string(name='custom_labels', deprecated='true', position='Body'),
  driveId: string(name='drive_id', example='1', position='Body'),
  storyId: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003', position='Body'),
  storyName?: string(name='story_name', example='name1', position='Body'),
}

model UpdateStoryResponseBody = {
  driveId?: string(name='drive_id', example='1'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model UpdateStoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateStoryResponseBody(name='body'),
}

async function updateStory(request: UpdateStoryRequest): UpdateStoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateStory', 'POST', '/v2/image/update_story', 'json', false, 'json', request);
}

model UpdateUserRequest {
  domainId?: string(name='domain_id', position='Host'),
  avatar?: string(name='avatar', description='The URL of the profile picture.

If you specify the parameter in the HTTP URL format, the URL must start with http:// or https:// and can be up to 4 KB in size.

If you specify the parameter in the DATA URL format, the URL must start with data:// and be encoded in Base64. The URL can be up to 300 KB in size.', example='http://a.b.c/pds.jpg', position='Body'),
  description?: string(name='description', description='The description of the user. The description can be up to 1,024 characters in length.', maxLength=1024, position='Body'),
  email?: string(name='email', description='The email address of the user.', example='a@aliyunpds.com', position='Body'),
  groupInfoList?: [ 
    {
      groupId?: string(name='group_id', description='The group ID.', example='g123'),
    }
  ](name='group_info_list', description='The information about the group.', position='Body'),
  nickName?: string(name='nick_name', description='The nickname of the user. The nickname can be up to 128 characters in length.', example='pdsuer', maxLength=128, position='Body'),
  phone?: string(name='phone', description='The mobile number of the user.', example='13900001111', position='Body'),
  role?: string(name='role', description='The role of the user. Valid values:

*   superadmin
*   admin
*   user', example='user', position='Body'),
  status?: string(name='status', description='The state of the user. Valid values:

*   disabled: The user is prohibited from logon.
*   enabled: The user is in a normal state.', example='enabled', position='Body'),
  userData?: map[string]string(name='user_data', description='The custom data. The data can be up to 1,024 characters in length.', position='Body'),
  userId: string(name='user_id', description='The user ID. The ID can be up to 64 characters in length and cannot contain a number sign (#).', example='c9b7a5aa04d14ae3867fdc886fa01da4', minLength=1, maxLength=1024, position='Body'),
}

model UpdateUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: User  
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateUser', 'POST', '/v2/user/update', 'json', false, 'json', request);
}

