/**
 *
 */
import Util;
import GatewayClient;
import OpenApi;
import OpenApiUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  var gatewayClient = new GatewayClient();
  @spi = gatewayClient;
  @signatureAlgorithm = 'v2';
  @disableHttp2 = true;
  @endpointRule = '';
  }

model AIAssistantSession {
  clientId?: string(name='client_id'),
  createdAt?: long(name='created_at'),
  customLabels?: [ string ](name='custom_labels'),
  domainId?: string(name='domain_id'),
  expiredAt?: long(name='expired_at'),
  name?: string(name='name'),
  sessionId?: string(name='session_id'),
  status?: string(name='status'),
  updatedAt?: long(name='updated_at'),
  userId?: string(name='user_id'),
}

model AccountAccessTokenResponse {
  accessToken?: string(name='access_token'),
  avatar?: string(name='avatar'),
  defaultDriveId?: string(name='default_drive_id'),
  defaultSboxDriveId?: string(name='default_sbox_drive_id'),
  deviceId?: string(name='device_id'),
  deviceName?: string(name='device_name'),
  domainId?: string(name='domain_id'),
  existLink?: [
    LinkInfo
  ](name='exist_link'),
  expireTime?: string(name='expire_time'),
  expiresIn?: long(name='expires_in'),
  isFirstLogin?: boolean(name='is_first_login'),
  needLink?: boolean(name='need_link'),
  needRpVerify?: boolean(name='need_rp_verify'),
  nickName?: string(name='nick_name'),
  pathStatus?: string(name='path_status'),
  pinSetup?: boolean(name='pin_setup'),
  refreshToken?: string(name='refresh_token'),
  role?: string(name='role'),
  state?: string(name='state'),
  status?: string(name='status'),
  tokenType?: string(name='token_type'),
  userData?: map[string]string(name='user_data'),
  userId?: string(name='user_id'),
  userName?: string(name='user_name'),
}

model AccountLinkInfo {
  authenticationType?: string(name='authentication_type'),
  createdAt?: long(name='created_at'),
  displayName?: string(name='display_name'),
  domainId?: string(name='domain_id'),
  extra?: string(name='extra'),
  identity?: string(name='identity'),
  userId?: string(name='user_id'),
}

model Activity {
  activityId?: string(name='activity_id'),
  device?: string(name='device'),
  driveId?: string(name='drive_id'),
  eventType?: int32(name='event_type'),
  latestEventTime?: string(name='latest_event_time'),
  resourceCategory?: int32(name='resource_category'),
  resourceList?: [  map[string]any ](name='resource_list'),
  totalResourceCount?: long(name='total_resource_count'),
  userId?: string(name='user_id'),
}

model Address {
  city?: string(name='city', example='杭州市'),
  country?: string(name='country', example='中国'),
  district?: string(name='district', example='余杭区'),
  province?: string(name='province', example='浙江省'),
  township?: string(name='township', example='文一西路'),
}

model AddressGroup {
  addressDetail?: Address(name='address_detail'),
  count?: long(name='count'),
  coverFileId?: string(name='cover_file_id'),
  coverUrl?: string(name='cover_url'),
  location?: string(name='location'),
  name?: string(name='name'),
}

model Aggregation {
  field?: bytes(name='field'),
  groups?: [
    AggregationsGroup
  ](name='groups'),
  operation?: bytes(name='operation'),
  value?: double(name='value'),
}

model AggregationsGroup {
  count?: long(name='count'),
  value?: bytes(name='value'),
}

model Album {
  albumId?: string(name='album_id'),
  baseFaceFile?: File(name='base_face_file'),
  baseFaceGroupId?: string(name='base_face_group_id'),
  coverFile?: File(name='cover_file'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  fileCount?: long(name='file_count'),
  name?: string(name='name'),
  owner?: string(name='owner'),
  updatedAt?: string(name='updated_at'),
  userTags?: map[string]string(name='user_tags'),
}

model AlbumFile {
  albumId?: string(name='album_id'),
  category?: string(name='category'),
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  contentType?: string(name='content_type'),
  crc64Hash?: string(name='crc64_hash'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  downloadUrl?: string(name='download_url'),
  driveId?: string(name='drive_id'),
  exFieldsInfo?: map[string]any(name='ex_fields_info'),
  fileExtension?: string(name='file_extension'),
  fileId?: string(name='file_id'),
  hidden?: boolean(name='hidden'),
  imageMediaMetadata?: ImageMediaMetadata(name='image_media_metadata'),
  investigationInfo?: InvestigationInfo(name='investigation_info'),
  joinedAt?: long(name='joined_at'),
  labels?: [ string ](name='labels'),
  localCreatedAt?: string(name='local_created_at'),
  localModifiedAt?: string(name='local_modified_at'),
  mimeType?: string(name='mime_type'),
  name?: string(name='name'),
  objectUri?: string(name='object_uri'),
  parentFileId?: string(name='parent_file_id'),
  revisionId?: string(name='revision_id'),
  size?: long(name='size'),
  starred?: boolean(name='starred'),
  status?: string(name='status'),
  thumbnail?: string(name='thumbnail'),
  thumbnailUrls?: map[string]string(name='thumbnail_urls'),
  transhedAt?: string(name='transhed_at'),
  type?: string(name='type'),
  updatedAt?: string(name='updated_at'),
  uploadId?: string(name='upload_id'),
  userMeta?: string(name='user_meta'),
}

model App {
  appId?: string(name='app_id'),
  appName?: string(name='app_name'),
  appSecret?: string(name='app_secret'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  logo?: string(name='logo'),
  provider?: string(name='provider'),
  redirectUri?: string(name='redirect_uri'),
  scope?: [ string ](name='scope'),
  stage?: string(name='stage'),
  type?: string(name='type'),
  updatedAt?: string(name='updated_at'),
}

model AppAccessStrategy {
  effect?: string(name='effect'),
  exceptAppIdList?: [ string ](name='except_app_id_list'),
}

model ArchiveFilesConfigResponse {
  enabled?: boolean(name='enabled'),
  version?: string(name='version'),
}

model AuditLog {
  actedAt?: string(name='acted_at'),
  actionCategory?: string(name='action_category'),
  actionType?: string(name='action_type'),
  actorId?: string(name='actor_id'),
  actorName?: string(name='actor_name'),
  actorType?: string(name='actor_type'),
  clientDevice?: string(name='client_device'),
  clientIp?: string(name='client_ip'),
  clientType?: string(name='client_type'),
  clientVersion?: string(name='client_version'),
  detail?: AuditLogDetail(name='detail'),
  filePathType?: string(name='file_path_type'),
  logId?: string(name='log_id'),
  objectId?: string(name='object_id'),
  objectName?: string(name='object_name'),
}

model AuditLogDetail {
  driveLogDetail?: DriveLogDetail(name='drive_log_detail'),
  fileLogDetail?: FileLogDetail(name='file_log_detail'),
  userLogDetail?: UserLogDetail(name='user_log_detail'),
}

model BaseAlbumFileOperationResult {
  errorCode?: string(name='error_code'),
  errorMessage?: string(name='error_message'),
  file?: CommonFileItem(name='file'),
  isSucceed?: boolean(name='is_succeed'),
}

model BaseAssignmentResponse {
  associatedRoleTagId?: string(name='associated_role_tag_id'),
  createdAt?: string(name='created_at'),
  creator?: string(name='creator'),
  disinheritSubGroup?: boolean(name='disinherit_sub_group'),
  domainId?: string(name='domain_id'),
  identity?: Identity(name='identity'),
  manageResourceId?: string(name='manage_resource_id'),
  manageResourceType?: string(name='manage_resource_type'),
  roleId?: string(name='role_id'),
  updatedAt?: string(name='updated_at'),
}

model BaseDomainResponse {
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  domainName?: string(name='domain_name'),
  initDriveEnable?: boolean(name='init_drive_enable'),
  initDriveSize?: long(name='init_drive_size'),
  parentDomainId?: string(name='parent_domain_id'),
  publishedAppAccessStrategy?: AppAccessStrategy(name='published_app_access_strategy'),
  shareLinkEnabled?: boolean(name='share_link_enabled'),
  sizeQuota?: long(name='size_quota'),
  sizeQuotaUsed?: long(name='size_quota_used'),
  status?: long(name='status'),
  updatedAt?: string(name='updated_at'),
  usedSize?: long(name='used_size'),
}

model BaseDriveResponse {
  actionList?: [ string ](name='action_list'),
  category?: string(name='category'),
  createdAt?: string(name='created_at'),
  creator?: string(name='creator', example='ccp'),
  deltaEnabled?: boolean(name='delta_enabled'),
  description?: string(name='description', example='ccp team drive'),
  domainId?: string(name='domain_id', example='hz999'),
  driveId?: string(name='drive_id', example='123'),
  driveName?: string(name='drive_name', example='ccpdrive'),
  driveType?: string(name='drive_type', example='normal'),
  encryptDataAccess?: boolean(name='encrypt_data_access'),
  encryptMode?: string(name='encrypt_mode'),
  isHandover?: boolean(name='is_handover'),
  owner?: string(name='owner', example='ccp'),
  ownerType?: string(name='owner_type', example='user'),
  pathStatus?: string(name='path_status'),
  permission?: map[string]IDPermission(name='permission'),
  relativePath?: string(name='relative_path'),
  status?: string(name='status', example='enabled'),
  storeId?: string(name='store_id', example='123'),
  totalSize?: long(name='total_size', example='102400'),
  updatedAt?: string(name='updated_at'),
  usedSize?: long(name='used_size', example='1024'),
}

model BaseGroupResponse {
  createdAt?: long(name='created_at', example='111111'),
  creator?: string(name='creator', example='system'),
  description?: string(name='description', example='desc-111'),
  domainId?: string(name='domain_id', example='bj123'),
  groupId?: string(name='group_id', example='b38b5681bd964950ad8bc0f8ea504793'),
  groupName?: string(name='group_name', example='name-111'),
  isSync?: boolean(name='is_sync'),
  permission?: map[string]IDPermission(name='permission'),
  updatedAt?: string(name='updated_at', example='111111'),
}

model BaseRoleMemberResponse {
  assignmentList?: [
    BaseAssignmentResponse
  ](name='assignment_list'),
  createdAt?: string(name='created_at'),
  creator?: string(name='creator'),
  domainId?: string(name='domain_id'),
  identity?: Identity(name='identity'),
  identityName?: string(name='identity_name'),
  isAdmin?: boolean(name='is_admin'),
  subdomainId?: string(name='subdomain_id'),
}

model BaseUserResponse {
  avatar?: string(name='avatar', example='http://a.b.c/ccp.jpg'),
  createdAt?: string(name='created_at', example='1567407718386'),
  creator?: string(name='creator', example='system'),
  defaultDriveId?: string(name='default_drive_id', example='123'),
  defaultLocation?: string(name='default_location'),
  denyChangePasswordBySelf?: boolean(name='deny_change_password_by_self'),
  description?: string(name='description', example='ccp team user'),
  domainId?: string(name='domain_id', example='hz999'),
  email?: string(name='email', example='123@ccp.com'),
  expiredAt?: long(name='expired_at', example='0'),
  isSync?: boolean(name='is_sync'),
  lastLoginTime?: long(name='last_login_time'),
  needChangePasswordNextLogin?: boolean(name='need_change_password_next_login'),
  nickName?: string(name='nick_name', example='abc'),
  pathStatus?: string(name='path_status'),
  permission?: map[string]IDPermission(name='permission'),
  phone?: string(name='phone', example='13700000000'),
  phoneRegion?: string(name='phone_region'),
  role?: string(name='role', example='user'),
  status?: string(name='status', example='enabled'),
  updatedAt?: string(name='updated_at', example='1567407718386'),
  userData?: map[string]any(name='user_data'),
  userId?: string(name='user_id', example='ccpuserid'),
  userName?: string(name='user_name', example='name'),
}

model BenefitPkgDeliveryInfo {
  amount?: long(name='amount'),
  createdAt?: string(name='created_at'),
  expireTime?: string(name='expire_time'),
  isPermanent?: boolean(name='is_permanent'),
}

model CNameStatus {
  bingdingState?: string(name='bingding_state', example='BINDING/BOUND'),
  legalState?: string(name='legal_state', example='NORMAL/ABNORMAL'),
  remark?: string(name='remark', example='beian'),
}

model CdnFileDownloadCallbackInfo {
  bucket?: string(name='bucket', description='This parameter is required.', example='ccp-bj1-bj-1234'),
  domainId?: string(name='domain_id', description='This parameter is required.'),
  driveId?: string(name='drive_id', description='This parameter is required.'),
  expire?: long(name='expire', description='This parameter is required.'),
  fileId?: string(name='file_id', description='This parameter is required.'),
  object?: string(name='object', description='This parameter is required.'),
  token?: string(name='token', description='This parameter is required.', example='md5.Sum([]byte(fmt.Sprintf("%v%v%v%v%v%v...%v", 		req.Object, req.Range, req.DomainID, req.DriveID, req.UserID, req.FileID, req.Expire)))'),
  userId?: string(name='user_id', description='This parameter is required.'),
}

model CertInfo {
  certBody?: string(name='cert_body', example='xxx'),
  certName?: string(name='cert_name', example='xxx'),
  certPrivatekey?: string(name='cert_privatekey', example='xxx'),
}

model ClearRecycleBinItem {
  asyncTaskId?: string(name='async_task_id'),
  domainId?: string(name='domain_id'),
  driveId?: string(name='drive_id'),
  taskId?: string(name='task_id'),
}

model CommonFileItem {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  revisionId?: string(name='revision_id'),
}

model CssCreateOrderParam {
  agentId?: string(name='agentId'),
  autoPay?: boolean(name='autoPay'),
  autoUseCoupon?: boolean(name='autoUseCoupon'),
  bid?: string(name='bid'),
  buyerId?: long(name='buyerId'),
  certificate?: string(name='certificate'),
  childId?: long(name='childId'),
  cilentIp?: string(name='cilentIp'),
  commodities?: [
    CssInstanceCommodity
  ](name='commodities'),
  createrNick?: string(name='createrNick'),
  cssAuthRequestParam?: any(name='cssAuthRequestParam'),
  fromApp?: string(name='fromApp'),
  language?: string(name='language'),
  marketType?: long(name='marketType'),
  memo?: string(name='memo'),
  orderOrigin?: string(name='orderOrigin'),
  orderParams?: map[string]string(name='orderParams'),
  payerId?: long(name='payerId'),
  planGroupId?: long(name='planGroupId'),
  planId?: long(name='planId'),
  planInstanceId?: string(name='planInstanceId'),
  promotionCode?: string(name='promotionCode'),
  promotionInputParam?: any(name='promotionInputParam'),
  requestId?: string(name='requestId'),
  skipChannel?: boolean(name='skipChannel'),
  token?: string(name='token'),
  transientAccess?: any(name='transientAccess'),
  umidToken?: string(name='umidToken'),
  userId?: long(name='userId'),
}

model CssInstanceCommodity {
  activityId?: long(name='activityId'),
  aliyunProduceCode?: string(name='aliyunProduceCode'),
  chargeType?: string(name='chargeType'),
  commodityCode?: string(name='commodityCode'),
  components?: [
    CssInstanceComponent
  ](name='components'),
  duration?: long(name='duration'),
  instanceId?: string(name='instanceId'),
  isFree?: boolean(name='isFree'),
  isPrePayPostCharge?: boolean(name='isPrePayPostCharge'),
  isRenewChange?: boolean(name='isRenewChange'),
  isSyncToSubscription?: boolean(name='isSyncToSubscription'),
  orderParams?: map[string]string(name='orderParams'),
  orderType?: string(name='orderType'),
  planItemId?: long(name='planItemId'),
  pricingCycle?: string(name='pricingCycle'),
  quantity?: long(name='quantity'),
  redeemNoList?: [ string ](name='redeemNoList'),
  redeemOrderType?: string(name='redeemOrderType'),
  refundSpecCode?: string(name='refundSpecCode'),
  specCode?: string(name='specCode'),
  specUpgradeOriginSpecCodes?: [ string ](name='specUpgradeOriginSpecCodes'),
  specifyStartDate?: long(name='specifyStartDate'),
  upgradeInquireFinancialValue?: boolean(name='upgradeInquireFinancialValue'),
}

model CssInstanceComponent {
  componentCode?: string(name='componentCode'),
  componentName?: string(name='componentName'),
  globalKey?: string(name='globalKey'),
  instanceProperty?: [
    CssInstanceProperty
  ](name='instanceProperty'),
  moduleAttrStatus?: long(name='moduleAttrStatus'),
  tag?: string(name='tag'),
}

model CssInstanceProperty {
  code?: string(name='code'),
  globalKey?: string(name='globalKey'),
  name?: string(name='name'),
  unit?: string(name='unit'),
  value?: string(name='value'),
}

model CssProduce {
  bid?: string(name='bid'),
  buyerId?: long(name='buyerId'),
  childId?: long(name='childId'),
  fromApp?: string(name='fromApp'),
  orderId?: long(name='orderId'),
  payerId?: long(name='payerId'),
  purchases?: [
    CssPurchase
  ](name='purchases'),
  requestId?: string(name='requestId'),
  skipChannel?: boolean(name='skipChannel'),
  token?: string(name='token'),
  userId?: long(name='userId'),
}

model CssPurchase {
  chargeType?: string(name='chargeType'),
  commodityCode?: string(name='commodityCode'),
  endDate?: long(name='endDate'),
  gmtCreate?: long(name='gmtCreate'),
  instanceComponents?: [
    CssInstanceComponent
  ](name='instanceComponents'),
  instanceId?: string(name='instanceId'),
  orderType?: string(name='orderType'),
  purchaseParams?: map[string]string(name='purchaseParams'),
  startDate?: long(name='startDate'),
}

model CustomSideLinkConfig {
  icon?: string(name='icon'),
  link?: string(name='link'),
  text?: string(name='text'),
}

model DataBoxPrivileges {
  featureAttrId?: string(name='feature_attr_id'),
  featureId?: string(name='feature_id'),
  quota?: long(name='quota'),
}

model DataCName {
  certExpireTime?: long(name='cert_expire_time'),
  certName?: string(name='cert_name'),
  cname?: string(name='cname'),
  cnameType?: string(name='cname_type'),
  location?: string(name='location'),
  storeId?: string(name='store_id'),
}

model Domain {
  createdAt?: string(name='created_at'),
  dataHashName?: string(name='data_hash_name'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  domainName?: string(name='domain_name'),
  initDriveEnable?: boolean(name='init_drive_enable'),
  initDriveSize?: long(name='init_drive_size'),
  parentDomainId?: string(name='parent_domain_id'),
  publishedAppAccessStrategy?: AppAccessStrategy(name='published_app_access_strategy'),
  sharable?: boolean(name='sharable'),
  sizeQuota?: long(name='size_quota'),
  sizeQuotaUsed?: long(name='size_quota_used'),
  status?: long(name='status'),
  updatedAt?: string(name='updated_at'),
  usedSize?: long(name='used_size'),
  userCountQuota?: long(name='user_count_quota'),
}

model DomainAppConfig {
  allowUploadCustomFileExtList?: [ string ](name='allow_upload_custom_file_ext_list'),
  allowUploadFileCategoryList?: [ string ](name='allow_upload_file_category_list'),
  sameNameFileUploadMode?: string(name='same_name_file_upload_mode'),
  singleFileUploadSizeLimit?: long(name='single_file_upload_size_limit'),
  webClientDownloadMode?: string(name='web_client_download_mode'),
}

model DomainBuildClientConfig {
  copyright?: string(name='copyright'),
  name?: string(name='name'),
}

model DomainEndpoints {
}

model DomainSeniorConfig {
  clientDownloadEnable?: boolean(name='client_download_enable'),
  cspFrameAncestors?: string(name='csp_frame_ancestors'),
  customLoginAppid?: string(name='custom_login_appid'),
  customLoginUrl?: string(name='custom_login_url'),
  customLogoutUrl?: string(name='custom_logout_url'),
  customSideLinkList?: [
    CustomSideLinkConfig
  ](name='custom_side_link_list'),
  homePageBgImageUrl?: string(name='home_page_bg_image_url'),
  homePageFooter?: string(name='home_page_footer'),
  homePageFooter2?: string(name='home_page_footer2'),
  homePageSlogan?: string(name='home_page_slogan'),
  refererEnable?: boolean(name='referer_enable'),
  wxTxtList?: WxTrustedDomainConfig(name='wx_txt_list'),
}

model Drive {
  createdAt?: string(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  driveId?: string(name='drive_id'),
  driveName?: string(name='drive_name'),
  driveType?: string(name='drive_type'),
  owner?: string(name='owner'),
  ownerType?: string(name='owner_type'),
  status?: string(name='status'),
  totalSize?: long(name='total_size'),
  usedSize?: long(name='used_size'),
}

model DriveLogDetail {
  forceDelete?: boolean(name='force_delete'),
  handoverOwnerName?: string(name='handover_owner_name'),
  name?: string(name='name'),
  ownerId?: string(name='owner_id'),
  ownerName?: string(name='owner_name'),
  ownerType?: string(name='owner_type'),
  totalSize?: long(name='total_size'),
  updateTo?: {
    name?: string(name='name'),
    ownerId?: string(name='owner_id'),
    ownerName?: string(name='owner_name'),
    ownerType?: string(name='owner_type'),
    totalSize?: long(name='total_size'),
  }(name='update_to'),
}

model ExternalMultiFileRevisionConfig {
  revisionCount?: long(name='revision_count'),
  revisionMergeEnabled?: boolean(name='revision_merge_enabled'),
  revisionRecyclePeriod?: long(name='revision_recycle_period'),
}

model FaceGroup {
  createdAt?: string(name='created_at', example='2022-01-14T10:10:52.83948013+08:00'),
  groupCoverFaceBoundary?: {
    height?: int32(name='Height', example='300'),
    left?: int32(name='Left', example='10'),
    top?: int32(name='Top', example='30'),
    width?: int32(name='Width', example='200'),
  }(name='group_cover_face_boundary'),
  groupCoverFileId?: string(name='group_cover_file_id', example='6549c959640fbd517c9b4d93b3b36aecc45xxxxx'),
  groupCoverHeight?: long(name='group_cover_height', example='1080'),
  groupCoverUrl?: string(name='group_cover_url', example='https://xxx'),
  groupCoverWidth?: long(name='group_cover_width', example='1920'),
  groupId?: string(name='group_id', example='Cluster-ae6e3472-999e-410b-b54e-cd5dba****'),
  groupName?: string(name='group_name', example='name'),
  imageCount?: long(name='image_count', example='10'),
  remarks?: string(name='remarks'),
  updatedAt?: string(name='updated_at', example='2022-01-14T10:10:52.83948013+08:00'),
}

model FaceThumbnail {
  faceGroupId?: string(name='face_group_id', example='Cluster-e3b7fb52-22b3-44f2-9746-8c1804bd6af0'),
  faceId?: string(name='face_id', example='a9a66a86-73dd-4c95-8b79-1d8a49db5226'),
  faceThumbnail?: string(name='face_thumbnail', example='https://pds-domain.region.aliyuncs.com/QieGeH98%2F1001%2F63e5e551ee621482ab934a0687c6cda75fc07864%2F642a8a40c00f1ad379df421694713ee65170f09b?security-token=CAIS%2BgF1q6Ft5B2yfSjIr5bjHPCNnrdR8aSaSW7woVlmVd1Bt5HorDz2IHpPfHdoBe0btvU%2BlWxX6fwZlq5rR4QAXlDfNSyFeX20qFHPWZHInuDox55m4cTXNAr%2BIhr%2F29CoEIedZdjBe%2FCrRknZnytou9XTfimjWFrXWv%2Fgy%2BQQDLItUxK%2FcCBNCfpPOwJms7V6D3bKMuu3OROY6Qi5TmgQ41En1DIlt%2FXuk5DCtkqB12eXkLFF%2B97DRbG%2FdNRpMZtFVNO44fd7bKKp0lQLsUMSqv8q0fEcqGaW4o7CWQJLnzyCMvvJ9OVDFyN0aKEnH7J%2Bq%2FzxhTPrMnpkSlacGoABPMvZ8rSESUEP96Vbf%2Bk0JRg9Qb1MnaIJqWAgo8K6K0UP1CtqL2zrUtugpKKDHOYiKbq2O0S5yLUPVX5vBHqEi%2FFc7i6ZnHCMcXLJs4rKDKwRBEhovUXXlklq2q43OSVtLrXkBy9Xs1ers%2FhJhcxpNA0Vl3EWfJxa2BTylEdnLOQ%3D&x-oss-access-key-id=STS.NUVWJ9shpFfqKHAEY3YRmXTCN&x-oss-expires=1686455451&x-oss-process=image%2Fcrop%2Cx_1128%2Cy_1211%2Cw_914%2Ch_914%2Fformat%2Cjpg&x-oss-signature=jmhOz91Tww1ciMEwadDiioU7d93FDiBNr8s8mHyMqW0%3D&x-oss-signature-version=OSS2', deprecated=true),
}

model File {
  category?: string(name='category'),
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  contentType?: string(name='content_type'),
  crc64Hash?: string(name='crc64_hash'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  downloadUrl?: string(name='download_url'),
  driveId?: string(name='drive_id'),
  fileExtension?: string(name='file_extension'),
  fileId?: string(name='file_id'),
  hidden?: boolean(name='hidden'),
  imageMediaMetadata?: ImageMediaMetadata(name='image_media_metadata'),
  labels?: [ string ](name='labels'),
  localCreatedAt?: string(name='local_created_at'),
  localModifiedAt?: string(name='local_modified_at'),
  name?: string(name='name'),
  parentFileId?: string(name='parent_file_id'),
  revisionId?: string(name='revision_id'),
  size?: long(name='size'),
  starred?: boolean(name='starred'),
  status?: string(name='status'),
  thumbnail?: string(name='thumbnail'),
  thumbnailUrls?: map[string]string(name='thumbnail_urls'),
  trashedAt?: string(name='trashed_at'),
  type?: string(name='type'),
  updatedAt?: string(name='updated_at'),
  uploadId?: string(name='upload_id'),
  userTags?: map[string]string(name='user_tags'),
  videoMediaMetadata?: VideoMediaMetadata(name='video_media_metadata'),
}

model FileDownloadCallbackInfo {
  bucket?: string(name='bucket', description='This parameter is required.', example='ccp-bj1-bj-1234'),
  domainId?: string(name='domain_id', description='This parameter is required.'),
  driveId?: string(name='drive_id', description='This parameter is required.'),
  fileId?: string(name='file_id', description='This parameter is required.'),
  object?: string(name='object', description='This parameter is required.'),
  userId?: string(name='user_id', description='This parameter is required.'),
}

model FileLogDetail {
  decompressFileList?: [ string ](name='decompress_file_list'),
  newName?: string(name='new_name'),
  parentPath?: string(name='parent_path'),
  revVersion?: long(name='rev_version'),
  revisionId?: string(name='revision_id'),
  size?: long(name='size'),
  toParentPath?: string(name='to_parent_path'),
  toParentPathType?: string(name='to_parent_path_type'),
  type?: string(name='type'),
}

model FilePermissionMember {
  actionList?: [ string ](name='action_list'),
  disinheritSubGroup?: boolean(name='disinherit_sub_group'),
  expireTime?: long(name='expire_time'),
  identity?: Identity(name='identity'),
  roleId?: string(name='role_id'),
}

model FileStreamInfo {
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  contentMd5?: string(name='content_md5'),
  partInfoList?: UploadPartInfo(name='part_info_list'),
  preHash?: string(name='pre_hash'),
  proofCode?: string(name='proof_code'),
  proofVersion?: string(name='proof_version'),
  size?: long(name='size'),
}

model GetOfficeEditUrlOption {
  copy?: boolean(name='copy'),
  print?: boolean(name='print'),
  readonly?: boolean(name='readonly'),
}

model GetOfficeEditUrlWatermark {
  fillstyle?: string(name='fillstyle'),
  font?: string(name='font'),
  horizontal?: long(name='horizontal'),
  rotate?: double(name='rotate'),
  type?: int32(name='type'),
  value?: string(name='value'),
  vertical?: long(name='vertical'),
}

model GetOfficePreviewUrlOption {
  copy?: boolean(name='copy'),
  print?: boolean(name='print'),
}

model Group {
  createdAt?: long(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  groupId?: string(name='group_id'),
  groupName?: string(name='group_name'),
  updatedAt?: long(name='updated_at'),
}

model IDPermission {
  disinheritSubGroup?: boolean(name='disinherit_sub_group'),
  expireTime?: long(name='expire_time'),
  permission?: Permission(name='permission', nullable=false),
  roles?: [ string ](name='roles'),
}

model Identity {
  identityId?: string(name='identity_id'),
  identityType?: string(name='identity_type', example='IT_User'),
}

model IdentityToBenefitPkgMapping {
  benefitPkgComputationRule?: string(name='benefit_pkg_computation_rule'),
  benefitPkgId?: string(name='benefit_pkg_id'),
  benefitPkgName?: string(name='benefit_pkg_name'),
  benefitPkgOwnerId?: string(name='benefit_pkg_owner_id'),
  benefitPkgPriority?: long(name='benefit_pkg_priority'),
  benefitPkgType?: string(name='benefit_pkg_type'),
  createdAt?: string(name='created_at'),
  deliveryInfoList?: [
    BenefitPkgDeliveryInfo
  ](name='delivery_info_list'),
  identityId?: string(name='identity_id'),
  identityType?: string(name='identity_type'),
  updatedAt?: string(name='updated_at'),
}

model ImageMediaMetadata {
  addressLine?: string(name='address_line', example='浙江省杭州市滨江区西兴街道江陵路'),
  city?: string(name='city', example='杭州市'),
  country?: string(name='country', example='中国'),
  district?: string(name='district', example='滨江区'),
  exif?: string(name='exif', example='{"Compression":{"value":"6"},"DateTime":{"value":"2020:08:19 17:11:11"}}'),
  facesThumbnail?: [
    FaceThumbnail
  ](name='faces_thumbnail'),
  height?: long(name='height', example='1080'),
  imageQuality?: ImageQuality(name='image_quality'),
  imageTags?: [
    SystemTag
  ](name='image_tags'),
  location?: string(name='location', example='30.185453,120.218522'),
  province?: string(name='province', example='浙江省'),
  time?: string(name='time', example='2006-01-02T15:04:05.000Z07:00'),
  township?: string(name='township', example='西兴街道'),
  width?: long(name='width', example='1920'),
}

model ImageProcess {
  imageThumbnailProcess?: string(name='image_thumbnail_process'),
  officeThumbnailProcess?: string(name='office_thumbnail_process'),
  videoThumbnailProcess?: string(name='video_thumbnail_process'),
}

model ImageQuality {
  overallScore?: double(name='overall_score', example='0.736'),
}

model ImageTag {
  count?: long(name='count', example='10'),
  coverFileCategory?: string(name='cover_file_category', example='image'),
  coverFileId?: string(name='cover_file_id', example='5d79206586bb5dd69fb34c349282718146c55da7'),
  coverOverallScore?: float(name='cover_overall_score', example='0.736'),
  coverTagConfidence?: float(name='cover_tag_confidence', example='1'),
  coverUrl?: string(name='cover_url', example='https://data.aliyunpds.com/hz22%2F5d5b986facbec311ef844c25954f96821497b383%2F5d5b986f955410dd991646bb87c6b4e899eff525?Expires=xxx&OSSAccessKeyId=xxx&Signature=xxx'),
  name?: string(name='name', example='动物'),
}

model Int64Range {
  from?: long(name='from'),
  to?: long(name='to'),
}

model InvestigationInfo {
  status?: long(name='status'),
  suggestion?: string(name='suggestion'),
  videoDetail?: {
    blockFrames?: [ 
      {
        label?: string(name='label'),
        offset?: long(name='offset'),
        rate?: double(name='rate'),
      }
    ](name='block_frames'),
  }(name='video_detail'),
}

model JWTPayload {
  aud?: string(name='aud'),
  autoCreate?: boolean(name='auto_create'),
  exp?: long(name='exp'),
  iat?: long(name='iat'),
  iss?: string(name='iss'),
  jti?: string(name='jti'),
  nbf?: long(name='nbf'),
  sub?: string(name='sub'),
  subType?: string(name='sub_type'),
}

model KnowledgeFile {
  creatorId?: string(name='creator_id'),
  driveId?: string(name='drive_id'),
  driveName?: string(name='drive_name'),
  fileCategory?: string(name='file_category'),
  fileCreatedAt?: long(name='file_created_at'),
  fileCreatorId?: string(name='file_creator_id'),
  fileId?: string(name='file_id'),
  fileImageTime?: long(name='file_image_time'),
  fileLastModifierId?: string(name='file_last_modifier_id'),
  fileLastModifierType?: string(name='file_last_modifier_type'),
  fileName?: string(name='file_name'),
  fileNamePath?: string(name='file_name_path'),
  fileSize?: long(name='file_size'),
  fileUpdatedAt?: long(name='file_updated_at'),
  joinedAt?: long(name='joined_at'),
  knowledgeBaseId?: string(name='knowledge_base_id'),
  knowledgeCategoryId?: string(name='knowledge_category_id'),
  revisionId?: string(name='revision_id'),
}

model KnowledgeFileItem {
  driveId?: string(name='drive_id', description='This parameter is required.'),
  fileId?: string(name='file_id', description='This parameter is required.'),
}

model LinkInfo {
  extra?: string(name='extra'),
  identity?: string(name='identity'),
  type?: string(name='type'),
}

model LocationDateCluster {
  address?: Address(name='address'),
  clusterId?: string(name='cluster_id'),
  createdAt?: string(name='created_at'),
  customLabels?: map[string]string(name='custom_labels'),
  driveId?: string(name='drive_id'),
  endTime?: string(name='end_time'),
  level?: string(name='level'),
  startTime?: string(name='start_time'),
  title?: string(name='title'),
  updatedAt?: string(name='updated_at'),
}

model Membership {
  createdAt?: long(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  groupId?: string(name='group_id'),
  memberRole?: string(name='member_role'),
  memberType?: string(name='member_type'),
  subGroupId?: string(name='sub_group_id'),
  updatedAt?: long(name='updated_at'),
  userId?: string(name='user_id'),
}

model NameCheckResult {
  existFileId?: string(name='exist_file_id'),
  existFileType?: string(name='exist_file_type'),
}

model OfficeEditConfig {
  enabled?: boolean(name='enabled'),
}

model OfficePreviewConfig {
  enabled?: boolean(name='enabled'),
}

model Permission {
  actionList?: [ 
    {
      action?: string(name='action'),
    }
  ](name='action_list'),
  collection?: string(name='collection'),
  condition?: PermissionCondition(name='condition'),
  createdAt?: long(name='created_at'),
  effect?: string(name='effect'),
  identityId?: string(name='identity_id'),
  identityType?: string(name='identity_type'),
  resource?: string(name='resource'),
  resourceType?: string(name='resource_type'),
  updatedAt?: long(name='updated_at'),
  userTags?: [ string ](name='user_tags'),
}

model PermissionCondition {
  ipEquals?: {
    clientIp?: [ string ](name='client_ip'),
  }(name='ip_equals'),
  ipNotEquals?: {
    clientIp?: [ string ](name='client_ip'),
  }(name='ip_not_equals'),
  stringLike?: {
    vpcId?: [ string ](name='vpc_id'),
  }(name='string_like'),
  stringNotLike?: {
    vpcId?: [ string ](name='vpc_id'),
  }(name='string_not_like'),
}

model PersonalRightsInfoResponse {
  expiresTime?: string(name='expires_time'),
  historyLatestRights?: PersonalRightsInfoResponse(name='history_latest_rights'),
  icon?: string(name='icon'),
  isExpires?: boolean(name='is_expires'),
  name?: string(name='name'),
  otherRights?: PersonalRightsInfoResponse(name='other_rights'),
  privileges?: [
    DataBoxPrivileges
  ](name='privileges'),
  spuId?: string(name='spu_id'),
  title?: string(name='title'),
}

model PersonalSpaceInfo {
  totalSize?: long(name='total_size'),
  usedSize?: long(name='used_size'),
}

model RecycleBinConfig {
  autoDeleteEnabled?: boolean(name='auto_delete_enabled'),
  autoDeleteKeepSecond?: int32(name='auto_delete_keep_second'),
  deleteTrashNormalFileDisabled?: boolean(name='delete_trash_normal_file_disabled'),
}

model RefundNoticeParam {
  aliuid?: long(name='aliuid'),
  aliyunProduceCode?: string(name='aliyunProduceCode'),
  commodityCode?: string(name='commodityCode'),
  instanceId?: string(name='instanceId'),
  newExpireTime?: any(name='newExpireTime'),
  orderIds?: [ long ](name='orderIds'),
  refundParamMap?: map[string]string(name='refundParamMap'),
  refundType?: string(name='refundType'),
}

model Revision {
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  crc64Hash?: string(name='crc64_hash'),
  createdAt?: string(name='created_at'),
  creatorId?: string(name='creator_id'),
  creatorName?: string(name='creator_name'),
  domainId?: string(name='domain_id'),
  downloadUrl?: string(name='download_url'),
  driveId?: string(name='drive_id'),
  fileExtension?: string(name='file_extension'),
  fileId?: string(name='file_id'),
  isLatestVersion?: boolean(name='is_latest_version'),
  keepForever?: boolean(name='keep_forever'),
  revisionDescription?: string(name='revision_description'),
  revisionId?: string(name='revision_id'),
  revisionName?: string(name='revision_name'),
  revisionVersion?: long(name='revision_version'),
  size?: long(name='size'),
  thumbnail?: string(name='thumbnail'),
  updatedAt?: string(name='updated_at'),
  url?: string(name='url'),
}

model Role {
  createdAt?: long(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  manageResourceType?: string(name='manage_resource_type'),
  name?: string(name='name'),
  permissions?: [
    Permission
  ](name='permissions'),
  roleId?: string(name='role_id'),
  status?: string(name='status'),
  updatedAt?: long(name='updated_at'),
}

model SearchFromThirdPartyItem {
  authenticationType?: string(name='authentication_type'),
  extra?: string(name='extra'),
  identity?: string(name='identity'),
  others?: map[string]any(name='others'),
}

model ShareLink {
  accessCount?: long(name='access_count'),
  createdAt?: string(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  disableDownload?: boolean(name='disable_download'),
  disablePreview?: boolean(name='disable_preview'),
  disableSave?: boolean(name='disable_save'),
  downloadCount?: long(name='download_count'),
  downloadLimit?: long(name='download_limit'),
  driveId?: string(name='drive_id'),
  expiration?: string(name='expiration'),
  expired?: boolean(name='expired'),
  fileIdList?: [ string ](name='file_id_list'),
  previewCount?: long(name='preview_count'),
  previewLimit?: long(name='preview_limit'),
  reportCount?: long(name='report_count'),
  saveCount?: long(name='save_count'),
  saveDownloadLimit?: long(name='save_download_limit'),
  saveLimit?: long(name='save_limit'),
  shareAllFiles?: boolean(name='share_all_files'),
  shareId?: string(name='share_id'),
  shareName?: string(name='share_name'),
  sharePwd?: string(name='share_pwd'),
  status?: string(name='status'),
  updatedAt?: string(name='updated_at'),
  videoPreviewCount?: long(name='video_preview_count'),
}

model ShareLinkConfig {
  enableShareLinkOfficeEdit?: boolean(name='enable_share_link_office_edit'),
}

model ShareLinkDetail {
  enableOfficeEditable?: boolean(name='enable_office_editable'),
}

model SimpleQuery {
  field?: bytes(name='field'),
  operation?: bytes(name='operation'),
  subQueries?: [
    SimpleQuery
  ](name='sub_queries'),
  value?: bytes(name='value'),
}

model SimpleStreamInfo {
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  crc64Hash?: string(name='crc64_hash'),
  downloadUrl?: string(name='download_url'),
  size?: long(name='size'),
  thumbnail?: string(name='thumbnail'),
  url?: string(name='url'),
}

model Story {
  coverFileId?: string(name='cover_file_id'),
  coverFileThumbnailUrl?: string(name='cover_file_thumbnail_url'),
  createdAt?: string(name='created_at'),
  customLabels?: map[string]any(name='custom_labels'),
  faceGroupIds?: [ string ](name='face_group_ids'),
  storyEndTime?: string(name='story_end_time'),
  storyFileList?: [
    File
  ](name='story_file_list'),
  storyId?: string(name='story_id'),
  storyName?: string(name='story_name'),
  storyStartTime?: string(name='story_start_time'),
  storySubType?: string(name='story_sub_type'),
  storyType?: string(name='story_type'),
  updatedAt?: string(name='updated_at'),
}

model SystemTag {
  centricScore?: float(name='centric_score', example='0.877'),
  confidence?: float(name='confidence', example='0.98'),
  name?: string(name='name', example='篮球'),
  parentName?: string(name='parent_name', example='运动'),
  tagLevel?: int32(name='tag_level', example='3'),
}

model TimeRange {
  end?: string(name='end'),
  start?: string(name='start'),
}

model Token {
  accessToken?: string(name='access_token'),
  avatar?: string(name='avatar'),
  defaultDriveId?: string(name='default_drive_id'),
  deviceId?: string(name='device_id'),
  deviceName?: string(name='device_name'),
  domainId?: string(name='domain_id'),
  expireTime?: string(name='expire_time'),
  expiresIn?: long(name='expires_in'),
  isFirstLogin?: boolean(name='is_first_login'),
  nickName?: string(name='nick_name'),
  refreshToken?: string(name='refresh_token'),
  role?: string(name='role'),
  status?: string(name='status'),
  tokenType?: string(name='token_type'),
  userId?: string(name='user_id'),
  userName?: string(name='user_name'),
}

model UncompressConfigResponse {
  enabled?: boolean(name='enabled'),
  version?: string(name='version'),
}

model UncompressedFileInfo {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  isFolder?: boolean(name='is_folder'),
  items?: [
    UncompressedFileInfo
  ](name='items'),
  name?: string(name='name'),
  size?: long(name='size'),
  updatedAt?: long(name='updated_at'),
}

model UploadFormInfo {
  bucketName?: string(name='bucket_name'),
  endpoint?: string(name='endpoint'),
  formData?: map[string]string(name='form_data'),
  objectKey?: string(name='object_key'),
  ossAccessKeyId?: string(name='oss_access_key_id'),
  ossEndPoint?: string(name='oss_end_point'),
  ossSecurityToken?: string(name='oss_security_token'),
  policy?: string(name='policy'),
  signature?: string(name='signature'),
}

model UploadPartInfo {
  etag?: string(name='etag', example='0CC175B9C0F1B6A831C399E269772661'),
  internalUploadUrl?: string(name='internal_upload_url'),
  parallelSha1Ctx?: {
    h?: [ long ](name='h'),
    partOffset?: long(name='part_offset'),
  }(name='parallel_sha1_ctx'),
  parallelSha256Ctx?: {
    h?: [ long ](name='h'),
    partOffset?: long(name='part_offset'),
  }(name='parallel_sha256_ctx'),
  partNumber?: int32(name='part_number', description='This parameter is required.', example='1'),
  partSize?: long(name='part_size', example='1024'),
  uploadUrl?: string(name='upload_url', description='This parameter is required.'),
}

model User {
  avatar?: string(name='avatar'),
  createdAt?: long(name='created_at'),
  creator?: string(name='creator'),
  defaultDriveId?: string(name='default_drive_id'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  email?: string(name='email'),
  nickName?: string(name='nick_name'),
  phone?: string(name='phone'),
  role?: string(name='role'),
  status?: string(name='status'),
  updatedAt?: long(name='updated_at'),
  userData?: map[string]string(name='user_data'),
  userId?: string(name='user_id'),
  userName?: string(name='user_name'),
}

model UserExtraItem {
  account?: [
    AccountLinkInfo
  ](name='account'),
  avatar?: string(name='avatar', example='http://a.b.c/ccp.jpg'),
  createdAt?: string(name='created_at', example='1567407718386'),
  creator?: string(name='creator', example='system'),
  defaultDrive?: BaseDriveResponse(name='default_drive', nullable=true),
  defaultDriveId?: string(name='default_drive_id', example='123'),
  defaultLocation?: string(name='default_location'),
  denyChangePasswordBySelf?: boolean(name='deny_change_password_by_self'),
  description?: string(name='description', example='ccp team user'),
  domainId?: string(name='domain_id', example='hz999'),
  email?: string(name='email', example='123@ccp.com'),
  expiredAt?: long(name='expired_at', example='0'),
  isSync?: boolean(name='is_sync'),
  lastLoginTime?: long(name='last_login_time'),
  needChangePasswordNextLogin?: boolean(name='need_change_password_next_login'),
  nickName?: string(name='nick_name', example='abc'),
  parentGroup?: [
    BaseDriveResponse
  ](name='parent_group'),
  pathStatus?: string(name='path_status'),
  permission?: map[string]IDPermission(name='permission'),
  phone?: string(name='phone', example='13700000000'),
  phoneRegion?: string(name='phone_region'),
  role?: string(name='role', example='user'),
  status?: string(name='status', example='enabled'),
  updatedAt?: string(name='updated_at', example='1567407718386'),
  userData?: map[string]any(name='user_data'),
  userId?: string(name='user_id', example='ccpuserid'),
  userName?: string(name='user_name', example='name'),
}

model UserLogDetail {
  email?: string(name='email'),
  expiredAt?: long(name='expired_at'),
  name?: string(name='name'),
  phone?: string(name='phone'),
  roleId?: string(name='role_id'),
  updateTo?: {
    email?: string(name='email'),
    expiredAt?: long(name='expired_at'),
    name?: string(name='name'),
    phone?: string(name='phone'),
    roleId?: string(name='role_id'),
  }(name='update_to'),
}

model UserTag {
  key?: string(name='key', description='This parameter is required.'),
  value?: string(name='value', description='This parameter is required.'),
}

model VideoMediaAudioStream {
  bitRate?: string(name='bit_rate', example='129280'),
  codeName?: string(name='code_name', example='aac'),
  duration?: string(name='duration', example='7704.573000'),
}

model VideoMediaMetadata {
  height?: long(name='height', example='1080'),
  videoMediaAudioStream?: [
    VideoMediaAudioStream
  ](name='video_media_audio_stream'),
  videoMediaVideoStream?: [
    VideoMediaVideoStream
  ](name='video_media_video_stream'),
  width?: long(name='width', example='1920'),
}

model VideoMediaVideoStream {
  bitrate?: string(name='bitrate', example='108420'),
  codeName?: string(name='code_name', example='h264'),
  duration?: string(name='duration', example='22.88'),
  frameCount?: string(name='frame_count', example='90'),
}

model VideoPreviewPlayInfo {
  category?: string(name='category', example='live_transcoding'),
  liveTranscodingTaskList?: [ 
    {
      keepOriginalResolution?: boolean(name='keep_original_resolution'),
      status?: string(name='status'),
      templateId?: string(name='template_id'),
      url?: string(name='url'),
    }
  ](name='live_transcoding_task_list'),
  masterUrl?: string(name='master_url'),
  meta?: {
    duration?: double(name='duration'),
    height?: long(name='height'),
    width?: long(name='width'),
  }(name='meta'),
  offlineVideoTranscodingList?: [ 
    {
      keepOriginalResolution?: boolean(name='keep_original_resolution'),
      status?: string(name='status'),
      templateId?: string(name='template_id'),
      url?: string(name='url'),
    }
  ](name='offline_video_transcoding_list'),
}

model VideoPreviewPlayMeta {
  category?: string(name='category', example='live_transcoding'),
  liveTranscodingTaskList?: [ 
    {
      keepOriginalResolution?: boolean(name='keep_original_resolution'),
      status?: string(name='status'),
      templateId?: string(name='template_id', example='264_720p'),
    }
  ](name='live_transcoding_task_list'),
  meta?: {
    duration?: double(name='duration', example='10'),
    height?: long(name='height', example='720'),
    width?: long(name='width', example='1280'),
  }(name='meta'),
}

model View {
  category?: string(name='category'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  exFieldsInfo?: map[string]any(name='ex_fields_info'),
  fileCount?: long(name='file_count'),
  name?: string(name='name'),
  owner?: string(name='owner'),
  updatedAt?: string(name='updated_at'),
  viewId?: string(name='view_id'),
}

model ViewFile {
  category?: string(name='category'),
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  contentType?: string(name='content_type'),
  crc64Hash?: string(name='crc64_hash'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  downloadUrl?: string(name='download_url'),
  driveId?: string(name='drive_id'),
  fields?: map[string]any(name='fields'),
  fileExtension?: string(name='file_extension'),
  fileId?: string(name='file_id'),
  fileRevisionId?: string(name='file_revision_id'),
  hidden?: boolean(name='hidden'),
  investigationInfo?: {
    status?: long(name='status'),
    suggestion?: string(name='suggestion'),
  }(name='investigation_info'),
  joinedAt?: long(name='joined_at'),
  labels?: [ string ](name='labels'),
  localCreatedAt?: string(name='local_created_at'),
  localModifiedAt?: string(name='local_modified_at'),
  name?: string(name='name'),
  parentFileId?: string(name='parent_file_id'),
  revisionId?: string(name='revision_id'),
  size?: long(name='size'),
  starred?: boolean(name='starred'),
  status?: string(name='status'),
  thumbnail?: string(name='thumbnail'),
  thumbnailUrls?: map[string]string(name='thumbnail_urls'),
  trashedAt?: string(name='trashed_at'),
  type?: string(name='type'),
  updatedAt?: string(name='updated_at'),
  uploadId?: string(name='upload_id'),
  viewId?: string(name='view_id'),
}

model WatermarkEnableConfig {
  displayAccessUserName?: boolean(name='display_access_user_name'),
  displayCustomText?: string(name='display_custom_text'),
  displayShareLinkCreatorName?: boolean(name='display_shareLink_creator_name'),
  enableDocPreview?: boolean(name='enable_doc_preview'),
}

model WxTrustedDomainConfig {
  content?: string(name='content'),
  name?: string(name='name'),
  show?: boolean(name='show'),
}

model AddGroupMemberRequest {
  groupId?: string(name='group_id', description='The ID of the destination group to which the member is added.

This parameter is required.', example='3e5***2c2'),
  memberId?: string(name='member_id', description='The member ID. If member_type is set to user, set this parameter to a user ID.

This parameter is required.', example='2e4***1b1'),
  memberType?: string(name='member_type', description='The type of the member. Set the value to user. When you create a group, you can directly add the group to a parent group.

* user

Note: A group can be added to only one group. A user can be added to multiple groups.

This parameter is required.', example='user'),
}

model AddGroupMemberResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Adds a member to a group.
 *
 * @param request AddGroupMemberRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddGroupMemberResponse
 */
async function addGroupMemberWithOptions(request: AddGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddGroupMemberResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }
  if (!Util.isUnset(request.memberId)) {
    body['member_id'] = request.memberId;
  }
  if (!Util.isUnset(request.memberType)) {
    body['member_type'] = request.memberType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddGroupMember',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/add_member`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Adds a member to a group.
 *
 * @param request AddGroupMemberRequest
 * @return AddGroupMemberResponse
 */
async function addGroupMember(request: AddGroupMemberRequest): AddGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addGroupMemberWithOptions(request, headers, runtime);
}

model AddStoryFilesRequest {
  driveId?: string(name='drive_id', description='This parameter is required.', example='1'),
  files?: [ 
    {
      fileId?: string(name='file_id', description='This parameter is required.', example='63e5e4340f76cb3ead5f40f68163f0f967c1a7bf'),
      revisionId?: string(name='revision_id', example='642a88dd06e49d9c0a14411ebae606f70edd9a59'),
    }
  ](name='files'),
  storyId?: string(name='story_id', description='This parameter is required.', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model AddStoryFilesResponseBody = {
  driveId?: string(name='drive_id', example='1'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model AddStoryFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddStoryFilesResponseBody(name='body'),
}

/**
 * @summary 故事添加文件
 *
 * @param request AddStoryFilesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddStoryFilesResponse
 */
async function addStoryFilesWithOptions(request: AddStoryFilesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddStoryFilesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.files)) {
    body['files'] = request.files;
  }
  if (!Util.isUnset(request.storyId)) {
    body['story_id'] = request.storyId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddStoryFiles',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/add_story_files`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 故事添加文件
 *
 * @param request AddStoryFilesRequest
 * @return AddStoryFilesResponse
 */
async function addStoryFiles(request: AddStoryFilesRequest): AddStoryFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addStoryFilesWithOptions(request, headers, runtime);
}

model AssignRoleRequest {
  identity?: Identity(name='identity', description='The unique identifier of a user. The group administrator role can only be assigned to a user.

This parameter is required.'),
  manageResourceId?: string(name='manage_resource_id', description='The ID of the resource that the role can manage. You can only set this parameter to the ID of a group.

This parameter is required.', example='105***b82'),
  manageResourceType?: string(name='manage_resource_type', description='The type of the resource that the role can manage. Valid value: RT_Group.

This parameter is required.', example='RT_Group'),
  roleId?: string(name='role_id', description='The ID of the role that is assigned to a user. Valid value: SystemGroupAdmin.

This parameter is required.', example='SystemGroupAdmin'),
}

model AssignRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Assigns a group administrator role to a user.
 *
 * @description You can call this operation to assign a group administrator role to a user.
 *
 * @param request AssignRoleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssignRoleResponse
 */
async function assignRoleWithOptions(request: AssignRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AssignRoleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }
  if (!Util.isUnset(request.manageResourceId)) {
    body['manage_resource_id'] = request.manageResourceId;
  }
  if (!Util.isUnset(request.manageResourceType)) {
    body['manage_resource_type'] = request.manageResourceType;
  }
  if (!Util.isUnset(request.roleId)) {
    body['role_id'] = request.roleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AssignRole',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/role/assign`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Assigns a group administrator role to a user.
 *
 * @description You can call this operation to assign a group administrator role to a user.
 *
 * @param request AssignRoleRequest
 * @return AssignRoleResponse
 */
async function assignRole(request: AssignRoleRequest): AssignRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return assignRoleWithOptions(request, headers, runtime);
}

model AuthorizeRequest {
  clientId?: string(name='client_id', description='The application ID returned when the application was created.

This parameter is required.', example='47eUHhrzgWBvlLWj'),
  hideConsent?: boolean(name='hide_consent', description='Specifies whether to hide the consent page.', example='true'),
  loginType?: string(name='login_type', description='The authentication method. Valid values:

*   default: all logon methods that are integrated on the default logon page provided by Drive and Photo Service.
*   ding: logs on by scanning a DingTalk QR code.
*   ding_sns: logs on by entering a DingTalk account and its password.
*   ram: logs on as an Alibaba Cloud Resource Access Management (RAM) user.
*   wechat: logs on by scanning a WeCom QR code.
*   wechat_app: logs on without authentication in WeCom.

This parameter is required.', example='default'),
  redirectUri?: string(name='redirect_uri', description='The callback URL specified when the application was created.

This parameter is required.', example='https://www.aliyunpds.com/sign/callback'),
  responseType?: string(name='response_type', description='The format in which to return the response. Set the value to code.

This parameter is required.', example='code'),
  scope?: [ string ](name='scope', description='The requested permissions. By default, all permissions are requested.'),
  state?: string(name='state', description='The user-defined parameter to return in the callback URL after the requested permissions are granted.', example='customdata'),
}

model AuthorizeShrinkRequest {
  clientId?: string(name='client_id', description='The application ID returned when the application was created.

This parameter is required.', example='47eUHhrzgWBvlLWj'),
  hideConsent?: boolean(name='hide_consent', description='Specifies whether to hide the consent page.', example='true'),
  loginType?: string(name='login_type', description='The authentication method. Valid values:

*   default: all logon methods that are integrated on the default logon page provided by Drive and Photo Service.
*   ding: logs on by scanning a DingTalk QR code.
*   ding_sns: logs on by entering a DingTalk account and its password.
*   ram: logs on as an Alibaba Cloud Resource Access Management (RAM) user.
*   wechat: logs on by scanning a WeCom QR code.
*   wechat_app: logs on without authentication in WeCom.

This parameter is required.', example='default'),
  redirectUri?: string(name='redirect_uri', description='The callback URL specified when the application was created.

This parameter is required.', example='https://www.aliyunpds.com/sign/callback'),
  responseType?: string(name='response_type', description='The format in which to return the response. Set the value to code.

This parameter is required.', example='code'),
  scopeShrink?: string(name='scope', description='The requested permissions. By default, all permissions are requested.'),
  state?: string(name='state', description='The user-defined parameter to return in the callback URL after the requested permissions are granted.', example='customdata'),
}

model AuthorizeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Requests permissions by using OAuth 2.0.
 *
 * @description For more information, see "OAuth 2.0 For Web Server Applications" at [OAuth 2.0 For Web Server Applications](https://www.alibabacloud.com/help/en/pds/drive-and-photo-service-dev/user-guide/oauth-2-0-access-process-for-web-server-applications) in User Guide.
 *
 * @param tmpReq AuthorizeRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AuthorizeResponse
 */
async function authorizeWithOptions(tmpReq: AuthorizeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuthorizeResponse {
  Util.validateModel(tmpReq);
  var request = new AuthorizeShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.scope)) {
    request.scopeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scope, 'scope', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientId)) {
    query['client_id'] = request.clientId;
  }
  if (!Util.isUnset(request.hideConsent)) {
    query['hide_consent'] = request.hideConsent;
  }
  if (!Util.isUnset(request.loginType)) {
    query['login_type'] = request.loginType;
  }
  if (!Util.isUnset(request.redirectUri)) {
    query['redirect_uri'] = request.redirectUri;
  }
  if (!Util.isUnset(request.responseType)) {
    query['response_type'] = request.responseType;
  }
  if (!Util.isUnset(request.scopeShrink)) {
    query['scope'] = request.scopeShrink;
  }
  if (!Util.isUnset(request.state)) {
    query['state'] = request.state;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Authorize',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/oauth/authorize`,
    method = 'GET',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'binary',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Requests permissions by using OAuth 2.0.
 *
 * @description For more information, see "OAuth 2.0 For Web Server Applications" at [OAuth 2.0 For Web Server Applications](https://www.alibabacloud.com/help/en/pds/drive-and-photo-service-dev/user-guide/oauth-2-0-access-process-for-web-server-applications) in User Guide.
 *
 * @param request AuthorizeRequest
 * @return AuthorizeResponse
 */
async function authorize(request: AuthorizeRequest): AuthorizeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return authorizeWithOptions(request, headers, runtime);
}

model BatchRequest {
  requests?: [ 
    {
      body?: map[string]any(name='body', description='The request parameters of a child request. The parameter value must be a JSON string. For more information, see the topic of the corresponding child request.

Before you specify the request body, you must specify a header by using Content-Type. Content-Type can only be set to application/json.'),
      headers?: map[string]string(name='headers', description='The header of a child request, which indicates the type of the data specified in the request body.'),
      id?: string(name='id', description='The ID of the child request. The ID is used to associate a child request with a response. The ID of a child request must be unique.

This parameter is required.', example='93433894994ad2e1'),
      method?: string(name='method', description='The method of a child request. Valid values:

*   POST
*   GET
*   PUT
*   DELETE
*   HEAD

This parameter is required.', example='POST'),
      url?: string(name='url', description='The API path of a child request. Valid values:

*   /file/get: queries the information about a file.
*   /file/update: modifies the information about a file.
*   /file/search: searches for a file.
*   /file/copy: copies a file or folder.
*   /file/move: moves a file or folder.
*   /file/delete: deletes a file or folder.
*   /file/get_download_url: queries the download URL of a file.
*   /file/get_share_link_download_url: queries the download URL of a file in a share.
*   /recyclebin/trash: moves a file or folder to the recycle bin.
*   /recyclebin/restore: restores a file or folder.
*   /file/put_usertags: adds tags to a user.
*   /file/delete_usertags: removes tags from a user.
*   /drive/get: queries the information about a drive.
*   /user/get: queries the information about a user.
*   /group/get: queries the information about a group.
*   /share_link/create: creates a share.
*   /share_link/update: modifies a share.
*   /share_link/cancel: cancels a share.
*   /share_link/list: queries shares.
*   /share_link/get: queries the information about a share.
*   /share_link/get_share_token: queries an access token of a share.
*   /async_task/get: queries the information about an asynchronous task.

This parameter is required.', example='/file/get'),
    }
  ](name='requests', description='The child requests.

The number of child requests. Valid value: 1 to 100.

This parameter is required.'),
  resource?: string(name='resource', description='The type of the resource that you want to manage. Valid values:

*   file: a file.
*   drive: an individual drive or a team drive.
*   user: a user.
*   group: a group.
*   membership: a group member.
*   share_link: a share.
*   async_task: an asynchronous task.

This parameter is required.', example='file'),
}

model BatchResponseBody = {
  responses?: [ 
    {
      body?: map[string]any(name='body', description='The response parameters of a child request. For more information, see the topic of the corresponding child request.'),
      id?: string(name='id', description='The ID of the child request. The ID is used to associate a child request with a response.', example='93433894994ad2e1'),
      status?: int32(name='status', description='The returned HTTP status code of a child request. For more information, see the topic of the corresponding child request.', example='200'),
    }
  ](name='responses', description='All responses of the child requests.'),
}

model BatchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchResponseBody(name='body'),
}

/**
 * @summary Calls multiple operations at a time to improve call efficiency.
 *
 * @param request BatchRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchResponse
 */
async function batchWithOptions(request: BatchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.requests)) {
    body['requests'] = request.requests;
  }
  if (!Util.isUnset(request.resource)) {
    body['resource'] = request.resource;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'Batch',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/batch`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Calls multiple operations at a time to improve call efficiency.
 *
 * @param request BatchRequest
 * @return BatchResponse
 */
async function batch(request: BatchRequest): BatchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchWithOptions(request, headers, runtime);
}

model CancelAssignRoleRequest {
  identity?: Identity(name='identity', description='The unique identifier. You can cancel only the role assigned to a user.

This parameter is required.'),
  manageResourceId?: string(name='manage_resource_id', description='The ID of the resource that the role manages. Set the value to a group ID.

This parameter is required.', example='105***b82'),
  manageResourceType?: string(name='manage_resource_type', description='The type of the resource that the role manages. Set the value to RT_Group, which specifies group.

This parameter is required.', example='RT_Group'),
  roleId?: string(name='role_id', description='The ID of the role to be canceled. Set the value to SystemGroupAdmin, which is the ID of the group administrator role.

This parameter is required.', example='SystemGroupAdmin'),
}

model CancelAssignRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Cancels a role.
 *
 * @description You can cancel only the group administrator role.
 *
 * @param request CancelAssignRoleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelAssignRoleResponse
 */
async function cancelAssignRoleWithOptions(request: CancelAssignRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelAssignRoleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }
  if (!Util.isUnset(request.manageResourceId)) {
    body['manage_resource_id'] = request.manageResourceId;
  }
  if (!Util.isUnset(request.manageResourceType)) {
    body['manage_resource_type'] = request.manageResourceType;
  }
  if (!Util.isUnset(request.roleId)) {
    body['role_id'] = request.roleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelAssignRole',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/role/cancel_assign`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Cancels a role.
 *
 * @description You can cancel only the group administrator role.
 *
 * @param request CancelAssignRoleRequest
 * @return CancelAssignRoleResponse
 */
async function cancelAssignRole(request: CancelAssignRoleRequest): CancelAssignRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelAssignRoleWithOptions(request, headers, runtime);
}

model CancelShareLinkRequest {
  shareId?: string(name='share_id', description='The share ID.

This parameter is required.', example='7JQX1FswpQ8'),
}

model CancelShareLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a share link.
 *
 * @param request CancelShareLinkRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelShareLinkResponse
 */
async function cancelShareLinkWithOptions(request: CancelShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/cancel`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a share link.
 *
 * @param request CancelShareLinkRequest
 * @return CancelShareLinkResponse
 */
async function cancelShareLink(request: CancelShareLinkRequest): CancelShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelShareLinkWithOptions(request, headers, runtime);
}

model ClearRecyclebinRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
}

model ClearRecyclebinResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

You can call the GetAsyncTask operation to query the information about the asynchronous task based on the task ID.', example='13ebd3a24dba4166b1527add676ef2866051b4d5dele16'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
}

model ClearRecyclebinResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ClearRecyclebinResponseBody(name='body'),
}

/**
 * @summary Empties the recycle bin.
 *
 * @param request ClearRecyclebinRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ClearRecyclebinResponse
 */
async function clearRecyclebinWithOptions(request: ClearRecyclebinRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ClearRecyclebinResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ClearRecyclebin',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/recyclebin/clear`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Empties the recycle bin.
 *
 * @param request ClearRecyclebinRequest
 * @return ClearRecyclebinResponse
 */
async function clearRecyclebin(request: ClearRecyclebinRequest): ClearRecyclebinResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return clearRecyclebinWithOptions(request, headers, runtime);
}

model CompleteFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
  uploadId?: string(name='upload_id', description='The upload ID.

This parameter is required.', example='C9DCFE5A82644AC7A02DB74C30C934A6'),
}

model CompleteFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: File  
}

/**
 * @summary Completes the upload of a file.
 *
 * @param request CompleteFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CompleteFileResponse
 */
async function completeFileWithOptions(request: CompleteFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CompleteFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.uploadId)) {
    body['upload_id'] = request.uploadId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CompleteFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/complete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Completes the upload of a file.
 *
 * @param request CompleteFileRequest
 * @return CompleteFileResponse
 */
async function completeFile(request: CompleteFileRequest): CompleteFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return completeFileWithOptions(request, headers, runtime);
}

model CopyFileRequest {
  autoRename?: boolean(name='auto_rename', description='Specifies whether to automatically rename the file if the file name already exists in the destination folder. Default value: false.', example='true'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID or folder ID.

This parameter is required.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a share link, carry the `x-share-token` header for authentication in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify one of `share_id` and `drive_id`.', example='7JQX1FswpQ8'),
  toDriveId?: string(name='to_drive_id', description='The ID of the drive to which you want to copy the file or folder. Default value: the value of drive_id.', example='1'),
  toParentFileId?: string(name='to_parent_file_id', description='The ID of the destination parent folder. If you want to copy the file or folder to a root directory, set this parameter to root.

This parameter is required.', example='6520943DC261'),
}

model CopyFileResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

If a file is copied, this parameter is not returned. If a folder is copied, the folder is asynchronously copied in the background and this parameter is returned. You can call the GetAsyncTask operation to query the information about the asynchronous task based on the task ID.', example='000e89fb-cf8f-11e9-8ab4-b6e980803a3b'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The ID of the copied file or folder.', example='4221bf6e6ab43a255edc4463bffa6f5f5d317401'),
}

model CopyFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CopyFileResponseBody(name='body'),
}

/**
 * @summary Copies a file or folder.
 *
 * @param request CopyFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CopyFileResponse
 */
async function copyFileWithOptions(request: CopyFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CopyFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoRename)) {
    body['auto_rename'] = request.autoRename;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.toDriveId)) {
    body['to_drive_id'] = request.toDriveId;
  }
  if (!Util.isUnset(request.toParentFileId)) {
    body['to_parent_file_id'] = request.toParentFileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CopyFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/copy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Copies a file or folder.
 *
 * @param request CopyFileRequest
 * @return CopyFileResponse
 */
async function copyFile(request: CopyFileRequest): CopyFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return copyFileWithOptions(request, headers, runtime);
}

model CreateCustomizedStoryRequest {
  customLabels?: map[string]string(name='custom_labels', deprecated=true),
  driveId?: string(name='drive_id', description='This parameter is required.', example='1'),
  storyCover?: {
    fileId?: string(name='file_id', description='This parameter is required.', example='63e5e4340f76cb3ead5f40f68163f0f967c1a7bf'),
    revisionId?: string(name='revision_id', example='642a88d4aff041ee68fd4fc89beb80e1119da343'),
  }(name='story_cover', description='This parameter is required.'),
  storyFiles?: [ 
    {
      fileId?: string(name='file_id', description='This parameter is required.', example='63e5e4340f76cb3ead5f40f68163f0f967c1a7bf'),
      revisionId?: string(name='revision_id', example='642a88d4aff041ee68fd4fc89beb80e1119da343'),
    }
  ](name='story_files', description='This parameter is required.'),
  storyName?: string(name='story_name', description='This parameter is required.', example='test_name'),
  storySubType?: string(name='story_sub_type', description='This parameter is required.', example='user_created'),
  storyType?: string(name='story_type', description='This parameter is required.', example='user_created'),
}

model CreateCustomizedStoryResponseBody = {
  driveId?: string(name='drive_id', example='1'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model CreateCustomizedStoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCustomizedStoryResponseBody(name='body'),
}

/**
 * @summary 创建自定义故事
 *
 * @param request CreateCustomizedStoryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCustomizedStoryResponse
 */
async function createCustomizedStoryWithOptions(request: CreateCustomizedStoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateCustomizedStoryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.customLabels)) {
    body['custom_labels'] = request.customLabels;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.storyCover)) {
    body['story_cover'] = request.storyCover;
  }
  if (!Util.isUnset(request.storyFiles)) {
    body['story_files'] = request.storyFiles;
  }
  if (!Util.isUnset(request.storyName)) {
    body['story_name'] = request.storyName;
  }
  if (!Util.isUnset(request.storySubType)) {
    body['story_sub_type'] = request.storySubType;
  }
  if (!Util.isUnset(request.storyType)) {
    body['story_type'] = request.storyType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomizedStory',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/create_customized_story`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 创建自定义故事
 *
 * @param request CreateCustomizedStoryRequest
 * @return CreateCustomizedStoryResponse
 */
async function createCustomizedStory(request: CreateCustomizedStoryRequest): CreateCustomizedStoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createCustomizedStoryWithOptions(request, headers, runtime);
}

model CreateDomainRequest {
  description?: string(name='description', description='The description of the domain.', example='domain for test'),
  domainName?: string(name='domain_name', description='The name of the domain.

This parameter is required.', example='test_domain'),
  initDriveEnable?: boolean(name='init_drive_enable', description='Specifies whether to enable the default drive feature. A value of true specifies that all users are assigned a drive by default on the first logon. Default value: false.', example='true'),
  initDriveSize?: long(name='init_drive_size', description='The size of the default drive. Unit: bytes. You must specify init_drive_size if you set init_drive_enable to true. Default value: 0. A value of 0 specifies that the size of the default drive is 0 bytes and you cannot upload files to the drive. To initialize the default drive, set init_drive_size to 0. A value of -1 specifies that the size is unlimited.', example='1073741824'),
  parentDomainId?: string(name='parent_domain_id', description='The ID of the parent domain. If you want to create a child domain, specify parent_domain_id. In most cases, you do not need to create a child domain. If you want to perform secondary operations based on Drive and Photo Service, contact the customer service.', example='bj1'),
  sizeQuota?: long(name='size_quota', description='The total storage quota for all drives in the domain. A value of 0 specifies that the quota is unlimited.', example='1099511627776'),
  userCountQuota?: long(name='user_count_quota', description='The largest number of users that can be created in the domain. A value of 0 specifies that the number is unlimited.', example='50'),
}

model CreateDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Domain  
}

/**
 * @summary Create domain.
 *
 * @description If you want to perform secondary operations based on Drive and Photo Service and perform fine-grained control on your tenants, you can use the parent-child domain feature of Drive and Photo Service. For more information, join the DingTalk group whose ID is 23146118.
 *
 * @param request CreateDomainRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDomainResponse
 */
async function createDomainWithOptions(request: CreateDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.domainName)) {
    body['domain_name'] = request.domainName;
  }
  if (!Util.isUnset(request.initDriveEnable)) {
    body['init_drive_enable'] = request.initDriveEnable;
  }
  if (!Util.isUnset(request.initDriveSize)) {
    body['init_drive_size'] = request.initDriveSize;
  }
  if (!Util.isUnset(request.parentDomainId)) {
    body['parent_domain_id'] = request.parentDomainId;
  }
  if (!Util.isUnset(request.sizeQuota)) {
    body['size_quota'] = request.sizeQuota;
  }
  if (!Util.isUnset(request.userCountQuota)) {
    body['user_count_quota'] = request.userCountQuota;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDomain',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Create domain.
 *
 * @description If you want to perform secondary operations based on Drive and Photo Service and perform fine-grained control on your tenants, you can use the parent-child domain feature of Drive and Photo Service. For more information, join the DingTalk group whose ID is 23146118.
 *
 * @param request CreateDomainRequest
 * @return CreateDomainResponse
 */
async function createDomain(request: CreateDomainRequest): CreateDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDomainWithOptions(request, headers, runtime);
}

model CreateDriveRequest {
  default?: boolean(name='default', description='Specifies whether the drive is the default drive. Default value: false.', example='true'),
  description?: string(name='description', description='The description of the drive. The description can be up to 1,024 characters in length.', example='drive for test'),
  driveName?: string(name='drive_name', description='The name of the drive. The name can be up to 128 characters in length.

This parameter is required.', example='test_drive'),
  driveType?: string(name='drive_type', description='The type of the drive. Set the value to normal.', example='normal'),
  owner?: string(name='owner', description='The owner of the drive.

This parameter is required.', example='3b3d7245c159488da17d081ad6c64687'),
  ownerType?: string(name='owner_type', description='The type of the owner. Valid values:

user and group.

This parameter is required.', example='user'),
  status?: string(name='status', description='The state of the drive. Valid values:

enabled and disabled.

Default value: enabled.', example='enabled'),
  totalSize?: long(name='total_size', description='The total size of the drive. Unit: bytes. By default, the size is unlimited.', example='1024'),
}

model CreateDriveResponseBody = {
  createdAt?: string(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  driveName?: string(name='drive_name'),
  driveType?: string(name='drive_type'),
  owner?: string(name='owner'),
  ownerType?: string(name='owner_type'),
  status?: string(name='status'),
  totalSize?: long(name='total_size'),
  usedSize?: long(name='used_size'),
}

model CreateDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDriveResponseBody(name='body'),
}

/**
 * @summary Creates a drive.
 *
 * @param request CreateDriveRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDriveResponse
 */
async function createDriveWithOptions(request: CreateDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.default)) {
    body['default'] = request.default;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.driveName)) {
    body['drive_name'] = request.driveName;
  }
  if (!Util.isUnset(request.driveType)) {
    body['drive_type'] = request.driveType;
  }
  if (!Util.isUnset(request.owner)) {
    body['owner'] = request.owner;
  }
  if (!Util.isUnset(request.ownerType)) {
    body['owner_type'] = request.ownerType;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.totalSize)) {
    body['total_size'] = request.totalSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a drive.
 *
 * @param request CreateDriveRequest
 * @return CreateDriveResponse
 */
async function createDrive(request: CreateDriveRequest): CreateDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDriveWithOptions(request, headers, runtime);
}

model CreateFileRequest {
  checkNameMode?: string(name='check_name_mode', description='The processing method that is used if the file that you want to create has the same name as an existing file in the cloud. Valid values:

ignore: allows you to create the file by using the same name as an existing file in the cloud.

auto_rename: automatically renames the file that you want to create. By default, the current point in time is added to the end of the file name. Example: xxx_20060102_150405.

refuse: does not create the file that you want to create but returns the information about the file that has the same name in the cloud.

Default value: ignore.', example='ignore', nullable=true),
  contentHash?: string(name='content_hash', description='The hash value of the file content. The value is calculated based on the algorithm specified by content_hash_name.', example='7C4A8D09CA3762AF61E59520943DC26494F8941B', nullable=true),
  contentHashName?: string(name='content_hash_name', description='The name of the algorithm that is used to calculate the hash value of the file content. Only SHA1 is supported.', example='sha1', nullable=true),
  contentType?: string(name='content_type', description='The type of the file content. Default value: application/oct-stream.', example='application/json', nullable=true),
  description?: string(name='description', description='The description of the file. The description can be up to 1,024 characters in length. By default, this parameter is left empty.', example='重要文件', nullable=true),
  driveId?: string(name='drive_id', description='The drive ID. This parameter is required if the file is not uploaded by using the share URL of the file.', example='1'),
  fileId?: string(name='file_id', description='The file ID. This parameter is required if check_name_mode is set to ignore.', example='9520943DC264', nullable=true),
  hidden?: boolean(name='hidden', description='Specifies whether to hide the file or folder. By default, the file or folder is not hidden.', example='false', nullable=true),
  imageMediaMetadata?: ImageMediaMetadata(name='image_media_metadata', description='The information about the image specified by the client.'),
  localCreatedAt?: string(name='local_created_at', description='The time when the local file was created. By default, this parameter is left empty. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format based on the UTC+0 time zone.', example='2019-08-20T06:51:27.292Z', nullable=true),
  localModifiedAt?: string(name='local_modified_at', description='The time when the local file was modified. By default, this parameter is left empty. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format based on the UTC+0 time zone.', example='2019-08-20T06:51:27.292Z'),
  name?: string(name='name', description='The name of the file. The name can be up to 1,024 bytes in length based on the UTF-8 encoding rule and cannot end with a forward slash (/).

This parameter is required.', example='a.txt', nullable=false),
  parallelUpload?: boolean(name='parallel_upload', description='Specifies whether to enable the parallel upload feature.', example='true', nullable=true),
  parentFileId?: string(name='parent_file_id', description='The ID of the parent directory. If you want to create a file or folder in the root directory, set this parameter to root.

This parameter is required.', example='fileid1'),
  partInfoList?: [ 
    {
      contentMd5?: string(name='content_md5', description='The MD5 hash value of the file part. This parameter is required when the MD5 hash value of the file part needs to be verified during part upload.', example='ASKJDJSKDJJSJDJS'),
      parallelSha1Ctx?: {
        h?: [ long ](name='h', description='The first to fifth 32-bit variables of the SHA-1 hash value of the file content before the file part. This parameter takes effect only if the parallel upload feature is enabled.'),
        partOffset?: long(name='part_offset', description='The size of the file content before the file part. Unit: bytes. The value must be a multiple of 64. This parameter takes effect only if the parallel upload feature is enabled.', example='10240'),
      }(name='parallel_sha1_ctx', description='The SHA-1 hash value of the file content before the file part. This parameter takes effect only if the parallel upload feature is enabled.'),
      partNumber?: int32(name='part_number', description='The serial number of a file part. The number starts from 1.', example='1'),
    }
  ](name='part_info_list', description='The information about the file parts. You can specify up to 10,000 parts. By default, if you do not specify this parameter, only one part is returned.'),
  preHash?: string(name='pre_hash', description='The SHA-1 hash value of the first 1 KB data of the file. This parameter is required if you perform instant file upload by using the pre-hashing feature. If the SHA-1 hash value is not matched on the cloud, the client does not need to calculate the SHA-1 hash value of the entire file.', example='7C4A8D09CA3762AF61E59520943DC26494F89411', nullable=true),
  shareId?: string(name='share_id', description='The share ID. This parameter is required if the file is uploaded by using the share URL of the file.', example='7JQX1FswpQ8', nullable=true),
  size?: long(name='size', description='The size of the file. Unit: bytes.', example='1024', nullable=true),
  type?: string(name='type', description='The type of the file. Valid values:

file folder

This parameter is required.', example='file', nullable=true),
  userTags?: [
    UserTag
  ](name='user_tags', description='The custom tags. You can specify up to 1,000 tags.'),
  videoMediaMetadata?: VideoMediaMetadata(name='video_media_metadata', description='The information about the video specified by the client.'),
}

model CreateFileResponseBody = {
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  exist?: boolean(name='exist', description='Indicates whether the file exists.', example='false'),
  fileId?: string(name='file_id', description='The file ID.', example='fileid1'),
  fileName?: string(name='file_name', description='The file name.', example='a.txt'),
  parentFileId?: string(name='parent_file_id', description='The ID of the parent directory.', example='fileid5'),
  partInfoList?: [
    UploadPartInfo
  ](name='part_info_list', description='The information about the file parts.'),
  rapidUpload?: boolean(name='rapid_upload', description='Indicates whether the file is instantly uploaded.', example='true'),
  status?: string(name='status', description='The state of the file.', example='uploading'),
  type?: string(name='type', description='The type of the file.', example='file'),
  uploadId?: string(name='upload_id', description='The ID of the upload task.', example='uploadid1'),
}

model CreateFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFileResponseBody(name='body'),
}

/**
 * @summary Creates a file or folder.
 *
 * @param request CreateFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFileResponse
 */
async function createFileWithOptions(request: CreateFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkNameMode)) {
    body['check_name_mode'] = request.checkNameMode;
  }
  if (!Util.isUnset(request.contentHash)) {
    body['content_hash'] = request.contentHash;
  }
  if (!Util.isUnset(request.contentHashName)) {
    body['content_hash_name'] = request.contentHashName;
  }
  if (!Util.isUnset(request.contentType)) {
    body['content_type'] = request.contentType;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.hidden)) {
    body['hidden'] = request.hidden;
  }
  if (!Util.isUnset(request.imageMediaMetadata)) {
    body['image_media_metadata'] = request.imageMediaMetadata;
  }
  if (!Util.isUnset(request.localCreatedAt)) {
    body['local_created_at'] = request.localCreatedAt;
  }
  if (!Util.isUnset(request.localModifiedAt)) {
    body['local_modified_at'] = request.localModifiedAt;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.parallelUpload)) {
    body['parallel_upload'] = request.parallelUpload;
  }
  if (!Util.isUnset(request.parentFileId)) {
    body['parent_file_id'] = request.parentFileId;
  }
  if (!Util.isUnset(request.partInfoList)) {
    body['part_info_list'] = request.partInfoList;
  }
  if (!Util.isUnset(request.preHash)) {
    body['pre_hash'] = request.preHash;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.size)) {
    body['size'] = request.size;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }
  if (!Util.isUnset(request.userTags)) {
    body['user_tags'] = request.userTags;
  }
  if (!Util.isUnset(request.videoMediaMetadata)) {
    body['video_media_metadata'] = request.videoMediaMetadata;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a file or folder.
 *
 * @param request CreateFileRequest
 * @return CreateFileResponse
 */
async function createFile(request: CreateFileRequest): CreateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFileWithOptions(request, headers, runtime);
}

model CreateGroupRequest {
  description?: string(name='description', description='The description of the group. The description can be up to 1,024 characters in length.', example='test group description'),
  groupName?: string(name='group_name', description='The name of the group. The name must be 1 to 128 characters in length.

This parameter is required.', example='test group'),
  isRoot?: boolean(name='is_root', description='Specifies whether the group is a root group. A root group cannot be added to any other group. In most cases, a root group is the top-level organization in the organizational structure.', example='false'),
  parentGroupId?: string(name='parent_group_id', description='The ID of the parent group to which the group is added. If this parameter is specified, the system automatically adds the group to the specified parent group after the group is created.', example='2e43ec8427dd45f19431b7504649a1b3'),
}

model CreateGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Group  
}

/**
 * @summary Creates a group.
 *
 * @param request CreateGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateGroupResponse
 */
async function createGroupWithOptions(request: CreateGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.groupName)) {
    body['group_name'] = request.groupName;
  }
  if (!Util.isUnset(request.isRoot)) {
    body['is_root'] = request.isRoot;
  }
  if (!Util.isUnset(request.parentGroupId)) {
    body['parent_group_id'] = request.parentGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateGroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a group.
 *
 * @param request CreateGroupRequest
 * @return CreateGroupResponse
 */
async function createGroup(request: CreateGroupRequest): CreateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createGroupWithOptions(request, headers, runtime);
}

model CreateIdentityToBenefitPkgMappingRequest {
  amount?: long(name='amount', description='The number of benefit packages.

This parameter takes effect only for the benefit packages of the resource type. Default value: 1.', example='1'),
  benefitPkgId?: string(name='benefit_pkg_id', description='The unique identifier of the benefit package.

This parameter is required.', example='40cb7794c9294'),
  expireTime?: long(name='expire_time', description='The time when the benefit package expires. Set the value to a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.

By default, the benefit package never expires.', example='1633167071000'),
  identityId?: string(name='identity_id', description='The unique identifier of the entity.

If you want to manage the benefits of a user, set this parameter to a user ID.

This parameter is required.', example='user123'),
  identityType?: string(name='identity_type', description='The type of the entity.

If you want to manage the benefits of a user, set this parameter to user.

This parameter is required.', example='user'),
}

model CreateIdentityToBenefitPkgMappingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Creates a mapping between an entity and a benefit package. You can call this operation to associate a benefit package with a user.
 *
 * @description If you need to manage a large number of users based on Drive and Photo Service, you can control the features and quotas that users can use based on the benefits to which they are entitled. For more information, join the DingTalk group (ID 23146118).
 *
 * @param request CreateIdentityToBenefitPkgMappingRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIdentityToBenefitPkgMappingResponse
 */
async function createIdentityToBenefitPkgMappingWithOptions(request: CreateIdentityToBenefitPkgMappingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIdentityToBenefitPkgMappingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.amount)) {
    body['amount'] = request.amount;
  }
  if (!Util.isUnset(request.benefitPkgId)) {
    body['benefit_pkg_id'] = request.benefitPkgId;
  }
  if (!Util.isUnset(request.expireTime)) {
    body['expire_time'] = request.expireTime;
  }
  if (!Util.isUnset(request.identityId)) {
    body['identity_id'] = request.identityId;
  }
  if (!Util.isUnset(request.identityType)) {
    body['identity_type'] = request.identityType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIdentityToBenefitPkgMapping',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/benefit/identity_to_benefit_pkg_mapping/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a mapping between an entity and a benefit package. You can call this operation to associate a benefit package with a user.
 *
 * @description If you need to manage a large number of users based on Drive and Photo Service, you can control the features and quotas that users can use based on the benefits to which they are entitled. For more information, join the DingTalk group (ID 23146118).
 *
 * @param request CreateIdentityToBenefitPkgMappingRequest
 * @return CreateIdentityToBenefitPkgMappingResponse
 */
async function createIdentityToBenefitPkgMapping(request: CreateIdentityToBenefitPkgMappingRequest): CreateIdentityToBenefitPkgMappingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIdentityToBenefitPkgMappingWithOptions(request, headers, runtime);
}

model CreateOrderRequest {
  autoPay?: boolean(name='auto_pay'),
  autoRenew?: boolean(name='auto_renew'),
  code?: string(name='code', description='This parameter is required.'),
  instanceId?: string(name='instance_id', description='This parameter is required.'),
  orderType?: string(name='order_type', description='This parameter is required.'),
  package?: string(name='package', description='This parameter is required.'),
  period?: long(name='period', description='This parameter is required.'),
  periodUnit?: string(name='period_unit', description='This parameter is required.'),
  totalSize?: long(name='total_size', description='This parameter is required.'),
  userCount?: long(name='user_count', description='This parameter is required.'),
}

model CreateOrderResponseBody = {
  instanceId?: string(name='instance_id'),
  orderId?: string(name='order_id'),
}

model CreateOrderResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOrderResponseBody(name='body'),
}

/**
 * @summary 创建凌霄订单
 *
 * @param request CreateOrderRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOrderResponse
 */
async function createOrderWithOptions(request: CreateOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOrderResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoPay)) {
    body['auto_pay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoRenew)) {
    body['auto_renew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.code)) {
    body['code'] = request.code;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['instance_id'] = request.instanceId;
  }
  if (!Util.isUnset(request.orderType)) {
    body['order_type'] = request.orderType;
  }
  if (!Util.isUnset(request.package)) {
    body['package'] = request.package;
  }
  if (!Util.isUnset(request.period)) {
    body['period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    body['period_unit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.totalSize)) {
    body['total_size'] = request.totalSize;
  }
  if (!Util.isUnset(request.userCount)) {
    body['user_count'] = request.userCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrder',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/create_order`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 创建凌霄订单
 *
 * @param request CreateOrderRequest
 * @return CreateOrderResponse
 */
async function createOrder(request: CreateOrderRequest): CreateOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOrderWithOptions(request, headers, runtime);
}

model CreateShareLinkRequest {
  creatable?: boolean(name='creatable'),
  creatableFileIdList?: [ string ](name='creatable_file_id_list'),
  description?: string(name='description', description='The description of the share. The description must be 0 to 1,024 characters in length.'),
  disableDownload?: boolean(name='disable_download', description='Specifies whether to disable the download feature.', example='false'),
  disablePreview?: boolean(name='disable_preview', description='Specifies whether to disable the preview feature.', example='false'),
  disableSave?: boolean(name='disable_save', description='Specifies whether to disable the dump feature.', example='false'),
  downloadLimit?: long(name='download_limit', description='The limit on the number of times that the shared files can be downloaded. The value of this parameter must be equal to or greater than 0. A value of 0 indicates no limit.', example='100'),
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  expiration?: string(name='expiration', description='The time when the share URL expires. The value of this parameter follows the RFC 3339 standard. Example: "2020-06-28T11:33:00.000+08:00". If expiration is set to "", the share URL never expires.', example='2020-06-28T11:33:00.000+08:00'),
  fileIdList?: [ string ](name='file_id_list', description='The IDs of the files to share in the parent path. The number of files in the parent path ranges from 1 to 100. If share_all_files is set to true, this parameter does not take effect. Otherwise, you must specify this parameter.``', example='["520b217f13adf4fc24f2191991b1664ce045b393"]'),
  previewLimit?: long(name='preview_limit', description='The limit on the number of times that the shared files can be previewed. The value of this parameter must be equal to or greater than 0. A value of 0 indicates no limit.', example='100'),
  saveLimit?: long(name='save_limit', description='The limit on the number of times that the shared files can be dumped. The value of this parameter must be equal to or greater than 0. A value of 0 indicates no limit.', example='100'),
  shareAllFiles?: boolean(name='share_all_files', description='Specifies whether to share all files in the drive.', example='true'),
  shareName?: string(name='share_name', description='The name of the share. If you leave this parameter empty, the file name that corresponds to the first ID in the file ID list is used. The name must be 0 to 128 characters in length.'),
  sharePwd?: string(name='share_pwd', description='The access code. An access code must be 0 to 64 bytes in length. If you do not specify this parameter or leave this parameter empty, the files can be accessed without an access code. In this case, you do not need to specify the share_pwd parameter when you call an operation to query the share URL. The access code can contain only visible ASCII characters.', example='abcF123x'),
  userId?: string(name='user_id', description='The user ID.', example='u123'),
}

model CreateShareLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ShareLink  
}

/**
 * @summary Creates a share URL.
 *
 * @description A share is a file view container. You can grant anonymous users the permissions to access files in the user drive by using the share URL. Anonymous users can access the files based on the granted permissions.
 *
 * @param request CreateShareLinkRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateShareLinkResponse
 */
async function createShareLinkWithOptions(request: CreateShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.creatable)) {
    body['creatable'] = request.creatable;
  }
  if (!Util.isUnset(request.creatableFileIdList)) {
    body['creatable_file_id_list'] = request.creatableFileIdList;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.disableDownload)) {
    body['disable_download'] = request.disableDownload;
  }
  if (!Util.isUnset(request.disablePreview)) {
    body['disable_preview'] = request.disablePreview;
  }
  if (!Util.isUnset(request.disableSave)) {
    body['disable_save'] = request.disableSave;
  }
  if (!Util.isUnset(request.downloadLimit)) {
    body['download_limit'] = request.downloadLimit;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.expiration)) {
    body['expiration'] = request.expiration;
  }
  if (!Util.isUnset(request.fileIdList)) {
    body['file_id_list'] = request.fileIdList;
  }
  if (!Util.isUnset(request.previewLimit)) {
    body['preview_limit'] = request.previewLimit;
  }
  if (!Util.isUnset(request.saveLimit)) {
    body['save_limit'] = request.saveLimit;
  }
  if (!Util.isUnset(request.shareAllFiles)) {
    body['share_all_files'] = request.shareAllFiles;
  }
  if (!Util.isUnset(request.shareName)) {
    body['share_name'] = request.shareName;
  }
  if (!Util.isUnset(request.sharePwd)) {
    body['share_pwd'] = request.sharePwd;
  }
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a share URL.
 *
 * @description A share is a file view container. You can grant anonymous users the permissions to access files in the user drive by using the share URL. Anonymous users can access the files based on the granted permissions.
 *
 * @param request CreateShareLinkRequest
 * @return CreateShareLinkResponse
 */
async function createShareLink(request: CreateShareLinkRequest): CreateShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createShareLinkWithOptions(request, headers, runtime);
}

model CreateSimilarImageClusterTaskRequest {
  driveId?: string(name='drive_id', description='This parameter is required.', example='123'),
}

model CreateSimilarImageClusterTaskResponseBody = {
  taskId?: string(name='task_id', example='i:SimilarImageClustering-b67d53e7-2fe8-460f-9b95-1e93636923eb'),
}

model CreateSimilarImageClusterTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSimilarImageClusterTaskResponseBody(name='body'),
}

/**
 * @summary 创建相似图片聚类任务
 *
 * @param request CreateSimilarImageClusterTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSimilarImageClusterTaskResponse
 */
async function createSimilarImageClusterTaskWithOptions(request: CreateSimilarImageClusterTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSimilarImageClusterTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSimilarImageClusterTask',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/create_similar_image_cluster_task`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 创建相似图片聚类任务
 *
 * @param request CreateSimilarImageClusterTaskRequest
 * @return CreateSimilarImageClusterTaskResponse
 */
async function createSimilarImageClusterTask(request: CreateSimilarImageClusterTaskRequest): CreateSimilarImageClusterTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSimilarImageClusterTaskWithOptions(request, headers, runtime);
}

model CreateStoryRequest {
  address?: Address(name='address'),
  customLabels?: map[string]string(name='custom_labels', deprecated=true),
  driveId?: string(name='drive_id', description='This parameter is required.', example='1'),
  maxImageCount?: long(name='max_image_count', example='30', nullable=true),
  minImageCount?: long(name='min_image_count', example='1', nullable=true),
  storyEndTime?: string(name='story_end_time', example='2022-12-30T16:00:00Z'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
  storyName?: string(name='story_name'),
  storyStartTime?: string(name='story_start_time', example='2016-12-30T16:00:00Z'),
  storySubType?: string(name='story_sub_type', example='Food'),
  storyType?: string(name='story_type', description='This parameter is required.', example='TagMemory'),
}

model CreateStoryResponseBody = {
  driveId?: string(name='drive_id', example='1'),
}

model CreateStoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateStoryResponseBody(name='body'),
}

/**
 * @summary 创建推荐故事
 *
 * @param request CreateStoryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateStoryResponse
 */
async function createStoryWithOptions(request: CreateStoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateStoryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.address)) {
    body['address'] = request.address;
  }
  if (!Util.isUnset(request.customLabels)) {
    body['custom_labels'] = request.customLabels;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.maxImageCount)) {
    body['max_image_count'] = request.maxImageCount;
  }
  if (!Util.isUnset(request.minImageCount)) {
    body['min_image_count'] = request.minImageCount;
  }
  if (!Util.isUnset(request.storyEndTime)) {
    body['story_end_time'] = request.storyEndTime;
  }
  if (!Util.isUnset(request.storyId)) {
    body['story_id'] = request.storyId;
  }
  if (!Util.isUnset(request.storyName)) {
    body['story_name'] = request.storyName;
  }
  if (!Util.isUnset(request.storyStartTime)) {
    body['story_start_time'] = request.storyStartTime;
  }
  if (!Util.isUnset(request.storySubType)) {
    body['story_sub_type'] = request.storySubType;
  }
  if (!Util.isUnset(request.storyType)) {
    body['story_type'] = request.storyType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateStory',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/create_story`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 创建推荐故事
 *
 * @param request CreateStoryRequest
 * @return CreateStoryResponse
 */
async function createStory(request: CreateStoryRequest): CreateStoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createStoryWithOptions(request, headers, runtime);
}

model CreateUserRequest {
  avatar?: string(name='avatar', description='The URL of the profile picture.

If you specify the parameter in the HTTP URL format, the URL must start with http:// or https:// and can be up to 4 KB in size.

If you specify the parameter in the data URL format, the URL must start with data:// and be encoded in Base64. The URL can be up to 300 KB in size.', example='http://a.b.c/pds.jpg'),
  description?: string(name='description', description='The description of the user. The description can be up to 1,024 characters in length.', example='The VIP user'),
  email?: string(name='email', description='The email address.', example='123@pds.com'),
  groupInfoList?: [ 
    {
      groupId?: string(name='group_id', description='The group ID.', example='g123'),
    }
  ](name='group_info_list', description='The information about the group.'),
  nickName?: string(name='nick_name', description='The nickname of the user. The nickname can be up to 128 characters in length.', example='pdsuer'),
  phone?: string(name='phone', description='The phone number.', example='13900001111'),
  role?: string(name='role', description='The role of the user. Default value: user. Valid values:

*   superadmin
*   admin
*   user

If the domain can be divided into subdomains, the subdomain_super_admin and subdomain_admin roles are also supported.

Valid values:

*   subdomain_super_admin

    <!-- -->

    <!-- -->

    <!-- -->

*   subdomain_admin

    <!-- -->

    <!-- -->

    <!-- -->

*   superadmin

    <!-- -->

    <!-- -->

    <!-- -->

*   admin

    <!-- -->

    <!-- -->

    <!-- -->

*   user

    <!-- -->

    <!-- -->

    <!-- -->', example='user'),
  status?: string(name='status', description='The state of the user. Default value: enabled. Valid values:

*   enabled: The user is in a normal state.
*   disabled: The user is prohibited from logon.', example='enabled'),
  userData?: map[string]any(name='user_data', description='The custom data. The data can be up to 1,024 characters in length.', example='md'),
  userId?: string(name='user_id', description='The user ID. The ID can be up to 64 characters in length and cannot contain number signs (#).

This parameter is required.', example='pdsuserid1'),
  userName?: string(name='user_name', description='The username. The username can be up to 128 characters in length.', example='pdsusername'),
}

model CreateUserResponseBody = {
  avatar?: string(name='avatar', description='The URL of the profile picture.', example='http://aa.com/1.jpg'),
  createdAt?: long(name='created_at', description='The time when the user was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1639762579768'),
  creator?: string(name='creator', description='The user who created the user.', example='user1'),
  defaultDriveId?: string(name='default_drive_id', description='The ID of the default drive.', example='1'),
  description?: string(name='description', description='The description of the user.', example='vipuser'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  email?: string(name='email', description='The email address.', example='a@a.com'),
  nickName?: string(name='nick_name', description='The nickname of the user.', example='001'),
  phone?: string(name='phone', description='The phone number.', example='13900001111'),
  role?: string(name='role', description='The role of the user. Valid values:

*   superadmin
*   admin
*   user', example='admin'),
  status?: string(name='status', description='The state of the user. Valid values:

*   disabled: The user is prohibited from logon.
*   enabled: The user is in a normal state.', example='enabled'),
  updatedAt?: long(name='updated_at', description='The time when the user was modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1639762579768'),
  userData?: map[string]any(name='user_data', description='The custom data.'),
  userId?: string(name='user_id', description='The user ID.', example='dingding_abc001'),
  userName?: string(name='user_name', description='The username.', example='pds'),
}

model CreateUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateUserResponseBody(name='body'),
}

/**
 * @summary Creates a user.
 *
 * @param request CreateUserRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUserResponse
 */
async function createUserWithOptions(request: CreateUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.avatar)) {
    body['avatar'] = request.avatar;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.email)) {
    body['email'] = request.email;
  }
  if (!Util.isUnset(request.groupInfoList)) {
    body['group_info_list'] = request.groupInfoList;
  }
  if (!Util.isUnset(request.nickName)) {
    body['nick_name'] = request.nickName;
  }
  if (!Util.isUnset(request.phone)) {
    body['phone'] = request.phone;
  }
  if (!Util.isUnset(request.role)) {
    body['role'] = request.role;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.userData)) {
    body['user_data'] = request.userData;
  }
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }
  if (!Util.isUnset(request.userName)) {
    body['user_name'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Creates a user.
 *
 * @param request CreateUserRequest
 * @return CreateUserResponse
 */
async function createUser(request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createUserWithOptions(request, headers, runtime);
}

model CsiGetFileInfoRequest {
  driveId?: string(name='drive_id', description='This parameter is required.', example='1'),
  fileId?: string(name='file_id', description='This parameter is required.', example='9520943DC264'),
  urlExpireSec?: int32(name='url_expire_sec', example='100'),
}

model CsiGetFileInfoResponseBody = {
  investigationInfo?: InvestigationInfo(name='investigation_info'),
  url?: string(name='url', example='https://data.aliyunpds.com/hz22%2F5d5b986facbec311ef844c25954f96821497b383%2F5d5b986f955410dd991646bb87c6b4e899eff525?Expires=xxx&OSSAccessKeyId=xxx&Signature=xxx'),
}

model CsiGetFileInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CsiGetFileInfoResponseBody(name='body'),
}

/**
 * @summary 获取文件内容安全信息
 *
 * @param request CsiGetFileInfoRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CsiGetFileInfoResponse
 */
async function csiGetFileInfoWithOptions(request: CsiGetFileInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CsiGetFileInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.urlExpireSec)) {
    body['url_expire_sec'] = request.urlExpireSec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CsiGetFileInfo',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/csi/get_file_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 获取文件内容安全信息
 *
 * @param request CsiGetFileInfoRequest
 * @return CsiGetFileInfoResponse
 */
async function csiGetFileInfo(request: CsiGetFileInfoRequest): CsiGetFileInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return csiGetFileInfoWithOptions(request, headers, runtime);
}

model DeleteDomainRequest {
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
}

model DeleteDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Delete the domain
 *
 * @param request DeleteDomainRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDomainResponse
 */
async function deleteDomainWithOptions(request: DeleteDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainId)) {
    body['domain_id'] = request.domainId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomain',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Delete the domain
 *
 * @param request DeleteDomainRequest
 * @return DeleteDomainResponse
 */
async function deleteDomain(request: DeleteDomainRequest): DeleteDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDomainWithOptions(request, headers, runtime);
}

model DeleteDriveRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
}

model DeleteDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a drive.
 *
 * @param request DeleteDriveRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDriveResponse
 */
async function deleteDriveWithOptions(request: DeleteDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a drive.
 *
 * @param request DeleteDriveRequest
 * @return DeleteDriveResponse
 */
async function deleteDrive(request: DeleteDriveRequest): DeleteDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDriveWithOptions(request, headers, runtime);
}

model DeleteFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fileId?: string(name='file_id', description='The file ID or folder ID.

This parameter is required.', example='9520943DC264'),
}

model DeleteFileResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task. This parameter is returned only in asynchronous processing scenarios. You can call the [GetAsyncTask](https://help.aliyun.com/document_detail/440456.html) operation to query the information about the asynchronous task based on the task ID.', example='000e89fb-cf8f-11e9-8ab4-b6e980803a3b'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
}

model DeleteFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFileResponseBody(name='body'),
}

/**
 * @summary Deletes a file or folder.
 *
 * @param request DeleteFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFileResponse
 */
async function deleteFileWithOptions(request: DeleteFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a file or folder.
 *
 * @param request DeleteFileRequest
 * @return DeleteFileResponse
 */
async function deleteFile(request: DeleteFileRequest): DeleteFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFileWithOptions(request, headers, runtime);
}

model DeleteGroupRequest {
  groupId?: string(name='group_id', description='The group ID.

This parameter is required.', example='g123'),
}

model DeleteGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes groups. Before you delete a group, make sure that no other groups or users exist in the group. Otherwise, the group fails to be deleted.
 *
 * @param request DeleteGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGroupResponse
 */
async function deleteGroupWithOptions(request: DeleteGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes groups. Before you delete a group, make sure that no other groups or users exist in the group. Otherwise, the group fails to be deleted.
 *
 * @param request DeleteGroupRequest
 * @return DeleteGroupResponse
 */
async function deleteGroup(request: DeleteGroupRequest): DeleteGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGroupWithOptions(request, headers, runtime);
}

model DeleteRevisionRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
  revisionId?: string(name='revision_id', description='The version ID.

This parameter is required.', example='40CB7794C929'),
}

model DeleteRevisionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a historical version of a file. You cannot delete the latest version of a file.
 *
 * @param request DeleteRevisionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRevisionResponse
 */
async function deleteRevisionWithOptions(request: DeleteRevisionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRevisionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.revisionId)) {
    body['revision_id'] = request.revisionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRevision',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/revision/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a historical version of a file. You cannot delete the latest version of a file.
 *
 * @param request DeleteRevisionRequest
 * @return DeleteRevisionResponse
 */
async function deleteRevision(request: DeleteRevisionRequest): DeleteRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRevisionWithOptions(request, headers, runtime);
}

model DeleteStoryRequest {
  driveId?: string(name='drive_id', description='This parameter is required.', example='1'),
  storyId?: string(name='story_id', description='This parameter is required.', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model DeleteStoryResponseBody = {
  driveId?: string(name='drive_id', example='1'),
}

model DeleteStoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteStoryResponseBody(name='body'),
}

/**
 * @summary 删除故事
 *
 * @param request DeleteStoryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteStoryResponse
 */
async function deleteStoryWithOptions(request: DeleteStoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteStoryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.storyId)) {
    body['story_id'] = request.storyId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteStory',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/delete_story`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 删除故事
 *
 * @param request DeleteStoryRequest
 * @return DeleteStoryResponse
 */
async function deleteStory(request: DeleteStoryRequest): DeleteStoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteStoryWithOptions(request, headers, runtime);
}

model DeleteUserRequest {
  userId?: string(name='user_id', description='The user ID.

This parameter is required.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
}

model DeleteUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Deletes a user.
 *
 * @param request DeleteUserRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteUserResponse
 */
async function deleteUserWithOptions(request: DeleteUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Deletes a user.
 *
 * @param request DeleteUserRequest
 * @return DeleteUserResponse
 */
async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteUserWithOptions(request, headers, runtime);
}

model DeltaGetLastCursorRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  syncRootId?: string(name='sync_root_id', description='The ID of the root file of the synced folder.', example='622fb09598ae66777c7040109a16f49381f6abe1'),
}

model DeltaGetLastCursorResponseBody = {
  cursor?: string(name='cursor', description='The latest cursor of incremental information in the specified drive or synced folder.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model DeltaGetLastCursorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeltaGetLastCursorResponseBody(name='body'),
}

/**
 * @summary Queries the cursor of incremental information.
 *
 * @param request DeltaGetLastCursorRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeltaGetLastCursorResponse
 */
async function deltaGetLastCursorWithOptions(request: DeltaGetLastCursorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeltaGetLastCursorResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.syncRootId)) {
    body['sync_root_id'] = request.syncRootId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeltaGetLastCursor',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get_last_cursor`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the cursor of incremental information.
 *
 * @param request DeltaGetLastCursorRequest
 * @return DeltaGetLastCursorResponse
 */
async function deltaGetLastCursor(request: DeltaGetLastCursorRequest): DeltaGetLastCursorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deltaGetLastCursorWithOptions(request, headers, runtime);
}

model DownloadFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', description='The method used to generate the thumbnail of an image. If this parameter is specified, you are redirected to the URL of the generated thumbnail.', example='image/resize,m_fill,h_128,w_128,limit_0'),
  officeThumbnailProcess?: string(name='office_thumbnail_process', description='The method used to generate the thumbnail of a document. If this parameter is specified, you are redirected to the URL of the generated thumbnail.', example='image/resize,w_200'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a share link, carry the `x-share-token` header for authentication in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify one of `share_id` and `drive_id`.', example='7JQX1FswpQ8'),
  videoThumbnailProcess?: string(name='video_thumbnail_process', description='The method used to generate the thumbnail of a video. If this parameter is specified, you are redirected to the URL of the generated thumbnail.', example='video/snapshot,t_7000,f_jpg,w_800,h_600,m_fast'),
}

model DownloadFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Downloads a file.
 *
 * @description For information about best practices for downloading a file.
 *
 * @param request DownloadFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DownloadFileResponse
 */
async function downloadFileWithOptions(request: DownloadFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DownloadFileResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    query['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    query['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    query['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.officeThumbnailProcess)) {
    query['office_thumbnail_process'] = request.officeThumbnailProcess;
  }
  if (!Util.isUnset(request.shareId)) {
    query['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.videoThumbnailProcess)) {
    query['video_thumbnail_process'] = request.videoThumbnailProcess;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DownloadFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/download`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'binary',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Downloads a file.
 *
 * @description For information about best practices for downloading a file.
 *
 * @param request DownloadFileRequest
 * @return DownloadFileResponse
 */
async function downloadFile(request: DownloadFileRequest): DownloadFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return downloadFileWithOptions(request, headers, runtime);
}

model FileAddPermissionRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fileId?: string(name='file_id', description='The ID of the folder. If you want to authorize a user or group to access a team drive, set this parameter to root. If you want to authorize a user or group to access an individual drive, you cannot set this parameter to root.

This parameter is required.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406'),
  memberList?: [
    FilePermissionMember
  ](name='member_list', description='The members that are authorized to access files.

This parameter is required.'),
}

model FileAddPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Grants permissions to access files to a user or group.
 *
 * @param request FileAddPermissionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return FileAddPermissionResponse
 */
async function fileAddPermissionWithOptions(request: FileAddPermissionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FileAddPermissionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.memberList)) {
    body['member_list'] = request.memberList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FileAddPermission',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/add_permission`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Grants permissions to access files to a user or group.
 *
 * @param request FileAddPermissionRequest
 * @return FileAddPermissionResponse
 */
async function fileAddPermission(request: FileAddPermissionRequest): FileAddPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fileAddPermissionWithOptions(request, headers, runtime);
}

model FileDeleteUserTagsRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
  keyList?: [ string ](name='key_list', description='The tags that you want to remove from a file. You cannot leave this parameter empty. You can specify up to 1,000 tags.

This parameter is required.'),
}

model FileDeleteUserTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Removes custom tags from a file.
 *
 * @param request FileDeleteUserTagsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return FileDeleteUserTagsResponse
 */
async function fileDeleteUserTagsWithOptions(request: FileDeleteUserTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FileDeleteUserTagsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.keyList)) {
    body['key_list'] = request.keyList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FileDeleteUserTags',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/delete_usertags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Removes custom tags from a file.
 *
 * @param request FileDeleteUserTagsRequest
 * @return FileDeleteUserTagsResponse
 */
async function fileDeleteUserTags(request: FileDeleteUserTagsRequest): FileDeleteUserTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fileDeleteUserTagsWithOptions(request, headers, runtime);
}

model FileListPermissionRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='4221bf6e6ab43a255edc4463bffa6f5f5d317401'),
}

model FileListPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [
    FilePermissionMember
  ](name='body'),
}

/**
 * @summary Queries the sharing authorization records of a file.
 *
 * @param request FileListPermissionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return FileListPermissionResponse
 */
async function fileListPermissionWithOptions(request: FileListPermissionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FileListPermissionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FileListPermission',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/list_permission`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the sharing authorization records of a file.
 *
 * @param request FileListPermissionRequest
 * @return FileListPermissionResponse
 */
async function fileListPermission(request: FileListPermissionRequest): FileListPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fileListPermissionWithOptions(request, headers, runtime);
}

model FilePutUserTagsRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
  userTags?: [ 
    {
      key?: string(name='key', description='The name of the tag. The tag name cannot be empty and cannot contain number signs (#).

This parameter is required.', example='tag'),
      value?: string(name='value', description='The value of the tag. The tag value cannot contain number signs (#).', example='value'),
    }
  ](name='user_tags', description='The tags to be added to the file. You cannot leave this parameter empty. You can specify up to 1,000 tags. You cannot specify tags that have the same name.

This parameter is required.'),
}

model FilePutUserTagsResponseBody = {
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
}

model FilePutUserTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: FilePutUserTagsResponseBody(name='body'),
}

/**
 * @summary Adds custom tags to a file.
 *
 * @description This operation is an incremental update operation. Take note of the following items:
 * *   If a tag name specified in the request is the same as an existing tag name, the existing tag is overwritten.
 * *   If a tag name specified in the request is different from the existing tag names, the specified tag is added.
 * *   The existing tags with unique names are not affected.
 *
 * @param request FilePutUserTagsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return FilePutUserTagsResponse
 */
async function filePutUserTagsWithOptions(request: FilePutUserTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FilePutUserTagsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.userTags)) {
    body['user_tags'] = request.userTags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FilePutUserTags',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/put_usertags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Adds custom tags to a file.
 *
 * @description This operation is an incremental update operation. Take note of the following items:
 * *   If a tag name specified in the request is the same as an existing tag name, the existing tag is overwritten.
 * *   If a tag name specified in the request is different from the existing tag names, the specified tag is added.
 * *   The existing tags with unique names are not affected.
 *
 * @param request FilePutUserTagsRequest
 * @return FilePutUserTagsResponse
 */
async function filePutUserTags(request: FilePutUserTagsRequest): FilePutUserTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return filePutUserTagsWithOptions(request, headers, runtime);
}

model FileRemovePermissionRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406'),
  memberList?: [ 
    {
      identity?: Identity(name='identity', description='The identity to whom the permissions are granted, which is a user or a group.

This parameter is required.'),
      roleId?: string(name='role_id', description='The role ID. You can grant permissions by assigning roles to identities, or you can customize the permissions. To grant permissions by assigning roles to identities, specify role_id. role_id and action_list are mutually exclusive. If both parameters are specified, role_id has a higher priority.

Valid values:

SystemFileOwner: collaborator.

SystemFileDownloader: downloader.

SystemFileEditor: editor.

SystemFileEditorWithoutDelete: editor without permissions to delete the file.

SystemFileEditorWithoutShareLink: editor without permissions to share the file.

SystemFileMetaViewer: viewer of lists.

SystemFileUploader: uploader. SystemFileUploaderAndDownloader: uploader and downloader.

SystemFileDownloaderWithShareLink: downloader and sharer.

SystemFileUploaderAndDownloaderWithShareLink: uploader, downloader, and sharer.

SystemFileUploaderAndViewer: viewer and uploader.

SystemFileUploaderWithShareLink: uploader and sharer.

SystemFileViewer: viewer.

This parameter is required.', example='SystemFileDownloader'),
    }
  ](name='member_list', description='The identities with whom the file is shared.

This parameter is required.'),
}

model FileRemovePermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Cancels the permissions on a shared file.
 *
 * @param request FileRemovePermissionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return FileRemovePermissionResponse
 */
async function fileRemovePermissionWithOptions(request: FileRemovePermissionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FileRemovePermissionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.memberList)) {
    body['member_list'] = request.memberList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FileRemovePermission',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/remove_permission`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Cancels the permissions on a shared file.
 *
 * @param request FileRemovePermissionRequest
 * @return FileRemovePermissionResponse
 */
async function fileRemovePermission(request: FileRemovePermissionRequest): FileRemovePermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fileRemovePermissionWithOptions(request, headers, runtime);
}

model GetAsyncTaskRequest {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

This parameter is required.', example='000e89fb-cf8f-11e9-8ab4-b6e980803a3b'),
}

model GetAsyncTaskResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.', example='000e89fb-cf8f-11e9-8ab4-b6e980803a3b'),
  category?: string(name='category', description='The custom category of the task.', example='album'),
  consumedProcess?: long(name='consumed_process', description='The total amount of work that is done in the asynchronous task, such as the number of files that are packaged for package download on the server.', example='100'),
  createdAt?: string(name='created_at', description='The time when the task was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. Example: 2019-03-28T13:03:29.298Z.', example='2019-08-20T06:51:27.292Z'),
  errCode?: long(name='err_code', description='<warning>This parameter is no longer used. We recommend that you use error_code instead.</warning>

The error code returned if the asynchronous task failed.', example='InternalError'),
  errorCode?: string(name='error_code', description='The error code returned if the asynchronous task failed.', example='InternalError'),
  errorMessage?: string(name='error_message', description='The error message returned if the asynchronous task failed.', example='The request has been failed due to some unknown error. Please try again later.'),
  failedProcess?: long(name='failed_process'),
  finishedAt?: string(name='finished_at', description='The time when the task was complete. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. Example: 2019-03-28T13:03:29.298Z.', example='2019-08-20T06:51:27.292Z'),
  message?: string(name='message', description='<warning>This parameter is no longer used. We recommend that you use error_message instead.</warning>

The error message returned if the asynchronous task failed.', example='The request has been failed due to some unknown error. Please try again later.'),
  skippedProcess?: long(name='skipped_process'),
  startedAt?: string(name='started_at', description='The time when the task was started. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. Example: 2019-03-28T13:03:29.298Z.', example='2019-08-20T06:51:27.292Z'),
  state?: string(name='state', description='The state of the task. Valid values:

*   Failed
*   Running
*   PartialSucceed
*   Succeed', example='Succeed'),
  status?: string(name='status', description='<warning>This parameter is no longer used. We recommend that you use state instead.</warning>

The state of the task. Valid values:

*   Failed
*   Running
*   PartialSucceed
*   Succeed', example='Succeed'),
  totalProcess?: long(name='total_process', description='The total amount of work to be done in the asynchronous task, such as the number of files to be packaged for package download on the server.', example='1000'),
  uncompressFileList?: [
    UncompressedFileInfo
  ](name='uncompress_file_list', description='The extracted files.'),
  url?: string(name='url', description='The download URL of the data generated by the asynchronous task, such as the download URL of the packaged files generated by the task of package download on the server.', example='https://data.aliyunpds.com/hz22%2F5d5b986facbec311ef844c25954f96821497b383%2F5d5b986f955410dd991646bb87c6b4e899eff525?Expires=xxx&OSSAccessKeyId=xxx&Signature=xxx'),
}

model GetAsyncTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAsyncTaskResponseBody(name='body'),
}

/**
 * @summary Queries the information about an asynchronous task.
 *
 * @param request GetAsyncTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAsyncTaskResponse
 */
async function getAsyncTaskWithOptions(request: GetAsyncTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAsyncTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.asyncTaskId)) {
    body['async_task_id'] = request.asyncTaskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetAsyncTask',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/async_task/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the information about an asynchronous task.
 *
 * @param request GetAsyncTaskRequest
 * @return GetAsyncTaskResponse
 */
async function getAsyncTask(request: GetAsyncTaskRequest): GetAsyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAsyncTaskWithOptions(request, headers, runtime);
}

model GetDefaultDriveRequest {
  userId?: string(name='user_id', description='The user ID. If you use an AccessKey pair for authentication, you must specify this parameter. If you use an access token for authentication, this parameter is optional. By default, the user ID associated with the access token is used.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
}

model GetDefaultDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Drive  
}

/**
 * @summary Queries the default drive of a user.
 *
 * @param request GetDefaultDriveRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDefaultDriveResponse
 */
async function getDefaultDriveWithOptions(request: GetDefaultDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDefaultDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDefaultDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/get_default_drive`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the default drive of a user.
 *
 * @param request GetDefaultDriveRequest
 * @return GetDefaultDriveResponse
 */
async function getDefaultDrive(request: GetDefaultDriveRequest): GetDefaultDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDefaultDriveWithOptions(request, headers, runtime);
}

model GetDomainRequest {
  domainId?: string(name='domain_id', description='The ID of the domain.

This parameter is required.', example='bj1'),
  fields?: string(name='fields'),
  getQuotaUsed?: boolean(name='get_quota_used', description='Specifies whether to return the used quota of the domain. Default value: false. If the quota of the domain is greater than 0 and you set this parameter to true, the used quota of the domain is returned.', example='true'),
}

model GetDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Domain  
}

/**
 * @summary Get domain information.
 *
 * @param request GetDomainRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDomainResponse
 */
async function getDomainWithOptions(request: GetDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainId)) {
    body['domain_id'] = request.domainId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.getQuotaUsed)) {
    body['get_quota_used'] = request.getQuotaUsed;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDomain',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Get domain information.
 *
 * @param request GetDomainRequest
 * @return GetDomainResponse
 */
async function getDomain(request: GetDomainRequest): GetDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDomainWithOptions(request, headers, runtime);
}

model GetDomainQuotaResponseBody = {
  sizeQuota?: long(name='size_quota'),
  sizeUsed?: long(name='size_used'),
  userCountQuota?: long(name='user_count_quota'),
  userCountUsed?: long(name='user_count_used'),
}

model GetDomainQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDomainQuotaResponseBody(name='body'),
}

/**
 * @summary 获取domain限额
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDomainQuotaResponse
 */
async function getDomainQuotaWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetDomainQuotaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDomainQuota',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/get_quota`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 获取domain限额
 *
 * @return GetDomainQuotaResponse
 */
async function getDomainQuota(): GetDomainQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDomainQuotaWithOptions(headers, runtime);
}

model GetDownloadUrlRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  expireSec?: int32(name='expire_sec', description='The validity period of the download URL. Maximum value: 115200. Default value: 900. Unit: seconds.', example='100'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
  fileName?: string(name='file_name', description='The name of the file. The name can be up to 1,024 characters in length.', example='1.txt'),
  responseContentType?: string(name='response_content_type', example='video/mp4'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a sharing link, carry the `x-share-token` header in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify at least either `share_id` or `drive_id`.', example='7JQX1FswpQ8'),
}

model GetDownloadUrlResponseBody = {
  cdnUrl?: string(name='cdn_url', description='The download URL of a file that is downloaded by using Alibaba Cloud CDN.', example='https://data-cdn.aliyunpds.com/hz22%2F5d79219b0aa9a7c995a94a96993ba3205cd91c5a%2F5d79219bf3261a5d38744da0834ed489b677a27a?Expires=xxxOSSAccessKeyId=xxx&Signature=xxx&response-content-disposition=attachment%3Bfilename%3DtBiZAoJPC2c8b13450eda4292b7f5f8010618e078.txt'),
  contentHash?: string(name='content_hash', description='The hash value of the file content.', example='EA4942AA8761213890A5C386F88E6464D2C31CA1'),
  contentHashName?: string(name='content_hash_name', description='The name of the algorithm that is used to calculate the hash value of the file content.', example='sha1'),
  crc64Hash?: string(name='crc64_hash', description='The hash value calculated by using 64-bit cyclic redundancy check (CRC-64).', example='5498595269368962671'),
  expiration?: string(name='expiration', description='The time when the download URL expires.', example='2022-01-02T15:04:05.999Z07:00'),
  internalUrl?: string(name='internal_url', description='The download URL of a file that is downloaded over a virtual private cloud (VPC).', example='https://data-vpc.aliyunpds.com/hz22%2F5d79219b0aa9a7c995a94a96993ba3205cd91c5a%2F5d79219bf3261a5d38744da0834ed489b677a27a?Expires=xxxOSSAccessKeyId=xxx&Signature=xxx&response-content-disposition=attachment%3Bfilename%3DtBiZAoJPC2c8b13450eda4292b7f5f8010618e078.txt'),
  size?: long(name='size', description='The size of the file. Unit: bytes.', example='10'),
  url?: string(name='url', description='The download URL of a file that is downloaded over the Internet.', example='https://data.aliyunpds.com/hz22%2F5d79219b0aa9a7c995a94a96993ba3205cd91c5a%2F5d79219bf3261a5d38744da0834ed489b677a27a?Expires=xxxOSSAccessKeyId=xxx&Signature=xxx&response-content-disposition=attachment%3Bfilename%3DtBiZAoJPC2c8b13450eda4292b7f5f8010618e078.txt'),
}

model GetDownloadUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDownloadUrlResponseBody(name='body'),
}

/**
 * @summary Queries the download URL of a file. For more information about best practices, visit https://help.aliyun.com/document_detail/175889.html.
 *
 * @param request GetDownloadUrlRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDownloadUrlResponse
 */
async function getDownloadUrlWithOptions(request: GetDownloadUrlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDownloadUrlResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.expireSec)) {
    body['expire_sec'] = request.expireSec;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.fileName)) {
    body['file_name'] = request.fileName;
  }
  if (!Util.isUnset(request.responseContentType)) {
    body['response_content_type'] = request.responseContentType;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDownloadUrl',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get_download_url`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the download URL of a file. For more information about best practices, visit https://help.aliyun.com/document_detail/175889.html.
 *
 * @param request GetDownloadUrlRequest
 * @return GetDownloadUrlResponse
 */
async function getDownloadUrl(request: GetDownloadUrlRequest): GetDownloadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDownloadUrlWithOptions(request, headers, runtime);
}

model GetDriveRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
}

model GetDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Drive  
}

/**
 * @summary Queries the information about a drive.
 *
 * @param request GetDriveRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDriveResponse
 */
async function getDriveWithOptions(request: GetDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the information about a drive.
 *
 * @param request GetDriveRequest
 * @return GetDriveResponse
 */
async function getDrive(request: GetDriveRequest): GetDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDriveWithOptions(request, headers, runtime);
}

model GetFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fields?: string(name='fields', description='The fields to return.

1.  If this parameter is set to \\\\*, all fields of the file except the fields that must be specified are returned.
2.  If only specific fields are required, you can specify the following fields: url, thumbnail, exif, cropping_suggestion, characteristic_hash, video_metadata, and video_preview_metadata. If multiple fields are required, separate them with commas (,). Example: url,thumbnail.
3.  The investigation_info field is returned only if you specify this field.

By default, all fields except the fields that must be specified are returned.', example='*'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a share link, carry the `x-share-token` header for authentication in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify one of `share_id` and `drive_id`.', example='7JQX1FswpQ8'),
  thumbnailProcesses?: map[string]ImageProcess(name='thumbnail_processes', description='缩略图配置，可一次性返回最多5个缩略图，map的key可以自定义，返回时按key返回对应的缩略图链接'),
  urlExpireSec?: int32(name='url_expire_sec', description='The time when the file expires. Unit: seconds. Valid values: 10 to 14400.', example='100'),
}

model GetFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: File  
}

/**
 * @summary Queries the information about a file.
 *
 * @param request GetFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileResponse
 */
async function getFileWithOptions(request: GetFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.thumbnailProcesses)) {
    body['thumbnail_processes'] = request.thumbnailProcesses;
  }
  if (!Util.isUnset(request.urlExpireSec)) {
    body['url_expire_sec'] = request.urlExpireSec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the information about a file.
 *
 * @param request GetFileRequest
 * @return GetFileResponse
 */
async function getFile(request: GetFileRequest): GetFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFileWithOptions(request, headers, runtime);
}

model GetGroupRequest {
  groupId?: string(name='group_id', description='The group ID.

This parameter is required.', example='2e43ec8427dd45f19431b7504649a1b1'),
}

model GetGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Group  
}

/**
 * @summary Queries the information about a group.
 *
 * @param request GetGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetGroupResponse
 */
async function getGroupWithOptions(request: GetGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetGroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the information about a group.
 *
 * @param request GetGroupRequest
 * @return GetGroupResponse
 */
async function getGroup(request: GetGroupRequest): GetGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getGroupWithOptions(request, headers, runtime);
}

model GetIdentityToBenefitPkgMappingRequest {
  benefitPkgId?: string(name='benefit_pkg_id', description='The unique identifier of the benefit package.

This parameter is required.', example='40cb7794c9294'),
  identityId?: string(name='identity_id', description='The unique identifier of the entity.

If you want to manage the benefits of a user, set this parameter to a user ID.

This parameter is required.', example='user123'),
  identityType?: string(name='identity_type', description='The type of the entity. If you want to manage the benefits of a user, set this parameter to user.

This parameter is required.', example='user'),
}

model GetIdentityToBenefitPkgMappingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: IdentityToBenefitPkgMapping  
}

/**
 * @summary Queries the mapping between an entity and a benefit package. You can call this operation to query the benefit package that is associated with a user.
 *
 * @param request GetIdentityToBenefitPkgMappingRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetIdentityToBenefitPkgMappingResponse
 */
async function getIdentityToBenefitPkgMappingWithOptions(request: GetIdentityToBenefitPkgMappingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetIdentityToBenefitPkgMappingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.benefitPkgId)) {
    body['benefit_pkg_id'] = request.benefitPkgId;
  }
  if (!Util.isUnset(request.identityId)) {
    body['identity_id'] = request.identityId;
  }
  if (!Util.isUnset(request.identityType)) {
    body['identity_type'] = request.identityType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetIdentityToBenefitPkgMapping',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/benefit/identity_to_benefit_pkg_mapping/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the mapping between an entity and a benefit package. You can call this operation to query the benefit package that is associated with a user.
 *
 * @param request GetIdentityToBenefitPkgMappingRequest
 * @return GetIdentityToBenefitPkgMappingResponse
 */
async function getIdentityToBenefitPkgMapping(request: GetIdentityToBenefitPkgMappingRequest): GetIdentityToBenefitPkgMappingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIdentityToBenefitPkgMappingWithOptions(request, headers, runtime);
}

model GetLinkInfoRequest {
  extra?: string(name='extra'),
  identity?: string(name='identity', description='This parameter is required.', example='130***'),
  type?: string(name='type', description='This parameter is required.', example='mobile'),
}

model GetLinkInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AccountLinkInfo  
}

/**
 * @summary 获取用户认证方式详情
 *
 * @param request GetLinkInfoRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLinkInfoResponse
 */
async function getLinkInfoWithOptions(request: GetLinkInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLinkInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extra)) {
    body['extra'] = request.extra;
  }
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetLinkInfo',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/account/get_link_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 获取用户认证方式详情
 *
 * @param request GetLinkInfoRequest
 * @return GetLinkInfoResponse
 */
async function getLinkInfo(request: GetLinkInfoRequest): GetLinkInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLinkInfoWithOptions(request, headers, runtime);
}

model GetLinkInfoByUserIdRequest {
  userId?: string(name='user_id', description='The user ID.', example='xxx'),
}

model GetLinkInfoByUserIdResponseBody = {
  items?: [
    AccountLinkInfo
  ](name='items', description='The information about the users.'),
}

model GetLinkInfoByUserIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLinkInfoByUserIdResponseBody(name='body'),
}

/**
 * @summary Queries the information about a user based on the user ID.
 *
 * @param request GetLinkInfoByUserIdRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLinkInfoByUserIdResponse
 */
async function getLinkInfoByUserIdWithOptions(request: GetLinkInfoByUserIdRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLinkInfoByUserIdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetLinkInfoByUserId',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/account/get_link_info_by_user_id`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the information about a user based on the user ID.
 *
 * @param request GetLinkInfoByUserIdRequest
 * @return GetLinkInfoByUserIdResponse
 */
async function getLinkInfoByUserId(request: GetLinkInfoByUserIdRequest): GetLinkInfoByUserIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLinkInfoByUserIdWithOptions(request, headers, runtime);
}

model GetRevisionRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fields?: string(name='fields', description='Specifies the returned fields.

By default, this parameter is left empty. If you set this parameter to \\\\*, all fields are returned. If you leave this parameter empty, the creator of the file is not returned.', example='*'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
  revisionId?: string(name='revision_id', description='The version ID.

This parameter is required.', example='40CB7794C929'),
  urlExpireSec?: long(name='url_expire_sec', description='The validity period of the file download or preview. Valid values: 10 to 86400.

Default value: 900. Unit: seconds.', example='900'),
}

model GetRevisionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Revision  
}

/**
 * @summary Queries the information about a version.
 *
 * @param request GetRevisionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRevisionResponse
 */
async function getRevisionWithOptions(request: GetRevisionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRevisionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.revisionId)) {
    body['revision_id'] = request.revisionId;
  }
  if (!Util.isUnset(request.urlExpireSec)) {
    body['url_expire_sec'] = request.urlExpireSec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetRevision',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/revision/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the information about a version.
 *
 * @param request GetRevisionRequest
 * @return GetRevisionResponse
 */
async function getRevision(request: GetRevisionRequest): GetRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRevisionWithOptions(request, headers, runtime);
}

model GetShareLinkRequest {
  shareId?: string(name='share_id', description='The share ID.

This parameter is required.', example='7JQX1FswpQ8'),
}

model GetShareLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ShareLink  
}

/**
 * @summary Queries the share URL of a file.
 *
 * @param request GetShareLinkRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetShareLinkResponse
 */
async function getShareLinkWithOptions(request: GetShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the share URL of a file.
 *
 * @param request GetShareLinkRequest
 * @return GetShareLinkResponse
 */
async function getShareLink(request: GetShareLinkRequest): GetShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getShareLinkWithOptions(request, headers, runtime);
}

model GetShareLinkByAnonymousRequest {
  shareId?: string(name='share_id', description='The share ID.

This parameter is required.', example='7JQX1FswpQ8'),
}

model GetShareLinkByAnonymousResponseBody = {
  accessCount?: long(name='access_count', description='The number of times that the shared files are visited.', example='30'),
  avatar?: string(name='avatar', description='The profile picture of the user who created the share link.', example='https://aliyunpds.com/a.jpg'),
  creatorId?: string(name='creator_id', description='The ID of the user who created the share link.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
  creatorName?: string(name='creator_name', description='The name of the user who created the share link. The value is masked.', example='AB***CD'),
  creatorPhone?: string(name='creator_phone', description='The mobile number of the user who created the share link. The value is masked.', example='136****00'),
  disableDownload?: boolean(name='disable_download', description='Indicates whether the downloads of the shared files are prohibited.', example='false'),
  disablePreview?: boolean(name='disable_preview', description='Indicates whether the previews of the shared files are prohibited.', example='false'),
  disableSave?: boolean(name='disable_save', description='Indicates whether the saves of the shared files are prohibited.', example='false'),
  downloadCount?: long(name='download_count', description='The number of times that the shared files are downloaded.', example='50'),
  downloadLimit?: long(name='download_limit', description='The maximum number of times that the shared files can be downloaded.', example='100'),
  expiration?: string(name='expiration', description='The time when the share link expires.', example='2020-08-20T06:51:27.292Z'),
  previewCount?: long(name='preview_count', description='The number of times that the shared files are previewed.', example='80'),
  previewLimit?: long(name='preview_limit', description='The maximum number of times that the shared files can be previewed.', example='100'),
  reportCount?: long(name='report_count', description='The number of times that the shared files are reported.', example='0'),
  saveCount?: long(name='save_count', description='The number of times that the shared files are saved.', example='2'),
  saveDownloadLimit?: long(name='save_download_limit', description='The maximum number of times that the shared files can be saved and downloaded.', example='200'),
  saveLimit?: long(name='save_limit', description='The maximum number of times that the shared files can be saved.', example='100'),
  shareName?: string(name='share_name', description='The name of the share link.'),
  updatedAt?: string(name='updated_at', description='The time when the share link was last modified.', example='2019-08-20T06:51:27.292Z'),
  videoPreviewCount?: long(name='video_preview_count', description='The number of times that the videos are previewed in the shared files.', example='5'),
}

model GetShareLinkByAnonymousResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetShareLinkByAnonymousResponseBody(name='body'),
}

/**
 * @summary Queries the information about a share link anonymously.
 *
 * @param request GetShareLinkByAnonymousRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetShareLinkByAnonymousResponse
 */
async function getShareLinkByAnonymousWithOptions(request: GetShareLinkByAnonymousRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetShareLinkByAnonymousResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetShareLinkByAnonymous',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/get_by_anonymous`,
    method = 'POST',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the information about a share link anonymously.
 *
 * @param request GetShareLinkByAnonymousRequest
 * @return GetShareLinkByAnonymousResponse
 */
async function getShareLinkByAnonymous(request: GetShareLinkByAnonymousRequest): GetShareLinkByAnonymousResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getShareLinkByAnonymousWithOptions(request, headers, runtime);
}

model GetShareLinkTokenRequest {
  expireSec?: int32(name='expire_sec', description='The validity period of the token. Valid values: (0,7200]. Default value: 7200. Unit: seconds.', example='7200'),
  shareId?: string(name='share_id', description='The share ID.

This parameter is required.', example='7JQX1FswpQ8'),
  sharePwd?: string(name='share_pwd', description='The access code.', example='abcF123x'),
}

model GetShareLinkTokenResponseBody = {
  expiresIn?: long(name='expires_in', description='The validity period of the token. Unit: seconds. For example, a value of 7200 indicates two hours.', example='7200'),
  shareToken?: string(name='share_token', description='The JSON Web Token (JWT).', example='eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJjOWI3YTVhYTA0ZDE0YWUzODY3ZmRjODg2ZmEwMWRhNCIsImN1c3RvbUpzb24iOiJ7XCJjbGllbnRJZFwiOlwiMjVkelgzdmJZcWt0Vnh5WFwiLFwiZG9tYWluSWRcIjpcImJqMjlcIixcInNjb3BlXCI6W1wiRFJJVkUuQUxMXCIsXCJTSEFSRS5BTExcIixcIkZJTEUuQUxMXCIsXCJVU0VSLkFMTFwiLFwiVklFVy5BTExcIixcIlNUT1JBR0UuQUxMXCIsXCJTVE9SQUdFRklMRS5MSVNUXCIsXCJCQVRDSFwiLFwiT0FVVEguQUxMXCIsXCJJTUFHRS5BTExcIixcIklOVklURS5BTExcIixcIkFDQ09VTlQuQUxMXCJdLFwicm9sZVwiOlwidXNlclwiLFwicmVmXCI6XCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vXCIsXCJkZXZpY2VfaWRcIjpcImIyODIwNWU1YzU5NzRjY2JiODI3MDNiNjhkYjhjNDUxXCJ9IiwiZXhwIjoxNjQ4NjE0NDkzLCJpYXQiOjE2NDg2MDcyMzN9.d3HVLvv_LFw2QhPrhvjH_kICWQJX9sKKt7NjQEqI_xE2JO_b7D8rPsFTZz93PLvZ7MhCmudTjGImUpd-ehFnI4Go-1S7BGaKaHFILvP-sWy18Wpikowjxx9mSbzBM_cO6D1LI-kyYhXKWHgVdADfVIPniTDA7-ffhUpi7cAebEs'),
}

model GetShareLinkTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetShareLinkTokenResponseBody(name='body'),
}

/**
 * @summary Queries a share token anonymously.
 *
 * @description To access a file by using a share link, you must first obtain a share token, even if the value of share_pwd of this share is an empty string, which specifies that the share is not private.
 *
 * @param request GetShareLinkTokenRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetShareLinkTokenResponse
 */
async function getShareLinkTokenWithOptions(request: GetShareLinkTokenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetShareLinkTokenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.expireSec)) {
    body['expire_sec'] = request.expireSec;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.sharePwd)) {
    body['share_pwd'] = request.sharePwd;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetShareLinkToken',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/get_share_token`,
    method = 'POST',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a share token anonymously.
 *
 * @description To access a file by using a share link, you must first obtain a share token, even if the value of share_pwd of this share is an empty string, which specifies that the share is not private.
 *
 * @param request GetShareLinkTokenRequest
 * @return GetShareLinkTokenResponse
 */
async function getShareLinkToken(request: GetShareLinkTokenRequest): GetShareLinkTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getShareLinkTokenWithOptions(request, headers, runtime);
}

model GetStoryRequest {
  coverImageThumbnailProcess?: string(name='cover_image_thumbnail_process', example='image/resize,m_fill,h_128,w_128,limit_0/format,jpg', deprecated=true),
  coverVideoThumbnailProcess?: string(name='cover_video_thumbnail_process', example='video/snapshot,t_1000,f_jpg,w_0,h_0,m_fast,ar_auto', deprecated=true),
  driveId?: string(name='drive_id', description='This parameter is required.', example='1'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', example='image/resize,m_fill,h_128,w_128,limit_0/format,jpg', deprecated=true),
  imageUrlProcess?: string(name='image_url_process', example='image/resize,m_fill,h_128,w_128,limit_0/format,jpg', deprecated=true),
  storyId?: string(name='story_id', description='This parameter is required.', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
  urlExpireSec?: long(name='url_expire_sec', example='900', deprecated=true),
  videoThumbnailProcess?: string(name='video_thumbnail_process', example='video/snapshot,t_1000,f_jpg,w_0,h_0,m_fast,ar_auto', deprecated=true),
}

model GetStoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Story  
}

/**
 * @summary 获取故事详情
 *
 * @param request GetStoryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetStoryResponse
 */
async function getStoryWithOptions(request: GetStoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetStoryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.coverImageThumbnailProcess)) {
    body['cover_image_thumbnail_process'] = request.coverImageThumbnailProcess;
  }
  if (!Util.isUnset(request.coverVideoThumbnailProcess)) {
    body['cover_video_thumbnail_process'] = request.coverVideoThumbnailProcess;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    body['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.imageUrlProcess)) {
    body['image_url_process'] = request.imageUrlProcess;
  }
  if (!Util.isUnset(request.storyId)) {
    body['story_id'] = request.storyId;
  }
  if (!Util.isUnset(request.urlExpireSec)) {
    body['url_expire_sec'] = request.urlExpireSec;
  }
  if (!Util.isUnset(request.videoThumbnailProcess)) {
    body['video_thumbnail_process'] = request.videoThumbnailProcess;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetStory',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/get_story`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 获取故事详情
 *
 * @param request GetStoryRequest
 * @return GetStoryResponse
 */
async function getStory(request: GetStoryRequest): GetStoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getStoryWithOptions(request, headers, runtime);
}

model GetTaskStatusRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  taskId?: string(name='task_id', description='The ID of the task.

This parameter is required.', example='i:SimilarImageClustering-b67d53e7-2fe8-460f-9b95-1e93636923eb'),
}

model GetTaskStatusResponseBody = {
  status?: string(name='status', description='The state of the task.

Valid values:

*   running

    <!-- -->

    : The task is

    <!-- -->

    running

    <!-- -->

    .

*   failed

    <!-- -->

    : The task

    <!-- -->

    fails

    <!-- -->

    .

*   succeeded

    <!-- -->

    : The task is

    <!-- -->

    successful

    <!-- -->

    .', example='running'),
}

model GetTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTaskStatusResponseBody(name='body'),
}

/**
 * @summary Queries the execution status of a value-added asynchronous task. You can call this operation to query the execution status of an asynchronous task that is created by calling the CreateSimilarImageClusterTask operation.
 *
 * @description **Before you call this operation, make sure that you are familiar with the [billing](https://help.aliyun.com/document_detail/425220.html) of Drive and Photo Service**.
 * To call this operation, make sure that the value-added image processing feature is enabled.
 * Before you call this operation, a value-added asynchronous task must be created. For example, you can call the CreateSimilarImageClusterTask operation to create an asynchronous task. Then, you can call this operation to query the execution status of the asynchronous task based on the task ID.
 *
 * @param request GetTaskStatusRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTaskStatusResponse
 */
async function getTaskStatusWithOptions(request: GetTaskStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTaskStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['task_id'] = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskStatus',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/get_task_status`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the execution status of a value-added asynchronous task. You can call this operation to query the execution status of an asynchronous task that is created by calling the CreateSimilarImageClusterTask operation.
 *
 * @description **Before you call this operation, make sure that you are familiar with the [billing](https://help.aliyun.com/document_detail/425220.html) of Drive and Photo Service**.
 * To call this operation, make sure that the value-added image processing feature is enabled.
 * Before you call this operation, a value-added asynchronous task must be created. For example, you can call the CreateSimilarImageClusterTask operation to create an asynchronous task. Then, you can call this operation to query the execution status of the asynchronous task based on the task ID.
 *
 * @param request GetTaskStatusRequest
 * @return GetTaskStatusResponse
 */
async function getTaskStatus(request: GetTaskStatusRequest): GetTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTaskStatusWithOptions(request, headers, runtime);
}

model GetUploadUrlRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='5d5b846942cf94fa72324c14a4bda34e81da635d'),
  partInfoList?: [ 
    {
      contentMd5?: string(name='content_md5'),
      contentType?: string(name='content_type'),
      parallelSha1Ctx?: {
        h?: [ long ](name='h', description='The first to fifth 32-bit variables of the SHA-1 hash value of the file content before the file part. This parameter takes effect only if the parallel upload feature is enabled.'),
        partOffset?: long(name='part_offset', description='The size of the file part. Unit: bytes. The value must be a multiple of 64. This parameter takes effect only if the parallel upload feature is enabled.', example='10240'),
      }(name='parallel_sha1_ctx', description='The SHA-1 hash value of the file content before the file part. This parameter takes effect only if the parallel upload feature is enabled.'),
      parallelSha256Ctx?: {
        h?: [ long ](name='h'),
        partOffset?: long(name='part_offset'),
      }(name='parallel_sha256_ctx'),
      partNumber?: int32(name='part_number', description='The serial number of a part.', example='1'),
    }
  ](name='part_info_list', description='The information about the file parts.

This parameter is required.'),
  shareId?: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8'),
  uploadId?: string(name='upload_id', description='The ID of the upload task.

This parameter is required.', example='10166D06127B413BA1EC8ABB1144D111'),
}

model GetUploadUrlResponseBody = {
  createAt?: string(name='create_at', description='The time when the upload task was created.', example='2019-09-11T16:34:36.977Z'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='5d5b846942cf94fa72324c14a4bda34e81da635d'),
  partInfoList?: [
    UploadPartInfo
  ](name='part_info_list', description='The information about the file parts.'),
  uploadId?: string(name='upload_id', description='The ID of the upload task.', example='10166D06127B413BA1EC8ABB1144D111'),
}

model GetUploadUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUploadUrlResponseBody(name='body'),
}

/**
 * @summary Queries the upload URL of a file.
 *
 * @param request GetUploadUrlRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetUploadUrlResponse
 */
async function getUploadUrlWithOptions(request: GetUploadUrlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUploadUrlResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.partInfoList)) {
    body['part_info_list'] = request.partInfoList;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.uploadId)) {
    body['upload_id'] = request.uploadId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetUploadUrl',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get_upload_url`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the upload URL of a file.
 *
 * @param request GetUploadUrlRequest
 * @return GetUploadUrlResponse
 */
async function getUploadUrl(request: GetUploadUrlRequest): GetUploadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUploadUrlWithOptions(request, headers, runtime);
}

model GetUserRequest {
  userId?: string(name='user_id', description='The user ID. If you use an AccessKey pair to access Drive and Photo Service, you must specify this parameter. If you use an access token to access Drive and Photo Service, you do not need to specify this parameter, and Drive and Photo Service automatically finds the user ID contained in the access token.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
}

model GetUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: User  
}

/**
 * @summary Queries the information about a user.
 *
 * @param request GetUserRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetUserResponse
 */
async function getUserWithOptions(request: GetUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the information about a user.
 *
 * @param request GetUserRequest
 * @return GetUserResponse
 */
async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUserWithOptions(request, headers, runtime);
}

model GetVideoPreviewPlayInfoRequest {
  category?: string(name='category', description='The preview type. You must enable the corresponding video transcoding feature. Valid values:

*   live_transcoding: previews a live stream while transcoding is in progress.
*   quick_video: previews a video while transcoding is in progress.
*   offline_audio: previews a piece of audio after the audio is transcoded offline.
*   offline_video: previews a video after the video is transcoded offline.

This parameter is required.', example='live_transcoding'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
  getMasterUrl?: boolean(name='get_master_url'),
  getWithoutUrl?: boolean(name='get_without_url', description='Specifies whether not to query the playback URL. If you set this parameter to true, only transcoding metadata is returned. The video is not transcoded in the TS format, and the playback URL is not returned. If you set this parameter to false, the playback URL is returned. If the video has not been transcoded by using the template specified by template_id, the transcoding process is triggered. You are charged for the value-added service fees generated for transcoding.', example='true'),
  reTranscode?: boolean(name='re_transcode'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a sharing link, carry the `x-share-token` header in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify at least either `share_id` or `drive_id`.', example='7JQX1FswpQ8'),
  templateId?: string(name='template_id', description='The ID of the definition template. If you leave this parameter empty, all definition templates are available.', example='264_480p'),
  urlExpireSec?: long(name='url_expire_sec', description='The validity period of the video preview. Unit: seconds. Default value: 900. Maximum value: 14400.', example='3600'),
}

model GetVideoPreviewPlayInfoResponseBody = {
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='fileid1'),
  shareId?: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8'),
  videoPreviewPlayInfo?: VideoPreviewPlayInfo(name='video_preview_play_info', description='The information about video playback.'),
}

model GetVideoPreviewPlayInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetVideoPreviewPlayInfoResponseBody(name='body'),
}

/**
 * @summary Queries the information about video playback.
 *
 * @description For more information about best practices, see [Preview videos online](https://help.aliyun.com/document_detail/427477.html).
 *
 * @param request GetVideoPreviewPlayInfoRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVideoPreviewPlayInfoResponse
 */
async function getVideoPreviewPlayInfoWithOptions(request: GetVideoPreviewPlayInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetVideoPreviewPlayInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.category)) {
    body['category'] = request.category;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.getMasterUrl)) {
    body['get_master_url'] = request.getMasterUrl;
  }
  if (!Util.isUnset(request.getWithoutUrl)) {
    body['get_without_url'] = request.getWithoutUrl;
  }
  if (!Util.isUnset(request.reTranscode)) {
    body['re_transcode'] = request.reTranscode;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.templateId)) {
    body['template_id'] = request.templateId;
  }
  if (!Util.isUnset(request.urlExpireSec)) {
    body['url_expire_sec'] = request.urlExpireSec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetVideoPreviewPlayInfo',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get_video_preview_play_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the information about video playback.
 *
 * @description For more information about best practices, see [Preview videos online](https://help.aliyun.com/document_detail/427477.html).
 *
 * @param request GetVideoPreviewPlayInfoRequest
 * @return GetVideoPreviewPlayInfoResponse
 */
async function getVideoPreviewPlayInfo(request: GetVideoPreviewPlayInfoRequest): GetVideoPreviewPlayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getVideoPreviewPlayInfoWithOptions(request, headers, runtime);
}

model GetVideoPreviewPlayMetaRequest {
  category?: string(name='category', description='The preview type. You must enable the corresponding video transcoding feature. Valid values:

*   live_transcoding: previews a live stream while transcoding is in progress.
*   quick_video: previews a video while transcoding is in progress.
*   offline_audio: previews a piece of audio after the audio is transcoded offline.
*   offline_video: previews a video after the video is transcoded offline.

This parameter is required.', example='live_transcoding'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a sharing link, carry the `x-share-token` header in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify at least either `share_id` or `drive_id`.', example='7JQX1FswpQ8'),
}

model GetVideoPreviewPlayMetaResponseBody = {
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='fileid1'),
  shareId?: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8'),
  videoPreviewPlayMeta?: VideoPreviewPlayMeta(name='video_preview_play_meta', description='The preview metadata of the video.'),
}

model GetVideoPreviewPlayMetaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetVideoPreviewPlayMetaResponseBody(name='body'),
}

/**
 * @summary Queries the preview metadata of a video.
 *
 * @description For more information about best practices, see [Preview videos online](https://help.aliyun.com/document_detail/427477.html).
 *
 * @param request GetVideoPreviewPlayMetaRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVideoPreviewPlayMetaResponse
 */
async function getVideoPreviewPlayMetaWithOptions(request: GetVideoPreviewPlayMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetVideoPreviewPlayMetaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.category)) {
    body['category'] = request.category;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetVideoPreviewPlayMeta',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get_video_preview_play_meta`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the preview metadata of a video.
 *
 * @description For more information about best practices, see [Preview videos online](https://help.aliyun.com/document_detail/427477.html).
 *
 * @param request GetVideoPreviewPlayMetaRequest
 * @return GetVideoPreviewPlayMetaResponse
 */
async function getVideoPreviewPlayMeta(request: GetVideoPreviewPlayMetaRequest): GetVideoPreviewPlayMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getVideoPreviewPlayMetaWithOptions(request, headers, runtime);
}

model GroupUpdateNameRequest {
  groupId?: string(name='group_id', description='This parameter is required.'),
  name?: string(name='name'),
}

model GroupUpdateNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 更新用户组名字
 *
 * @param request GroupUpdateNameRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GroupUpdateNameResponse
 */
async function groupUpdateNameWithOptions(request: GroupUpdateNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GroupUpdateNameResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GroupUpdateName',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/update_name`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 更新用户组名字
 *
 * @param request GroupUpdateNameRequest
 * @return GroupUpdateNameResponse
 */
async function groupUpdateName(request: GroupUpdateNameRequest): GroupUpdateNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return groupUpdateNameWithOptions(request, headers, runtime);
}

model ImportUserRequest {
  authenticationDisplayName?: string(name='authentication_display_name', description='The display name of the authentication type.', example='10000'),
  authenticationType?: string(name='authentication_type', description='The authentication type. Valid values:

*   mobile: mobile number.
*   email: email address.
*   ding: DingTalk account.
*   ram: Alibaba Cloud Resource Access Management (RAM) user.
*   wechat: WeCom account.
*   ldap: Lightweight Directory Access Protocol (LDAP) account.
*   custom: custom account.

This parameter is required.', example='mobile'),
  autoCreateDrive?: boolean(name='auto_create_drive', description='Specifies whether to automatically create a drive.', example='false'),
  driveTotalSize?: long(name='drive_total_size', description='The size of the drive. The value cannot be smaller than -1. A value of -1 specifies that the size is unlimited.', example='10240'),
  extra?: string(name='extra', description='The additional information.

If authentication_type is set to mobile, set this parameter to a country code. If you do not specify this parameter, 86 is used by default.', example='1'),
  identity?: string(name='identity', description='The unique identifier.

This parameter is required.', example='130****'),
  nickName?: string(name='nick_name', description='The nickname of the user.

This parameter is required.', example='pdsuer'),
  parentGroupId?: string(name='parent_group_id', description='The ID of the group to which the user is added.', example='g12'),
}

model ImportUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: User  
}

/**
 * @summary Imports a user.
 *
 * @param request ImportUserRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportUserResponse
 */
async function importUserWithOptions(request: ImportUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ImportUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.authenticationDisplayName)) {
    body['authentication_display_name'] = request.authenticationDisplayName;
  }
  if (!Util.isUnset(request.authenticationType)) {
    body['authentication_type'] = request.authenticationType;
  }
  if (!Util.isUnset(request.autoCreateDrive)) {
    body['auto_create_drive'] = request.autoCreateDrive;
  }
  if (!Util.isUnset(request.driveTotalSize)) {
    body['drive_total_size'] = request.driveTotalSize;
  }
  if (!Util.isUnset(request.extra)) {
    body['extra'] = request.extra;
  }
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }
  if (!Util.isUnset(request.nickName)) {
    body['nick_name'] = request.nickName;
  }
  if (!Util.isUnset(request.parentGroupId)) {
    body['parent_group_id'] = request.parentGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ImportUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/import`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Imports a user.
 *
 * @param request ImportUserRequest
 * @return ImportUserResponse
 */
async function importUser(request: ImportUserRequest): ImportUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return importUserWithOptions(request, headers, runtime);
}

model InvestigateFileRequest {
  driveFileIds?: [ 
    {
      driveId?: string(name='drive_id', description='This parameter is required.', example='1'),
      fileId?: string(name='file_id', description='This parameter is required.', example='9520943DC264'),
    }
  ](name='drive_file_ids', description='This parameter is required.'),
}

model InvestigateFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 送审文件
 *
 * @param request InvestigateFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return InvestigateFileResponse
 */
async function investigateFileWithOptions(request: InvestigateFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InvestigateFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveFileIds)) {
    body['drive_file_ids'] = request.driveFileIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InvestigateFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/csi/investigate_file`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 送审文件
 *
 * @param request InvestigateFileRequest
 * @return InvestigateFileResponse
 */
async function investigateFile(request: InvestigateFileRequest): InvestigateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return investigateFileWithOptions(request, headers, runtime);
}

model LinkAccountRequest {
  extra?: string(name='extra', description='The additional information about the unique identifier of the account. For example, if type is set to mobile, set the value of extra to a country code. For example, a value of 86 specifies a mobile number in the Chinese mainland. If you do not specify this parameter, 86 is used by default.', example='86'),
  identity?: string(name='identity', description='The unique identifier of the account, such as a mobile number.

This parameter is required.', example='eyy***'),
  type?: string(name='type', description='The account type. Valid values:

*   mobile: a mobile number.
*   email: an email address.
*   ding: a DingTalk account.
*   ram: an Alibaba Cloud Resource Access Management (RAM) user.
*   wechat: a WeCom account.
*   ldap: a Lightweight Directory Access Protocol (LDAP) account.
*   custom: a custom account.

This parameter is required.', example='ding'),
  userId?: string(name='user_id', description='The ID of the user with which you want to associate an account.

This parameter is required.', example='xxx'),
}

model LinkAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Token  
}

/**
 * @summary Associates an account with a user.
 *
 * @param request LinkAccountRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return LinkAccountResponse
 */
async function linkAccountWithOptions(request: LinkAccountRequest, headers: map[string]string, runtime: Util.RuntimeOptions): LinkAccountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extra)) {
    body['extra'] = request.extra;
  }
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'LinkAccount',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/account/link`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Associates an account with a user.
 *
 * @param request LinkAccountRequest
 * @return LinkAccountResponse
 */
async function linkAccount(request: LinkAccountRequest): LinkAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return linkAccountWithOptions(request, headers, runtime);
}

model ListAddressGroupsRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', description='The method that is used to generate a thumbnail of an image.', example='image/resize,w_200'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  videoThumbnailProcess?: string(name='video_thumbnail_process', description='The method that is used to generate a thumbnail of a video.', example='video_thumbnail_process'),
}

model ListAddressGroupsResponseBody = {
  items?: [
    AddressGroup
  ](name='items', description='The information about the location-based groups.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListAddressGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAddressGroupsResponseBody(name='body'),
}

/**
 * @summary Queries location-based groups.
 *
 * @param request ListAddressGroupsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAddressGroupsResponse
 */
async function listAddressGroupsWithOptions(request: ListAddressGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAddressGroupsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    body['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.videoThumbnailProcess)) {
    body['video_thumbnail_process'] = request.videoThumbnailProcess;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAddressGroups',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/list_address_groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries location-based groups.
 *
 * @param request ListAddressGroupsRequest
 * @return ListAddressGroupsResponse
 */
async function listAddressGroups(request: ListAddressGroupsRequest): ListAddressGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAddressGroupsWithOptions(request, headers, runtime);
}

model ListAssignmentRequest {
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  manageResourceId?: string(name='manage_resource_id', description='The ID of the managed resource, such as a group ID.', example='105***b82'),
  manageResourceType?: string(name='manage_resource_type', description='The type of the managed resource. Set the value to RT_Group, which specifies that the administrators of a group are queried.', example='RT_Group'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListAssignmentResponseBody = {
  assignmentList?: [ 
    {
      createdAt?: long(name='created_at', description='The time when the role was assigned. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1622682267564'),
      creator?: string(name='creator', description='The ID of the user who assigned the role.', example='216***c83'),
      domainId?: string(name='domain_id', description='The domain ID.', example='hz1'),
      identity?: Identity(name='identity', description='The identity to whom the role is assigned, which is a user or a group.'),
      manageResourceId?: string(name='manage_resource_id', description='The ID of the managed resource, such as a group ID.', example='105***b82'),
      manageResourceType?: string(name='manage_resource_type', description='The type of the managed resource. For example, a value of RT_Group indicates group.', example='RT_Group'),
      roleId?: string(name='role_id', description='The ID of the role assigned to the identity.', example='SystemGroupAdmin'),
    }
  ](name='assignment_list', description='The assigned roles.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListAssignmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAssignmentResponseBody(name='body'),
}

/**
 * @summary Queries a list of assigned roles. For example, you can query the administrators of a group by group ID.
 *
 * @param request ListAssignmentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAssignmentResponse
 */
async function listAssignmentWithOptions(request: ListAssignmentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAssignmentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.manageResourceId)) {
    body['manage_resource_id'] = request.manageResourceId;
  }
  if (!Util.isUnset(request.manageResourceType)) {
    body['manage_resource_type'] = request.manageResourceType;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAssignment',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/role/list_assignment`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of assigned roles. For example, you can query the administrators of a group by group ID.
 *
 * @param request ListAssignmentRequest
 * @return ListAssignmentResponse
 */
async function listAssignment(request: ListAssignmentRequest): ListAssignmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAssignmentWithOptions(request, headers, runtime);
}

model ListDeltaRequest {
  cursor?: string(name='cursor', description='The cursor of the incremental information.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 0 to 100. Default value: 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  syncRootId?: string(name='sync_root_id', description='The ID of the root file of the synced folder.', example='622fb09598ae66777c7040109a16f49381f6abe1'),
}

model ListDeltaResponseBody = {
  cursor?: string(name='cursor', description='The cursor of the incremental information.', example='1WQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  hasMore?: boolean(name='has_more', description='Indicates whether more information is returned.', example='true'),
  items?: [ 
    {
      file?: File(name='file', description='The information about the file.'),
      fileId?: string(name='file_id', description='The file ID.', example='122fb09598ae66777c7040109a16f49381f6abe2'),
      op?: string(name='op', description='The operation that is performed. Valid values: Valid values:

*   create
*   overwrite
*   delete
*   update
*   move
*   trash
*   restore
*   rename', example='create'),
    }
  ](name='items', description='The incremental information returned.'),
}

model ListDeltaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDeltaResponseBody(name='body'),
}

/**
 * @summary Queries incremental information.
 *
 * @param request ListDeltaRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDeltaResponse
 */
async function listDeltaWithOptions(request: ListDeltaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeltaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cursor)) {
    body['cursor'] = request.cursor;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.syncRootId)) {
    body['sync_root_id'] = request.syncRootId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDelta',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/list_delta`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries incremental information.
 *
 * @param request ListDeltaRequest
 * @return ListDeltaResponse
 */
async function listDelta(request: ListDeltaRequest): ListDeltaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeltaWithOptions(request, headers, runtime);
}

model ListDomainsRequest {
  limit?: long(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 50.', example='60'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  parentDomainId?: string(name='parent_domain_id', description='The ID of the parent domain.', example='bj1'),
  serviceCode?: string(name='service_code'),
}

model ListDomainsResponseBody = {
  items?: [
    Domain
  ](name='items', description='The information about the domains.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDomainsResponseBody(name='body'),
}

/**
 * @summary 列举 domain
 *
 * @param request ListDomainsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDomainsResponse
 */
async function listDomainsWithOptions(request: ListDomainsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDomainsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.parentDomainId)) {
    body['parent_domain_id'] = request.parentDomainId;
  }
  if (!Util.isUnset(request.serviceCode)) {
    body['service_code'] = request.serviceCode;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDomains',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 列举 domain
 *
 * @param request ListDomainsRequest
 * @return ListDomainsResponse
 */
async function listDomains(request: ListDomainsRequest): ListDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDomainsWithOptions(request, headers, runtime);
}

model ListDriveRequest {
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  owner?: string(name='owner', description='The owner of the drive. If this parameter is not specified, all drives are returned.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
  ownerType?: string(name='owner_type', description='The type of the owner. Valid values:

user and group.

By default, drives of all owner types are returned.', example='user'),
}

model ListDriveResponseBody = {
  items?: [
    Drive
  ](name='items', description='The queried drives.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDriveResponseBody(name='body'),
}

/**
 * @summary Queries a list of drives.
 *
 * @param request ListDriveRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDriveResponse
 */
async function listDriveWithOptions(request: ListDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.owner)) {
    body['owner'] = request.owner;
  }
  if (!Util.isUnset(request.ownerType)) {
    body['owner_type'] = request.ownerType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of drives.
 *
 * @param request ListDriveRequest
 * @return ListDriveResponse
 */
async function listDrive(request: ListDriveRequest): ListDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDriveWithOptions(request, headers, runtime);
}

model ListFacegroupsRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  remarks?: string(name='remarks', description='The filter condition that is used to query groups. The value can be up to 128 characters in length. An exact match is used.'),
  returnTotalCount?: boolean(name='return_total_count'),
}

model ListFacegroupsResponseBody = {
  items?: [
    FaceGroup
  ](name='items', description='The information about the face-based groups.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  totalCount?: long(name='total_count'),
}

model ListFacegroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFacegroupsResponseBody(name='body'),
}

/**
 * @summary Queries face-based groups.
 *
 * @param request ListFacegroupsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFacegroupsResponse
 */
async function listFacegroupsWithOptions(request: ListFacegroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFacegroupsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.remarks)) {
    body['remarks'] = request.remarks;
  }
  if (!Util.isUnset(request.returnTotalCount)) {
    body['return_total_count'] = request.returnTotalCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFacegroups',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/list_facegroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries face-based groups.
 *
 * @param request ListFacegroupsRequest
 * @return ListFacegroupsResponse
 */
async function listFacegroups(request: ListFacegroupsRequest): ListFacegroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFacegroupsWithOptions(request, headers, runtime);
}

model ListFileRequest {
  category?: string(name='category', description='The category of the file. Valid values:

app: installation package. zip: compressed package. image: image. doc: document. video: video. audio: audio. others: other files.

By default, files of all categories are returned.', example='image'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fields?: string(name='fields', description='The fields to return.

1.  If this parameter is set to \\\\*, all fields of the file except the fields that must be specified are returned.
2.  If only specific fields are required, you can specify the following fields: url, exif, cropping_suggestion, characteristic_hash, video_metadata, and video_preview_metadata. If multiple fields are required, separate them with commas (,). Example: url,exif.
3.  The investigation_info field is returned only if you specify this field.

By default, all fields except the fields that must be specified are returned.', example='*'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\\\
By default, this parameter is empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  orderBy?: string(name='order_by', description='The sorting field.

Default value: created_at.

Valid values:

*   updated_at

    <!-- -->

    :

    <!-- -->

    sorts the results based on the time when the file was last modified

    <!-- -->

    .

*   size

    <!-- -->

    :

    <!-- -->

    sorts the results based on the size of the file

    <!-- -->

    .

*   name

    <!-- -->

    :

    <!-- -->

    sorts the results based on the name of the file

    <!-- -->

    .

*   created_at

    <!-- -->

    :

    <!-- -->

    sorts the results based on the time when the file was created

    <!-- -->

    .', example='updated_at'),
  orderDirection?: string(name='order_direction', description='The sorting direction. Valid values:

ASC: ascending order. DESC: descending order.

Default value: ASC.', example='ASC'),
  parentFileId?: string(name='parent_file_id', description='The ID of the parent folder. If the parent folder is a root directory, set this parameter to root.

This parameter is required.', example='root'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a share link, carry the `x-share-token` header for authentication in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify one of `share_id` and `drive_id`.', example='7JQX1FswpQ8'),
  status?: string(name='status', description='The state of the file. Valid values:

available: Only normal files are returned. uploading: Only files that are being uploaded are returned.

By default, only files in the available state are returned.', example='available'),
  thumbnailProcesses?: map[string]ImageProcess(name='thumbnail_processes', description='The thumbnail configurations. Up to five thumbnails can be returned at a time. The value contains key-value pairs. You can customize the keys. The URL of a thumbnail is returned based on the key.'),
  type?: string(name='type', description='The type of the file. Valid values:

file: Only files are returned. folder: Only folders are returned.

By default, files of all types are returned.', example='file'),
}

model ListFileResponseBody = {
  items?: [
    File
  ](name='items', description='The queried files.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFileResponseBody(name='body'),
}

/**
 * @summary Queries a list of files and folders.
 *
 * @param request ListFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListFileResponse
 */
async function listFileWithOptions(request: ListFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.category)) {
    body['category'] = request.category;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.orderBy)) {
    body['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    body['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.parentFileId)) {
    body['parent_file_id'] = request.parentFileId;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.thumbnailProcesses)) {
    body['thumbnail_processes'] = request.thumbnailProcesses;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of files and folders.
 *
 * @param request ListFileRequest
 * @return ListFileResponse
 */
async function listFile(request: ListFileRequest): ListFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFileWithOptions(request, headers, runtime);
}

model ListGroupRequest {
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListGroupResponseBody = {
  items?: [
    Group
  ](name='items', description='The information about the groups.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListGroupResponseBody(name='body'),
}

/**
 * @summary Queries groups.
 *
 * @param request ListGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGroupResponse
 */
async function listGroupWithOptions(request: ListGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListGroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries groups.
 *
 * @param request ListGroupRequest
 * @return ListGroupResponse
 */
async function listGroup(request: ListGroupRequest): ListGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupWithOptions(request, headers, runtime);
}

model ListGroupMemberRequest {
  groupId?: string(name='group_id', description='The ID of the group of which you want to query members.

This parameter is required.', example='3e5***2c2'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  memberType?: string(name='member_type', description='The member type. If you do not specify this parameter, both types of members are returned. Valid values:

*   user
*   group

Note: A group can be a member of only one group. It cannot be a member of multiple groups. A user can be a member of multiple groups.', example='user'),
}

model ListGroupMemberResponseBody = {
  groupItems?: [
    Group
  ](name='group_items', description='The information about the groups.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhM1'),
  userItems?: [
    User
  ](name='user_items', description='The information about the users.'),
}

model ListGroupMemberResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListGroupMemberResponseBody(name='body'),
}

/**
 * @summary Queries the members of a group.
 *
 * @param request ListGroupMemberRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGroupMemberResponse
 */
async function listGroupMemberWithOptions(request: ListGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupMemberResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.memberType)) {
    body['member_type'] = request.memberType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListGroupMember',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/list_member`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the members of a group.
 *
 * @param request ListGroupMemberRequest
 * @return ListGroupMemberResponse
 */
async function listGroupMember(request: ListGroupMemberRequest): ListGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupMemberWithOptions(request, headers, runtime);
}

model ListIdentityRoleRequest {
  identity?: Identity(name='identity', description='This parameter is required.'),
}

model ListIdentityRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BaseRoleMemberResponse  
}

/**
 * @summary 列举用户或团队已分配的角色列表
 *
 * @param request ListIdentityRoleRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListIdentityRoleResponse
 */
async function listIdentityRoleWithOptions(request: ListIdentityRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIdentityRoleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListIdentityRole',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/role/list_identity_role`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 列举用户或团队已分配的角色列表
 *
 * @param request ListIdentityRoleRequest
 * @return ListIdentityRoleResponse
 */
async function listIdentityRole(request: ListIdentityRoleRequest): ListIdentityRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIdentityRoleWithOptions(request, headers, runtime);
}

model ListIdentityToBenefitPkgMappingRequest {
  identityId?: string(name='identity_id', description='The unique identifier of the entity.

If you call this operation to manage the benefits of a user, set this parameter to the ID of the user.

This parameter is required.', example='user123'),
  identityType?: string(name='identity_type', description='The type of the entity. If you call this operation to manage the benefits of a user, set this parameter to user.

This parameter is required.', example='user'),
  includeExpired?: boolean(name='include_expired', description='Specifies whether to return the benefit packages that expire. Default value: false.', example='false'),
}

model ListIdentityToBenefitPkgMappingResponseBody = {
  items?: [
    IdentityToBenefitPkgMapping
  ](name='items', description='The information about the benefit packages that are associated with an entity.'),
}

model ListIdentityToBenefitPkgMappingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListIdentityToBenefitPkgMappingResponseBody(name='body'),
}

/**
 * @summary Queries the mappings between entities and benefit packages. You can call this operation to query the benefit packages that are associated with a user.
 *
 * @param request ListIdentityToBenefitPkgMappingRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListIdentityToBenefitPkgMappingResponse
 */
async function listIdentityToBenefitPkgMappingWithOptions(request: ListIdentityToBenefitPkgMappingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIdentityToBenefitPkgMappingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.identityId)) {
    body['identity_id'] = request.identityId;
  }
  if (!Util.isUnset(request.identityType)) {
    body['identity_type'] = request.identityType;
  }
  if (!Util.isUnset(request.includeExpired)) {
    body['include_expired'] = request.includeExpired;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListIdentityToBenefitPkgMapping',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/benefit/identity_to_benefit_pkg_mapping/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the mappings between entities and benefit packages. You can call this operation to query the benefit packages that are associated with a user.
 *
 * @param request ListIdentityToBenefitPkgMappingRequest
 * @return ListIdentityToBenefitPkgMappingResponse
 */
async function listIdentityToBenefitPkgMapping(request: ListIdentityToBenefitPkgMappingRequest): ListIdentityToBenefitPkgMappingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIdentityToBenefitPkgMappingWithOptions(request, headers, runtime);
}

model ListMyDrivesRequest {
  limit?: int32(name='limit', description='The maximum number of results to return. Default value: 100. Valid values: 1 to 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListMyDrivesResponseBody = {
  items?: [
    Drive
  ](name='items', description='The queried drives.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListMyDrivesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMyDrivesResponseBody(name='body'),
}

/**
 * @summary Queries the drives of the current user.
 *
 * @param request ListMyDrivesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMyDrivesResponse
 */
async function listMyDrivesWithOptions(request: ListMyDrivesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMyDrivesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMyDrives',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/list_my_drives`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the drives of the current user.
 *
 * @param request ListMyDrivesRequest
 * @return ListMyDrivesResponse
 */
async function listMyDrives(request: ListMyDrivesRequest): ListMyDrivesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMyDrivesWithOptions(request, headers, runtime);
}

model ListMyGroupDriveRequest {
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListMyGroupDriveResponseBody = {
  items?: [
    Drive
  ](name='items', description='The information about the team drives.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  rootGroupDrive?: Drive(name='root_group_drive'),
}

model ListMyGroupDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMyGroupDriveResponseBody(name='body'),
}

/**
 * @summary Queries the team drives that can be accessed by the authorized users.
 *
 * @param request ListMyGroupDriveRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMyGroupDriveResponse
 */
async function listMyGroupDriveWithOptions(request: ListMyGroupDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMyGroupDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMyGroupDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/list_my_group_drive`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the team drives that can be accessed by the authorized users.
 *
 * @param request ListMyGroupDriveRequest
 * @return ListMyGroupDriveResponse
 */
async function listMyGroupDrive(request: ListMyGroupDriveRequest): ListMyGroupDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMyGroupDriveWithOptions(request, headers, runtime);
}

model ListReceivedFileRequest {
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is empty.', example='eym***'),
}

model ListReceivedFileResponseBody = {
  items?: [
    File
  ](name='items', description='The queried files.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='eym***'),
}

model ListReceivedFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListReceivedFileResponseBody(name='body'),
}

/**
 * @summary Queries a list of files that are shared with a user. You can call this operation to query a list of files in a personal drive on which a user is granted permissions.
 *
 * @param request ListReceivedFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListReceivedFileResponse
 */
async function listReceivedFileWithOptions(request: ListReceivedFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListReceivedFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListReceivedFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/list_received_file`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries a list of files that are shared with a user. You can call this operation to query a list of files in a personal drive on which a user is granted permissions.
 *
 * @param request ListReceivedFileRequest
 * @return ListReceivedFileResponse
 */
async function listReceivedFile(request: ListReceivedFileRequest): ListReceivedFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listReceivedFileWithOptions(request, headers, runtime);
}

model ListRecyclebinRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fields?: string(name='fields', description='Specifies the returned fields.

1\\\\. If you set this parameter to \\\\*, all fields of the file are returned.

2\\\\. If you set this parameter to a null value or leave this parameter empty, the fields, such as file creator, file modifier, and custom tags, are not returned.

The default value is a null value, which indicates that only some fields are returned.', example='*'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 200. Default value: 50.

The number of returned results must be less than or equal to the specified number.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListRecyclebinResponseBody = {
  items?: [
    File
  ](name='items', description='The information about the files and folders in the recycle bin.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhM1'),
}

model ListRecyclebinResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRecyclebinResponseBody(name='body'),
}

/**
 * @summary Queries the information about files and folders in the recycle bin.
 *
 * @param request ListRecyclebinRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRecyclebinResponse
 */
async function listRecyclebinWithOptions(request: ListRecyclebinRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRecyclebinResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListRecyclebin',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/recyclebin/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the information about files and folders in the recycle bin.
 *
 * @param request ListRecyclebinRequest
 * @return ListRecyclebinResponse
 */
async function listRecyclebin(request: ListRecyclebinRequest): ListRecyclebinResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRecyclebinWithOptions(request, headers, runtime);
}

model ListRevisionRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fields?: string(name='fields', description='Specifies the returned fields.

By default, this parameter is left empty. If you set this parameter to \\\\*, all fields are returned. If you leave this parameter empty, the creator of the file is not returned.', example='*'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
  limit?: long(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.

Default value: 50.

The number of returned results must be less than or equal to the specified number.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.

By default, this parameter is left empty.', example='40CB7794C929'),
}

model ListRevisionResponseBody = {
  items?: [
    Revision
  ](name='items', description='The information about the versions.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListRevisionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRevisionResponseBody(name='body'),
}

/**
 * @summary Queries the versions of a file.
 *
 * @param request ListRevisionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRevisionResponse
 */
async function listRevisionWithOptions(request: ListRevisionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRevisionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListRevision',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/revision/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the versions of a file.
 *
 * @param request ListRevisionRequest
 * @return ListRevisionResponse
 */
async function listRevision(request: ListRevisionRequest): ListRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRevisionWithOptions(request, headers, runtime);
}

model ListShareLinkRequest {
  creator?: string(name='creator', description='The creator of the share.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
  includeCancelled?: boolean(name='include_cancelled', description='Specifies whether to return the shares that are canceled.', example='true'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 0 to 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  orderBy?: string(name='order_by', description='The field by which to sort the returned results. Default value: created_at. Valid values:

*   share_name: sorts the results by the name of the share.
*   updated_at: sorts the results by the time when the share was modified.
*   description: sorts the results by the description of the share.
*   created_at: sorts the results by the time when the share was created.', example='share_name'),
  orderDirection?: string(name='order_direction', description='The order in which you want to sort the returned results. By default, order_direction is set to DESC if order_by is set to created_at or updated_at, and is set to ASC if order_by is set to other values. Valid values:

*   ASC: sorts the results in ascending order.
*   DESC: sorts the results in descending order.', example='ASC'),
}

model ListShareLinkResponseBody = {
  items?: [
    ShareLink
  ](name='items', description='The information about the shares.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListShareLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListShareLinkResponseBody(name='body'),
}

/**
 * @summary Queries shares.
 *
 * @description This operation is discontinued. To query shares, you can call the SearchShareLink operation.
 *
 * @param request ListShareLinkRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListShareLinkResponse
 */
async function listShareLinkWithOptions(request: ListShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.creator)) {
    body['creator'] = request.creator;
  }
  if (!Util.isUnset(request.includeCancelled)) {
    body['include_cancelled'] = request.includeCancelled;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.orderBy)) {
    body['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    body['order_direction'] = request.orderDirection;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries shares.
 *
 * @description This operation is discontinued. To query shares, you can call the SearchShareLink operation.
 *
 * @param request ListShareLinkRequest
 * @return ListShareLinkResponse
 */
async function listShareLink(request: ListShareLinkRequest): ListShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listShareLinkWithOptions(request, headers, runtime);
}

model ListTagsRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', description='The method that is used to generate the thumbnail of an image.', example='image/resize,w_200'),
  videoThumbnailProcess?: string(name='video_thumbnail_process', description='The method that is used to generate the thumbnail of a video.', example='video/snapshot,t_7000,f_jpg,w_800,h_600,m_fast'),
}

model ListTagsResponseBody = {
  tags?: [
    ImageTag
  ](name='tags', description='The information about the tags.'),
}

model ListTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagsResponseBody(name='body'),
}

/**
 * @summary Queries tags.
 *
 * @description You can call this operation to query the tags within the specified drive at a time. The top 2,000 tags of the images are returned.
 *
 * @param request ListTagsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagsResponse
 */
async function listTagsWithOptions(request: ListTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    body['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.videoThumbnailProcess)) {
    body['video_thumbnail_process'] = request.videoThumbnailProcess;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListTags',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/list_tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries tags.
 *
 * @description You can call this operation to query the tags within the specified drive at a time. The top 2,000 tags of the images are returned.
 *
 * @param request ListTagsRequest
 * @return ListTagsResponse
 */
async function listTags(request: ListTagsRequest): ListTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagsWithOptions(request, headers, runtime);
}

model ListUploadedPartsRequest {
  driveId?: string(name='drive_id', description='The drive ID. This parameter is required if the file is not uploaded by using the share URL of the file.', example='1'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='322fb07b975f4b0ae1b543fe8475eee4c19eb2b2'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  partNumberMarker?: int32(name='part_number_marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  shareId?: string(name='share_id', description='The share ID. This parameter is required if the file is uploaded by using the share URL of the file.', example='7JQX1FswpQ8'),
  uploadId?: string(name='upload_id', description='The ID of the upload task.

This parameter is required.', example='00166D06127B413BA1EC8ABB1144D101'),
}

model ListUploadedPartsResponseBody = {
  fileId?: string(name='file_id', description='The file ID.', example='322fb07b975f4b0ae1b543fe8475eee4c19eb2b2'),
  nextPartNumberMarker?: string(name='next_part_number_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  parallelUpload?: boolean(name='parallel_upload', description='Indicates whether the parallel upload feature is enabled.', example='false'),
  uploadId?: string(name='upload_id', description='The ID of the upload task.', example='00166D06127B413BA1EC8ABB1144D101'),
  uploadedParts?: [
    UploadPartInfo
  ](name='uploaded_parts', description='The information about the file parts.'),
}

model ListUploadedPartsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUploadedPartsResponseBody(name='body'),
}

/**
 * @summary Queries the file parts that are uploaded.
 *
 * @param request ListUploadedPartsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUploadedPartsResponse
 */
async function listUploadedPartsWithOptions(request: ListUploadedPartsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListUploadedPartsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.partNumberMarker)) {
    body['part_number_marker'] = request.partNumberMarker;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.uploadId)) {
    body['upload_id'] = request.uploadId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListUploadedParts',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/list_uploaded_parts`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries the file parts that are uploaded.
 *
 * @param request ListUploadedPartsRequest
 * @return ListUploadedPartsResponse
 */
async function listUploadedParts(request: ListUploadedPartsRequest): ListUploadedPartsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUploadedPartsWithOptions(request, headers, runtime);
}

model ListUserRequest {
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListUserResponseBody = {
  items?: [
    User
  ](name='items', description='The information about the users.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUserResponseBody(name='body'),
}

/**
 * @summary Queries users.
 *
 * @param request ListUserRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUserResponse
 */
async function listUserWithOptions(request: ListUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries users.
 *
 * @param request ListUserRequest
 * @return ListUserResponse
 */
async function listUser(request: ListUserRequest): ListUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUserWithOptions(request, headers, runtime);
}

model MoveFileRequest {
  checkNameMode?: string(name='check_name_mode', description='The processing method that is used if the file that you want to move has the same name as an existing file in the destination directory. Valid values:

ignore: allows you to move the file by using the same name as an existing file in the destination directory.

auto_rename: automatically renames the file that has the same name exists in the destination directory. By default, the current point in time is added to the end of the file name. Example: xxx_20060102_150405.

refuse: does not move the file that you want to move but returns the information about the file that has the same name in the destination directory.

Default value: ignore.', example='ignore'),
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
  toParentFileId?: string(name='to_parent_file_id', description='The ID of the destination parent directory to which you want to move a file or folder. If you want to move a file or folder to the root directory, set this parameter to root.

This parameter is required.', example='6520943DC261'),
}

model MoveFileResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

If an empty string is returned, the file is moved.

If a non-empty string is returned, an asynchronous task is required. You can call the GetAsyncTask operation to obtain the information about an asynchronous task based on the task ID.', example='23ebd1a24dba4166b1527add476ef2866051b4d5del106'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  exist?: boolean(name='exist', description='Indicates whether the file already exists in the destination directory.', example='false'),
  fileId?: string(name='file_id', description='The file ID.', example='fileid1'),
}

model MoveFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MoveFileResponseBody(name='body'),
}

/**
 * @summary Moves files or folders.
 *
 * @param request MoveFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return MoveFileResponse
 */
async function moveFileWithOptions(request: MoveFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MoveFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkNameMode)) {
    body['check_name_mode'] = request.checkNameMode;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.toParentFileId)) {
    body['to_parent_file_id'] = request.toParentFileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'MoveFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/move`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Moves files or folders.
 *
 * @param request MoveFileRequest
 * @return MoveFileResponse
 */
async function moveFile(request: MoveFileRequest): MoveFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return moveFileWithOptions(request, headers, runtime);
}

model QueryOrderPriceRequest {
  code?: string(name='code', description='This parameter is required.'),
  instanceId?: string(name='instance_id', description='This parameter is required.'),
  orderType?: string(name='order_type', description='This parameter is required.'),
  package?: string(name='package', description='This parameter is required.'),
  period?: long(name='period', description='This parameter is required.'),
  periodUnit?: string(name='period_unit', description='This parameter is required.'),
  totalSize?: long(name='total_size', description='This parameter is required.'),
  userCount?: long(name='user_count', description='This parameter is required.'),
}

model QueryOrderPriceResponseBody = {
  discountPrice?: double(name='discount_price'),
  originalPrice?: double(name='original_price'),
  tradePrice?: double(name='trade_price'),
}

model QueryOrderPriceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryOrderPriceResponseBody(name='body'),
}

/**
 * @summary 查询凌霄订单价格
 *
 * @param request QueryOrderPriceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryOrderPriceResponse
 */
async function queryOrderPriceWithOptions(request: QueryOrderPriceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryOrderPriceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.code)) {
    body['code'] = request.code;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['instance_id'] = request.instanceId;
  }
  if (!Util.isUnset(request.orderType)) {
    body['order_type'] = request.orderType;
  }
  if (!Util.isUnset(request.package)) {
    body['package'] = request.package;
  }
  if (!Util.isUnset(request.period)) {
    body['period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    body['period_unit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.totalSize)) {
    body['total_size'] = request.totalSize;
  }
  if (!Util.isUnset(request.userCount)) {
    body['user_count'] = request.userCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryOrderPrice',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/query_order_price`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 查询凌霄订单价格
 *
 * @param request QueryOrderPriceRequest
 * @return QueryOrderPriceResponse
 */
async function queryOrderPrice(request: QueryOrderPriceRequest): QueryOrderPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryOrderPriceWithOptions(request, headers, runtime);
}

model RemoveFaceGroupFileRequest {
  driveId?: string(name='drive_id', description='This parameter is required.', example='123'),
  faceGroupId?: string(name='face_group_id', description='This parameter is required.', example='Cluster-abc'),
  fileId?: string(name='file_id', description='This parameter is required.', example='abcd'),
}

model RemoveFaceGroupFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 从人脸分组中的移除指定的文件
 *
 * @param request RemoveFaceGroupFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveFaceGroupFileResponse
 */
async function removeFaceGroupFileWithOptions(request: RemoveFaceGroupFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveFaceGroupFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.faceGroupId)) {
    body['face_group_id'] = request.faceGroupId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveFaceGroupFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/albums/unassign_facegroup_item`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 从人脸分组中的移除指定的文件
 *
 * @param request RemoveFaceGroupFileRequest
 * @return RemoveFaceGroupFileResponse
 */
async function removeFaceGroupFile(request: RemoveFaceGroupFileRequest): RemoveFaceGroupFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeFaceGroupFileWithOptions(request, headers, runtime);
}

model RemoveGroupMemberRequest {
  groupId?: string(name='group_id', description='The ID of the group from which you want to remove a member.

This parameter is required.', example='3e5***2c2'),
  memberId?: string(name='member_id', description='The ID of the member. If member_type is set to user, set this parameter to the ID of the corresponding user.

This parameter is required.', example='2e4***1b1'),
  memberType?: string(name='member_type', description='The type of the member that you want to remove from the group. Only common users can be removed. If you want to remove all members from a group, you can directly delete the group. Valid value:

*   user

Note: A group can be a member of only one group. It cannot be a member of multiple groups. A user can be a member of multiple groups.

This parameter is required.', example='user'),
}

model RemoveGroupMemberResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Removes a member from a group.
 *
 * @param request RemoveGroupMemberRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveGroupMemberResponse
 */
async function removeGroupMemberWithOptions(request: RemoveGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveGroupMemberResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }
  if (!Util.isUnset(request.memberId)) {
    body['member_id'] = request.memberId;
  }
  if (!Util.isUnset(request.memberType)) {
    body['member_type'] = request.memberType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveGroupMember',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/remove_member`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Removes a member from a group.
 *
 * @param request RemoveGroupMemberRequest
 * @return RemoveGroupMemberResponse
 */
async function removeGroupMember(request: RemoveGroupMemberRequest): RemoveGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeGroupMemberWithOptions(request, headers, runtime);
}

model RemoveStoryFilesRequest {
  driveId?: string(name='drive_id', description='This parameter is required.', example='1'),
  files?: [ 
    {
      fileId?: string(name='file_id', description='This parameter is required.', example='63e5e4340f76cb3ead5f40f68163f0f967c1a7bf'),
      revisionId?: string(name='revision_id', example='642a88dd06e49d9c0a14411ebae606f70edd9a59'),
    }
  ](name='files'),
  storyId?: string(name='story_id', description='This parameter is required.', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model RemoveStoryFilesResponseBody = {
  driveId?: string(name='drive_id', example='1'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model RemoveStoryFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveStoryFilesResponseBody(name='body'),
}

/**
 * @summary 故事移除文件
 *
 * @param request RemoveStoryFilesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveStoryFilesResponse
 */
async function removeStoryFilesWithOptions(request: RemoveStoryFilesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveStoryFilesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.files)) {
    body['files'] = request.files;
  }
  if (!Util.isUnset(request.storyId)) {
    body['story_id'] = request.storyId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveStoryFiles',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/remove_story_files`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 故事移除文件
 *
 * @param request RemoveStoryFilesRequest
 * @return RemoveStoryFilesResponse
 */
async function removeStoryFiles(request: RemoveStoryFilesRequest): RemoveStoryFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeStoryFilesWithOptions(request, headers, runtime);
}

model RestoreFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fileId?: string(name='file_id', description='The ID of the file or folder.

This parameter is required.', example='4221bf6e6ab43a255edc4463bffa6f5f5d317401'),
}

model RestoreFileResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

If an empty string is returned, the file or folder is restored.

If a non-empty string is returned, an asynchronous task is required. You can call the GetAsyncTask operation to obtain the information about an asynchronous task based on the task ID.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The ID of the file or folder.', example='4221bf6e6ab43a255edc4463bffa6f5f5d317401'),
}

model RestoreFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestoreFileResponseBody(name='body'),
}

/**
 * @summary Restores a file or folder from the recycle bin.
 *
 * @param request RestoreFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestoreFileResponse
 */
async function restoreFileWithOptions(request: RestoreFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestoreFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RestoreFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/recyclebin/restore`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Restores a file or folder from the recycle bin.
 *
 * @param request RestoreFileRequest
 * @return RestoreFileResponse
 */
async function restoreFile(request: RestoreFileRequest): RestoreFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restoreFileWithOptions(request, headers, runtime);
}

model RestoreRevisionRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
  revisionId?: string(name='revision_id', description='The version ID.

This parameter is required.', example='40CB7794C929'),
}

model RestoreRevisionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Revision  
}

/**
 * @summary Restores a historical version of a file. You cannot restore the latest version of a file.
 *
 * @param request RestoreRevisionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestoreRevisionResponse
 */
async function restoreRevisionWithOptions(request: RestoreRevisionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestoreRevisionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.revisionId)) {
    body['revision_id'] = request.revisionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RestoreRevision',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/revision/restore`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Restores a historical version of a file. You cannot restore the latest version of a file.
 *
 * @param request RestoreRevisionRequest
 * @return RestoreRevisionResponse
 */
async function restoreRevision(request: RestoreRevisionRequest): RestoreRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restoreRevisionWithOptions(request, headers, runtime);
}

model ScanFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fields?: string(name='fields', description='The file properties to return.

*   If you want to return all file properties, set this parameter to \\\\*.
*   By default, if you do not specify this parameter, the following properties of a file are returned: - file_id, - drive_id, - parent_file_id, - type, - created_at, - updated_at, - file_extention, - size, - starred, - status, - category, and - permissions.
*   You can also specify properties to return. Separate multiple properties with commas (,).', example='*'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ScanFileResponseBody = {
  items?: [
    File
  ](name='items', description='The information about the files.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ScanFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ScanFileResponseBody(name='body'),
}

/**
 * @summary Scans files.
 *
 * @param request ScanFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ScanFileResponse
 */
async function scanFileWithOptions(request: ScanFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScanFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ScanFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/scan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Scans files.
 *
 * @param request ScanFileRequest
 * @return ScanFileResponse
 */
async function scanFile(request: ScanFileRequest): ScanFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scanFileWithOptions(request, headers, runtime);
}

model SearchAddressGroupsRequest {
  addressLevel?: string(name='address_level', description='The level of the location.

Valid values:

*   country

    <!-- -->

    <!-- -->

    <!-- -->

*   province

    <!-- -->

    <!-- -->

    <!-- -->

*   city

    <!-- -->

    <!-- -->

    <!-- -->

*   district

    <!-- -->

    <!-- -->

    <!-- -->

*   township

    <!-- -->

    <!-- -->

    <!-- -->'),
  addressNames?: [ string ](name='address_names', description='The locations.'),
  brGeoPoint?: string(name='br_geo_point', description='The coordinates of the bottom right vertex of the rectangle. Set the value in the format of latitude,longitude.', example='40.121,105.2121'),
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', description='The method used to generate the thumbnail of an image.', example='image/resize,w_200'),
  tlGeoPoint?: string(name='tl_geo_point', description='The coordinates of the top left vertex of the rectangle. Set the value in the format of latitude,longitude.', example='39.121,101.2121'),
  videoThumbnailProcess?: string(name='video_thumbnail_process', description='The method used to generate the thumbnail of a video.', example='video/snapshot,t_7000,f_jpg,w_800,h_600,m_fast'),
}

model SearchAddressGroupsResponseBody = {
  items?: [
    AddressGroup
  ](name='items', description='The location-based groups.'),
}

model SearchAddressGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchAddressGroupsResponseBody(name='body'),
}

/**
 * @summary Queries location-based groups based on specific locations.
 *
 * @param request SearchAddressGroupsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchAddressGroupsResponse
 */
async function searchAddressGroupsWithOptions(request: SearchAddressGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchAddressGroupsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.addressLevel)) {
    body['address_level'] = request.addressLevel;
  }
  if (!Util.isUnset(request.addressNames)) {
    body['address_names'] = request.addressNames;
  }
  if (!Util.isUnset(request.brGeoPoint)) {
    body['br_geo_point'] = request.brGeoPoint;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    body['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.tlGeoPoint)) {
    body['tl_geo_point'] = request.tlGeoPoint;
  }
  if (!Util.isUnset(request.videoThumbnailProcess)) {
    body['video_thumbnail_process'] = request.videoThumbnailProcess;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchAddressGroups',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/search_address_groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries location-based groups based on specific locations.
 *
 * @param request SearchAddressGroupsRequest
 * @return SearchAddressGroupsResponse
 */
async function searchAddressGroups(request: SearchAddressGroupsRequest): SearchAddressGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchAddressGroupsWithOptions(request, headers, runtime);
}

model SearchDomainsRequest {
  limit?: long(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\\\
By default, this parameter is empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  name?: string(name='name', description='The name of the domain. Fuzzy search is supported.'),
  orderBy?: string(name='order_by', description='The sorting rule. Set the value to created_at, which specifies that the results are sorted based on the time when the domain was created.', example='created_at'),
}

model SearchDomainsResponseBody = {
  items?: [
    Domain
  ](name='items', description='The queried domains.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model SearchDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchDomainsResponseBody(name='body'),
}

/**
 * @summary Search domain with specified attributes
 *
 * @param request SearchDomainsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchDomainsResponse
 */
async function searchDomainsWithOptions(request: SearchDomainsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchDomainsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    body['order_by'] = request.orderBy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchDomains',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Search domain with specified attributes
 *
 * @param request SearchDomainsRequest
 * @return SearchDomainsResponse
 */
async function searchDomains(request: SearchDomainsRequest): SearchDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchDomainsWithOptions(request, headers, runtime);
}

model SearchDriveRequest {
  driveName?: string(name='drive_name', description='The drive name.'),
  limit?: int32(name='limit', description='The maximum number of asynchronous tasks to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  owner?: string(name='owner', description='The owner of the drive.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
  ownerType?: string(name='owner_type', description='The type of the owner. Valid values:

user group', example='user'),
}

model SearchDriveResponseBody = {
  items?: [
    Drive
  ](name='items', description='The information about the drives.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model SearchDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchDriveResponseBody(name='body'),
}

/**
 * @summary Queries drives.
 *
 * @param request SearchDriveRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchDriveResponse
 */
async function searchDriveWithOptions(request: SearchDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveName)) {
    body['drive_name'] = request.driveName;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.owner)) {
    body['owner'] = request.owner;
  }
  if (!Util.isUnset(request.ownerType)) {
    body['owner_type'] = request.ownerType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries drives.
 *
 * @param request SearchDriveRequest
 * @return SearchDriveResponse
 */
async function searchDrive(request: SearchDriveRequest): SearchDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchDriveWithOptions(request, headers, runtime);
}

model SearchFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fields?: string(name='fields', example='url,thumbnail', deprecated=true),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  orderBy?: string(name='order_by', description='The field by which to sort the returned results. Default value: created_at. Valid values:

*   created_at: sorts the results by the time when the file was created.
*   updated_at: sorts the results by the time when the file was modified.
*   size: sorts the results by the size of the file.
*   name: sorts the results by the name of the file.

The order in which you want to sort the returned results. Valid values:

*   ASC: sorts the results in ascending order.
*   DESC: sorts the results in descending order.

You must specify this parameter in the \\\\<field name> \\\\<ASC or DESC> format. Separate multiple field names with commas (,). A preceding field has a higher priority than a following field. Examples:

*   If you want to sort the results based on the file name in ascending order, set this parameter to "name ASC".
*   If you want to sort the results based on the creation time in descending order, set this parameter to "created_at DESC".
*   If you want to sort the results based on the creation time in descending order first, and then sort the results based on the file name in ascending order if the creation time is the same, set this parameter to "created_at DESC,name ASC".', example='name'),
  query?: string(name='query', description='The search condition. Fuzzy searches based on the file name or directory name are supported. The search condition can be up to 4,096 characters in length.

This parameter is required.', example='not name=123'),
  recursive?: boolean(name='recursive'),
  returnTotalCount?: boolean(name='return_total_count', description='Specifies whether to return the total number of retrieved files.', example='true'),
}

model SearchFileResponseBody = {
  items?: [
    File
  ](name='items', description='The information about the files.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  totalCount?: long(name='total_count', description='The total number of retrieved files.', example='1022'),
}

model SearchFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchFileResponseBody(name='body'),
}

/**
 * @summary Queries files. For more information about best practices, visit https://help.aliyun.com/document_detail/175890.html.
 *
 * @param request SearchFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchFileResponse
 */
async function searchFileWithOptions(request: SearchFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.orderBy)) {
    body['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.query)) {
    body['query'] = request.query;
  }
  if (!Util.isUnset(request.recursive)) {
    body['recursive'] = request.recursive;
  }
  if (!Util.isUnset(request.returnTotalCount)) {
    body['return_total_count'] = request.returnTotalCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries files. For more information about best practices, visit https://help.aliyun.com/document_detail/175890.html.
 *
 * @param request SearchFileRequest
 * @return SearchFileResponse
 */
async function searchFile(request: SearchFileRequest): SearchFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchFileWithOptions(request, headers, runtime);
}

model SearchShareLinkRequest {
  creators?: [ string ](name='creators', description='The creators of shares. Set this parameter to a user ID. If you do not specify this parameter, Drive and Photo Service automatically queries shares based on your permissions. If you are a drive administrator or the super administrator, the shares created by all members are queried. If you are a team administrator, the shares created by all team members are queried. If you are a common user, only the shares created by yourself are queried.

If you specify this parameter, this parameter must be set to the ID of the super administrator, a drive administrator, or a team administrator.'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  orderBy?: string(name='order_by', description='The field by which to sort the returned results. Default value: created_at. Valid values:

*   share_name: sorts the results by the name of the share.
*   updated_at: sorts the results by the time when the share was modified.
*   description: sorts the results by the description of the share.
*   created_at: sorts the results by the time when the share was created.', example='created_at'),
  orderDirection?: string(name='order_direction', description='The order in which you want to sort the returned results. By default, order_direction is set to DESC if order_by is set to created_at or updated_at, and is set to ASC if order_by is set to other values. Valid values:

*   ASC: sorts the results in ascending order.
*   DESC: sorts the results in descending order.', example='ASC'),
  query?: string(name='query', description='The query condition that is used to search for share URLs. You can use the following fields to specify query conditions: created_at: queries a share URL based on the time when the share URL was created. updated_at: queries a share URL based on the time when the share URL was modified. share_name_for_fuzzy: queries a share URL based on the name of the share. A fuzzy match is supported. status: queries a share URL based on the status of the share. Valid values: enabled and disabled. A value of enabled indicates that the share is valid. A value of disabled indicates that the share is canceled. expired_time: queries a share URL based on the expiration time of the share. If the share never expires, set this field to 1970-01-01T00:00:00. Otherwise, set this field to 1970-01-02T00:00:00.', example='created_at>=\\\\"2022-01-18T02:50:00\\\\" and created_at<\\\\"2022-01-19T09:45:28\\\\" and share_name_for_fuzzy match \\\\"HD.mp4\\\\" and status in [\\\\"enabled\\\\", \\\\"disabled\\\\"] and expired_time=\\\\"1970-01-01T00:00:00\\\\"'),
  returnTotalCount?: boolean(name='return_total_count', description='Specifies whether to return the total number of returned results.', example='false'),
}

model SearchShareLinkResponseBody = {
  items?: [
    ShareLink
  ](name='items', description='The share URLs.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  totalCount?: long(name='total_count', description='The total number of entries returned.', example='101'),
}

model SearchShareLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchShareLinkResponseBody(name='body'),
}

/**
 * @summary Queries share URLs.
 *
 * @param request SearchShareLinkRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchShareLinkResponse
 */
async function searchShareLinkWithOptions(request: SearchShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.creators)) {
    body['creators'] = request.creators;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.orderBy)) {
    body['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    body['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.query)) {
    body['query'] = request.query;
  }
  if (!Util.isUnset(request.returnTotalCount)) {
    body['return_total_count'] = request.returnTotalCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Queries share URLs.
 *
 * @param request SearchShareLinkRequest
 * @return SearchShareLinkResponse
 */
async function searchShareLink(request: SearchShareLinkRequest): SearchShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchShareLinkWithOptions(request, headers, runtime);
}

model SearchSimilarImageClustersRequest {
  driveId?: string(name='drive_id', description='This parameter is required.', example='1'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', example='image/resize,m_fill,h_128,w_128,limit_0/format,jpg', deprecated=true),
  limit?: long(name='limit', example='50'),
  marker?: string(name='marker', example='YWRzX3VzZXJfcHJvZmlsZV9je1bnQh***'),
  order?: string(name='order', example='desc'),
}

model SearchSimilarImageClustersResponseBody = {
  nextMarker?: string(name='next_marker', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0***'),
  similarImageClusters?: [ 
    {
      files?: [
        File
      ](name='files'),
    }
  ](name='similar_image_clusters'),
}

model SearchSimilarImageClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchSimilarImageClustersResponseBody(name='body'),
}

/**
 * @summary 获取相似图片聚类结果
 *
 * @param request SearchSimilarImageClustersRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchSimilarImageClustersResponse
 */
async function searchSimilarImageClustersWithOptions(request: SearchSimilarImageClustersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchSimilarImageClustersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    body['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchSimilarImageClusters',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/query_similar_image_clusters`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 获取相似图片聚类结果
 *
 * @param request SearchSimilarImageClustersRequest
 * @return SearchSimilarImageClustersResponse
 */
async function searchSimilarImageClusters(request: SearchSimilarImageClustersRequest): SearchSimilarImageClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchSimilarImageClustersWithOptions(request, headers, runtime);
}

model SearchStoriesRequest {
  coverImageThumbnailProcess?: string(name='cover_image_thumbnail_process', example='image/resize,m_fill,h_128,w_128,limit_0/format,jpg', deprecated=true),
  coverVideoThumbnailProcess?: string(name='cover_video_thumbnail_process', example='video/snapshot,t_1000,f_jpg,w_0,h_0,m_fast,ar_auto', deprecated=true),
  createTimeRange?: {
    end?: string(name='end', example='2022-12-31T00:00:00+08:00'),
    start?: string(name='start', example='2016-12-31T00:00:00+08:00'),
  }(name='create_time_range', nullable=true),
  customLabels?: string(name='custom_labels', example='key1=value1,key2!=value2', deprecated=true),
  driveId?: string(name='drive_id', description='This parameter is required.', example='1'),
  faceGroupIds?: [ string ](name='face_group_ids'),
  limit?: long(name='limit', example='100'),
  marker?: string(name='marker', example='NWQ1Yjk4YmI1ZDODBhNDQ2Nzhl***'),
  order?: string(name='order', example='desc'),
  sort?: string(name='sort', example='CreateTime'),
  storyEndTimeRange?: {
    end?: string(name='end', example='2022-12-31T00:00:00+08:00'),
    start?: string(name='start', example='2016-12-31T00:00:00+08:00'),
  }(name='story_end_time_range', nullable=true),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
  storyName?: string(name='story_name'),
  storyStartTimeRange?: {
    end?: string(name='end', example='2022-12-31T00:00:00+08:00'),
    start?: string(name='start', example='2016-12-31T00:00:00+08:00'),
  }(name='story_start_time_range', nullable=true),
  storyType?: string(name='story_type', example='PeopleMemory'),
  urlExpireSec?: long(name='url_expire_sec', example='900', deprecated=true),
  withEmptyStories?: boolean(name='with_empty_stories', example='false', nullable=true),
}

model SearchStoriesResponseBody = {
  items?: [
    Story
  ](name='items'),
  nextMarker?: string(name='next_marker', example='Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJ***'),
}

model SearchStoriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchStoriesResponseBody(name='body'),
}

/**
 * @summary 查询故事列表
 *
 * @param request SearchStoriesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchStoriesResponse
 */
async function searchStoriesWithOptions(request: SearchStoriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchStoriesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.coverImageThumbnailProcess)) {
    body['cover_image_thumbnail_process'] = request.coverImageThumbnailProcess;
  }
  if (!Util.isUnset(request.coverVideoThumbnailProcess)) {
    body['cover_video_thumbnail_process'] = request.coverVideoThumbnailProcess;
  }
  if (!Util.isUnset(request.createTimeRange)) {
    body['create_time_range'] = request.createTimeRange;
  }
  if (!Util.isUnset(request.customLabels)) {
    body['custom_labels'] = request.customLabels;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.faceGroupIds)) {
    body['face_group_ids'] = request.faceGroupIds;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }
  if (!Util.isUnset(request.sort)) {
    body['sort'] = request.sort;
  }
  if (!Util.isUnset(request.storyEndTimeRange)) {
    body['story_end_time_range'] = request.storyEndTimeRange;
  }
  if (!Util.isUnset(request.storyId)) {
    body['story_id'] = request.storyId;
  }
  if (!Util.isUnset(request.storyName)) {
    body['story_name'] = request.storyName;
  }
  if (!Util.isUnset(request.storyStartTimeRange)) {
    body['story_start_time_range'] = request.storyStartTimeRange;
  }
  if (!Util.isUnset(request.storyType)) {
    body['story_type'] = request.storyType;
  }
  if (!Util.isUnset(request.urlExpireSec)) {
    body['url_expire_sec'] = request.urlExpireSec;
  }
  if (!Util.isUnset(request.withEmptyStories)) {
    body['with_empty_stories'] = request.withEmptyStories;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchStories',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/find_stories`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 查询故事列表
 *
 * @param request SearchStoriesRequest
 * @return SearchStoriesResponse
 */
async function searchStories(request: SearchStoriesRequest): SearchStoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchStoriesWithOptions(request, headers, runtime);
}

model SearchUserRequest {
  email?: string(name='email', description='The email address of the user.', example='123@pds.com'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  nickName?: string(name='nick_name', description='The nickname of the user. The nickname can be up to 128 characters in length.', example='pdsuer'),
  nickNameForFuzzy?: string(name='nick_name_for_fuzzy', description='The nickname used for fuzzy searches. The nickname can be up to 128 characters in length.', example='la'),
  phone?: string(name='phone', description='The mobile number of the user.', example='13900001111'),
  role?: string(name='role', description='The role of the user. Valid values:

*   superadmin
*   admin
*   user', example='user'),
  status?: string(name='status', description='The state of the user. Valid values:

*   disabled: The user is prohibited from logon.
*   enabled: The user is in a normal state.', example='enabled'),
  userName?: string(name='user_name', description='The name of the user. The name can be up to 128 characters in length.', example='pds'),
}

model SearchUserResponseBody = {
  items?: [
    User
  ](name='items', description='The information about the users.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model SearchUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SearchUserResponseBody(name='body'),
}

/**
 * @summary Searches for users.
 *
 * @param request SearchUserRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchUserResponse
 */
async function searchUserWithOptions(request: SearchUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.email)) {
    body['email'] = request.email;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.nickName)) {
    body['nick_name'] = request.nickName;
  }
  if (!Util.isUnset(request.nickNameForFuzzy)) {
    body['nick_name_for_fuzzy'] = request.nickNameForFuzzy;
  }
  if (!Util.isUnset(request.phone)) {
    body['phone'] = request.phone;
  }
  if (!Util.isUnset(request.role)) {
    body['role'] = request.role;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.userName)) {
    body['user_name'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Searches for users.
 *
 * @param request SearchUserRequest
 * @return SearchUserResponse
 */
async function searchUser(request: SearchUserRequest): SearchUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchUserWithOptions(request, headers, runtime);
}

model TokenRequest {
  assertion?: string(name='assertion', description='The JWT assertion that is signed by using the JWT private key. The JWT assertion contains the information about the user to be authorized and the authorization parameters. For more information about the structure of the JWT assertion, see JWTPayload. This parameter is required if grant_type is set to urn:ietf:params:oauth:grant-type:jwt-bearer.', example='ey***asd'),
  clientId?: string(name='client_id', description='The AppId of the application that is created in the Drive and Photo Service console.

This parameter is required.', example='1Zu***flH'),
  clientSecret?: string(name='client_secret', description='The AppSecret of the application that is created in the Drive and Photo Service console. This parameter is required if the application is of the WebServer type.', example='80D***3i5'),
  code?: string(name='code', description='The authorization code in the redirect URI that is specified after the authorization process is complete. This parameter is required if grant_type is set to authorization_code.', example='0045157fa8e24f4f9a0d9e3ff158c1e0'),
  grantType?: string(name='grant_type', description='The method that is used to generate an access token. Valid values:

authorization_code: generates an access token by using the authorization code that is returned after the authorization process is complete.

refresh_token: generates an access token by using the refresh token that is returned after the authorization process is complete.

urn:ietf:params:oauth:grant-type:jwt-bearer: generates an access token by using a JWT assertion.

This parameter is required.', example='refresh_token'),
  redirectUri?: string(name='redirect_uri', description='The redirect URI that is specified when you initiate the authorization request. This parameter is required if grant_type is set to authorization_code.', example='https://aliyun.com/pds'),
  refreshToken?: string(name='refresh_token', description='The refresh token that is used to refresh the access token. This parameter is required if grant_type is set to refresh_token.', example='399623e13353490391266c7d48a13ed1'),
}

model TokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Token  
}

/**
 * @summary Generates an access token based on Open Authorization (OAuth) 2.0.
 *
 * @description For more information about how to access Drive and Photo Service from a web server application by using OAuth 2.0, visit [OAuth 2.0 For Web Server Applications](https://www.alibabacloud.com/help/zh/pds/drive-and-photo-service-dev/user-guide/oauth-2-0-access-process-for-web-server-applications).
 * For more information about how to access Drive and Photo Service by using a JSON Web Token (JWT) application, visit [Access process for JWT applications](https://www.alibabacloud.com/help/zh/pds/drive-and-photo-service-dev/user-guide/access-process-for-jwt-applications).
 *
 * @param request TokenRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TokenResponse
 */
async function tokenWithOptions(request: TokenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TokenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.assertion)) {
    body['assertion'] = request.assertion;
  }
  if (!Util.isUnset(request.clientId)) {
    body['client_id'] = request.clientId;
  }
  if (!Util.isUnset(request.clientSecret)) {
    body['client_secret'] = request.clientSecret;
  }
  if (!Util.isUnset(request.code)) {
    body['code'] = request.code;
  }
  if (!Util.isUnset(request.grantType)) {
    body['grant_type'] = request.grantType;
  }
  if (!Util.isUnset(request.redirectUri)) {
    body['redirect_uri'] = request.redirectUri;
  }
  if (!Util.isUnset(request.refreshToken)) {
    body['refresh_token'] = request.refreshToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'Token',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/oauth/token`,
    method = 'POST',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Generates an access token based on Open Authorization (OAuth) 2.0.
 *
 * @description For more information about how to access Drive and Photo Service from a web server application by using OAuth 2.0, visit [OAuth 2.0 For Web Server Applications](https://www.alibabacloud.com/help/zh/pds/drive-and-photo-service-dev/user-guide/oauth-2-0-access-process-for-web-server-applications).
 * For more information about how to access Drive and Photo Service by using a JSON Web Token (JWT) application, visit [Access process for JWT applications](https://www.alibabacloud.com/help/zh/pds/drive-and-photo-service-dev/user-guide/access-process-for-jwt-applications).
 *
 * @param request TokenRequest
 * @return TokenResponse
 */
async function token(request: TokenRequest): TokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tokenWithOptions(request, headers, runtime);
}

model TrashFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fileId?: string(name='file_id', description='The ID of the file or folder.

This parameter is required.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406'),
}

model TrashFileResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

If an empty string is returned, the file or folder is moved to the recycle bin.

If a non-empty string is returned, an asynchronous task is required. You can call the GetAsyncTask operation to obtain the information about an asynchronous task based on the task ID.', example='13ebd3a24dba4166b1527add676ef2866051b4d5dele16'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The ID of the file or folder.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406'),
}

model TrashFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TrashFileResponseBody(name='body'),
}

/**
 * @summary Moves a file or folder to the recycle bin.
 *
 * @param request TrashFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TrashFileResponse
 */
async function trashFileWithOptions(request: TrashFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TrashFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TrashFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/recyclebin/trash`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Moves a file or folder to the recycle bin.
 *
 * @param request TrashFileRequest
 * @return TrashFileResponse
 */
async function trashFile(request: TrashFileRequest): TrashFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return trashFileWithOptions(request, headers, runtime);
}

model UnLinkAccountRequest {
  extra?: string(name='extra', example='1'),
  identity?: string(name='identity', description='This parameter is required.', example='139****'),
  type?: string(name='type', description='This parameter is required.', example='mobile'),
  userId?: string(name='user_id', description='This parameter is required.', example='uid1'),
}

model UnLinkAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 取消账号绑定
 *
 * @param request UnLinkAccountRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnLinkAccountResponse
 */
async function unLinkAccountWithOptions(request: UnLinkAccountRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UnLinkAccountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extra)) {
    body['extra'] = request.extra;
  }
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnLinkAccount',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/account/unlink`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 取消账号绑定
 *
 * @param request UnLinkAccountRequest
 * @return UnLinkAccountResponse
 */
async function unLinkAccount(request: UnLinkAccountRequest): UnLinkAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unLinkAccountWithOptions(request, headers, runtime);
}

model UpdateDomainRequest {
  description?: string(name='description', description='The description of the domain.'),
  domainId?: string(name='domain_id', description='The domain ID.

This parameter is required.', example='bj1'),
  domainName?: string(name='domain_name', description='The name of the domain.'),
  initDriveEnable?: boolean(name='init_drive_enable', description='Specifies whether to enable the default drive feature. A value of true specifies that all users are assigned a drive by default on the first logon. Default value: false.', example='true'),
  initDriveSize?: long(name='init_drive_size', description='The size of the default drive. Unit: bytes. You must specify init_drive_size if you set init_drive_enable to true. Default value: 0. A value of 0 specifies that the size of the default drive is 0 bytes and you cannot upload files to the drive. To initialize the default drive, set init_drive_size to 0. A value of -1 specifies that the size is unlimited.', example='1073741824'),
  publishedAppAccessStrategy?: AppAccessStrategy(name='published_app_access_strategy', description='The access policy of the application.'),
  sizeQuota?: long(name='size_quota', description='The total storage quota for all drives in the domain. A value of 0 specifies that the quota is unlimited.', example='1099511627776'),
  userCountQuota?: long(name='user_count_quota', description='The maximum number of users that can be created in the domain.', example='50'),
}

model UpdateDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Domain  
}

/**
 * @summary Update domain information.
 *
 * @param request UpdateDomainRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDomainResponse
 */
async function updateDomainWithOptions(request: UpdateDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.domainId)) {
    body['domain_id'] = request.domainId;
  }
  if (!Util.isUnset(request.domainName)) {
    body['domain_name'] = request.domainName;
  }
  if (!Util.isUnset(request.initDriveEnable)) {
    body['init_drive_enable'] = request.initDriveEnable;
  }
  if (!Util.isUnset(request.initDriveSize)) {
    body['init_drive_size'] = request.initDriveSize;
  }
  if (!Util.isUnset(request.publishedAppAccessStrategy)) {
    body['published_app_access_strategy'] = request.publishedAppAccessStrategy;
  }
  if (!Util.isUnset(request.sizeQuota)) {
    body['size_quota'] = request.sizeQuota;
  }
  if (!Util.isUnset(request.userCountQuota)) {
    body['user_count_quota'] = request.userCountQuota;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDomain',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Update domain information.
 *
 * @param request UpdateDomainRequest
 * @return UpdateDomainResponse
 */
async function updateDomain(request: UpdateDomainRequest): UpdateDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDomainWithOptions(request, headers, runtime);
}

model UpdateDriveRequest {
  description?: string(name='description', description='The description of the drive. The description can be up to 1,024 characters in length.'),
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  driveName?: string(name='drive_name', description='The name of the drive. The name can be up to 128 characters in length.', example='my_drive'),
  owner?: string(name='owner', description='The owner of the drive. Note: You can modify the owner of a personal drive only by using an AccessKey pair.', example='user1'),
  status?: string(name='status', description='The state of the drive. Valid values:

enabled and disabled.', example='enabled'),
  totalSize?: long(name='total_size', description='The total size of the drive. Unit: bytes. A value of -1 specifies that the size is unlimited.', example='10240'),
}

model UpdateDriveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Drive  
}

/**
 * @summary Modifies a drive.
 *
 * @param request UpdateDriveRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDriveResponse
 */
async function updateDriveWithOptions(request: UpdateDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.driveName)) {
    body['drive_name'] = request.driveName;
  }
  if (!Util.isUnset(request.owner)) {
    body['owner'] = request.owner;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.totalSize)) {
    body['total_size'] = request.totalSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Modifies a drive.
 *
 * @param request UpdateDriveRequest
 * @return UpdateDriveResponse
 */
async function updateDrive(request: UpdateDriveRequest): UpdateDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDriveWithOptions(request, headers, runtime);
}

model UpdateFacegroupRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  groupCoverFaceId?: string(name='group_cover_face_id', description='The face ID of the thumbnail of the face-based group. You can obtain the face ID from the **image_media_metadata** parameter in the returned results of the GetFile, ListFile, or SearchFile operation.', example='face1'),
  groupId?: string(name='group_id', description='The ID of the face-based group. You can call the ListFacegroups operation to query the group ID.

This parameter is required.', example='group-abc'),
  groupName?: string(name='group_name', description='The name of the face-based group. The name can be up to 128 characters in length.'),
  remarks?: string(name='remarks', description='The remarks. The remarks can be up to 128 characters in length.'),
}

model UpdateFacegroupResponseBody = {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  groupId?: string(name='group_id', description='The group ID.', example='group-abc'),
}

model UpdateFacegroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFacegroupResponseBody(name='body'),
}

/**
 * @summary Updates a face-based group.
 *
 * @param request UpdateFacegroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFacegroupResponse
 */
async function updateFacegroupWithOptions(request: UpdateFacegroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFacegroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.groupCoverFaceId)) {
    body['group_cover_face_id'] = request.groupCoverFaceId;
  }
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    body['group_name'] = request.groupName;
  }
  if (!Util.isUnset(request.remarks)) {
    body['remarks'] = request.remarks;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFacegroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/update_facegroup_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates a face-based group.
 *
 * @param request UpdateFacegroupRequest
 * @return UpdateFacegroupResponse
 */
async function updateFacegroup(request: UpdateFacegroupRequest): UpdateFacegroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFacegroupWithOptions(request, headers, runtime);
}

model UpdateFileRequest {
  checkNameMode?: string(name='check_name_mode', description='The processing method that is used if the file that you want to modify has the same name as an existing file on the cloud. Valid values:

ignore: allows you to modify the file by using the same name as an existing file on the cloud.

auto_rename: automatically renames the file that has the same name on the cloud. By default, the current point in time is added to the end of the file name. Example: xxx_20060102_150405.

refuse: does not modify the file that you want to modify but returns the information about the file that has the same name on the cloud.

Default value: ignore.', example='ignore'),
  description?: string(name='description', description='The description of the file. The description can be up to 1,024 characters in length.'),
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
  hidden?: boolean(name='hidden', description='Specifies whether to hide the file.', example='true'),
  labels?: [ string ](name='labels', description='The tags of the file. You can specify up to 100 tags.'),
  localModifiedAt?: string(name='local_modified_at', description='The local time when the file was modified. The time is in the yyyy-MM-ddTHH:mm:ssZ format based on the UTC+0 time zone.', example='2019-08-20T06:51:27.292Z'),
  name?: string(name='name', description='The name of the file. The name can be up to 1,024 bytes in length based on the UTF-8 encoding rule.', example='a.jpg'),
  starred?: boolean(name='starred', description='Specifies whether to add the file to favorites.', example='true'),
}

model UpdateFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: File  
}

/**
 * @summary Modifies the information about a file instead of the file data.
 *
 * @param request UpdateFileRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFileResponse
 */
async function updateFileWithOptions(request: UpdateFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkNameMode)) {
    body['check_name_mode'] = request.checkNameMode;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.hidden)) {
    body['hidden'] = request.hidden;
  }
  if (!Util.isUnset(request.labels)) {
    body['labels'] = request.labels;
  }
  if (!Util.isUnset(request.localModifiedAt)) {
    body['local_modified_at'] = request.localModifiedAt;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.starred)) {
    body['starred'] = request.starred;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Modifies the information about a file instead of the file data.
 *
 * @param request UpdateFileRequest
 * @return UpdateFileResponse
 */
async function updateFile(request: UpdateFileRequest): UpdateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFileWithOptions(request, headers, runtime);
}

model UpdateGroupRequest {
  description?: string(name='description', description='The description of the group after modification.', example='test group description'),
  groupId?: string(name='group_id', description='The ID of the group that you want to modify.

This parameter is required.', example='2e43ec8427dd45f19431b7504649a1b4'),
  groupName?: string(name='group_name', description='The name of the group after modification.', example='test group'),
}

model UpdateGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Group  
}

/**
 * @summary Modifies the information about a group.
 *
 * @param request UpdateGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateGroupResponse
 */
async function updateGroupWithOptions(request: UpdateGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    body['group_name'] = request.groupName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Modifies the information about a group.
 *
 * @param request UpdateGroupRequest
 * @return UpdateGroupResponse
 */
async function updateGroup(request: UpdateGroupRequest): UpdateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateGroupWithOptions(request, headers, runtime);
}

model UpdateIdentityToBenefitPkgMappingRequest {
  amount?: long(name='amount', description='The number of benefit packages.

This parameter specifies the number of benefit packages of the resource type. Default value: 1.', example='1'),
  benefitPkgId?: string(name='benefit_pkg_id', description='The unique identifier of the benefit package.

This parameter is required.', example='40cb7794c9294'),
  expireTime?: long(name='expire_time', description='The expiration time of the benefit package. Set this parameter to a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.

By default, the benefit package never expires.', example='1633167071000'),
  identityId?: string(name='identity_id', description='The unique identifier of the entity.

If you call this operation to manage the benefits of a user, set this parameter to the ID of the user.

This parameter is required.', example='user123'),
  identityType?: string(name='identity_type', description='The type of the entity. If you call this operation to manage the benefits of a user, set this parameter to user.

This parameter is required.', example='user'),
}

model UpdateIdentityToBenefitPkgMappingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary Updates the mapping between an entity and a benefit package. You can call this operation to associate a benefit package with a user.
 *
 * @param request UpdateIdentityToBenefitPkgMappingRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateIdentityToBenefitPkgMappingResponse
 */
async function updateIdentityToBenefitPkgMappingWithOptions(request: UpdateIdentityToBenefitPkgMappingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateIdentityToBenefitPkgMappingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.amount)) {
    body['amount'] = request.amount;
  }
  if (!Util.isUnset(request.benefitPkgId)) {
    body['benefit_pkg_id'] = request.benefitPkgId;
  }
  if (!Util.isUnset(request.expireTime)) {
    body['expire_time'] = request.expireTime;
  }
  if (!Util.isUnset(request.identityId)) {
    body['identity_id'] = request.identityId;
  }
  if (!Util.isUnset(request.identityType)) {
    body['identity_type'] = request.identityType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIdentityToBenefitPkgMapping',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/benefit/identity_to_benefit_pkg_mapping/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates the mapping between an entity and a benefit package. You can call this operation to associate a benefit package with a user.
 *
 * @param request UpdateIdentityToBenefitPkgMappingRequest
 * @return UpdateIdentityToBenefitPkgMappingResponse
 */
async function updateIdentityToBenefitPkgMapping(request: UpdateIdentityToBenefitPkgMappingRequest): UpdateIdentityToBenefitPkgMappingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateIdentityToBenefitPkgMappingWithOptions(request, headers, runtime);
}

model UpdateRevisionRequest {
  driveId?: string(name='drive_id', description='The drive ID.

This parameter is required.', example='1'),
  fileId?: string(name='file_id', description='The file ID.

This parameter is required.', example='9520943DC264'),
  keepForever?: boolean(name='keep_forever', description='Specifies whether to permanently retain a version.

By default, this parameter is not specified, which indicates that you do not modify the permanent retention configuration of the version.', example='true'),
  revisionDescription?: string(name='revision_description', description='The description of the version. The description can be up to 1,024 characters in length.

By default, this parameter is not specified, which indicates that you do not modify the description of the version.', example='aaa'),
  revisionId?: string(name='revision_id', description='The version ID.

This parameter is required.', example='40CB7794C929'),
}

model UpdateRevisionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Revision  
}

/**
 * @summary Updates the version information. You can call this operation to permanently retain a version or modify the description of a version. You can permanently retain up to 50 versions of a file.
 *
 * @param request UpdateRevisionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRevisionResponse
 */
async function updateRevisionWithOptions(request: UpdateRevisionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRevisionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.keepForever)) {
    body['keep_forever'] = request.keepForever;
  }
  if (!Util.isUnset(request.revisionDescription)) {
    body['revision_description'] = request.revisionDescription;
  }
  if (!Util.isUnset(request.revisionId)) {
    body['revision_id'] = request.revisionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRevision',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/revision/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Updates the version information. You can call this operation to permanently retain a version or modify the description of a version. You can permanently retain up to 50 versions of a file.
 *
 * @param request UpdateRevisionRequest
 * @return UpdateRevisionResponse
 */
async function updateRevision(request: UpdateRevisionRequest): UpdateRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRevisionWithOptions(request, headers, runtime);
}

model UpdateShareLinkRequest {
  description?: string(name='description', description='The description of the share link. The description can be up to 1,024 characters in length.'),
  disableDownload?: boolean(name='disable_download', description='Specifies whether to prohibit the downloads of the shared files.', example='false'),
  disablePreview?: boolean(name='disable_preview', description='Specifies whether to prohibit the previews of the shared files.', example='false'),
  disableSave?: boolean(name='disable_save', description='Specifies whether to prohibit the saves of the shared files.', example='false'),
  downloadCount?: long(name='download_count', description='The number of times that the shared files are downloaded. The value must be greater than or equal to 0.', example='30'),
  downloadLimit?: long(name='download_limit', description='The maximum number of times that the shared files can be downloaded. The value must be greater than or equal to 0. A value of 0 specifies that the number is unlimited.', example='100'),
  expiration?: string(name='expiration', description='The time when the share link expires. The time follows the RFC 3339 standard. Example: 2020-06-28T11:33:00.000+08:00. If you leave this parameter empty, the share link never expires.', example='2020-06-28T11:33:00.000+08:00'),
  previewCount?: long(name='preview_count', description='The number of times that the shared files are previewed. The value must be greater than or equal to 0.', example='3'),
  previewLimit?: long(name='preview_limit', description='The maximum number of times that the shared files can be previewed. The value must be greater than or equal to 0. A value of 0 specifies that the number is unlimited.', example='100'),
  reportCount?: long(name='report_count', description='The number of times that the shared files are reported. The value must be greater than or equal to 0.', example='1'),
  saveCount?: long(name='save_count', description='The number of times that the shared files are saved. The value must be greater than or equal to 0.', example='5'),
  saveLimit?: long(name='save_limit', description='The maximum number of times that the shared files can be saved. The value must be greater than or equal to 0. A value of 0 specifies that the number is unlimited.', example='100'),
  shareId?: string(name='share_id', description='The share ID.

This parameter is required.', example='7JQX1FswpQ8'),
  shareName?: string(name='share_name', description='The name of the share link. By default, the name of the first file is used. The name can be up to 128 characters in length.'),
  sharePwd?: string(name='share_pwd', description='The access code. The access code can be up to 64 characters in length. A value of 0 specifies an empty string.', example='abcF123x'),
  status?: string(name='status', description='The state of the share link. Valid values:

*   disabled: The share link is canceled.
*   enabled: The share link is effective.', example='enabled'),
  videoPreviewCount?: long(name='video_preview_count', description='The number of times that the videos are previewed in the shared files. The value must be greater than or equal to 0.', example='100'),
}

model UpdateShareLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ShareLink  
}

/**
 * @summary Modifies a share link.
 *
 * @param request UpdateShareLinkRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateShareLinkResponse
 */
async function updateShareLinkWithOptions(request: UpdateShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.disableDownload)) {
    body['disable_download'] = request.disableDownload;
  }
  if (!Util.isUnset(request.disablePreview)) {
    body['disable_preview'] = request.disablePreview;
  }
  if (!Util.isUnset(request.disableSave)) {
    body['disable_save'] = request.disableSave;
  }
  if (!Util.isUnset(request.downloadCount)) {
    body['download_count'] = request.downloadCount;
  }
  if (!Util.isUnset(request.downloadLimit)) {
    body['download_limit'] = request.downloadLimit;
  }
  if (!Util.isUnset(request.expiration)) {
    body['expiration'] = request.expiration;
  }
  if (!Util.isUnset(request.previewCount)) {
    body['preview_count'] = request.previewCount;
  }
  if (!Util.isUnset(request.previewLimit)) {
    body['preview_limit'] = request.previewLimit;
  }
  if (!Util.isUnset(request.reportCount)) {
    body['report_count'] = request.reportCount;
  }
  if (!Util.isUnset(request.saveCount)) {
    body['save_count'] = request.saveCount;
  }
  if (!Util.isUnset(request.saveLimit)) {
    body['save_limit'] = request.saveLimit;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.shareName)) {
    body['share_name'] = request.shareName;
  }
  if (!Util.isUnset(request.sharePwd)) {
    body['share_pwd'] = request.sharePwd;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.videoPreviewCount)) {
    body['video_preview_count'] = request.videoPreviewCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Modifies a share link.
 *
 * @param request UpdateShareLinkRequest
 * @return UpdateShareLinkResponse
 */
async function updateShareLink(request: UpdateShareLinkRequest): UpdateShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateShareLinkWithOptions(request, headers, runtime);
}

model UpdateStoryRequest {
  cover?: {
    fileId?: string(name='file_id', example='63e5e4340f76cb3ead5f40f68163f0f967c1a7bf'),
    revisionId?: string(name='revision_id', example='642a88dd06e49d9c0a14411ebae606f70edd9a59'),
  }(name='cover', nullable=true),
  customLabels?: map[string]string(name='custom_labels', deprecated=true),
  driveId?: string(name='drive_id', description='This parameter is required.', example='1'),
  storyId?: string(name='story_id', description='This parameter is required.', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
  storyName?: string(name='story_name', example='name1', nullable=true),
}

model UpdateStoryResponseBody = {
  driveId?: string(name='drive_id', example='1'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model UpdateStoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateStoryResponseBody(name='body'),
}

/**
 * @summary 更新故事
 *
 * @param request UpdateStoryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateStoryResponse
 */
async function updateStoryWithOptions(request: UpdateStoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateStoryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cover)) {
    body['cover'] = request.cover;
  }
  if (!Util.isUnset(request.customLabels)) {
    body['custom_labels'] = request.customLabels;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.storyId)) {
    body['story_id'] = request.storyId;
  }
  if (!Util.isUnset(request.storyName)) {
    body['story_name'] = request.storyName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateStory',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/update_story`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 更新故事
 *
 * @param request UpdateStoryRequest
 * @return UpdateStoryResponse
 */
async function updateStory(request: UpdateStoryRequest): UpdateStoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateStoryWithOptions(request, headers, runtime);
}

model UpdateUserRequest {
  avatar?: string(name='avatar', description='The URL of the profile picture.

If you specify the parameter in the HTTP URL format, the URL must start with http:// or https:// and can be up to 4 KB in size.

If you specify the parameter in the DATA URL format, the URL must start with data:// and be encoded in Base64. The URL can be up to 300 KB in size.', example='http://a.b.c/pds.jpg'),
  description?: string(name='description', description='The description of the user. The description can be up to 1,024 characters in length.'),
  email?: string(name='email', description='The email address of the user.', example='a@aliyunpds.com'),
  groupInfoList?: [ 
    {
      groupId?: string(name='group_id', description='The group ID.', example='g123'),
    }
  ](name='group_info_list', description='The information about the group.'),
  nickName?: string(name='nick_name', description='The nickname of the user. The nickname can be up to 128 characters in length.', example='pdsuer'),
  phone?: string(name='phone', description='The mobile number of the user.', example='13900001111'),
  role?: string(name='role', description='The role of the user. Valid values:

*   superadmin
*   admin
*   user', example='user'),
  status?: string(name='status', description='The state of the user. Valid values:

*   disabled: The user is prohibited from logon.
*   enabled: The user is in a normal state.', example='enabled'),
  userData?: map[string]string(name='user_data', description='The custom data. The data can be up to 1,024 characters in length.'),
  userId?: string(name='user_id', description='The user ID. The ID can be up to 64 characters in length and cannot contain a number sign (#).

This parameter is required.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
}

model UpdateUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: User  
}

/**
 * @summary Modifies the information about a user.
 *
 * @param request UpdateUserRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateUserResponse
 */
async function updateUserWithOptions(request: UpdateUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.avatar)) {
    body['avatar'] = request.avatar;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.email)) {
    body['email'] = request.email;
  }
  if (!Util.isUnset(request.groupInfoList)) {
    body['group_info_list'] = request.groupInfoList;
  }
  if (!Util.isUnset(request.nickName)) {
    body['nick_name'] = request.nickName;
  }
  if (!Util.isUnset(request.phone)) {
    body['phone'] = request.phone;
  }
  if (!Util.isUnset(request.role)) {
    body['role'] = request.role;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.userData)) {
    body['user_data'] = request.userData;
  }
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary Modifies the information about a user.
 *
 * @param request UpdateUserRequest
 * @return UpdateUserResponse
 */
async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateUserWithOptions(request, headers, runtime);
}

