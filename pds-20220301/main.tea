/**
 *
 */
import Util;
import SPI;
import GatewayClient;
import OpenApi;
import OpenApiUtil;

extends OpenApi;

type @client = SPI

init(config: OpenApi.Config){
  super(config);
  @client = new GatewayClient();
  @spi = @client;
  @signatureAlgorithm = 'v2';
  @endpointRule = '';
  }

model AccountLinkInfo {
  authenticationType?: string(name='authentication_type', description='账号类型'),
  createdAt?: long(name='created_at', description='账号创建时间'),
  displayName?: string(name='display_name', description='账号显示名'),
  domainId?: string(name='domain_id', description='域ID'),
  extra?: string(name='extra', description='账号附加信息'),
  identity?: string(name='identity', description='账号唯一标识'),
  userId?: string(name='user_id', description='账号对应的用户ID'),
}

model Activity {
  activityId?: string(name='activity_id', description='活动 id'),
  device?: string(name='device', description='设备名'),
  driveId?: string(name='drive_id', description='空间 id'),
  eventType?: int32(name='event_type', description='事件类型'),
  latestEventTime?: string(name='latest_event_time', description='最近事件时间'),
  resourceCategory?: int32(name='resource_category', description='资源类型'),
  resourceList?: [  map[string]any ](name='resource_list', description='资源列表'),
  totalResourceCount?: long(name='total_resource_count', description='资源总数'),
  userId?: string(name='user_id', description='用户 id'),
}

model Address {
  city?: string(name='city', description='市'),
  country?: string(name='country', description='国家'),
  district?: string(name='district', description='区'),
  province?: string(name='province', description='省'),
  township?: string(name='township', description='镇'),
}

model AddressGroup {
  addressDetail?: Address(name='address_detail', description='地点详细信息'),
  count?: long(name='count', description='地点数量'),
  coverFileId?: string(name='cover_file_id', description='地点封面图片文件ID'),
  coverUrl?: string(name='cover_url', description='地点封面图片地址'),
  location?: string(name='location', description='经纬度'),
  name?: string(name='name', description='地点名称'),
}

model Drive {
  createdAt?: string(name='created_at', description='创建时间'),
  creator?: string(name='creator', description='创建者'),
  description?: string(name='description', description='描述'),
  domainId?: string(name='domain_id', description='域id'),
  driveId?: string(name='drive_id', description='空间id'),
  driveName?: string(name='drive_name', description='空间名称'),
  driveType?: string(name='drive_type', description='空间类型'),
  owner?: string(name='owner', description='归属者'),
  ownerType?: string(name='owner_type', description='归属者类型'),
  status?: string(name='status', description='状态'),
  totalSize?: long(name='total_size', description='总空间大小'),
  usedSize?: long(name='used_size', description='使用空间大小'),
}

model FaceGroup {
  createdAt?: string(name='created_at', description='人脸分组生成时间'),
  groupCoverFaceBoundary?: {
    height?: int32(name='height', description='高， 单位像素'),
    left?: int32(name='left', description='距离照片左边框的距离，单位像素'),
    top?: int32(name='top', description='距离照片顶部的距离，单位像素'),
    width?: int32(name='width', description='宽，单位像素'),
  }(name='group_cover_face_boundary', description='人脸分组封面图片边框'),
  groupCoverFileId?: string(name='group_cover_file_id', description='人脸分组封面文件ID'),
  groupCoverHeight?: long(name='group_cover_height', description='人脸分组封面图片高'),
  groupCoverUrl?: string(name='group_cover_url', description='人脸分组封面头像地址'),
  groupCoverWidth?: long(name='group_cover_width', description='人脸分组封面图片宽'),
  groupId?: string(name='group_id', description='人脸分组ID'),
  groupName?: string(name='group_name', description='人脸分组名称'),
  imageCount?: long(name='image_count', description='照片数量'),
  remarks?: string(name='remarks', description='备注'),
  updatedAt?: string(name='updated_at', description='人脸分组修改时间'),
}

model File {
  category?: string(name='category', description='分类'),
  contentHash?: string(name='content_hash', description='内容hash'),
  contentHashName?: string(name='content_hash_name', description='内容hash算法名'),
  contentType?: string(name='content_type', description='内容类型'),
  crc64Hash?: string(name='crc64_hash', description='crc64'),
  createdAt?: string(name='created_at', description='创建时间'),
  description?: string(name='description', description='描述'),
  domainId?: string(name='domain_id', description='域id'),
  downloadUrl?: string(name='download_url', description='下载链接'),
  driveId?: string(name='drive_id', description='空间id'),
  fileExtension?: string(name='file_extension', description='文件扩展'),
  fileId?: string(name='file_id', description='文件id'),
  hidden?: boolean(name='hidden', description='是否隐藏'),
  labels?: string(name='labels', description='标签'),
  localCreatedAt?: string(name='local_created_at', description='文件本地创建时间'),
  localModifiedAt?: string(name='local_modified_at', description='文件本地修改时间'),
  name?: string(name='name', description='名称'),
  parentFileId?: string(name='parent_file_id', description='父文件夹id'),
  revisionId?: string(name='revision_id', description='版本id'),
  size?: long(name='size', description='大小'),
  starred?: boolean(name='starred', description='是否收藏'),
  status?: string(name='status', description='状态'),
  thumbnail?: string(name='thumbnail', description='缩略图地址'),
  trashedAt?: string(name='trashed_at', description='放入回收站时间'),
  type?: string(name='type', description='类型'),
  updatedAt?: string(name='updated_at', description='修改时间'),
  uploadId?: string(name='upload_id', description='上传id'),
}

model FilePermissionMember {
  actionList?: [ string ](name='action_list', description='授予的操作权限列表'),
  disinheritSubGroup?: boolean(name='disinherit_sub_group', description='是否禁用子用户组继承此权限'),
  expireTime?: long(name='expire_time', description='过期时间'),
  identity?: Identity(name='identity', description='授权对象'),
  roleId?: string(name='role_id', description='授予的角色ID'),
}

model FileStreamInfo {
  contentHash?: string(name='content_hash', description='内容hash'),
  contentHashName?: string(name='content_hash_name', description='内容hash名'),
  contentMd5?: string(name='content_md5', description='内容md5'),
  partInfoList?: UploadPartInfo(name='part_info_list', description='分段信息'),
  preHash?: string(name='pre_hash', description='预秒传'),
  proofCode?: string(name='proof_code', description='挑战码'),
  proofVersion?: string(name='proof_version', description='挑战算法版本'),
  size?: long(name='size', description='大小'),
}

model Group {
  createdAt?: long(name='created_at', description='创建时间'),
  creator?: string(name='creator', description='创建者'),
  description?: string(name='description', description='描述'),
  domainId?: string(name='domain_id', description='域ID'),
  groupId?: string(name='group_id', description='用户组ID'),
  groupName?: string(name='group_name', description='用户组名'),
  updatedAt?: long(name='updated_at', description='更新时间'),
}

model Identity {
  identityId?: string(name='identity_id', description='ID'),
  identityType?: string(name='identity_type', description='类型'),
}

model ImageMediaMetadata {
  height?: long(name='height', description='长'),
  takenAt?: string(name='taken_at', description='拍摄时间'),
  width?: long(name='width', description='宽'),
}

model ImageTag {
  count?: long(name='count', description='数量'),
  coverFileCategory?: string(name='cover_file_category', description='封面文件分类'),
  coverFileId?: string(name='cover_file_id', description='封面文件id'),
  coverOverallScore?: float(name='cover_overall_score', description='封面评分'),
  coverTagConfidence?: float(name='cover_tag_confidence', description='封面标签置信度'),
  coverUrl?: string(name='cover_url', description='标签封面图片地址'),
  name?: string(name='name', description='名称'),
}

model JWTPayload {
  aud?: string(name='aud', description='DomainID'),
  autoCreate?: boolean(name='auto_create', description='扩展字段，是否自动创建用户'),
  exp?: long(name='exp', description='JWT过期时间, Unix Time，单位秒，生效时间和过期时间不能超过15分钟。为防止客户端和服务器时间不一致，此时间建议设置为当前时间加5分钟。'),
  iat?: long(name='iat', description='签发时间，Unix Time，单位秒，在此时间之前无法使用，如：1577682075'),
  iss?: string(name='iss', description='控制台申请的JWT App ID'),
  jti?: string(name='jti', description='应用生成JWT的唯一标识，长度16-128位，推荐使用uuid即可'),
  nbf?: long(name='nbf', description='生效时间，Unix Time，单位秒，不指定则默认为当前时间。生效时间和过期时间不能超过15分钟。 为防止客户端和服务器时间不一致，此时间建议设置为当前时间减5分钟，或者不设置。'),
  sub?: string(name='sub', description='待授权的UserID或者DomainID'),
  subType?: string(name='sub_type', description='扩展字段，表示账号类型，目前支持填 user、service，此处填user，则sub为userID，签发普通用户accessToken。 此处填service，则sub为domainID，签发domain服务账号accessToken(超级管理员权限)'),
}

model Revision {
  contentHash?: string(name='content_hash', description='内容hash'),
  contentHashName?: string(name='content_hash_name', description='内容hash算法名'),
  crc64Hash?: string(name='crc64_hash', description='crc64'),
  createdAt?: string(name='created_at', description='创建时间'),
  domainId?: string(name='domain_id', description='域id'),
  downloadUrl?: string(name='download_url', description='下载地址'),
  driveId?: string(name='drive_id', description='空间id'),
  fileExtension?: string(name='file_extension', description='扩展名'),
  fileId?: string(name='file_id', description='文件id'),
  isLatestVersion?: boolean(name='is_latest_version', description='是否为最新版本'),
  keepForever?: boolean(name='keep_forever', description='是否永久保留'),
  revisionDescription?: string(name='revision_description', description='版本描述'),
  revisionId?: string(name='revision_id', description='版本id'),
  revisionName?: string(name='revision_name', description='版本名'),
  revisionVersion?: long(name='revision_version', description='版本号'),
  size?: long(name='size', description='版本大小'),
  thumbnail?: string(name='thumbnail', description='缩略图地址'),
  updatedAt?: string(name='updated_at', description='修改时间'),
  url?: string(name='url', description='预览地址'),
}

model ShareLink {
  accessCount?: long(name='access_count', description='访问次数'),
  createdAt?: string(name='created_at', description='创建时间'),
  creator?: string(name='creator', description='创建者'),
  description?: string(name='description', description='描述'),
  disableDownload?: boolean(name='disable_download', description='禁止下载分享中的文件'),
  disablePreview?: boolean(name='disable_preview', description='禁止预览分享中的文件'),
  disableSave?: boolean(name='disable_save', description='禁止转存分享中的文件'),
  downloadCount?: long(name='download_count', description='下载次数'),
  downloadLimit?: long(name='download_limit', description='分享下载次数限制'),
  driveId?: string(name='drive_id', description='空间id'),
  expiration?: string(name='expiration', description='到期时间'),
  expired?: boolean(name='expired', description='是否过期'),
  fileIdList?: string(name='file_id_list', description='分享父路径文件id列表'),
  previewCount?: long(name='preview_count', description='预览次数'),
  previewLimit?: long(name='preview_limit', description='分享预览次数限制'),
  reportCount?: long(name='report_count', description='被举报次数'),
  saveCount?: long(name='save_count', description='转存次数'),
  saveLimit?: long(name='save_limit', description='分享转存次数限制'),
  shareId?: string(name='share_id', description='分享id'),
  shareName?: string(name='share_name', description='分享名称'),
  sharePwd?: string(name='share_pwd', description='分享密码'),
  status?: string(name='status', description='状态'),
  updatedAt?: string(name='updated_at', description='修改时间'),
  videoPreviewCount?: long(name='video_preview_count', description='音视频播放次数'),
}

model SystemTag {
  confidence?: float(name='confidence', description='标签置信度'),
  name?: string(name='name', description='标签名'),
  parentName?: string(name='parent_name', description='标签父标签'),
  source?: string(name='source', description='解析出标签的来源关键词'),
  tagLevel?: int32(name='tag_level', description='标签层级'),
}

model Token {
  accessToken?: string(name='access_token', description='访问凭证'),
  avatar?: string(name='avatar', description='用户头像'),
  defaultDriveId?: string(name='default_drive_id', description='用户默认空间ID'),
  deviceId?: string(name='device_id', description='登录设备ID'),
  deviceName?: string(name='device_name', description='登录设备名称'),
  domainId?: string(name='domain_id', description='域ID'),
  expireTime?: string(name='expire_time', description='凭证过期时间'),
  expiresIn?: long(name='expires_in', description='凭证有效期'),
  isFirstLogin?: boolean(name='is_first_login', description='是否首次登录'),
  nickName?: string(name='nick_name', description='用户昵称'),
  refreshToken?: string(name='refresh_token', description='刷新凭证'),
  role?: string(name='role', description='用户角色'),
  status?: string(name='status', description='用户状态'),
  tokenType?: string(name='token_type', description='凭证类型'),
  userId?: string(name='user_id', description='用户ID'),
  userName?: string(name='user_name', description='用户名'),
}

model UploadPartInfo {
  etag?: string(name='etag', description='etag'),
  internalUploadUrl?: string(name='internal_upload_url', description='内网上传地址'),
  parallelSha1Ctx?: {
    h?: [ long ](name='h', description='上一个数据块SHA1的第1-5个32位变量'),
    partOffset?: long(name='part_offset', description='到上一个数据块为止的总长度，字节，需要为64的倍数'),
  }(name='parallel_sha1_ctx', description='上一个分段的sha1上下文'),
  partNumber?: int32(name='part_number', description='段编号'),
  partSize?: long(name='part_size', description='分段大小'),
  uploadUrl?: string(name='upload_url', description='上传地址'),
}

model User {
  avatar?: string(name='avatar', description='头像'),
  createdAt?: long(name='created_at', description='创建时间'),
  creator?: string(name='creator', description='创建者'),
  defaultDriveId?: string(name='default_drive_id', description='缺省空间id'),
  description?: string(name='description', description='描述'),
  domainId?: string(name='domain_id', description='域id'),
  email?: string(name='email', description='邮箱'),
  nickName?: string(name='nick_name', description='昵称'),
  phone?: string(name='phone', description='手机号'),
  role?: string(name='role', description='角色'),
  status?: string(name='status', description='状态'),
  updatedAt?: long(name='updated_at', description='修改时间'),
  userData?: map[string]string(name='user_data', description='用户自定义数据'),
  userId?: string(name='user_id', description='用户id'),
  userName?: string(name='user_name', description='用户名'),
}

model UserTag {
  value?: string(name='Value', description='value'),
  key?: string(name='key', description='key'),
}

model VideoMediaMetadata {
  duration?: string(name='duration', description='时长'),
  takenAt?: string(name='taken_at', description='拍摄时间'),
}

model VideoPreviewPlayInfo {
  category?: string(name='category', description='所属分类'),
  liveTranscodingTaskList?: [ 
    {
      keepOriginalResolution?: boolean(name='keep_original_resolution', description='是否保持原分辨率'),
      status?: string(name='status', description='状态'),
      templateId?: string(name='template_id', description='模板id'),
      url?: string(name='url', description='播放地址'),
    }
  ](name='live_transcoding_task_list', description='播放信息'),
  meta?: {
    duration?: double(name='duration', description='视频长度'),
    height?: long(name='height', description='视频高度'),
    width?: long(name='width', description='视频宽度'),
  }(name='meta', description='视频元信息'),
}

model AuthorizeRequest {
  clientId?: string(name='client_id'),
  hideConsent?: boolean(name='hide_consent'),
  loginType?: string(name='login_type'),
  redirectUri?: string(name='redirect_uri'),
  responseType?: string(name='response_type'),
  scope?: [ string ](name='scope'),
  state?: string(name='state'),
}

model AuthorizeShrinkRequest {
  clientId?: string(name='client_id'),
  hideConsent?: boolean(name='hide_consent'),
  loginType?: string(name='login_type'),
  redirectUri?: string(name='redirect_uri'),
  responseType?: string(name='response_type'),
  scopeShrink?: string(name='scope'),
  state?: string(name='state'),
}

model AuthorizeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function authorize(request: AuthorizeRequest): AuthorizeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return authorizeWithOptions(request, headers, runtime);
}

async function authorizeWithOptions(tmpReq: AuthorizeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuthorizeResponse {
  Util.validateModel(tmpReq);
  var request = new AuthorizeShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.scope)) {
    request.scopeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scope, 'scope', 'simple');
  }
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientId)) {
    query['client_id'] = request.clientId;
  }
  if (!Util.isUnset(request.hideConsent)) {
    query['hide_consent'] = request.hideConsent;
  }
  if (!Util.isUnset(request.loginType)) {
    query['login_type'] = request.loginType;
  }
  if (!Util.isUnset(request.redirectUri)) {
    query['redirect_uri'] = request.redirectUri;
  }
  if (!Util.isUnset(request.responseType)) {
    query['response_type'] = request.responseType;
  }
  if (!Util.isUnset(request.scopeShrink)) {
    query['scope'] = request.scopeShrink;
  }
  if (!Util.isUnset(request.state)) {
    query['state'] = request.state;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Authorize',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/oauth/authorize`,
    method = 'GET',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model CancelShareLinkRequest {
  shareId?: string(name='share_id'),
}

model CancelShareLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function cancelShareLink(request: CancelShareLinkRequest): CancelShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelShareLinkWithOptions(request, headers, runtime);
}

async function cancelShareLinkWithOptions(request: CancelShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/cancel`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ClearRecyclebinRequest {
  driveId?: string(name='drive_id'),
}

model ClearRecyclebinResponseBody = {
  asyncTaskId?: string(name='async_task_id'),
  domainId?: string(name='domain_id', description='Id of the request'),
  driveId?: string(name='drive_id'),
}

model ClearRecyclebinResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ClearRecyclebinResponseBody(name='body'),
}

async function clearRecyclebin(request: ClearRecyclebinRequest): ClearRecyclebinResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return clearRecyclebinWithOptions(request, headers, runtime);
}

async function clearRecyclebinWithOptions(request: ClearRecyclebinRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ClearRecyclebinResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ClearRecyclebin',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/recyclebin/clear`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model CompleteFileRequest {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  uploadId?: string(name='upload_id'),
}

model CompleteFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: File  
}

async function completeFile(request: CompleteFileRequest): CompleteFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return completeFileWithOptions(request, headers, runtime);
}

async function completeFileWithOptions(request: CompleteFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CompleteFileResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.uploadId)) {
    body['upload_id'] = request.uploadId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CompleteFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/complete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model CreateDriveRequest {
  default?: boolean(name='default'),
  description?: string(name='description'),
  driveName?: string(name='drive_name'),
  driveType?: string(name='drive_type'),
  owner?: string(name='owner'),
  ownerType?: string(name='owner_type'),
  status?: string(name='status'),
  totalSize?: long(name='total_size'),
}

model CreateDriveResponseBody = {
  domainId?: string(name='domain_id', description='Id of the request'),
  driveId?: string(name='drive_id'),
}

model CreateDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDriveResponseBody(name='body'),
}

async function createDrive(request: CreateDriveRequest): CreateDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDriveWithOptions(request, headers, runtime);
}

async function createDriveWithOptions(request: CreateDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDriveResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.default)) {
    body['default'] = request.default;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.driveName)) {
    body['drive_name'] = request.driveName;
  }
  if (!Util.isUnset(request.driveType)) {
    body['drive_type'] = request.driveType;
  }
  if (!Util.isUnset(request.owner)) {
    body['owner'] = request.owner;
  }
  if (!Util.isUnset(request.ownerType)) {
    body['owner_type'] = request.ownerType;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.totalSize)) {
    body['total_size'] = request.totalSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model CreateFileRequest {
  checkNameMode?: string(name='check_name_mode', description='重命名模式'),
  contentHash?: string(name='content_hash', description='内容hash'),
  contentHashName?: string(name='content_hash_name', description='内容hash算法名'),
  contentType?: string(name='content_type', description='文件类型'),
  description?: string(name='description', description='描述信息'),
  driveId?: string(name='drive_id', description='用户空间id'),
  fileId?: string(name='file_id', description='文件id'),
  hidden?: boolean(name='hidden'),
  imageMediaMetadata?: ImageMediaMetadata(name='image_media_metadata'),
  localCreatedAt?: string(name='local_created_at', description='文件本地创建时间'),
  localModifiedAt?: string(name='local_modified_at', description='本地文件修改时间'),
  name?: string(name='name', description='文件或文件夹名称'),
  parallelUpload?: boolean(name='parallel_upload'),
  parentFileId?: string(name='parent_file_id', description='父文件夹id'),
  partInfoList?: [ 
    {
      partNumber?: int32(name='part_number'),
    }
  ](name='part_info_list'),
  preHash?: string(name='pre_hash'),
  proofCode?: string(name='proof_code', description='挑战码'),
  proofVersion?: string(name='proof_version', description='挑战算法版本'),
  shareId?: string(name='share_id', description='共享id'),
  size?: long(name='size', description='文件大小'),
  type?: string(name='type', description='类型'),
  userTags?: [
    UserTag
  ](name='user_tags', description='用户打标'),
  videoMediaMetadata?: VideoMediaMetadata(name='video_media_metadata'),
}

model CreateFileResponseBody = {
  domainId?: string(name='domain_id', description='域id'),
  driveId?: string(name='drive_id', description='空间id'),
  exist?: boolean(name='exist', description='文件是否存在'),
  fileId?: string(name='file_id', description='文件id'),
  fileName?: string(name='file_name', description='文件名'),
  parentFileId?: string(name='parent_file_id', description='父目录文件id'),
  partInfoList?: [
    UploadPartInfo
  ](name='part_info_list', description='分段信息'),
  rapidUpload?: boolean(name='rapid_upload', description='是否已经秒传'),
  status?: string(name='status', description='文件状态'),
  type?: string(name='type'),
  uploadId?: string(name='upload_id', description='上传id'),
}

model CreateFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFileResponseBody(name='body'),
}

async function createFile(request: CreateFileRequest): CreateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFileWithOptions(request, headers, runtime);
}

async function createFileWithOptions(request: CreateFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFileResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.checkNameMode)) {
    body['check_name_mode'] = request.checkNameMode;
  }
  if (!Util.isUnset(request.contentHash)) {
    body['content_hash'] = request.contentHash;
  }
  if (!Util.isUnset(request.contentHashName)) {
    body['content_hash_name'] = request.contentHashName;
  }
  if (!Util.isUnset(request.contentType)) {
    body['content_type'] = request.contentType;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.hidden)) {
    body['hidden'] = request.hidden;
  }
  if (!Util.isUnset(request.imageMediaMetadata)) {
    body['image_media_metadata'] = request.imageMediaMetadata;
  }
  if (!Util.isUnset(request.localCreatedAt)) {
    body['local_created_at'] = request.localCreatedAt;
  }
  if (!Util.isUnset(request.localModifiedAt)) {
    body['local_modified_at'] = request.localModifiedAt;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.parallelUpload)) {
    body['parallel_upload'] = request.parallelUpload;
  }
  if (!Util.isUnset(request.parentFileId)) {
    body['parent_file_id'] = request.parentFileId;
  }
  if (!Util.isUnset(request.partInfoList)) {
    body['part_info_list'] = request.partInfoList;
  }
  if (!Util.isUnset(request.preHash)) {
    body['pre_hash'] = request.preHash;
  }
  if (!Util.isUnset(request.proofCode)) {
    body['proof_code'] = request.proofCode;
  }
  if (!Util.isUnset(request.proofVersion)) {
    body['proof_version'] = request.proofVersion;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.size)) {
    body['size'] = request.size;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }
  if (!Util.isUnset(request.userTags)) {
    body['user_tags'] = request.userTags;
  }
  if (!Util.isUnset(request.videoMediaMetadata)) {
    body['video_media_metadata'] = request.videoMediaMetadata;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model CreateGroupRequest {
  description?: string(name='description'),
  groupName?: string(name='group_name'),
  isRoot?: boolean(name='is_root'),
  parentGroupId?: string(name='parent_group_id'),
}

model CreateGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Group  
}

async function createGroup(request: CreateGroupRequest): CreateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createGroupWithOptions(request, headers, runtime);
}

async function createGroupWithOptions(request: CreateGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateGroupResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.groupName)) {
    body['group_name'] = request.groupName;
  }
  if (!Util.isUnset(request.isRoot)) {
    body['is_root'] = request.isRoot;
  }
  if (!Util.isUnset(request.parentGroupId)) {
    body['parent_group_id'] = request.parentGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateGroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model CreateShareLinkRequest {
  description?: string(name='description'),
  disableDownload?: boolean(name='disable_download'),
  disablePreview?: boolean(name='disable_preview'),
  disableSave?: boolean(name='disable_save'),
  downloadLimit?: long(name='download_limit'),
  driveId?: string(name='drive_id'),
  expiration?: string(name='expiration'),
  fileIdList?: string(name='file_id_list'),
  previewLimit?: long(name='preview_limit'),
  saveLimit?: long(name='save_limit'),
  shareName?: string(name='share_name'),
  sharePwd?: string(name='share_pwd'),
  userId?: string(name='user_id'),
}

model CreateShareLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ShareLink  
}

async function createShareLink(request: CreateShareLinkRequest): CreateShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createShareLinkWithOptions(request, headers, runtime);
}

async function createShareLinkWithOptions(request: CreateShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.disableDownload)) {
    body['disable_download'] = request.disableDownload;
  }
  if (!Util.isUnset(request.disablePreview)) {
    body['disable_preview'] = request.disablePreview;
  }
  if (!Util.isUnset(request.disableSave)) {
    body['disable_save'] = request.disableSave;
  }
  if (!Util.isUnset(request.downloadLimit)) {
    body['download_limit'] = request.downloadLimit;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.expiration)) {
    body['expiration'] = request.expiration;
  }
  if (!Util.isUnset(request.fileIdList)) {
    body['file_id_list'] = request.fileIdList;
  }
  if (!Util.isUnset(request.previewLimit)) {
    body['preview_limit'] = request.previewLimit;
  }
  if (!Util.isUnset(request.saveLimit)) {
    body['save_limit'] = request.saveLimit;
  }
  if (!Util.isUnset(request.shareName)) {
    body['share_name'] = request.shareName;
  }
  if (!Util.isUnset(request.sharePwd)) {
    body['share_pwd'] = request.sharePwd;
  }
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model CreateUserRequest {
  avatar?: string(name='avatar', description='头像地址'),
  description?: string(name='description', description='用户描述'),
  email?: string(name='email', description='邮箱地址'),
  groupInfoList?: [ 
    {
      groupId?: string(name='group_id'),
    }
  ](name='group_info_list'),
  nickName?: string(name='nick_name', description='用户昵称'),
  phone?: string(name='phone', description='电话'),
  role?: string(name='role', description='角色'),
  status?: string(name='status', description='用户状态'),
  userData?: string(name='user_data', description='用户自定义数据'),
  userId?: string(name='user_id', description='用户id'),
  userName?: string(name='user_name', description='用户名'),
}

model CreateUserResponseBody = {
  avatar?: string(name='avatar', description='头像地址'),
  createdAt?: long(name='created_at'),
  creator?: string(name='creator', description='创建者'),
  defaultDriveId?: string(name='default_drive_id', description='缺省空间id'),
  description?: string(name='description', description='描述'),
  domainId?: string(name='domain_id', description='域id'),
  email?: string(name='email', description='邮箱地址'),
  nickName?: string(name='nick_name', description='昵称'),
  phone?: string(name='phone', description='电话'),
  role?: string(name='role', description='角色'),
  status?: string(name='status', description='状态'),
  updatedAt?: long(name='updated_at'),
  userData?: map[string]string(name='user_data'),
  userId?: string(name='user_id', description='用户id'),
  userName?: string(name='user_name', description='用户名'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUserResponseBody(name='body'),
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createUserWithOptions(request, headers, runtime);
}

async function createUserWithOptions(request: CreateUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.avatar)) {
    body['avatar'] = request.avatar;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.email)) {
    body['email'] = request.email;
  }
  if (!Util.isUnset(request.groupInfoList)) {
    body['group_info_list'] = request.groupInfoList;
  }
  if (!Util.isUnset(request.nickName)) {
    body['nick_name'] = request.nickName;
  }
  if (!Util.isUnset(request.phone)) {
    body['phone'] = request.phone;
  }
  if (!Util.isUnset(request.role)) {
    body['role'] = request.role;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.userData)) {
    body['user_data'] = request.userData;
  }
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }
  if (!Util.isUnset(request.userName)) {
    body['user_name'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model DeleteDriveRequest {
  driveId?: string(name='drive_id'),
}

model DeleteDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteDrive(request: DeleteDriveRequest): DeleteDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDriveWithOptions(request, headers, runtime);
}

async function deleteDriveWithOptions(request: DeleteDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDriveResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model DeleteFileRequest {
  driveId?: string(name='drive_id', description='drive id 如果要删除drive下的文件时，drive_id时必需的参数'),
  fileId?: string(name='file_id', description='file_id是文件的唯一标识，删除文件或者目录时必须指定file_id'),
}

model DeleteFileResponseBody = {
  asyncTaskId?: string(name='async_task_id'),
  domainId?: string(name='domain_id'),
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
}

model DeleteFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFileResponseBody(name='body'),
}

async function deleteFile(request: DeleteFileRequest): DeleteFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFileWithOptions(request, headers, runtime);
}

async function deleteFileWithOptions(request: DeleteFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFileResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model DeleteGroupRequest {
  groupId?: string(name='group_id'),
}

model DeleteGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteGroup(request: DeleteGroupRequest): DeleteGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGroupWithOptions(request, headers, runtime);
}

async function deleteGroupWithOptions(request: DeleteGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteGroupResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model DeleteRevisionRequest {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  revisionId?: string(name='revision_id'),
}

model DeleteRevisionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteRevision(domainId: string, request: DeleteRevisionRequest): DeleteRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRevisionWithOptions(domainId, request, headers, runtime);
}

async function deleteRevisionWithOptions(domainId: string, request: DeleteRevisionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRevisionResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['domain_id'] = domainId;
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.revisionId)) {
    body['revision_id'] = request.revisionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRevision',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/revision/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model DeleteUserRequest {
  userId?: string(name='user_id'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteUserWithOptions(request, headers, runtime);
}

async function deleteUserWithOptions(request: DeleteUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model DeltaGetLastCursorRequest {
  driveId?: string(name='drive_id', description='云端 drive id'),
  syncRootId?: string(name='sync_root_id', description='同步目录的对应的云端跟目录'),
}

model DeltaGetLastCursorResponseBody = {
  cursor?: string(name='cursor', description='当前增量变化的最新游标'),
}

model DeltaGetLastCursorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeltaGetLastCursorResponseBody(name='body'),
}

async function deltaGetLastCursor(request: DeltaGetLastCursorRequest): DeltaGetLastCursorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deltaGetLastCursorWithOptions(request, headers, runtime);
}

async function deltaGetLastCursorWithOptions(request: DeltaGetLastCursorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeltaGetLastCursorResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.syncRootId)) {
    body['sync_root_id'] = request.syncRootId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeltaGetLastCursor',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get_last_cursor`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model DownloadFileRequest {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  imageThumbnailProcess?: string(name='image_thumbnail_process'),
  officeThumbnailProcess?: string(name='office_thumbnail_process'),
  videoThumbnailProcess?: string(name='video_thumbnail_process'),
}

model DownloadFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function downloadFile(request: DownloadFileRequest): DownloadFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return downloadFileWithOptions(request, headers, runtime);
}

async function downloadFileWithOptions(request: DownloadFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DownloadFileResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    body['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.officeThumbnailProcess)) {
    body['office_thumbnail_process'] = request.officeThumbnailProcess;
  }
  if (!Util.isUnset(request.videoThumbnailProcess)) {
    body['video_thumbnail_process'] = request.videoThumbnailProcess;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DownloadFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/download`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model FileAddPermissionRequest {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  memberList?: [
    FilePermissionMember
  ](name='member_list'),
}

model FileAddPermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function fileAddPermission(request: FileAddPermissionRequest): FileAddPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fileAddPermissionWithOptions(request, headers, runtime);
}

async function fileAddPermissionWithOptions(request: FileAddPermissionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FileAddPermissionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.memberList)) {
    body['member_list'] = request.memberList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FileAddPermission',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/add_permission`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model FileListPermissionRequest {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
}

model FileListPermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [
    FilePermissionMember
  ](name='body'),
}

async function fileListPermission(request: FileListPermissionRequest): FileListPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fileListPermissionWithOptions(request, headers, runtime);
}

async function fileListPermissionWithOptions(request: FileListPermissionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FileListPermissionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FileListPermission',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/list_permission`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

model FileRemovePermissionRequest {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  memberList?: [ 
    {
      identity?: Identity(name='identity'),
      roleId?: string(name='role_id'),
    }
  ](name='member_list'),
}

model FileRemovePermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function fileRemovePermission(request: FileRemovePermissionRequest): FileRemovePermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fileRemovePermissionWithOptions(request, headers, runtime);
}

async function fileRemovePermissionWithOptions(request: FileRemovePermissionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FileRemovePermissionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.memberList)) {
    body['member_list'] = request.memberList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FileRemovePermission',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/remove_permission`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetAsyncTaskRequest {
  asyncTaskId?: string(name='async_task_id'),
}

model GetAsyncTaskResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='Id of the request'),
  consumedProcess?: long(name='consumed_process'),
  errCode?: long(name='err_code'),
  message?: string(name='message'),
  status?: string(name='status'),
  totalProcess?: long(name='total_process'),
  url?: string(name='url'),
}

model GetAsyncTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAsyncTaskResponseBody(name='body'),
}

async function getAsyncTask(request: GetAsyncTaskRequest): GetAsyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAsyncTaskWithOptions(request, headers, runtime);
}

async function getAsyncTaskWithOptions(request: GetAsyncTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAsyncTaskResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.asyncTaskId)) {
    body['async_task_id'] = request.asyncTaskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetAsyncTask',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/async_task/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetDefaultDriveRequest {
  userId?: string(name='user_id'),
}

model GetDefaultDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Drive  
}

async function getDefaultDrive(request: GetDefaultDriveRequest): GetDefaultDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDefaultDriveWithOptions(request, headers, runtime);
}

async function getDefaultDriveWithOptions(request: GetDefaultDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDefaultDriveResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDefaultDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/get_default_drive`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetDownloadUrlRequest {
  driveId?: string(name='drive_id'),
  expireSec?: int32(name='expire_sec'),
  fileId?: string(name='file_id'),
  fileName?: string(name='file_name'),
}

model GetDownloadUrlResponseBody = {
  cdnUrl?: string(name='cdn_url'),
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  crc64Hash?: string(name='crc64_hash'),
  expiration?: string(name='expiration'),
  internalUrl?: string(name='internal_url'),
  size?: long(name='size'),
  url?: string(name='url', description='Id of the request'),
}

model GetDownloadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDownloadUrlResponseBody(name='body'),
}

async function getDownloadUrl(request: GetDownloadUrlRequest): GetDownloadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDownloadUrlWithOptions(request, headers, runtime);
}

async function getDownloadUrlWithOptions(request: GetDownloadUrlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDownloadUrlResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.expireSec)) {
    body['expire_sec'] = request.expireSec;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.fileName)) {
    body['file_name'] = request.fileName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDownloadUrl',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get_download_url`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetDriveRequest {
  driveId?: string(name='drive_id'),
}

model GetDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Drive  
}

async function getDrive(request: GetDriveRequest): GetDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDriveWithOptions(request, headers, runtime);
}

async function getDriveWithOptions(request: GetDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDriveResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetFileRequest {
  driveId?: string(name='drive_id'),
  fields?: string(name='fields'),
  fileId?: string(name='file_id'),
  urlExpireSec?: int32(name='url_expire_sec'),
}

model GetFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: File  
}

async function getFile(request: GetFileRequest): GetFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFileWithOptions(request, headers, runtime);
}

async function getFileWithOptions(request: GetFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFileResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.urlExpireSec)) {
    body['url_expire_sec'] = request.urlExpireSec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetGroupRequest {
  groupId?: string(name='group_id'),
}

model GetGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Group  
}

async function getGroup(request: GetGroupRequest): GetGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getGroupWithOptions(request, headers, runtime);
}

async function getGroupWithOptions(request: GetGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetGroupResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetGroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetLinkInfoRequest {
  extra?: string(name='extra'),
  identity?: string(name='identity'),
  type?: string(name='type'),
}

model GetLinkInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AccountLinkInfo  
}

async function getLinkInfo(request: GetLinkInfoRequest): GetLinkInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLinkInfoWithOptions(request, headers, runtime);
}

async function getLinkInfoWithOptions(request: GetLinkInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLinkInfoResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.extra)) {
    body['extra'] = request.extra;
  }
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetLinkInfo',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/account/get_link_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetLinkInfoByUserIdRequest {
  userId?: string(name='user_id'),
}

model GetLinkInfoByUserIdResponseBody = {
  items?: [
    AccountLinkInfo
  ](name='items', description='items'),
}

model GetLinkInfoByUserIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLinkInfoByUserIdResponseBody(name='body'),
}

async function getLinkInfoByUserId(request: GetLinkInfoByUserIdRequest): GetLinkInfoByUserIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLinkInfoByUserIdWithOptions(request, headers, runtime);
}

async function getLinkInfoByUserIdWithOptions(request: GetLinkInfoByUserIdRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLinkInfoByUserIdResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetLinkInfoByUserId',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/account/get_link_info_by_user_id`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetRevisionRequest {
  driveId?: string(name='drive_id'),
  fields?: string(name='fields'),
  fileId?: string(name='file_id'),
  revisionId?: string(name='revision_id'),
  urlExpireSec?: long(name='url_expire_sec'),
}

model GetRevisionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Revision  
}

async function getRevision(domainId: string, request: GetRevisionRequest): GetRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRevisionWithOptions(domainId, request, headers, runtime);
}

async function getRevisionWithOptions(domainId: string, request: GetRevisionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRevisionResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['domain_id'] = domainId;
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.revisionId)) {
    body['revision_id'] = request.revisionId;
  }
  if (!Util.isUnset(request.urlExpireSec)) {
    body['url_expire_sec'] = request.urlExpireSec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetRevision',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/revision/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetShareLinkRequest {
  shareId?: string(name='share_id'),
}

model GetShareLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ShareLink  
}

async function getShareLink(request: GetShareLinkRequest): GetShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getShareLinkWithOptions(request, headers, runtime);
}

async function getShareLinkWithOptions(request: GetShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetShareLinkByAnonymousRequest {
  shareId?: string(name='share_id'),
}

model GetShareLinkByAnonymousResponseBody = {
  accessCount?: long(name='access_count'),
  avatar?: string(name='avatar'),
  creatorId?: string(name='creator_id'),
  creatorName?: string(name='creator_name'),
  creatorPhone?: string(name='creator_phone'),
  disableDownload?: boolean(name='disable_download'),
  disablePreview?: boolean(name='disable_preview'),
  disableSave?: boolean(name='disable_save'),
  downloadCount?: long(name='download_count'),
  downloadLimit?: long(name='download_limit'),
  expiration?: string(name='expiration'),
  previewCount?: long(name='preview_count'),
  previewLimit?: long(name='preview_limit'),
  reportCount?: long(name='report_count'),
  saveCount?: long(name='save_count'),
  saveDownloadLimit?: long(name='save_download_limit'),
  saveLimit?: long(name='save_limit'),
  shareName?: string(name='share_name'),
  updatedAt?: string(name='updated_at'),
  videoPreviewCount?: long(name='video_preview_count'),
}

model GetShareLinkByAnonymousResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetShareLinkByAnonymousResponseBody(name='body'),
}

async function getShareLinkByAnonymous(request: GetShareLinkByAnonymousRequest): GetShareLinkByAnonymousResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getShareLinkByAnonymousWithOptions(request, headers, runtime);
}

async function getShareLinkByAnonymousWithOptions(request: GetShareLinkByAnonymousRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetShareLinkByAnonymousResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetShareLinkByAnonymous',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/get_by_anonymous`,
    method = 'POST',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetShareLinkTokenRequest {
  expireSec?: int32(name='expire_sec'),
  shareId?: string(name='share_id'),
  sharePwd?: string(name='share_pwd'),
}

model GetShareLinkTokenResponseBody = {
  expiresIn?: long(name='expires_in'),
  shareToken?: string(name='share_token', description='Id of the request'),
}

model GetShareLinkTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetShareLinkTokenResponseBody(name='body'),
}

async function getShareLinkToken(request: GetShareLinkTokenRequest): GetShareLinkTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getShareLinkTokenWithOptions(request, headers, runtime);
}

async function getShareLinkTokenWithOptions(request: GetShareLinkTokenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetShareLinkTokenResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.expireSec)) {
    body['expire_sec'] = request.expireSec;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.sharePwd)) {
    body['share_pwd'] = request.sharePwd;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetShareLinkToken',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/get_share_token`,
    method = 'POST',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetUploadUrlRequest {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  partInfoList?: [ 
    {
      parallelSha1Ctx?: {
        h?: [ long ](name='h'),
        partOffset?: long(name='part_offset'),
      }(name='parallel_sha1_ctx'),
      partNumber?: int32(name='part_number'),
    }
  ](name='part_info_list'),
  shareId?: string(name='share_id'),
  uploadId?: string(name='upload_id'),
}

model GetUploadUrlResponseBody = {
  createAt?: string(name='create_at'),
  domainId?: string(name='domain_id', description='Id of the request'),
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  partInfoList?: [
    UploadPartInfo
  ](name='part_info_list'),
  uploadId?: string(name='upload_id'),
}

model GetUploadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUploadUrlResponseBody(name='body'),
}

async function getUploadUrl(request: GetUploadUrlRequest): GetUploadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUploadUrlWithOptions(request, headers, runtime);
}

async function getUploadUrlWithOptions(request: GetUploadUrlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUploadUrlResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.partInfoList)) {
    body['part_info_list'] = request.partInfoList;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.uploadId)) {
    body['upload_id'] = request.uploadId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetUploadUrl',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get_upload_url`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetUserRequest {
  userId?: string(name='user_id'),
}

model GetUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: User  
}

async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUserWithOptions(request, headers, runtime);
}

async function getUserWithOptions(request: GetUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model GetVideoPreviewPlayInfoRequest {
  category?: string(name='category'),
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  getWithoutUrl?: string(name='get_without_url'),
  shareId?: string(name='share_id'),
  templateId?: string(name='template_id'),
}

model GetVideoPreviewPlayInfoResponseBody = {
  domainId?: string(name='domain_id'),
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  shareId?: string(name='share_id', description='Id of the request'),
  videoPreviewPlayInfo?: VideoPreviewPlayInfo(name='video_preview_play_info'),
}

model GetVideoPreviewPlayInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVideoPreviewPlayInfoResponseBody(name='body'),
}

async function getVideoPreviewPlayInfo(request: GetVideoPreviewPlayInfoRequest): GetVideoPreviewPlayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getVideoPreviewPlayInfoWithOptions(request, headers, runtime);
}

async function getVideoPreviewPlayInfoWithOptions(request: GetVideoPreviewPlayInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetVideoPreviewPlayInfoResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.category)) {
    body['category'] = request.category;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.getWithoutUrl)) {
    body['get_without_url'] = request.getWithoutUrl;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.templateId)) {
    body['template_id'] = request.templateId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetVideoPreviewPlayInfo',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get_video_preview_play_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ImportUserRequest {
  authenticationDisplayName?: string(name='authentication_display_name'),
  authenticationType?: string(name='authentication_type'),
  autoCreateDrive?: boolean(name='auto_create_drive'),
  driveTotalSize?: long(name='drive_total_size'),
  extra?: string(name='extra'),
  identity?: string(name='identity'),
  nickName?: string(name='nick_name'),
  parentGroupId?: string(name='parent_group_id'),
}

model ImportUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: User  
}

async function importUser(request: ImportUserRequest): ImportUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return importUserWithOptions(request, headers, runtime);
}

async function importUserWithOptions(request: ImportUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ImportUserResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.authenticationDisplayName)) {
    body['authentication_display_name'] = request.authenticationDisplayName;
  }
  if (!Util.isUnset(request.authenticationType)) {
    body['authentication_type'] = request.authenticationType;
  }
  if (!Util.isUnset(request.autoCreateDrive)) {
    body['auto_create_drive'] = request.autoCreateDrive;
  }
  if (!Util.isUnset(request.driveTotalSize)) {
    body['drive_total_size'] = request.driveTotalSize;
  }
  if (!Util.isUnset(request.extra)) {
    body['extra'] = request.extra;
  }
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }
  if (!Util.isUnset(request.nickName)) {
    body['nick_name'] = request.nickName;
  }
  if (!Util.isUnset(request.parentGroupId)) {
    body['parent_group_id'] = request.parentGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ImportUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/import`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model LinkAccountRequest {
  extra?: string(name='extra'),
  identity?: string(name='identity'),
  type?: string(name='type'),
  userId?: string(name='user_id'),
}

model LinkAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Token  
}

async function linkAccount(request: LinkAccountRequest): LinkAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return linkAccountWithOptions(request, headers, runtime);
}

async function linkAccountWithOptions(request: LinkAccountRequest, headers: map[string]string, runtime: Util.RuntimeOptions): LinkAccountResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.extra)) {
    body['extra'] = request.extra;
  }
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'LinkAccount',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/account/link`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListAddressGroupsRequest {
  driveId?: string(name='drive_id'),
  imageThumbnailProcess?: string(name='image_thumbnail_process'),
  limit?: int32(name='limit'),
  marker?: string(name='marker'),
  videoThumbnailProcess?: string(name='video_thumbnail_process'),
}

model ListAddressGroupsResponseBody = {
  items?: [
    AddressGroup
  ](name='items'),
  nextMarker?: string(name='next_marker'),
}

model ListAddressGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAddressGroupsResponseBody(name='body'),
}

async function listAddressGroups(request: ListAddressGroupsRequest): ListAddressGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAddressGroupsWithOptions(request, headers, runtime);
}

async function listAddressGroupsWithOptions(request: ListAddressGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAddressGroupsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    body['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.videoThumbnailProcess)) {
    body['video_thumbnail_process'] = request.videoThumbnailProcess;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAddressGroups',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/list_address_groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListDeltaRequest {
  cursor?: string(name='cursor', description='增量信息的起始游标'),
  driveId?: string(name='drive_id', description='云端Drive id'),
  limit?: int32(name='limit', description='获取增量信息的条数限制'),
  syncRootId?: string(name='sync_root_id', description='如果是同步目录的增量信息，必须设置同步目录对应的云端根目录'),
}

model ListDeltaResponseBody = {
  cursor?: string(name='cursor'),
  hasMore?: boolean(name='has_more'),
  items?: [ 
    {
      file?: File(name='file'),
      fileId?: string(name='file_id', description='文件唯一id'),
      op?: string(name='op', description='文件操作，主要包括'),
    }
  ](name='items'),
}

model ListDeltaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeltaResponseBody(name='body'),
}

async function listDelta(domainId: string, request: ListDeltaRequest): ListDeltaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeltaWithOptions(domainId, request, headers, runtime);
}

async function listDeltaWithOptions(domainId: string, request: ListDeltaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeltaResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['domain_id'] = domainId;
  var body : map[string]any= {};
  if (!Util.isUnset(request.cursor)) {
    body['cursor'] = request.cursor;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.syncRootId)) {
    body['sync_root_id'] = request.syncRootId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDelta',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/list_delta`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListDriveRequest {
  limit?: int32(name='limit'),
  marker?: string(name='marker'),
  owner?: string(name='owner'),
  ownerType?: string(name='owner_type'),
}

model ListDriveResponseBody = {
  items?: [
    Drive
  ](name='items'),
  nextMarker?: string(name='next_marker'),
}

model ListDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDriveResponseBody(name='body'),
}

async function listDrive(request: ListDriveRequest): ListDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDriveWithOptions(request, headers, runtime);
}

async function listDriveWithOptions(request: ListDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDriveResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.owner)) {
    body['owner'] = request.owner;
  }
  if (!Util.isUnset(request.ownerType)) {
    body['owner_type'] = request.ownerType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListFacegroupsRequest {
  driveId?: string(name='drive_id'),
  limit?: int32(name='limit'),
  marker?: string(name='marker'),
  remarks?: string(name='remarks'),
}

model ListFacegroupsResponseBody = {
  items?: [
    FaceGroup
  ](name='items'),
  nextMarker?: string(name='next_marker'),
}

model ListFacegroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFacegroupsResponseBody(name='body'),
}

async function listFacegroups(request: ListFacegroupsRequest): ListFacegroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFacegroupsWithOptions(request, headers, runtime);
}

async function listFacegroupsWithOptions(request: ListFacegroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFacegroupsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.remarks)) {
    body['remarks'] = request.remarks;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFacegroups',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/list_facegroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListFileRequest {
  category?: string(name='category'),
  driveId?: string(name='drive_id'),
  fields?: string(name='fields'),
  limit?: int32(name='limit'),
  marker?: string(name='marker'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  parentFileId?: string(name='parent_file_id'),
  status?: string(name='status'),
  type?: string(name='type'),
}

model ListFileResponseBody = {
  items?: [
    File
  ](name='items'),
  nextMarker?: string(name='next_marker'),
}

model ListFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFileResponseBody(name='body'),
}

async function listFile(request: ListFileRequest): ListFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFileWithOptions(request, headers, runtime);
}

async function listFileWithOptions(request: ListFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFileResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.category)) {
    body['category'] = request.category;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.orderBy)) {
    body['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    body['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.parentFileId)) {
    body['parent_file_id'] = request.parentFileId;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListGroupRequest {
  limit?: string(name='limit'),
  marker?: string(name='marker'),
}

model ListGroupResponseBody = {
  items?: [
    Group
  ](name='items'),
  nextMarker?: string(name='next_marker'),
}

model ListGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupResponseBody(name='body'),
}

async function listGroup(request: ListGroupRequest): ListGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupWithOptions(request, headers, runtime);
}

async function listGroupWithOptions(request: ListGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListGroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListMyDrivesRequest {
  limit?: int32(name='limit'),
  marker?: string(name='marker'),
}

model ListMyDrivesResponseBody = {
  items?: [
    Drive
  ](name='items'),
  nextMarker?: string(name='next_marker'),
}

model ListMyDrivesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMyDrivesResponseBody(name='body'),
}

async function listMyDrives(request: ListMyDrivesRequest): ListMyDrivesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMyDrivesWithOptions(request, headers, runtime);
}

async function listMyDrivesWithOptions(request: ListMyDrivesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMyDrivesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMyDrives',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/list_my_drives`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListRecyclebinRequest {
  driveId?: string(name='drive_id'),
  fields?: string(name='fields'),
  limit?: int32(name='limit'),
  marker?: string(name='marker'),
}

model ListRecyclebinResponseBody = {
  items?: [
    File
  ](name='items'),
  nextMarker?: string(name='next_marker'),
}

model ListRecyclebinResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRecyclebinResponseBody(name='body'),
}

async function listRecyclebin(request: ListRecyclebinRequest): ListRecyclebinResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRecyclebinWithOptions(request, headers, runtime);
}

async function listRecyclebinWithOptions(request: ListRecyclebinRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRecyclebinResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListRecyclebin',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/recyclebin/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListRevisionRequest {
  driveId?: string(name='drive_id'),
  fields?: string(name='fields'),
  fileId?: string(name='file_id'),
  limit?: long(name='limit'),
  marker?: string(name='marker'),
}

model ListRevisionResponseBody = {
  items?: [
    Revision
  ](name='items'),
  nextMarker?: string(name='next_marker'),
}

model ListRevisionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRevisionResponseBody(name='body'),
}

async function listRevision(domainId: string, request: ListRevisionRequest): ListRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRevisionWithOptions(domainId, request, headers, runtime);
}

async function listRevisionWithOptions(domainId: string, request: ListRevisionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRevisionResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['domain_id'] = domainId;
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListRevision',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/revision/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListShareLinkRequest {
  creator?: string(name='creator'),
  includeCancelled?: boolean(name='include_cancelled'),
  limit?: int32(name='limit'),
  marker?: string(name='marker'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
}

model ListShareLinkResponseBody = {
  items?: [
    ShareLink
  ](name='items'),
  nextMarker?: string(name='next_marker'),
}

model ListShareLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListShareLinkResponseBody(name='body'),
}

async function listShareLink(request: ListShareLinkRequest): ListShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listShareLinkWithOptions(request, headers, runtime);
}

async function listShareLinkWithOptions(request: ListShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.creator)) {
    body['creator'] = request.creator;
  }
  if (!Util.isUnset(request.includeCancelled)) {
    body['include_cancelled'] = request.includeCancelled;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.orderBy)) {
    body['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    body['order_direction'] = request.orderDirection;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListTagsRequest {
  driveId?: string(name='drive_id'),
  imageThumbnailProcess?: string(name='image_thumbnail_process'),
  videoThumbnailProcess?: string(name='video_thumbnail_process'),
}

model ListTagsResponseBody = {
  tags?: [
    ImageTag
  ](name='tags'),
}

model ListTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagsResponseBody(name='body'),
}

async function listTags(request: ListTagsRequest): ListTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagsWithOptions(request, headers, runtime);
}

async function listTagsWithOptions(request: ListTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    body['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.videoThumbnailProcess)) {
    body['video_thumbnail_process'] = request.videoThumbnailProcess;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListTags',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/list_tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListUploadedPartsRequest {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  limit?: int32(name='limit'),
  partNumberMarker?: int32(name='part_number_marker'),
  shareId?: string(name='share_id'),
  uploadId?: string(name='upload_id'),
}

model ListUploadedPartsResponseBody = {
  fileId?: string(name='file_id', description='Id of the request'),
  nextPartNumberMarker?: string(name='next_part_number_marker'),
  parallelUpload?: boolean(name='parallel_upload'),
  uploadId?: string(name='upload_id'),
  uploadedParts?: [
    UploadPartInfo
  ](name='uploaded_parts'),
}

model ListUploadedPartsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUploadedPartsResponseBody(name='body'),
}

async function listUploadedParts(request: ListUploadedPartsRequest): ListUploadedPartsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUploadedPartsWithOptions(request, headers, runtime);
}

async function listUploadedPartsWithOptions(request: ListUploadedPartsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListUploadedPartsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.partNumberMarker)) {
    body['part_number_marker'] = request.partNumberMarker;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.uploadId)) {
    body['upload_id'] = request.uploadId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListUploadedParts',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/list_uploaded_parts`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ListUserRequest {
  limit?: int32(name='limit'),
  marker?: string(name='marker'),
}

model ListUserResponseBody = {
  items?: [
    User
  ](name='items'),
  nextMarker?: string(name='next_marker', description='Id of the request'),
}

model ListUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserResponseBody(name='body'),
}

async function listUser(request: ListUserRequest): ListUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUserWithOptions(request, headers, runtime);
}

async function listUserWithOptions(request: ListUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListUserResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model LiveTranscodeForGetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function liveTranscodeForGet(objectPath: string): LiveTranscodeForGetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return liveTranscodeForGetWithOptions(objectPath, headers, runtime);
}

async function liveTranscodeForGetWithOptions(objectPath: string, headers: map[string]string, runtime: Util.RuntimeOptions): LiveTranscodeForGetResponse {
  objectPath = OpenApiUtil.getEncodeParam(objectPath);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'LiveTranscodeForGet',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/live_transcode_for_get/*object_path`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model MoveFileRequest {
  checkNameMode?: string(name='check_name_mode'),
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  toParentFileId?: string(name='to_parent_file_id'),
}

model MoveFileResponseBody = {
  asyncTaskId?: string(name='async_task_id'),
  domainId?: string(name='domain_id', description='Id of the request'),
  driveId?: string(name='drive_id'),
  exist?: boolean(name='exist'),
  fileId?: string(name='file_id'),
}

model MoveFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MoveFileResponseBody(name='body'),
}

async function moveFile(request: MoveFileRequest): MoveFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return moveFileWithOptions(request, headers, runtime);
}

async function moveFileWithOptions(request: MoveFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MoveFileResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.checkNameMode)) {
    body['check_name_mode'] = request.checkNameMode;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.toParentFileId)) {
    body['to_parent_file_id'] = request.toParentFileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'MoveFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/move`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ParseKeywordsRequest {
  keywords?: string(name='keywords', description='需要进行语意解析的关键词'),
}

model ParseKeywordsResponseBody = {
  addressLine?: string(name='address_line', description='地点详细信息'),
  tags?: [
    SystemTag
  ](name='tags'),
  timeRange?: {
    end?: string(name='end', description='结束时间'),
    start?: string(name='start', description='起始时间'),
  }(name='time_range'),
}

model ParseKeywordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ParseKeywordsResponseBody(name='body'),
}

async function parseKeywords(request: ParseKeywordsRequest): ParseKeywordsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return parseKeywordsWithOptions(request, headers, runtime);
}

async function parseKeywordsWithOptions(request: ParseKeywordsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ParseKeywordsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.keywords)) {
    body['keywords'] = request.keywords;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ParseKeywords',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/parse_keywords`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model RemoveFaceGroupFileRequest {
  driveId?: string(name='drive_id'),
  faceGroupId?: string(name='face_group_id'),
  fileId?: string(name='file_id'),
}

model RemoveFaceGroupFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function removeFaceGroupFile(request: RemoveFaceGroupFileRequest): RemoveFaceGroupFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeFaceGroupFileWithOptions(request, headers, runtime);
}

async function removeFaceGroupFileWithOptions(request: RemoveFaceGroupFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveFaceGroupFileResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.faceGroupId)) {
    body['face_group_id'] = request.faceGroupId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveFaceGroupFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/albums/unassign_facegroup_item`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model RestoreFileRequest {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
}

model RestoreFileResponseBody = {
  asyncTaskId?: string(name='async_task_id'),
  domainId?: string(name='domain_id', description='Id of the request'),
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
}

model RestoreFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestoreFileResponseBody(name='body'),
}

async function restoreFile(request: RestoreFileRequest): RestoreFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restoreFileWithOptions(request, headers, runtime);
}

async function restoreFileWithOptions(request: RestoreFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestoreFileResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RestoreFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/recyclebin/restore`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model RestoreRevisionRequest {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  revisionId?: string(name='revision_id'),
}

model RestoreRevisionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Revision  
}

async function restoreRevision(domainId: string, request: RestoreRevisionRequest): RestoreRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restoreRevisionWithOptions(domainId, request, headers, runtime);
}

async function restoreRevisionWithOptions(domainId: string, request: RestoreRevisionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestoreRevisionResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['domain_id'] = domainId;
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.revisionId)) {
    body['revision_id'] = request.revisionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RestoreRevision',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/revision/restore`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model ScanFileRequest {
  driveId?: string(name='drive_id'),
  fields?: string(name='fields', description='scan file 想要获取的文件属性，
1. 如果想要获取所有属性使用‘*’，
 2.不传默认返回以下属性：
      file_id, drive_id, parent_file_id, type,
      created_at, updated_at, file_extention, size, starred, status,deleting, category, permissions
   3 用户也可以指定属性进行返回，多个属性之间用，隔开'),
  limit?: int32(name='limit'),
  marker?: string(name='marker'),
}

model ScanFileResponseBody = {
  items?: [
    File
  ](name='items'),
  nextMarker?: string(name='next_marker'),
}

model ScanFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScanFileResponseBody(name='body'),
}

async function scanFile(request: ScanFileRequest): ScanFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scanFileWithOptions(request, headers, runtime);
}

async function scanFileWithOptions(request: ScanFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScanFileResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ScanFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2//file/scan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model SearchAddressGroupsRequest {
  addressLevel?: string(name='address_level'),
  addressNames?: [ string ](name='address_names'),
  brGeoPoint?: string(name='br_geo_point'),
  driveId?: string(name='drive_id'),
  imageThumbnailProcess?: string(name='image_thumbnail_process'),
  tlGeoPoint?: string(name='tl_geo_point'),
  videoThumbnailProcess?: string(name='video_thumbnail_process'),
}

model SearchAddressGroupsResponseBody = {
  items?: [
    AddressGroup
  ](name='items'),
}

model SearchAddressGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchAddressGroupsResponseBody(name='body'),
}

async function searchAddressGroups(request: SearchAddressGroupsRequest): SearchAddressGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchAddressGroupsWithOptions(request, headers, runtime);
}

async function searchAddressGroupsWithOptions(request: SearchAddressGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchAddressGroupsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.addressLevel)) {
    body['address_level'] = request.addressLevel;
  }
  if (!Util.isUnset(request.addressNames)) {
    body['address_names'] = request.addressNames;
  }
  if (!Util.isUnset(request.brGeoPoint)) {
    body['br_geo_point'] = request.brGeoPoint;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    body['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.tlGeoPoint)) {
    body['tl_geo_point'] = request.tlGeoPoint;
  }
  if (!Util.isUnset(request.videoThumbnailProcess)) {
    body['video_thumbnail_process'] = request.videoThumbnailProcess;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchAddressGroups',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/search_address_groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model SearchDriveRequest {
  driveName?: string(name='drive_name'),
  limit?: int32(name='limit'),
  marker?: string(name='marker'),
  owner?: string(name='owner'),
  ownerType?: string(name='owner_type'),
}

model SearchDriveResponseBody = {
  items?: [
    Drive
  ](name='items'),
  nextMarker?: string(name='next_marker'),
}

model SearchDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchDriveResponseBody(name='body'),
}

async function searchDrive(request: SearchDriveRequest): SearchDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchDriveWithOptions(request, headers, runtime);
}

async function searchDriveWithOptions(request: SearchDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchDriveResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveName)) {
    body['drive_name'] = request.driveName;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.owner)) {
    body['owner'] = request.owner;
  }
  if (!Util.isUnset(request.ownerType)) {
    body['owner_type'] = request.ownerType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model SearchFileRequest {
  driveId?: string(name='drive_id'),
  limit?: int32(name='limit'),
  marker?: string(name='marker'),
  orderBy?: string(name='order_by'),
  query?: string(name='query'),
  returnTotalCount?: boolean(name='return_total_count'),
}

model SearchFileResponseBody = {
  items?: [
    File
  ](name='items'),
  nextMarker?: string(name='next_marker'),
  totalCount?: long(name='total_count'),
}

model SearchFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchFileResponseBody(name='body'),
}

async function searchFile(request: SearchFileRequest): SearchFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchFileWithOptions(request, headers, runtime);
}

async function searchFileWithOptions(request: SearchFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchFileResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.orderBy)) {
    body['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.query)) {
    body['query'] = request.query;
  }
  if (!Util.isUnset(request.returnTotalCount)) {
    body['return_total_count'] = request.returnTotalCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model SearchShareLinkRequest {
  creators?: [ string ](name='creators'),
  limit?: int32(name='limit'),
  marker?: string(name='marker'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  query?: string(name='query'),
  returnTotalCount?: boolean(name='return_total_count'),
}

model SearchShareLinkResponseBody = {
  items?: [
    ShareLink
  ](name='items'),
  nextMarker?: string(name='next_marker'),
  totalCount?: long(name='total_count'),
}

model SearchShareLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchShareLinkResponseBody(name='body'),
}

async function searchShareLink(request: SearchShareLinkRequest): SearchShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchShareLinkWithOptions(request, headers, runtime);
}

async function searchShareLinkWithOptions(request: SearchShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.creators)) {
    body['creators'] = request.creators;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.orderBy)) {
    body['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    body['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.query)) {
    body['query'] = request.query;
  }
  if (!Util.isUnset(request.returnTotalCount)) {
    body['return_total_count'] = request.returnTotalCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model SearchUserRequest {
  email?: string(name='email'),
  limit?: int32(name='limit'),
  marker?: string(name='marker'),
  nickName?: string(name='nick_name'),
  nickNameForFuzzy?: string(name='nick_name_for_fuzzy'),
  phone?: string(name='phone'),
  role?: string(name='role'),
  status?: string(name='status'),
  userName?: string(name='user_name'),
}

model SearchUserResponseBody = {
  items?: [
    User
  ](name='items'),
  nextMarker?: string(name='next_marker', description='Id of the request'),
}

model SearchUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchUserResponseBody(name='body'),
}

async function searchUser(request: SearchUserRequest): SearchUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchUserWithOptions(request, headers, runtime);
}

async function searchUserWithOptions(request: SearchUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchUserResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.email)) {
    body['email'] = request.email;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.nickName)) {
    body['nick_name'] = request.nickName;
  }
  if (!Util.isUnset(request.nickNameForFuzzy)) {
    body['nick_name_for_fuzzy'] = request.nickNameForFuzzy;
  }
  if (!Util.isUnset(request.phone)) {
    body['phone'] = request.phone;
  }
  if (!Util.isUnset(request.role)) {
    body['role'] = request.role;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.userName)) {
    body['user_name'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model TokenRequest {
  assertion?: string(name='assertion'),
  clientId?: string(name='client_id'),
  clientSecret?: string(name='client_secret'),
  code?: string(name='code'),
  grantType?: string(name='grant_type'),
  redirectUri?: string(name='redirect_uri'),
  refreshToken?: string(name='refresh_token'),
}

model TokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Token  
}

async function token(request: TokenRequest): TokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tokenWithOptions(request, headers, runtime);
}

async function tokenWithOptions(request: TokenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TokenResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.assertion)) {
    body['assertion'] = request.assertion;
  }
  if (!Util.isUnset(request.clientId)) {
    body['client_id'] = request.clientId;
  }
  if (!Util.isUnset(request.clientSecret)) {
    body['client_secret'] = request.clientSecret;
  }
  if (!Util.isUnset(request.code)) {
    body['code'] = request.code;
  }
  if (!Util.isUnset(request.grantType)) {
    body['grant_type'] = request.grantType;
  }
  if (!Util.isUnset(request.redirectUri)) {
    body['redirect_uri'] = request.redirectUri;
  }
  if (!Util.isUnset(request.refreshToken)) {
    body['refresh_token'] = request.refreshToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'Token',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/oauth/token`,
    method = 'POST',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model TrashFileRequest {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
}

model TrashFileResponseBody = {
  asyncTaskId?: string(name='async_task_id'),
  domainId?: string(name='domain_id', description='Id of the request'),
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
}

model TrashFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TrashFileResponseBody(name='body'),
}

async function trashFile(request: TrashFileRequest): TrashFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return trashFileWithOptions(request, headers, runtime);
}

async function trashFileWithOptions(request: TrashFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TrashFileResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TrashFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/recyclebin/trash`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model UpdateDriveRequest {
  description?: string(name='description'),
  driveId?: string(name='drive_id'),
  driveName?: string(name='drive_name'),
  status?: string(name='status'),
  totalSize?: long(name='total_size'),
}

model UpdateDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Drive  
}

async function updateDrive(request: UpdateDriveRequest): UpdateDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDriveWithOptions(request, headers, runtime);
}

async function updateDriveWithOptions(request: UpdateDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDriveResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.driveName)) {
    body['drive_name'] = request.driveName;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.totalSize)) {
    body['total_size'] = request.totalSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model UpdateFacegroupRequest {
  driveId?: string(name='drive_id'),
  groupCoverFaceId?: string(name='group_cover_face_id'),
  groupId?: string(name='group_id'),
  groupName?: string(name='group_name'),
  remarks?: string(name='remarks'),
}

model UpdateFacegroupResponseBody = {
  driveId?: string(name='drive_id', description='Id of the request'),
  groupId?: string(name='group_id'),
}

model UpdateFacegroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFacegroupResponseBody(name='body'),
}

async function updateFacegroup(request: UpdateFacegroupRequest): UpdateFacegroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFacegroupWithOptions(request, headers, runtime);
}

async function updateFacegroupWithOptions(request: UpdateFacegroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFacegroupResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.groupCoverFaceId)) {
    body['group_cover_face_id'] = request.groupCoverFaceId;
  }
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    body['group_name'] = request.groupName;
  }
  if (!Util.isUnset(request.remarks)) {
    body['remarks'] = request.remarks;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFacegroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/update_facegroup_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model UpdateFileRequest {
  checkNameMode?: string(name='check_name_mode'),
  description?: string(name='description'),
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  hidden?: boolean(name='hidden'),
  labels?: [ string ](name='labels'),
  localModifiedAt?: string(name='local_modified_at'),
  name?: string(name='name'),
  starred?: boolean(name='starred'),
}

model UpdateFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: File  
}

async function updateFile(request: UpdateFileRequest): UpdateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFileWithOptions(request, headers, runtime);
}

async function updateFileWithOptions(request: UpdateFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFileResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.checkNameMode)) {
    body['check_name_mode'] = request.checkNameMode;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.hidden)) {
    body['hidden'] = request.hidden;
  }
  if (!Util.isUnset(request.labels)) {
    body['labels'] = request.labels;
  }
  if (!Util.isUnset(request.localModifiedAt)) {
    body['local_modified_at'] = request.localModifiedAt;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.starred)) {
    body['starred'] = request.starred;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model UpdateGroupRequest {
  description?: string(name='description'),
  groupId?: string(name='group_id'),
  groupName?: string(name='group_name'),
}

model UpdateGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Group  
}

async function updateGroup(request: UpdateGroupRequest): UpdateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateGroupWithOptions(request, headers, runtime);
}

async function updateGroupWithOptions(request: UpdateGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateGroupResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    body['group_name'] = request.groupName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model UpdateRevisionRequest {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  keepForever?: boolean(name='keep_forever'),
  revisionDescription?: string(name='revision_description'),
  revisionId?: string(name='revision_id'),
}

model UpdateRevisionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Revision  
}

async function updateRevision(domainId: string, request: UpdateRevisionRequest): UpdateRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRevisionWithOptions(domainId, request, headers, runtime);
}

async function updateRevisionWithOptions(domainId: string, request: UpdateRevisionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRevisionResponse {
  Util.validateModel(request);
  var hostMap : map[string]string = {};
  hostMap['domain_id'] = domainId;
  var body : map[string]any= {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.keepForever)) {
    body['keep_forever'] = request.keepForever;
  }
  if (!Util.isUnset(request.revisionDescription)) {
    body['revision_description'] = request.revisionDescription;
  }
  if (!Util.isUnset(request.revisionId)) {
    body['revision_id'] = request.revisionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    hostMap = hostMap,
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRevision',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/revision/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model UpdateShareLinkRequest {
  description?: string(name='description'),
  disableDownload?: boolean(name='disable_download'),
  disablePreview?: boolean(name='disable_preview'),
  disableSave?: boolean(name='disable_save'),
  downloadCount?: long(name='download_count'),
  downloadLimit?: long(name='download_limit'),
  expiration?: string(name='expiration'),
  previewCount?: long(name='preview_count'),
  previewLimit?: long(name='preview_limit'),
  reportCount?: long(name='report_count'),
  saveCount?: long(name='save_count'),
  saveLimit?: long(name='save_limit'),
  shareId?: string(name='share_id'),
  shareName?: string(name='share_name'),
  sharePwd?: string(name='share_pwd'),
  status?: string(name='status'),
  videoPreviewCount?: long(name='video_preview_count'),
}

model UpdateShareLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ShareLink  
}

async function updateShareLink(request: UpdateShareLinkRequest): UpdateShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateShareLinkWithOptions(request, headers, runtime);
}

async function updateShareLinkWithOptions(request: UpdateShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.disableDownload)) {
    body['disable_download'] = request.disableDownload;
  }
  if (!Util.isUnset(request.disablePreview)) {
    body['disable_preview'] = request.disablePreview;
  }
  if (!Util.isUnset(request.disableSave)) {
    body['disable_save'] = request.disableSave;
  }
  if (!Util.isUnset(request.downloadCount)) {
    body['download_count'] = request.downloadCount;
  }
  if (!Util.isUnset(request.downloadLimit)) {
    body['download_limit'] = request.downloadLimit;
  }
  if (!Util.isUnset(request.expiration)) {
    body['expiration'] = request.expiration;
  }
  if (!Util.isUnset(request.previewCount)) {
    body['preview_count'] = request.previewCount;
  }
  if (!Util.isUnset(request.previewLimit)) {
    body['preview_limit'] = request.previewLimit;
  }
  if (!Util.isUnset(request.reportCount)) {
    body['report_count'] = request.reportCount;
  }
  if (!Util.isUnset(request.saveCount)) {
    body['save_count'] = request.saveCount;
  }
  if (!Util.isUnset(request.saveLimit)) {
    body['save_limit'] = request.saveLimit;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.shareName)) {
    body['share_name'] = request.shareName;
  }
  if (!Util.isUnset(request.sharePwd)) {
    body['share_pwd'] = request.sharePwd;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.videoPreviewCount)) {
    body['video_preview_count'] = request.videoPreviewCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

model UpdateUserRequest {
  avatar?: string(name='avatar'),
  description?: string(name='description'),
  email?: string(name='email'),
  groupInfoList?: [ 
    {
      groupId?: string(name='group_id'),
    }
  ](name='group_info_list'),
  nickName?: string(name='nick_name'),
  phone?: string(name='phone'),
  role?: string(name='role'),
  status?: string(name='status'),
  userData?: map[string]string(name='user_data'),
  userId?: string(name='user_id'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: User  
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateUserWithOptions(request, headers, runtime);
}

async function updateUserWithOptions(request: UpdateUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.avatar)) {
    body['avatar'] = request.avatar;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.email)) {
    body['email'] = request.email;
  }
  if (!Util.isUnset(request.groupInfoList)) {
    body['group_info_list'] = request.groupInfoList;
  }
  if (!Util.isUnset(request.nickName)) {
    body['nick_name'] = request.nickName;
  }
  if (!Util.isUnset(request.phone)) {
    body['phone'] = request.phone;
  }
  if (!Util.isUnset(request.role)) {
    body['role'] = request.role;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.userData)) {
    body['user_data'] = request.userData;
  }
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

