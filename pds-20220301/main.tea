/**
 *
 */
import Util;
import SPI;
import GatewayClient;
import OpenApi;
import OpenApiUtil;

extends OpenApi;

type @client = SPI

init(config: OpenApi.Config){
  super(config);
  @client = new GatewayClient();
  @spi = @client;
  @signatureAlgorithm = 'v2';
  @endpointRule = '';
  }

model AccountAccessTokenResponse {
  accessToken?: string(name='access_token'),
  avatar?: string(name='avatar'),
  defaultDriveId?: string(name='default_drive_id'),
  defaultSboxDriveId?: string(name='default_sbox_drive_id'),
  deviceId?: string(name='device_id'),
  deviceName?: string(name='device_name'),
  domainId?: string(name='domain_id'),
  existLink?: [
    LinkInfo
  ](name='exist_link'),
  expireTime?: string(name='expire_time'),
  expiresIn?: long(name='expires_in'),
  isFirstLogin?: boolean(name='is_first_login'),
  needLink?: boolean(name='need_link'),
  needRpVerify?: boolean(name='need_rp_verify'),
  nickName?: string(name='nick_name'),
  pathStatus?: string(name='path_status'),
  pinSetup?: boolean(name='pin_setup'),
  refreshToken?: string(name='refresh_token'),
  role?: string(name='role'),
  state?: string(name='state'),
  status?: string(name='status'),
  tokenType?: string(name='token_type'),
  userData?: map[string]string(name='user_data'),
  userId?: string(name='user_id'),
  userName?: string(name='user_name'),
}

model AccountLinkInfo {
  authenticationType?: string(name='authentication_type'),
  createdAt?: long(name='created_at'),
  displayName?: string(name='display_name'),
  domainId?: string(name='domain_id'),
  extra?: string(name='extra'),
  identity?: string(name='identity'),
  userId?: string(name='user_id'),
}

model Activity {
  activityId?: string(name='activity_id'),
  device?: string(name='device'),
  driveId?: string(name='drive_id'),
  eventType?: int32(name='event_type'),
  latestEventTime?: string(name='latest_event_time'),
  resourceCategory?: int32(name='resource_category'),
  resourceList?: [  map[string]any ](name='resource_list'),
  totalResourceCount?: long(name='total_resource_count'),
  userId?: string(name='user_id'),
}

model Address {
  city?: string(name='city'),
  country?: string(name='country'),
  district?: string(name='district'),
  province?: string(name='province'),
  township?: string(name='township'),
}

model AddressGroup {
  addressDetail?: Address(name='address_detail'),
  count?: long(name='count'),
  coverFileId?: string(name='cover_file_id'),
  coverUrl?: string(name='cover_url'),
  location?: string(name='location'),
  name?: string(name='name'),
}

model Aggregation {
  field?: bytes(name='field'),
  groups?: [
    AggregationsGroup
  ](name='groups'),
  operation?: bytes(name='operation'),
  value?: double(name='value'),
}

model AggregationsGroup {
  count?: long(name='count'),
  value?: bytes(name='value'),
}

model App {
  appId?: string(name='app_id'),
  appName?: string(name='app_name'),
  appSecret?: string(name='app_secret'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  logo?: string(name='logo'),
  provider?: string(name='provider'),
  redirectUri?: string(name='redirect_uri'),
  scope?: [ string ](name='scope'),
  stage?: string(name='stage'),
  type?: string(name='type'),
  updatedAt?: string(name='updated_at'),
}

model AppAccessStrategy {
  effect?: string(name='effect'),
  exceptAppIdList?: [ string ](name='except_app_id_list'),
}

model ArchiveFilesConfig {
  enable?: boolean(name='enable'),
  version?: string(name='version'),
}

model ArchiveFilesConfigResponse {
  enabled?: boolean(name='enabled'),
  version?: string(name='version'),
}

model AsyncTask {
  asyncTaskId?: string(name='async_task_id'),
  category?: string(name='category'),
  consumedProcess?: long(name='consumed_process'),
  createdAt?: string(name='created_at'),
  errorCode?: string(name='error_code'),
  errorMessage?: string(name='error_message'),
  finishedAt?: string(name='finished_at'),
  startedAt?: string(name='started_at'),
  state?: string(name='state'),
  taskType?: string(name='task_type'),
  totalProcess?: long(name='total_process'),
  userId?: string(name='user_id'),
}

model AudioPreviewPlayInfo {
  meta?: {
    duration?: double(name='duration'),
  }(name='meta'),
  offlineAudioList?: [ 
    {
      status?: string(name='status'),
      templateId?: string(name='template_id'),
      url?: string(name='url'),
    }
  ](name='offline_audio_list'),
}

model AuditLog {
  actedAt?: string(name='acted_at'),
  actionCategory?: string(name='action_category'),
  actionType?: string(name='action_type'),
  actorId?: string(name='actor_id'),
  actorName?: string(name='actor_name'),
  actorType?: string(name='actor_type'),
  clientDevice?: string(name='client_device'),
  clientIp?: string(name='client_ip'),
  clientType?: string(name='client_type'),
  clientVersion?: string(name='client_version'),
  detail?: AuditLogDetail(name='detail'),
  filePathType?: string(name='file_path_type'),
  logId?: string(name='log_id'),
  objectId?: string(name='object_id'),
  objectName?: string(name='object_name'),
}

model AuditLogDetail {
  driveLogDetail?: DriveLogDetail(name='drive_log_detail'),
  fileLogDetail?: FileLogDetail(name='file_log_detail'),
  userLogDetail?: UserLogDetail(name='user_log_detail'),
}

model AuthenticationInfo {
  authenticationDisplayName?: string(name='authentication_display_name'),
  authenticationType?: string(name='authentication_type'),
  extra?: string(name='extra'),
  identity?: string(name='identity'),
}

model BaseAssignmentResponse {
  associatedRoleTagId?: string(name='associated_role_tag_id'),
  createdAt?: string(name='created_at'),
  creator?: string(name='creator'),
  disinheritSubGroup?: boolean(name='disinherit_sub_group'),
  domainId?: string(name='domain_id'),
  identity?: Identity(name='identity'),
  manageResourceId?: string(name='manage_resource_id'),
  manageResourceType?: string(name='manage_resource_type'),
  roleId?: string(name='role_id'),
  updatedAt?: string(name='updated_at'),
}

model BaseDomainResponse {
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  domainName?: string(name='domain_name'),
  initDriveEnable?: boolean(name='init_drive_enable'),
  initDriveSize?: long(name='init_drive_size'),
  parentDomainId?: string(name='parent_domain_id'),
  publishedAppAccessStrategy?: AppAccessStrategy(name='published_app_access_strategy'),
  shareLinkEnabled?: boolean(name='share_link_enabled'),
  sizeQuota?: long(name='size_quota'),
  sizeQuotaUsed?: long(name='size_quota_used'),
  status?: long(name='status'),
  updatedAt?: string(name='updated_at'),
  usedSize?: long(name='used_size'),
}

model BaseDriveResponse {
  actionList?: [ string ](name='action_list'),
  category?: string(name='category'),
  createdAt?: string(name='created_at'),
  creator?: string(name='creator', example='ccp'),
  deltaEnabled?: boolean(name='delta_enabled'),
  description?: string(name='description', example='ccp team drive'),
  domainId?: string(name='domain_id', example='hz999'),
  driveId?: string(name='drive_id', example='123'),
  driveName?: string(name='drive_name', example='ccpdrive'),
  driveType?: string(name='drive_type', example='normal'),
  encryptDataAccess?: boolean(name='encrypt_data_access'),
  encryptMode?: string(name='encrypt_mode'),
  isHandover?: boolean(name='is_handover'),
  owner?: string(name='owner', example='ccp'),
  ownerType?: string(name='owner_type', example='user'),
  pathStatus?: string(name='path_status'),
  permission?: map[string]IDPermission(name='permission'),
  relativePath?: string(name='relative_path'),
  status?: string(name='status', example='enabled'),
  storeId?: string(name='store_id', example='123'),
  totalSize?: long(name='total_size', example='102400'),
  updatedAt?: string(name='updated_at'),
  usedSize?: long(name='used_size', example='1024'),
}

model BaseGroupResponse {
  createdAt?: long(name='created_at', example='111111'),
  creator?: string(name='creator', example='system'),
  description?: string(name='description', example='desc-111'),
  domainId?: string(name='domain_id', example='bj123'),
  groupId?: string(name='group_id', example='b38b5681bd964950ad8bc0f8ea504793'),
  groupName?: string(name='group_name', example='name-111'),
  isSync?: boolean(name='is_sync'),
  permission?: map[string]IDPermission(name='permission'),
  updatedAt?: string(name='updated_at', example='111111'),
}

model BasePunishLogResponse {
  errorCode?: string(name='error_code'),
  errorMessage?: string(name='error_message'),
  punishedAt?: string(name='punished_at'),
  punishee?: {
    contentHash?: {
      hashHexStr?: string(name='hash_hex_str'),
      hashName?: string(name='hash_name'),
      size?: long(name='size'),
    }(name='content_hash'),
    driveId?: string(name='drive_id'),
    faceGroupId?: string(name='face_group_id'),
    fileId?: string(name='file_id'),
    revisionId?: string(name='revision_id'),
    shareId?: string(name='share_id'),
    userId?: string(name='user_id'),
  }(name='punishee'),
  punishmentDetail?: {
    actionCode?: string(name='action_code'),
    investigationStatus?: long(name='investigation_status'),
    method?: string(name='method'),
    punishReason?: string(name='punish_reason'),
    punishments?: [
      PunishRule
    ](name='punishments'),
    source?: string(name='source'),
  }(name='punishment_detail'),
  punishmentId?: string(name='punishment_id'),
  punishmentOperation?: string(name='punishment_operation'),
  status?: string(name='status'),
}

model BaseRoleMemberResponse {
  assignmentList?: [
    BaseAssignmentResponse
  ](name='assignment_list'),
  createdAt?: string(name='created_at'),
  creator?: string(name='creator'),
  domainId?: string(name='domain_id'),
  identity?: Identity(name='identity'),
  identityName?: string(name='identity_name'),
  isAdmin?: boolean(name='is_admin'),
  subdomainId?: string(name='subdomain_id'),
}

model BaseUserPunishRuleResponse {
  results?: [ 
    {
      success?: boolean(name='success'),
      userId?: string(name='user_id'),
    }
  ](name='results'),
}

model BaseUserResponse {
  avatar?: string(name='avatar', example='http://a.b.c/ccp.jpg'),
  createdAt?: string(name='created_at', example='1567407718386'),
  creator?: string(name='creator', example='system'),
  defaultDriveId?: string(name='default_drive_id', example='123'),
  defaultLocation?: string(name='default_location'),
  denyChangePasswordBySelf?: boolean(name='deny_change_password_by_self'),
  description?: string(name='description', example='ccp team user'),
  domainId?: string(name='domain_id', example='hz999'),
  email?: string(name='email', example='123@ccp.com'),
  expiredAt?: long(name='expired_at', example='0'),
  isSync?: boolean(name='is_sync'),
  lastLoginTime?: long(name='last_login_time'),
  needChangePasswordNextLogin?: boolean(name='need_change_password_next_login'),
  nickName?: string(name='nick_name', example='abc'),
  pathStatus?: string(name='path_status'),
  permission?: map[string]IDPermission(name='permission'),
  phone?: string(name='phone', example='13700000000'),
  phoneRegion?: string(name='phone_region'),
  role?: string(name='role', example='user'),
  status?: string(name='status', example='enabled'),
  updatedAt?: string(name='updated_at', example='1567407718386'),
  userData?: map[string]any(name='user_data'),
  userId?: string(name='user_id', example='ccpuserid'),
  userName?: string(name='user_name', example='name'),
}

model BenefitMeta {
  config?: string(name='config'),
  enabled?: boolean(name='enabled'),
  quota?: long(name='quota'),
}

model BenefitPkgDeliveryInfo {
  amount?: long(name='amount'),
  createdAt?: string(name='created_at'),
  expireTime?: string(name='expire_time'),
  isPermanent?: boolean(name='is_permanent'),
}

model CNameStatus {
  bingdingState?: string(name='bingding_state', example='BINDING/BOUND'),
  legalState?: string(name='legal_state', example='NORMAL/ABNORMAL'),
  remark?: string(name='remark', example='beian'),
}

model CdnFileDownloadCallbackInfo {
  bucket?: string(name='bucket', example='ccp-bj1-bj-1234'),
  domainId?: string(name='domain_id'),
  driveId?: string(name='drive_id'),
  expire?: long(name='expire'),
  fileId?: string(name='file_id'),
  object?: string(name='object'),
  token?: string(name='token', example='md5.Sum([]byte(fmt.Sprintf("%v%v%v%v%v%v...%v", 		req.Object, req.Range, req.DomainID, req.DriveID, req.UserID, req.FileID, req.Expire)))'),
  userId?: string(name='user_id'),
}

model CertInfo {
  certBody?: string(name='cert_body', example='xxx'),
  certName?: string(name='cert_name', example='xxx'),
  certPrivatekey?: string(name='cert_privatekey', example='xxx'),
}

model ClearRecycleBinItem {
  asyncTaskId?: string(name='async_task_id'),
  domainId?: string(name='domain_id'),
  driveId?: string(name='drive_id'),
  taskId?: string(name='task_id'),
}

model Condition {
  intEquals?: [ long ](name='int_equals'),
  intNotEquals?: [ long ](name='int_not_equals'),
  stringEquals?: [ string ](name='string_equals'),
  stringNotEquals?: [ string ](name='string_not_equals'),
}

model CsiCondition {
  fileDataPunish?: Condition(name='file_data_punish'),
}

model CssCreateOrderParam {
  agentId?: string(name='agentId'),
  autoPay?: boolean(name='autoPay'),
  autoUseCoupon?: boolean(name='autoUseCoupon'),
  bid?: string(name='bid'),
  buyerId?: long(name='buyerId'),
  certificate?: string(name='certificate'),
  childId?: long(name='childId'),
  cilentIp?: string(name='cilentIp'),
  commodities?: [
    CssInstanceCommodity
  ](name='commodities'),
  createrNick?: string(name='createrNick'),
  cssAuthRequestParam?: any(name='cssAuthRequestParam'),
  fromApp?: string(name='fromApp'),
  language?: string(name='language'),
  marketType?: long(name='marketType'),
  memo?: string(name='memo'),
  orderOrigin?: string(name='orderOrigin'),
  orderParams?: map[string]string(name='orderParams'),
  payerId?: long(name='payerId'),
  planGroupId?: long(name='planGroupId'),
  planId?: long(name='planId'),
  planInstanceId?: string(name='planInstanceId'),
  promotionCode?: string(name='promotionCode'),
  promotionInputParam?: any(name='promotionInputParam'),
  requestId?: string(name='requestId'),
  skipChannel?: boolean(name='skipChannel'),
  token?: string(name='token'),
  transientAccess?: any(name='transientAccess'),
  umidToken?: string(name='umidToken'),
  userId?: long(name='userId'),
}

model CssInstanceCommodity {
  activityId?: long(name='activityId'),
  aliyunProduceCode?: string(name='aliyunProduceCode'),
  chargeType?: string(name='chargeType'),
  commodityCode?: string(name='commodityCode'),
  components?: [
    CssInstanceComponent
  ](name='components'),
  duration?: long(name='duration'),
  instanceId?: string(name='instanceId'),
  isFree?: boolean(name='isFree'),
  isPrePayPostCharge?: boolean(name='isPrePayPostCharge'),
  isRenewChange?: boolean(name='isRenewChange'),
  isSyncToSubscription?: boolean(name='isSyncToSubscription'),
  orderParams?: map[string]string(name='orderParams'),
  orderType?: string(name='orderType'),
  planItemId?: long(name='planItemId'),
  pricingCycle?: string(name='pricingCycle'),
  quantity?: long(name='quantity'),
  redeemNoList?: [ string ](name='redeemNoList'),
  redeemOrderType?: string(name='redeemOrderType'),
  refundSpecCode?: string(name='refundSpecCode'),
  specCode?: string(name='specCode'),
  specUpgradeOriginSpecCodes?: [ string ](name='specUpgradeOriginSpecCodes'),
  specifyStartDate?: long(name='specifyStartDate'),
  upgradeInquireFinancialValue?: boolean(name='upgradeInquireFinancialValue'),
}

model CssInstanceComponent {
  componentCode?: string(name='componentCode'),
  componentName?: string(name='componentName'),
  globalKey?: string(name='globalKey'),
  instanceProperty?: [
    CssInstanceProperty
  ](name='instanceProperty'),
  moduleAttrStatus?: long(name='moduleAttrStatus'),
  tag?: string(name='tag'),
}

model CssInstanceProperty {
  code?: string(name='code'),
  globalKey?: string(name='globalKey'),
  name?: string(name='name'),
  unit?: string(name='unit'),
  value?: string(name='value'),
}

model CssProduce {
  bid?: string(name='bid'),
  buyerId?: long(name='buyerId'),
  childId?: long(name='childId'),
  fromApp?: string(name='fromApp'),
  orderId?: long(name='orderId'),
  payerId?: long(name='payerId'),
  purchases?: [
    CssPurchase
  ](name='purchases'),
  requestId?: string(name='requestId'),
  skipChannel?: boolean(name='skipChannel'),
  token?: string(name='token'),
  userId?: long(name='userId'),
}

model CssPurchase {
  chargeType?: string(name='chargeType'),
  commodityCode?: string(name='commodityCode'),
  endDate?: long(name='endDate'),
  gmtCreate?: long(name='gmtCreate'),
  instanceComponents?: [
    CssInstanceComponent
  ](name='instanceComponents'),
  instanceId?: string(name='instanceId'),
  orderType?: string(name='orderType'),
  purchaseParams?: map[string]string(name='purchaseParams'),
  startDate?: long(name='startDate'),
}

model CustomSideLinkConfig {
  icon?: string(name='icon'),
  link?: string(name='link'),
  text?: string(name='text'),
}

model DataCName {
  dataCname?: string(name='data_cname'),
  location?: string(name='location'),
}

model Domain {
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  domainName?: string(name='domain_name'),
  initDriveEnable?: boolean(name='init_drive_enable'),
  initDriveSize?: long(name='init_drive_size'),
  parentDomainId?: string(name='parent_domain_id'),
  publishedAppAccessStrategy?: AppAccessStrategy(name='published_app_access_strategy'),
  sharable?: boolean(name='sharable'),
  sizeQuota?: long(name='size_quota'),
  sizeQuotaUsed?: long(name='size_quota_used'),
  status?: long(name='status'),
  updatedAt?: string(name='updated_at'),
  usedSize?: long(name='used_size'),
  userCountQuota?: long(name='user_count_quota'),
}

model DomainAppConfig {
  allowUploadCustomFileExtList?: [ string ](name='allow_upload_custom_file_ext_list'),
  allowUploadFileCategoryList?: [ string ](name='allow_upload_file_category_list'),
  sameNameFileUploadMode?: string(name='same_name_file_upload_mode'),
  singleFileUploadSizeLimit?: long(name='single_file_upload_size_limit'),
  webClientDownloadMode?: string(name='web_client_download_mode'),
}

model DomainBuildClientConfig {
  copyright?: string(name='copyright'),
  name?: string(name='name'),
}

model DomainSeniorConfig {
  clientDownloadEnable?: boolean(name='client_download_enable'),
  cspFrameAncestors?: string(name='csp_frame_ancestors'),
  customLoginAppid?: string(name='custom_login_appid'),
  customLoginUrl?: string(name='custom_login_url'),
  customLogoutUrl?: string(name='custom_logout_url'),
  customSideLinkList?: [
    CustomSideLinkConfig
  ](name='custom_side_link_list'),
  homePageBgImageUrl?: string(name='home_page_bg_image_url'),
  homePageFooter?: string(name='home_page_footer'),
  homePageFooter2?: string(name='home_page_footer2'),
  homePageSlogan?: string(name='home_page_slogan'),
  refererEnable?: boolean(name='referer_enable'),
  wxTxtList?: WxTrustedDomainConfig(name='wx_txt_list'),
}

model Drive {
  createdAt?: string(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  driveId?: string(name='drive_id'),
  driveName?: string(name='drive_name'),
  driveType?: string(name='drive_type'),
  owner?: string(name='owner'),
  ownerType?: string(name='owner_type'),
  status?: string(name='status'),
  totalSize?: long(name='total_size'),
  usedSize?: long(name='used_size'),
}

model DriveLogDetail {
  forceDelete?: boolean(name='force_delete'),
  handoverOwnerName?: string(name='handover_owner_name'),
  name?: string(name='name'),
  ownerId?: string(name='owner_id'),
  ownerName?: string(name='owner_name'),
  ownerType?: string(name='owner_type'),
  totalSize?: long(name='total_size'),
  updateTo?: {
    name?: string(name='name'),
    ownerId?: string(name='owner_id'),
    ownerName?: string(name='owner_name'),
    ownerType?: string(name='owner_type'),
    totalSize?: long(name='total_size'),
  }(name='update_to'),
}

model ExternalMultiFileRevisionConfig {
  revisionCount?: long(name='revision_count'),
  revisionMergeEnabled?: boolean(name='revision_merge_enabled'),
  revisionRecyclePeriod?: long(name='revision_recycle_period'),
}

model FaceGroup {
  createdAt?: string(name='created_at', example='2022-01-14T10:10:52.83948013+08:00'),
  groupCoverFaceBoundary?: {
    height?: int32(name='Height', example='300'),
    left?: int32(name='Left', example='10'),
    top?: int32(name='Top', example='30'),
    width?: int32(name='Width', example='200'),
  }(name='group_cover_face_boundary'),
  groupCoverFileId?: string(name='group_cover_file_id', example='6549c959640fbd517c9b4d93b3b36aecc45xxxxx'),
  groupCoverHeight?: long(name='group_cover_height', example='1080'),
  groupCoverUrl?: string(name='group_cover_url', example='https://xxx'),
  groupCoverWidth?: long(name='group_cover_width', example='1920'),
  groupId?: string(name='group_id', example='Cluster-ae6e3472-999e-410b-b54e-cd5dba****'),
  groupName?: string(name='group_name', example='name'),
  imageCount?: long(name='image_count', example='10'),
  remarks?: string(name='remarks'),
  updatedAt?: string(name='updated_at', example='2022-01-14T10:10:52.83948013+08:00'),
}

model FaceThumbnail {
  faceGroupId?: string(name='face_group_id', example='Cluster-e3b7fb52-22b3-44f2-9746-8c1804bd6af0'),
  faceId?: string(name='face_id', example='a9a66a86-73dd-4c95-8b79-1d8a49db5226'),
  faceThumbnail?: string(name='face_thumbnail', example='https://pds-domain.region.aliyuncs.com/QieGeH98%2F1001%2F63e5e551ee621482ab934a0687c6cda75fc07864%2F642a8a40c00f1ad379df421694713ee65170f09b?security-token=CAIS%2BgF1q6Ft5B2yfSjIr5bjHPCNnrdR8aSaSW7woVlmVd1Bt5HorDz2IHpPfHdoBe0btvU%2BlWxX6fwZlq5rR4QAXlDfNSyFeX20qFHPWZHInuDox55m4cTXNAr%2BIhr%2F29CoEIedZdjBe%2FCrRknZnytou9XTfimjWFrXWv%2Fgy%2BQQDLItUxK%2FcCBNCfpPOwJms7V6D3bKMuu3OROY6Qi5TmgQ41En1DIlt%2FXuk5DCtkqB12eXkLFF%2B97DRbG%2FdNRpMZtFVNO44fd7bKKp0lQLsUMSqv8q0fEcqGaW4o7CWQJLnzyCMvvJ9OVDFyN0aKEnH7J%2Bq%2FzxhTPrMnpkSlacGoABPMvZ8rSESUEP96Vbf%2Bk0JRg9Qb1MnaIJqWAgo8K6K0UP1CtqL2zrUtugpKKDHOYiKbq2O0S5yLUPVX5vBHqEi%2FFc7i6ZnHCMcXLJs4rKDKwRBEhovUXXlklq2q43OSVtLrXkBy9Xs1ers%2FhJhcxpNA0Vl3EWfJxa2BTylEdnLOQ%3D&x-oss-access-key-id=STS.NUVWJ9shpFfqKHAEY3YRmXTCN&x-oss-expires=1686455451&x-oss-process=image%2Fcrop%2Cx_1128%2Cy_1211%2Cw_914%2Ch_914%2Fformat%2Cjpg&x-oss-signature=jmhOz91Tww1ciMEwadDiioU7d93FDiBNr8s8mHyMqW0%3D&x-oss-signature-version=OSS2', deprecated='true'),
}

model File {
  category?: string(name='category'),
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  contentType?: string(name='content_type'),
  crc64Hash?: string(name='crc64_hash'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  downloadUrl?: string(name='download_url'),
  driveId?: string(name='drive_id'),
  fileExtension?: string(name='file_extension'),
  fileId?: string(name='file_id'),
  hidden?: boolean(name='hidden'),
  investigationInfo?: {
    status?: long(name='status'),
    suggestion?: string(name='suggestion'),
  }(name='investigation_info'),
  labels?: [ string ](name='labels'),
  localCreatedAt?: string(name='local_created_at'),
  localModifiedAt?: string(name='local_modified_at'),
  name?: string(name='name'),
  parentFileId?: string(name='parent_file_id'),
  revisionId?: string(name='revision_id'),
  size?: long(name='size'),
  starred?: boolean(name='starred'),
  status?: string(name='status'),
  thumbnail?: string(name='thumbnail'),
  thumbnailUrls?: map[string]string(name='thumbnail_urls'),
  trashedAt?: string(name='trashed_at'),
  type?: string(name='type'),
  updatedAt?: string(name='updated_at'),
  uploadId?: string(name='upload_id'),
  userTags?: map[string]string(name='user_tags'),
  videoMediaMetadata?: VideoMediaMetadata(name='video_media_metadata'),
}

model FileDownloadCallbackInfo {
  bucket?: string(name='bucket', example='ccp-bj1-bj-1234'),
  domainId?: string(name='domain_id'),
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  object?: string(name='object'),
  userId?: string(name='user_id'),
}

model FileLogDetail {
  decompressFileList?: [ string ](name='decompress_file_list'),
  newName?: string(name='new_name'),
  parentPath?: string(name='parent_path'),
  revVersion?: long(name='rev_version'),
  revisionId?: string(name='revision_id'),
  size?: long(name='size'),
  toParentPath?: string(name='to_parent_path'),
  toParentPathType?: string(name='to_parent_path_type'),
  type?: string(name='type'),
}

model FilePermissionMember {
  actionList?: [ string ](name='action_list'),
  disinheritSubGroup?: boolean(name='disinherit_sub_group'),
  expireTime?: long(name='expire_time'),
  identity?: Identity(name='identity'),
  roleId?: string(name='role_id'),
}

model FileStreamInfo {
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  contentMd5?: string(name='content_md5'),
  partInfoList?: UploadPartInfo(name='part_info_list'),
  preHash?: string(name='pre_hash'),
  proofCode?: string(name='proof_code'),
  proofVersion?: string(name='proof_version'),
  size?: long(name='size'),
}

model GetOfficeEditUrlOption {
  copy?: boolean(name='copy'),
  print?: boolean(name='print'),
  readonly?: boolean(name='readonly'),
}

model GetOfficeEditUrlWatermark {
  fillstyle?: string(name='fillstyle'),
  font?: string(name='font'),
  horizontal?: long(name='horizontal'),
  rotate?: double(name='rotate'),
  type?: int32(name='type'),
  value?: string(name='value'),
  vertical?: long(name='vertical'),
}

model GetOfficePreviewUrlOption {
  copy?: boolean(name='copy'),
  print?: boolean(name='print'),
}

model Group {
  createdAt?: long(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  groupId?: string(name='group_id'),
  groupName?: string(name='group_name'),
  updatedAt?: long(name='updated_at'),
}

model IDPermission {
  disinheritSubGroup?: boolean(name='disinherit_sub_group'),
  expireTime?: long(name='expire_time'),
  permission?: Permission(name='permission'),
  roles?: [ string ](name='roles'),
}

model Identity {
  identityId?: string(name='identity_id'),
  identityType?: string(name='identity_type', example='IT_User'),
}

model IdentityBenefitPkg {
  benefitPkgId?: string(name='benefit_pkg_id'),
  name?: string(name='name'),
}

model IdentityToBenefitPkgMapping {
  benefitPkgComputationRule?: string(name='benefit_pkg_computation_rule'),
  benefitPkgId?: string(name='benefit_pkg_id'),
  benefitPkgName?: string(name='benefit_pkg_name'),
  benefitPkgOwnerId?: string(name='benefit_pkg_owner_id'),
  benefitPkgPriority?: long(name='benefit_pkg_priority'),
  benefitPkgType?: string(name='benefit_pkg_type'),
  createdAt?: string(name='created_at'),
  deliveryInfoList?: [
    BenefitPkgDeliveryInfo
  ](name='delivery_info_list'),
  identityId?: string(name='identity_id'),
  identityType?: string(name='identity_type'),
  updatedAt?: string(name='updated_at'),
}

model ImageMediaMetadata {
  addressLine?: string(name='address_line', example='浙江省杭州市滨江区西兴街道江陵路'),
  city?: string(name='city', example='杭州市'),
  country?: string(name='country', example='中国'),
  district?: string(name='district', example='滨江区'),
  exif?: string(name='exif', example='{"Compression":{"value":"6"},"DateTime":{"value":"2020:08:19 17:11:11"}}'),
  facesThumbnail?: [
    FaceThumbnail
  ](name='faces_thumbnail'),
  height?: long(name='height', example='1080'),
  imageQuality?: ImageQuality(name='image_quality'),
  imageTags?: [
    SystemTag
  ](name='image_tags'),
  location?: string(name='location', example='30.185453,120.218522'),
  province?: string(name='province', example='浙江省'),
  time?: string(name='time', example='2006-01-02T15:04:05.000Z07:00'),
  township?: string(name='township', example='西兴街道'),
  width?: long(name='width', example='1920'),
}

model ImageProcess {
  imageThumbnailProcess?: string(name='image_thumbnail_process'),
  officeThumbnailProcess?: string(name='office_thumbnail_process'),
  videoThumbnailProcess?: string(name='video_thumbnail_process'),
}

model ImageQuality {
  overallScore?: double(name='overall_score', example='0.736'),
}

model ImageTag {
  count?: long(name='count'),
  coverFileCategory?: string(name='cover_file_category'),
  coverFileId?: string(name='cover_file_id'),
  coverOverallScore?: float(name='cover_overall_score'),
  coverTagConfidence?: float(name='cover_tag_confidence'),
  coverUrl?: string(name='cover_url'),
  name?: string(name='name'),
}

model Int64Range {
  from?: long(name='from'),
  to?: long(name='to'),
}

model InvestigationInfo {
  status?: long(name='status'),
  suggestion?: string(name='suggestion'),
  videoDetail?: {
    blockFrames?: [ 
      {
        label?: string(name='label'),
        offset?: long(name='offset'),
        rate?: double(name='rate'),
      }
    ](name='block_frames'),
  }(name='video_detail'),
}

model JWTPayload {
  aud?: string(name='aud'),
  autoCreate?: boolean(name='auto_create'),
  exp?: long(name='exp'),
  iat?: long(name='iat'),
  iss?: string(name='iss'),
  jti?: string(name='jti'),
  nbf?: long(name='nbf'),
  sub?: string(name='sub'),
  subType?: string(name='sub_type'),
}

model LinkInfo {
  extra?: string(name='extra'),
  identity?: string(name='identity'),
  type?: string(name='type'),
}

model LocationDateCluster {
  address?: Address(name='address'),
  clusterId?: string(name='cluster_id'),
  createdAt?: string(name='created_at'),
  customLabels?: map[string]string(name='custom_labels'),
  driveId?: string(name='drive_id'),
  endTime?: string(name='end_time'),
  level?: string(name='level'),
  startTime?: string(name='start_time'),
  title?: string(name='title'),
  updatedAt?: string(name='updated_at'),
}

model Membership {
  createdAt?: long(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  groupId?: string(name='group_id'),
  memberRole?: string(name='member_role'),
  memberType?: string(name='member_type'),
  subGroupId?: string(name='sub_group_id'),
  updatedAt?: long(name='updated_at'),
  userId?: string(name='user_id'),
}

model NameCheckResult {
  existFileId?: string(name='exist_file_id'),
  existFileType?: string(name='exist_file_type'),
}

model OfficeEditConfig {
  enabled?: boolean(name='enabled'),
}

model OfficePreviewConfig {
  enabled?: boolean(name='enabled'),
}

model Permission {
  actionList?: [ 
    {
      action?: string(name='action'),
    }
  ](name='action_list'),
  collection?: string(name='collection'),
  condition?: PermissionCondition(name='condition'),
  createdAt?: long(name='created_at'),
  effect?: string(name='effect'),
  identityId?: string(name='identity_id'),
  identityType?: string(name='identity_type'),
  resource?: string(name='resource'),
  resourceType?: string(name='resource_type'),
  updatedAt?: long(name='updated_at'),
  userTags?: [ string ](name='user_tags'),
}

model PermissionCondition {
  ipEquals?: {
    clientIp?: [ string ](name='client_ip'),
  }(name='ip_equals'),
  ipNotEquals?: {
    clientIp?: [ string ](name='client_ip'),
  }(name='ip_not_equals'),
  stringLike?: {
    vpcId?: [ string ](name='vpc_id'),
  }(name='string_like'),
  stringNotLike?: {
    vpcId?: [ string ](name='vpc_id'),
  }(name='string_not_like'),
}

model PunishRule {
  actionCode?: string(name='action_code'),
  endsAt?: string(name='ends_at'),
  impermanent?: boolean(name='impermanent'),
  startsAt?: string(name='starts_at'),
}

model RecycleBinConfig {
  autoDeleteEnabled?: boolean(name='auto_delete_enabled'),
  autoDeleteKeepSecond?: int32(name='auto_delete_keep_second'),
  deleteTrashNormalFileDisabled?: boolean(name='delete_trash_normal_file_disabled'),
}

model RefundNoticeParam {
  aliuid?: long(name='aliuid'),
  aliyunProduceCode?: string(name='aliyunProduceCode'),
  commodityCode?: string(name='commodityCode'),
  instanceId?: string(name='instanceId'),
  newExpireTime?: any(name='newExpireTime'),
  orderIds?: [ long ](name='orderIds'),
  refundParamMap?: map[string]string(name='refundParamMap'),
  refundType?: string(name='refundType'),
}

model Revision {
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  crc64Hash?: string(name='crc64_hash'),
  createdAt?: string(name='created_at'),
  creatorId?: string(name='creator_id'),
  creatorName?: string(name='creator_name'),
  domainId?: string(name='domain_id'),
  downloadUrl?: string(name='download_url'),
  driveId?: string(name='drive_id'),
  fileExtension?: string(name='file_extension'),
  fileId?: string(name='file_id'),
  isLatestVersion?: boolean(name='is_latest_version'),
  keepForever?: boolean(name='keep_forever'),
  revisionDescription?: string(name='revision_description'),
  revisionId?: string(name='revision_id'),
  revisionName?: string(name='revision_name'),
  revisionVersion?: long(name='revision_version'),
  size?: long(name='size'),
  thumbnail?: string(name='thumbnail'),
  updatedAt?: string(name='updated_at'),
  url?: string(name='url'),
}

model Role {
  createdAt?: long(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  manageResourceType?: string(name='manage_resource_type'),
  name?: string(name='name'),
  permissions?: [
    Permission
  ](name='permissions'),
  roleId?: string(name='role_id'),
  status?: string(name='status'),
  updatedAt?: long(name='updated_at'),
}

model SearchFromThirdPartyItem {
  authenticationType?: string(name='authentication_type'),
  extra?: string(name='extra'),
  identity?: string(name='identity'),
  others?: map[string]any(name='others'),
}

model ShareLink {
  accessCount?: long(name='access_count'),
  createdAt?: string(name='created_at'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  disableDownload?: boolean(name='disable_download'),
  disablePreview?: boolean(name='disable_preview'),
  disableSave?: boolean(name='disable_save'),
  downloadCount?: long(name='download_count'),
  downloadLimit?: long(name='download_limit'),
  driveId?: string(name='drive_id'),
  expiration?: string(name='expiration'),
  expired?: boolean(name='expired'),
  fileIdList?: [ string ](name='file_id_list'),
  previewCount?: long(name='preview_count'),
  previewLimit?: long(name='preview_limit'),
  reportCount?: long(name='report_count'),
  saveCount?: long(name='save_count'),
  saveLimit?: long(name='save_limit'),
  shareAllFiles?: boolean(name='share_all_files'),
  shareId?: string(name='share_id'),
  shareName?: string(name='share_name'),
  sharePwd?: string(name='share_pwd'),
  status?: string(name='status'),
  updatedAt?: string(name='updated_at'),
  videoPreviewCount?: long(name='video_preview_count'),
}

model ShareLinkConfig {
  enableShareLinkOfficeEdit?: boolean(name='enable_share_link_office_edit'),
}

model ShareLinkDetail {
  enableOfficeEditable?: boolean(name='enable_office_editable'),
}

model SimpleQuery {
  field?: bytes(name='field'),
  operation?: bytes(name='operation'),
  subQueries?: [
    SimpleQuery
  ](name='sub_queries'),
  value?: bytes(name='value'),
}

model SimpleStreamInfo {
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  crc64Hash?: string(name='crc64_hash'),
  downloadUrl?: string(name='download_url'),
  size?: long(name='size'),
  thumbnail?: string(name='thumbnail'),
  url?: string(name='url'),
}

model Store {
  basePath?: string(name='base_path'),
  bucket?: string(name='bucket'),
  endpoint?: string(name='endpoint'),
  location?: string(name='location'),
  ownership?: string(name='ownership'),
  roleArn?: string(name='role_arn'),
  storeId?: string(name='store_id'),
  type?: string(name='type'),
}

model Story {
  coverFileId?: string(name='cover_file_id'),
  coverFileThumbnailUrl?: string(name='cover_file_thumbnail_url'),
  createdAt?: string(name='created_at'),
  customLabels?: map[string]any(name='custom_labels'),
  faceGroupIds?: [ string ](name='face_group_ids'),
  storyEndTime?: string(name='story_end_time'),
  storyFileList?: [
    File
  ](name='story_file_list'),
  storyId?: string(name='story_id'),
  storyName?: string(name='story_name'),
  storyStartTime?: string(name='story_start_time'),
  storySubType?: string(name='story_sub_type'),
  storyType?: string(name='story_type'),
  updatedAt?: string(name='updated_at'),
}

model StreamUploadInfo {
  location?: string(name='location', example='cn-beijing'),
  partInfoList?: [
    UploadPartInfo
  ](name='part_info_list'),
  preRapidUpload?: boolean(name='pre_rapid_upload', example='false'),
  rapidUpload?: boolean(name='rapid_upload', example='false'),
  uploadId?: string(name='upload_id', example='abcd'),
}

model SystemTag {
  centricScore?: float(name='centric_score', example='0.877'),
  confidence?: float(name='confidence', example='0.98'),
  name?: string(name='name', example='篮球'),
  parentName?: string(name='parent_name', example='运动'),
  tagLevel?: int32(name='tag_level', example='3'),
}

model TimeRange {
  end?: string(name='end'),
  start?: string(name='start'),
}

model Token {
  accessToken?: string(name='access_token'),
  avatar?: string(name='avatar'),
  defaultDriveId?: string(name='default_drive_id'),
  deviceId?: string(name='device_id'),
  deviceName?: string(name='device_name'),
  domainId?: string(name='domain_id'),
  expireTime?: string(name='expire_time'),
  expiresIn?: long(name='expires_in'),
  isFirstLogin?: boolean(name='is_first_login'),
  nickName?: string(name='nick_name'),
  refreshToken?: string(name='refresh_token'),
  role?: string(name='role'),
  status?: string(name='status'),
  tokenType?: string(name='token_type'),
  userId?: string(name='user_id'),
  userName?: string(name='user_name'),
}

model UncompressConfig {
  enable?: boolean(name='enable'),
  version?: string(name='version'),
}

model UncompressConfigResponse {
  enabled?: boolean(name='enabled'),
  version?: string(name='version'),
}

model UncompressedFileInfo {
  driveId?: string(name='drive_id'),
  fileId?: string(name='file_id'),
  isFolder?: boolean(name='is_folder'),
  items?: [
    UncompressedFileInfo
  ](name='items'),
  name?: string(name='name'),
  size?: long(name='size'),
  updatedAt?: long(name='updated_at'),
}

model UploadFormInfo {
  bucketName?: string(name='bucket_name'),
  objectKey?: string(name='object_key'),
  ossAccessKeyId?: string(name='oss_access_key_id'),
  ossEndPoint?: string(name='oss_end_point'),
  ossSecurityToken?: string(name='oss_security_token'),
  policy?: string(name='policy'),
  signature?: string(name='signature'),
}

model UploadPartInfo {
  etag?: string(name='etag', example='0CC175B9C0F1B6A831C399E269772661'),
  internalUploadUrl?: string(name='internal_upload_url'),
  parallelSha1Ctx?: {
    h?: [ long ](name='h'),
    partOffset?: long(name='part_offset'),
  }(name='parallel_sha1_ctx'),
  parallelSha256Ctx?: {
    h?: [ long ](name='h'),
    partOffset?: long(name='part_offset'),
  }(name='parallel_sha256_ctx'),
  partNumber?: int32(name='part_number', example='1'),
  partSize?: long(name='part_size', example='1024'),
  uploadUrl?: string(name='upload_url'),
}

model User {
  avatar?: string(name='avatar'),
  createdAt?: long(name='created_at'),
  creator?: string(name='creator'),
  defaultDriveId?: string(name='default_drive_id'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  email?: string(name='email'),
  nickName?: string(name='nick_name'),
  phone?: string(name='phone'),
  role?: string(name='role'),
  status?: string(name='status'),
  updatedAt?: long(name='updated_at'),
  userData?: map[string]string(name='user_data'),
  userId?: string(name='user_id'),
  userName?: string(name='user_name'),
}

model UserExtraItem {
  account?: [
    AccountLinkInfo
  ](name='account'),
  avatar?: string(name='avatar', example='http://a.b.c/ccp.jpg'),
  createdAt?: string(name='created_at', example='1567407718386'),
  creator?: string(name='creator', example='system'),
  defaultDrive?: BaseDriveResponse(name='default_drive'),
  defaultDriveId?: string(name='default_drive_id', example='123'),
  defaultLocation?: string(name='default_location'),
  denyChangePasswordBySelf?: boolean(name='deny_change_password_by_self'),
  description?: string(name='description', example='ccp team user'),
  domainId?: string(name='domain_id', example='hz999'),
  email?: string(name='email', example='123@ccp.com'),
  expiredAt?: long(name='expired_at', example='0'),
  isSync?: boolean(name='is_sync'),
  lastLoginTime?: long(name='last_login_time'),
  needChangePasswordNextLogin?: boolean(name='need_change_password_next_login'),
  nickName?: string(name='nick_name', example='abc'),
  parentGroup?: [
    BaseDriveResponse
  ](name='parent_group'),
  pathStatus?: string(name='path_status'),
  permission?: map[string]IDPermission(name='permission'),
  phone?: string(name='phone', example='13700000000'),
  phoneRegion?: string(name='phone_region'),
  role?: string(name='role', example='user'),
  status?: string(name='status', example='enabled'),
  updatedAt?: string(name='updated_at', example='1567407718386'),
  userData?: map[string]any(name='user_data'),
  userId?: string(name='user_id', example='ccpuserid'),
  userName?: string(name='user_name', example='name'),
}

model UserLogDetail {
  email?: string(name='email'),
  expiredAt?: long(name='expired_at'),
  name?: string(name='name'),
  phone?: string(name='phone'),
  roleId?: string(name='role_id'),
  updateTo?: {
    email?: string(name='email'),
    expiredAt?: long(name='expired_at'),
    name?: string(name='name'),
    phone?: string(name='phone'),
    roleId?: string(name='role_id'),
  }(name='update_to'),
}

model UserTag {
  value?: string(name='Value'),
  key?: string(name='key'),
}

model VideoMediaAudioStream {
  bitRate?: string(name='bit_rate', example='129280'),
  codeName?: string(name='code_name', example='aac'),
  duration?: string(name='duration', example='7704.573000'),
}

model VideoMediaMetadata {
  height?: long(name='height', example='1080'),
  videoMediaAudioStream?: [
    VideoMediaAudioStream
  ](name='video_media_audio_stream'),
  videoMediaVideoStream?: [
    VideoMediaVideoStream
  ](name='video_media_video_stream'),
  width?: long(name='width', example='1920'),
}

model VideoMediaVideoStream {
  bitrate?: string(name='bitrate', example='108420'),
  codeName?: string(name='code_name', example='h264'),
  duration?: string(name='duration', example='22.88'),
  frameCount?: string(name='frame_count', example='90'),
}

model VideoPreviewPlayInfo {
  category?: string(name='category', example='live_transcoding'),
  liveTranscodingTaskList?: [ 
    {
      keepOriginalResolution?: boolean(name='keep_original_resolution'),
      status?: string(name='status'),
      templateId?: string(name='template_id'),
      url?: string(name='url'),
    }
  ](name='live_transcoding_task_list'),
  meta?: {
    duration?: double(name='duration'),
    height?: long(name='height'),
    width?: long(name='width'),
  }(name='meta'),
}

model VideoPreviewPlayMeta {
  category?: string(name='category', example='live_transcoding'),
  liveTranscodingTaskList?: [ 
    {
      keepOriginalResolution?: boolean(name='keep_original_resolution'),
      status?: string(name='status'),
      templateId?: string(name='template_id', example='264_720p'),
    }
  ](name='live_transcoding_task_list'),
  meta?: {
    duration?: double(name='duration', example='10'),
    height?: long(name='height', example='720'),
    width?: long(name='width', example='1280'),
  }(name='meta'),
}

model View {
  category?: string(name='category'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  exFieldsInfo?: map[string]any(name='ex_fields_info'),
  fileCount?: long(name='file_count'),
  name?: string(name='name'),
  owner?: string(name='owner'),
  updatedAt?: string(name='updated_at'),
  viewId?: string(name='view_id'),
}

model ViewFile {
  category?: string(name='category'),
  contentHash?: string(name='content_hash'),
  contentHashName?: string(name='content_hash_name'),
  contentType?: string(name='content_type'),
  crc64Hash?: string(name='crc64_hash'),
  createdAt?: string(name='created_at'),
  description?: string(name='description'),
  domainId?: string(name='domain_id'),
  downloadUrl?: string(name='download_url'),
  driveId?: string(name='drive_id'),
  fields?: map[string]any(name='fields'),
  fileExtension?: string(name='file_extension'),
  fileId?: string(name='file_id'),
  fileRevisionId?: string(name='file_revision_id'),
  hidden?: boolean(name='hidden'),
  investigationInfo?: {
    status?: long(name='status'),
    suggestion?: string(name='suggestion'),
  }(name='investigation_info'),
  joinedAt?: long(name='joined_at'),
  labels?: [ string ](name='labels'),
  localCreatedAt?: string(name='local_created_at'),
  localModifiedAt?: string(name='local_modified_at'),
  name?: string(name='name'),
  parentFileId?: string(name='parent_file_id'),
  revisionId?: string(name='revision_id'),
  size?: long(name='size'),
  starred?: boolean(name='starred'),
  status?: string(name='status'),
  thumbnail?: string(name='thumbnail'),
  thumbnailUrls?: map[string]string(name='thumbnail_urls'),
  trashedAt?: string(name='trashed_at'),
  type?: string(name='type'),
  updatedAt?: string(name='updated_at'),
  uploadId?: string(name='upload_id'),
  viewId?: string(name='view_id'),
}

model WatermarkConfig {
  displayAccessUserName?: boolean(name='display_access_user_name'),
  displayShareLinkCreatorName?: boolean(name='display_shareLink_creator_name'),
  enableDocPreview?: boolean(name='enable_doc_preview'),
  enableOnPreview?: boolean(name='enable_on_preview'),
}

model WatermarkEnableConfig {
  displayAccessUserName?: boolean(name='display_access_user_name'),
  displayCustomText?: string(name='display_custom_text'),
  displayShareLinkCreatorName?: boolean(name='display_shareLink_creator_name'),
  enableDocPreview?: boolean(name='enable_doc_preview'),
}

model WxTrustedDomainConfig {
  content?: string(name='content'),
  name?: string(name='name'),
  show?: boolean(name='show'),
}

model AddGroupMemberRequest {
  groupId?: string(name='group_id', description='The ID of the destination group to which the member is added.', example='3e5***2c2'),
  memberId?: string(name='member_id', description='The member ID. If member_type is set to user, set this parameter to a user ID.', example='2e4***1b1'),
  memberType?: string(name='member_type', description='The type of the member. Set the value to user. When you create a group, you can directly add the group to a parent group.

*

Note: A group can be added to only one group. A user can be added to multiple groups.', example='user'),
}

model AddGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function addGroupMemberWithOptions(request: AddGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddGroupMemberResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }
  if (!Util.isUnset(request.memberId)) {
    body['member_id'] = request.memberId;
  }
  if (!Util.isUnset(request.memberType)) {
    body['member_type'] = request.memberType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddGroupMember',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/add_member`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function addGroupMember(request: AddGroupMemberRequest): AddGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addGroupMemberWithOptions(request, headers, runtime);
}

model AddStoryFilesRequest {
  driveId?: string(name='drive_id', example='1'),
  files?: [ 
    {
      fileId?: string(name='file_id', example='63e5e4340f76cb3ead5f40f68163f0f967c1a7bf'),
      revisionId?: string(name='revision_id', example='642a88dd06e49d9c0a14411ebae606f70edd9a59'),
    }
  ](name='files'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model AddStoryFilesResponseBody = {
  driveId?: string(name='drive_id', example='1'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model AddStoryFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddStoryFilesResponseBody(name='body'),
}

async function addStoryFilesWithOptions(request: AddStoryFilesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddStoryFilesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.files)) {
    body['files'] = request.files;
  }
  if (!Util.isUnset(request.storyId)) {
    body['story_id'] = request.storyId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddStoryFiles',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/add_story_files`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function addStoryFiles(request: AddStoryFilesRequest): AddStoryFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addStoryFilesWithOptions(request, headers, runtime);
}

model AssignRoleRequest {
  identity?: Identity(name='identity', description='The unique identifier of a user. The group administrator role can only be assigned to a user.'),
  manageResourceId?: string(name='manage_resource_id', description='The ID of the resource that the role can manage. You can only set this parameter to the ID of a group.', example='105***b82'),
  manageResourceType?: string(name='manage_resource_type', description='The type of the resource that the role can manage. Valid value: RT_Group.', example='RT_Group'),
  roleId?: string(name='role_id', description='The ID of the role that is assigned to a user. Valid value: SystemGroupAdmin.', example='SystemGroupAdmin'),
}

model AssignRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * You can call this operation to assign a group administrator role to a user.
  *
  * @param request AssignRoleRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return AssignRoleResponse
 */
async function assignRoleWithOptions(request: AssignRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AssignRoleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }
  if (!Util.isUnset(request.manageResourceId)) {
    body['manage_resource_id'] = request.manageResourceId;
  }
  if (!Util.isUnset(request.manageResourceType)) {
    body['manage_resource_type'] = request.manageResourceType;
  }
  if (!Util.isUnset(request.roleId)) {
    body['role_id'] = request.roleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AssignRole',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/role/assign`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * You can call this operation to assign a group administrator role to a user.
  *
  * @param request AssignRoleRequest
  * @return AssignRoleResponse
 */
async function assignRole(request: AssignRoleRequest): AssignRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return assignRoleWithOptions(request, headers, runtime);
}

model AuthorizeRequest {
  clientId?: string(name='client_id', description='The application ID returned when the application was created.', example='47eUHhrzgWBvlLWj'),
  hideConsent?: boolean(name='hide_consent', description='Specifies whether to hide the consent page.', example='true'),
  loginType?: string(name='login_type', description='The authentication method. Valid values:

*   default: all logon methods that are integrated on the default logon page provided by Drive and Photo Service.
*   ding: logs on by scanning a DingTalk QR code.
*   ding_sns: logs on by entering a DingTalk account and its password.
*   ram: logs on as an Alibaba Cloud Resource Access Management (RAM) user.
*   wechat: logs on by scanning a WeCom QR code.
*   wechat_app: logs on without authentication in WeCom.', example='default'),
  redirectUri?: string(name='redirect_uri', description='The callback URL specified when the application was created.', example='https://www.aliyunpds.com/sign/callback'),
  responseType?: string(name='response_type', description='The format in which to return the response. Set the value to code.', example='code'),
  scope?: [ string ](name='scope', description='The requested permissions. By default, all permissions are requested.'),
  state?: string(name='state', description='The user-defined parameter to return in the callback URL after the requested permissions are granted.', example='customdata'),
}

model AuthorizeShrinkRequest {
  clientId?: string(name='client_id', description='The application ID returned when the application was created.', example='47eUHhrzgWBvlLWj'),
  hideConsent?: boolean(name='hide_consent', description='Specifies whether to hide the consent page.', example='true'),
  loginType?: string(name='login_type', description='The authentication method. Valid values:

*   default: all logon methods that are integrated on the default logon page provided by Drive and Photo Service.
*   ding: logs on by scanning a DingTalk QR code.
*   ding_sns: logs on by entering a DingTalk account and its password.
*   ram: logs on as an Alibaba Cloud Resource Access Management (RAM) user.
*   wechat: logs on by scanning a WeCom QR code.
*   wechat_app: logs on without authentication in WeCom.', example='default'),
  redirectUri?: string(name='redirect_uri', description='The callback URL specified when the application was created.', example='https://www.aliyunpds.com/sign/callback'),
  responseType?: string(name='response_type', description='The format in which to return the response. Set the value to code.', example='code'),
  scopeShrink?: string(name='scope', description='The requested permissions. By default, all permissions are requested.'),
  state?: string(name='state', description='The user-defined parameter to return in the callback URL after the requested permissions are granted.', example='customdata'),
}

model AuthorizeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * For more information, see "OAuth 2.0 For Web Server Applications" at [OAuth 2.0 For Web Server Applications](https://www.alibabacloud.com/help/en/pds/drive-and-photo-service-dev/user-guide/oauth-2-0-access-process-for-web-server-applications) in User Guide.
  *
  * @param tmpReq AuthorizeRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return AuthorizeResponse
 */
async function authorizeWithOptions(tmpReq: AuthorizeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuthorizeResponse {
  Util.validateModel(tmpReq);
  var request = new AuthorizeShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.scope)) {
    request.scopeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scope, 'scope', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientId)) {
    query['client_id'] = request.clientId;
  }
  if (!Util.isUnset(request.hideConsent)) {
    query['hide_consent'] = request.hideConsent;
  }
  if (!Util.isUnset(request.loginType)) {
    query['login_type'] = request.loginType;
  }
  if (!Util.isUnset(request.redirectUri)) {
    query['redirect_uri'] = request.redirectUri;
  }
  if (!Util.isUnset(request.responseType)) {
    query['response_type'] = request.responseType;
  }
  if (!Util.isUnset(request.scopeShrink)) {
    query['scope'] = request.scopeShrink;
  }
  if (!Util.isUnset(request.state)) {
    query['state'] = request.state;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Authorize',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/oauth/authorize`,
    method = 'GET',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'binary',
  };
  return execute(params, req, runtime);
}

/**
  * For more information, see "OAuth 2.0 For Web Server Applications" at [OAuth 2.0 For Web Server Applications](https://www.alibabacloud.com/help/en/pds/drive-and-photo-service-dev/user-guide/oauth-2-0-access-process-for-web-server-applications) in User Guide.
  *
  * @param request AuthorizeRequest
  * @return AuthorizeResponse
 */
async function authorize(request: AuthorizeRequest): AuthorizeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return authorizeWithOptions(request, headers, runtime);
}

model BatchRequest {
  requests?: [ 
    {
      body?: map[string]string(name='body', description='The request parameters of a child request. The parameter value must be a JSON string. For more information, see the topic of the corresponding child request.

Before you specify the request body, you must specify a header by using Content-Type. Content-Type can only be set to application/json.'),
      headers?: map[string]string(name='headers', description='The header of a child request, which indicates the type of the data specified in the request body.'),
      id?: string(name='id', description='The ID of the child request. The ID is used to associate a child request with a response. The ID of a child request must be unique.', example='93433894994ad2e1'),
      method?: string(name='method', description='The method of a child request. Valid values:

*   POST
*   GET
*   PUT
*   DELETE
*   HEAD', example='POST'),
      url?: string(name='url', description='The API path of a child request. Valid values:

*   /file/get: queries the information about a file.
*   /file/update: modifies the information about a file.
*   /file/search: searches for a file.
*   /file/copy: copies a file or folder.
*   /file/move: moves a file or folder.
*   /file/delete: deletes a file or folder.
*   /file/get_download_url: queries the download URL of a file.
*   /file/get_share_link_download_url: queries the download URL of a file in a share.
*   /recyclebin/trash: moves a file or folder to the recycle bin.
*   /recyclebin/restore: restores a file or folder.
*   /file/put_usertags: adds tags to a user.
*   /file/delete_usertags: removes tags from a user.
*   /drive/get: queries the information about a drive.
*   /user/get: queries the information about a user.
*   /group/get: queries the information about a group.
*   /share_link/create: creates a share.
*   /share_link/update: modifies a share.
*   /share_link/cancel: cancels a share.
*   /share_link/list: queries shares.
*   /share_link/get: queries the information about a share.
*   /share_link/get_share_token: queries an access token of a share.
*   /async_task/get: queries the information about an asynchronous task.', example='/file/get'),
    }
  ](name='requests', description='The child requests.

The number of child requests. Valid value: 1 to 100.'),
  resource?: string(name='resource', description='The type of the resource that you want to manage. Valid values:

*   file: a file.
*   drive: an individual drive or a team drive.
*   user: a user.
*   group: a group.
*   membership: a group member.
*   share_link: a share.
*   async_task: an asynchronous task.

<!---->

*   <!-- -->

    <!-- -->

    <!-- -->

*   <!-- -->

    <!-- -->

    <!-- -->

*   <!-- -->

    <!-- -->

    <!-- -->

*   <!-- -->

    <!-- -->

    <!-- -->

*   <!-- -->

    <!-- -->

    <!-- -->

*   <!-- -->

    <!-- -->

    <!-- -->

*   <!-- -->

    <!-- -->

    <!-- -->', example='file'),
}

model BatchResponseBody = {
  responses?: [ 
    {
      body?: map[string]string(name='body', description='The response parameters of a child request. For more information, see the topic of the corresponding child request.'),
      id?: string(name='id', description='The ID of the child request. The ID is used to associate a child request with a response.', example='93433894994ad2e1'),
      status?: int32(name='status', description='The returned HTTP status code of a child request. For more information, see the topic of the corresponding child request.', example='200'),
    }
  ](name='responses', description='All responses of the child requests.'),
}

model BatchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchResponseBody(name='body'),
}

async function batchWithOptions(request: BatchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.requests)) {
    body['requests'] = request.requests;
  }
  if (!Util.isUnset(request.resource)) {
    body['resource'] = request.resource;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'Batch',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/batch`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function batch(request: BatchRequest): BatchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchWithOptions(request, headers, runtime);
}

model CancelAssignRoleRequest {
  identity?: Identity(name='identity', description='The unique identifier. You can cancel only the role assigned to a user.'),
  manageResourceId?: string(name='manage_resource_id', description='The ID of the resource that the role manages. Set the value to a group ID.', example='105***b82'),
  manageResourceType?: string(name='manage_resource_type', description='The type of the resource that the role manages. Set the value to RT_Group, which specifies group.', example='RT_Group'),
  roleId?: string(name='role_id', description='The ID of the role to be canceled. Set the value to SystemGroupAdmin, which is the ID of the group administrator role.', example='SystemGroupAdmin'),
}

model CancelAssignRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * You can cancel only the group administrator role.
  *
  * @param request CancelAssignRoleRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CancelAssignRoleResponse
 */
async function cancelAssignRoleWithOptions(request: CancelAssignRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelAssignRoleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }
  if (!Util.isUnset(request.manageResourceId)) {
    body['manage_resource_id'] = request.manageResourceId;
  }
  if (!Util.isUnset(request.manageResourceType)) {
    body['manage_resource_type'] = request.manageResourceType;
  }
  if (!Util.isUnset(request.roleId)) {
    body['role_id'] = request.roleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelAssignRole',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/role/cancel_assign`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * You can cancel only the group administrator role.
  *
  * @param request CancelAssignRoleRequest
  * @return CancelAssignRoleResponse
 */
async function cancelAssignRole(request: CancelAssignRoleRequest): CancelAssignRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelAssignRoleWithOptions(request, headers, runtime);
}

model CancelShareLinkRequest {
  shareId?: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8'),
}

model CancelShareLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function cancelShareLinkWithOptions(request: CancelShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CancelShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/cancel`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function cancelShareLink(request: CancelShareLinkRequest): CancelShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelShareLinkWithOptions(request, headers, runtime);
}

model ClearRecyclebinRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
}

model ClearRecyclebinResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

You can call the GetAsyncTask operation to query the information about the asynchronous task based on the task ID.', example='13ebd3a24dba4166b1527add676ef2866051b4d5dele16'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
}

model ClearRecyclebinResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ClearRecyclebinResponseBody(name='body'),
}

async function clearRecyclebinWithOptions(request: ClearRecyclebinRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ClearRecyclebinResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ClearRecyclebin',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/recyclebin/clear`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function clearRecyclebin(request: ClearRecyclebinRequest): ClearRecyclebinResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return clearRecyclebinWithOptions(request, headers, runtime);
}

model CompleteFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
  uploadId?: string(name='upload_id', description='The upload ID.', example='C9DCFE5A82644AC7A02DB74C30C934A6'),
}

model CompleteFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: File  
}

async function completeFileWithOptions(request: CompleteFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CompleteFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.uploadId)) {
    body['upload_id'] = request.uploadId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CompleteFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/complete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function completeFile(request: CompleteFileRequest): CompleteFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return completeFileWithOptions(request, headers, runtime);
}

model CopyFileRequest {
  autoRename?: boolean(name='auto_rename', description='Specifies whether to automatically rename the file if the file name already exists in the destination folder. Default value: false.', example='true'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID or folder ID.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a share link, carry the `x-share-token` header for authentication in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify one of `share_id` and `drive_id`.', example='7JQX1FswpQ8'),
  toDriveId?: string(name='to_drive_id', description='The ID of the drive to which you want to copy the file or folder. Default value: the value of drive_id.', example='1'),
  toParentFileId?: string(name='to_parent_file_id', description='The ID of the destination parent folder. If you want to copy the file or folder to a root directory, set this parameter to root.', example='6520943DC261'),
}

model CopyFileResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

If a file is copied, this parameter is not returned. If a folder is copied, the folder is asynchronously copied in the background and this parameter is returned. You can call the GetAsyncTask operation to query the information about the asynchronous task based on the task ID.', example='000e89fb-cf8f-11e9-8ab4-b6e980803a3b'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The ID of the copied file or folder.', example='4221bf6e6ab43a255edc4463bffa6f5f5d317401'),
}

model CopyFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyFileResponseBody(name='body'),
}

async function copyFileWithOptions(request: CopyFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CopyFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoRename)) {
    body['auto_rename'] = request.autoRename;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.toDriveId)) {
    body['to_drive_id'] = request.toDriveId;
  }
  if (!Util.isUnset(request.toParentFileId)) {
    body['to_parent_file_id'] = request.toParentFileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CopyFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/copy`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function copyFile(request: CopyFileRequest): CopyFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return copyFileWithOptions(request, headers, runtime);
}

model CreateCustomizedStoryRequest {
  customLabels?: map[string]string(name='custom_labels', deprecated='true'),
  driveId?: string(name='drive_id', example='1'),
  storyCover?: {
    fileId?: string(name='file_id', example='63e5e4340f76cb3ead5f40f68163f0f967c1a7bf'),
    revisionId?: string(name='revision_id', example='642a88d4aff041ee68fd4fc89beb80e1119da343'),
  }(name='story_cover'),
  storyFiles?: [ 
    {
      fileId?: string(name='file_id', example='63e5e4340f76cb3ead5f40f68163f0f967c1a7bf'),
      revisionId?: string(name='revision_id', example='642a88d4aff041ee68fd4fc89beb80e1119da343'),
    }
  ](name='story_files'),
  storyName?: string(name='story_name', example='test_name'),
  storySubType?: string(name='story_sub_type', example='user_created'),
  storyType?: string(name='story_type', example='user_created'),
}

model CreateCustomizedStoryResponseBody = {
  driveId?: string(name='drive_id', example='1'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model CreateCustomizedStoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCustomizedStoryResponseBody(name='body'),
}

async function createCustomizedStoryWithOptions(request: CreateCustomizedStoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateCustomizedStoryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.customLabels)) {
    body['custom_labels'] = request.customLabels;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.storyCover)) {
    body['story_cover'] = request.storyCover;
  }
  if (!Util.isUnset(request.storyFiles)) {
    body['story_files'] = request.storyFiles;
  }
  if (!Util.isUnset(request.storyName)) {
    body['story_name'] = request.storyName;
  }
  if (!Util.isUnset(request.storySubType)) {
    body['story_sub_type'] = request.storySubType;
  }
  if (!Util.isUnset(request.storyType)) {
    body['story_type'] = request.storyType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomizedStory',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/create_customized_story`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function createCustomizedStory(request: CreateCustomizedStoryRequest): CreateCustomizedStoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createCustomizedStoryWithOptions(request, headers, runtime);
}

model CreateDomainRequest {
  description?: string(name='description', description='The description of the domain.'),
  domainName?: string(name='domain_name', description='The name of the domain.'),
  initDriveEnable?: boolean(name='init_drive_enable', description='Specifies whether to enable the default drive feature. A value of true specifies that all users are assigned a drive by default on the first logon. Default value: false.', example='true'),
  initDriveSize?: long(name='init_drive_size', description='The size of the default drive. Unit: bytes. You must specify init_drive_size if you set init_drive_enable to true. Default value: 0. A value of 0 specifies that the size of the default drive is 0 bytes and you cannot upload files to the drive. To initialize the default drive, set init_drive_size to 0. A value of -1 specifies that the size is unlimited.', example='1073741824'),
  parentDomainId?: string(name='parent_domain_id', description='The ID of the parent domain. If you want to create a child domain, specify parent_domain_id. In most cases, you do not need to create a child domain. If you want to perform secondary operations based on Drive and Photo Service, contact the customer service.', example='bj1'),
  sizeQuota?: long(name='size_quota', description='The total storage quota for all drives in the domain. A value of 0 specifies that the quota is unlimited.', example='1099511627776'),
  userCountQuota?: long(name='user_count_quota', description='The largest number of users that can be created in the domain. A value of 0 specifies that the number is unlimited.', example='50'),
}

model CreateDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Domain  
}

/**
  * If you want to perform secondary operations based on Drive and Photo Service and perform fine-grained control on your tenants, you can use the parent-child domain feature of Drive and Photo Service. For more information, join the DingTalk group whose ID is 23146118.
  *
  * @param request CreateDomainRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateDomainResponse
 */
async function createDomainWithOptions(request: CreateDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.domainName)) {
    body['domain_name'] = request.domainName;
  }
  if (!Util.isUnset(request.initDriveEnable)) {
    body['init_drive_enable'] = request.initDriveEnable;
  }
  if (!Util.isUnset(request.initDriveSize)) {
    body['init_drive_size'] = request.initDriveSize;
  }
  if (!Util.isUnset(request.parentDomainId)) {
    body['parent_domain_id'] = request.parentDomainId;
  }
  if (!Util.isUnset(request.sizeQuota)) {
    body['size_quota'] = request.sizeQuota;
  }
  if (!Util.isUnset(request.userCountQuota)) {
    body['user_count_quota'] = request.userCountQuota;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDomain',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * If you want to perform secondary operations based on Drive and Photo Service and perform fine-grained control on your tenants, you can use the parent-child domain feature of Drive and Photo Service. For more information, join the DingTalk group whose ID is 23146118.
  *
  * @param request CreateDomainRequest
  * @return CreateDomainResponse
 */
async function createDomain(request: CreateDomainRequest): CreateDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDomainWithOptions(request, headers, runtime);
}

model CreateDriveRequest {
  default?: boolean(name='default', description='Specifies whether the drive is the default drive. Default value: false.', example='true'),
  description?: string(name='description', description='The description of the drive. The description can be up to 1,024 characters in length.'),
  driveName?: string(name='drive_name', description='The name of the drive. The name can be up to 128 characters in length.', example='my_drive'),
  driveType?: string(name='drive_type', description='The type of the drive. Set the value to normal.', example='normal'),
  owner?: string(name='owner', description='The owner of the drive.', example='3b3d7245c159488da17d081ad6c64687'),
  ownerType?: string(name='owner_type', description='The type of the owner. Valid values:

user and group.', example='user'),
  status?: string(name='status', description='The state of the drive. Valid values:

enabled and disabled.

Default value: enabled.', example='enabled'),
  totalSize?: long(name='total_size', description='The total size of the drive. Unit: bytes. By default, the size is unlimited.', example='1024'),
}

model CreateDriveResponseBody = {
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
}

model CreateDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDriveResponseBody(name='body'),
}

async function createDriveWithOptions(request: CreateDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.default)) {
    body['default'] = request.default;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.driveName)) {
    body['drive_name'] = request.driveName;
  }
  if (!Util.isUnset(request.driveType)) {
    body['drive_type'] = request.driveType;
  }
  if (!Util.isUnset(request.owner)) {
    body['owner'] = request.owner;
  }
  if (!Util.isUnset(request.ownerType)) {
    body['owner_type'] = request.ownerType;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.totalSize)) {
    body['total_size'] = request.totalSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function createDrive(request: CreateDriveRequest): CreateDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDriveWithOptions(request, headers, runtime);
}

model CreateFileRequest {
  checkNameMode?: string(name='check_name_mode', description='The processing method that is used if the file that you want to create has the same name as an existing file on the cloud. Valid values:

ignore: allows you to create the file by using the same name as an existing file on the cloud.

auto_rename: automatically renames the file that has the same name on the cloud. By default, the current point in time is added to the end of the file name. Example: xxx\\_20060102\\_150405.

refuse: does not create the file that you want to create but returns the information about the file that has the same name on the cloud.

Default value: ignore.', example='ignore'),
  contentHash?: string(name='content_hash', description='The hash value of the file content. The value is calculated based on the algorithm specified by content_hash_name.', example='7C4A8D09CA3762AF61E59520943DC26494F8941B'),
  contentHashName?: string(name='content_hash_name', description='The name of the algorithm that is used to calculate the hash value of the file content. Only SHA1 is supported.', example='sha1'),
  contentType?: string(name='content_type', description='The type of the file content. Default value: application/oct-stream. For more information about common content types, see [How do I configure the Content-Type header?](https://help.aliyun.com/document_detail/39522.htm?spm=a2c4g.11186623.0.0.5a0b7dbb1TPnWF#concept-5041)', example='application/json'),
  description?: string(name='description', description='The description of the file. The description can be up to 1,024 characters in length. By default, this parameter is left empty.', example='重要文件'),
  driveId?: string(name='drive_id', description='The drive ID. This parameter is required if the file is not uploaded by using the share URL of the file.', example='1'),
  fileId?: string(name='file_id', description='The file ID. This parameter is required if check_name_mode is set to ignore.', example='9520943DC264'),
  hidden?: boolean(name='hidden', description='Specifies whether to hide the file or folder. By default, the file or folder is not hidden.', example='false'),
  imageMediaMetadata?: ImageMediaMetadata(name='image_media_metadata', description='The information about the image specified by the client.'),
  localCreatedAt?: string(name='local_created_at', description='The local time when the file was created. By default, this parameter is left empty. The time is specified in the yyyy-MM-ddTHH:mm:ssZ format based on the UTC+0 time zone.', example='2019-08-20T06:51:27.292Z'),
  localModifiedAt?: string(name='local_modified_at', description='The local time when the file was modified. By default, this parameter is left empty. The time is specified in the yyyy-MM-ddTHH:mm:ssZ format based on the UTC+0 time zone.', example='2019-08-20T06:51:27.292Z'),
  name?: string(name='name', description='The name of the file. The name can be up to 1,024 bytes in length based on the UTF-8 encoding rule and cannot end with a forward slash (/).', example='a.txt'),
  parallelUpload?: boolean(name='parallel_upload', description='Specifies whether to enable the parallel upload feature.', example='true'),
  parentFileId?: string(name='parent_file_id', description='The ID of the parent directory. If you want to create a file or folder in the root directory, set this parameter to root.', example='fileid1'),
  partInfoList?: [ 
    {
      contentMd5?: string(name='content_md5', example='ASKJDJSKDJJSJDJS'),
      parallelSha1Ctx?: {
        h?: [ long ](name='h', description='该分片前所有数据的SHA1上下文的第1-5个32位变量，该字段只在多分片并发上传的模式下有效'),
        partOffset?: long(name='part_offset', description='到上一个数据块为止的总长度，字节，需要为64的倍数，该字段只在多分片并发上传的模式下有效', example='10240'),
      }(name='parallel_sha1_ctx', description='该分片前所有数据的SHA1上下文，该字段只在多分片并发上传的模式下有效'),
      partNumber?: int32(name='part_number', description='The serial number of a part. The number starts from 1.', example='1'),
    }
  ](name='part_info_list', description='The information about the file parts. You can specify up to 10,000 parts. By default, if you do not specify this parameter, only one part is returned.'),
  preHash?: string(name='pre_hash', description='The SHA-1 hash value of the first 1 KB data of the file. This parameter is required if you perform instant file upload by using the pre-hashing feature. If the SHA-1 hash value is not matched on the cloud, the client does not need to calculate the SHA-1 hash value of the entire file.', example='7C4A8D09CA3762AF61E59520943DC26494F89411'),
  shareId?: string(name='share_id', description='The share ID. This parameter is required if the file is uploaded by using the share URL of the file.', example='7JQX1FswpQ8'),
  size?: long(name='size', description='The file size. Unit: bytes.', example='1024'),
  type?: string(name='type', description='The type of the file. Valid values:

file folder', example='file'),
  userTags?: [
    UserTag
  ](name='user_tags', description='The custom tags. You can specify up to 1,000 tags.'),
  videoMediaMetadata?: VideoMediaMetadata(name='video_media_metadata', description='The information about the video specified by the client.'),
}

model CreateFileResponseBody = {
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  exist?: boolean(name='exist', description='Indicates whether the file exists.', example='false'),
  fileId?: string(name='file_id', description='The file ID.', example='fileid1'),
  fileName?: string(name='file_name', description='The file name.', example='a.txt'),
  parentFileId?: string(name='parent_file_id', description='The ID of the parent directory.', example='fileid5'),
  partInfoList?: [
    UploadPartInfo
  ](name='part_info_list', description='The information about the file parts.'),
  rapidUpload?: boolean(name='rapid_upload', description='Indicates whether the file is instantly uploaded.', example='true'),
  status?: string(name='status', description='The state of the file.', example='uploading'),
  type?: string(name='type', description='The type of the file.', example='file'),
  uploadId?: string(name='upload_id', description='The ID of the upload task.', example='uploadid1'),
}

model CreateFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFileResponseBody(name='body'),
}

async function createFileWithOptions(request: CreateFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkNameMode)) {
    body['check_name_mode'] = request.checkNameMode;
  }
  if (!Util.isUnset(request.contentHash)) {
    body['content_hash'] = request.contentHash;
  }
  if (!Util.isUnset(request.contentHashName)) {
    body['content_hash_name'] = request.contentHashName;
  }
  if (!Util.isUnset(request.contentType)) {
    body['content_type'] = request.contentType;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.hidden)) {
    body['hidden'] = request.hidden;
  }
  if (!Util.isUnset(request.imageMediaMetadata)) {
    body['image_media_metadata'] = request.imageMediaMetadata;
  }
  if (!Util.isUnset(request.localCreatedAt)) {
    body['local_created_at'] = request.localCreatedAt;
  }
  if (!Util.isUnset(request.localModifiedAt)) {
    body['local_modified_at'] = request.localModifiedAt;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.parallelUpload)) {
    body['parallel_upload'] = request.parallelUpload;
  }
  if (!Util.isUnset(request.parentFileId)) {
    body['parent_file_id'] = request.parentFileId;
  }
  if (!Util.isUnset(request.partInfoList)) {
    body['part_info_list'] = request.partInfoList;
  }
  if (!Util.isUnset(request.preHash)) {
    body['pre_hash'] = request.preHash;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.size)) {
    body['size'] = request.size;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }
  if (!Util.isUnset(request.userTags)) {
    body['user_tags'] = request.userTags;
  }
  if (!Util.isUnset(request.videoMediaMetadata)) {
    body['video_media_metadata'] = request.videoMediaMetadata;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function createFile(request: CreateFileRequest): CreateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFileWithOptions(request, headers, runtime);
}

model CreateGroupRequest {
  description?: string(name='description', description='The description of the group. The description can be up to 1,024 characters in length.', example='test group description'),
  groupName?: string(name='group_name', description='The name of the group. The name must be 1 to 128 characters in length.', example='test group'),
  isRoot?: boolean(name='is_root', description='Specifies whether the group is a root group. A root group cannot be added to any other group. In most cases, a root group is the top-level organization in the organizational structure.', example='false'),
  parentGroupId?: string(name='parent_group_id', description='The ID of the parent group to which the group is added. If this parameter is specified, the system automatically adds the group to the specified parent group after the group is created.', example='2e43ec8427dd45f19431b7504649a1b3'),
}

model CreateGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Group  
}

async function createGroupWithOptions(request: CreateGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.groupName)) {
    body['group_name'] = request.groupName;
  }
  if (!Util.isUnset(request.isRoot)) {
    body['is_root'] = request.isRoot;
  }
  if (!Util.isUnset(request.parentGroupId)) {
    body['parent_group_id'] = request.parentGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateGroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function createGroup(request: CreateGroupRequest): CreateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createGroupWithOptions(request, headers, runtime);
}

model CreateIdentityToBenefitPkgMappingRequest {
  amount?: long(name='amount', description='The number of benefit packages.

This parameter takes effect only for the benefit packages of the resource type. Default value: 1.', example='1'),
  benefitPkgId?: string(name='benefit_pkg_id', description='The unique identifier of the benefit package.', example='40cb7794c9294'),
  expireTime?: long(name='expire_time', description='The time when the benefit package expires. Set the value to a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.

By default, the benefit package never expires.', example='1633167071000'),
  identityId?: string(name='identity_id', description='The unique identifier of the entity.

If you want to manage the benefits of a user, set this parameter to a user ID.', example='user123'),
  identityType?: string(name='identity_type', description='The type of the entity.

If you want to manage the benefits of a user, set this parameter to user.', example='user'),
}

model CreateIdentityToBenefitPkgMappingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * If you need to manage a large number of users based on Drive and Photo Service, you can control the features and quotas that users can use based on the benefits to which they are entitled. For more information, join the DingTalk group (ID 23146118).
  *
  * @param request CreateIdentityToBenefitPkgMappingRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateIdentityToBenefitPkgMappingResponse
 */
async function createIdentityToBenefitPkgMappingWithOptions(request: CreateIdentityToBenefitPkgMappingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIdentityToBenefitPkgMappingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.amount)) {
    body['amount'] = request.amount;
  }
  if (!Util.isUnset(request.benefitPkgId)) {
    body['benefit_pkg_id'] = request.benefitPkgId;
  }
  if (!Util.isUnset(request.expireTime)) {
    body['expire_time'] = request.expireTime;
  }
  if (!Util.isUnset(request.identityId)) {
    body['identity_id'] = request.identityId;
  }
  if (!Util.isUnset(request.identityType)) {
    body['identity_type'] = request.identityType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIdentityToBenefitPkgMapping',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/benefit/identity_to_benefit_pkg_mapping/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * If you need to manage a large number of users based on Drive and Photo Service, you can control the features and quotas that users can use based on the benefits to which they are entitled. For more information, join the DingTalk group (ID 23146118).
  *
  * @param request CreateIdentityToBenefitPkgMappingRequest
  * @return CreateIdentityToBenefitPkgMappingResponse
 */
async function createIdentityToBenefitPkgMapping(request: CreateIdentityToBenefitPkgMappingRequest): CreateIdentityToBenefitPkgMappingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIdentityToBenefitPkgMappingWithOptions(request, headers, runtime);
}

model CreateOrderRequest {
  autoPay?: boolean(name='auto_pay'),
  autoRenew?: boolean(name='auto_renew'),
  code?: string(name='code'),
  instanceId?: string(name='instance_id'),
  orderType?: string(name='order_type'),
  package?: string(name='package'),
  period?: long(name='period'),
  periodUnit?: string(name='period_unit'),
  totalSize?: long(name='total_size'),
  userCount?: long(name='user_count'),
}

model CreateOrderResponseBody = {
  instanceId?: string(name='instance_id'),
  orderId?: string(name='order_id'),
}

model CreateOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrderResponseBody(name='body'),
}

async function createOrderWithOptions(request: CreateOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateOrderResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoPay)) {
    body['auto_pay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoRenew)) {
    body['auto_renew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.code)) {
    body['code'] = request.code;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['instance_id'] = request.instanceId;
  }
  if (!Util.isUnset(request.orderType)) {
    body['order_type'] = request.orderType;
  }
  if (!Util.isUnset(request.package)) {
    body['package'] = request.package;
  }
  if (!Util.isUnset(request.period)) {
    body['period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    body['period_unit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.totalSize)) {
    body['total_size'] = request.totalSize;
  }
  if (!Util.isUnset(request.userCount)) {
    body['user_count'] = request.userCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrder',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/create_order`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function createOrder(request: CreateOrderRequest): CreateOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createOrderWithOptions(request, headers, runtime);
}

model CreateShareLinkRequest {
  description?: string(name='description', description='The description of the share. The description must be 0 to 1,024 characters in length.'),
  disableDownload?: boolean(name='disable_download', description='Specifies whether to disable the download feature.', example='false'),
  disablePreview?: boolean(name='disable_preview', description='Specifies whether to disable the preview feature.', example='false'),
  disableSave?: boolean(name='disable_save', description='Specifies whether to disable the dump feature.', example='false'),
  downloadLimit?: long(name='download_limit', description='The limit on the number of times that the shared files can be downloaded. The value of this parameter must be equal to or greater than 0. A value of 0 indicates no limit.', example='100'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  expiration?: string(name='expiration', description='The time when the share URL expires. The value of this parameter follows the RFC 3339 standard. Example: "2020-06-28T11:33:00.000+08:00". If expiration is set to "", the share URL never expires.', example='2020-06-28T11:33:00.000+08:00'),
  fileIdList?: [ string ](name='file_id_list', description='The IDs of the files to share in the parent path. The number of files in the parent path ranges from 1 to 100. If share_all_files is set to true, this parameter does not take effect. Otherwise, you must specify this parameter.``', example='["520b217f13adf4fc24f2191991b1664ce045b393"]'),
  officeEditable?: boolean(name='office_editable'),
  previewLimit?: long(name='preview_limit', description='The limit on the number of times that the shared files can be previewed. The value of this parameter must be equal to or greater than 0. A value of 0 indicates no limit.', example='100'),
  saveLimit?: long(name='save_limit', description='The limit on the number of times that the shared files can be dumped. The value of this parameter must be equal to or greater than 0. A value of 0 indicates no limit.', example='100'),
  shareAllFiles?: boolean(name='share_all_files', description='Specifies whether to share all files in the drive.', example='true'),
  shareName?: string(name='share_name', description='The name of the share. If you leave this parameter empty, the file name that corresponds to the first ID in the file ID list is used. The name must be 0 to 128 characters in length.'),
  sharePwd?: string(name='share_pwd', description='The access code. An access code must be 0 to 64 bytes in length. If you do not specify this parameter or leave this parameter empty, the files can be accessed without an access code. In this case, you do not need to specify the share_pwd parameter when you call an operation to query the share URL. The access code can contain only visible ASCII characters.', example='abcF123x'),
  userId?: string(name='user_id', description='The user ID.', example='u123'),
}

model CreateShareLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ShareLink  
}

/**
  * A share is a file view container. You can grant anonymous users the permissions to access files in the user drive by using the share URL. Anonymous users can access the files based on the granted permissions.
  *
  * @param request CreateShareLinkRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateShareLinkResponse
 */
async function createShareLinkWithOptions(request: CreateShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.disableDownload)) {
    body['disable_download'] = request.disableDownload;
  }
  if (!Util.isUnset(request.disablePreview)) {
    body['disable_preview'] = request.disablePreview;
  }
  if (!Util.isUnset(request.disableSave)) {
    body['disable_save'] = request.disableSave;
  }
  if (!Util.isUnset(request.downloadLimit)) {
    body['download_limit'] = request.downloadLimit;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.expiration)) {
    body['expiration'] = request.expiration;
  }
  if (!Util.isUnset(request.fileIdList)) {
    body['file_id_list'] = request.fileIdList;
  }
  if (!Util.isUnset(request.officeEditable)) {
    body['office_editable'] = request.officeEditable;
  }
  if (!Util.isUnset(request.previewLimit)) {
    body['preview_limit'] = request.previewLimit;
  }
  if (!Util.isUnset(request.saveLimit)) {
    body['save_limit'] = request.saveLimit;
  }
  if (!Util.isUnset(request.shareAllFiles)) {
    body['share_all_files'] = request.shareAllFiles;
  }
  if (!Util.isUnset(request.shareName)) {
    body['share_name'] = request.shareName;
  }
  if (!Util.isUnset(request.sharePwd)) {
    body['share_pwd'] = request.sharePwd;
  }
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * A share is a file view container. You can grant anonymous users the permissions to access files in the user drive by using the share URL. Anonymous users can access the files based on the granted permissions.
  *
  * @param request CreateShareLinkRequest
  * @return CreateShareLinkResponse
 */
async function createShareLink(request: CreateShareLinkRequest): CreateShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createShareLinkWithOptions(request, headers, runtime);
}

model CreateSimilarImageClusterTaskRequest {
  driveId?: string(name='drive_id', example='123'),
}

model CreateSimilarImageClusterTaskResponseBody = {
  taskId?: string(name='task_id', example='i:SimilarImageClustering-b67d53e7-2fe8-460f-9b95-1e93636923eb'),
}

model CreateSimilarImageClusterTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSimilarImageClusterTaskResponseBody(name='body'),
}

async function createSimilarImageClusterTaskWithOptions(request: CreateSimilarImageClusterTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSimilarImageClusterTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSimilarImageClusterTask',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/create_similar_image_cluster_task`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function createSimilarImageClusterTask(request: CreateSimilarImageClusterTaskRequest): CreateSimilarImageClusterTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSimilarImageClusterTaskWithOptions(request, headers, runtime);
}

model CreateStoryRequest {
  address?: Address(name='address'),
  customLabels?: map[string]string(name='custom_labels', deprecated='true'),
  driveId?: string(name='drive_id', example='1'),
  maxImageCount?: long(name='max_image_count', example='30'),
  minImageCount?: long(name='min_image_count', example='1'),
  storyEndTime?: string(name='story_end_time', example='2022-12-30T16:00:00Z'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
  storyName?: string(name='story_name'),
  storyStartTime?: string(name='story_start_time', example='2016-12-30T16:00:00Z'),
  storySubType?: string(name='story_sub_type', example='Food'),
  storyType?: string(name='story_type', example='TagMemory'),
}

model CreateStoryResponseBody = {
  driveId?: string(name='drive_id', example='1'),
}

model CreateStoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateStoryResponseBody(name='body'),
}

async function createStoryWithOptions(request: CreateStoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateStoryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.address)) {
    body['address'] = request.address;
  }
  if (!Util.isUnset(request.customLabels)) {
    body['custom_labels'] = request.customLabels;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.maxImageCount)) {
    body['max_image_count'] = request.maxImageCount;
  }
  if (!Util.isUnset(request.minImageCount)) {
    body['min_image_count'] = request.minImageCount;
  }
  if (!Util.isUnset(request.storyEndTime)) {
    body['story_end_time'] = request.storyEndTime;
  }
  if (!Util.isUnset(request.storyId)) {
    body['story_id'] = request.storyId;
  }
  if (!Util.isUnset(request.storyName)) {
    body['story_name'] = request.storyName;
  }
  if (!Util.isUnset(request.storyStartTime)) {
    body['story_start_time'] = request.storyStartTime;
  }
  if (!Util.isUnset(request.storySubType)) {
    body['story_sub_type'] = request.storySubType;
  }
  if (!Util.isUnset(request.storyType)) {
    body['story_type'] = request.storyType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateStory',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/create_story`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function createStory(request: CreateStoryRequest): CreateStoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createStoryWithOptions(request, headers, runtime);
}

model CreateUserRequest {
  avatar?: string(name='avatar', description='The URL of the profile picture.

If you specify the parameter in the HTTP URL format, the URL must start with http:// or https:// and can be up to 4 KB in size.

If you specify the parameter in the data URL format, the URL must start with data:// and be encoded in Base64. The URL can be up to 300 KB in size.', example='http://a.b.c/pds.jpg'),
  description?: string(name='description', description='The description of the user. The description can be up to 1,024 characters in length.', example='VIP用户'),
  email?: string(name='email', description='The email address.', example='123@pds.com'),
  groupInfoList?: [ 
    {
      groupId?: string(name='group_id', description='The group ID.', example='g123'),
    }
  ](name='group_info_list', description='The information about the group.'),
  nickName?: string(name='nick_name', description='The nickname of the user. The nickname can be up to 128 characters in length.', example='pdsuer'),
  phone?: string(name='phone', description='The phone number.', example='13900001111'),
  role?: string(name='role', description='The role of the user. Default value: user. Valid values:

*   superadmin
*   admin
*   user

If the domain can be divided into subdomains, the subdomain_super_admin and subdomain_admin roles are also supported.

Valid values:

*   subdomain_super_admin

    <!-- -->

    <!-- -->

    <!-- -->

*   subdomain_admin

    <!-- -->

    <!-- -->

    <!-- -->

*   superadmin

    <!-- -->

    <!-- -->

    <!-- -->

*   admin

    <!-- -->

    <!-- -->

    <!-- -->

*   user

    <!-- -->

    <!-- -->

    <!-- -->', example='user'),
  status?: string(name='status', description='The state of the user. Default value: enabled. Valid values:

*   enabled: The user is in a normal state.
*   disabled: The user is prohibited from logon.', example='enabled'),
  userData?: map[string]any(name='user_data', description='The custom data. The data can be up to 1,024 characters in length.', example='md'),
  userId?: string(name='user_id', description='The user ID. The ID can be up to 64 characters in length and cannot contain number signs (#).', example='pdsuserid1'),
  userName?: string(name='user_name', description='The username. The username can be up to 128 characters in length.', example='pdsusername'),
}

model CreateUserResponseBody = {
  avatar?: string(name='avatar', description='The URL of the profile picture.', example='http://aa.com/1.jpg'),
  createdAt?: long(name='created_at', description='The time when the user was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1639762579768'),
  creator?: string(name='creator', description='The user who created the user.', example='user1'),
  defaultDriveId?: string(name='default_drive_id', description='The ID of the default drive.', example='1'),
  description?: string(name='description', description='The description of the user.', example='vipuser'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  email?: string(name='email', description='The email address.', example='a@a.com'),
  nickName?: string(name='nick_name', description='The nickname of the user.', example='001'),
  phone?: string(name='phone', description='The phone number.', example='13900001111'),
  role?: string(name='role', description='The role of the user. Valid values:

*   superadmin
*   admin
*   user', example='admin'),
  status?: string(name='status', description='The state of the user. Valid values:

*   disabled: The user is prohibited from logon.
*   enabled: The user is in a normal state.', example='enabled'),
  updatedAt?: long(name='updated_at', description='The time when the user was modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1639762579768'),
  userData?: map[string]any(name='user_data', description='The custom data.'),
  userId?: string(name='user_id', description='The user ID.', example='dingding_abc001'),
  userName?: string(name='user_name', description='The username.', example='pds'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUserResponseBody(name='body'),
}

async function createUserWithOptions(request: CreateUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.avatar)) {
    body['avatar'] = request.avatar;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.email)) {
    body['email'] = request.email;
  }
  if (!Util.isUnset(request.groupInfoList)) {
    body['group_info_list'] = request.groupInfoList;
  }
  if (!Util.isUnset(request.nickName)) {
    body['nick_name'] = request.nickName;
  }
  if (!Util.isUnset(request.phone)) {
    body['phone'] = request.phone;
  }
  if (!Util.isUnset(request.role)) {
    body['role'] = request.role;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.userData)) {
    body['user_data'] = request.userData;
  }
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }
  if (!Util.isUnset(request.userName)) {
    body['user_name'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/create`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createUserWithOptions(request, headers, runtime);
}

model CsiGetFileInfoRequest {
  driveId?: string(name='drive_id', example='1'),
  fileId?: string(name='file_id', example='9520943DC264'),
  urlExpireSec?: int32(name='url_expire_sec', example='100'),
}

model CsiGetFileInfoResponseBody = {
  investigationInfo?: InvestigationInfo(name='investigation_info'),
  url?: string(name='url', example='https://data.aliyunpds.com/hz22%2F5d5b986facbec311ef844c25954f96821497b383%2F5d5b986f955410dd991646bb87c6b4e899eff525?Expires=xxx&OSSAccessKeyId=xxx&Signature=xxx'),
}

model CsiGetFileInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CsiGetFileInfoResponseBody(name='body'),
}

async function csiGetFileInfoWithOptions(request: CsiGetFileInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CsiGetFileInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.urlExpireSec)) {
    body['url_expire_sec'] = request.urlExpireSec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CsiGetFileInfo',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/csi/get_file_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function csiGetFileInfo(request: CsiGetFileInfoRequest): CsiGetFileInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return csiGetFileInfoWithOptions(request, headers, runtime);
}

model DeleteDomainRequest {
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
}

model DeleteDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteDomainWithOptions(request: DeleteDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainId)) {
    body['domain_id'] = request.domainId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomain',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function deleteDomain(request: DeleteDomainRequest): DeleteDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDomainWithOptions(request, headers, runtime);
}

model DeleteDriveRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
}

model DeleteDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteDriveWithOptions(request: DeleteDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function deleteDrive(request: DeleteDriveRequest): DeleteDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDriveWithOptions(request, headers, runtime);
}

model DeleteFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID or folder ID.', example='9520943DC264'),
}

model DeleteFileResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task. This parameter is returned only in asynchronous processing scenarios. You can call the [GetAsyncTask](~~440456~~) operation to query the information about the asynchronous task based on the task ID.', example='000e89fb-cf8f-11e9-8ab4-b6e980803a3b'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
}

model DeleteFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFileResponseBody(name='body'),
}

async function deleteFileWithOptions(request: DeleteFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function deleteFile(request: DeleteFileRequest): DeleteFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFileWithOptions(request, headers, runtime);
}

model DeleteGroupRequest {
  groupId?: string(name='group_id', description='The group ID.', example='g123'),
}

model DeleteGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteGroupWithOptions(request: DeleteGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function deleteGroup(request: DeleteGroupRequest): DeleteGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGroupWithOptions(request, headers, runtime);
}

model DeleteRevisionRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
  revisionId?: string(name='revision_id', description='The version ID.', example='40CB7794C929'),
}

model DeleteRevisionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteRevisionWithOptions(request: DeleteRevisionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRevisionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.revisionId)) {
    body['revision_id'] = request.revisionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRevision',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/revision/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function deleteRevision(request: DeleteRevisionRequest): DeleteRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRevisionWithOptions(request, headers, runtime);
}

model DeleteStoryRequest {
  driveId?: string(name='drive_id', example='1'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model DeleteStoryResponseBody = {
  driveId?: string(name='drive_id', example='1'),
}

model DeleteStoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteStoryResponseBody(name='body'),
}

async function deleteStoryWithOptions(request: DeleteStoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteStoryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.storyId)) {
    body['story_id'] = request.storyId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteStory',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/delete_story`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function deleteStory(request: DeleteStoryRequest): DeleteStoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteStoryWithOptions(request, headers, runtime);
}

model DeleteUserRequest {
  userId?: string(name='user_id', description='The user ID.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteUserWithOptions(request, headers, runtime);
}

model DeltaGetLastCursorRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  syncRootId?: string(name='sync_root_id', description='The ID of the root file of the synced folder.', example='622fb09598ae66777c7040109a16f49381f6abe1'),
}

model DeltaGetLastCursorResponseBody = {
  cursor?: string(name='cursor', description='The latest cursor of incremental information in the specified drive or synced folder.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model DeltaGetLastCursorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeltaGetLastCursorResponseBody(name='body'),
}

async function deltaGetLastCursorWithOptions(request: DeltaGetLastCursorRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeltaGetLastCursorResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.syncRootId)) {
    body['sync_root_id'] = request.syncRootId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeltaGetLastCursor',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get_last_cursor`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function deltaGetLastCursor(request: DeltaGetLastCursorRequest): DeltaGetLastCursorResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deltaGetLastCursorWithOptions(request, headers, runtime);
}

model DownloadFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', description='The method used to generate the thumbnail of an image. If this parameter is specified, you are redirected to the URL of the generated thumbnail.', example='image/resize,m_fill,h_128,w_128,limit_0'),
  officeThumbnailProcess?: string(name='office_thumbnail_process', description='The method used to generate the thumbnail of a document. If this parameter is specified, you are redirected to the URL of the generated thumbnail.', example='image/resize,w_200'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a share link, carry the `x-share-token` header for authentication in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify one of `share_id` and `drive_id`.', example='7JQX1FswpQ8'),
  videoThumbnailProcess?: string(name='video_thumbnail_process', description='The method used to generate the thumbnail of a video. If this parameter is specified, you are redirected to the URL of the generated thumbnail.', example='video/snapshot,t_7000,f_jpg,w_800,h_600,m_fast'),
}

model DownloadFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

/**
  * For information about best practices for downloading a file.
  *
  * @param request DownloadFileRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return DownloadFileResponse
 */
async function downloadFileWithOptions(request: DownloadFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DownloadFileResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    query['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    query['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    query['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.officeThumbnailProcess)) {
    query['office_thumbnail_process'] = request.officeThumbnailProcess;
  }
  if (!Util.isUnset(request.shareId)) {
    query['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.videoThumbnailProcess)) {
    query['video_thumbnail_process'] = request.videoThumbnailProcess;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DownloadFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/download`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'binary',
  };
  return execute(params, req, runtime);
}

/**
  * For information about best practices for downloading a file.
  *
  * @param request DownloadFileRequest
  * @return DownloadFileResponse
 */
async function downloadFile(request: DownloadFileRequest): DownloadFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return downloadFileWithOptions(request, headers, runtime);
}

model FileAddPermissionRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The ID of the folder. If you want to authorize a user or group to access a team drive, set this parameter to root. If you want to authorize a user or group to access an individual drive, you cannot set this parameter to root.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406'),
  memberList?: [
    FilePermissionMember
  ](name='member_list', description='The members that are authorized to access files.'),
}

model FileAddPermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function fileAddPermissionWithOptions(request: FileAddPermissionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FileAddPermissionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.memberList)) {
    body['member_list'] = request.memberList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FileAddPermission',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/add_permission`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function fileAddPermission(request: FileAddPermissionRequest): FileAddPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fileAddPermissionWithOptions(request, headers, runtime);
}

model FileDeleteUserTagsRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
  keyList?: [ string ](name='key_list', description='The tags that you want to remove from a file. You cannot leave this parameter empty. You can specify up to 1,000 tags.'),
}

model FileDeleteUserTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function fileDeleteUserTagsWithOptions(request: FileDeleteUserTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FileDeleteUserTagsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.keyList)) {
    body['key_list'] = request.keyList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FileDeleteUserTags',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/delete_usertags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function fileDeleteUserTags(request: FileDeleteUserTagsRequest): FileDeleteUserTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fileDeleteUserTagsWithOptions(request, headers, runtime);
}

model FileListPermissionRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='4221bf6e6ab43a255edc4463bffa6f5f5d317401'),
}

model FileListPermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [
    FilePermissionMember
  ](name='body'),
}

async function fileListPermissionWithOptions(request: FileListPermissionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FileListPermissionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FileListPermission',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/list_permission`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return execute(params, req, runtime);
}

async function fileListPermission(request: FileListPermissionRequest): FileListPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fileListPermissionWithOptions(request, headers, runtime);
}

model FilePutUserTagsRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
  userTags?: [ 
    {
      key?: string(name='key', description='The name of the tag. The tag name cannot be empty and cannot contain number signs (#).', example='tag'),
      value?: string(name='value', description='The value of the tag. The tag value cannot contain number signs (#).', example='value'),
    }
  ](name='user_tags', description='The tags to be added to the file. You cannot leave this parameter empty. You can specify up to 1,000 tags. You cannot specify tags that have the same name.'),
}

model FilePutUserTagsResponseBody = {
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
}

model FilePutUserTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FilePutUserTagsResponseBody(name='body'),
}

/**
  * This operation is an incremental update operation. Take note of the following items:
  * *   If a tag name specified in the request is the same as an existing tag name, the existing tag is overwritten.
  * *   If a tag name specified in the request is different from the existing tag names, the specified tag is added.
  * *   The existing tags with unique names are not affected.
  *
  * @param request FilePutUserTagsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return FilePutUserTagsResponse
 */
async function filePutUserTagsWithOptions(request: FilePutUserTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FilePutUserTagsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.userTags)) {
    body['user_tags'] = request.userTags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FilePutUserTags',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/put_usertags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * This operation is an incremental update operation. Take note of the following items:
  * *   If a tag name specified in the request is the same as an existing tag name, the existing tag is overwritten.
  * *   If a tag name specified in the request is different from the existing tag names, the specified tag is added.
  * *   The existing tags with unique names are not affected.
  *
  * @param request FilePutUserTagsRequest
  * @return FilePutUserTagsResponse
 */
async function filePutUserTags(request: FilePutUserTagsRequest): FilePutUserTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return filePutUserTagsWithOptions(request, headers, runtime);
}

model FileRemovePermissionRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406'),
  memberList?: [ 
    {
      identity?: Identity(name='identity', description='The identity to whom the permissions are granted, which is a user or a group.'),
      roleId?: string(name='role_id', description='The role ID. You can grant permissions by assigning roles to identities, or you can customize the permissions. To grant permissions by assigning roles to identities, specify role_id. role_id and action_list are mutually exclusive. If both parameters are specified, role_id has a higher priority.

Valid values:

SystemFileOwner: collaborator.

SystemFileDownloader: downloader.

SystemFileEditor: editor.

SystemFileEditorWithoutDelete: editor without permissions to delete the file.

SystemFileEditorWithoutShareLink: editor without permissions to share the file.

SystemFileMetaViewer: viewer of lists.

SystemFileUploader: uploader. SystemFileUploaderAndDownloader: uploader and downloader.

SystemFileDownloaderWithShareLink: downloader and sharer.

SystemFileUploaderAndDownloaderWithShareLink: uploader, downloader, and sharer.

SystemFileUploaderAndViewer: viewer and uploader.

SystemFileUploaderWithShareLink: uploader and sharer.

SystemFileViewer: viewer.', example='SystemFileDownloader'),
    }
  ](name='member_list', description='The identities with whom the file is shared.'),
}

model FileRemovePermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function fileRemovePermissionWithOptions(request: FileRemovePermissionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FileRemovePermissionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.memberList)) {
    body['member_list'] = request.memberList;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FileRemovePermission',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/remove_permission`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function fileRemovePermission(request: FileRemovePermissionRequest): FileRemovePermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fileRemovePermissionWithOptions(request, headers, runtime);
}

model GetAsyncTaskRequest {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.', example='000e89fb-cf8f-11e9-8ab4-b6e980803a3b'),
}

model GetAsyncTaskResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.', example='000e89fb-cf8f-11e9-8ab4-b6e980803a3b'),
  category?: string(name='category', description='The custom category of the task.', example='album'),
  consumedProcess?: long(name='consumed_process', description='The total amount of work that is done in the asynchronous task, such as the number of files that are packaged for package download on the server.', example='100'),
  createdAt?: string(name='created_at', description='The time when the task was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. Example: 2019-03-28T13:03:29.298Z.', example='2019-08-20T06:51:27.292Z'),
  errCode?: long(name='err_code', description='**

**Warning **This parameter is no longer used. We recommend that you use error_code instead.

The error code returned if the asynchronous task failed.', example='InternalError'),
  errorCode?: string(name='error_code', description='The error code returned if the asynchronous task failed.', example='InternalError'),
  errorMessage?: string(name='error_message', description='The error message returned if the asynchronous task failed.', example='The request has been failed due to some unknown error. Please try again later.'),
  failedProcess?: long(name='failed_process'),
  finishedAt?: string(name='finished_at', description='The time when the task was complete. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. Example: 2019-03-28T13:03:29.298Z.', example='2019-08-20T06:51:27.292Z'),
  message?: string(name='message', description='**

**Warning **This parameter is no longer used. We recommend that you use error_message instead.

The error message returned if the asynchronous task failed.', example='The request has been failed due to some unknown error. Please try again later.'),
  skippedProcess?: long(name='skipped_process'),
  startedAt?: string(name='started_at', description='The time when the task was started. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. Example: 2019-03-28T13:03:29.298Z.', example='2019-08-20T06:51:27.292Z'),
  state?: string(name='state', description='The state of the task. Valid values:

*   Failed
*   Running
*   PartialSucceed
*   Succeed', example='Succeed'),
  status?: string(name='status', description='**

**Warning **This parameter is no longer used. We recommend that you use state instead.

The state of the task. Valid values:

*   Failed
*   Running
*   PartialSucceed
*   Succeed', example='Succeed'),
  totalProcess?: long(name='total_process', description='The total amount of work to be done in the asynchronous task, such as the number of files to be packaged for package download on the server.', example='1000'),
  uncompressFileList?: [
    UncompressedFileInfo
  ](name='uncompress_file_list', description='The extracted files.'),
  url?: string(name='url', description='The download URL of the data generated by the asynchronous task, such as the download URL of the packaged files generated by the task of package download on the server.', example='https://data.aliyunpds.com/hz22%2F5d5b986facbec311ef844c25954f96821497b383%2F5d5b986f955410dd991646bb87c6b4e899eff525?Expires=xxx&OSSAccessKeyId=xxx&Signature=xxx'),
}

model GetAsyncTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAsyncTaskResponseBody(name='body'),
}

async function getAsyncTaskWithOptions(request: GetAsyncTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAsyncTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.asyncTaskId)) {
    body['async_task_id'] = request.asyncTaskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetAsyncTask',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/async_task/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getAsyncTask(request: GetAsyncTaskRequest): GetAsyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAsyncTaskWithOptions(request, headers, runtime);
}

model GetDefaultDriveRequest {
  userId?: string(name='user_id', description='The user ID. If you use an AccessKey pair for authentication, you must specify this parameter. If you use an access token for authentication, this parameter is optional. By default, the user ID associated with the access token is used.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
}

model GetDefaultDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Drive  
}

async function getDefaultDriveWithOptions(request: GetDefaultDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDefaultDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDefaultDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/get_default_drive`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getDefaultDrive(request: GetDefaultDriveRequest): GetDefaultDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDefaultDriveWithOptions(request, headers, runtime);
}

model GetDomainRequest {
  domainId?: string(name='domain_id', description='The ID of the domain.', example='bj1'),
  getQuotaUsed?: boolean(name='get_quota_used', description='Specifies whether to return the used quota of the domain. Default value: false. If the quota of the domain is greater than 0 and you set this parameter to true, the used quota of the domain is returned.', example='true'),
}

model GetDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Domain  
}

async function getDomainWithOptions(request: GetDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainId)) {
    body['domain_id'] = request.domainId;
  }
  if (!Util.isUnset(request.getQuotaUsed)) {
    body['get_quota_used'] = request.getQuotaUsed;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDomain',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getDomain(request: GetDomainRequest): GetDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDomainWithOptions(request, headers, runtime);
}

model GetDomainQuotaResponseBody = {
  sizeQuota?: long(name='size_quota'),
  sizeUsed?: long(name='size_used'),
  userCountQuota?: long(name='user_count_quota'),
  userCountUsed?: long(name='user_count_used'),
}

model GetDomainQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDomainQuotaResponseBody(name='body'),
}

async function getDomainQuotaWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetDomainQuotaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDomainQuota',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/get_quota`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getDomainQuota(): GetDomainQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDomainQuotaWithOptions(headers, runtime);
}

model GetDownloadUrlRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  expireSec?: int32(name='expire_sec', description='The validity period of the download URL. Maximum value: 115200. Default value: 900. Unit: seconds.', example='100'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
  fileName?: string(name='file_name', description='The name of the file. The name can be up to 1,024 characters in length.', example='1.txt'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a sharing link, carry the `x-share-token` header in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify at least either `share_id` or `drive_id`.', example='7JQX1FswpQ8'),
}

model GetDownloadUrlResponseBody = {
  cdnUrl?: string(name='cdn_url', description='The download URL of a file that is downloaded by using Alibaba Cloud CDN.', example='https://data-cdn.aliyunpds.com/hz22%2F5d79219b0aa9a7c995a94a96993ba3205cd91c5a%2F5d79219bf3261a5d38744da0834ed489b677a27a?Expires=xxxOSSAccessKeyId=xxx&Signature=xxx&response-content-disposition=attachment%3Bfilename%3DtBiZAoJPC2c8b13450eda4292b7f5f8010618e078.txt'),
  contentHash?: string(name='content_hash', description='The hash value of the file content.', example='EA4942AA8761213890A5C386F88E6464D2C31CA1'),
  contentHashName?: string(name='content_hash_name', description='The name of the algorithm that is used to calculate the hash value of the file content.', example='sha1'),
  crc64Hash?: string(name='crc64_hash', description='The hash value calculated by using 64-bit cyclic redundancy check (CRC-64).', example='5498595269368962671'),
  expiration?: string(name='expiration', description='The time when the download URL expires.', example='2022-01-02T15:04:05.999Z07:00'),
  internalUrl?: string(name='internal_url', description='The download URL of a file that is downloaded over a virtual private cloud (VPC).', example='https://data-vpc.aliyunpds.com/hz22%2F5d79219b0aa9a7c995a94a96993ba3205cd91c5a%2F5d79219bf3261a5d38744da0834ed489b677a27a?Expires=xxxOSSAccessKeyId=xxx&Signature=xxx&response-content-disposition=attachment%3Bfilename%3DtBiZAoJPC2c8b13450eda4292b7f5f8010618e078.txt'),
  size?: long(name='size', description='The size of the file. Unit: bytes.', example='10'),
  url?: string(name='url', description='The download URL of a file that is downloaded over the Internet.', example='https://data.aliyunpds.com/hz22%2F5d79219b0aa9a7c995a94a96993ba3205cd91c5a%2F5d79219bf3261a5d38744da0834ed489b677a27a?Expires=xxxOSSAccessKeyId=xxx&Signature=xxx&response-content-disposition=attachment%3Bfilename%3DtBiZAoJPC2c8b13450eda4292b7f5f8010618e078.txt'),
}

model GetDownloadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDownloadUrlResponseBody(name='body'),
}

async function getDownloadUrlWithOptions(request: GetDownloadUrlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDownloadUrlResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.expireSec)) {
    body['expire_sec'] = request.expireSec;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.fileName)) {
    body['file_name'] = request.fileName;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDownloadUrl',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get_download_url`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getDownloadUrl(request: GetDownloadUrlRequest): GetDownloadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDownloadUrlWithOptions(request, headers, runtime);
}

model GetDriveRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
}

model GetDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Drive  
}

async function getDriveWithOptions(request: GetDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getDrive(request: GetDriveRequest): GetDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDriveWithOptions(request, headers, runtime);
}

model GetFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fields?: string(name='fields', description='The fields to return.

1.  If this parameter is set to \\*, all fields of the file except the fields that must be specified are returned.
2.  If only specific fields are required, you can specify the following fields: url, thumbnail, exif, cropping_suggestion, characteristic_hash, video_metadata, and video_preview_metadata. If multiple fields are required, separate them with commas (,). Example: url,thumbnail.
3.  The investigation_info field is returned only if you specify this field.

By default, all fields except the fields that must be specified are returned.', example='*'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a share link, carry the `x-share-token` header for authentication in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify one of `share_id` and `drive_id`.', example='7JQX1FswpQ8'),
  thumbnailProcesses?: map[string]ImageProcess(name='thumbnail_processes', description='缩略图配置，可一次性返回最多5个缩略图，map的key可以自定义，返回时按key返回对应的缩略图链接'),
  urlExpireSec?: int32(name='url_expire_sec', description='The time when the file expires. Unit: seconds. Valid values: 10 to 14400.', example='100'),
}

model GetFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: File  
}

async function getFileWithOptions(request: GetFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.thumbnailProcesses)) {
    body['thumbnail_processes'] = request.thumbnailProcesses;
  }
  if (!Util.isUnset(request.urlExpireSec)) {
    body['url_expire_sec'] = request.urlExpireSec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getFile(request: GetFileRequest): GetFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFileWithOptions(request, headers, runtime);
}

model GetGroupRequest {
  groupId?: string(name='group_id', description='The group ID.', example='2e43ec8427dd45f19431b7504649a1b1'),
}

model GetGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Group  
}

async function getGroupWithOptions(request: GetGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetGroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getGroup(request: GetGroupRequest): GetGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getGroupWithOptions(request, headers, runtime);
}

model GetIdentityToBenefitPkgMappingRequest {
  benefitPkgId?: string(name='benefit_pkg_id', description='The unique identifier of the benefit package.', example='40cb7794c9294'),
  identityId?: string(name='identity_id', description='The unique identifier of the entity.

If you want to manage the benefits of a user, set this parameter to a user ID.', example='user123'),
  identityType?: string(name='identity_type', description='The type of the entity. If you want to manage the benefits of a user, set this parameter to user.', example='user'),
}

model GetIdentityToBenefitPkgMappingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: IdentityToBenefitPkgMapping  
}

async function getIdentityToBenefitPkgMappingWithOptions(request: GetIdentityToBenefitPkgMappingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetIdentityToBenefitPkgMappingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.benefitPkgId)) {
    body['benefit_pkg_id'] = request.benefitPkgId;
  }
  if (!Util.isUnset(request.identityId)) {
    body['identity_id'] = request.identityId;
  }
  if (!Util.isUnset(request.identityType)) {
    body['identity_type'] = request.identityType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetIdentityToBenefitPkgMapping',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/benefit/identity_to_benefit_pkg_mapping/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getIdentityToBenefitPkgMapping(request: GetIdentityToBenefitPkgMappingRequest): GetIdentityToBenefitPkgMappingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getIdentityToBenefitPkgMappingWithOptions(request, headers, runtime);
}

model GetLinkInfoRequest {
  extra?: string(name='extra'),
  identity?: string(name='identity', example='130***'),
  type?: string(name='type', example='mobile'),
}

model GetLinkInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AccountLinkInfo  
}

async function getLinkInfoWithOptions(request: GetLinkInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLinkInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extra)) {
    body['extra'] = request.extra;
  }
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetLinkInfo',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/account/get_link_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getLinkInfo(request: GetLinkInfoRequest): GetLinkInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLinkInfoWithOptions(request, headers, runtime);
}

model GetLinkInfoByUserIdRequest {
  userId?: string(name='user_id', description='The user ID.', example='xxx'),
}

model GetLinkInfoByUserIdResponseBody = {
  items?: [
    AccountLinkInfo
  ](name='items', description='The information about the users.'),
}

model GetLinkInfoByUserIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLinkInfoByUserIdResponseBody(name='body'),
}

async function getLinkInfoByUserIdWithOptions(request: GetLinkInfoByUserIdRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLinkInfoByUserIdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetLinkInfoByUserId',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/account/get_link_info_by_user_id`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getLinkInfoByUserId(request: GetLinkInfoByUserIdRequest): GetLinkInfoByUserIdResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLinkInfoByUserIdWithOptions(request, headers, runtime);
}

model GetRevisionRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fields?: string(name='fields', description='Specifies the returned fields.

By default, this parameter is left empty. If you set this parameter to \\*, all fields are returned. If you leave this parameter empty, the creator of the file is not returned.', example='*'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
  revisionId?: string(name='revision_id', description='The version ID.', example='40CB7794C929'),
  urlExpireSec?: long(name='url_expire_sec', description='The validity period of the file download or preview. Valid values: 10 to 86400.

Default value: 900. Unit: seconds.', example='900'),
}

model GetRevisionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Revision  
}

async function getRevisionWithOptions(request: GetRevisionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRevisionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.revisionId)) {
    body['revision_id'] = request.revisionId;
  }
  if (!Util.isUnset(request.urlExpireSec)) {
    body['url_expire_sec'] = request.urlExpireSec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetRevision',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/revision/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getRevision(request: GetRevisionRequest): GetRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRevisionWithOptions(request, headers, runtime);
}

model GetShareLinkRequest {
  shareId?: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8'),
}

model GetShareLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ShareLink  
}

async function getShareLinkWithOptions(request: GetShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getShareLink(request: GetShareLinkRequest): GetShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getShareLinkWithOptions(request, headers, runtime);
}

model GetShareLinkByAnonymousRequest {
  shareId?: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8'),
}

model GetShareLinkByAnonymousResponseBody = {
  accessCount?: long(name='access_count', description='The number of times that the shared files are visited.', example='30'),
  avatar?: string(name='avatar', description='The profile picture of the user who created the share link.', example='https://aliyunpds.com/a.jpg'),
  creatorId?: string(name='creator_id', description='The ID of the user who created the share link.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
  creatorName?: string(name='creator_name', description='The name of the user who created the share link. The value is masked.', example='AB***CD'),
  creatorPhone?: string(name='creator_phone', description='The mobile number of the user who created the share link. The value is masked.', example='136****00'),
  disableDownload?: boolean(name='disable_download', description='Indicates whether the downloads of the shared files are prohibited.', example='false'),
  disablePreview?: boolean(name='disable_preview', description='Indicates whether the previews of the shared files are prohibited.', example='false'),
  disableSave?: boolean(name='disable_save', description='Indicates whether the saves of the shared files are prohibited.', example='false'),
  downloadCount?: long(name='download_count', description='The number of times that the shared files are downloaded.', example='50'),
  downloadLimit?: long(name='download_limit', description='The maximum number of times that the shared files can be downloaded.', example='100'),
  expiration?: string(name='expiration', description='The time when the share link expires.', example='2020-08-20T06:51:27.292Z'),
  previewCount?: long(name='preview_count', description='The number of times that the shared files are previewed.', example='80'),
  previewLimit?: long(name='preview_limit', description='The maximum number of times that the shared files can be previewed.', example='100'),
  reportCount?: long(name='report_count', description='The number of times that the shared files are reported.', example='0'),
  saveCount?: long(name='save_count', description='The number of times that the shared files are saved.', example='2'),
  saveDownloadLimit?: long(name='save_download_limit', description='The maximum number of times that the shared files can be saved and downloaded.', example='200'),
  saveLimit?: long(name='save_limit', description='The maximum number of times that the shared files can be saved.', example='100'),
  shareName?: string(name='share_name', description='The name of the share link.'),
  updatedAt?: string(name='updated_at', description='The time when the share link was last modified.', example='2019-08-20T06:51:27.292Z'),
  videoPreviewCount?: long(name='video_preview_count', description='The number of times that the videos are previewed in the shared files.', example='5'),
}

model GetShareLinkByAnonymousResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetShareLinkByAnonymousResponseBody(name='body'),
}

async function getShareLinkByAnonymousWithOptions(request: GetShareLinkByAnonymousRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetShareLinkByAnonymousResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetShareLinkByAnonymous',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/get_by_anonymous`,
    method = 'POST',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getShareLinkByAnonymous(request: GetShareLinkByAnonymousRequest): GetShareLinkByAnonymousResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getShareLinkByAnonymousWithOptions(request, headers, runtime);
}

model GetShareLinkTokenRequest {
  expireSec?: int32(name='expire_sec', description='The validity period of the token. Valid values: (0,7200]. Default value: 7200. Unit: seconds.', example='7200'),
  shareId?: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8'),
  sharePwd?: string(name='share_pwd', description='The access code.', example='abcF123x'),
}

model GetShareLinkTokenResponseBody = {
  expiresIn?: long(name='expires_in', description='The validity period of the token. Unit: seconds. For example, a value of 7200 indicates two hours.', example='7200'),
  shareToken?: string(name='share_token', description='The JSON Web Token (JWT).', example='eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJjOWI3YTVhYTA0ZDE0YWUzODY3ZmRjODg2ZmEwMWRhNCIsImN1c3RvbUpzb24iOiJ7XCJjbGllbnRJZFwiOlwiMjVkelgzdmJZcWt0Vnh5WFwiLFwiZG9tYWluSWRcIjpcImJqMjlcIixcInNjb3BlXCI6W1wiRFJJVkUuQUxMXCIsXCJTSEFSRS5BTExcIixcIkZJTEUuQUxMXCIsXCJVU0VSLkFMTFwiLFwiVklFVy5BTExcIixcIlNUT1JBR0UuQUxMXCIsXCJTVE9SQUdFRklMRS5MSVNUXCIsXCJCQVRDSFwiLFwiT0FVVEguQUxMXCIsXCJJTUFHRS5BTExcIixcIklOVklURS5BTExcIixcIkFDQ09VTlQuQUxMXCJdLFwicm9sZVwiOlwidXNlclwiLFwicmVmXCI6XCJodHRwczovL3d3dy5hbGl5dW5kcml2ZS5jb20vXCIsXCJkZXZpY2VfaWRcIjpcImIyODIwNWU1YzU5NzRjY2JiODI3MDNiNjhkYjhjNDUxXCJ9IiwiZXhwIjoxNjQ4NjE0NDkzLCJpYXQiOjE2NDg2MDcyMzN9.d3HVLvv_LFw2QhPrhvjH_kICWQJX9sKKt7NjQEqI_xE2JO_b7D8rPsFTZz93PLvZ7MhCmudTjGImUpd-ehFnI4Go-1S7BGaKaHFILvP-sWy18Wpikowjxx9mSbzBM_cO6D1LI-kyYhXKWHgVdADfVIPniTDA7-ffhUpi7cAebEs'),
}

model GetShareLinkTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetShareLinkTokenResponseBody(name='body'),
}

/**
  * To access a file by using a share link, you must first obtain a share token, even if the value of share_pwd of this share is an empty string, which specifies that the share is not private.
  *
  * @param request GetShareLinkTokenRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetShareLinkTokenResponse
 */
async function getShareLinkTokenWithOptions(request: GetShareLinkTokenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetShareLinkTokenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.expireSec)) {
    body['expire_sec'] = request.expireSec;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.sharePwd)) {
    body['share_pwd'] = request.sharePwd;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetShareLinkToken',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/get_share_token`,
    method = 'POST',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * To access a file by using a share link, you must first obtain a share token, even if the value of share_pwd of this share is an empty string, which specifies that the share is not private.
  *
  * @param request GetShareLinkTokenRequest
  * @return GetShareLinkTokenResponse
 */
async function getShareLinkToken(request: GetShareLinkTokenRequest): GetShareLinkTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getShareLinkTokenWithOptions(request, headers, runtime);
}

model GetStoryRequest {
  coverImageThumbnailProcess?: string(name='cover_image_thumbnail_process', example='image/resize,m_fill,h_128,w_128,limit_0/format,jpg', deprecated='true'),
  coverVideoThumbnailProcess?: string(name='cover_video_thumbnail_process', example='video/snapshot,t_1000,f_jpg,w_0,h_0,m_fast,ar_auto', deprecated='true'),
  driveId?: string(name='drive_id', example='1'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', example='image/resize,m_fill,h_128,w_128,limit_0/format,jpg', deprecated='true'),
  imageUrlProcess?: string(name='image_url_process', example='image/resize,m_fill,h_128,w_128,limit_0/format,jpg', deprecated='true'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
  urlExpireSec?: long(name='url_expire_sec', example='900', deprecated='true'),
  videoThumbnailProcess?: string(name='video_thumbnail_process', example='video/snapshot,t_1000,f_jpg,w_0,h_0,m_fast,ar_auto', deprecated='true'),
}

model GetStoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Story  
}

async function getStoryWithOptions(request: GetStoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetStoryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.coverImageThumbnailProcess)) {
    body['cover_image_thumbnail_process'] = request.coverImageThumbnailProcess;
  }
  if (!Util.isUnset(request.coverVideoThumbnailProcess)) {
    body['cover_video_thumbnail_process'] = request.coverVideoThumbnailProcess;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    body['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.imageUrlProcess)) {
    body['image_url_process'] = request.imageUrlProcess;
  }
  if (!Util.isUnset(request.storyId)) {
    body['story_id'] = request.storyId;
  }
  if (!Util.isUnset(request.urlExpireSec)) {
    body['url_expire_sec'] = request.urlExpireSec;
  }
  if (!Util.isUnset(request.videoThumbnailProcess)) {
    body['video_thumbnail_process'] = request.videoThumbnailProcess;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetStory',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/get_story`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getStory(request: GetStoryRequest): GetStoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getStoryWithOptions(request, headers, runtime);
}

model GetTaskStatusRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  taskId?: string(name='task_id', description='The ID of the task.', example='i:SimilarImageClustering-b67d53e7-2fe8-460f-9b95-1e93636923eb'),
}

model GetTaskStatusResponseBody = {
  status?: string(name='status', description='The state of the task.

Valid values:

*   running

    <!-- -->

    : The task is

    <!-- -->

    running

    <!-- -->

    .

*   failed

    <!-- -->

    : The task

    <!-- -->

    fails

    <!-- -->

    .

*   succeeded

    <!-- -->

    : The task is

    <!-- -->

    successful

    <!-- -->

    .', example='running'),
}

model GetTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskStatusResponseBody(name='body'),
}

/**
  * **Before you call this operation, make sure that you are familiar with the [billing](~~425220~~) of Drive and Photo Service**.
  * To call this operation, make sure that the value-added image processing feature is enabled.
  * Before you call this operation, a value-added asynchronous task must be created. For example, you can call the CreateSimilarImageClusterTask operation to create an asynchronous task. Then, you can call this operation to query the execution status of the asynchronous task based on the task ID.
  *
  * @param request GetTaskStatusRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetTaskStatusResponse
 */
async function getTaskStatusWithOptions(request: GetTaskStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTaskStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['task_id'] = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskStatus',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/get_task_status`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * **Before you call this operation, make sure that you are familiar with the [billing](~~425220~~) of Drive and Photo Service**.
  * To call this operation, make sure that the value-added image processing feature is enabled.
  * Before you call this operation, a value-added asynchronous task must be created. For example, you can call the CreateSimilarImageClusterTask operation to create an asynchronous task. Then, you can call this operation to query the execution status of the asynchronous task based on the task ID.
  *
  * @param request GetTaskStatusRequest
  * @return GetTaskStatusResponse
 */
async function getTaskStatus(request: GetTaskStatusRequest): GetTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTaskStatusWithOptions(request, headers, runtime);
}

model GetUploadUrlRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='5d5b846942cf94fa72324c14a4bda34e81da635d'),
  partInfoList?: [ 
    {
      contentMd5?: string(name='content_md5'),
      contentType?: string(name='content_type'),
      parallelSha1Ctx?: {
        h?: [ long ](name='h', description='The first to fifth 32-bit variables of the SHA-1 hash value of the file content before the file part. This parameter takes effect only if the parallel upload feature is enabled.'),
        partOffset?: long(name='part_offset', description='The size of the file part. Unit: bytes. The value must be a multiple of 64. This parameter takes effect only if the parallel upload feature is enabled.', example='10240'),
      }(name='parallel_sha1_ctx', description='The SHA-1 hash value of the file content before the file part. This parameter takes effect only if the parallel upload feature is enabled.'),
      partNumber?: int32(name='part_number', description='The serial number of a part.', example='1'),
    }
  ](name='part_info_list', description='The information about the file parts.'),
  shareId?: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8'),
  uploadId?: string(name='upload_id', description='The ID of the upload task.', example='10166D06127B413BA1EC8ABB1144D111'),
}

model GetUploadUrlResponseBody = {
  createAt?: string(name='create_at', description='The time when the upload task was created.', example='2019-09-11T16:34:36.977Z'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='5d5b846942cf94fa72324c14a4bda34e81da635d'),
  partInfoList?: [
    UploadPartInfo
  ](name='part_info_list', description='The information about the file parts.'),
  uploadId?: string(name='upload_id', description='The ID of the upload task.', example='10166D06127B413BA1EC8ABB1144D111'),
}

model GetUploadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUploadUrlResponseBody(name='body'),
}

async function getUploadUrlWithOptions(request: GetUploadUrlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUploadUrlResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.partInfoList)) {
    body['part_info_list'] = request.partInfoList;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.uploadId)) {
    body['upload_id'] = request.uploadId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetUploadUrl',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get_upload_url`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getUploadUrl(request: GetUploadUrlRequest): GetUploadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUploadUrlWithOptions(request, headers, runtime);
}

model GetUserRequest {
  userId?: string(name='user_id', description='The user ID. If you use an AccessKey pair to access Drive and Photo Service, you must specify this parameter. If you use an access token to access Drive and Photo Service, you do not need to specify this parameter, and Drive and Photo Service automatically finds the user ID contained in the access token.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
}

model GetUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: User  
}

async function getUserWithOptions(request: GetUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getUserWithOptions(request, headers, runtime);
}

model GetVideoPreviewPlayInfoRequest {
  category?: string(name='category', description='The preview type. You must enable the corresponding video transcoding feature. Valid values:

*   live_transcoding: previews a live stream while transcoding is in progress.
*   quick_video: previews a video while transcoding is in progress.
*   offline_audio: previews a piece of audio after the audio is transcoded offline.
*   offline_video: previews a video after the video is transcoded offline.', example='live_transcoding'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
  getMasterUrl?: boolean(name='get_master_url'),
  getWithoutUrl?: boolean(name='get_without_url', description='Specifies whether not to query the playback URL. If you set this parameter to true, only transcoding metadata is returned. The video is not transcoded in the TS format, and the playback URL is not returned. If you set this parameter to false, the playback URL is returned. If the video has not been transcoded by using the template specified by template_id, the transcoding process is triggered. You are charged for the value-added service fees generated for transcoding.', example='true'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a sharing link, carry the `x-share-token` header in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify at least either `share_id` or `drive_id`.', example='7JQX1FswpQ8'),
  templateId?: string(name='template_id', description='The ID of the definition template. If you leave this parameter empty, all definition templates are available.', example='264_480p'),
  urlExpireSec?: long(name='url_expire_sec', description='The validity period of the video preview. Unit: seconds. Default value: 900. Maximum value: 14400.', example='3600'),
}

model GetVideoPreviewPlayInfoResponseBody = {
  code?: string(name='code', example='VideoPreviewWaitAndRetry'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='fileid1'),
  masterUrl?: string(name='master_url'),
  message?: string(name='message', example='media is transcoding, please wait and retry.'),
  shareId?: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8'),
  videoPreviewPlayInfo?: VideoPreviewPlayInfo(name='video_preview_play_info', description='The information about video playback.'),
}

model GetVideoPreviewPlayInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVideoPreviewPlayInfoResponseBody(name='body'),
}

/**
  * For more information about best practices, see [Preview videos online](~~427477~~).
  *
  * @param request GetVideoPreviewPlayInfoRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetVideoPreviewPlayInfoResponse
 */
async function getVideoPreviewPlayInfoWithOptions(request: GetVideoPreviewPlayInfoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetVideoPreviewPlayInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.category)) {
    body['category'] = request.category;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.getMasterUrl)) {
    body['get_master_url'] = request.getMasterUrl;
  }
  if (!Util.isUnset(request.getWithoutUrl)) {
    body['get_without_url'] = request.getWithoutUrl;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.templateId)) {
    body['template_id'] = request.templateId;
  }
  if (!Util.isUnset(request.urlExpireSec)) {
    body['url_expire_sec'] = request.urlExpireSec;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetVideoPreviewPlayInfo',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get_video_preview_play_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * For more information about best practices, see [Preview videos online](~~427477~~).
  *
  * @param request GetVideoPreviewPlayInfoRequest
  * @return GetVideoPreviewPlayInfoResponse
 */
async function getVideoPreviewPlayInfo(request: GetVideoPreviewPlayInfoRequest): GetVideoPreviewPlayInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getVideoPreviewPlayInfoWithOptions(request, headers, runtime);
}

model GetVideoPreviewPlayMetaRequest {
  category?: string(name='category', description='The preview type. You must enable the corresponding video transcoding feature. Valid values:

*   live_transcoding: previews a live stream while transcoding is in progress.
*   quick_video: previews a video while transcoding is in progress.
*   offline_audio: previews a piece of audio after the audio is transcoded offline.
*   offline_video: previews a video after the video is transcoded offline.', example='live_transcoding'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a sharing link, carry the `x-share-token` header in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify at least either `share_id` or `drive_id`.', example='7JQX1FswpQ8'),
}

model GetVideoPreviewPlayMetaResponseBody = {
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='fileid1'),
  shareId?: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8'),
  videoPreviewPlayMeta?: VideoPreviewPlayMeta(name='video_preview_play_meta', description='The preview metadata of the video.'),
}

model GetVideoPreviewPlayMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVideoPreviewPlayMetaResponseBody(name='body'),
}

/**
  * For more information about best practices, see [Preview videos online](~~427477~~).
  *
  * @param request GetVideoPreviewPlayMetaRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return GetVideoPreviewPlayMetaResponse
 */
async function getVideoPreviewPlayMetaWithOptions(request: GetVideoPreviewPlayMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetVideoPreviewPlayMetaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.category)) {
    body['category'] = request.category;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetVideoPreviewPlayMeta',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/get_video_preview_play_meta`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * For more information about best practices, see [Preview videos online](~~427477~~).
  *
  * @param request GetVideoPreviewPlayMetaRequest
  * @return GetVideoPreviewPlayMetaResponse
 */
async function getVideoPreviewPlayMeta(request: GetVideoPreviewPlayMetaRequest): GetVideoPreviewPlayMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getVideoPreviewPlayMetaWithOptions(request, headers, runtime);
}

model GroupUpdateNameRequest {
  groupId?: string(name='group_id'),
  name?: string(name='name'),
}

model GroupUpdateNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function groupUpdateNameWithOptions(request: GroupUpdateNameRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GroupUpdateNameResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GroupUpdateName',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/update_name`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function groupUpdateName(request: GroupUpdateNameRequest): GroupUpdateNameResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return groupUpdateNameWithOptions(request, headers, runtime);
}

model ImportUserRequest {
  authenticationDisplayName?: string(name='authentication_display_name', description='The display name of the authentication type.', example='10000'),
  authenticationType?: string(name='authentication_type', description='The authentication type. Valid values:

*   mobile: mobile number.
*   email: email address.
*   ding: DingTalk account.
*   ram: Alibaba Cloud Resource Access Management (RAM) user.
*   wechat: WeCom account.
*   ldap: Lightweight Directory Access Protocol (LDAP) account.
*   custom: custom account.', example='mobile'),
  autoCreateDrive?: boolean(name='auto_create_drive', description='Specifies whether to automatically create a drive.', example='false'),
  driveTotalSize?: long(name='drive_total_size', description='The size of the drive. The value cannot be smaller than -1. A value of -1 specifies that the size is unlimited.', example='10240'),
  extra?: string(name='extra', description='The additional information.

If authentication_type is set to mobile, set this parameter to a country code. If you do not specify this parameter, 86 is used by default.', example='1'),
  identity?: string(name='identity', description='The unique identifier.', example='130****'),
  nickName?: string(name='nick_name', description='The nickname of the user.', example='pdsuer'),
  parentGroupId?: string(name='parent_group_id', description='The ID of the group to which the user is added.', example='g12'),
}

model ImportUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: User  
}

async function importUserWithOptions(request: ImportUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ImportUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.authenticationDisplayName)) {
    body['authentication_display_name'] = request.authenticationDisplayName;
  }
  if (!Util.isUnset(request.authenticationType)) {
    body['authentication_type'] = request.authenticationType;
  }
  if (!Util.isUnset(request.autoCreateDrive)) {
    body['auto_create_drive'] = request.autoCreateDrive;
  }
  if (!Util.isUnset(request.driveTotalSize)) {
    body['drive_total_size'] = request.driveTotalSize;
  }
  if (!Util.isUnset(request.extra)) {
    body['extra'] = request.extra;
  }
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }
  if (!Util.isUnset(request.nickName)) {
    body['nick_name'] = request.nickName;
  }
  if (!Util.isUnset(request.parentGroupId)) {
    body['parent_group_id'] = request.parentGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ImportUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/import`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function importUser(request: ImportUserRequest): ImportUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return importUserWithOptions(request, headers, runtime);
}

model InvestigateFileRequest {
  driveFileIds?: [ 
    {
      driveId?: string(name='drive_id', example='1'),
      fileId?: string(name='file_id', example='9520943DC264'),
    }
  ](name='drive_file_ids'),
}

model InvestigateFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function investigateFileWithOptions(request: InvestigateFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InvestigateFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveFileIds)) {
    body['drive_file_ids'] = request.driveFileIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InvestigateFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/csi/investigate_file`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function investigateFile(request: InvestigateFileRequest): InvestigateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return investigateFileWithOptions(request, headers, runtime);
}

model LinkAccountRequest {
  extra?: string(name='extra', description='The additional information about the unique identifier of the account. For example, if type is set to mobile, set the value of extra to a country code. For example, a value of 86 specifies a mobile number in the Chinese mainland. If you do not specify this parameter, 86 is used by default.', example='86'),
  identity?: string(name='identity', description='The unique identifier of the account, such as a mobile number.', example='eyy***'),
  type?: string(name='type', description='The account type. Valid values:

*   mobile: a mobile number.
*   email: an email address.
*   ding: a DingTalk account.
*   ram: an Alibaba Cloud Resource Access Management (RAM) user.
*   wechat: a WeCom account.
*   ldap: a Lightweight Directory Access Protocol (LDAP) account.
*   custom: a custom account.', example='ding'),
  userId?: string(name='user_id', description='The ID of the user with which you want to associate an account.', example='xxx'),
}

model LinkAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Token  
}

async function linkAccountWithOptions(request: LinkAccountRequest, headers: map[string]string, runtime: Util.RuntimeOptions): LinkAccountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extra)) {
    body['extra'] = request.extra;
  }
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'LinkAccount',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/account/link`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function linkAccount(request: LinkAccountRequest): LinkAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return linkAccountWithOptions(request, headers, runtime);
}

model ListAddressGroupsRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', description='The method that is used to generate a thumbnail of an image.', example='image/resize,w_200'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  videoThumbnailProcess?: string(name='video_thumbnail_process', description='The method that is used to generate a thumbnail of a video.', example='video_thumbnail_process'),
}

model ListAddressGroupsResponseBody = {
  items?: [
    AddressGroup
  ](name='items', description='The information about the location-based groups.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListAddressGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAddressGroupsResponseBody(name='body'),
}

async function listAddressGroupsWithOptions(request: ListAddressGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAddressGroupsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    body['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.videoThumbnailProcess)) {
    body['video_thumbnail_process'] = request.videoThumbnailProcess;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAddressGroups',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/list_address_groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listAddressGroups(request: ListAddressGroupsRequest): ListAddressGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAddressGroupsWithOptions(request, headers, runtime);
}

model ListAssignmentRequest {
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  manageResourceId?: string(name='manage_resource_id', description='The ID of the managed resource, such as a group ID.', example='105***b82'),
  manageResourceType?: string(name='manage_resource_type', description='The type of the managed resource. Set the value to RT_Group, which specifies that the administrators of a group are queried.', example='RT_Group'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListAssignmentResponseBody = {
  assignmentList?: [ 
    {
      createdAt?: long(name='created_at', description='The time when the role was assigned. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1622682267564'),
      creator?: string(name='creator', description='The ID of the user who assigned the role.', example='216***c83'),
      domainId?: string(name='domain_id', description='The domain ID.', example='hz1'),
      identity?: Identity(name='identity', description='The identity to whom the role is assigned, which is a user or a group.'),
      manageResourceId?: string(name='manage_resource_id', description='The ID of the managed resource, such as a group ID.', example='105***b82'),
      manageResourceType?: string(name='manage_resource_type', description='The type of the managed resource. For example, a value of RT_Group indicates group.', example='RT_Group'),
      roleId?: string(name='role_id', description='The ID of the role assigned to the identity.', example='SystemGroupAdmin'),
    }
  ](name='assignment_list', description='The assigned roles.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListAssignmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAssignmentResponseBody(name='body'),
}

async function listAssignmentWithOptions(request: ListAssignmentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAssignmentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.manageResourceId)) {
    body['manage_resource_id'] = request.manageResourceId;
  }
  if (!Util.isUnset(request.manageResourceType)) {
    body['manage_resource_type'] = request.manageResourceType;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAssignment',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/role/list_assignment`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listAssignment(request: ListAssignmentRequest): ListAssignmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAssignmentWithOptions(request, headers, runtime);
}

model ListDeltaRequest {
  cursor?: string(name='cursor', description='The cursor of the incremental information.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 0 to 100. Default value: 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  syncRootId?: string(name='sync_root_id', description='The ID of the root file of the synced folder.', example='622fb09598ae66777c7040109a16f49381f6abe1'),
}

model ListDeltaResponseBody = {
  cursor?: string(name='cursor', description='The cursor of the incremental information.', example='1WQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  hasMore?: boolean(name='has_more', description='Indicates whether more information is returned.', example='true'),
  items?: [ 
    {
      file?: File(name='file', description='The information about the file.'),
      fileId?: string(name='file_id', description='The file ID.', example='122fb09598ae66777c7040109a16f49381f6abe2'),
      op?: string(name='op', description='The operation that is performed. Valid values: Valid values:

*   create
*   overwrite
*   delete
*   update
*   move
*   trash
*   restore
*   rename', example='create'),
    }
  ](name='items', description='The incremental information returned.'),
}

model ListDeltaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeltaResponseBody(name='body'),
}

async function listDeltaWithOptions(request: ListDeltaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeltaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cursor)) {
    body['cursor'] = request.cursor;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.syncRootId)) {
    body['sync_root_id'] = request.syncRootId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDelta',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/list_delta`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listDelta(request: ListDeltaRequest): ListDeltaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeltaWithOptions(request, headers, runtime);
}

model ListDomainsRequest {
  limit?: long(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 50.', example='60'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  parentDomainId?: string(name='parent_domain_id', description='The ID of the parent domain.', example='bj1'),
}

model ListDomainsResponseBody = {
  items?: [
    Domain
  ](name='items', description='The information about the domains.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDomainsResponseBody(name='body'),
}

async function listDomainsWithOptions(request: ListDomainsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDomainsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.parentDomainId)) {
    body['parent_domain_id'] = request.parentDomainId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDomains',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listDomains(request: ListDomainsRequest): ListDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDomainsWithOptions(request, headers, runtime);
}

model ListDriveRequest {
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  owner?: string(name='owner', description='The owner of the drive. If this parameter is not specified, all drives are returned.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
  ownerType?: string(name='owner_type', description='The type of the owner. Valid values:

user and group.

By default, drives of all owner types are returned.', example='user'),
}

model ListDriveResponseBody = {
  items?: [
    Drive
  ](name='items', description='The queried drives.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDriveResponseBody(name='body'),
}

async function listDriveWithOptions(request: ListDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.owner)) {
    body['owner'] = request.owner;
  }
  if (!Util.isUnset(request.ownerType)) {
    body['owner_type'] = request.ownerType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listDrive(request: ListDriveRequest): ListDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDriveWithOptions(request, headers, runtime);
}

model ListFacegroupsRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  remarks?: string(name='remarks', description='The filter condition that is used to query groups. The value can be up to 128 characters in length. An exact match is used.'),
  returnTotalCount?: boolean(name='return_total_count'),
}

model ListFacegroupsResponseBody = {
  items?: [
    FaceGroup
  ](name='items', description='The information about the face-based groups.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  totalCount?: long(name='total_count'),
}

model ListFacegroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFacegroupsResponseBody(name='body'),
}

async function listFacegroupsWithOptions(request: ListFacegroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFacegroupsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.remarks)) {
    body['remarks'] = request.remarks;
  }
  if (!Util.isUnset(request.returnTotalCount)) {
    body['return_total_count'] = request.returnTotalCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFacegroups',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/list_facegroups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listFacegroups(request: ListFacegroupsRequest): ListFacegroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFacegroupsWithOptions(request, headers, runtime);
}

model ListFileRequest {
  category?: string(name='category', description='The category of the file. Valid values:

app: installation package. zip: compressed package. image: image. doc: document. video: video. audio: audio. others: other files.

By default, files of all categories are returned.', example='image'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fields?: string(name='fields', description='The fields to return.

1.  If this parameter is set to \\*, all fields of the file except the fields that must be specified are returned.
2.  If only specific fields are required, you can specify the following fields: url, exif, cropping_suggestion, characteristic_hash, video_metadata, and video_preview_metadata. If multiple fields are required, separate them with commas (,). Example: url,exif.
3.  The investigation_info field is returned only if you specify this field.

By default, all fields except the fields that must be specified are returned.', example='*'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  orderBy?: string(name='order_by', description='The sorting field.

Default value: created_at.

Valid values:

*   updated_at

    <!-- -->

    :

    <!-- -->

    sorts the results based on the time when the file was last modified

    <!-- -->

    .

*   size

    <!-- -->

    :

    <!-- -->

    sorts the results based on the size of the file

    <!-- -->

    .

*   name

    <!-- -->

    :

    <!-- -->

    sorts the results based on the name of the file

    <!-- -->

    .

*   created_at

    <!-- -->

    :

    <!-- -->

    sorts the results based on the time when the file was created

    <!-- -->

    .', example='updated_at'),
  orderDirection?: string(name='order_direction', description='The sorting direction. Valid values:

ASC: ascending order. DESC: descending order.

Default value: ASC.', example='ASC'),
  parentFileId?: string(name='parent_file_id', description='The ID of the parent folder. If the parent folder is a root directory, set this parameter to root.', example='root'),
  shareId?: string(name='share_id', description='The share ID. If you want to manage a file by using a share link, carry the `x-share-token` header for authentication in the request and specify share_id. In this case, `drive_id` is invalid. Otherwise, use an `AccessKey pair` or `access token` for authentication and specify `drive_id`. You must specify one of `share_id` and `drive_id`.', example='7JQX1FswpQ8'),
  status?: string(name='status', description='The state of the file. Valid values:

available: Only normal files are returned. uploading: Only files that are being uploaded are returned.

By default, only files in the available state are returned.', example='available'),
  thumbnailProcesses?: map[string]ImageProcess(name='thumbnail_processes', description='The thumbnail configurations. Up to five thumbnails can be returned at a time. The value contains key-value pairs. You can customize the keys. The URL of a thumbnail is returned based on the key.'),
  type?: string(name='type', description='The type of the file. Valid values:

file: Only files are returned. folder: Only folders are returned.

By default, files of all types are returned.', example='file'),
}

model ListFileResponseBody = {
  items?: [
    File
  ](name='items', description='The queried files.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFileResponseBody(name='body'),
}

async function listFileWithOptions(request: ListFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.category)) {
    body['category'] = request.category;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.orderBy)) {
    body['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    body['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.parentFileId)) {
    body['parent_file_id'] = request.parentFileId;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.thumbnailProcesses)) {
    body['thumbnail_processes'] = request.thumbnailProcesses;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listFile(request: ListFileRequest): ListFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFileWithOptions(request, headers, runtime);
}

model ListGroupRequest {
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListGroupResponseBody = {
  items?: [
    Group
  ](name='items', description='The information about the groups.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupResponseBody(name='body'),
}

async function listGroupWithOptions(request: ListGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListGroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listGroup(request: ListGroupRequest): ListGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupWithOptions(request, headers, runtime);
}

model ListGroupMemberRequest {
  groupId?: string(name='group_id', description='The ID of the group of which you want to query members.', example='3e5***2c2'),
  limit?: int32(name='limit', description='The total number of returned entries.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  memberType?: string(name='member_type', description='The member type. If you do not specify this parameter, both types of members are returned. Valid values:

*   user
*   group

Note: A group can be a member of only one group. It cannot be a member of multiple groups. A user can be a member of multiple groups.', example='user'),
}

model ListGroupMemberResponseBody = {
  groupItems?: [
    Group
  ](name='group_items', description='The information about the groups.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhM1'),
  userItems?: [
    User
  ](name='user_items', description='The information about the users.'),
}

model ListGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupMemberResponseBody(name='body'),
}

async function listGroupMemberWithOptions(request: ListGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGroupMemberResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.memberType)) {
    body['member_type'] = request.memberType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListGroupMember',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/list_member`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listGroupMember(request: ListGroupMemberRequest): ListGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGroupMemberWithOptions(request, headers, runtime);
}

model ListIdentityRoleRequest {
  identity?: Identity(name='identity'),
}

model ListIdentityRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BaseRoleMemberResponse  
}

async function listIdentityRoleWithOptions(request: ListIdentityRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIdentityRoleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListIdentityRole',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/role/list_identity_role`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listIdentityRole(request: ListIdentityRoleRequest): ListIdentityRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIdentityRoleWithOptions(request, headers, runtime);
}

model ListIdentityToBenefitPkgMappingRequest {
  identityId?: string(name='identity_id', description='The unique identifier of the entity.

If you call this operation to manage the benefits of a user, set this parameter to the ID of the user.', example='user123'),
  identityType?: string(name='identity_type', description='The type of the entity. If you call this operation to manage the benefits of a user, set this parameter to user.', example='user'),
  includeExpired?: boolean(name='include_expired', description='Specifies whether to return the benefit packages that expire. Default value: false.', example='false'),
}

model ListIdentityToBenefitPkgMappingResponseBody = {
  items?: [
    IdentityToBenefitPkgMapping
  ](name='items', description='The information about the benefit packages that are associated with an entity.'),
}

model ListIdentityToBenefitPkgMappingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIdentityToBenefitPkgMappingResponseBody(name='body'),
}

async function listIdentityToBenefitPkgMappingWithOptions(request: ListIdentityToBenefitPkgMappingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIdentityToBenefitPkgMappingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.identityId)) {
    body['identity_id'] = request.identityId;
  }
  if (!Util.isUnset(request.identityType)) {
    body['identity_type'] = request.identityType;
  }
  if (!Util.isUnset(request.includeExpired)) {
    body['include_expired'] = request.includeExpired;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListIdentityToBenefitPkgMapping',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/benefit/identity_to_benefit_pkg_mapping/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listIdentityToBenefitPkgMapping(request: ListIdentityToBenefitPkgMappingRequest): ListIdentityToBenefitPkgMappingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIdentityToBenefitPkgMappingWithOptions(request, headers, runtime);
}

model ListMyDrivesRequest {
  limit?: int32(name='limit', description='The maximum number of results to return. Default value: 100. Valid values: 1 to 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListMyDrivesResponseBody = {
  items?: [
    Drive
  ](name='items', description='The queried drives.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListMyDrivesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMyDrivesResponseBody(name='body'),
}

async function listMyDrivesWithOptions(request: ListMyDrivesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMyDrivesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMyDrives',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/list_my_drives`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listMyDrives(request: ListMyDrivesRequest): ListMyDrivesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMyDrivesWithOptions(request, headers, runtime);
}

model ListMyGroupDriveRequest {
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListMyGroupDriveResponseBody = {
  items?: [
    Drive
  ](name='items', description='The information about the team drives.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListMyGroupDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMyGroupDriveResponseBody(name='body'),
}

async function listMyGroupDriveWithOptions(request: ListMyGroupDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMyGroupDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMyGroupDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/list_my_group_drive`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listMyGroupDrive(request: ListMyGroupDriveRequest): ListMyGroupDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMyGroupDriveWithOptions(request, headers, runtime);
}

model ListReceivedFileRequest {
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is empty.', example='eym***'),
}

model ListReceivedFileResponseBody = {
  items?: [
    File
  ](name='items', description='The queried files.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='eym***'),
}

model ListReceivedFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListReceivedFileResponseBody(name='body'),
}

async function listReceivedFileWithOptions(request: ListReceivedFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListReceivedFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListReceivedFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/list_received_file`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listReceivedFile(request: ListReceivedFileRequest): ListReceivedFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listReceivedFileWithOptions(request, headers, runtime);
}

model ListRecyclebinRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fields?: string(name='fields', description='Specifies the returned fields.

1\\. If you set this parameter to \\*, all fields of the file are returned.

2\\. If you set this parameter to a null value or leave this parameter empty, the fields, such as file creator, file modifier, and custom tags, are not returned.

The default value is a null value, which indicates that only some fields are returned.', example='*'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 200. Default value: 50.

The number of returned results must be less than or equal to the specified number.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListRecyclebinResponseBody = {
  items?: [
    File
  ](name='items', description='The information about the files and folders in the recycle bin.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhM1'),
}

model ListRecyclebinResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRecyclebinResponseBody(name='body'),
}

async function listRecyclebinWithOptions(request: ListRecyclebinRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRecyclebinResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListRecyclebin',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/recyclebin/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listRecyclebin(request: ListRecyclebinRequest): ListRecyclebinResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRecyclebinWithOptions(request, headers, runtime);
}

model ListRevisionRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fields?: string(name='fields', description='Specifies the returned fields.

By default, this parameter is left empty. If you set this parameter to \\*, all fields are returned. If you leave this parameter empty, the creator of the file is not returned.', example='*'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
  limit?: long(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.

Default value: 50.

The number of returned results must be less than or equal to the specified number.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.

By default, this parameter is left empty.', example='40CB7794C929'),
}

model ListRevisionResponseBody = {
  items?: [
    Revision
  ](name='items', description='The information about the versions.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListRevisionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRevisionResponseBody(name='body'),
}

async function listRevisionWithOptions(request: ListRevisionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRevisionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListRevision',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/revision/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listRevision(request: ListRevisionRequest): ListRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRevisionWithOptions(request, headers, runtime);
}

model ListShareLinkRequest {
  creator?: string(name='creator', description='The creator of the share.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
  includeCancelled?: boolean(name='include_cancelled', description='Specifies whether to return the shares that are canceled.', example='true'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 0 to 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  orderBy?: string(name='order_by', description='The field by which to sort the returned results. Default value: created_at. Valid values:

*   share_name: sorts the results by the name of the share.
*   updated_at: sorts the results by the time when the share was modified.
*   description: sorts the results by the description of the share.
*   created_at: sorts the results by the time when the share was created.', example='share_name'),
  orderDirection?: string(name='order_direction', description='The order in which you want to sort the returned results. By default, order_direction is set to DESC if order_by is set to created_at or updated_at, and is set to ASC if order_by is set to other values. Valid values:

*   ASC: sorts the results in ascending order.
*   DESC: sorts the results in descending order.', example='ASC'),
}

model ListShareLinkResponseBody = {
  items?: [
    ShareLink
  ](name='items', description='The information about the shares.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListShareLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListShareLinkResponseBody(name='body'),
}

/**
  * This operation is discontinued. To query shares, you can call the SearchShareLink operation.
  *
  * @param request ListShareLinkRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListShareLinkResponse
 */
async function listShareLinkWithOptions(request: ListShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.creator)) {
    body['creator'] = request.creator;
  }
  if (!Util.isUnset(request.includeCancelled)) {
    body['include_cancelled'] = request.includeCancelled;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.orderBy)) {
    body['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    body['order_direction'] = request.orderDirection;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * This operation is discontinued. To query shares, you can call the SearchShareLink operation.
  *
  * @param request ListShareLinkRequest
  * @return ListShareLinkResponse
 */
async function listShareLink(request: ListShareLinkRequest): ListShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listShareLinkWithOptions(request, headers, runtime);
}

model ListTagsRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', description='The method that is used to generate the thumbnail of an image.', example='image/resize,w_200'),
  videoThumbnailProcess?: string(name='video_thumbnail_process', description='The method that is used to generate the thumbnail of a video.', example='video/snapshot,t_7000,f_jpg,w_800,h_600,m_fast'),
}

model ListTagsResponseBody = {
  tags?: [
    ImageTag
  ](name='tags', description='The information about the tags.'),
}

model ListTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagsResponseBody(name='body'),
}

/**
  * You can call this operation to query the tags within the specified drive at a time. The top 2,000 tags of the images are returned.
  *
  * @param request ListTagsRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListTagsResponse
 */
async function listTagsWithOptions(request: ListTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    body['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.videoThumbnailProcess)) {
    body['video_thumbnail_process'] = request.videoThumbnailProcess;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListTags',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/list_tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * You can call this operation to query the tags within the specified drive at a time. The top 2,000 tags of the images are returned.
  *
  * @param request ListTagsRequest
  * @return ListTagsResponse
 */
async function listTags(request: ListTagsRequest): ListTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagsWithOptions(request, headers, runtime);
}

model ListUploadedPartsRequest {
  driveId?: string(name='drive_id', description='The drive ID. This parameter is required if the file is not uploaded by using the share URL of the file.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='322fb07b975f4b0ae1b543fe8475eee4c19eb2b2'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  partNumberMarker?: int32(name='part_number_marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  shareId?: string(name='share_id', description='The share ID. This parameter is required if the file is uploaded by using the share URL of the file.', example='7JQX1FswpQ8'),
  uploadId?: string(name='upload_id', description='The ID of the upload task.', example='00166D06127B413BA1EC8ABB1144D101'),
}

model ListUploadedPartsResponseBody = {
  fileId?: string(name='file_id', description='The file ID.', example='322fb07b975f4b0ae1b543fe8475eee4c19eb2b2'),
  nextPartNumberMarker?: string(name='next_part_number_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  parallelUpload?: boolean(name='parallel_upload', description='Indicates whether the parallel upload feature is enabled.', example='false'),
  uploadId?: string(name='upload_id', description='The ID of the upload task.', example='00166D06127B413BA1EC8ABB1144D101'),
  uploadedParts?: [
    UploadPartInfo
  ](name='uploaded_parts', description='The information about the file parts.'),
}

model ListUploadedPartsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUploadedPartsResponseBody(name='body'),
}

async function listUploadedPartsWithOptions(request: ListUploadedPartsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListUploadedPartsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.partNumberMarker)) {
    body['part_number_marker'] = request.partNumberMarker;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.uploadId)) {
    body['upload_id'] = request.uploadId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListUploadedParts',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/list_uploaded_parts`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listUploadedParts(request: ListUploadedPartsRequest): ListUploadedPartsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUploadedPartsWithOptions(request, headers, runtime);
}

model ListUserRequest {
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker. By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListUserResponseBody = {
  items?: [
    User
  ](name='items', description='The information about the users.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ListUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserResponseBody(name='body'),
}

async function listUserWithOptions(request: ListUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function listUser(request: ListUserRequest): ListUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUserWithOptions(request, headers, runtime);
}

model MoveFileRequest {
  checkNameMode?: string(name='check_name_mode', description='The processing method that is used if the file that you want to move has the same name as an existing file in the destination directory. Valid values:

ignore: allows you to move the file by using the same name as an existing file in the destination directory.

auto_rename: automatically renames the file that has the same name exists in the destination directory. By default, the current point in time is added to the end of the file name. Example: xxx\\_20060102\\_150405.

refuse: does not move the file that you want to move but returns the information about the file that has the same name in the destination directory.

Default value: ignore.', example='ignore'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
  toParentFileId?: string(name='to_parent_file_id', description='The ID of the destination parent directory to which you want to move a file or folder. If you want to move a file or folder to the root directory, set this parameter to root.', example='6520943DC261'),
}

model MoveFileResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

If an empty string is returned, the file is moved.

If a non-empty string is returned, an asynchronous task is required. You can call the GetAsyncTask operation to obtain the information about an asynchronous task based on the task ID.', example='23ebd1a24dba4166b1527add476ef2866051b4d5del106'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  exist?: boolean(name='exist', description='Indicates whether the file already exists in the destination directory.', example='false'),
  fileId?: string(name='file_id', description='The file ID.', example='fileid1'),
}

model MoveFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MoveFileResponseBody(name='body'),
}

async function moveFileWithOptions(request: MoveFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MoveFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkNameMode)) {
    body['check_name_mode'] = request.checkNameMode;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.toParentFileId)) {
    body['to_parent_file_id'] = request.toParentFileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'MoveFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/move`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function moveFile(request: MoveFileRequest): MoveFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return moveFileWithOptions(request, headers, runtime);
}

model QueryOrderPriceRequest {
  code?: string(name='code'),
  instanceId?: string(name='instance_id'),
  orderType?: string(name='order_type'),
  package?: string(name='package'),
  period?: long(name='period'),
  periodUnit?: string(name='period_unit'),
  totalSize?: long(name='total_size'),
  userCount?: long(name='user_count'),
}

model QueryOrderPriceResponseBody = {
  discountPrice?: double(name='discount_price'),
  originalPrice?: double(name='original_price'),
  tradePrice?: double(name='trade_price'),
}

model QueryOrderPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryOrderPriceResponseBody(name='body'),
}

async function queryOrderPriceWithOptions(request: QueryOrderPriceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryOrderPriceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.code)) {
    body['code'] = request.code;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['instance_id'] = request.instanceId;
  }
  if (!Util.isUnset(request.orderType)) {
    body['order_type'] = request.orderType;
  }
  if (!Util.isUnset(request.package)) {
    body['package'] = request.package;
  }
  if (!Util.isUnset(request.period)) {
    body['period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    body['period_unit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.totalSize)) {
    body['total_size'] = request.totalSize;
  }
  if (!Util.isUnset(request.userCount)) {
    body['user_count'] = request.userCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryOrderPrice',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/query_order_price`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function queryOrderPrice(request: QueryOrderPriceRequest): QueryOrderPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryOrderPriceWithOptions(request, headers, runtime);
}

model RemoveFaceGroupFileRequest {
  driveId?: string(name='drive_id', example='123'),
  faceGroupId?: string(name='face_group_id', example='Cluster-abc'),
  fileId?: string(name='file_id', example='abcd'),
}

model RemoveFaceGroupFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function removeFaceGroupFileWithOptions(request: RemoveFaceGroupFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveFaceGroupFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.faceGroupId)) {
    body['face_group_id'] = request.faceGroupId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveFaceGroupFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/albums/unassign_facegroup_item`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function removeFaceGroupFile(request: RemoveFaceGroupFileRequest): RemoveFaceGroupFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeFaceGroupFileWithOptions(request, headers, runtime);
}

model RemoveGroupMemberRequest {
  groupId?: string(name='group_id', description='The ID of the group from which you want to remove a member.', example='3e5***2c2'),
  memberId?: string(name='member_id', description='The ID of the member. If member_type is set to user, set this parameter to the ID of the corresponding user.', example='2e4***1b1'),
  memberType?: string(name='member_type', description='The type of the member that you want to remove from the group. Only common users can be removed. If you want to remove all members from a group, you can directly delete the group. Valid value:

*   user

Note: A group can be a member of only one group. It cannot be a member of multiple groups. A user can be a member of multiple groups.', example='user'),
}

model RemoveGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function removeGroupMemberWithOptions(request: RemoveGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveGroupMemberResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }
  if (!Util.isUnset(request.memberId)) {
    body['member_id'] = request.memberId;
  }
  if (!Util.isUnset(request.memberType)) {
    body['member_type'] = request.memberType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveGroupMember',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/remove_member`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function removeGroupMember(request: RemoveGroupMemberRequest): RemoveGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeGroupMemberWithOptions(request, headers, runtime);
}

model RemoveStoryFilesRequest {
  driveId?: string(name='drive_id', example='1'),
  files?: [ 
    {
      fileId?: string(name='file_id', example='63e5e4340f76cb3ead5f40f68163f0f967c1a7bf'),
      revisionId?: string(name='revision_id', example='642a88dd06e49d9c0a14411ebae606f70edd9a59'),
    }
  ](name='files'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model RemoveStoryFilesResponseBody = {
  driveId?: string(name='drive_id', example='1'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model RemoveStoryFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveStoryFilesResponseBody(name='body'),
}

async function removeStoryFilesWithOptions(request: RemoveStoryFilesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveStoryFilesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.files)) {
    body['files'] = request.files;
  }
  if (!Util.isUnset(request.storyId)) {
    body['story_id'] = request.storyId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveStoryFiles',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/remove_story_files`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function removeStoryFiles(request: RemoveStoryFilesRequest): RemoveStoryFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeStoryFilesWithOptions(request, headers, runtime);
}

model RestoreFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The ID of the file or folder.', example='4221bf6e6ab43a255edc4463bffa6f5f5d317401'),
}

model RestoreFileResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

If an empty string is returned, the file or folder is restored.

If a non-empty string is returned, an asynchronous task is required. You can call the GetAsyncTask operation to obtain the information about an asynchronous task based on the task ID.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The ID of the file or folder.', example='4221bf6e6ab43a255edc4463bffa6f5f5d317401'),
}

model RestoreFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestoreFileResponseBody(name='body'),
}

async function restoreFileWithOptions(request: RestoreFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestoreFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RestoreFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/recyclebin/restore`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function restoreFile(request: RestoreFileRequest): RestoreFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restoreFileWithOptions(request, headers, runtime);
}

model RestoreRevisionRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
  revisionId?: string(name='revision_id', description='The version ID.', example='40CB7794C929'),
}

model RestoreRevisionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Revision  
}

async function restoreRevisionWithOptions(request: RestoreRevisionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestoreRevisionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.revisionId)) {
    body['revision_id'] = request.revisionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RestoreRevision',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/revision/restore`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function restoreRevision(request: RestoreRevisionRequest): RestoreRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restoreRevisionWithOptions(request, headers, runtime);
}

model ScanFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fields?: string(name='fields', description='The file properties to return.

*   If you want to return all file properties, set this parameter to \\*.
*   By default, if you do not specify this parameter, the following properties of a file are returned: - file_id, - drive_id, - parent_file_id, - type, - created_at, - updated_at, - file_extention, - size, - starred, - status, - category, and - permissions.
*   You can also specify properties to return. Separate multiple properties with commas (,).', example='*'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ScanFileResponseBody = {
  items?: [
    File
  ](name='items', description='The information about the files.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model ScanFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScanFileResponseBody(name='body'),
}

async function scanFileWithOptions(request: ScanFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ScanFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ScanFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/scan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function scanFile(request: ScanFileRequest): ScanFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return scanFileWithOptions(request, headers, runtime);
}

model SearchAddressGroupsRequest {
  addressLevel?: string(name='address_level', description='The level of the location.

Valid values:

*   country

    <!-- -->

    <!-- -->

    <!-- -->

*   province

    <!-- -->

    <!-- -->

    <!-- -->

*   city

    <!-- -->

    <!-- -->

    <!-- -->

*   district

    <!-- -->

    <!-- -->

    <!-- -->

*   township

    <!-- -->

    <!-- -->

    <!-- -->'),
  addressNames?: [ string ](name='address_names', description='The locations.'),
  brGeoPoint?: string(name='br_geo_point', description='The coordinates of the bottom right vertex of the rectangle. Set the value in the format of latitude,longitude.', example='40.121,105.2121'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', description='The method used to generate the thumbnail of an image.', example='image/resize,w_200'),
  tlGeoPoint?: string(name='tl_geo_point', description='The coordinates of the top left vertex of the rectangle. Set the value in the format of latitude,longitude.', example='39.121,101.2121'),
  videoThumbnailProcess?: string(name='video_thumbnail_process', description='The method used to generate the thumbnail of a video.', example='video/snapshot,t_7000,f_jpg,w_800,h_600,m_fast'),
}

model SearchAddressGroupsResponseBody = {
  items?: [
    AddressGroup
  ](name='items', description='The location-based groups.'),
}

model SearchAddressGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchAddressGroupsResponseBody(name='body'),
}

async function searchAddressGroupsWithOptions(request: SearchAddressGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchAddressGroupsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.addressLevel)) {
    body['address_level'] = request.addressLevel;
  }
  if (!Util.isUnset(request.addressNames)) {
    body['address_names'] = request.addressNames;
  }
  if (!Util.isUnset(request.brGeoPoint)) {
    body['br_geo_point'] = request.brGeoPoint;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    body['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.tlGeoPoint)) {
    body['tl_geo_point'] = request.tlGeoPoint;
  }
  if (!Util.isUnset(request.videoThumbnailProcess)) {
    body['video_thumbnail_process'] = request.videoThumbnailProcess;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchAddressGroups',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/search_address_groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function searchAddressGroups(request: SearchAddressGroupsRequest): SearchAddressGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchAddressGroupsWithOptions(request, headers, runtime);
}

model SearchDomainsRequest {
  instanceId?: string(name='instance_id', description='预付费domain支持按订单实例ID搜索，通过下单接口获取对应的实例ID', example='pds_trc_public_cn-h033e720j01'),
  limit?: long(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  name?: string(name='name', description='The name of the domain. Fuzzy search is supported.'),
  orderBy?: string(name='order_by', description='The sorting rule. Set the value to created_at, which specifies that the results are sorted based on the time when the domain was created.', example='created_at'),
}

model SearchDomainsResponseBody = {
  items?: [
    Domain
  ](name='items', description='The queried domains.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model SearchDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchDomainsResponseBody(name='body'),
}

async function searchDomainsWithOptions(request: SearchDomainsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchDomainsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['instance_id'] = request.instanceId;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    body['order_by'] = request.orderBy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchDomains',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function searchDomains(request: SearchDomainsRequest): SearchDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchDomainsWithOptions(request, headers, runtime);
}

model SearchDriveRequest {
  driveName?: string(name='drive_name', description='The drive name.'),
  limit?: int32(name='limit', description='The maximum number of asynchronous tasks to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  owner?: string(name='owner', description='The owner of the drive.', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
  ownerType?: string(name='owner_type', description='The type of the owner. Valid values:

user group', example='user'),
}

model SearchDriveResponseBody = {
  items?: [
    Drive
  ](name='items', description='The information about the drives.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model SearchDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchDriveResponseBody(name='body'),
}

async function searchDriveWithOptions(request: SearchDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveName)) {
    body['drive_name'] = request.driveName;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.owner)) {
    body['owner'] = request.owner;
  }
  if (!Util.isUnset(request.ownerType)) {
    body['owner_type'] = request.ownerType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function searchDrive(request: SearchDriveRequest): SearchDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchDriveWithOptions(request, headers, runtime);
}

model SearchFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fields?: string(name='fields', example='url,thumbnail'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  orderBy?: string(name='order_by', description='The field by which to sort the returned results. Default value: created_at. Valid values:

*   created_at: sorts the results by the time when the file was created.
*   updated_at: sorts the results by the time when the file was modified.
*   size: sorts the results by the size of the file.
*   name: sorts the results by the name of the file.

The order in which you want to sort the returned results. Valid values:

*   ASC: sorts the results in ascending order.
*   DESC: sorts the results in descending order.

You must specify this parameter in the \\<field name> \\<ASC or DESC> format. Separate multiple field names with commas (,). A preceding field has a higher priority than a following field. Examples:

*   If you want to sort the results based on the file name in ascending order, set this parameter to "name ASC".
*   If you want to sort the results based on the creation time in descending order, set this parameter to "created_at DESC".
*   If you want to sort the results based on the creation time in descending order first, and then sort the results based on the file name in ascending order if the creation time is the same, set this parameter to "created_at DESC,name ASC".', example='name'),
  query?: string(name='query', description='The search condition. Fuzzy searches based on the file name or directory name are supported. The search condition can be up to 4,096 characters in length.', example='not name=123'),
  returnTotalCount?: boolean(name='return_total_count', description='Specifies whether to return the total number of retrieved files.', example='true'),
}

model SearchFileResponseBody = {
  items?: [
    File
  ](name='items', description='The information about the files.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  totalCount?: long(name='total_count', description='The total number of retrieved files.', example='1022'),
}

model SearchFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchFileResponseBody(name='body'),
}

async function searchFileWithOptions(request: SearchFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fields)) {
    body['fields'] = request.fields;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.orderBy)) {
    body['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.query)) {
    body['query'] = request.query;
  }
  if (!Util.isUnset(request.returnTotalCount)) {
    body['return_total_count'] = request.returnTotalCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function searchFile(request: SearchFileRequest): SearchFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchFileWithOptions(request, headers, runtime);
}

model SearchShareLinkRequest {
  creators?: [ string ](name='creators', description='The creators of shares. Set this parameter to a user ID. If you do not specify this parameter, Drive and Photo Service automatically queries shares based on your permissions. If you are a drive administrator or the super administrator, the shares created by all members are queried. If you are a team administrator, the shares created by all team members are queried. If you are a common user, only the shares created by yourself are queried.

If you specify this parameter, this parameter must be set to the ID of the super administrator, a drive administrator, or a team administrator.'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.

The number of returned results must be less than or equal to the specified number.', example='50'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  orderBy?: string(name='order_by', description='The field by which to sort the returned results. Default value: created_at. Valid values:

*   share_name: sorts the results by the name of the share.
*   updated_at: sorts the results by the time when the share was modified.
*   description: sorts the results by the description of the share.
*   created_at: sorts the results by the time when the share was created.', example='created_at'),
  orderDirection?: string(name='order_direction', description='The order in which you want to sort the returned results. By default, order_direction is set to DESC if order_by is set to created_at or updated_at, and is set to ASC if order_by is set to other values. Valid values:

*   ASC: sorts the results in ascending order.
*   DESC: sorts the results in descending order.', example='ASC'),
  query?: string(name='query', description='The query condition that is used to search for share URLs. You can use the following fields to specify query conditions: created_at: queries a share URL based on the time when the share URL was created. updated_at: queries a share URL based on the time when the share URL was modified. share_name_for_fuzzy: queries a share URL based on the name of the share. A fuzzy match is supported. status: queries a share URL based on the status of the share. Valid values: enabled and disabled. A value of enabled indicates that the share is valid. A value of disabled indicates that the share is canceled. expired_time: queries a share URL based on the expiration time of the share. If the share never expires, set this field to 1970-01-01T00:00:00. Otherwise, set this field to 1970-01-02T00:00:00.', example='created_at>=\\"2022-01-18T02:50:00\\" and created_at<\\"2022-01-19T09:45:28\\" and share_name_for_fuzzy match \\"HD.mp4\\" and status in [\\"enabled\\", \\"disabled\\"] and expired_time=\\"1970-01-01T00:00:00\\"'),
  returnTotalCount?: boolean(name='return_total_count', description='Specifies whether to return the total number of returned results.', example='false'),
}

model SearchShareLinkResponseBody = {
  items?: [
    ShareLink
  ](name='items', description='The share URLs.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  totalCount?: long(name='total_count', description='The total number of entries returned.', example='101'),
}

model SearchShareLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchShareLinkResponseBody(name='body'),
}

async function searchShareLinkWithOptions(request: SearchShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.creators)) {
    body['creators'] = request.creators;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.orderBy)) {
    body['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    body['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.query)) {
    body['query'] = request.query;
  }
  if (!Util.isUnset(request.returnTotalCount)) {
    body['return_total_count'] = request.returnTotalCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function searchShareLink(request: SearchShareLinkRequest): SearchShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchShareLinkWithOptions(request, headers, runtime);
}

model SearchSimilarImageClustersRequest {
  driveId?: string(name='drive_id', example='1'),
  imageThumbnailProcess?: string(name='image_thumbnail_process', example='image/resize,m_fill,h_128,w_128,limit_0/format,jpg', deprecated='true'),
  limit?: long(name='limit', example='50'),
  marker?: string(name='marker', example='YWRzX3VzZXJfcHJvZmlsZV9je1bnQh***'),
  order?: string(name='order', example='desc'),
}

model SearchSimilarImageClustersResponseBody = {
  nextMarker?: string(name='next_marker', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0***'),
  similarImageClusters?: [ 
    {
      files?: [
        File
      ](name='files'),
    }
  ](name='similar_image_clusters'),
}

model SearchSimilarImageClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchSimilarImageClustersResponseBody(name='body'),
}

async function searchSimilarImageClustersWithOptions(request: SearchSimilarImageClustersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchSimilarImageClustersResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.imageThumbnailProcess)) {
    body['image_thumbnail_process'] = request.imageThumbnailProcess;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchSimilarImageClusters',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/query_similar_image_clusters`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function searchSimilarImageClusters(request: SearchSimilarImageClustersRequest): SearchSimilarImageClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchSimilarImageClustersWithOptions(request, headers, runtime);
}

model SearchStoriesRequest {
  coverImageThumbnailProcess?: string(name='cover_image_thumbnail_process', example='image/resize,m_fill,h_128,w_128,limit_0/format,jpg', deprecated='true'),
  coverVideoThumbnailProcess?: string(name='cover_video_thumbnail_process', example='video/snapshot,t_1000,f_jpg,w_0,h_0,m_fast,ar_auto', deprecated='true'),
  createTimeRange?: {
    end?: string(name='end', example='2022-12-31T00:00:00+08:00'),
    start?: string(name='start', example='2016-12-31T00:00:00+08:00'),
  }(name='create_time_range'),
  customLabels?: string(name='custom_labels', example='key1=value1,key2!=value2', deprecated='true'),
  driveId?: string(name='drive_id', example='1'),
  faceGroupIds?: [ string ](name='face_group_ids'),
  limit?: long(name='limit', example='100'),
  marker?: string(name='marker', example='NWQ1Yjk4YmI1ZDODBhNDQ2Nzhl***'),
  order?: string(name='order', example='desc'),
  sort?: string(name='sort', example='CreateTime'),
  storyEndTimeRange?: {
    end?: string(name='end', example='2022-12-31T00:00:00+08:00'),
    start?: string(name='start', example='2016-12-31T00:00:00+08:00'),
  }(name='story_end_time_range'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
  storyName?: string(name='story_name'),
  storyStartTimeRange?: {
    end?: string(name='end', example='2022-12-31T00:00:00+08:00'),
    start?: string(name='start', example='2016-12-31T00:00:00+08:00'),
  }(name='story_start_time_range'),
  storyType?: string(name='story_type', example='PeopleMemory'),
  urlExpireSec?: long(name='url_expire_sec', example='900', deprecated='true'),
  withEmptyStories?: boolean(name='with_empty_stories', example='false'),
}

model SearchStoriesResponseBody = {
  items?: [
    Story
  ](name='items'),
  nextMarker?: string(name='next_marker', example='Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJ***'),
}

model SearchStoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchStoriesResponseBody(name='body'),
}

async function searchStoriesWithOptions(request: SearchStoriesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchStoriesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.coverImageThumbnailProcess)) {
    body['cover_image_thumbnail_process'] = request.coverImageThumbnailProcess;
  }
  if (!Util.isUnset(request.coverVideoThumbnailProcess)) {
    body['cover_video_thumbnail_process'] = request.coverVideoThumbnailProcess;
  }
  if (!Util.isUnset(request.createTimeRange)) {
    body['create_time_range'] = request.createTimeRange;
  }
  if (!Util.isUnset(request.customLabels)) {
    body['custom_labels'] = request.customLabels;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.faceGroupIds)) {
    body['face_group_ids'] = request.faceGroupIds;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.order)) {
    body['order'] = request.order;
  }
  if (!Util.isUnset(request.sort)) {
    body['sort'] = request.sort;
  }
  if (!Util.isUnset(request.storyEndTimeRange)) {
    body['story_end_time_range'] = request.storyEndTimeRange;
  }
  if (!Util.isUnset(request.storyId)) {
    body['story_id'] = request.storyId;
  }
  if (!Util.isUnset(request.storyName)) {
    body['story_name'] = request.storyName;
  }
  if (!Util.isUnset(request.storyStartTimeRange)) {
    body['story_start_time_range'] = request.storyStartTimeRange;
  }
  if (!Util.isUnset(request.storyType)) {
    body['story_type'] = request.storyType;
  }
  if (!Util.isUnset(request.urlExpireSec)) {
    body['url_expire_sec'] = request.urlExpireSec;
  }
  if (!Util.isUnset(request.withEmptyStories)) {
    body['with_empty_stories'] = request.withEmptyStories;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchStories',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/find_stories`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function searchStories(request: SearchStoriesRequest): SearchStoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchStoriesWithOptions(request, headers, runtime);
}

model SearchUserRequest {
  email?: string(name='email', description='The email address of the user.', example='123@pds.com'),
  limit?: int32(name='limit', description='The maximum number of results to return. Valid values: 1 to 100. Default value: 100.', example='100'),
  marker?: string(name='marker', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of marker.\\
By default, this parameter is left empty.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
  nickName?: string(name='nick_name', description='The nickname of the user. The nickname can be up to 128 characters in length.', example='pdsuer'),
  nickNameForFuzzy?: string(name='nick_name_for_fuzzy', description='The nickname used for fuzzy searches. The nickname can be up to 128 characters in length.', example='la'),
  phone?: string(name='phone', description='The mobile number of the user.', example='13900001111'),
  role?: string(name='role', description='The role of the user. Valid values:

*   superadmin
*   admin
*   user', example='user'),
  status?: string(name='status', description='The state of the user. Valid values:

*   disabled: The user is prohibited from logon.
*   enabled: The user is in a normal state.', example='enabled'),
  userName?: string(name='user_name', description='The name of the user. The name can be up to 128 characters in length.', example='pds'),
}

model SearchUserResponseBody = {
  items?: [
    User
  ](name='items', description='The information about the users.'),
  nextMarker?: string(name='next_marker', description='A pagination token. It can be used in the next request to retrieve a new page of results. If next_marker is empty, no next page exists.', example='NWQ1Yjk4YmI1ZDRlYmU1Y2E0YWE0NmJhYWJmODBhNDQ2NzhlMTRhMg'),
}

model SearchUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchUserResponseBody(name='body'),
}

async function searchUserWithOptions(request: SearchUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.email)) {
    body['email'] = request.email;
  }
  if (!Util.isUnset(request.limit)) {
    body['limit'] = request.limit;
  }
  if (!Util.isUnset(request.marker)) {
    body['marker'] = request.marker;
  }
  if (!Util.isUnset(request.nickName)) {
    body['nick_name'] = request.nickName;
  }
  if (!Util.isUnset(request.nickNameForFuzzy)) {
    body['nick_name_for_fuzzy'] = request.nickNameForFuzzy;
  }
  if (!Util.isUnset(request.phone)) {
    body['phone'] = request.phone;
  }
  if (!Util.isUnset(request.role)) {
    body['role'] = request.role;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.userName)) {
    body['user_name'] = request.userName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/search`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function searchUser(request: SearchUserRequest): SearchUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchUserWithOptions(request, headers, runtime);
}

model TokenRequest {
  assertion?: string(name='assertion', description='The JWT assertion that is signed by using the JWT private key. The JWT assertion contains the information about the user to be authorized and the authorization parameters. For more information about the structure of the JWT assertion, see JWTPayload. This parameter is required if grant_type is set to urn:ietf:params:oauth:grant-type:jwt-bearer.', example='ey***asd'),
  clientId?: string(name='client_id', description='The AppId of the application that is created in the Drive and Photo Service console.', example='1Zu***flH'),
  clientSecret?: string(name='client_secret', description='The AppSecret of the application that is created in the Drive and Photo Service console. This parameter is required if the application is of the WebServer type.', example='80D***3i5'),
  code?: string(name='code', description='The authorization code in the redirect URI that is specified after the authorization process is complete. This parameter is required if grant_type is set to authorization_code.', example='0045157fa8e24f4f9a0d9e3ff158c1e0'),
  grantType?: string(name='grant_type', description='The method that is used to generate an access token. Valid values:

authorization_code: generates an access token by using the authorization code that is returned after the authorization process is complete.

refresh_token: generates an access token by using the refresh token that is returned after the authorization process is complete.

urn:ietf:params:oauth:grant-type:jwt-bearer: generates an access token by using a JWT assertion.', example='refresh_token'),
  redirectUri?: string(name='redirect_uri', description='The redirect URI that is specified when you initiate the authorization request. This parameter is required if grant_type is set to authorization_code.', example='https://aliyun.com/pds'),
  refreshToken?: string(name='refresh_token', description='The refresh token that is used to refresh the access token. This parameter is required if grant_type is set to refresh_token.', example='399623e13353490391266c7d48a13ed1'),
}

model TokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Token  
}

/**
  * For more information about how to access Drive and Photo Service from a web server application by using OAuth 2.0, visit [OAuth 2.0 For Web Server Applications](https://www.alibabacloud.com/help/zh/pds/drive-and-photo-service-dev/user-guide/oauth-2-0-access-process-for-web-server-applications).<props="intl">只发布国际站</props>
  * For more information about how to access Drive and Photo Service by using a JSON Web Token (JWT) application, visit [Access process for JWT applications](https://www.alibabacloud.com/help/zh/pds/drive-and-photo-service-dev/user-guide/access-process-for-jwt-applications).<props="intl">只发布国际站</props>
  *
  * @param request TokenRequest
  * @param headers map
  * @param runtime runtime options for this request RuntimeOptions
  * @return TokenResponse
 */
async function tokenWithOptions(request: TokenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TokenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.assertion)) {
    body['assertion'] = request.assertion;
  }
  if (!Util.isUnset(request.clientId)) {
    body['client_id'] = request.clientId;
  }
  if (!Util.isUnset(request.clientSecret)) {
    body['client_secret'] = request.clientSecret;
  }
  if (!Util.isUnset(request.code)) {
    body['code'] = request.code;
  }
  if (!Util.isUnset(request.grantType)) {
    body['grant_type'] = request.grantType;
  }
  if (!Util.isUnset(request.redirectUri)) {
    body['redirect_uri'] = request.redirectUri;
  }
  if (!Util.isUnset(request.refreshToken)) {
    body['refresh_token'] = request.refreshToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'Token',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/oauth/token`,
    method = 'POST',
    authType = 'Anonymous',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
  * For more information about how to access Drive and Photo Service from a web server application by using OAuth 2.0, visit [OAuth 2.0 For Web Server Applications](https://www.alibabacloud.com/help/zh/pds/drive-and-photo-service-dev/user-guide/oauth-2-0-access-process-for-web-server-applications).<props="intl">只发布国际站</props>
  * For more information about how to access Drive and Photo Service by using a JSON Web Token (JWT) application, visit [Access process for JWT applications](https://www.alibabacloud.com/help/zh/pds/drive-and-photo-service-dev/user-guide/access-process-for-jwt-applications).<props="intl">只发布国际站</props>
  *
  * @param request TokenRequest
  * @return TokenResponse
 */
async function token(request: TokenRequest): TokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tokenWithOptions(request, headers, runtime);
}

model TrashFileRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The ID of the file or folder.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406'),
}

model TrashFileResponseBody = {
  asyncTaskId?: string(name='async_task_id', description='The ID of the asynchronous task.

If an empty string is returned, the file or folder is moved to the recycle bin.

If a non-empty string is returned, an asynchronous task is required. You can call the GetAsyncTask operation to obtain the information about an asynchronous task based on the task ID.', example='13ebd3a24dba4166b1527add676ef2866051b4d5dele16'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The ID of the file or folder.', example='4221bf6e6ab43c255edc4463bf3a6f5f5d317406'),
}

model TrashFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TrashFileResponseBody(name='body'),
}

async function trashFileWithOptions(request: TrashFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TrashFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TrashFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/recyclebin/trash`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function trashFile(request: TrashFileRequest): TrashFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return trashFileWithOptions(request, headers, runtime);
}

model UnLinkAccountRequest {
  extra?: string(name='extra', example='1'),
  identity?: string(name='identity', example='139****'),
  type?: string(name='type', example='mobile'),
  userId?: string(name='user_id', example='uid1'),
}

model UnLinkAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function unLinkAccountWithOptions(request: UnLinkAccountRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UnLinkAccountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extra)) {
    body['extra'] = request.extra;
  }
  if (!Util.isUnset(request.identity)) {
    body['identity'] = request.identity;
  }
  if (!Util.isUnset(request.type)) {
    body['type'] = request.type;
  }
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnLinkAccount',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/account/unlink`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function unLinkAccount(request: UnLinkAccountRequest): UnLinkAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unLinkAccountWithOptions(request, headers, runtime);
}

model UpdateDomainRequest {
  description?: string(name='description', description='The description of the domain.'),
  domainId?: string(name='domain_id', description='The domain ID.', example='bj1'),
  domainName?: string(name='domain_name', description='The name of the domain.'),
  initDriveEnable?: boolean(name='init_drive_enable', description='Specifies whether to enable the default drive feature. A value of true specifies that all users are assigned a drive by default on the first logon. Default value: false.', example='true'),
  initDriveSize?: long(name='init_drive_size', description='The size of the default drive. Unit: bytes. You must specify init_drive_size if you set init_drive_enable to true. Default value: 0. A value of 0 specifies that the size of the default drive is 0 bytes and you cannot upload files to the drive. To initialize the default drive, set init_drive_size to 0. A value of -1 specifies that the size is unlimited.', example='1073741824'),
  publishedAppAccessStrategy?: AppAccessStrategy(name='published_app_access_strategy', description='The access policy of the application.'),
  sizeQuota?: long(name='size_quota', description='The total storage quota for all drives in the domain. A value of 0 specifies that the quota is unlimited.', example='1099511627776'),
  userCountQuota?: long(name='user_count_quota', description='The maximum number of users that can be created in the domain.', example='50'),
}

model UpdateDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Domain  
}

async function updateDomainWithOptions(request: UpdateDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.domainId)) {
    body['domain_id'] = request.domainId;
  }
  if (!Util.isUnset(request.domainName)) {
    body['domain_name'] = request.domainName;
  }
  if (!Util.isUnset(request.initDriveEnable)) {
    body['init_drive_enable'] = request.initDriveEnable;
  }
  if (!Util.isUnset(request.initDriveSize)) {
    body['init_drive_size'] = request.initDriveSize;
  }
  if (!Util.isUnset(request.publishedAppAccessStrategy)) {
    body['published_app_access_strategy'] = request.publishedAppAccessStrategy;
  }
  if (!Util.isUnset(request.sizeQuota)) {
    body['size_quota'] = request.sizeQuota;
  }
  if (!Util.isUnset(request.userCountQuota)) {
    body['user_count_quota'] = request.userCountQuota;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDomain',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/domain/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function updateDomain(request: UpdateDomainRequest): UpdateDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDomainWithOptions(request, headers, runtime);
}

model UpdateDriveRequest {
  description?: string(name='description', description='The description of the drive. The description can be up to 1,024 characters in length.'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  driveName?: string(name='drive_name', description='The name of the drive. The name can be up to 128 characters in length.', example='my_drive'),
  owner?: string(name='owner', description='The owner of the drive. Note: You can modify the owner of a personal drive only by using an AccessKey pair.', example='user1'),
  status?: string(name='status', description='The state of the drive. Valid values:

enabled and disabled.', example='enabled'),
  totalSize?: long(name='total_size', description='The total size of the drive. Unit: bytes. A value of -1 specifies that the size is unlimited.', example='10240'),
}

model UpdateDriveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Drive  
}

async function updateDriveWithOptions(request: UpdateDriveRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDriveResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.driveName)) {
    body['drive_name'] = request.driveName;
  }
  if (!Util.isUnset(request.owner)) {
    body['owner'] = request.owner;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.totalSize)) {
    body['total_size'] = request.totalSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDrive',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/drive/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function updateDrive(request: UpdateDriveRequest): UpdateDriveResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDriveWithOptions(request, headers, runtime);
}

model UpdateFacegroupRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  groupCoverFaceId?: string(name='group_cover_face_id', description='The face ID of the thumbnail of the face-based group. You can obtain the face ID from the **image_media_metadata** parameter in the returned results of the GetFile, ListFile, or SearchFile operation.', example='face1'),
  groupId?: string(name='group_id', description='The ID of the face-based group. You can call the ListFacegroups operation to query the group ID.', example='group-abc'),
  groupName?: string(name='group_name', description='The name of the face-based group. The name can be up to 128 characters in length.'),
  remarks?: string(name='remarks', description='The remarks. The remarks can be up to 128 characters in length.'),
}

model UpdateFacegroupResponseBody = {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  groupId?: string(name='group_id', description='The group ID.', example='group-abc'),
}

model UpdateFacegroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFacegroupResponseBody(name='body'),
}

async function updateFacegroupWithOptions(request: UpdateFacegroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFacegroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.groupCoverFaceId)) {
    body['group_cover_face_id'] = request.groupCoverFaceId;
  }
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    body['group_name'] = request.groupName;
  }
  if (!Util.isUnset(request.remarks)) {
    body['remarks'] = request.remarks;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFacegroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/update_facegroup_info`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function updateFacegroup(request: UpdateFacegroupRequest): UpdateFacegroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFacegroupWithOptions(request, headers, runtime);
}

model UpdateFileRequest {
  checkNameMode?: string(name='check_name_mode', description='The processing method that is used if the file that you want to modify has the same name as an existing file on the cloud. Valid values:

ignore: allows you to modify the file by using the same name as an existing file on the cloud.

auto_rename: automatically renames the file that has the same name on the cloud. By default, the current point in time is added to the end of the file name. Example: xxx\\_20060102\\_150405.

refuse: does not modify the file that you want to modify but returns the information about the file that has the same name on the cloud.

Default value: ignore.', example='ignore'),
  description?: string(name='description', description='The description of the file. The description can be up to 1,024 characters in length.'),
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
  hidden?: boolean(name='hidden', description='Specifies whether to hide the file.', example='true'),
  labels?: [ string ](name='labels', description='The tags of the file. You can specify up to 100 tags.'),
  localModifiedAt?: string(name='local_modified_at', description='The local time when the file was modified. The time is in the yyyy-MM-ddTHH:mm:ssZ format based on the UTC+0 time zone.', example='2019-08-20T06:51:27.292Z'),
  name?: string(name='name', description='The name of the file. The name can be up to 1,024 bytes in length based on the UTF-8 encoding rule.', example='a.jpg'),
  starred?: boolean(name='starred', description='Specifies whether to add the file to favorites.', example='true'),
}

model UpdateFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: File  
}

async function updateFileWithOptions(request: UpdateFileRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkNameMode)) {
    body['check_name_mode'] = request.checkNameMode;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.hidden)) {
    body['hidden'] = request.hidden;
  }
  if (!Util.isUnset(request.labels)) {
    body['labels'] = request.labels;
  }
  if (!Util.isUnset(request.localModifiedAt)) {
    body['local_modified_at'] = request.localModifiedAt;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.starred)) {
    body['starred'] = request.starred;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFile',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function updateFile(request: UpdateFileRequest): UpdateFileResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateFileWithOptions(request, headers, runtime);
}

model UpdateGroupRequest {
  description?: string(name='description', description='The description of the group after modification.', example='test group description'),
  groupId?: string(name='group_id', description='The ID of the group that you want to modify.', example='2e43ec8427dd45f19431b7504649a1b4'),
  groupName?: string(name='group_name', description='The name of the group after modification.', example='test group'),
}

model UpdateGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Group  
}

async function updateGroupWithOptions(request: UpdateGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.groupId)) {
    body['group_id'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    body['group_name'] = request.groupName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGroup',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/group/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function updateGroup(request: UpdateGroupRequest): UpdateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateGroupWithOptions(request, headers, runtime);
}

model UpdateIdentityToBenefitPkgMappingRequest {
  amount?: long(name='amount', description='The number of benefit packages.

This parameter specifies the number of benefit packages of the resource type. Default value: 1.', example='1'),
  benefitPkgId?: string(name='benefit_pkg_id', description='The unique identifier of the benefit package.', example='40cb7794c9294'),
  expireTime?: long(name='expire_time', description='The expiration time of the benefit package. Set this parameter to a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.

By default, the benefit package never expires.', example='1633167071000'),
  identityId?: string(name='identity_id', description='The unique identifier of the entity.

If you call this operation to manage the benefits of a user, set this parameter to the ID of the user.', example='user123'),
  identityType?: string(name='identity_type', description='The type of the entity. If you call this operation to manage the benefits of a user, set this parameter to user.', example='user'),
}

model UpdateIdentityToBenefitPkgMappingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function updateIdentityToBenefitPkgMappingWithOptions(request: UpdateIdentityToBenefitPkgMappingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateIdentityToBenefitPkgMappingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.amount)) {
    body['amount'] = request.amount;
  }
  if (!Util.isUnset(request.benefitPkgId)) {
    body['benefit_pkg_id'] = request.benefitPkgId;
  }
  if (!Util.isUnset(request.expireTime)) {
    body['expire_time'] = request.expireTime;
  }
  if (!Util.isUnset(request.identityId)) {
    body['identity_id'] = request.identityId;
  }
  if (!Util.isUnset(request.identityType)) {
    body['identity_type'] = request.identityType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIdentityToBenefitPkgMapping',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/benefit/identity_to_benefit_pkg_mapping/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function updateIdentityToBenefitPkgMapping(request: UpdateIdentityToBenefitPkgMappingRequest): UpdateIdentityToBenefitPkgMappingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateIdentityToBenefitPkgMappingWithOptions(request, headers, runtime);
}

model UpdateRevisionRequest {
  driveId?: string(name='drive_id', description='The drive ID.', example='1'),
  fileId?: string(name='file_id', description='The file ID.', example='9520943DC264'),
  keepForever?: boolean(name='keep_forever', description='Specifies whether to permanently retain a version.

By default, this parameter is not specified, which indicates that you do not modify the permanent retention configuration of the version.', example='true'),
  revisionDescription?: string(name='revision_description', description='The description of the version. The description can be up to 1,024 characters in length.

By default, this parameter is not specified, which indicates that you do not modify the description of the version.', example='aaa'),
  revisionId?: string(name='revision_id', description='The version ID.', example='40CB7794C929'),
}

model UpdateRevisionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Revision  
}

async function updateRevisionWithOptions(request: UpdateRevisionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRevisionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.fileId)) {
    body['file_id'] = request.fileId;
  }
  if (!Util.isUnset(request.keepForever)) {
    body['keep_forever'] = request.keepForever;
  }
  if (!Util.isUnset(request.revisionDescription)) {
    body['revision_description'] = request.revisionDescription;
  }
  if (!Util.isUnset(request.revisionId)) {
    body['revision_id'] = request.revisionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRevision',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/file/revision/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function updateRevision(request: UpdateRevisionRequest): UpdateRevisionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRevisionWithOptions(request, headers, runtime);
}

model UpdateShareLinkRequest {
  description?: string(name='description', description='The description of the share link. The description can be up to 1,024 characters in length.'),
  disableDownload?: boolean(name='disable_download', description='Specifies whether to prohibit the downloads of the shared files.', example='false'),
  disablePreview?: boolean(name='disable_preview', description='Specifies whether to prohibit the previews of the shared files.', example='false'),
  disableSave?: boolean(name='disable_save', description='Specifies whether to prohibit the saves of the shared files.', example='false'),
  downloadCount?: long(name='download_count', description='The number of times that the shared files are downloaded. The value must be greater than or equal to 0.', example='30'),
  downloadLimit?: long(name='download_limit', description='The maximum number of times that the shared files can be downloaded. The value must be greater than or equal to 0. A value of 0 specifies that the number is unlimited.', example='100'),
  expiration?: string(name='expiration', description='The time when the share link expires. The time follows the RFC 3339 standard. Example: 2020-06-28T11:33:00.000+08:00. If you leave this parameter empty, the share link never expires.', example='2020-06-28T11:33:00.000+08:00'),
  previewCount?: long(name='preview_count', description='The number of times that the shared files are previewed. The value must be greater than or equal to 0.', example='3'),
  previewLimit?: long(name='preview_limit', description='The maximum number of times that the shared files can be previewed. The value must be greater than or equal to 0. A value of 0 specifies that the number is unlimited.', example='100'),
  reportCount?: long(name='report_count', description='The number of times that the shared files are reported. The value must be greater than or equal to 0.', example='1'),
  saveCount?: long(name='save_count', description='The number of times that the shared files are saved. The value must be greater than or equal to 0.', example='5'),
  saveLimit?: long(name='save_limit', description='The maximum number of times that the shared files can be saved. The value must be greater than or equal to 0. A value of 0 specifies that the number is unlimited.', example='100'),
  shareId?: string(name='share_id', description='The share ID.', example='7JQX1FswpQ8'),
  shareName?: string(name='share_name', description='The name of the share link. By default, the name of the first file is used. The name can be up to 128 characters in length.'),
  sharePwd?: string(name='share_pwd', description='The access code. The access code can be up to 64 characters in length. A value of 0 specifies an empty string.', example='abcF123x'),
  status?: string(name='status', description='The state of the share link. Valid values:

*   disabled: The share link is canceled.
*   enabled: The share link is effective.', example='enabled'),
  videoPreviewCount?: long(name='video_preview_count', description='The number of times that the videos are previewed in the shared files. The value must be greater than or equal to 0.', example='100'),
}

model UpdateShareLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ShareLink  
}

async function updateShareLinkWithOptions(request: UpdateShareLinkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateShareLinkResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.disableDownload)) {
    body['disable_download'] = request.disableDownload;
  }
  if (!Util.isUnset(request.disablePreview)) {
    body['disable_preview'] = request.disablePreview;
  }
  if (!Util.isUnset(request.disableSave)) {
    body['disable_save'] = request.disableSave;
  }
  if (!Util.isUnset(request.downloadCount)) {
    body['download_count'] = request.downloadCount;
  }
  if (!Util.isUnset(request.downloadLimit)) {
    body['download_limit'] = request.downloadLimit;
  }
  if (!Util.isUnset(request.expiration)) {
    body['expiration'] = request.expiration;
  }
  if (!Util.isUnset(request.previewCount)) {
    body['preview_count'] = request.previewCount;
  }
  if (!Util.isUnset(request.previewLimit)) {
    body['preview_limit'] = request.previewLimit;
  }
  if (!Util.isUnset(request.reportCount)) {
    body['report_count'] = request.reportCount;
  }
  if (!Util.isUnset(request.saveCount)) {
    body['save_count'] = request.saveCount;
  }
  if (!Util.isUnset(request.saveLimit)) {
    body['save_limit'] = request.saveLimit;
  }
  if (!Util.isUnset(request.shareId)) {
    body['share_id'] = request.shareId;
  }
  if (!Util.isUnset(request.shareName)) {
    body['share_name'] = request.shareName;
  }
  if (!Util.isUnset(request.sharePwd)) {
    body['share_pwd'] = request.sharePwd;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.videoPreviewCount)) {
    body['video_preview_count'] = request.videoPreviewCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateShareLink',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/share_link/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function updateShareLink(request: UpdateShareLinkRequest): UpdateShareLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateShareLinkWithOptions(request, headers, runtime);
}

model UpdateStoryRequest {
  cover?: {
    fileId?: string(name='file_id', example='63e5e4340f76cb3ead5f40f68163f0f967c1a7bf'),
    revisionId?: string(name='revision_id', example='642a88dd06e49d9c0a14411ebae606f70edd9a59'),
  }(name='cover'),
  customLabels?: map[string]string(name='custom_labels', deprecated='true'),
  driveId?: string(name='drive_id', example='1'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
  storyName?: string(name='story_name', example='name1'),
}

model UpdateStoryResponseBody = {
  driveId?: string(name='drive_id', example='1'),
  storyId?: string(name='story_id', example='9132e0d8-fe92-4e56-86c3-f5f112308003'),
}

model UpdateStoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateStoryResponseBody(name='body'),
}

async function updateStoryWithOptions(request: UpdateStoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateStoryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cover)) {
    body['cover'] = request.cover;
  }
  if (!Util.isUnset(request.customLabels)) {
    body['custom_labels'] = request.customLabels;
  }
  if (!Util.isUnset(request.driveId)) {
    body['drive_id'] = request.driveId;
  }
  if (!Util.isUnset(request.storyId)) {
    body['story_id'] = request.storyId;
  }
  if (!Util.isUnset(request.storyName)) {
    body['story_name'] = request.storyName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateStory',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/image/update_story`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function updateStory(request: UpdateStoryRequest): UpdateStoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateStoryWithOptions(request, headers, runtime);
}

model UpdateUserRequest {
  avatar?: string(name='avatar', description='The URL of the profile picture.

If you specify the parameter in the HTTP URL format, the URL must start with http:// or https:// and can be up to 4 KB in size.

If you specify the parameter in the DATA URL format, the URL must start with data:// and be encoded in Base64. The URL can be up to 300 KB in size.', example='http://a.b.c/pds.jpg'),
  description?: string(name='description', description='The description of the user. The description can be up to 1,024 characters in length.'),
  email?: string(name='email', description='The email address of the user.', example='a@aliyunpds.com'),
  groupInfoList?: [ 
    {
      groupId?: string(name='group_id', description='The group ID.', example='g123'),
    }
  ](name='group_info_list', description='The information about the group.'),
  nickName?: string(name='nick_name', description='The nickname of the user. The nickname can be up to 128 characters in length.', example='pdsuer'),
  phone?: string(name='phone', description='The mobile number of the user.', example='13900001111'),
  role?: string(name='role', description='The role of the user. Valid values:

*   superadmin
*   admin
*   user', example='user'),
  status?: string(name='status', description='The state of the user. Valid values:

*   disabled: The user is prohibited from logon.
*   enabled: The user is in a normal state.', example='enabled'),
  userData?: map[string]string(name='user_data', description='The custom data. The data can be up to 1,024 characters in length.'),
  userId?: string(name='user_id', description='The user ID. The ID can be up to 64 characters in length and cannot contain a number sign (#).', example='c9b7a5aa04d14ae3867fdc886fa01da4'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: User  
}

async function updateUserWithOptions(request: UpdateUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.avatar)) {
    body['avatar'] = request.avatar;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.email)) {
    body['email'] = request.email;
  }
  if (!Util.isUnset(request.groupInfoList)) {
    body['group_info_list'] = request.groupInfoList;
  }
  if (!Util.isUnset(request.nickName)) {
    body['nick_name'] = request.nickName;
  }
  if (!Util.isUnset(request.phone)) {
    body['phone'] = request.phone;
  }
  if (!Util.isUnset(request.role)) {
    body['role'] = request.role;
  }
  if (!Util.isUnset(request.status)) {
    body['status'] = request.status;
  }
  if (!Util.isUnset(request.userData)) {
    body['user_data'] = request.userData;
  }
  if (!Util.isUnset(request.userId)) {
    body['user_id'] = request.userId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2022-03-01',
    protocol = 'HTTPS',
    pathname = `/v2/user/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateUserWithOptions(request, headers, runtime);
}

