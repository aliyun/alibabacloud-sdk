/**
 *
 */
import Util;
import OSS;
import OpenPlatform;
import OSSUtil;
import FileForm;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('docmind-api', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model GetDocStructureResultRequest {
  id?: string(name='Id'),
}

model GetDocStructureResultResponseBody = {
  code?: string(name='Code'),
  completed?: boolean(name='Completed'),
  data?: any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model GetDocStructureResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDocStructureResultResponseBody(name='body'),
}

async function getDocStructureResultWithOptions(request: GetDocStructureResultRequest, runtime: Util.RuntimeOptions): GetDocStructureResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDocStructureResult',
    version = '2022-07-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDocStructureResult(request: GetDocStructureResultRequest): GetDocStructureResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDocStructureResultWithOptions(request, runtime);
}

model GetDocumentCompareResultRequest {
  id?: string(name='Id'),
}

model GetDocumentCompareResultResponseBody = {
  code?: string(name='Code'),
  completed?: boolean(name='Completed'),
  data?: any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model GetDocumentCompareResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDocumentCompareResultResponseBody(name='body'),
}

async function getDocumentCompareResultWithOptions(request: GetDocumentCompareResultRequest, runtime: Util.RuntimeOptions): GetDocumentCompareResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDocumentCompareResult',
    version = '2022-07-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDocumentCompareResult(request: GetDocumentCompareResultRequest): GetDocumentCompareResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDocumentCompareResultWithOptions(request, runtime);
}

model GetDocumentConvertResultRequest {
  id?: string(name='Id'),
}

model GetDocumentConvertResultResponseBody = {
  code?: string(name='Code'),
  completed?: boolean(name='Completed'),
  data?: [ 
    {
      md5?: string(name='Md5'),
      size?: long(name='Size'),
      type?: string(name='Type'),
      url?: string(name='Url'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model GetDocumentConvertResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDocumentConvertResultResponseBody(name='body'),
}

async function getDocumentConvertResultWithOptions(request: GetDocumentConvertResultRequest, runtime: Util.RuntimeOptions): GetDocumentConvertResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDocumentConvertResult',
    version = '2022-07-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDocumentConvertResult(request: GetDocumentConvertResultRequest): GetDocumentConvertResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDocumentConvertResultWithOptions(request, runtime);
}

model GetDocumentExtractResultRequest {
  id?: string(name='Id'),
}

model GetDocumentExtractResultResponseBody = {
  code?: string(name='Code'),
  completed?: boolean(name='Completed'),
  data?: any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model GetDocumentExtractResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDocumentExtractResultResponseBody(name='body'),
}

async function getDocumentExtractResultWithOptions(request: GetDocumentExtractResultRequest, runtime: Util.RuntimeOptions): GetDocumentExtractResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDocumentExtractResult',
    version = '2022-07-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDocumentExtractResult(request: GetDocumentExtractResultRequest): GetDocumentExtractResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDocumentExtractResultWithOptions(request, runtime);
}

model GetTableUnderstandingResultRequest {
  id?: string(name='Id'),
}

model GetTableUnderstandingResultResponseBody = {
  code?: string(name='Code'),
  completed?: boolean(name='Completed'),
  data?: any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model GetTableUnderstandingResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTableUnderstandingResultResponseBody(name='body'),
}

async function getTableUnderstandingResultWithOptions(request: GetTableUnderstandingResultRequest, runtime: Util.RuntimeOptions): GetTableUnderstandingResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTableUnderstandingResult',
    version = '2022-07-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTableUnderstandingResult(request: GetTableUnderstandingResultRequest): GetTableUnderstandingResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTableUnderstandingResultWithOptions(request, runtime);
}

model SubmitConvertImageToExcelJobRequest {
  imageNameExtension?: string(name='ImageNameExtension'),
  imageNames?: [ string ](name='ImageNames'),
  imageUrls?: [ string ](name='ImageUrls'),
}

model SubmitConvertImageToExcelJobShrinkRequest {
  imageNameExtension?: string(name='ImageNameExtension'),
  imageNamesShrink?: string(name='ImageNames'),
  imageUrlsShrink?: string(name='ImageUrls'),
}

model SubmitConvertImageToExcelJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SubmitConvertImageToExcelJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitConvertImageToExcelJobResponseBody(name='body'),
}

async function submitConvertImageToExcelJobWithOptions(tmpReq: SubmitConvertImageToExcelJobRequest, runtime: Util.RuntimeOptions): SubmitConvertImageToExcelJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitConvertImageToExcelJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.imageNames)) {
    request.imageNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.imageNames, 'ImageNames', 'simple');
  }
  if (!Util.isUnset(tmpReq.imageUrls)) {
    request.imageUrlsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.imageUrls, 'ImageUrls', 'simple');
  }
  var query = {};
  if (!Util.isUnset(request.imageNameExtension)) {
    query['ImageNameExtension'] = request.imageNameExtension;
  }
  if (!Util.isUnset(request.imageNamesShrink)) {
    query['ImageNames'] = request.imageNamesShrink;
  }
  if (!Util.isUnset(request.imageUrlsShrink)) {
    query['ImageUrls'] = request.imageUrlsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitConvertImageToExcelJob',
    version = '2022-07-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitConvertImageToExcelJob(request: SubmitConvertImageToExcelJobRequest): SubmitConvertImageToExcelJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitConvertImageToExcelJobWithOptions(request, runtime);
}

model SubmitConvertImageToPdfJobRequest {
  imageNameExtension?: string(name='ImageNameExtension'),
  imageNames?: [ string ](name='ImageNames'),
  imageUrls?: [ string ](name='ImageUrls'),
}

model SubmitConvertImageToPdfJobShrinkRequest {
  imageNameExtension?: string(name='ImageNameExtension'),
  imageNamesShrink?: string(name='ImageNames'),
  imageUrlsShrink?: string(name='ImageUrls'),
}

model SubmitConvertImageToPdfJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SubmitConvertImageToPdfJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitConvertImageToPdfJobResponseBody(name='body'),
}

async function submitConvertImageToPdfJobWithOptions(tmpReq: SubmitConvertImageToPdfJobRequest, runtime: Util.RuntimeOptions): SubmitConvertImageToPdfJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitConvertImageToPdfJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.imageNames)) {
    request.imageNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.imageNames, 'ImageNames', 'simple');
  }
  if (!Util.isUnset(tmpReq.imageUrls)) {
    request.imageUrlsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.imageUrls, 'ImageUrls', 'simple');
  }
  var query = {};
  if (!Util.isUnset(request.imageNameExtension)) {
    query['ImageNameExtension'] = request.imageNameExtension;
  }
  if (!Util.isUnset(request.imageNamesShrink)) {
    query['ImageNames'] = request.imageNamesShrink;
  }
  if (!Util.isUnset(request.imageUrlsShrink)) {
    query['ImageUrls'] = request.imageUrlsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitConvertImageToPdfJob',
    version = '2022-07-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitConvertImageToPdfJob(request: SubmitConvertImageToPdfJobRequest): SubmitConvertImageToPdfJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitConvertImageToPdfJobWithOptions(request, runtime);
}

model SubmitConvertImageToWordJobRequest {
  imageNameExtension?: string(name='ImageNameExtension'),
  imageNames?: [ string ](name='ImageNames'),
  imageUrls?: [ string ](name='ImageUrls'),
}

model SubmitConvertImageToWordJobShrinkRequest {
  imageNameExtension?: string(name='ImageNameExtension'),
  imageNamesShrink?: string(name='ImageNames'),
  imageUrlsShrink?: string(name='ImageUrls'),
}

model SubmitConvertImageToWordJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SubmitConvertImageToWordJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitConvertImageToWordJobResponseBody(name='body'),
}

async function submitConvertImageToWordJobWithOptions(tmpReq: SubmitConvertImageToWordJobRequest, runtime: Util.RuntimeOptions): SubmitConvertImageToWordJobResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitConvertImageToWordJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.imageNames)) {
    request.imageNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.imageNames, 'ImageNames', 'simple');
  }
  if (!Util.isUnset(tmpReq.imageUrls)) {
    request.imageUrlsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.imageUrls, 'ImageUrls', 'simple');
  }
  var query = {};
  if (!Util.isUnset(request.imageNameExtension)) {
    query['ImageNameExtension'] = request.imageNameExtension;
  }
  if (!Util.isUnset(request.imageNamesShrink)) {
    query['ImageNames'] = request.imageNamesShrink;
  }
  if (!Util.isUnset(request.imageUrlsShrink)) {
    query['ImageUrls'] = request.imageUrlsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitConvertImageToWordJob',
    version = '2022-07-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitConvertImageToWordJob(request: SubmitConvertImageToWordJobRequest): SubmitConvertImageToWordJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitConvertImageToWordJobWithOptions(request, runtime);
}

model SubmitConvertPdfToExcelJobRequest {
  fileName?: string(name='FileName'),
  fileUrl?: string(name='FileUrl'),
}

model SubmitConvertPdfToExcelJobAdvanceRequest {
  fileName?: string(name='FileName'),
  fileUrlObject?: readable(name='FileUrl'),
}

model SubmitConvertPdfToExcelJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SubmitConvertPdfToExcelJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitConvertPdfToExcelJobResponseBody(name='body'),
}

async function submitConvertPdfToExcelJobWithOptions(request: SubmitConvertPdfToExcelJobRequest, runtime: Util.RuntimeOptions): SubmitConvertPdfToExcelJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileUrl)) {
    query['FileUrl'] = request.fileUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitConvertPdfToExcelJob',
    version = '2022-07-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitConvertPdfToExcelJob(request: SubmitConvertPdfToExcelJobRequest): SubmitConvertPdfToExcelJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitConvertPdfToExcelJobWithOptions(request, runtime);
}

async function submitConvertPdfToExcelJobAdvance(request: SubmitConvertPdfToExcelJobAdvanceRequest, runtime: Util.RuntimeOptions): SubmitConvertPdfToExcelJobResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'docmind-api',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var submitConvertPdfToExcelJobReq = new SubmitConvertPdfToExcelJobRequest{};
  OpenApiUtil.convert(request, submitConvertPdfToExcelJobReq);

  if(!Util.isUnset(request.fileUrlObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.fileUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    submitConvertPdfToExcelJobReq.fileUrl = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var submitConvertPdfToExcelJobResp = submitConvertPdfToExcelJobWithOptions(submitConvertPdfToExcelJobReq, runtime);
  return submitConvertPdfToExcelJobResp;
}

model SubmitConvertPdfToImageJobRequest {
  fileName?: string(name='FileName'),
  fileUrl?: string(name='FileUrl'),
}

model SubmitConvertPdfToImageJobAdvanceRequest {
  fileName?: string(name='FileName'),
  fileUrlObject?: readable(name='FileUrl'),
}

model SubmitConvertPdfToImageJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SubmitConvertPdfToImageJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitConvertPdfToImageJobResponseBody(name='body'),
}

async function submitConvertPdfToImageJobWithOptions(request: SubmitConvertPdfToImageJobRequest, runtime: Util.RuntimeOptions): SubmitConvertPdfToImageJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileUrl)) {
    query['FileUrl'] = request.fileUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitConvertPdfToImageJob',
    version = '2022-07-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitConvertPdfToImageJob(request: SubmitConvertPdfToImageJobRequest): SubmitConvertPdfToImageJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitConvertPdfToImageJobWithOptions(request, runtime);
}

async function submitConvertPdfToImageJobAdvance(request: SubmitConvertPdfToImageJobAdvanceRequest, runtime: Util.RuntimeOptions): SubmitConvertPdfToImageJobResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'docmind-api',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var submitConvertPdfToImageJobReq = new SubmitConvertPdfToImageJobRequest{};
  OpenApiUtil.convert(request, submitConvertPdfToImageJobReq);

  if(!Util.isUnset(request.fileUrlObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.fileUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    submitConvertPdfToImageJobReq.fileUrl = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var submitConvertPdfToImageJobResp = submitConvertPdfToImageJobWithOptions(submitConvertPdfToImageJobReq, runtime);
  return submitConvertPdfToImageJobResp;
}

model SubmitConvertPdfToWordJobRequest {
  fileName?: string(name='FileName'),
  fileUrl?: string(name='FileUrl'),
}

model SubmitConvertPdfToWordJobAdvanceRequest {
  fileName?: string(name='FileName'),
  fileUrlObject?: readable(name='FileUrl'),
}

model SubmitConvertPdfToWordJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SubmitConvertPdfToWordJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitConvertPdfToWordJobResponseBody(name='body'),
}

async function submitConvertPdfToWordJobWithOptions(request: SubmitConvertPdfToWordJobRequest, runtime: Util.RuntimeOptions): SubmitConvertPdfToWordJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileUrl)) {
    query['FileUrl'] = request.fileUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitConvertPdfToWordJob',
    version = '2022-07-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitConvertPdfToWordJob(request: SubmitConvertPdfToWordJobRequest): SubmitConvertPdfToWordJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitConvertPdfToWordJobWithOptions(request, runtime);
}

async function submitConvertPdfToWordJobAdvance(request: SubmitConvertPdfToWordJobAdvanceRequest, runtime: Util.RuntimeOptions): SubmitConvertPdfToWordJobResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'docmind-api',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var submitConvertPdfToWordJobReq = new SubmitConvertPdfToWordJobRequest{};
  OpenApiUtil.convert(request, submitConvertPdfToWordJobReq);

  if(!Util.isUnset(request.fileUrlObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.fileUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    submitConvertPdfToWordJobReq.fileUrl = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var submitConvertPdfToWordJobResp = submitConvertPdfToWordJobWithOptions(submitConvertPdfToWordJobReq, runtime);
  return submitConvertPdfToWordJobResp;
}

model SubmitDocStructureJobRequest {
  fileName?: string(name='FileName'),
  fileNameExtension?: string(name='FileNameExtension'),
  fileUrl?: string(name='FileUrl'),
}

model SubmitDocStructureJobAdvanceRequest {
  fileName?: string(name='FileName'),
  fileNameExtension?: string(name='FileNameExtension'),
  fileUrlObject?: readable(name='FileUrl'),
}

model SubmitDocStructureJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SubmitDocStructureJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitDocStructureJobResponseBody(name='body'),
}

async function submitDocStructureJobWithOptions(request: SubmitDocStructureJobRequest, runtime: Util.RuntimeOptions): SubmitDocStructureJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileNameExtension)) {
    query['FileNameExtension'] = request.fileNameExtension;
  }
  if (!Util.isUnset(request.fileUrl)) {
    query['FileUrl'] = request.fileUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitDocStructureJob',
    version = '2022-07-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitDocStructureJob(request: SubmitDocStructureJobRequest): SubmitDocStructureJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitDocStructureJobWithOptions(request, runtime);
}

async function submitDocStructureJobAdvance(request: SubmitDocStructureJobAdvanceRequest, runtime: Util.RuntimeOptions): SubmitDocStructureJobResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'docmind-api',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var submitDocStructureJobReq = new SubmitDocStructureJobRequest{};
  OpenApiUtil.convert(request, submitDocStructureJobReq);

  if(!Util.isUnset(request.fileUrlObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.fileUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    submitDocStructureJobReq.fileUrl = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var submitDocStructureJobResp = submitDocStructureJobWithOptions(submitDocStructureJobReq, runtime);
  return submitDocStructureJobResp;
}

model SubmitDocumentCompareJobRequest {
  compareFileName?: string(name='CompareFileName'),
  compareFileUrl?: string(name='CompareFileUrl'),
  originFileName?: string(name='OriginFileName'),
  originFileUrl?: string(name='OriginFileUrl'),
}

model SubmitDocumentCompareJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SubmitDocumentCompareJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitDocumentCompareJobResponseBody(name='body'),
}

async function submitDocumentCompareJobWithOptions(request: SubmitDocumentCompareJobRequest, runtime: Util.RuntimeOptions): SubmitDocumentCompareJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.compareFileName)) {
    query['CompareFileName'] = request.compareFileName;
  }
  if (!Util.isUnset(request.compareFileUrl)) {
    query['CompareFileUrl'] = request.compareFileUrl;
  }
  if (!Util.isUnset(request.originFileName)) {
    query['OriginFileName'] = request.originFileName;
  }
  if (!Util.isUnset(request.originFileUrl)) {
    query['OriginFileUrl'] = request.originFileUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitDocumentCompareJob',
    version = '2022-07-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitDocumentCompareJob(request: SubmitDocumentCompareJobRequest): SubmitDocumentCompareJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitDocumentCompareJobWithOptions(request, runtime);
}

model SubmitDocumentExtractJobRequest {
  fileName?: string(name='FileName'),
  fileNameExtension?: string(name='FileNameExtension'),
  fileUrl?: string(name='FileUrl'),
}

model SubmitDocumentExtractJobAdvanceRequest {
  fileName?: string(name='FileName'),
  fileNameExtension?: string(name='FileNameExtension'),
  fileUrlObject?: readable(name='FileUrl'),
}

model SubmitDocumentExtractJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SubmitDocumentExtractJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitDocumentExtractJobResponseBody(name='body'),
}

async function submitDocumentExtractJobWithOptions(request: SubmitDocumentExtractJobRequest, runtime: Util.RuntimeOptions): SubmitDocumentExtractJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileNameExtension)) {
    query['FileNameExtension'] = request.fileNameExtension;
  }
  if (!Util.isUnset(request.fileUrl)) {
    query['FileUrl'] = request.fileUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitDocumentExtractJob',
    version = '2022-07-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitDocumentExtractJob(request: SubmitDocumentExtractJobRequest): SubmitDocumentExtractJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitDocumentExtractJobWithOptions(request, runtime);
}

async function submitDocumentExtractJobAdvance(request: SubmitDocumentExtractJobAdvanceRequest, runtime: Util.RuntimeOptions): SubmitDocumentExtractJobResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'docmind-api',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var submitDocumentExtractJobReq = new SubmitDocumentExtractJobRequest{};
  OpenApiUtil.convert(request, submitDocumentExtractJobReq);

  if(!Util.isUnset(request.fileUrlObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.fileUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    submitDocumentExtractJobReq.fileUrl = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var submitDocumentExtractJobResp = submitDocumentExtractJobWithOptions(submitDocumentExtractJobReq, runtime);
  return submitDocumentExtractJobResp;
}

model SubmitTableUnderstandingJobRequest {
  fileName?: string(name='FileName'),
  fileNameExtension?: string(name='FileNameExtension'),
  fileUrl?: string(name='FileUrl'),
}

model SubmitTableUnderstandingJobAdvanceRequest {
  fileName?: string(name='FileName'),
  fileNameExtension?: string(name='FileNameExtension'),
  fileUrlObject?: readable(name='FileUrl'),
}

model SubmitTableUnderstandingJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SubmitTableUnderstandingJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitTableUnderstandingJobResponseBody(name='body'),
}

async function submitTableUnderstandingJobWithOptions(request: SubmitTableUnderstandingJobRequest, runtime: Util.RuntimeOptions): SubmitTableUnderstandingJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileNameExtension)) {
    query['FileNameExtension'] = request.fileNameExtension;
  }
  if (!Util.isUnset(request.fileUrl)) {
    query['FileUrl'] = request.fileUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitTableUnderstandingJob',
    version = '2022-07-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitTableUnderstandingJob(request: SubmitTableUnderstandingJobRequest): SubmitTableUnderstandingJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitTableUnderstandingJobWithOptions(request, runtime);
}

async function submitTableUnderstandingJobAdvance(request: SubmitTableUnderstandingJobAdvanceRequest, runtime: Util.RuntimeOptions): SubmitTableUnderstandingJobResponse {
  // Step 0: init client
  var accessKeyId = @credential.getAccessKeyId();
  var accessKeySecret = @credential.getAccessKeySecret();
  var securityToken = @credential.getSecurityToken();
  var credentialType = @credential.getType();
  var openPlatformEndpoint = @openPlatformEndpoint;
  if(Util.isUnset(openPlatformEndpoint)) {
    openPlatformEndpoint ='openplatform.aliyuncs.com';
  }
  if(Util.isUnset(credentialType)) {
    credentialType ='access_key';
  }
  var authConfig = new OpenApi.Config{
    accessKeyId = accessKeyId,
    accessKeySecret = accessKeySecret,
    securityToken = securityToken,
    type = credentialType,
    endpoint = openPlatformEndpoint,
    protocol = @protocol,
    regionId = @regionId,
  };
  var authClient = new OpenPlatform(authConfig);
  var authRequest = new OpenPlatform.AuthorizeFileUploadRequest{
    product = 'docmind-api',
    regionId = @regionId,
  };
  var authResponse = new OpenPlatform.AuthorizeFileUploadResponse{};
  var ossConfig = new OSS.Config{
    accessKeySecret = accessKeySecret,
    type = 'access_key',
    protocol = @protocol,
    regionId = @regionId,
  };
  var ossClient : OSS = null;

  var fileObj = new FileForm.FileField{};
  var ossHeader = new OSS.PostObjectRequest.header{};
  var uploadRequest = new OSS.PostObjectRequest{};
  var ossRuntime = new OSSUtil.RuntimeOptions{};
  OpenApiUtil.convert(runtime, ossRuntime);
  var submitTableUnderstandingJobReq = new SubmitTableUnderstandingJobRequest{};
  OpenApiUtil.convert(request, submitTableUnderstandingJobReq);

  if(!Util.isUnset(request.fileUrlObject)) {
    authResponse = authClient.authorizeFileUploadWithOptions(authRequest, runtime);
    ossConfig.accessKeyId = authResponse.body.accessKeyId;
    ossConfig.endpoint = OpenApiUtil.getEndpoint(authResponse.body.endpoint, authResponse.body.useAccelerate, @endpointType);
    ossClient = new OSS(ossConfig);

    fileObj = new FileForm.FileField{
      filename = authResponse.body.objectKey,
      content = request.fileUrlObject,
      contentType = '',
    };
    ossHeader = new OSS.PostObjectRequest.header{
      accessKeyId = authResponse.body.accessKeyId,
      policy = authResponse.body.encodedPolicy,
      signature = authResponse.body.signature,
      key = authResponse.body.objectKey,
      file = fileObj,
      successActionStatus = '201',
    };
    uploadRequest = new OSS.PostObjectRequest{
      bucketName = authResponse.body.bucket,
      header = ossHeader,
    };
    ossClient.postObject(uploadRequest, ossRuntime);
    submitTableUnderstandingJobReq.fileUrl = `http://${authResponse.body.bucket}.${authResponse.body.endpoint}/${authResponse.body.objectKey}`;
  }
  var submitTableUnderstandingJobResp = submitTableUnderstandingJobWithOptions(submitTableUnderstandingJobReq, runtime);
  return submitTableUnderstandingJobResp;
}

