/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('cddc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateDedicatedHostRequest {
  autoRenew?: string(name='AutoRenew'),
  clientToken?: string(name='ClientToken'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  hostClass?: string(name='HostClass'),
  hostStorage?: string(name='HostStorage'),
  hostStorageType?: string(name='HostStorageType'),
  imageCategory?: string(name='ImageCategory'),
  osPassword?: string(name='OsPassword'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  period?: string(name='Period'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  usedTime?: string(name='UsedTime'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
}

model CreateDedicatedHostResponseBody = {
  dedicateHostList?: {
    dedicateHostList?: [ 
    {
      dedicatedHostId?: string(name='DedicatedHostId'),
    }
  ](name='DedicateHostList')
  }(name='DedicateHostList'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateDedicatedHostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDedicatedHostResponseBody(name='body'),
}

async function createDedicatedHostWithOptions(request: CreateDedicatedHostRequest, runtime: Util.RuntimeOptions): CreateDedicatedHostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.hostClass)) {
    query['HostClass'] = request.hostClass;
  }
  if (!Util.isUnset(request.hostStorage)) {
    query['HostStorage'] = request.hostStorage;
  }
  if (!Util.isUnset(request.hostStorageType)) {
    query['HostStorageType'] = request.hostStorageType;
  }
  if (!Util.isUnset(request.imageCategory)) {
    query['ImageCategory'] = request.imageCategory;
  }
  if (!Util.isUnset(request.osPassword)) {
    query['OsPassword'] = request.osPassword;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDedicatedHost',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDedicatedHost(request: CreateDedicatedHostRequest): CreateDedicatedHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDedicatedHostWithOptions(request, runtime);
}

model CreateDedicatedHostAccountRequest {
  accountName?: string(name='AccountName'),
  accountPassword?: string(name='AccountPassword'),
  accountType?: string(name='AccountType'),
  bastionInstanceId?: string(name='BastionInstanceId'),
  clientToken?: string(name='ClientToken'),
  dedicatedHostId?: string(name='DedicatedHostId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateDedicatedHostAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateDedicatedHostAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDedicatedHostAccountResponseBody(name='body'),
}

async function createDedicatedHostAccountWithOptions(request: CreateDedicatedHostAccountRequest, runtime: Util.RuntimeOptions): CreateDedicatedHostAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.accountType)) {
    query['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.bastionInstanceId)) {
    query['BastionInstanceId'] = request.bastionInstanceId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDedicatedHostAccount',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDedicatedHostAccount(request: CreateDedicatedHostAccountRequest): CreateDedicatedHostAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDedicatedHostAccountWithOptions(request, runtime);
}

model CreateDedicatedHostGroupRequest {
  allocationPolicy?: string(name='AllocationPolicy'),
  clientToken?: string(name='ClientToken'),
  cpuAllocationRatio?: int32(name='CpuAllocationRatio'),
  dedicatedHostGroupDesc?: string(name='DedicatedHostGroupDesc'),
  diskAllocationRatio?: int32(name='DiskAllocationRatio'),
  engine?: string(name='Engine'),
  hostReplacePolicy?: string(name='HostReplacePolicy'),
  memAllocationRatio?: int32(name='MemAllocationRatio'),
  openPermission?: int32(name='OpenPermission'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VPCId?: string(name='VPCId'),
}

model CreateDedicatedHostGroupResponseBody = {
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateDedicatedHostGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDedicatedHostGroupResponseBody(name='body'),
}

async function createDedicatedHostGroupWithOptions(request: CreateDedicatedHostGroupRequest, runtime: Util.RuntimeOptions): CreateDedicatedHostGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocationPolicy)) {
    query['AllocationPolicy'] = request.allocationPolicy;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.cpuAllocationRatio)) {
    query['CpuAllocationRatio'] = request.cpuAllocationRatio;
  }
  if (!Util.isUnset(request.dedicatedHostGroupDesc)) {
    query['DedicatedHostGroupDesc'] = request.dedicatedHostGroupDesc;
  }
  if (!Util.isUnset(request.diskAllocationRatio)) {
    query['DiskAllocationRatio'] = request.diskAllocationRatio;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.hostReplacePolicy)) {
    query['HostReplacePolicy'] = request.hostReplacePolicy;
  }
  if (!Util.isUnset(request.memAllocationRatio)) {
    query['MemAllocationRatio'] = request.memAllocationRatio;
  }
  if (!Util.isUnset(request.openPermission)) {
    query['OpenPermission'] = request.openPermission;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDedicatedHostGroup',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDedicatedHostGroup(request: CreateDedicatedHostGroupRequest): CreateDedicatedHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDedicatedHostGroupWithOptions(request, runtime);
}

model CreateMyBaseRequest {
  autoRenew?: string(name='AutoRenew'),
  clientToken?: string(name='ClientToken'),
  dedicatedHostGroupDescription?: string(name='DedicatedHostGroupDescription'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  ECSClassList?: [ 
    {
      instanceType?: string(name='instanceType'),
      nodeCount?: int32(name='nodeCount'),
      sysDiskCapacity?: int32(name='sysDiskCapacity'),
      sysDiskType?: string(name='sysDiskType'),
    }
  ](name='ECSClassList'),
  engine?: string(name='Engine'),
  osPassword?: string(name='OsPassword'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  period?: string(name='Period'),
  periodType?: string(name='PeriodType'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityGroupId?: string(name='SecurityGroupId'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model CreateMyBaseShrinkRequest {
  autoRenew?: string(name='AutoRenew'),
  clientToken?: string(name='ClientToken'),
  dedicatedHostGroupDescription?: string(name='DedicatedHostGroupDescription'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  ECSClassListShrink?: string(name='ECSClassList'),
  engine?: string(name='Engine'),
  osPassword?: string(name='OsPassword'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  period?: string(name='Period'),
  periodType?: string(name='PeriodType'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityGroupId?: string(name='SecurityGroupId'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model CreateMyBaseResponseBody = {
  orderList?: {
    orderList?: [ 
    {
      createTimestamp?: long(name='CreateTimestamp'),
      ECSInstanceIds?: string(name='ECSInstanceIds'),
      orderId?: string(name='OrderId'),
    }
  ](name='OrderList')
  }(name='OrderList'),
  requestId?: string(name='RequestId'),
}

model CreateMyBaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMyBaseResponseBody(name='body'),
}

async function createMyBaseWithOptions(tmpReq: CreateMyBaseRequest, runtime: Util.RuntimeOptions): CreateMyBaseResponse {
  Util.validateModel(tmpReq);
  var request = new CreateMyBaseShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ECSClassList)) {
    request.ECSClassListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ECSClassList, 'ECSClassList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dedicatedHostGroupDescription)) {
    query['DedicatedHostGroupDescription'] = request.dedicatedHostGroupDescription;
  }
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.ECSClassListShrink)) {
    query['ECSClassList'] = request.ECSClassListShrink;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.osPassword)) {
    query['OsPassword'] = request.osPassword;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodType)) {
    query['PeriodType'] = request.periodType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMyBase',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMyBase(request: CreateMyBaseRequest): CreateMyBaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMyBaseWithOptions(request, runtime);
}

model DeleteDedicatedHostAccountRequest {
  accountName?: string(name='AccountName'),
  dedicatedHostId?: string(name='DedicatedHostId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDedicatedHostAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDedicatedHostAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDedicatedHostAccountResponseBody(name='body'),
}

async function deleteDedicatedHostAccountWithOptions(request: DeleteDedicatedHostAccountRequest, runtime: Util.RuntimeOptions): DeleteDedicatedHostAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDedicatedHostAccount',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDedicatedHostAccount(request: DeleteDedicatedHostAccountRequest): DeleteDedicatedHostAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDedicatedHostAccountWithOptions(request, runtime);
}

model DeleteDedicatedHostGroupRequest {
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDedicatedHostGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDedicatedHostGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDedicatedHostGroupResponseBody(name='body'),
}

async function deleteDedicatedHostGroupWithOptions(request: DeleteDedicatedHostGroupRequest, runtime: Util.RuntimeOptions): DeleteDedicatedHostGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDedicatedHostGroup',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDedicatedHostGroup(request: DeleteDedicatedHostGroupRequest): DeleteDedicatedHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDedicatedHostGroupWithOptions(request, runtime);
}

model DescribeDedicatedHostAttributeRequest {
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  dedicatedHostId?: string(name='DedicatedHostId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDedicatedHostAttributeResponseBody = {
  accountName?: string(name='AccountName'),
  accountType?: string(name='AccountType'),
  allocationStatus?: string(name='AllocationStatus'),
  autoRenew?: string(name='AutoRenew'),
  CPUAllocationRatio?: string(name='CPUAllocationRatio'),
  cpuUsed?: string(name='CpuUsed'),
  createdTime?: string(name='CreatedTime'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  dedicatedHostId?: string(name='DedicatedHostId'),
  diskAllocationRatio?: string(name='DiskAllocationRatio'),
  distributionTag?: string(name='DistributionTag'),
  ecsClassCode?: string(name='EcsClassCode'),
  expiredTime?: string(name='ExpiredTime'),
  hostCPU?: int32(name='HostCPU'),
  hostClass?: string(name='HostClass'),
  hostMem?: int32(name='HostMem'),
  hostName?: string(name='HostName'),
  hostStatus?: string(name='HostStatus'),
  hostStorage?: int32(name='HostStorage'),
  hostType?: string(name='HostType'),
  IPAddress?: string(name='IPAddress'),
  imageCategory?: string(name='ImageCategory'),
  instanceNumber?: int32(name='InstanceNumber'),
  instanceNumberMaster?: int32(name='InstanceNumberMaster'),
  instanceNumberROMaster?: int32(name='InstanceNumberROMaster'),
  instanceNumberROSlave?: int32(name='InstanceNumberROSlave'),
  instanceNumberSlave?: int32(name='InstanceNumberSlave'),
  memAllocationRatio?: string(name='MemAllocationRatio'),
  memoryUsed?: string(name='MemoryUsed'),
  openPermission?: string(name='OpenPermission'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  storageUsed?: string(name='StorageUsed'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeDedicatedHostAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDedicatedHostAttributeResponseBody(name='body'),
}

async function describeDedicatedHostAttributeWithOptions(request: DescribeDedicatedHostAttributeRequest, runtime: Util.RuntimeOptions): DescribeDedicatedHostAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDedicatedHostAttribute',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDedicatedHostAttribute(request: DescribeDedicatedHostAttributeRequest): DescribeDedicatedHostAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDedicatedHostAttributeWithOptions(request, runtime);
}

model DescribeDedicatedHostDisksRequest {
  dedicatedHostId?: string(name='DedicatedHostId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDedicatedHostDisksResponseBody = {
  dedicatedHostId?: string(name='DedicatedHostId'),
  disks?: [ 
    {
      category?: string(name='Category'),
      DBInstanceId?: string(name='DBInstanceId'),
      device?: string(name='Device'),
      diskId?: string(name='DiskId'),
      hasDBInstance?: boolean(name='HasDBInstance'),
      maxIOPS?: int32(name='MaxIOPS'),
      maxThroughput?: int32(name='MaxThroughput'),
      performanceLevel?: string(name='PerformanceLevel'),
      size?: int32(name='Size'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Disks'),
  requestId?: string(name='RequestId'),
}

model DescribeDedicatedHostDisksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDedicatedHostDisksResponseBody(name='body'),
}

async function describeDedicatedHostDisksWithOptions(request: DescribeDedicatedHostDisksRequest, runtime: Util.RuntimeOptions): DescribeDedicatedHostDisksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDedicatedHostDisks',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDedicatedHostDisks(request: DescribeDedicatedHostDisksRequest): DescribeDedicatedHostDisksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDedicatedHostDisksWithOptions(request, runtime);
}

model DescribeDedicatedHostGroupsRequest {
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  engine?: string(name='Engine'),
  imageCategory?: string(name='ImageCategory'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDedicatedHostGroupsResponseBody = {
  dedicatedHostGroups?: {
    dedicatedHostGroups?: [ 
    {
      allocationPolicy?: string(name='AllocationPolicy'),
      bastionInstanceId?: string(name='BastionInstanceId'),
      category?: string(name='Category'),
      cpuAllocateRation?: float(name='CpuAllocateRation'),
      cpuAllocatedAmount?: float(name='CpuAllocatedAmount'),
      cpuAllocationRatio?: int32(name='CpuAllocationRatio'),
      createTime?: string(name='CreateTime'),
      dedicatedHostCountGroupByHostType?: map[string]any(name='DedicatedHostCountGroupByHostType'),
      dedicatedHostGroupDesc?: string(name='DedicatedHostGroupDesc'),
      dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
      deployType?: string(name='DeployType'),
      diskAllocateRation?: float(name='DiskAllocateRation'),
      diskAllocatedAmount?: float(name='DiskAllocatedAmount'),
      diskAllocationRatio?: int32(name='DiskAllocationRatio'),
      diskUsedAmount?: float(name='DiskUsedAmount'),
      diskUtility?: float(name='DiskUtility'),
      engine?: string(name='Engine'),
      hostNumber?: int32(name='HostNumber'),
      hostReplacePolicy?: string(name='HostReplacePolicy'),
      instanceNumber?: int32(name='InstanceNumber'),
      memAllocateRation?: float(name='MemAllocateRation'),
      memAllocatedAmount?: float(name='MemAllocatedAmount'),
      memAllocationRatio?: int32(name='MemAllocationRatio'),
      memUsedAmount?: float(name='MemUsedAmount'),
      memUtility?: float(name='MemUtility'),
      openPermission?: string(name='OpenPermission'),
      text?: string(name='Text'),
      VPCId?: string(name='VPCId'),
      zoneIDList?: {
        zoneIDList?: [ string ](name='ZoneIDList')
      }(name='ZoneIDList'),
    }
  ](name='DedicatedHostGroups')
  }(name='DedicatedHostGroups'),
  requestId?: string(name='RequestId'),
}

model DescribeDedicatedHostGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDedicatedHostGroupsResponseBody(name='body'),
}

async function describeDedicatedHostGroupsWithOptions(request: DescribeDedicatedHostGroupsRequest, runtime: Util.RuntimeOptions): DescribeDedicatedHostGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.imageCategory)) {
    query['ImageCategory'] = request.imageCategory;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDedicatedHostGroups',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDedicatedHostGroups(request: DescribeDedicatedHostGroupsRequest): DescribeDedicatedHostGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDedicatedHostGroupsWithOptions(request, runtime);
}

model DescribeDedicatedHostsRequest {
  allocationStatus?: string(name='AllocationStatus'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  dedicatedHostId?: string(name='DedicatedHostId'),
  hostStatus?: string(name='HostStatus'),
  hostType?: string(name='HostType'),
  orderId?: long(name='OrderId'),
  ownerId?: long(name='OwnerId'),
  pageNumbers?: int32(name='PageNumbers'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tags?: string(name='Tags'),
  zoneId?: string(name='ZoneId'),
}

model DescribeDedicatedHostsResponseBody = {
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  dedicatedHosts?: {
    dedicatedHosts?: [ 
    {
      accountName?: string(name='AccountName'),
      accountType?: string(name='AccountType'),
      allocationStatus?: string(name='AllocationStatus'),
      bastionInstanceId?: string(name='BastionInstanceId'),
      CPUAllocationRatio?: string(name='CPUAllocationRatio'),
      category?: string(name='Category'),
      chargeType?: string(name='ChargeType'),
      cpuUsed?: string(name='CpuUsed'),
      createdTime?: string(name='CreatedTime'),
      dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
      dedicatedHostId?: string(name='DedicatedHostId'),
      diskAllocationRatio?: string(name='DiskAllocationRatio'),
      diskInfo?: string(name='DiskInfo'),
      distributionSymbol?: string(name='DistributionSymbol'),
      distributionTag?: string(name='DistributionTag'),
      ecsClassCode?: string(name='EcsClassCode'),
      ecsId?: string(name='EcsId'),
      endTime?: string(name='EndTime'),
      engine?: string(name='Engine'),
      hostCPU?: string(name='HostCPU'),
      hostClass?: string(name='HostClass'),
      hostMem?: string(name='HostMem'),
      hostName?: string(name='HostName'),
      hostStatus?: string(name='HostStatus'),
      hostStorage?: string(name='HostStorage'),
      hostType?: string(name='HostType'),
      IPAddress?: string(name='IPAddress'),
      imageCategory?: string(name='ImageCategory'),
      instanceNumber?: string(name='InstanceNumber'),
      memAllocationRatio?: string(name='MemAllocationRatio'),
      memoryUsed?: string(name='MemoryUsed'),
      mssqlSupportVersion?: string(name='MssqlSupportVersion'),
      openPermission?: string(name='OpenPermission'),
      storageUsed?: string(name='StorageUsed'),
      VPCId?: string(name='VPCId'),
      vSwitchId?: string(name='VSwitchId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DedicatedHosts')
  }(name='DedicatedHosts'),
  maxAutoScaleHostStorage?: long(name='MaxAutoScaleHostStorage'),
  pageNumbers?: int32(name='PageNumbers'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalRecords?: int32(name='TotalRecords'),
}

model DescribeDedicatedHostsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDedicatedHostsResponseBody(name='body'),
}

async function describeDedicatedHostsWithOptions(request: DescribeDedicatedHostsRequest, runtime: Util.RuntimeOptions): DescribeDedicatedHostsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocationStatus)) {
    query['AllocationStatus'] = request.allocationStatus;
  }
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.hostStatus)) {
    query['HostStatus'] = request.hostStatus;
  }
  if (!Util.isUnset(request.hostType)) {
    query['HostType'] = request.hostType;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumbers)) {
    query['PageNumbers'] = request.pageNumbers;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDedicatedHosts',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDedicatedHosts(request: DescribeDedicatedHostsRequest): DescribeDedicatedHostsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDedicatedHostsWithOptions(request, runtime);
}

model DescribeHostEcsLevelInfoRequest {
  commodityCode?: string(name='CommodityCode'),
  dbType?: string(name='DbType'),
  imageCategory?: string(name='ImageCategory'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  storageType?: string(name='StorageType'),
  zoneId?: string(name='ZoneId'),
}

model DescribeHostEcsLevelInfoResponseBody = {
  hostEcsLevelInfos?: [ 
    {
      cddcHostType?: string(name='CddcHostType'),
      items?: [ 
        {
          cloudStorageBandwidth?: float(name='CloudStorageBandwidth'),
          cpu?: int32(name='Cpu'),
          cpuFrequency?: string(name='CpuFrequency'),
          cpuVersion?: string(name='CpuVersion'),
          description?: string(name='Description'),
          ecsClass?: string(name='EcsClass'),
          ecsClassCode?: string(name='EcsClassCode'),
          isCloudDisk?: int32(name='IsCloudDisk'),
          localStorage?: string(name='LocalStorage'),
          memory?: int32(name='Memory'),
          netBandWidth?: float(name='NetBandWidth'),
          netPackage?: int32(name='NetPackage'),
          rdsClassCode?: string(name='RdsClassCode'),
          storageIops?: int32(name='StorageIops'),
        }
      ](name='Items'),
    }
  ](name='HostEcsLevelInfos'),
  requestId?: string(name='RequestId'),
}

model DescribeHostEcsLevelInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHostEcsLevelInfoResponseBody(name='body'),
}

async function describeHostEcsLevelInfoWithOptions(request: DescribeHostEcsLevelInfoRequest, runtime: Util.RuntimeOptions): DescribeHostEcsLevelInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.commodityCode)) {
    query['CommodityCode'] = request.commodityCode;
  }
  if (!Util.isUnset(request.dbType)) {
    query['DbType'] = request.dbType;
  }
  if (!Util.isUnset(request.imageCategory)) {
    query['ImageCategory'] = request.imageCategory;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHostEcsLevelInfo',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHostEcsLevelInfo(request: DescribeHostEcsLevelInfoRequest): DescribeHostEcsLevelInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHostEcsLevelInfoWithOptions(request, runtime);
}

model DescribeHostSecurityGroupAttributeRequest {
  dedicatedHostId?: string(name='DedicatedHostId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeHostSecurityGroupAttributeResponseBody = {
  requestId?: string(name='RequestId'),
  secGroupPermission?: {
    secGroupPermission?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      direction?: string(name='Direction'),
      ipProtocol?: string(name='IpProtocol'),
      nicType?: string(name='NicType'),
      policy?: string(name='Policy'),
      portRange?: string(name='PortRange'),
      sourceCidrIp?: string(name='SourceCidrIp'),
    }
  ](name='SecGroupPermission')
  }(name='SecGroupPermission'),
  success?: int32(name='Success'),
}

model DescribeHostSecurityGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHostSecurityGroupAttributeResponseBody(name='body'),
}

async function describeHostSecurityGroupAttributeWithOptions(request: DescribeHostSecurityGroupAttributeRequest, runtime: Util.RuntimeOptions): DescribeHostSecurityGroupAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHostSecurityGroupAttribute',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHostSecurityGroupAttribute(request: DescribeHostSecurityGroupAttributeRequest): DescribeHostSecurityGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHostSecurityGroupAttributeWithOptions(request, runtime);
}

model DescribeHostWebShellRequest {
  dedicatedHostId?: string(name='DedicatedHostId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeHostWebShellResponseBody = {
  loginUrl?: string(name='LoginUrl'),
  requestId?: string(name='RequestId'),
}

model DescribeHostWebShellResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHostWebShellResponseBody(name='body'),
}

async function describeHostWebShellWithOptions(request: DescribeHostWebShellRequest, runtime: Util.RuntimeOptions): DescribeHostWebShellResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHostWebShell',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHostWebShell(request: DescribeHostWebShellRequest): DescribeHostWebShellResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHostWebShellWithOptions(request, runtime);
}

model DescribeMyBaseHostOverViewRequest {
  ownerId?: long(name='OwnerId'),
  region?: string(name='Region'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeMyBaseHostOverViewResponseBody = {
  regions?: {
    regionModel?: [ 
    {
      engineCount?: string(name='EngineCount'),
      hostGroupCount?: int32(name='HostGroupCount'),
      region?: string(name='Region'),
      totalCount?: int32(name='TotalCount'),
      typeModels?: {
        typeModel?: [ 
        {
          count?: int32(name='Count'),
          hostDateType?: string(name='HostDateType'),
          hostEngineCount?: string(name='HostEngineCount'),
        }
      ](name='TypeModel')
      }(name='TypeModels'),
    }
  ](name='RegionModel')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeMyBaseHostOverViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMyBaseHostOverViewResponseBody(name='body'),
}

async function describeMyBaseHostOverViewWithOptions(request: DescribeMyBaseHostOverViewRequest, runtime: Util.RuntimeOptions): DescribeMyBaseHostOverViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMyBaseHostOverView',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMyBaseHostOverView(request: DescribeMyBaseHostOverViewRequest): DescribeMyBaseHostOverViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMyBaseHostOverViewWithOptions(request, runtime);
}

model DescribeMyBaseInstanceOverViewRequest {
  ownerId?: long(name='OwnerId'),
  region?: string(name='Region'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeMyBaseInstanceOverViewResponseBody = {
  regions?: {
    regionModel?: [ 
    {
      engineCount?: string(name='EngineCount'),
      region?: string(name='Region'),
      totalCount?: int32(name='TotalCount'),
      typeModels?: {
        typeModel?: [ 
        {
          count?: int32(name='Count'),
          instanceDateType?: string(name='InstanceDateType'),
          instanceEngineCount?: string(name='InstanceEngineCount'),
          instanceModels?: {
            instanceModel?: [ 
            {
              createdTime?: string(name='CreatedTime'),
              DBInstanceId?: string(name='DBInstanceId'),
              DBInstanceStatus?: string(name='DBInstanceStatus'),
              expireTime?: string(name='ExpireTime'),
              payType?: string(name='PayType'),
              zoneId?: string(name='ZoneId'),
            }
          ](name='InstanceModel')
          }(name='InstanceModels'),
        }
      ](name='TypeModel')
      }(name='TypeModels'),
    }
  ](name='RegionModel')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeMyBaseInstanceOverViewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMyBaseInstanceOverViewResponseBody(name='body'),
}

async function describeMyBaseInstanceOverViewWithOptions(request: DescribeMyBaseInstanceOverViewRequest, runtime: Util.RuntimeOptions): DescribeMyBaseInstanceOverViewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMyBaseInstanceOverView',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMyBaseInstanceOverView(request: DescribeMyBaseInstanceOverViewRequest): DescribeMyBaseInstanceOverViewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMyBaseInstanceOverViewWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    RDSRegion?: [ 
    {
      regionId?: string(name='RegionId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='RDSRegion')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyDedicatedHostAccountRequest {
  accountName?: string(name='AccountName'),
  accountPassword?: string(name='AccountPassword'),
  dedicatedHostId?: string(name='DedicatedHostId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDedicatedHostAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDedicatedHostAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDedicatedHostAccountResponseBody(name='body'),
}

async function modifyDedicatedHostAccountWithOptions(request: ModifyDedicatedHostAccountRequest, runtime: Util.RuntimeOptions): ModifyDedicatedHostAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDedicatedHostAccount',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDedicatedHostAccount(request: ModifyDedicatedHostAccountRequest): ModifyDedicatedHostAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDedicatedHostAccountWithOptions(request, runtime);
}

model ModifyDedicatedHostAttributeRequest {
  allocationStatus?: string(name='AllocationStatus'),
  dedicatedHostId?: string(name='DedicatedHostId'),
  hostName?: string(name='HostName'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDedicatedHostAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDedicatedHostAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDedicatedHostAttributeResponseBody(name='body'),
}

async function modifyDedicatedHostAttributeWithOptions(request: ModifyDedicatedHostAttributeRequest, runtime: Util.RuntimeOptions): ModifyDedicatedHostAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocationStatus)) {
    query['AllocationStatus'] = request.allocationStatus;
  }
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDedicatedHostAttribute',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDedicatedHostAttribute(request: ModifyDedicatedHostAttributeRequest): ModifyDedicatedHostAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDedicatedHostAttributeWithOptions(request, runtime);
}

model ModifyDedicatedHostClassRequest {
  dedicatedHostId?: string(name='DedicatedHostId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  switchTime?: string(name='SwitchTime'),
  switchTimeMode?: string(name='SwitchTimeMode'),
  targetClassCode?: string(name='TargetClassCode'),
}

model ModifyDedicatedHostClassResponseBody = {
  dedicatedHostId?: string(name='DedicatedHostId'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ModifyDedicatedHostClassResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDedicatedHostClassResponseBody(name='body'),
}

async function modifyDedicatedHostClassWithOptions(request: ModifyDedicatedHostClassRequest, runtime: Util.RuntimeOptions): ModifyDedicatedHostClassResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.switchTime)) {
    query['SwitchTime'] = request.switchTime;
  }
  if (!Util.isUnset(request.switchTimeMode)) {
    query['SwitchTimeMode'] = request.switchTimeMode;
  }
  if (!Util.isUnset(request.targetClassCode)) {
    query['TargetClassCode'] = request.targetClassCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDedicatedHostClass',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDedicatedHostClass(request: ModifyDedicatedHostClassRequest): ModifyDedicatedHostClassResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDedicatedHostClassWithOptions(request, runtime);
}

model ModifyDedicatedHostGroupAttributeRequest {
  allocationPolicy?: string(name='AllocationPolicy'),
  cpuAllocationRatio?: int32(name='CpuAllocationRatio'),
  dedicatedHostGroupDesc?: string(name='DedicatedHostGroupDesc'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  diskAllocationRatio?: int32(name='DiskAllocationRatio'),
  hostReplacePolicy?: string(name='HostReplacePolicy'),
  memAllocationRatio?: int32(name='MemAllocationRatio'),
  openPermission?: string(name='OpenPermission'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDedicatedHostGroupAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDedicatedHostGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDedicatedHostGroupAttributeResponseBody(name='body'),
}

async function modifyDedicatedHostGroupAttributeWithOptions(request: ModifyDedicatedHostGroupAttributeRequest, runtime: Util.RuntimeOptions): ModifyDedicatedHostGroupAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocationPolicy)) {
    query['AllocationPolicy'] = request.allocationPolicy;
  }
  if (!Util.isUnset(request.cpuAllocationRatio)) {
    query['CpuAllocationRatio'] = request.cpuAllocationRatio;
  }
  if (!Util.isUnset(request.dedicatedHostGroupDesc)) {
    query['DedicatedHostGroupDesc'] = request.dedicatedHostGroupDesc;
  }
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.diskAllocationRatio)) {
    query['DiskAllocationRatio'] = request.diskAllocationRatio;
  }
  if (!Util.isUnset(request.hostReplacePolicy)) {
    query['HostReplacePolicy'] = request.hostReplacePolicy;
  }
  if (!Util.isUnset(request.memAllocationRatio)) {
    query['MemAllocationRatio'] = request.memAllocationRatio;
  }
  if (!Util.isUnset(request.openPermission)) {
    query['OpenPermission'] = request.openPermission;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDedicatedHostGroupAttribute',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDedicatedHostGroupAttribute(request: ModifyDedicatedHostGroupAttributeRequest): ModifyDedicatedHostGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDedicatedHostGroupAttributeWithOptions(request, runtime);
}

model ModifyDedicatedHostPasswordRequest {
  dedicatedHostId?: string(name='DedicatedHostId'),
  newPassword?: string(name='NewPassword'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDedicatedHostPasswordResponseBody = {
  dedicatedHostName?: string(name='DedicatedHostName'),
  requestId?: string(name='RequestId'),
}

model ModifyDedicatedHostPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDedicatedHostPasswordResponseBody(name='body'),
}

async function modifyDedicatedHostPasswordWithOptions(request: ModifyDedicatedHostPasswordRequest, runtime: Util.RuntimeOptions): ModifyDedicatedHostPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.newPassword)) {
    query['NewPassword'] = request.newPassword;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDedicatedHostPassword',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDedicatedHostPassword(request: ModifyDedicatedHostPasswordRequest): ModifyDedicatedHostPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDedicatedHostPasswordWithOptions(request, runtime);
}

model QueryHostBaseInfoByInstanceRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryHostBaseInfoByInstanceResponseBody = {
  hostInstanceConsoleInfos?: [ 
    {
      clusterName?: string(name='ClusterName'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      expiredTime?: string(name='ExpiredTime'),
      hostName?: string(name='HostName'),
      ip?: string(name='Ip'),
      port?: string(name='Port'),
      role?: string(name='Role'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
    }
  ](name='HostInstanceConsoleInfos'),
  requestId?: string(name='RequestId'),
}

model QueryHostBaseInfoByInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryHostBaseInfoByInstanceResponseBody(name='body'),
}

async function queryHostBaseInfoByInstanceWithOptions(request: QueryHostBaseInfoByInstanceRequest, runtime: Util.RuntimeOptions): QueryHostBaseInfoByInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryHostBaseInfoByInstance',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryHostBaseInfoByInstance(request: QueryHostBaseInfoByInstanceRequest): QueryHostBaseInfoByInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryHostBaseInfoByInstanceWithOptions(request, runtime);
}

model QueryHostInstanceConsoleInfoRequest {
  dedicatedHostId?: string(name='DedicatedHostId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model QueryHostInstanceConsoleInfoResponseBody = {
  hostInstanceConsoleInfos?: [ 
    {
      cpuCores?: int32(name='CpuCores'),
      cpuIncreaseRatioValue?: int32(name='CpuIncreaseRatioValue'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      diskSize?: int32(name='DiskSize'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      ip?: string(name='Ip'),
      levelName?: string(name='LevelName'),
      maxConnIncreaseRatioValue?: int32(name='MaxConnIncreaseRatioValue'),
      memSize?: int32(name='MemSize'),
      memoryIncreaseRatioValue?: int32(name='MemoryIncreaseRatioValue'),
      perfInfo?: {
        cpuRatio?: float(name='CpuRatio'),
        diskCurr?: float(name='DiskCurr'),
        memRatio?: float(name='MemRatio'),
        perfIdbPio?: float(name='PerfIdbPio'),
      }(name='PerfInfo'),
      port?: string(name='Port'),
      role?: string(name='Role'),
      status?: string(name='Status'),
    }
  ](name='HostInstanceConsoleInfos'),
  requestId?: string(name='RequestId'),
}

model QueryHostInstanceConsoleInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryHostInstanceConsoleInfoResponseBody(name='body'),
}

async function queryHostInstanceConsoleInfoWithOptions(request: QueryHostInstanceConsoleInfoRequest, runtime: Util.RuntimeOptions): QueryHostInstanceConsoleInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryHostInstanceConsoleInfo',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryHostInstanceConsoleInfo(request: QueryHostInstanceConsoleInfoRequest): QueryHostInstanceConsoleInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryHostInstanceConsoleInfoWithOptions(request, runtime);
}

model ReplaceDedicatedHostRequest {
  dedicatedHostId?: string(name='DedicatedHostId'),
  failoverMode?: string(name='FailoverMode'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ReplaceDedicatedHostResponseBody = {
  dedicatedHostId?: string(name='DedicatedHostId'),
  requestId?: string(name='RequestId'),
  taskId?: int32(name='TaskId'),
}

model ReplaceDedicatedHostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReplaceDedicatedHostResponseBody(name='body'),
}

async function replaceDedicatedHostWithOptions(request: ReplaceDedicatedHostRequest, runtime: Util.RuntimeOptions): ReplaceDedicatedHostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.failoverMode)) {
    query['FailoverMode'] = request.failoverMode;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReplaceDedicatedHost',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function replaceDedicatedHost(request: ReplaceDedicatedHostRequest): ReplaceDedicatedHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return replaceDedicatedHostWithOptions(request, runtime);
}

model RestartDedicatedHostRequest {
  dedicatedHostId?: string(name='DedicatedHostId'),
  failoverMode?: string(name='FailoverMode'),
  forceStop?: boolean(name='ForceStop'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RestartDedicatedHostResponseBody = {
  dedicatedHostId?: string(name='DedicatedHostId'),
  requestId?: string(name='RequestId'),
  taskId?: int32(name='TaskId'),
}

model RestartDedicatedHostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartDedicatedHostResponseBody(name='body'),
}

async function restartDedicatedHostWithOptions(request: RestartDedicatedHostRequest, runtime: Util.RuntimeOptions): RestartDedicatedHostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.failoverMode)) {
    query['FailoverMode'] = request.failoverMode;
  }
  if (!Util.isUnset(request.forceStop)) {
    query['ForceStop'] = request.forceStop;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartDedicatedHost',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartDedicatedHost(request: RestartDedicatedHostRequest): RestartDedicatedHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartDedicatedHostWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model ListRequest {
  aliUid?: long(name='AliUid'),
  bid?: string(name='Bid'),
  keys?: [ string ](name='Keys'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceIds?: [ string ](name='ResourceIds'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  values?: [ string ](name='Values'),
}

model ListResponseBody = {
  requestId?: string(name='RequestId'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResources'),
}

model ListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResponseBody(name='body'),
}

async function listWithOptions(request: ListRequest, runtime: Util.RuntimeOptions): ListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.bid)) {
    query['Bid'] = request.bid;
  }
  if (!Util.isUnset(request.keys)) {
    query['Keys'] = request.keys;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.values)) {
    query['Values'] = request.values;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'list',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function list(request: ListRequest): ListResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWithOptions(request, runtime);
}

model TagRequest {
  aliUid?: long(name='AliUid'),
  bid?: string(name='Bid'),
  keys?: [ string ](name='Keys'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceIds?: [ string ](name='ResourceIds'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  values?: [ string ](name='Values'),
}

model TagResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResponseBody(name='body'),
}

async function tagWithOptions(request: TagRequest, runtime: Util.RuntimeOptions): TagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.bid)) {
    query['Bid'] = request.bid;
  }
  if (!Util.isUnset(request.keys)) {
    query['Keys'] = request.keys;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.values)) {
    query['Values'] = request.values;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'tag',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tag(request: TagRequest): TagResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagWithOptions(request, runtime);
}

model UntagRequest {
  aliUid?: long(name='AliUid'),
  all?: boolean(name='All'),
  bid?: string(name='Bid'),
  keys?: [ string ](name='Keys'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  release?: boolean(name='Release'),
  resourceIds?: [ string ](name='ResourceIds'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  values?: [ string ](name='Values'),
}

model UntagResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResponseBody(name='body'),
}

async function untagWithOptions(request: UntagRequest, runtime: Util.RuntimeOptions): UntagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.bid)) {
    query['Bid'] = request.bid;
  }
  if (!Util.isUnset(request.keys)) {
    query['Keys'] = request.keys;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.release)) {
    query['Release'] = request.release;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.values)) {
    query['Values'] = request.values;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'untag',
    version = '2020-03-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untag(request: UntagRequest): UntagResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagWithOptions(request, runtime);
}

