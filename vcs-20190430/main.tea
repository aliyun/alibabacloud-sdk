/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('vcs', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateComputeTaskRequest {
  algorithmCodeList?: string(name='AlgorithmCodeList'),
  deviceCodeList?: string(name='DeviceCodeList'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  taskName?: string(name='TaskName'),
  vcsId?: string(name='VcsId'),
}

model CreateComputeTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    taskId?: string(name='TaskId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateComputeTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateComputeTaskResponseBody(name='body'),
}

async function createComputeTaskWithOptions(request: CreateComputeTaskRequest, runtime: Util.RuntimeOptions): CreateComputeTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithmCodeList)) {
    query['AlgorithmCodeList'] = request.algorithmCodeList;
  }
  if (!Util.isUnset(request.deviceCodeList)) {
    query['DeviceCodeList'] = request.deviceCodeList;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.vcsId)) {
    query['VcsId'] = request.vcsId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateComputeTask',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createComputeTask(request: CreateComputeTaskRequest): CreateComputeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createComputeTaskWithOptions(request, runtime);
}

model CreateProjectRequest {
  areaCode?: string(name='AreaCode'),
  projectName?: string(name='ProjectName'),
  regionId?: string(name='RegionId'),
  timeZoneCode?: string(name='TimeZoneCode'),
  vcsId?: string(name='VcsId'),
}

model CreateProjectResponseBody = {
  code?: string(name='Code'),
  data?: {
    projectId?: string(name='ProjectId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateProjectResponse = {
  headers: map[string]string(name='headers'),
  body: CreateProjectResponseBody(name='body'),
}

async function createProjectWithOptions(request: CreateProjectRequest, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.areaCode)) {
    query['AreaCode'] = request.areaCode;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.timeZoneCode)) {
    query['TimeZoneCode'] = request.timeZoneCode;
  }
  if (!Util.isUnset(request.vcsId)) {
    query['VcsId'] = request.vcsId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProject',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProjectWithOptions(request, runtime);
}

model DescribeComputeTasksRequest {
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  searchKey?: string(name='SearchKey'),
  vcsId?: string(name='VcsId'),
}

model DescribeComputeTasksResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      algorithmName?: string(name='AlgorithmName'),
      deviceNum?: int32(name='DeviceNum'),
      imageSize?: float(name='ImageSize'),
      runtime?: string(name='Runtime'),
      structuredSize?: float(name='StructuredSize'),
      taskId?: string(name='TaskId'),
      taskName?: string(name='TaskName'),
      taskStatus?: string(name='TaskStatus'),
      vectorSize?: float(name='VectorSize'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeComputeTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeComputeTasksResponseBody(name='body'),
}

async function describeComputeTasksWithOptions(request: DescribeComputeTasksRequest, runtime: Util.RuntimeOptions): DescribeComputeTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.searchKey)) {
    query['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.vcsId)) {
    query['VcsId'] = request.vcsId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeComputeTasks',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeComputeTasks(request: DescribeComputeTasksRequest): DescribeComputeTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeComputeTasksWithOptions(request, runtime);
}

model DescribeDevicesRequest {
  filterKey?: string(name='FilterKey'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  searchKey?: string(name='SearchKey'),
  vcsId?: string(name='VcsId'),
}

model DescribeDevicesResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      deviceCode?: string(name='DeviceCode'),
      deviceId?: string(name='DeviceId'),
      deviceName?: string(name='DeviceName'),
      deviceType?: string(name='DeviceType'),
      frameRate?: string(name='FrameRate'),
      imageSize?: float(name='ImageSize'),
      location?: string(name='Location'),
      owner?: string(name='Owner'),
      pullStreamStatus?: string(name='PullStreamStatus'),
      realTimeDataRate?: string(name='RealTimeDataRate'),
      structuredSize?: float(name='StructuredSize'),
      vectorSize?: float(name='VectorSize'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDevicesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDevicesResponseBody(name='body'),
}

async function describeDevicesWithOptions(request: DescribeDevicesRequest, runtime: Util.RuntimeOptions): DescribeDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filterKey)) {
    query['FilterKey'] = request.filterKey;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.searchKey)) {
    query['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.vcsId)) {
    query['VcsId'] = request.vcsId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDevices',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDevices(request: DescribeDevicesRequest): DescribeDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDevicesWithOptions(request, runtime);
}

model DescribeProjectsRequest {
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  projectName?: string(name='ProjectName'),
  regionId?: string(name='RegionId'),
  vcsId?: string(name='VcsId'),
}

model DescribeProjectsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      algorithmName?: string(name='AlgorithmName'),
      gbId?: string(name='GbId'),
      gbIp?: string(name='GbIp'),
      gbPort?: string(name='GbPort'),
      imageSize?: float(name='ImageSize'),
      packagePattern?: string(name='PackagePattern'),
      projectCode?: string(name='ProjectCode'),
      projectId?: string(name='ProjectId'),
      projectName?: string(name='ProjectName'),
      protocol?: string(name='Protocol'),
      status?: string(name='Status'),
      structuredSize?: float(name='StructuredSize'),
      vectorSize?: float(name='VectorSize'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeProjectsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeProjectsResponseBody(name='body'),
}

async function describeProjectsWithOptions(request: DescribeProjectsRequest, runtime: Util.RuntimeOptions): DescribeProjectsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vcsId)) {
    query['VcsId'] = request.vcsId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeProjects',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeProjects(request: DescribeProjectsRequest): DescribeProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProjectsWithOptions(request, runtime);
}

model GetPictureSearchResultsRequest {
  algorithmType?: string(name='AlgorithmType'),
  beginTime?: string(name='BeginTime'),
  deviceList?: string(name='DeviceList'),
  endTime?: string(name='EndTime'),
  pageNum?: int32(name='PageNum'),
  pictureContents?: string(name='PictureContents'),
  regionId?: string(name='RegionId'),
  topNum?: int32(name='TopNum'),
  vcsId?: string(name='VcsId'),
}

model GetPictureSearchResultsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      deviceId?: string(name='DeviceId'),
      leftUpperCornerXCoordinate?: string(name='LeftUpperCornerXCoordinate'),
      leftUpperCornerYCoordinate?: string(name='LeftUpperCornerYCoordinate'),
      locationMarkTime?: string(name='LocationMarkTime'),
      pictureId1?: string(name='PictureId1'),
      pictureId2?: string(name='PictureId2'),
      pictureUrl1?: string(name='PictureUrl1'),
      pictureUrl2?: string(name='PictureUrl2'),
      rightLowerCornerXCoordinate?: string(name='RightLowerCornerXCoordinate'),
      rightLowerCornerYCoordinate?: string(name='RightLowerCornerYCoordinate'),
      similarity?: float(name='Similarity'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetPictureSearchResultsResponse = {
  headers: map[string]string(name='headers'),
  body: GetPictureSearchResultsResponseBody(name='body'),
}

async function getPictureSearchResultsWithOptions(request: GetPictureSearchResultsRequest, runtime: Util.RuntimeOptions): GetPictureSearchResultsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithmType)) {
    query['AlgorithmType'] = request.algorithmType;
  }
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.deviceList)) {
    query['DeviceList'] = request.deviceList;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pictureContents)) {
    query['PictureContents'] = request.pictureContents;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.topNum)) {
    query['TopNum'] = request.topNum;
  }
  if (!Util.isUnset(request.vcsId)) {
    query['VcsId'] = request.vcsId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPictureSearchResults',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPictureSearchResults(request: GetPictureSearchResultsRequest): GetPictureSearchResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPictureSearchResultsWithOptions(request, runtime);
}

model ImportDevicesRequest {
  deviceList?: string(name='DeviceList'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  vcsId?: string(name='VcsId'),
}

model ImportDevicesResponseBody = {
  code?: string(name='Code'),
  data?: {
    failure?: [ 
      {
        deviceCode?: string(name='DeviceCode'),
        deviceId?: string(name='DeviceId'),
      }
    ](name='Failure'),
    success?: [ 
      {
        deviceCode?: string(name='DeviceCode'),
        deviceId?: string(name='DeviceId'),
      }
    ](name='Success'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ImportDevicesResponse = {
  headers: map[string]string(name='headers'),
  body: ImportDevicesResponseBody(name='body'),
}

async function importDevicesWithOptions(request: ImportDevicesRequest, runtime: Util.RuntimeOptions): ImportDevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceList)) {
    query['DeviceList'] = request.deviceList;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.vcsId)) {
    query['VcsId'] = request.vcsId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportDevices',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importDevices(request: ImportDevicesRequest): ImportDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return importDevicesWithOptions(request, runtime);
}

