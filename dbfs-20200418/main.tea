/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  @endpointMap = {
    ap-northeast-2-pop = 'dbfs.aliyuncs.com',
    cn-beijing-finance-1 = 'dbfs.aliyuncs.com',
    cn-beijing-finance-pop = 'dbfs.aliyuncs.com',
    cn-beijing-gov-1 = 'dbfs.aliyuncs.com',
    cn-beijing-nu16-b01 = 'dbfs.aliyuncs.com',
    cn-edge-1 = 'dbfs.aliyuncs.com',
    cn-fujian = 'dbfs.aliyuncs.com',
    cn-haidian-cm12-c01 = 'dbfs.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'dbfs.aliyuncs.com',
    cn-hangzhou-finance = 'dbfs.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'dbfs.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'dbfs.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'dbfs.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'dbfs.aliyuncs.com',
    cn-hangzhou-test-306 = 'dbfs.aliyuncs.com',
    cn-hongkong-finance-pop = 'dbfs.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'dbfs.aliyuncs.com',
    cn-north-2-gov-1 = 'dbfs.aliyuncs.com',
    cn-qingdao-nebula = 'dbfs.aliyuncs.com',
    cn-shanghai-et15-b01 = 'dbfs.aliyuncs.com',
    cn-shanghai-et2-b01 = 'dbfs.aliyuncs.com',
    cn-shanghai-finance-1 = 'dbfs.aliyuncs.com',
    cn-shanghai-inner = 'dbfs.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'dbfs.aliyuncs.com',
    cn-shenzhen-finance-1 = 'dbfs.aliyuncs.com',
    cn-shenzhen-inner = 'dbfs.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'dbfs.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'dbfs.aliyuncs.com',
    cn-wuhan = 'dbfs.aliyuncs.com',
    cn-wulanchabu = 'dbfs.aliyuncs.com',
    cn-yushanfang = 'dbfs.aliyuncs.com',
    cn-zhangbei = 'dbfs.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'dbfs.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'dbfs.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'dbfs.aliyuncs.com',
    eu-west-1-oxs = 'dbfs.aliyuncs.com',
    rus-west-1-pop = 'dbfs.aliyuncs.com',
  };
  checkConfig(config);
  @endpoint = getEndpoint('dbfs', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CreateConstantsRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  constantsData?: string(name='ConstantsData'),
}

model CreateConstantsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: string(name='Data'),
  pageSize?: long(name='PageSize'),
  totalCount?: long(name='TotalCount'),
  pageNumber?: long(name='PageNumber'),
}

model CreateConstantsResponse = {
  headers: map[string]string(name='headers'),
  body: CreateConstantsResponseBody(name='body'),
}

async function createConstantsWithOptions(request: CreateConstantsRequest, runtime: Util.RuntimeOptions): CreateConstantsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateConstants', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createConstants(request: CreateConstantsRequest): CreateConstantsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConstantsWithOptions(request, runtime);
}

model DeleteDbfsRequest {
  fsId?: string(name='FsId'),
  regionId?: string(name='RegionId'),
}

model DeleteDbfsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDbfsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDbfsResponseBody(name='body'),
}

async function deleteDbfsWithOptions(request: DeleteDbfsRequest, runtime: Util.RuntimeOptions): DeleteDbfsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteDbfs', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteDbfs(request: DeleteDbfsRequest): DeleteDbfsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDbfsWithOptions(request, runtime);
}

model DeleteConstantsRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  constantsData?: string(name='ConstantsData'),
}

model DeleteConstantsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: string(name='Data'),
  pageSize?: long(name='PageSize'),
  totalCount?: long(name='TotalCount'),
  pageNumber?: long(name='PageNumber'),
}

model DeleteConstantsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteConstantsResponseBody(name='body'),
}

async function deleteConstantsWithOptions(request: DeleteConstantsRequest, runtime: Util.RuntimeOptions): DeleteConstantsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteConstants', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteConstants(request: DeleteConstantsRequest): DeleteConstantsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConstantsWithOptions(request, runtime);
}

model CreateServiceLinkedRoleRequest {
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
}

model CreateServiceLinkedRoleResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateServiceLinkedRoleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceLinkedRoleResponseBody(name='body'),
}

async function createServiceLinkedRoleWithOptions(request: CreateServiceLinkedRoleRequest, runtime: Util.RuntimeOptions): CreateServiceLinkedRoleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateServiceLinkedRole', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createServiceLinkedRole(request: CreateServiceLinkedRoleRequest): CreateServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceLinkedRoleWithOptions(request, runtime);
}

model ResizeDbfsRequest {
  regionId?: string(name='RegionId'),
  fsId?: string(name='FsId'),
  newSizeG?: int32(name='NewSizeG'),
}

model ResizeDbfsResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResizeDbfsResponse = {
  headers: map[string]string(name='headers'),
  body: ResizeDbfsResponseBody(name='body'),
}

async function resizeDbfsWithOptions(request: ResizeDbfsRequest, runtime: Util.RuntimeOptions): ResizeDbfsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ResizeDbfs', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function resizeDbfs(request: ResizeDbfsRequest): ResizeDbfsResponse {
  var runtime = new Util.RuntimeOptions{};
  return resizeDbfsWithOptions(request, runtime);
}

model PublishUpgradeTaskRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  batchStrategyList?: string(name='BatchStrategyList'),
}

model PublishUpgradeTaskResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model PublishUpgradeTaskResponse = {
  headers: map[string]string(name='headers'),
  body: PublishUpgradeTaskResponseBody(name='body'),
}

async function publishUpgradeTaskWithOptions(request: PublishUpgradeTaskRequest, runtime: Util.RuntimeOptions): PublishUpgradeTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PublishUpgradeTask', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function publishUpgradeTask(request: PublishUpgradeTaskRequest): PublishUpgradeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishUpgradeTaskWithOptions(request, runtime);
}

model ListTagValuesRequest {
  regionId?: string(name='RegionId'),
  tagKey?: string(name='TagKey'),
}

model ListTagValuesResponseBody = {
  requestId?: string(name='RequestId'),
  tagValues?: [ string ](name='TagValues'),
}

model ListTagValuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagValuesResponseBody(name='body'),
}

async function listTagValuesWithOptions(request: ListTagValuesRequest, runtime: Util.RuntimeOptions): ListTagValuesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTagValues', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTagValues(request: ListTagValuesRequest): ListTagValuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagValuesWithOptions(request, runtime);
}

model DeleteSnapshotRequest {
  regionId?: string(name='RegionId'),
  snapshotId?: string(name='SnapshotId'),
  force?: boolean(name='Force'),
}

model DeleteSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnapshotResponseBody(name='body'),
}

async function deleteSnapshotWithOptions(request: DeleteSnapshotRequest, runtime: Util.RuntimeOptions): DeleteSnapshotResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSnapshot', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSnapshot(request: DeleteSnapshotRequest): DeleteSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSnapshotWithOptions(request, runtime);
}

model DetachDbfsRequest {
  fsId?: string(name='FsId'),
  ECSInstanceId?: string(name='ECSInstanceId'),
  regionId?: string(name='RegionId'),
}

model DetachDbfsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachDbfsResponse = {
  headers: map[string]string(name='headers'),
  body: DetachDbfsResponseBody(name='body'),
}

async function detachDbfsWithOptions(request: DetachDbfsRequest, runtime: Util.RuntimeOptions): DetachDbfsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetachDbfs', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detachDbfs(request: DetachDbfsRequest): DetachDbfsResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachDbfsWithOptions(request, runtime);
}

model GenerateUpgradeRecordRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  batchStrategyList?: string(name='BatchStrategyList'),
}

model GenerateUpgradeRecordResponseBody = {
  requestId?: string(name='RequestId'),
  records?: [ 
    {
      id?: long(name='Id'),
      batchStrategyNo?: string(name='BatchStrategyNo'),
      accountId?: string(name='AccountId'),
      dbfsId?: string(name='DbfsId'),
      ecsId?: string(name='EcsId'),
      taskId?: string(name='TaskId'),
      regionId?: string(name='RegionId'),
      zoneId?: string(name='ZoneId'),
      state?: string(name='State'),
      currentVersion?: string(name='CurrentVersion'),
      targetVersion?: string(name='TargetVersion'),
      upgradeStartTime?: long(name='UpgradeStartTime'),
      upgradeEndTime?: long(name='UpgradeEndTime'),
      taskExecutionCounts?: int32(name='TaskExecutionCounts'),
      taskErrorReason?: string(name='TaskErrorReason'),
      createTime?: long(name='CreateTime'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='Records'),
}

model GenerateUpgradeRecordResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateUpgradeRecordResponseBody(name='body'),
}

async function generateUpgradeRecordWithOptions(request: GenerateUpgradeRecordRequest, runtime: Util.RuntimeOptions): GenerateUpgradeRecordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GenerateUpgradeRecord', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function generateUpgradeRecord(request: GenerateUpgradeRecordRequest): GenerateUpgradeRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateUpgradeRecordWithOptions(request, runtime);
}

model ResetDbfsRequest {
  regionId?: string(name='RegionId'),
  fsId?: string(name='FsId'),
  snapshotId?: string(name='SnapshotId'),
}

model ResetDbfsResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetDbfsResponse = {
  headers: map[string]string(name='headers'),
  body: ResetDbfsResponseBody(name='body'),
}

async function resetDbfsWithOptions(request: ResetDbfsRequest, runtime: Util.RuntimeOptions): ResetDbfsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ResetDbfs', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function resetDbfs(request: ResetDbfsRequest): ResetDbfsResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetDbfsWithOptions(request, runtime);
}

model GetDbfsRequest {
  regionId?: string(name='RegionId'),
  fsId?: string(name='FsId'),
}

model GetDbfsResponseBody = {
  requestId?: string(name='RequestId'),
  DBFSInfo?: {
    status?: string(name='Status'),
    payType?: string(name='PayType'),
    fsId?: string(name='FsId'),
    tags?: [ 
      {
        tagValue?: string(name='TagValue'),
        id?: int32(name='Id'),
        tagKey?: string(name='TagKey'),
      }
    ](name='Tags'),
    sizeG?: int32(name='SizeG'),
    ecsList?: [ 
      {
        ecsId?: string(name='EcsId'),
      }
    ](name='EcsList'),
    regionId?: string(name='RegionId'),
    DBFSClusterId?: string(name='DBFSClusterId'),
    description?: string(name='Description'),
    zoneId?: string(name='ZoneId'),
    fsName?: string(name='FsName'),
    category?: string(name='Category'),
    createdTime?: string(name='CreatedTime'),
    attachNodeNumber?: int32(name='AttachNodeNumber'),
    KMSKeyId?: string(name='KMSKeyId'),
    encryption?: boolean(name='Encryption'),
    performanceLevel?: string(name='PerformanceLevel'),
    usedScene?: string(name='UsedScene'),
    lastMountTime?: string(name='LastMountTime'),
    lastUmountTime?: string(name='LastUmountTime'),
    enableRaid?: boolean(name='EnableRaid'),
    raidStrip?: int32(name='RaidStrip'),
    ebsList?: [ 
      {
        ebsId?: string(name='EbsId'),
        sizeG?: int32(name='SizeG'),
      }
    ](name='EbsList'),
  }(name='DBFSInfo'),
}

model GetDbfsResponse = {
  headers: map[string]string(name='headers'),
  body: GetDbfsResponseBody(name='body'),
}

async function getDbfsWithOptions(request: GetDbfsRequest, runtime: Util.RuntimeOptions): GetDbfsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetDbfs', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getDbfs(request: GetDbfsRequest): GetDbfsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDbfsWithOptions(request, runtime);
}

model DbfsRecordRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  data?: string(name='Data'),
}

model DbfsRecordResponseBody = {
  requestId?: string(name='RequestId'),
  records?: [ 
    {
      id?: long(name='Id'),
      batchStrategyNo?: string(name='BatchStrategyNo'),
      accountId?: string(name='AccountId'),
      dbfsId?: string(name='DbfsId'),
      ecsId?: string(name='EcsId'),
      taskId?: string(name='TaskId'),
      regionId?: string(name='RegionId'),
      zoneId?: string(name='ZoneId'),
      state?: string(name='State'),
      currentVersion?: string(name='CurrentVersion'),
      targetVersion?: string(name='TargetVersion'),
      upgradeStartTime?: long(name='UpgradeStartTime'),
      upgradeEndTime?: long(name='UpgradeEndTime'),
      taskExecutionCounts?: int32(name='TaskExecutionCounts'),
      taskErrorReason?: string(name='TaskErrorReason'),
      createTime?: long(name='CreateTime'),
      updateTime?: long(name='UpdateTime'),
      isDel?: string(name='IsDel'),
    }
  ](name='Records'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  total?: long(name='Total'),
}

model DbfsRecordResponse = {
  headers: map[string]string(name='headers'),
  body: DbfsRecordResponseBody(name='body'),
}

async function dbfsRecordWithOptions(request: DbfsRecordRequest, runtime: Util.RuntimeOptions): DbfsRecordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DbfsRecord', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function dbfsRecord(request: DbfsRecordRequest): DbfsRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return dbfsRecordWithOptions(request, runtime);
}

model StopUpgradeTaskRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  batchStrategyList?: string(name='BatchStrategyList'),
}

model StopUpgradeTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopUpgradeTaskResponse = {
  headers: map[string]string(name='headers'),
  body: StopUpgradeTaskResponseBody(name='body'),
}

async function stopUpgradeTaskWithOptions(request: StopUpgradeTaskRequest, runtime: Util.RuntimeOptions): StopUpgradeTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StopUpgradeTask', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function stopUpgradeTask(request: StopUpgradeTaskRequest): StopUpgradeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopUpgradeTaskWithOptions(request, runtime);
}

model CreateDbfsRequest {
  regionId?: string(name='RegionId'),
  fsName?: string(name='FsName'),
  category?: string(name='Category'),
  sizeG?: int32(name='SizeG'),
  zoneId?: string(name='ZoneId'),
  clientToken?: string(name='ClientToken'),
  snapshotId?: string(name='SnapshotId'),
  deleteSnapshot?: boolean(name='DeleteSnapshot'),
  performanceLevel?: string(name='PerformanceLevel'),
  enableRaid?: boolean(name='EnableRaid'),
  raidStripeUnitNumber?: int32(name='RaidStripeUnitNumber'),
  KMSKeyId?: string(name='KMSKeyId'),
  encryption?: boolean(name='Encryption'),
  usedScene?: string(name='UsedScene'),
}

model CreateDbfsResponseBody = {
  requestId?: string(name='RequestId'),
  fsId?: string(name='FsId'),
}

model CreateDbfsResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDbfsResponseBody(name='body'),
}

async function createDbfsWithOptions(request: CreateDbfsRequest, runtime: Util.RuntimeOptions): CreateDbfsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateDbfs', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createDbfs(request: CreateDbfsRequest): CreateDbfsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDbfsWithOptions(request, runtime);
}

model UpdateTaskRequest {
  regionId?: string(name='RegionId'),
  taskIds?: string(name='TaskIds'),
  taskProgress?: int32(name='TaskProgress'),
}

model UpdateTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTaskResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTaskResponseBody(name='body'),
}

async function updateTaskWithOptions(request: UpdateTaskRequest, runtime: Util.RuntimeOptions): UpdateTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateTask', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateTask(request: UpdateTaskRequest): UpdateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTaskWithOptions(request, runtime);
}

model DeleteTagsBatchRequest {
  regionId?: string(name='RegionId'),
  dbfsList?: string(name='DbfsList'),
  tags?: string(name='Tags'),
}

model DeleteTagsBatchResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTagsBatchResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTagsBatchResponseBody(name='body'),
}

async function deleteTagsBatchWithOptions(request: DeleteTagsBatchRequest, runtime: Util.RuntimeOptions): DeleteTagsBatchResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteTagsBatch', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteTagsBatch(request: DeleteTagsBatchRequest): DeleteTagsBatchResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTagsBatchWithOptions(request, runtime);
}

model GetServiceLinkedRoleRequest {
  regionId?: string(name='RegionId'),
}

model GetServiceLinkedRoleResponseBody = {
  accountId?: string(name='AccountId'),
  requestId?: string(name='RequestId'),
  dbfsLinkedRole?: boolean(name='DbfsLinkedRole'),
  regionId?: string(name='RegionId'),
}

model GetServiceLinkedRoleResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceLinkedRoleResponseBody(name='body'),
}

async function getServiceLinkedRoleWithOptions(request: GetServiceLinkedRoleRequest, runtime: Util.RuntimeOptions): GetServiceLinkedRoleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetServiceLinkedRole', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getServiceLinkedRole(request: GetServiceLinkedRoleRequest): GetServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceLinkedRoleWithOptions(request, runtime);
}

model UpdateConstantsRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  constantsData?: string(name='ConstantsData'),
}

model UpdateConstantsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: string(name='Data'),
  pageSize?: long(name='PageSize'),
  totalCount?: long(name='TotalCount'),
  pageNumber?: long(name='PageNumber'),
}

model UpdateConstantsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateConstantsResponseBody(name='body'),
}

async function updateConstantsWithOptions(request: UpdateConstantsRequest, runtime: Util.RuntimeOptions): UpdateConstantsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateConstants', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateConstants(request: UpdateConstantsRequest): UpdateConstantsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConstantsWithOptions(request, runtime);
}

model InsertSynchronizConstantsRequest {
  regionId?: string(name='RegionId'),
  accessData?: string(name='AccessData'),
  endpointData?: string(name='EndpointData'),
  masterData?: string(name='MasterData'),
  productCodeData?: string(name='ProductCodeData'),
  osversionData?: string(name='OsversionData'),
  zoneData?: string(name='ZoneData'),
  regionData?: string(name='RegionData'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model InsertSynchronizConstantsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: string(name='Data'),
  pageSize?: long(name='PageSize'),
  totalCount?: long(name='TotalCount'),
  pageNumber?: long(name='PageNumber'),
}

model InsertSynchronizConstantsResponse = {
  headers: map[string]string(name='headers'),
  body: InsertSynchronizConstantsResponseBody(name='body'),
}

async function insertSynchronizConstantsWithOptions(request: InsertSynchronizConstantsRequest, runtime: Util.RuntimeOptions): InsertSynchronizConstantsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('InsertSynchronizConstants', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function insertSynchronizConstants(request: InsertSynchronizConstantsRequest): InsertSynchronizConstantsResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertSynchronizConstantsWithOptions(request, runtime);
}

model AttachDbfsRequest {
  ECSInstanceId?: string(name='ECSInstanceId'),
  serverUrl?: string(name='ServerUrl'),
  fsId?: string(name='FsId'),
  regionId?: string(name='RegionId'),
  attachMode?: string(name='AttachMode'),
  attachPoint?: string(name='AttachPoint'),
}

model AttachDbfsResponseBody = {
  requestId?: string(name='RequestId'),
}

model AttachDbfsResponse = {
  headers: map[string]string(name='headers'),
  body: AttachDbfsResponseBody(name='body'),
}

async function attachDbfsWithOptions(request: AttachDbfsRequest, runtime: Util.RuntimeOptions): AttachDbfsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AttachDbfs', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function attachDbfs(request: AttachDbfsRequest): AttachDbfsResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachDbfsWithOptions(request, runtime);
}

model ListTaskRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sortKey?: string(name='SortKey'),
  sortType?: string(name='SortType'),
  filterKey?: string(name='FilterKey'),
  filterValue?: string(name='FilterValue'),
}

model ListTaskResponseBody = {
  totalCount?: int32(name='TotalCount'),
  tasks?: [ 
    {
      taskErrorReason?: string(name='TaskErrorReason'),
      taskName?: string(name='TaskName'),
      priority?: string(name='Priority'),
      nextExecutionTime?: string(name='NextExecutionTime'),
      completionTime?: string(name='CompletionTime'),
      taskType?: string(name='TaskType'),
      taskStatus?: string(name='TaskStatus'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskExecutionCounts?: int32(name='TaskExecutionCounts'),
      clientToken?: string(name='ClientToken'),
      taskAdder?: string(name='TaskAdder'),
      taskProgressDescription?: string(name='TaskProgressDescription'),
      createdTime?: string(name='CreatedTime'),
      taskRunner?: string(name='TaskRunner'),
      taskProgress?: int32(name='TaskProgress'),
      taskOwner?: string(name='TaskOwner'),
      id?: int32(name='Id'),
      maxRetry?: int32(name='MaxRetry'),
    }
  ](name='Tasks'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
}

model ListTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListTaskResponseBody(name='body'),
}

async function listTaskWithOptions(request: ListTaskRequest, runtime: Util.RuntimeOptions): ListTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTask', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTask(request: ListTaskRequest): ListTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTaskWithOptions(request, runtime);
}

model ListDbfsRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sortKey?: string(name='SortKey'),
  sortType?: string(name='SortType'),
  filterKey?: string(name='FilterKey'),
  filterValue?: string(name='FilterValue'),
  tags?: string(name='Tags'),
}

model ListDbfsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  DBFSInfo?: [ 
    {
      status?: string(name='Status'),
      encryption?: boolean(name='Encryption'),
      payType?: string(name='PayType'),
      fsId?: string(name='FsId'),
      tags?: [ 
        {
          tagValue?: string(name='TagValue'),
          id?: long(name='Id'),
          tagKey?: string(name='TagKey'),
        }
      ](name='Tags'),
      sizeG?: int32(name='SizeG'),
      ecsList?: [ 
        {
          ecsId?: string(name='EcsId'),
        }
      ](name='EcsList'),
      ebsList?: [ 
        {
          ebsId?: string(name='EbsId'),
          sizeG?: int32(name='SizeG'),
        }
      ](name='EbsList'),
      regionId?: string(name='RegionId'),
      DBFSClusterId?: string(name='DBFSClusterId'),
      zoneId?: string(name='ZoneId'),
      fsName?: string(name='FsName'),
      category?: string(name='Category'),
      createdTime?: string(name='CreatedTime'),
      attachNodeNumber?: int32(name='AttachNodeNumber'),
      KMSKeyId?: string(name='KMSKeyId'),
      performanceLevel?: string(name='PerformanceLevel'),
      usedScene?: string(name='UsedScene'),
      lastMountTime?: string(name='LastMountTime'),
      lastUmountTime?: string(name='LastUmountTime'),
      enableRaid?: boolean(name='EnableRaid'),
      raidStrip?: int32(name='RaidStrip'),
    }
  ](name='DBFSInfo'),
}

model ListDbfsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDbfsResponseBody(name='body'),
}

async function listDbfsWithOptions(request: ListDbfsRequest, runtime: Util.RuntimeOptions): ListDbfsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListDbfs', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listDbfs(request: ListDbfsRequest): ListDbfsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDbfsWithOptions(request, runtime);
}

model AddTagsBatchRequest {
  regionId?: string(name='RegionId'),
  dbfsList?: string(name='DbfsList'),
  tags?: string(name='Tags'),
  clientToken?: string(name='ClientToken'),
}

model AddTagsBatchResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddTagsBatchResponse = {
  headers: map[string]string(name='headers'),
  body: AddTagsBatchResponseBody(name='body'),
}

async function addTagsBatchWithOptions(request: AddTagsBatchRequest, runtime: Util.RuntimeOptions): AddTagsBatchResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddTagsBatch', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addTagsBatch(request: AddTagsBatchRequest): AddTagsBatchResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTagsBatchWithOptions(request, runtime);
}

model TagDbfsRequest {
  regionId?: string(name='RegionId'),
  dbfsId?: string(name='DbfsId'),
  tags?: string(name='Tags'),
}

model TagDbfsResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagDbfsResponse = {
  headers: map[string]string(name='headers'),
  body: TagDbfsResponseBody(name='body'),
}

async function tagDbfsWithOptions(request: TagDbfsRequest, runtime: Util.RuntimeOptions): TagDbfsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TagDbfs', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function tagDbfs(request: TagDbfsRequest): TagDbfsResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagDbfsWithOptions(request, runtime);
}

model GetSynchronizConstantsRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model GetSynchronizConstantsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: string(name='Data'),
  pageSize?: long(name='PageSize'),
  totalCount?: long(name='TotalCount'),
  pageNumber?: long(name='PageNumber'),
  regionData?: string(name='RegionData'),
  zoneData?: string(name='ZoneData'),
  osversionData?: string(name='OsversionData'),
  productCodeData?: string(name='ProductCodeData'),
  masterData?: string(name='MasterData'),
  endpointData?: string(name='EndpointData'),
  accessData?: string(name='AccessData'),
}

model GetSynchronizConstantsResponse = {
  headers: map[string]string(name='headers'),
  body: GetSynchronizConstantsResponseBody(name='body'),
}

async function getSynchronizConstantsWithOptions(request: GetSynchronizConstantsRequest, runtime: Util.RuntimeOptions): GetSynchronizConstantsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSynchronizConstants', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSynchronizConstants(request: GetSynchronizConstantsRequest): GetSynchronizConstantsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSynchronizConstantsWithOptions(request, runtime);
}

model OpreateConstantsRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  constantsData?: string(name='ConstantsData'),
}

model OpreateConstantsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: string(name='Data'),
  regionData?: string(name='RegionData'),
  zoneData?: string(name='ZoneData'),
  osversionData?: string(name='OsversionData'),
  pageSize?: long(name='PageSize'),
  totalCount?: long(name='TotalCount'),
  pageNumber?: long(name='PageNumber'),
  productCodeData?: string(name='ProductCodeData'),
  masterData?: string(name='MasterData'),
  endpointData?: string(name='EndpointData'),
  accessData?: string(name='AccessData'),
}

model OpreateConstantsResponse = {
  headers: map[string]string(name='headers'),
  body: OpreateConstantsResponseBody(name='body'),
}

async function opreateConstantsWithOptions(request: OpreateConstantsRequest, runtime: Util.RuntimeOptions): OpreateConstantsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('OpreateConstants', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function opreateConstants(request: OpreateConstantsRequest): OpreateConstantsResponse {
  var runtime = new Util.RuntimeOptions{};
  return opreateConstantsWithOptions(request, runtime);
}

model RenameDbfsRequest {
  fsName?: string(name='FsName'),
  fsId?: string(name='FsId'),
  regionId?: string(name='RegionId'),
}

model RenameDbfsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RenameDbfsResponse = {
  headers: map[string]string(name='headers'),
  body: RenameDbfsResponseBody(name='body'),
}

async function renameDbfsWithOptions(request: RenameDbfsRequest, runtime: Util.RuntimeOptions): RenameDbfsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RenameDbfs', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function renameDbfs(request: RenameDbfsRequest): RenameDbfsResponse {
  var runtime = new Util.RuntimeOptions{};
  return renameDbfsWithOptions(request, runtime);
}

model ListTagKeysRequest {
  regionId?: string(name='RegionId'),
}

model ListTagKeysResponseBody = {
  requestId?: string(name='RequestId'),
  tagKeys?: [ string ](name='TagKeys'),
}

model ListTagKeysResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagKeysResponseBody(name='body'),
}

async function listTagKeysWithOptions(request: ListTagKeysRequest, runtime: Util.RuntimeOptions): ListTagKeysResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTagKeys', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTagKeys(request: ListTagKeysRequest): ListTagKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagKeysWithOptions(request, runtime);
}

model ListConstantsRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  constantsData?: string(name='ConstantsData'),
}

model ListConstantsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  data?: string(name='Data'),
  pageSize?: long(name='PageSize'),
  totalCount?: long(name='TotalCount'),
  pageNumber?: long(name='PageNumber'),
}

model ListConstantsResponse = {
  headers: map[string]string(name='headers'),
  body: ListConstantsResponseBody(name='body'),
}

async function listConstantsWithOptions(request: ListConstantsRequest, runtime: Util.RuntimeOptions): ListConstantsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListConstants', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listConstants(request: ListConstantsRequest): ListConstantsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConstantsWithOptions(request, runtime);
}

model ListSnapshotRequest {
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sortKey?: string(name='SortKey'),
  sortType?: string(name='SortType'),
  filterKey?: string(name='FilterKey'),
  filterValue?: string(name='FilterValue'),
  fsId?: string(name='FsId'),
  status?: string(name='Status'),
  snapshotName?: string(name='SnapshotName'),
  snapshotType?: string(name='SnapshotType'),
  snapshotIds?: string(name='SnapshotIds'),
}

model ListSnapshotResponseBody = {
  totalCount?: int32(name='TotalCount'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  snapshots?: [ 
    {
      status?: string(name='Status'),
      creationTime?: string(name='CreationTime'),
      progress?: string(name='Progress'),
      sourceFsSize?: int32(name='SourceFsSize'),
      retentionDays?: int32(name='RetentionDays'),
      remainTime?: int32(name='RemainTime'),
      lastModifiedTime?: string(name='LastModifiedTime'),
      snapshotType?: string(name='SnapshotType'),
      snapshotName?: string(name='SnapshotName'),
      description?: string(name='Description'),
      sourceFsId?: string(name='SourceFsId'),
      snapshotId?: string(name='SnapshotId'),
      category?: string(name='Category'),
    }
  ](name='Snapshots'),
}

model ListSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: ListSnapshotResponseBody(name='body'),
}

async function listSnapshotWithOptions(request: ListSnapshotRequest, runtime: Util.RuntimeOptions): ListSnapshotResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListSnapshot', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listSnapshot(request: ListSnapshotRequest): ListSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSnapshotWithOptions(request, runtime);
}

model DescribeDbfsSpecificationsRequest {
  regionId?: string(name='RegionId'),
  ecsInstanceType?: string(name='EcsInstanceType'),
  category?: string(name='Category'),
}

model DescribeDbfsSpecificationsResponseBody = {
  requestId?: string(name='RequestId'),
  supportedEcsInstanceTypeFamily?: [ string ](name='SupportedEcsInstanceTypeFamily'),
  maxDbfsNumberPerEcs?: map[string]any(name='MaxDbfsNumberPerEcs'),
}

model DescribeDbfsSpecificationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDbfsSpecificationsResponseBody(name='body'),
}

async function describeDbfsSpecificationsWithOptions(request: DescribeDbfsSpecificationsRequest, runtime: Util.RuntimeOptions): DescribeDbfsSpecificationsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeDbfsSpecifications', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeDbfsSpecifications(request: DescribeDbfsSpecificationsRequest): DescribeDbfsSpecificationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDbfsSpecificationsWithOptions(request, runtime);
}

model CreateSnapshotRequest {
  regionId?: string(name='RegionId'),
  fsId?: string(name='FsId'),
  snapshotName?: string(name='SnapshotName'),
  description?: string(name='Description'),
  retentionDays?: int32(name='RetentionDays'),
  clientToken?: string(name='ClientToken'),
}

model CreateSnapshotResponseBody = {
  snapshotId?: string(name='SnapshotId'),
  requestId?: string(name='RequestId'),
}

model CreateSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSnapshotResponseBody(name='body'),
}

async function createSnapshotWithOptions(request: CreateSnapshotRequest, runtime: Util.RuntimeOptions): CreateSnapshotResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSnapshot', '2020-04-18', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSnapshot(request: CreateSnapshotRequest): CreateSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSnapshotWithOptions(request, runtime);
}

