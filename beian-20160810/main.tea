/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('beian', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model DeleteUnbeianIpCheckTypeRequest {
  caller?: string(name='Caller', description='This parameter is required.'),
  checkType?: int32(name='CheckType', description='This parameter is required.'),
  ip?: string(name='Ip', description='This parameter is required.'),
  remark?: string(name='Remark'),
}

model DeleteUnbeianIpCheckTypeResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  huntressIpCheckTypeResultDO?: {
    msg?: string(name='Msg'),
    success?: boolean(name='Success'),
  }(name='HuntressIpCheckTypeResultDO'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteUnbeianIpCheckTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteUnbeianIpCheckTypeResponseBody(name='body'),
}

/**
 * @param request DeleteUnbeianIpCheckTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteUnbeianIpCheckTypeResponse
 */
async function deleteUnbeianIpCheckTypeWithOptions(request: DeleteUnbeianIpCheckTypeRequest, runtime: Util.RuntimeOptions): DeleteUnbeianIpCheckTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caller)) {
    query['Caller'] = request.caller;
  }
  if (!Util.isUnset(request.checkType)) {
    query['CheckType'] = request.checkType;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUnbeianIpCheckType',
    version = '2016-08-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteUnbeianIpCheckTypeRequest
 * @return DeleteUnbeianIpCheckTypeResponse
 */
async function deleteUnbeianIpCheckType(request: DeleteUnbeianIpCheckTypeRequest): DeleteUnbeianIpCheckTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUnbeianIpCheckTypeWithOptions(request, runtime);
}

model GetMainDomainRequest {
  domain?: string(name='Domain'),
}

model GetMainDomainResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetMainDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMainDomainResponseBody(name='body'),
}

/**
 * @summary 获取主域名接口
 *
 * @param request GetMainDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMainDomainResponse
 */
async function getMainDomainWithOptions(request: GetMainDomainRequest, runtime: Util.RuntimeOptions): GetMainDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMainDomain',
    version = '2016-08-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取主域名接口
 *
 * @param request GetMainDomainRequest
 * @return GetMainDomainResponse
 */
async function getMainDomain(request: GetMainDomainRequest): GetMainDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMainDomainWithOptions(request, runtime);
}

model InsertUnbeianIpCheckTypeRequest {
  caller?: string(name='Caller', description='This parameter is required.'),
  checkType?: int32(name='CheckType', description='This parameter is required.'),
  ip?: string(name='Ip', description='This parameter is required.'),
  remark?: string(name='Remark'),
}

model InsertUnbeianIpCheckTypeResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  huntressIpCheckTypeResultDO?: {
    msg?: string(name='Msg'),
    success?: boolean(name='Success'),
  }(name='HuntressIpCheckTypeResultDO'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InsertUnbeianIpCheckTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InsertUnbeianIpCheckTypeResponseBody(name='body'),
}

/**
 * @param request InsertUnbeianIpCheckTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InsertUnbeianIpCheckTypeResponse
 */
async function insertUnbeianIpCheckTypeWithOptions(request: InsertUnbeianIpCheckTypeRequest, runtime: Util.RuntimeOptions): InsertUnbeianIpCheckTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caller)) {
    query['Caller'] = request.caller;
  }
  if (!Util.isUnset(request.checkType)) {
    query['CheckType'] = request.checkType;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InsertUnbeianIpCheckType',
    version = '2016-08-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request InsertUnbeianIpCheckTypeRequest
 * @return InsertUnbeianIpCheckTypeResponse
 */
async function insertUnbeianIpCheckType(request: InsertUnbeianIpCheckTypeRequest): InsertUnbeianIpCheckTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertUnbeianIpCheckTypeWithOptions(request, runtime);
}

model ListUnbeianIpCheckTypeRequest {
  caller?: string(name='Caller', description='This parameter is required.'),
  checkType?: int32(name='CheckType'),
  ip?: string(name='Ip'),
  limit?: int32(name='Limit'),
  page?: int32(name='Page'),
  remark?: string(name='Remark'),
}

model ListUnbeianIpCheckTypeResponseBody = {
  errorCode?: int32(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  huntressIpCheckTypeResultDO?: {
    list?: [ 
      {
        aliuid?: long(name='Aliuid'),
        caller?: string(name='Caller'),
        checkType?: int32(name='CheckType'),
        ip?: string(name='Ip'),
        remark?: string(name='Remark'),
      }
    ](name='List'),
    msg?: string(name='Msg'),
    success?: boolean(name='Success'),
  }(name='HuntressIpCheckTypeResultDO'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListUnbeianIpCheckTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUnbeianIpCheckTypeResponseBody(name='body'),
}

/**
 * @param request ListUnbeianIpCheckTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUnbeianIpCheckTypeResponse
 */
async function listUnbeianIpCheckTypeWithOptions(request: ListUnbeianIpCheckTypeRequest, runtime: Util.RuntimeOptions): ListUnbeianIpCheckTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caller)) {
    query['Caller'] = request.caller;
  }
  if (!Util.isUnset(request.checkType)) {
    query['CheckType'] = request.checkType;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUnbeianIpCheckType',
    version = '2016-08-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListUnbeianIpCheckTypeRequest
 * @return ListUnbeianIpCheckTypeResponse
 */
async function listUnbeianIpCheckType(request: ListUnbeianIpCheckTypeRequest): ListUnbeianIpCheckTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUnbeianIpCheckTypeWithOptions(request, runtime);
}

model ManageAccessorDomainRequest {
  caller?: string(name='Caller', description='This parameter is required.'),
  domain?: string(name='Domain', description='This parameter is required.'),
  operation?: string(name='Operation', description='This parameter is required.'),
}

model ManageAccessorDomainResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ManageAccessorDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ManageAccessorDomainResponseBody(name='body'),
}

/**
 * @summary 接入方服务域名上报接口
 *
 * @param request ManageAccessorDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ManageAccessorDomainResponse
 */
async function manageAccessorDomainWithOptions(request: ManageAccessorDomainRequest, runtime: Util.RuntimeOptions): ManageAccessorDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caller)) {
    query['Caller'] = request.caller;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ManageAccessorDomain',
    version = '2016-08-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 接入方服务域名上报接口
 *
 * @param request ManageAccessorDomainRequest
 * @return ManageAccessorDomainResponse
 */
async function manageAccessorDomain(request: ManageAccessorDomainRequest): ManageAccessorDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return manageAccessorDomainWithOptions(request, runtime);
}

model ManageAccessorDomainWhiteListRequest {
  caller?: string(name='Caller', description='This parameter is required.'),
  domains?: [ string ](name='Domains', description='This parameter is required.'),
  endTime?: string(name='EndTime'),
  operation?: string(name='Operation', description='This parameter is required.'),
  remark?: string(name='Remark'),
  startTime?: string(name='StartTime'),
}

model ManageAccessorDomainWhiteListResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ManageAccessorDomainWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ManageAccessorDomainWhiteListResponseBody(name='body'),
}

/**
 * @summary 接入方域名白名单上报接口
 *
 * @param request ManageAccessorDomainWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ManageAccessorDomainWhiteListResponse
 */
async function manageAccessorDomainWhiteListWithOptions(request: ManageAccessorDomainWhiteListRequest, runtime: Util.RuntimeOptions): ManageAccessorDomainWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caller)) {
    query['Caller'] = request.caller;
  }
  if (!Util.isUnset(request.domains)) {
    query['Domains'] = request.domains;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ManageAccessorDomainWhiteList',
    version = '2016-08-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 接入方域名白名单上报接口
 *
 * @param request ManageAccessorDomainWhiteListRequest
 * @return ManageAccessorDomainWhiteListResponse
 */
async function manageAccessorDomainWhiteList(request: ManageAccessorDomainWhiteListRequest): ManageAccessorDomainWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return manageAccessorDomainWhiteListWithOptions(request, runtime);
}

model ManageAccessorIpRequest {
  caller?: string(name='Caller', description='This parameter is required.'),
  ip?: string(name='Ip', description='This parameter is required.'),
  ipVersion?: int32(name='IpVersion', description='This parameter is required.'),
  operation?: string(name='Operation', description='This parameter is required.'),
  remark?: string(name='Remark'),
}

model ManageAccessorIpResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ManageAccessorIpResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ManageAccessorIpResponseBody(name='body'),
}

/**
 * @summary 接入方管控IP上报接口
 *
 * @param request ManageAccessorIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ManageAccessorIpResponse
 */
async function manageAccessorIpWithOptions(request: ManageAccessorIpRequest, runtime: Util.RuntimeOptions): ManageAccessorIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caller)) {
    query['Caller'] = request.caller;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.ipVersion)) {
    query['IpVersion'] = request.ipVersion;
  }
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ManageAccessorIp',
    version = '2016-08-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 接入方管控IP上报接口
 *
 * @param request ManageAccessorIpRequest
 * @return ManageAccessorIpResponse
 */
async function manageAccessorIp(request: ManageAccessorIpRequest): ManageAccessorIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return manageAccessorIpWithOptions(request, runtime);
}

model QueryAccessorDomainRequest {
  caller?: string(name='Caller', description='This parameter is required.'),
  domain?: string(name='Domain', description='This parameter is required.'),
}

model QueryAccessorDomainResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryAccessorDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryAccessorDomainResponseBody(name='body'),
}

/**
 * @summary 接入方服务域名是否上报查询接口
 *
 * @param request QueryAccessorDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryAccessorDomainResponse
 */
async function queryAccessorDomainWithOptions(request: QueryAccessorDomainRequest, runtime: Util.RuntimeOptions): QueryAccessorDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caller)) {
    query['Caller'] = request.caller;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryAccessorDomain',
    version = '2016-08-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 接入方服务域名是否上报查询接口
 *
 * @param request QueryAccessorDomainRequest
 * @return QueryAccessorDomainResponse
 */
async function queryAccessorDomain(request: QueryAccessorDomainRequest): QueryAccessorDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAccessorDomainWithOptions(request, runtime);
}

model QueryAccessorDomainListRequest {
  caller?: string(name='Caller', description='This parameter is required.'),
  domain?: string(name='Domain', description='This parameter is required.'),
  pageNo?: int32(name='PageNo', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model QueryAccessorDomainListResponseBody = {
  code?: int32(name='Code'),
  data?: {
    domains?: [ string ](name='Domains'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryAccessorDomainListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryAccessorDomainListResponseBody(name='body'),
}

/**
 * @summary 接入方查询服务域名列表接口
 *
 * @param request QueryAccessorDomainListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryAccessorDomainListResponse
 */
async function queryAccessorDomainListWithOptions(request: QueryAccessorDomainListRequest, runtime: Util.RuntimeOptions): QueryAccessorDomainListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caller)) {
    query['Caller'] = request.caller;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryAccessorDomainList',
    version = '2016-08-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 接入方查询服务域名列表接口
 *
 * @param request QueryAccessorDomainListRequest
 * @return QueryAccessorDomainListResponse
 */
async function queryAccessorDomainList(request: QueryAccessorDomainListRequest): QueryAccessorDomainListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAccessorDomainListWithOptions(request, runtime);
}

model QueryAccessorDomainStatusRequest {
  caller?: string(name='Caller', description='This parameter is required.'),
  domain?: string(name='Domain', description='This parameter is required.'),
}

model QueryAccessorDomainStatusResponseBody = {
  code?: int32(name='Code'),
  data?: {
    domain?: string(name='Domain'),
    reason?: string(name='Reason'),
    reasonCode?: int32(name='ReasonCode'),
    status?: string(name='Status'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryAccessorDomainStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryAccessorDomainStatusResponseBody(name='body'),
}

/**
 * @summary 接入方域名状态查询接口
 *
 * @param request QueryAccessorDomainStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryAccessorDomainStatusResponse
 */
async function queryAccessorDomainStatusWithOptions(request: QueryAccessorDomainStatusRequest, runtime: Util.RuntimeOptions): QueryAccessorDomainStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caller)) {
    query['Caller'] = request.caller;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryAccessorDomainStatus',
    version = '2016-08-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 接入方域名状态查询接口
 *
 * @param request QueryAccessorDomainStatusRequest
 * @return QueryAccessorDomainStatusResponse
 */
async function queryAccessorDomainStatus(request: QueryAccessorDomainStatusRequest): QueryAccessorDomainStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAccessorDomainStatusWithOptions(request, runtime);
}

model QueryAccessorDomainWhiteListRequest {
  caller?: string(name='Caller', description='This parameter is required.'),
  domain?: string(name='Domain', description='This parameter is required.'),
}

model QueryAccessorDomainWhiteListResponseBody = {
  code?: int32(name='Code'),
  data?: {
    items?: [ 
      {
        createTime?: string(name='CreateTime'),
        endTime?: string(name='EndTime'),
        startTime?: string(name='StartTime'),
        type?: string(name='Type'),
        valid?: boolean(name='Valid'),
      }
    ](name='Items'),
    white?: boolean(name='White'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryAccessorDomainWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryAccessorDomainWhiteListResponseBody(name='body'),
}

/**
 * @summary 接入方域名白名单上报查询接口
 *
 * @param request QueryAccessorDomainWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryAccessorDomainWhiteListResponse
 */
async function queryAccessorDomainWhiteListWithOptions(request: QueryAccessorDomainWhiteListRequest, runtime: Util.RuntimeOptions): QueryAccessorDomainWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caller)) {
    query['Caller'] = request.caller;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryAccessorDomainWhiteList',
    version = '2016-08-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 接入方域名白名单上报查询接口
 *
 * @param request QueryAccessorDomainWhiteListRequest
 * @return QueryAccessorDomainWhiteListResponse
 */
async function queryAccessorDomainWhiteList(request: QueryAccessorDomainWhiteListRequest): QueryAccessorDomainWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAccessorDomainWhiteListWithOptions(request, runtime);
}

model QueryAccessorDomainsStatusRequest {
  caller?: string(name='Caller', description='This parameter is required.'),
  domains?: [ string ](name='Domains', description='This parameter is required.'),
}

model QueryAccessorDomainsStatusResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      domain?: string(name='Domain'),
      reason?: string(name='Reason'),
      reasonCode?: int32(name='ReasonCode'),
      status?: string(name='Status'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryAccessorDomainsStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryAccessorDomainsStatusResponseBody(name='body'),
}

/**
 * @summary 接入方域名状态批量查询接口
 *
 * @param request QueryAccessorDomainsStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryAccessorDomainsStatusResponse
 */
async function queryAccessorDomainsStatusWithOptions(request: QueryAccessorDomainsStatusRequest, runtime: Util.RuntimeOptions): QueryAccessorDomainsStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caller)) {
    query['Caller'] = request.caller;
  }
  if (!Util.isUnset(request.domains)) {
    query['Domains'] = request.domains;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryAccessorDomainsStatus',
    version = '2016-08-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 接入方域名状态批量查询接口
 *
 * @param request QueryAccessorDomainsStatusRequest
 * @return QueryAccessorDomainsStatusResponse
 */
async function queryAccessorDomainsStatus(request: QueryAccessorDomainsStatusRequest): QueryAccessorDomainsStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAccessorDomainsStatusWithOptions(request, runtime);
}

model QueryAccessorIpRequest {
  caller?: string(name='Caller', description='This parameter is required.'),
  ip?: string(name='Ip', description='This parameter is required.'),
}

model QueryAccessorIpResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryAccessorIpResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryAccessorIpResponseBody(name='body'),
}

/**
 * @summary 接入方服务域名上报接口
 *
 * @param request QueryAccessorIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryAccessorIpResponse
 */
async function queryAccessorIpWithOptions(request: QueryAccessorIpRequest, runtime: Util.RuntimeOptions): QueryAccessorIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caller)) {
    query['Caller'] = request.caller;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryAccessorIp',
    version = '2016-08-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 接入方服务域名上报接口
 *
 * @param request QueryAccessorIpRequest
 * @return QueryAccessorIpResponse
 */
async function queryAccessorIp(request: QueryAccessorIpRequest): QueryAccessorIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAccessorIpWithOptions(request, runtime);
}

model SubmitAccessorFullDomainsOssListRequest {
  caller?: string(name='Caller', description='This parameter is required.'),
  ossList?: [ string ](name='OssList', description='This parameter is required.'),
}

model SubmitAccessorFullDomainsOssListResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SubmitAccessorFullDomainsOssListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SubmitAccessorFullDomainsOssListResponseBody(name='body'),
}

/**
 * @summary 接入方服务域名全量上报接口
 *
 * @param request SubmitAccessorFullDomainsOssListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitAccessorFullDomainsOssListResponse
 */
async function submitAccessorFullDomainsOssListWithOptions(request: SubmitAccessorFullDomainsOssListRequest, runtime: Util.RuntimeOptions): SubmitAccessorFullDomainsOssListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.caller)) {
    query['Caller'] = request.caller;
  }
  if (!Util.isUnset(request.ossList)) {
    query['OssList'] = request.ossList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitAccessorFullDomainsOssList',
    version = '2016-08-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 接入方服务域名全量上报接口
 *
 * @param request SubmitAccessorFullDomainsOssListRequest
 * @return SubmitAccessorFullDomainsOssListResponse
 */
async function submitAccessorFullDomainsOssList(request: SubmitAccessorFullDomainsOssListRequest): SubmitAccessorFullDomainsOssListResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitAccessorFullDomainsOssListWithOptions(request, runtime);
}

