/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('serverless', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model Environment {
  creationTime?: string(name='creationTime', description='A time representing the server time when this object was created. Clients may not set this value. Populated by the system. Read-only.'),
  description?: string(name='description', description='Human-readable description of the resource'),
  generation?: int32(name='generation', description='A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.'),
  kind?: string(name='kind', description='The kind of the resource'),
  name?: string(name='name', description='Name must be unique within a namespace. Is required when creating resources. Cannot be updated.'),
  spec?: {
    region?: string(name='region', description='A region ID at Aliyun. For example, "cn-hangzhou"'),
    roleArn?: string(name='roleArn', description='The ARN (Aliyun Resource Name) of the role designated by a user to allow the system to manage his Aliyun resources. If null, use roleArn of role AliyunFCDefaultRole.'),
    template?: string(name='template', description='The name of the template for the Environment'),
    templateVariables?: map[string]any(name='templateVariables', description='Variables for specified template'),
  }(name='spec', description='Specification of the desired behavior of the Environment'),
  status?: {
    credentials?: StsCredentials(name='credentials', description='Credentials required for tasks'),
    message?: string(name='message', description='A human-readable message indicating details about why the Environment is in this condition'),
    observedGeneration?: int32(name='observedGeneration', description='The most recent generation observed'),
    observedTime?: string(name='observedTime', description='Time when the last update of the status is observed'),
    output?: map[string]any(name='output', description='Details of current state of the Environment'),
    phase?: string(name='phase', description='A simple, high-level summary of where the Environment is in its lifecycle'),
  }(name='status', description='Most recently observed status of the Environment. This data may not be up-to-date. Populated by the system. Read-only'),
  uid?: string(name='uid', description='Main user ID of an Aliyun account'),
}

model Service {
  creationTime?: string(name='creationTime', description='A time representing the server time when this object was created. Clients may not set this value. Populated by the system. Read-only.'),
  description?: string(name='description', description='Human-readable description of the resource'),
  generation?: int32(name='generation', description='A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.'),
  kind?: string(name='kind', description='The kind of the resource'),
  name?: string(name='name', description='Name must be unique within a namespace. Is required when creating resources. Cannot be updated.'),
  spec?: {
    environment?: string(name='environment', description='The name of the associated Environment for the Service'),
    roleArn?: string(name='roleArn', description='The ARN (Aliyun Resource Name) of the role designated by a user to allow the system to manage his Aliyun resources. If null, use roleArn of role AliyunFCDefaultRole.'),
    template?: string(name='template', description='The name of the template for the Service'),
    templateVariables?: map[string]any(name='templateVariables', description='Variables for specified template'),
  }(name='spec', description='Specification of the desired behavior of the Service'),
  status?: {
    credentials?: StsCredentials(name='credentials', description='Credentials required for tasks'),
    message?: string(name='message', description='A human-readable message indicating details about why the Service is in this condition'),
    observedGeneration?: int32(name='observedGeneration', description='The most recent generation observed'),
    observedTime?: string(name='observedTime', description='Time when the last update of the status is observed'),
    output?: map[string]any(name='output', description='Details of current state of the Service'),
    phase?: string(name='phase', description='A simple, high-level summary of where the Service is in its lifecycle'),
  }(name='status', description='Most recently observed status of the Service. This data may not be up-to-date. Populated by the system. Read-only'),
  uid?: string(name='uid', description='Main user ID of an Aliyun account'),
}

model StsCredentials {
  accessKeyId?: string(name='accessKeyId', description='Access key ID'),
  expirationTime?: string(name='expirationTime', description='Expiration time of the credentials'),
  kind?: string(name='kind', description='The kind of the credentials'),
  secretAccessKey?: string(name='secretAccessKey', description='Secret access key'),
  token?: string(name='token', description='Token'),
}

model GetEnvironmentResponse = {
  headers: map[string]string(name='headers'),
  body: Environment  
}

async function getEnvironment(name: string): GetEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEnvironmentWithOptions(name, headers, runtime);
}

async function getEnvironmentWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetEnvironmentResponse {
  name = OpenApiUtil.getEncodeParam(name);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetEnvironment',
    version = '2021-09-24',
    protocol = 'HTTPS',
    pathname = `/apis/serverlessdeployment/v1/environments/${name}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceResponse = {
  headers: map[string]string(name='headers'),
  body: Service  
}

async function getService(name: string): GetServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceWithOptions(name, headers, runtime);
}

async function getServiceWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceResponse {
  name = OpenApiUtil.getEncodeParam(name);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetService',
    version = '2021-09-24',
    protocol = 'HTTPS',
    pathname = `/apis/serverlessdeployment/v1/services/${name}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEnvironmentsResponse = {
  headers: map[string]string(name='headers'),
  body: [
    Environment
  ](name='body'),
}

async function listEnvironments(): ListEnvironmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEnvironmentsWithOptions(headers, runtime);
}

async function listEnvironmentsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListEnvironmentsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListEnvironments',
    version = '2021-09-24',
    protocol = 'HTTPS',
    pathname = `/apis/serverlessdeployment/v1/environments/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model ListServicesResponse = {
  headers: map[string]string(name='headers'),
  body: [
    Service
  ](name='body'),
}

async function listServices(): ListServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServicesWithOptions(headers, runtime);
}

async function listServicesWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListServicesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListServices',
    version = '2021-09-24',
    protocol = 'HTTPS',
    pathname = `/apis/serverlessdeployment/v1/services/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

model PutEnvironmentRequest {
  body?: Environment(name='body', description='An environment for serverless deployments'),
}

model PutEnvironmentResponse = {
  headers: map[string]string(name='headers'),
  body: Environment  
}

async function putEnvironment(name: string, request: PutEnvironmentRequest): PutEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putEnvironmentWithOptions(name, request, headers, runtime);
}

async function putEnvironmentWithOptions(name: string, request: PutEnvironmentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutEnvironmentResponse {
  Util.validateModel(request);
  name = OpenApiUtil.getEncodeParam(name);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PutEnvironment',
    version = '2021-09-24',
    protocol = 'HTTPS',
    pathname = `/apis/serverlessdeployment/v1/environments/${name}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PutServiceRequest {
  body?: Service(name='body', description='A service for serverless deployments'),
}

model PutServiceResponse = {
  headers: map[string]string(name='headers'),
  body: Service  
}

async function putService(name: string, request: PutServiceRequest): PutServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putServiceWithOptions(name, request, headers, runtime);
}

async function putServiceWithOptions(name: string, request: PutServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutServiceResponse {
  Util.validateModel(request);
  name = OpenApiUtil.getEncodeParam(name);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PutService',
    version = '2021-09-24',
    protocol = 'HTTPS',
    pathname = `/apis/serverlessdeployment/v1/services/${name}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

