/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('slbv2', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddServersToServerGroupRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
  serverGroupId?: string(name='ServerGroupId'),
  servers?: [ 
    {
      description?: string(name='Description', description='服务器描述信息'),
      port?: int32(name='Port', description='服务器端口'),
      serverId?: string(name='ServerId', description='服务器id'),
      serverIp?: string(name='ServerIp', description='服务器ip'),
      serverType?: string(name='ServerType', description='服务器类型'),
      weight?: int32(name='Weight', description='后端权重'),
      zoneId?: string(name='ZoneId', description='服务器对应的zoneId'),
    }
  ](name='Servers'),
}

model AddServersToServerGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
    serverGroupId?: string(name='ServerGroupId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddServersToServerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AddServersToServerGroupResponseBody(name='body'),
}

async function addServersToServerGroupWithOptions(request: AddServersToServerGroupRequest, runtime: Util.RuntimeOptions): AddServersToServerGroupResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.servers)) {
    body['Servers'] = request.servers;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddServersToServerGroup',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addServersToServerGroup(request: AddServersToServerGroupRequest): AddServersToServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addServersToServerGroupWithOptions(request, runtime);
}

model CreateListenerRequest {
  caCertificateIds?: [ string ](name='CaCertificateIds', description='ca 证书列表'),
  caEnabled?: boolean(name='CaEnabled'),
  certificateIds?: [ string ](name='CertificateIds', description='server证书列表'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  idleTimeout?: int32(name='IdleTimeout', description='空闲超时时间'),
  listenerDescription?: string(name='ListenerDescription', description='监听描述'),
  listenerPort?: int32(name='ListenerPort', description='监听端口'),
  listenerProtocol?: string(name='ListenerProtocol', description='监听协议'),
  loadBalancerId?: string(name='LoadBalancerId', description='add 必选'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  securityPolicyId?: string(name='SecurityPolicyId', description='Tclssl监听的安全策略'),
  serverGroupId?: string(name='ServerGroupId', description='servergroupId'),
}

model CreateListenerResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
    listenerId?: string(name='ListenerId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateListenerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateListenerResponseBody(name='body'),
}

async function createListenerWithOptions(request: CreateListenerRequest, runtime: Util.RuntimeOptions): CreateListenerResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.caCertificateIds)) {
    body['CaCertificateIds'] = request.caCertificateIds;
  }
  if (!Util.isUnset(request.caEnabled)) {
    body['CaEnabled'] = request.caEnabled;
  }
  if (!Util.isUnset(request.certificateIds)) {
    body['CertificateIds'] = request.certificateIds;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    body['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerDescription)) {
    body['ListenerDescription'] = request.listenerDescription;
  }
  if (!Util.isUnset(request.listenerPort)) {
    body['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    body['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    body['SecurityPolicyId'] = request.securityPolicyId;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateListener',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createListener(request: CreateListenerRequest): CreateListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createListenerWithOptions(request, runtime);
}

model CreateLoadBalancerRequest {
  addressIpVersion?: string(name='AddressIpVersion'),
  addressType?: string(name='AddressType'),
  billingConfig?: {
    autoPay?: boolean(name='AutoPay'),
    internetChargeType?: string(name='InternetChargeType', description='PayByTraffic, PayByBandwidth, PayByLcu, PayBy95, PayByOld95, PayBy96'),
    payType?: string(name='PayType', description='PrePay, PostPay'),
    period?: int32(name='Period'),
    pricingCycle?: string(name='PricingCycle', description='Month, Year, Day'),
    specification?: string(name='Specification'),
  }(name='BillingConfig'),
  clientToken?: string(name='ClientToken'),
  commonBandwidthPackageId?: string(name='CommonBandwidthPackageId'),
  dryRun?: boolean(name='DryRun'),
  enableCrossZone?: boolean(name='EnableCrossZone'),
  enableTrafficAffinity?: boolean(name='EnableTrafficAffinity'),
  loadBalancerName?: string(name='LoadBalancerName'),
  loadBalancerType?: string(name='LoadBalancerType'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  securityGroups?: [ string ](name='SecurityGroups'),
  vpcId?: string(name='VpcId'),
  zoneMappings?: [ 
    {
      allocationId?: string(name='AllocationId', description='公网ipId'),
      privateIPv4Address?: string(name='PrivateIPv4Address', description='私网ip'),
      vSwitchId?: string(name='VSwitchId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='ZoneMappings'),
}

model CreateLoadBalancerResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
    loadbalancerId?: string(name='LoadbalancerId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoadBalancerResponseBody(name='body'),
}

async function createLoadBalancerWithOptions(request: CreateLoadBalancerRequest, runtime: Util.RuntimeOptions): CreateLoadBalancerResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.addressIpVersion)) {
    body['AddressIpVersion'] = request.addressIpVersion;
  }
  if (!Util.isUnset(request.addressType)) {
    body['AddressType'] = request.addressType;
  }
  var bodyFlat : map[string]any= {};
  if (!Util.isUnset(request.billingConfig)) {
    bodyFlat['BillingConfig'] = request.billingConfig;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.commonBandwidthPackageId)) {
    body['CommonBandwidthPackageId'] = request.commonBandwidthPackageId;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.enableCrossZone)) {
    body['EnableCrossZone'] = request.enableCrossZone;
  }
  if (!Util.isUnset(request.enableTrafficAffinity)) {
    body['EnableTrafficAffinity'] = request.enableTrafficAffinity;
  }
  if (!Util.isUnset(request.loadBalancerName)) {
    body['LoadBalancerName'] = request.loadBalancerName;
  }
  if (!Util.isUnset(request.loadBalancerType)) {
    body['LoadBalancerType'] = request.loadBalancerType;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityGroups)) {
    body['SecurityGroups'] = request.securityGroups;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneMappings)) {
    body['ZoneMappings'] = request.zoneMappings;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoadBalancer',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLoadBalancer(request: CreateLoadBalancerRequest): CreateLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoadBalancerWithOptions(request, runtime);
}

model CreateSecurityPolicyRequest {
  ciphers?: [ string ](name='Ciphers'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  securityPolicyName?: string(name='SecurityPolicyName'),
  tlsVersions?: [ string ](name='TlsVersions'),
}

model CreateSecurityPolicyResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
    securityPolicyId?: string(name='SecurityPolicyId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSecurityPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSecurityPolicyResponseBody(name='body'),
}

async function createSecurityPolicyWithOptions(request: CreateSecurityPolicyRequest, runtime: Util.RuntimeOptions): CreateSecurityPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.ciphers)) {
    body['Ciphers'] = request.ciphers;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityPolicyName)) {
    body['SecurityPolicyName'] = request.securityPolicyName;
  }
  if (!Util.isUnset(request.tlsVersions)) {
    body['TlsVersions'] = request.tlsVersions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSecurityPolicy',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSecurityPolicy(request: CreateSecurityPolicyRequest): CreateSecurityPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSecurityPolicyWithOptions(request, runtime);
}

model CreateServerGroupRequest {
  addressIPVersion?: string(name='AddressIPVersion'),
  clientToken?: string(name='ClientToken'),
  connectionDrainEnable?: boolean(name='ConnectionDrainEnable', description='是否开启连接优雅中断'),
  connectionDrainTimeout?: int32(name='ConnectionDrainTimeout', description='连接优雅中断超时时间'),
  dryRun?: boolean(name='DryRun'),
  healthCheckConfig?: {
    healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查使用的端口'),
    healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='健康检查响应的最大超时时间'),
    healthCheckDomain?: string(name='HealthCheckDomain', description='健康检查的域名'),
    healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='是否开启健康检查'),
    healthCheckHttpCode?: [ string ](name='HealthCheckHttpCode', description='状态码，多个状态码用逗号分隔'),
    healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查时间间隔'),
    healthCheckType?: string(name='HealthCheckType', description='健康检查协议类型'),
    healthCheckUrl?: string(name='HealthCheckUrl', description='健康检查的url'),
    healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success'),
    unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail'),
  }(name='HealthCheckConfig', description='健康检查配置'),
  persistenceEnable?: boolean(name='PersistenceEnable', description='是否开启会话保持'),
  persistenceTimeout?: int32(name='PersistenceTimeout', description='会话保持超时时间'),
  protocol?: string(name='Protocol', description='后端服务器类型'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scheduler?: string(name='Scheduler', description='调度类型'),
  serverGroupName?: string(name='ServerGroupName', description='服务器组名称'),
  serverGroupType?: string(name='ServerGroupType', description='服务器组类型'),
  vpcId?: string(name='VpcId', description='服务器组所在vpc的id'),
}

model CreateServerGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
    serverGroupId?: string(name='ServerGroupId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateServerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServerGroupResponseBody(name='body'),
}

async function createServerGroupWithOptions(request: CreateServerGroupRequest, runtime: Util.RuntimeOptions): CreateServerGroupResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.addressIPVersion)) {
    body['AddressIPVersion'] = request.addressIPVersion;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.connectionDrainEnable)) {
    body['ConnectionDrainEnable'] = request.connectionDrainEnable;
  }
  if (!Util.isUnset(request.connectionDrainTimeout)) {
    body['ConnectionDrainTimeout'] = request.connectionDrainTimeout;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  var bodyFlat : map[string]any= {};
  if (!Util.isUnset(request.healthCheckConfig)) {
    bodyFlat['HealthCheckConfig'] = request.healthCheckConfig;
  }
  if (!Util.isUnset(request.persistenceEnable)) {
    body['PersistenceEnable'] = request.persistenceEnable;
  }
  if (!Util.isUnset(request.persistenceTimeout)) {
    body['PersistenceTimeout'] = request.persistenceTimeout;
  }
  if (!Util.isUnset(request.protocol)) {
    body['Protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.scheduler)) {
    body['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.serverGroupName)) {
    body['ServerGroupName'] = request.serverGroupName;
  }
  if (!Util.isUnset(request.serverGroupType)) {
    body['ServerGroupType'] = request.serverGroupType;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateServerGroup',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServerGroup(request: CreateServerGroupRequest): CreateServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServerGroupWithOptions(request, runtime);
}

model DeleteListenerRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  listenerId?: string(name='ListenerId', description='update or delete必选, add在custom中生成'),
  regionId?: string(name='RegionId'),
}

model DeleteListenerResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteListenerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteListenerResponseBody(name='body'),
}

async function deleteListenerWithOptions(request: DeleteListenerRequest, runtime: Util.RuntimeOptions): DeleteListenerResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    body['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteListener',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteListener(request: DeleteListenerRequest): DeleteListenerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteListenerWithOptions(request, runtime);
}

model DeleteLoadBalancerRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  loadBalancerId?: string(name='LoadBalancerId'),
  regionId?: string(name='RegionId'),
}

model DeleteLoadBalancerResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteLoadBalancerResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLoadBalancerResponseBody(name='body'),
}

async function deleteLoadBalancerWithOptions(request: DeleteLoadBalancerRequest, runtime: Util.RuntimeOptions): DeleteLoadBalancerResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLoadBalancer',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLoadBalancer(request: DeleteLoadBalancerRequest): DeleteLoadBalancerResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoadBalancerWithOptions(request, runtime);
}

model DeleteSecurityPolicyRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
  securityPolicyId?: string(name='SecurityPolicyId'),
}

model DeleteSecurityPolicyResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
    securityPolicyId?: string(name='SecurityPolicyId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSecurityPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSecurityPolicyResponseBody(name='body'),
}

async function deleteSecurityPolicyWithOptions(request: DeleteSecurityPolicyRequest, runtime: Util.RuntimeOptions): DeleteSecurityPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    body['SecurityPolicyId'] = request.securityPolicyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecurityPolicy',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSecurityPolicy(request: DeleteSecurityPolicyRequest): DeleteSecurityPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecurityPolicyWithOptions(request, runtime);
}

model DeleteServerGroupRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
  serverGroupId?: string(name='ServerGroupId', description='服务器组ID'),
}

model DeleteServerGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
    serverGroupId?: string(name='ServerGroupId', description='服务器组ID'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteServerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServerGroupResponseBody(name='body'),
}

async function deleteServerGroupWithOptions(request: DeleteServerGroupRequest, runtime: Util.RuntimeOptions): DeleteServerGroupResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServerGroup',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServerGroup(request: DeleteServerGroupRequest): DeleteServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServerGroupWithOptions(request, runtime);
}

model GetJobStatusRequest {
  clientToken?: string(name='ClientToken'),
  jobId?: string(name='JobId', description='add 必选'),
}

model GetJobStatusResponseBody = {
  code?: string(name='Code'),
  data?: {
    status?: string(name='Status'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetJobStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobStatusResponseBody(name='body'),
}

async function getJobStatusWithOptions(request: GetJobStatusRequest, runtime: Util.RuntimeOptions): GetJobStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJobStatus',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJobStatus(request: GetJobStatusRequest): GetJobStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobStatusWithOptions(request, runtime);
}

model GetListenerAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  listenerId?: string(name='ListenerId', description='update or delete必选, add在custom中生成'),
  regionId?: string(name='RegionId'),
}

model GetListenerAttributeResponseBody = {
  code?: string(name='Code'),
  data?: {
    aliUid?: long(name='AliUid', description='用户uid'),
    caCertificateIds?: [ string ](name='CaCertificateIds', description='ca 证书列表'),
    caEnabled?: boolean(name='CaEnabled'),
    certificateIds?: [ string ](name='CertificateIds', description='server证书列表'),
    gmtCreated?: string(name='GmtCreated', description='创建时间'),
    idleTimeout?: int32(name='IdleTimeout', description='空闲超时时间'),
    listenerDescription?: string(name='ListenerDescription', description='监听描述'),
    listenerId?: string(name='ListenerId', description='监听id'),
    listenerPort?: int32(name='ListenerPort', description='监听端口'),
    listenerProtocol?: string(name='ListenerProtocol', description='监听协议 (TCP, UDP, TCPSSL, GENEVE)'),
    listenerStatus?: string(name='ListenerStatus'),
    loadBalancerId?: string(name='LoadBalancerId', description='列表id'),
    regionId?: string(name='RegionId', description='业务location'),
    securityPolicyId?: string(name='SecurityPolicyId', description='Tclssl监听的安全策略'),
    serverGroupId?: string(name='ServerGroupId', description='servergroupId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: GetListenerAttributeResponseBody(name='body'),
}

async function getListenerAttributeWithOptions(request: GetListenerAttributeRequest, runtime: Util.RuntimeOptions): GetListenerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.listenerId)) {
    query['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetListenerAttribute',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getListenerAttribute(request: GetListenerAttributeRequest): GetListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getListenerAttributeWithOptions(request, runtime);
}

model GetLoadBalancerAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  loadBalancerId?: string(name='LoadBalancerId'),
  regionId?: string(name='RegionId'),
}

model GetLoadBalancerAttributeResponseBody = {
  code?: string(name='Code'),
  data?: {
    addressIpVersion?: string(name='AddressIpVersion'),
    addressType?: string(name='AddressType'),
    bid?: string(name='Bid'),
    capacityUnitCount?: long(name='CapacityUnitCount'),
    commonBandwidthPackageId?: string(name='CommonBandwidthPackageId'),
    createTime?: string(name='CreateTime'),
    crossZoneEnable?: boolean(name='CrossZoneEnable'),
    DNSName?: string(name='DNSName'),
    loadBalancerBusinessStatus?: string(name='LoadBalancerBusinessStatus'),
    loadBalancerId?: string(name='LoadBalancerId'),
    loadBalancerName?: string(name='LoadBalancerName'),
    loadBalancerStatus?: string(name='LoadBalancerStatus'),
    loadBalancerType?: string(name='LoadBalancerType'),
    operationLocks?: [ 
      {
        lockReason?: string(name='LockReason'),
        lockType?: string(name='LockType'),
      }
    ](name='OperationLocks', description='实例处于锁定状态列表'),
    regionId?: string(name='RegionId'),
    resourceGroupId?: string(name='ResourceGroupId'),
    securityGroupIds?: [ string ](name='SecurityGroupIds'),
    trafficAffinityEnable?: boolean(name='TrafficAffinityEnable'),
    vpcId?: string(name='VpcId'),
    zoneMappings?: [ 
      {
        allocationId?: string(name='AllocationId', description='公网ipId'),
        eniId?: string(name='EniId'),
        privateIPv4Address?: string(name='PrivateIPv4Address', description='私网ip'),
        publicIPv4Address?: string(name='PublicIPv4Address', description='公网ip地址：仅Get的时候有值'),
        vSwitchId?: string(name='VSwitchId'),
        zoneId?: string(name='ZoneId'),
      }
    ](name='ZoneMappings'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetLoadBalancerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: GetLoadBalancerAttributeResponseBody(name='body'),
}

async function getLoadBalancerAttributeWithOptions(request: GetLoadBalancerAttributeRequest, runtime: Util.RuntimeOptions): GetLoadBalancerAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    query['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLoadBalancerAttribute',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLoadBalancerAttribute(request: GetLoadBalancerAttributeRequest): GetLoadBalancerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLoadBalancerAttributeWithOptions(request, runtime);
}

model ListListenersRequest {
  listenerIds?: [ string ](name='ListenerIds', description='监听唯一标识'),
  listenerProtocol?: string(name='ListenerProtocol', description='监听协议'),
  loadBalancerIds?: [ string ](name='LoadBalancerIds', description='负载均衡实例标识'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
}

model ListListenersResponseBody = {
  code?: string(name='Code'),
  data?: {
    listeners?: [ 
      {
        aliUid?: long(name='AliUid', description='用户uid'),
        caCertificateIds?: [ string ](name='CaCertificateIds', description='ca 证书列表'),
        caEnabled?: boolean(name='CaEnabled'),
        certificateIds?: [ string ](name='CertificateIds', description='server证书列表'),
        gmtCreated?: string(name='GmtCreated', description='创建时间'),
        gmtModified?: string(name='GmtModified', description='修改时间'),
        idleTimeout?: int32(name='IdleTimeout', description='空闲超时时间'),
        listenerDescription?: string(name='ListenerDescription', description='监听描述'),
        listenerId?: string(name='ListenerId', description='自己生成后赋值'),
        listenerPort?: int32(name='ListenerPort', description='监听端口'),
        listenerProtocol?: string(name='ListenerProtocol', description='监听协议 (TCP, UDP, TCPSSL, GENEVE)'),
        listenerStatus?: string(name='ListenerStatus'),
        loadBalancerId?: string(name='LoadBalancerId'),
        regionId?: string(name='RegionId', description='业务location'),
        securityPolicyId?: string(name='SecurityPolicyId', description='Tclssl监听的安全策略'),
        serverGroupId?: string(name='ServerGroupId', description='servergroupId'),
      }
    ](name='Listeners'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListListenersResponse = {
  headers: map[string]string(name='headers'),
  body: ListListenersResponseBody(name='body'),
}

async function listListenersWithOptions(request: ListListenersRequest, runtime: Util.RuntimeOptions): ListListenersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listenerIds)) {
    query['ListenerIds'] = request.listenerIds;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalancerIds)) {
    query['LoadBalancerIds'] = request.loadBalancerIds;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListListeners',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listListeners(request: ListListenersRequest): ListListenersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listListenersWithOptions(request, runtime);
}

model ListLoadBalancersRequest {
  address?: string(name='Address', description='负载均衡地址 todo 增加校验方法'),
  addressIpVersion?: string(name='AddressIpVersion', description='协议类型'),
  addressType?: string(name='AddressType', description='地址类型：取值 internet，intranet'),
  DNSName?: string(name='DNSName', description='dns 地址'),
  loadBalancerBusinessStatus?: string(name='LoadBalancerBusinessStatus', description='实例业务状态'),
  loadBalancerIds?: [ string ](name='LoadBalancerIds', description='实例列表'),
  loadBalancerNames?: [ string ](name='LoadBalancerNames', description='负载均衡实例名称'),
  loadBalancerStatus?: string(name='LoadBalancerStatus', description='实例状态'),
  loadBalancerType?: string(name='LoadBalancerType', description='负载均衡类型'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId', description='企业资源组标识'),
  vpcIds?: [ string ](name='VpcIds', description='专有网络唯一标识'),
  zoneId?: string(name='ZoneId', description='负载均衡拥有的可用区'),
}

model ListLoadBalancersResponseBody = {
  code?: string(name='Code'),
  data?: {
    loadBalancers?: [ 
      {
        addressIpVersion?: string(name='AddressIpVersion'),
        addressType?: string(name='AddressType'),
        aliUid?: long(name='AliUid', description='用户uid'),
        bid?: string(name='Bid'),
        capacityUnitCount?: long(name='CapacityUnitCount'),
        commonBandwidthPackageId?: string(name='CommonBandwidthPackageId'),
        createTime?: string(name='CreateTime'),
        crossZoneEnable?: boolean(name='CrossZoneEnable'),
        DNSName?: string(name='DNSName'),
        gmtCreated?: string(name='GmtCreated', description='创建时间'),
        gmtModified?: string(name='GmtModified', description='修改时间'),
        loadBalancerBusinessStatus?: string(name='LoadBalancerBusinessStatus'),
        loadBalancerId?: string(name='LoadBalancerId'),
        loadBalancerName?: string(name='LoadBalancerName'),
        loadBalancerStatus?: string(name='LoadBalancerStatus'),
        loadBalancerType?: string(name='LoadBalancerType'),
        operationLocks?: [ 
          {
            lockReason?: string(name='LockReason'),
            lockType?: string(name='LockType'),
          }
        ](name='OperationLocks', description='实例处于锁定状态列表'),
        regionId?: string(name='RegionId', description='业务location'),
        regionNo?: string(name='RegionNo', description='物理location'),
        resourceGroupId?: string(name='ResourceGroupId'),
        securityGroupIds?: [ string ](name='SecurityGroupIds'),
        serviceManagedEnabled?: boolean(name='ServiceManagedEnabled'),
        serviceManagedMode?: string(name='ServiceManagedMode', description='是否为托管实例，取值Managed-1, Unmanaged-0, DependencyManaged-2'),
        serviceUid?: long(name='ServiceUid', description='托管实例服务账号UID'),
        trafficAffinityEnable?: boolean(name='TrafficAffinityEnable'),
        vpcId?: string(name='VpcId'),
        zoneMappings?: [ 
          {
            allocationId?: string(name='AllocationId', description='公网ipId'),
            eniId?: string(name='EniId'),
            privateIPv4Address?: string(name='PrivateIPv4Address', description='私网ip'),
            publicIPv4Address?: string(name='PublicIPv4Address', description='公网ip地址：仅Get的时候有值'),
            vSwitchId?: string(name='VSwitchId'),
            zoneId?: string(name='ZoneId'),
          }
        ](name='ZoneMappings'),
      }
    ](name='LoadBalancers'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListLoadBalancersResponse = {
  headers: map[string]string(name='headers'),
  body: ListLoadBalancersResponseBody(name='body'),
}

async function listLoadBalancersWithOptions(request: ListLoadBalancersRequest, runtime: Util.RuntimeOptions): ListLoadBalancersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.addressIpVersion)) {
    query['AddressIpVersion'] = request.addressIpVersion;
  }
  if (!Util.isUnset(request.addressType)) {
    query['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.DNSName)) {
    query['DNSName'] = request.DNSName;
  }
  if (!Util.isUnset(request.loadBalancerBusinessStatus)) {
    query['LoadBalancerBusinessStatus'] = request.loadBalancerBusinessStatus;
  }
  if (!Util.isUnset(request.loadBalancerIds)) {
    query['LoadBalancerIds'] = request.loadBalancerIds;
  }
  if (!Util.isUnset(request.loadBalancerNames)) {
    query['LoadBalancerNames'] = request.loadBalancerNames;
  }
  if (!Util.isUnset(request.loadBalancerStatus)) {
    query['LoadBalancerStatus'] = request.loadBalancerStatus;
  }
  if (!Util.isUnset(request.loadBalancerType)) {
    query['LoadBalancerType'] = request.loadBalancerType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vpcIds)) {
    query['VpcIds'] = request.vpcIds;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLoadBalancers',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLoadBalancers(request: ListLoadBalancersRequest): ListLoadBalancersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLoadBalancersWithOptions(request, runtime);
}

model ListServerGroupServersRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  serverGroupId?: string(name='ServerGroupId'),
  serverIds?: [ string ](name='ServerIds'),
}

model ListServerGroupServersResponseBody = {
  code?: string(name='Code'),
  data?: {
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    servers?: [ 
      {
        description?: string(name='Description', description='服务器描述信息'),
        port?: int32(name='Port', description='服务器端口'),
        serverGroupId?: string(name='ServerGroupId'),
        serverId?: string(name='ServerId', description='服务器id'),
        serverIp?: string(name='ServerIp', description='服务器ip'),
        serverType?: string(name='ServerType', description='服务器类型'),
        status?: string(name='Status', description='服务器的状态'),
        weight?: int32(name='Weight', description='后端权重'),
        zoneId?: string(name='ZoneId', description='服务器对应的zoneId'),
      }
    ](name='Servers'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListServerGroupServersResponse = {
  headers: map[string]string(name='headers'),
  body: ListServerGroupServersResponseBody(name='body'),
}

async function listServerGroupServersWithOptions(request: ListServerGroupServersRequest, runtime: Util.RuntimeOptions): ListServerGroupServersResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.serverIds)) {
    body['ServerIds'] = request.serverIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListServerGroupServers',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServerGroupServers(request: ListServerGroupServersRequest): ListServerGroupServersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServerGroupServersWithOptions(request, runtime);
}

model ListServerGroupsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  serverGroupIds?: [ string ](name='ServerGroupIds'),
  serverGroupNames?: [ string ](name='ServerGroupNames'),
  vpcId?: string(name='VpcId', description='服务器组所在vpc的id'),
}

model ListServerGroupsResponseBody = {
  code?: string(name='Code'),
  data?: {
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    serverGroups?: [ 
      {
        addressType?: string(name='AddressType', description='服务器组地址类型'),
        aliUid?: long(name='AliUid'),
        connectionDrain?: boolean(name='ConnectionDrain', description='连接优雅中断开关'),
        connectionDrainTimeout?: int32(name='ConnectionDrainTimeout', description='连接优雅中断超时时间'),
        connectionPersistence?: boolean(name='ConnectionPersistence', description='会话保持开关'),
        connectionPersistenceTimeout?: int32(name='ConnectionPersistenceTimeout', description='会话保持超时时间'),
        healthCheck?: {
          healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查使用的端口'),
          healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='健康检查响应的最大超时时间'),
          healthCheckDomain?: string(name='HealthCheckDomain', description='健康检查的域名'),
          healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='是否开启健康检查'),
          healthCheckHttpCode?: [ string ](name='HealthCheckHttpCode', description='状态码，多个状态码用逗号分隔'),
          healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查时间间隔'),
          healthCheckType?: string(name='HealthCheckType', description='健康检查协议类型'),
          healthCheckUrl?: string(name='HealthCheckUrl', description='健康检查的url'),
          healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success'),
          unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail'),
        }(name='HealthCheck', description='健康检查配置'),
        protocol?: string(name='Protocol', description='后端协议'),
        regionId?: string(name='RegionId', description='业务region'),
        resourceGroupId?: string(name='ResourceGroupId', description='资源组id'),
        resourceId?: string(name='ResourceId'),
        scheduler?: string(name='Scheduler', description='调度类型'),
        serverGroupId?: string(name='ServerGroupId', description='服务器组id'),
        serverGroupName?: string(name='ServerGroupName', description='服务器组名称'),
        serverGroupStatus?: string(name='ServerGroupStatus', description='状态'),
        serverGroupType?: string(name='ServerGroupType', description='服务器组类型'),
        vpcId?: string(name='VpcId', description='服务器组的vpcid'),
      }
    ](name='ServerGroups'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListServerGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListServerGroupsResponseBody(name='body'),
}

async function listServerGroupsWithOptions(request: ListServerGroupsRequest, runtime: Util.RuntimeOptions): ListServerGroupsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    body['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.serverGroupIds)) {
    body['ServerGroupIds'] = request.serverGroupIds;
  }
  if (!Util.isUnset(request.serverGroupNames)) {
    body['ServerGroupNames'] = request.serverGroupNames;
  }
  if (!Util.isUnset(request.vpcId)) {
    body['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListServerGroups',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServerGroups(request: ListServerGroupsRequest): ListServerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServerGroupsWithOptions(request, runtime);
}

model RemoveServersFromServerGroupRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
  serverGroupId?: string(name='ServerGroupId'),
  servers?: [ 
    {
      description?: string(name='Description', description='服务器描述信息'),
      id?: long(name='Id'),
      port?: int32(name='Port', description='服务器端口'),
      serverId?: string(name='ServerId', description='服务器id'),
      serverIp?: string(name='ServerIp', description='服务器ip'),
      serverType?: string(name='ServerType', description='服务器类型'),
      weight?: int32(name='Weight', description='后端权重'),
      zoneId?: string(name='ZoneId', description='服务器对应的zoneId'),
    }
  ](name='Servers'),
}

model RemoveServersFromServerGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
    serverGroupId?: string(name='ServerGroupId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RemoveServersFromServerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveServersFromServerGroupResponseBody(name='body'),
}

async function removeServersFromServerGroupWithOptions(request: RemoveServersFromServerGroupRequest, runtime: Util.RuntimeOptions): RemoveServersFromServerGroupResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.servers)) {
    body['Servers'] = request.servers;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveServersFromServerGroup',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeServersFromServerGroup(request: RemoveServersFromServerGroupRequest): RemoveServersFromServerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeServersFromServerGroupWithOptions(request, runtime);
}

model UpdateListenerAttributeRequest {
  caCertificateIds?: [ string ](name='CaCertificateIds', description='ca 证书列表'),
  caEnabled?: boolean(name='CaEnabled'),
  certificateIds?: [ string ](name='CertificateIds', description='server证书列表'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  idleTimeout?: int32(name='IdleTimeout'),
  listenerDescription?: string(name='ListenerDescription', description='监听描述'),
  listenerId?: string(name='ListenerId', description='update or delete必选, add在custom中生成'),
  regionId?: string(name='RegionId'),
  securityPolicyId?: string(name='SecurityPolicyId', description='https监听的安全策略'),
  serverGroupId?: string(name='ServerGroupId', description='实服务组'),
}

model UpdateListenerAttributeResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateListenerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateListenerAttributeResponseBody(name='body'),
}

async function updateListenerAttributeWithOptions(request: UpdateListenerAttributeRequest, runtime: Util.RuntimeOptions): UpdateListenerAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.caCertificateIds)) {
    body['CaCertificateIds'] = request.caCertificateIds;
  }
  if (!Util.isUnset(request.caEnabled)) {
    body['CaEnabled'] = request.caEnabled;
  }
  if (!Util.isUnset(request.certificateIds)) {
    body['CertificateIds'] = request.certificateIds;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.idleTimeout)) {
    body['IdleTimeout'] = request.idleTimeout;
  }
  if (!Util.isUnset(request.listenerDescription)) {
    body['ListenerDescription'] = request.listenerDescription;
  }
  if (!Util.isUnset(request.listenerId)) {
    body['ListenerId'] = request.listenerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    body['SecurityPolicyId'] = request.securityPolicyId;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateListenerAttribute',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateListenerAttribute(request: UpdateListenerAttributeRequest): UpdateListenerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateListenerAttributeWithOptions(request, runtime);
}

model UpdateLoadBalancerAddressTypeConfigRequest {
  addressType?: string(name='AddressType'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  loadBalancerId?: string(name='LoadBalancerId'),
  regionId?: string(name='RegionId'),
  zoneMappings?: [ 
    {
      allocationId?: string(name='AllocationId', description='公网ipId'),
      vSwitchId?: string(name='VSwitchId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='ZoneMappings'),
}

model UpdateLoadBalancerAddressTypeConfigResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateLoadBalancerAddressTypeConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLoadBalancerAddressTypeConfigResponseBody(name='body'),
}

async function updateLoadBalancerAddressTypeConfigWithOptions(request: UpdateLoadBalancerAddressTypeConfigRequest, runtime: Util.RuntimeOptions): UpdateLoadBalancerAddressTypeConfigResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.addressType)) {
    body['AddressType'] = request.addressType;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneMappings)) {
    body['ZoneMappings'] = request.zoneMappings;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoadBalancerAddressTypeConfig',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLoadBalancerAddressTypeConfig(request: UpdateLoadBalancerAddressTypeConfigRequest): UpdateLoadBalancerAddressTypeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoadBalancerAddressTypeConfigWithOptions(request, runtime);
}

model UpdateLoadBalancerAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  enableCrossZone?: boolean(name='EnableCrossZone'),
  enableTrafficAffinity?: boolean(name='EnableTrafficAffinity'),
  loadBalancerId?: string(name='LoadBalancerId'),
  loadBalancerName?: string(name='LoadBalancerName'),
  regionId?: string(name='RegionId'),
  securityGroups?: [ string ](name='SecurityGroups'),
}

model UpdateLoadBalancerAttributeResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateLoadBalancerAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLoadBalancerAttributeResponseBody(name='body'),
}

async function updateLoadBalancerAttributeWithOptions(request: UpdateLoadBalancerAttributeRequest, runtime: Util.RuntimeOptions): UpdateLoadBalancerAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.enableCrossZone)) {
    body['EnableCrossZone'] = request.enableCrossZone;
  }
  if (!Util.isUnset(request.enableTrafficAffinity)) {
    body['EnableTrafficAffinity'] = request.enableTrafficAffinity;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.loadBalancerName)) {
    body['LoadBalancerName'] = request.loadBalancerName;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityGroups)) {
    body['SecurityGroups'] = request.securityGroups;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoadBalancerAttribute',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLoadBalancerAttribute(request: UpdateLoadBalancerAttributeRequest): UpdateLoadBalancerAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoadBalancerAttributeWithOptions(request, runtime);
}

model UpdateLoadBalancerZonesRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  loadBalancerId?: string(name='LoadBalancerId'),
  regionId?: string(name='RegionId'),
  zoneMappings?: [ 
    {
      allocationId?: string(name='AllocationId', description='公网ipId'),
      privateIPv4Address?: string(name='PrivateIPv4Address', description='私网ip'),
      vSwitchId?: string(name='VSwitchId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='ZoneMappings'),
}

model UpdateLoadBalancerZonesResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateLoadBalancerZonesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLoadBalancerZonesResponseBody(name='body'),
}

async function updateLoadBalancerZonesWithOptions(request: UpdateLoadBalancerZonesRequest, runtime: Util.RuntimeOptions): UpdateLoadBalancerZonesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.loadBalancerId)) {
    body['LoadBalancerId'] = request.loadBalancerId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneMappings)) {
    body['ZoneMappings'] = request.zoneMappings;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoadBalancerZones',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLoadBalancerZones(request: UpdateLoadBalancerZonesRequest): UpdateLoadBalancerZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoadBalancerZonesWithOptions(request, runtime);
}

model UpdateSecurityPolicyAttributeRequest {
  ciphers?: [ string ](name='Ciphers'),
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
  requestContent?: string(name='RequestContent'),
  securityPolicyId?: string(name='SecurityPolicyId'),
  tlsVersions?: [ string ](name='TlsVersions'),
}

model UpdateSecurityPolicyAttributeResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
    securityPolicyId?: string(name='SecurityPolicyId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSecurityPolicyAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSecurityPolicyAttributeResponseBody(name='body'),
}

async function updateSecurityPolicyAttributeWithOptions(request: UpdateSecurityPolicyAttributeRequest, runtime: Util.RuntimeOptions): UpdateSecurityPolicyAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.ciphers)) {
    body['Ciphers'] = request.ciphers;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestContent)) {
    body['RequestContent'] = request.requestContent;
  }
  if (!Util.isUnset(request.securityPolicyId)) {
    body['SecurityPolicyId'] = request.securityPolicyId;
  }
  if (!Util.isUnset(request.tlsVersions)) {
    body['TlsVersions'] = request.tlsVersions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSecurityPolicyAttribute',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSecurityPolicyAttribute(request: UpdateSecurityPolicyAttributeRequest): UpdateSecurityPolicyAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSecurityPolicyAttributeWithOptions(request, runtime);
}

model UpdateServerGroupAttributeRequest {
  clientToken?: string(name='ClientToken'),
  connectionDrainEnable?: boolean(name='ConnectionDrainEnable', description='是否开启连接优雅中断'),
  connectionDrainTimeout?: int32(name='ConnectionDrainTimeout', description='连接优雅中断超时时间'),
  dryRun?: boolean(name='DryRun'),
  healthCheckConfig?: {
    healthCheckConnectPort?: int32(name='HealthCheckConnectPort', description='健康检查使用的端口'),
    healthCheckConnectTimeout?: int32(name='HealthCheckConnectTimeout', description='健康检查响应的最大超时时间'),
    healthCheckDomain?: string(name='HealthCheckDomain', description='健康检查的域名'),
    healthCheckEnabled?: boolean(name='HealthCheckEnabled', description='是否开启健康检查'),
    healthCheckHttpCode?: [ string ](name='HealthCheckHttpCode', description='状态码，多个状态码用逗号分隔'),
    healthCheckInterval?: int32(name='HealthCheckInterval', description='健康检查时间间隔'),
    healthCheckType?: string(name='HealthCheckType', description='健康检查协议类型'),
    healthCheckUrl?: string(name='HealthCheckUrl', description='健康检查的url'),
    healthyThreshold?: int32(name='HealthyThreshold', description='健康检查连续成功多少次后，将后端服务器的健康检查状态由fail判定为success'),
    unhealthyThreshold?: int32(name='UnhealthyThreshold', description='健康检查连续失败多少次后，将后端服务器的健康检查状态由success判定为fail'),
  }(name='HealthCheckConfig', description='健康检查配置'),
  persistenceEnable?: boolean(name='PersistenceEnable', description='是否开启会话保持'),
  persistenceTimeout?: int32(name='PersistenceTimeout', description='会话保持超时时间'),
  regionId?: string(name='RegionId'),
  scheduler?: string(name='Scheduler', description='调度类型'),
  serverGroupId?: string(name='ServerGroupId', description='服务器组ID'),
}

model UpdateServerGroupAttributeResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
    serverGroupId?: string(name='ServerGroupId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateServerGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateServerGroupAttributeResponseBody(name='body'),
}

async function updateServerGroupAttributeWithOptions(request: UpdateServerGroupAttributeRequest, runtime: Util.RuntimeOptions): UpdateServerGroupAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.connectionDrainEnable)) {
    body['ConnectionDrainEnable'] = request.connectionDrainEnable;
  }
  if (!Util.isUnset(request.connectionDrainTimeout)) {
    body['ConnectionDrainTimeout'] = request.connectionDrainTimeout;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  var bodyFlat : map[string]any= {};
  if (!Util.isUnset(request.healthCheckConfig)) {
    bodyFlat['HealthCheckConfig'] = request.healthCheckConfig;
  }
  if (!Util.isUnset(request.persistenceEnable)) {
    body['PersistenceEnable'] = request.persistenceEnable;
  }
  if (!Util.isUnset(request.persistenceTimeout)) {
    body['PersistenceTimeout'] = request.persistenceTimeout;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.scheduler)) {
    body['Scheduler'] = request.scheduler;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServerGroupAttribute',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateServerGroupAttribute(request: UpdateServerGroupAttributeRequest): UpdateServerGroupAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateServerGroupAttributeWithOptions(request, runtime);
}

model UpdateServerGroupServersAttributeRequest {
  clientToken?: string(name='ClientToken'),
  dryRun?: boolean(name='DryRun'),
  regionId?: string(name='RegionId'),
  serverGroupId?: string(name='ServerGroupId'),
  servers?: [ 
    {
      description?: string(name='Description', description='服务器描述信息'),
      port?: int32(name='Port', description='服务器端口'),
      serverId?: string(name='ServerId', description='服务器id'),
      serverIp?: string(name='ServerIp', description='服务器ip'),
      serverType?: string(name='ServerType', description='服务器类型'),
      weight?: int32(name='Weight', description='后端权重'),
    }
  ](name='Servers'),
}

model UpdateServerGroupServersAttributeResponseBody = {
  code?: string(name='Code'),
  data?: {
    jobId?: string(name='JobId'),
    serverGroupId?: string(name='ServerGroupId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateServerGroupServersAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateServerGroupServersAttributeResponseBody(name='body'),
}

async function updateServerGroupServersAttributeWithOptions(request: UpdateServerGroupServersAttributeRequest, runtime: Util.RuntimeOptions): UpdateServerGroupServersAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dryRun)) {
    body['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serverGroupId)) {
    body['ServerGroupId'] = request.serverGroupId;
  }
  if (!Util.isUnset(request.servers)) {
    body['Servers'] = request.servers;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServerGroupServersAttribute',
    version = '2022-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateServerGroupServersAttribute(request: UpdateServerGroupServersAttributeRequest): UpdateServerGroupServersAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateServerGroupServersAttributeWithOptions(request, runtime);
}

