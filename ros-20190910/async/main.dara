/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'ROS';
  @version = '2019-09-10';
  @endpointRule = 'central';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model CancelUpdateStackRequest {
  cancelType?: string(name='CancelType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  stackId: string(name='StackId', position='Query'),
}

model CancelUpdateStackResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelUpdateStackResponse = {
  headers: map[string]string(name='headers'),
  body: CancelUpdateStackResponseBody(name='body'),
}

async function cancelUpdateStack(request: CancelUpdateStackRequest): CancelUpdateStackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelUpdateStack', 'POST', '/V2/CancelUpdateStack', 'json', false, 'json', request);
}

model ContinueCreateStackRequest {
  dryRun?: boolean(name='DryRun', position='Query'),
  mode?: string(name='Mode', position='Query'),
  parallelism?: long(name='Parallelism', position='Query'),
  parameters?: [ 
    {
      parameterKey: string(name='ParameterKey'),
      parameterValue: string(name='ParameterValue'),
    }
  ](name='Parameters', position='Query'),
  ramRoleName?: string(name='RamRoleName', position='Query'),
  recreatingOptions?: [ string ](name='RecreatingOptions', position='Query'),
  recreatingResources?: [ string ](name='RecreatingResources', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  stackId: string(name='StackId', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model ContinueCreateStackResponseBody = {
  dryRunResult?: {
    parametersAllowedToBeModified?: [ string ](name='ParametersAllowedToBeModified'),
    parametersConditionallyAllowedToBeModified?: [ string ](name='ParametersConditionallyAllowedToBeModified'),
    parametersNotAllowedToBeModified?: [ string ](name='ParametersNotAllowedToBeModified'),
  }(name='DryRunResult'),
  requestId?: string(name='RequestId'),
  stackId?: string(name='StackId'),
}

model ContinueCreateStackResponse = {
  headers: map[string]string(name='headers'),
  body: ContinueCreateStackResponseBody(name='body'),
}

async function continueCreateStack(request: ContinueCreateStackRequest): ContinueCreateStackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ContinueCreateStack', 'POST', '/', 'json', false, 'json', request);
}

model CreateChangeSetRequest {
  changeSetName: string(name='ChangeSetName', position='Query'),
  changeSetType?: string(name='ChangeSetType', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  disableRollback?: boolean(name='DisableRollback', position='Query'),
  notificationURLs?: [ string ](name='NotificationURLs', position='Query'),
  parallelism?: long(name='Parallelism', position='Query'),
  parameters?: [ 
    {
      parameterKey: string(name='ParameterKey'),
      parameterValue: string(name='ParameterValue'),
    }
  ](name='Parameters', position='Query'),
  ramRoleName?: string(name='RamRoleName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  replacementOption?: string(name='ReplacementOption', position='Query'),
  resourcesToImport?: [ 
    {
      logicalResourceId: string(name='LogicalResourceId'),
      resourceIdentifier: string(name='ResourceIdentifier'),
      resourceType: string(name='ResourceType'),
    }
  ](name='ResourcesToImport', position='Query'),
  stackId?: string(name='StackId', position='Query'),
  stackName?: string(name='StackName', position='Query'),
  stackPolicyBody?: string(name='StackPolicyBody', position='Query'),
  stackPolicyDuringUpdateBody?: string(name='StackPolicyDuringUpdateBody', position='Query'),
  stackPolicyDuringUpdateURL?: string(name='StackPolicyDuringUpdateURL', position='Query'),
  stackPolicyURL?: string(name='StackPolicyURL', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  templateScratchId?: string(name='TemplateScratchId', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
  timeoutInMinutes?: long(name='TimeoutInMinutes', position='Query'),
  usePreviousParameters?: boolean(name='UsePreviousParameters', position='Query'),
}

model CreateChangeSetResponseBody = {
  changeSetId?: string(name='ChangeSetId'),
  requestId?: string(name='RequestId'),
  stackId?: string(name='StackId'),
}

model CreateChangeSetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateChangeSetResponseBody(name='body'),
}

async function createChangeSet(request: CreateChangeSetRequest): CreateChangeSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateChangeSet', 'POST', '/', 'json', false, 'json', request);
}

model CreateStackRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  createOption?: string(name='CreateOption', position='Query'),
  deletionProtection?: string(name='DeletionProtection', position='Query'),
  disableRollback?: boolean(name='DisableRollback', position='Query'),
  notificationURLs?: [ string ](name='NotificationURLs', position='Query'),
  parallelism?: long(name='Parallelism', position='Query'),
  parameters?: [ 
    {
      parameterKey: string(name='ParameterKey'),
      parameterValue: string(name='ParameterValue'),
    }
  ](name='Parameters', position='Query'),
  ramRoleName?: string(name='RamRoleName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  stackName: string(name='StackName', position='Query'),
  stackPolicyBody?: string(name='StackPolicyBody', position='Query'),
  stackPolicyURL?: string(name='StackPolicyURL', position='Query'),
  tags?: [ 
    {
      key: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  templateScratchId?: string(name='TemplateScratchId', position='Query'),
  templateScratchRegionId?: string(name='TemplateScratchRegionId', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
  timeoutInMinutes?: long(name='TimeoutInMinutes', position='Query'),
}

model CreateStackResponseBody = {
  requestId?: string(name='RequestId'),
  stackId?: string(name='StackId'),
}

model CreateStackResponse = {
  headers: map[string]string(name='headers'),
  body: CreateStackResponseBody(name='body'),
}

async function createStack(request: CreateStackRequest): CreateStackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateStack', 'POST', '/', 'json', false, 'json', request);
}

model CreateStackGroupRequest {
  administrationRoleName?: string(name='AdministrationRoleName', position='Query'),
  autoDeployment?: {
    enabled?: boolean(name='Enabled'),
    retainStacksOnAccountRemoval?: boolean(name='RetainStacksOnAccountRemoval'),
  }(name='AutoDeployment', shrink='json', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  executionRoleName?: string(name='ExecutionRoleName', position='Query'),
  parameters?: [ 
    {
      parameterKey: string(name='ParameterKey'),
      parameterValue: string(name='ParameterValue'),
    }
  ](name='Parameters', position='Query'),
  permissionModel?: string(name='PermissionModel', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  stackGroupName: string(name='StackGroupName', position='Query'),
  tags?: [ 
    {
      key: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model CreateStackGroupResponseBody = {
  requestId?: string(name='RequestId'),
  stackGroupId?: string(name='StackGroupId'),
}

model CreateStackGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateStackGroupResponseBody(name='body'),
}

async function createStackGroup(request: CreateStackGroupRequest): CreateStackGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateStackGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateStackInstancesRequest {
  accountIds?: [ string ](name='AccountIds', shrink='json', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  deploymentTargets?: {
    rdFolderIds?: [ string ](name='RdFolderIds'),
  }(name='DeploymentTargets', shrink='json', position='Query'),
  disableRollback?: boolean(name='DisableRollback', position='Query'),
  operationDescription?: string(name='OperationDescription', position='Query'),
  operationPreferences?: map[string]any(name='OperationPreferences', shrink='json', position='Query'),
  parameterOverrides?: [ 
    {
      parameterKey: string(name='ParameterKey'),
      parameterValue: string(name='ParameterValue'),
    }
  ](name='ParameterOverrides', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  regionIds: [ string ](name='RegionIds', shrink='json', position='Query'),
  stackGroupName: string(name='StackGroupName', position='Query'),
  timeoutInMinutes?: long(name='TimeoutInMinutes', minimum=10, maximum=1440, position='Query'),
}

model CreateStackInstancesResponseBody = {
  operationId?: string(name='OperationId'),
  requestId?: string(name='RequestId'),
}

model CreateStackInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateStackInstancesResponseBody(name='body'),
}

async function createStackInstances(request: CreateStackInstancesRequest): CreateStackInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateStackInstances', 'POST', '/', 'json', false, 'json', request);
}

model CreateTemplateRequest {
  description?: string(name='Description', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  tags?: [ 
    {
      key: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateName: string(name='TemplateName', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
}

model CreateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model CreateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTemplateResponseBody(name='body'),
}

async function createTemplate(request: CreateTemplateRequest): CreateTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTemplate', 'POST', '/', 'json', false, 'json', request);
}

model CreateTemplateScratchRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  executionMode?: string(name='ExecutionMode', position='Query'),
  logicalIdStrategy?: string(name='LogicalIdStrategy', position='Query'),
  preferenceParameters?: [ 
    {
      parameterKey: string(name='ParameterKey'),
      parameterValue: string(name='ParameterValue'),
    }
  ](name='PreferenceParameters', shrink='json', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  sourceResourceGroup?: {
    resourceGroupId: string(name='ResourceGroupId'),
    resourceTypeFilter?: [ string ](name='ResourceTypeFilter'),
  }(name='SourceResourceGroup', shrink='json', position='Query'),
  sourceResources?: [ 
    {
      resourceId: string(name='ResourceId'),
      resourceType: string(name='ResourceType'),
    }
  ](name='SourceResources', shrink='json', position='Query'),
  sourceTag?: {
    resourceTags: map[string]any(name='ResourceTags'),
    resourceTypeFilter?: [ string ](name='ResourceTypeFilter'),
  }(name='SourceTag', shrink='json', position='Query'),
  tags?: [ 
    {
      key: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags', position='Query'),
  templateScratchType: string(name='TemplateScratchType', position='Query'),
}

model CreateTemplateScratchResponseBody = {
  requestId?: string(name='RequestId'),
  templateScratchId?: string(name='TemplateScratchId'),
}

model CreateTemplateScratchResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTemplateScratchResponseBody(name='body'),
}

async function createTemplateScratch(request: CreateTemplateScratchRequest): CreateTemplateScratchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTemplateScratch', 'POST', '/', 'json', false, 'json', request);
}

model DeleteChangeSetRequest {
  changeSetId: string(name='ChangeSetId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DeleteChangeSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteChangeSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteChangeSetResponseBody(name='body'),
}

async function deleteChangeSet(request: DeleteChangeSetRequest): DeleteChangeSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteChangeSet', 'POST', '/V2/DeleteChangeSet', 'json', false, 'json', request);
}

model DeleteStackRequest {
  ramRoleName?: string(name='RamRoleName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  retainAllResources?: boolean(name='RetainAllResources', position='Query'),
  retainResources?: [ string ](name='RetainResources', position='Query'),
  stackId: string(name='StackId', position='Query'),
}

model DeleteStackResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteStackResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteStackResponseBody(name='body'),
}

async function deleteStack(request: DeleteStackRequest): DeleteStackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteStack', 'POST', '/', 'json', false, 'json', request);
}

model DeleteStackGroupRequest {
  regionId: string(name='RegionId', position='Query'),
  stackGroupName: string(name='StackGroupName', position='Query'),
}

model DeleteStackGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteStackGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteStackGroupResponseBody(name='body'),
}

async function deleteStackGroup(request: DeleteStackGroupRequest): DeleteStackGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteStackGroup', 'POST', '/V2/DeleteStackGroup', 'json', false, 'json', request);
}

model DeleteStackInstancesRequest {
  accountIds?: [ string ](name='AccountIds', shrink='json', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  deploymentTargets?: {
    rdFolderIds?: [ string ](name='RdFolderIds'),
  }(name='DeploymentTargets', shrink='json', position='Query'),
  operationDescription?: string(name='OperationDescription', position='Query'),
  operationPreferences?: map[string]any(name='OperationPreferences', shrink='json', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  regionIds: [ string ](name='RegionIds', shrink='json', position='Query'),
  retainStacks: boolean(name='RetainStacks', position='Query'),
  stackGroupName: string(name='StackGroupName', position='Query'),
}

model DeleteStackInstancesResponseBody = {
  operationId?: string(name='OperationId'),
  requestId?: string(name='RequestId'),
}

model DeleteStackInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteStackInstancesResponseBody(name='body'),
}

async function deleteStackInstances(request: DeleteStackInstancesRequest): DeleteStackInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteStackInstances', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTemplateRequest {
  templateId: string(name='TemplateId', position='Query'),
}

model DeleteTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTemplateResponseBody(name='body'),
}

async function deleteTemplate(request: DeleteTemplateRequest): DeleteTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTemplate', 'POST', '/V2/DeleteTemplate', 'json', false, 'json', request);
}

model DeleteTemplateScratchRequest {
  regionId: string(name='RegionId', position='Query'),
  templateScratchId: string(name='TemplateScratchId', position='Query'),
}

model DeleteTemplateScratchResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTemplateScratchResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTemplateScratchResponseBody(name='body'),
}

async function deleteTemplateScratch(request: DeleteTemplateScratchRequest): DeleteTemplateScratchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTemplateScratch', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/V2/DescribeRegions', 'json', false, 'json', request);
}

model DetectStackDriftRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  logicalResourceId?: [ string ](name='LogicalResourceId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  stackId: string(name='StackId', position='Query'),
}

model DetectStackDriftResponseBody = {
  driftDetectionId?: string(name='DriftDetectionId'),
  requestId?: string(name='RequestId'),
}

model DetectStackDriftResponse = {
  headers: map[string]string(name='headers'),
  body: DetectStackDriftResponseBody(name='body'),
}

async function detectStackDrift(request: DetectStackDriftRequest): DetectStackDriftResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetectStackDrift', 'POST', '/V2/DetectStackDrift', 'json', false, 'json', request);
}

model DetectStackGroupDriftRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  operationPreferences?: map[string]any(name='OperationPreferences', shrink='json', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  stackGroupName: string(name='StackGroupName', position='Query'),
}

model DetectStackGroupDriftResponseBody = {
  operationId?: string(name='OperationId'),
  requestId?: string(name='RequestId'),
}

model DetectStackGroupDriftResponse = {
  headers: map[string]string(name='headers'),
  body: DetectStackGroupDriftResponseBody(name='body'),
}

async function detectStackGroupDrift(request: DetectStackGroupDriftRequest): DetectStackGroupDriftResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetectStackGroupDrift', 'POST', '/V2/DetectStackGroupDrift', 'json', false, 'json', request);
}

model DetectStackResourceDriftRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  logicalResourceId: string(name='LogicalResourceId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  stackId: string(name='StackId', position='Query'),
}

model DetectStackResourceDriftResponseBody = {
  actualProperties?: string(name='ActualProperties'),
  driftDetectionTime?: string(name='DriftDetectionTime'),
  expectedProperties?: string(name='ExpectedProperties'),
  logicalResourceId?: string(name='LogicalResourceId'),
  physicalResourceId?: string(name='PhysicalResourceId'),
  propertyDifferences?: [ 
    {
      actualValue?: string(name='ActualValue'),
      differenceType?: string(name='DifferenceType'),
      expectedValue?: string(name='ExpectedValue'),
      propertyPath?: string(name='PropertyPath'),
    }
  ](name='PropertyDifferences'),
  requestId?: string(name='RequestId'),
  resourceDriftStatus?: string(name='ResourceDriftStatus'),
  resourceType?: string(name='ResourceType'),
  stackId?: string(name='StackId'),
}

model DetectStackResourceDriftResponse = {
  headers: map[string]string(name='headers'),
  body: DetectStackResourceDriftResponseBody(name='body'),
}

async function detectStackResourceDrift(request: DetectStackResourceDriftRequest): DetectStackResourceDriftResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetectStackResourceDrift', 'POST', '/', 'json', false, 'json', request);
}

model ExecuteChangeSetRequest {
  changeSetId: string(name='ChangeSetId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ExecuteChangeSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ExecuteChangeSetResponse = {
  headers: map[string]string(name='headers'),
  body: ExecuteChangeSetResponseBody(name='body'),
}

async function executeChangeSet(request: ExecuteChangeSetRequest): ExecuteChangeSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExecuteChangeSet', 'POST', '/', 'json', false, 'json', request);
}

model GenerateTemplateByScratchRequest {
  provisionRegionId?: string(name='ProvisionRegionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  templateScratchId: string(name='TemplateScratchId', position='Query'),
}

model GenerateTemplateByScratchResponseBody = {
  requestId?: string(name='RequestId'),
  resourcesToImport?: [ 
    {
      logicalResourceId?: string(name='LogicalResourceId'),
      resourceIdentifier?: map[string]any(name='ResourceIdentifier'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='ResourcesToImport'),
  templateBody?: string(name='TemplateBody'),
}

model GenerateTemplateByScratchResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateTemplateByScratchResponseBody(name='body'),
}

async function generateTemplateByScratch(request: GenerateTemplateByScratchRequest): GenerateTemplateByScratchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateTemplateByScratch', 'POST', '/', 'json', false, 'json', request);
}

model GenerateTemplatePolicyRequest {
  operationTypes?: [ string ](name='OperationTypes', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model GenerateTemplatePolicyResponseBody = {
  policy?: {
    statement?: [ 
      {
        action?: [ string ](name='Action'),
        effect?: string(name='Effect'),
        resource?: string(name='Resource'),
      }
    ](name='Statement'),
    version?: string(name='Version'),
  }(name='Policy'),
  requestId?: string(name='RequestId'),
}

model GenerateTemplatePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateTemplatePolicyResponseBody(name='body'),
}

async function generateTemplatePolicy(request: GenerateTemplatePolicyRequest): GenerateTemplatePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateTemplatePolicy', 'POST', '/', 'json', false, 'json', request);
}

model GetChangeSetRequest {
  changeSetId: string(name='ChangeSetId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  showTemplate?: boolean(name='ShowTemplate', position='Query'),
}

model GetChangeSetResponseBody = {
  changeSetId?: string(name='ChangeSetId'),
  changeSetName?: string(name='ChangeSetName'),
  changeSetType?: string(name='ChangeSetType'),
  changes?: [  map[string]any ](name='Changes'),
  createTime?: string(name='CreateTime'),
  description?: string(name='Description'),
  disableRollback?: boolean(name='DisableRollback'),
  executionStatus?: string(name='ExecutionStatus'),
  log?: {
    terraformLogs?: [ 
      {
        command?: string(name='Command'),
        content?: string(name='Content'),
        stream?: string(name='Stream'),
      }
    ](name='TerraformLogs'),
  }(name='Log'),
  parameters?: [ 
    {
      parameterKey?: string(name='ParameterKey'),
      parameterValue?: string(name='ParameterValue'),
    }
  ](name='Parameters'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  stackId?: string(name='StackId'),
  stackName?: string(name='StackName'),
  status?: string(name='Status'),
  statusReason?: string(name='StatusReason'),
  templateBody?: string(name='TemplateBody'),
  timeoutInMinutes?: int32(name='TimeoutInMinutes'),
}

model GetChangeSetResponse = {
  headers: map[string]string(name='headers'),
  body: GetChangeSetResponseBody(name='body'),
}

async function getChangeSet(request: GetChangeSetRequest): GetChangeSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetChangeSet', 'POST', '/', 'json', false, 'json', request);
}

model GetFeatureDetailsRequest {
  feature: string(name='Feature', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetFeatureDetailsResponseBody = {
  requestId?: string(name='RequestId'),
  resourceCleaner?: {
    supportedResourceTypes?: [ 
      {
        resourceType?: string(name='ResourceType'),
        sideEffects?: [ string ](name='SideEffects'),
        supportedFilters?: [ string ](name='SupportedFilters'),
      }
    ](name='SupportedResourceTypes'),
  }(name='ResourceCleaner'),
  templateScratch?: {
    supportedResourceTypes?: [ 
      {
        resourceType?: string(name='ResourceType'),
        sourceResourceGroupSupported?: boolean(name='SourceResourceGroupSupported'),
        sourceResourcesSupported?: boolean(name='SourceResourcesSupported'),
        sourceSupported?: boolean(name='SourceSupported'),
        sourceTagSupported?: boolean(name='SourceTagSupported'),
      }
    ](name='SupportedResourceTypes'),
  }(name='TemplateScratch'),
  terraform?: {
    supportedResourceTypes?: {
      customTag?: [ string ](name='CustomTag'),
      estimateCost?: [ string ](name='EstimateCost'),
      resourceGroup?: [ string ](name='ResourceGroup'),
      stackOperationRisk?: {
        deleteStack?: [ string ](name='DeleteStack'),
      }(name='StackOperationRisk'),
      systemTag?: [ string ](name='SystemTag'),
    }(name='SupportedResourceTypes'),
    supportedVersions?: [ 
      {
        providerVersions?: [ 
          {
            providerName?: string(name='ProviderName'),
            supportedVersions?: [ string ](name='SupportedVersions'),
          }
        ](name='ProviderVersions'),
        terraformVersion?: string(name='TerraformVersion'),
        transform?: string(name='Transform'),
        updateAllowedTransforms?: [ string ](name='UpdateAllowedTransforms'),
      }
    ](name='SupportedVersions'),
  }(name='Terraform'),
}

model GetFeatureDetailsResponse = {
  headers: map[string]string(name='headers'),
  body: GetFeatureDetailsResponseBody(name='body'),
}

async function getFeatureDetails(request: GetFeatureDetailsRequest): GetFeatureDetailsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetFeatureDetails', 'POST', '/', 'json', false, 'json', request);
}

model GetResourceTypeRequest {
  resourceType: string(name='ResourceType', position='Query'),
}

model GetResourceTypeResponseBody = {
  attributes?: map[string]any(name='Attributes'),
  entityType?: string(name='EntityType'),
  properties?: map[string]any(name='Properties'),
  requestId?: string(name='RequestId'),
  resourceType?: string(name='ResourceType'),
  supportDriftDetection?: boolean(name='SupportDriftDetection'),
  supportScratchDetection?: boolean(name='SupportScratchDetection'),
}

model GetResourceTypeResponse = {
  headers: map[string]string(name='headers'),
  body: GetResourceTypeResponseBody(name='body'),
}

async function getResourceType(request: GetResourceTypeRequest): GetResourceTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetResourceType', 'POST', '/', 'json', false, 'json', request);
}

model GetResourceTypeTemplateRequest {
  resourceType: string(name='ResourceType', position='Query'),
}

model GetResourceTypeTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateBody?: map[string]any(name='TemplateBody'),
}

model GetResourceTypeTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetResourceTypeTemplateResponseBody(name='body'),
}

async function getResourceTypeTemplate(request: GetResourceTypeTemplateRequest): GetResourceTypeTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetResourceTypeTemplate', 'POST', '/V2/GetResourceTypeTemplate', 'json', false, 'json', request);
}

model GetServiceProvisionsRequest {
  parameters?: [ 
    {
      parameterKey: string(name='ParameterKey'),
      parameterValue: string(name='ParameterValue'),
    }
  ](name='Parameters', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  services?: [ 
    {
      serviceName: string(name='ServiceName'),
    }
  ](name='Services', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model GetServiceProvisionsResponseBody = {
  requestId?: string(name='RequestId'),
  serviceProvisions?: [ 
    {
      autoEnableService?: boolean(name='AutoEnableService'),
      dependentServiceNames?: [ string ](name='DependentServiceNames'),
      enableURL?: string(name='EnableURL'),
      roleProvision?: {
        authorizationURL?: string(name='AuthorizationURL'),
        roles?: [ 
          {
            apiForCreation?: {
              apiName?: string(name='ApiName'),
              apiProductId?: string(name='ApiProductId'),
              apiType?: string(name='ApiType'),
              parameters?: map[string]any(name='Parameters'),
            }(name='ApiForCreation'),
            created?: boolean(name='Created'),
            function?: string(name='Function'),
            roleName?: string(name='RoleName'),
          }
        ](name='Roles'),
      }(name='RoleProvision'),
      serviceName?: string(name='ServiceName'),
      status?: string(name='Status'),
      statusReason?: string(name='StatusReason'),
    }
  ](name='ServiceProvisions'),
}

model GetServiceProvisionsResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceProvisionsResponseBody(name='body'),
}

async function getServiceProvisions(request: GetServiceProvisionsRequest): GetServiceProvisionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetServiceProvisions', 'POST', '/', 'json', false, 'json', request);
}

model GetStackRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  logOption?: string(name='LogOption', position='Query'),
  outputOption?: string(name='OutputOption', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  showResourceProgress?: string(name='ShowResourceProgress', position='Query'),
  stackId: string(name='StackId', position='Query'),
}

model GetStackResponseBody = {
  createTime?: string(name='CreateTime'),
  deletionProtection?: string(name='DeletionProtection'),
  description?: string(name='Description'),
  disableRollback?: boolean(name='DisableRollback'),
  driftDetectionTime?: string(name='DriftDetectionTime'),
  interface?: string(name='Interface'),
  log?: {
    resourceLogs?: [ 
      {
        logs?: [ 
          {
            content?: string(name='Content'),
            keys?: [ string ](name='Keys'),
          }
        ](name='Logs'),
        resourceName?: string(name='ResourceName'),
      }
    ](name='ResourceLogs'),
    terraformLogs?: [ 
      {
        command?: string(name='Command'),
        content?: string(name='Content'),
        stream?: string(name='Stream'),
      }
    ](name='TerraformLogs'),
  }(name='Log'),
  notificationURLs?: [ string ](name='NotificationURLs'),
  operationInfo?: {
    action?: string(name='Action'),
    code?: string(name='Code'),
    logicalResourceId?: string(name='LogicalResourceId'),
    message?: string(name='Message'),
    requestId?: string(name='RequestId'),
    resourceType?: string(name='ResourceType'),
  }(name='OperationInfo'),
  outputs?: [  map[string]any ](name='Outputs'),
  parameters?: [ 
    {
      parameterKey?: string(name='ParameterKey'),
      parameterValue?: string(name='ParameterValue'),
    }
  ](name='Parameters'),
  parentStackId?: string(name='ParentStackId'),
  ramRoleName?: string(name='RamRoleName'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceProgress?: {
    failedResourceCount?: int32(name='FailedResourceCount'),
    inProgressResourceCount?: int32(name='InProgressResourceCount'),
    inProgressResourceDetails?: [ 
      {
        progressTargetValue?: float(name='ProgressTargetValue'),
        progressValue?: float(name='ProgressValue'),
        resourceName?: string(name='ResourceName'),
        resourceType?: string(name='ResourceType'),
      }
    ](name='InProgressResourceDetails'),
    pendingResourceCount?: int32(name='PendingResourceCount'),
    successResourceCount?: int32(name='SuccessResourceCount'),
    totalResourceCount?: int32(name='TotalResourceCount'),
  }(name='ResourceProgress'),
  rootStackId?: string(name='RootStackId'),
  serviceManaged?: boolean(name='ServiceManaged'),
  serviceName?: string(name='ServiceName'),
  stackDriftStatus?: string(name='StackDriftStatus'),
  stackId?: string(name='StackId'),
  stackName?: string(name='StackName'),
  stackType?: string(name='StackType'),
  status?: string(name='Status'),
  statusReason?: string(name='StatusReason'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
  templateDescription?: string(name='TemplateDescription'),
  templateId?: string(name='TemplateId'),
  templateScratchId?: string(name='TemplateScratchId'),
  templateURL?: string(name='TemplateURL'),
  templateVersion?: string(name='TemplateVersion'),
  timeoutInMinutes?: int32(name='TimeoutInMinutes'),
  updateTime?: string(name='UpdateTime'),
}

model GetStackResponse = {
  headers: map[string]string(name='headers'),
  body: GetStackResponseBody(name='body'),
}

async function getStack(request: GetStackRequest): GetStackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetStack', 'POST', '/', 'json', false, 'json', request);
}

model GetStackDriftDetectionStatusRequest {
  driftDetectionId: string(name='DriftDetectionId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetStackDriftDetectionStatusResponseBody = {
  driftDetectionId?: string(name='DriftDetectionId'),
  driftDetectionStatus?: string(name='DriftDetectionStatus'),
  driftDetectionStatusReason?: string(name='DriftDetectionStatusReason'),
  driftDetectionTime?: string(name='DriftDetectionTime'),
  driftedStackResourceCount?: int32(name='DriftedStackResourceCount'),
  requestId?: string(name='RequestId'),
  stackDriftStatus?: string(name='StackDriftStatus'),
  stackId?: string(name='StackId'),
}

model GetStackDriftDetectionStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetStackDriftDetectionStatusResponseBody(name='body'),
}

async function getStackDriftDetectionStatus(request: GetStackDriftDetectionStatusRequest): GetStackDriftDetectionStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetStackDriftDetectionStatus', 'POST', '/V2/GetStackDriftDetectionStatus', 'json', false, 'json', request);
}

model GetStackGroupRequest {
  regionId: string(name='RegionId', position='Query'),
  stackGroupId?: string(name='StackGroupId', position='Query'),
  stackGroupName?: string(name='StackGroupName', position='Query'),
}

model GetStackGroupResponseBody = {
  requestId?: string(name='RequestId'),
  stackGroup?: {
    administrationRoleName?: string(name='AdministrationRoleName'),
    autoDeployment?: {
      enabled?: boolean(name='Enabled'),
      retainStacksOnAccountRemoval?: boolean(name='RetainStacksOnAccountRemoval'),
    }(name='AutoDeployment'),
    description?: string(name='Description'),
    executionRoleName?: string(name='ExecutionRoleName'),
    parameters?: [ 
      {
        parameterKey?: string(name='ParameterKey'),
        parameterValue?: string(name='ParameterValue'),
      }
    ](name='Parameters'),
    permissionModel?: string(name='PermissionModel'),
    rdFolderIds?: [ string ](name='RdFolderIds'),
    resourceGroupId?: string(name='ResourceGroupId'),
    stackGroupDriftDetectionDetail?: {
      cancelledStackInstancesCount?: int32(name='CancelledStackInstancesCount'),
      driftDetectionStatus?: string(name='DriftDetectionStatus'),
      driftDetectionTime?: string(name='DriftDetectionTime'),
      driftedStackInstancesCount?: int32(name='DriftedStackInstancesCount'),
      failedStackInstancesCount?: int32(name='FailedStackInstancesCount'),
      inProgressStackInstancesCount?: int32(name='InProgressStackInstancesCount'),
      inSyncStackInstancesCount?: int32(name='InSyncStackInstancesCount'),
      stackGroupDriftStatus?: string(name='StackGroupDriftStatus'),
      totalStackInstancesCount?: int32(name='TotalStackInstancesCount'),
    }(name='StackGroupDriftDetectionDetail'),
    stackGroupId?: string(name='StackGroupId'),
    stackGroupName?: string(name='StackGroupName'),
    status?: string(name='Status'),
    templateBody?: string(name='TemplateBody'),
  }(name='StackGroup'),
}

model GetStackGroupResponse = {
  headers: map[string]string(name='headers'),
  body: GetStackGroupResponseBody(name='body'),
}

async function getStackGroup(request: GetStackGroupRequest): GetStackGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetStackGroup', 'POST', '/', 'json', false, 'json', request);
}

model GetStackGroupOperationRequest {
  operationId: string(name='OperationId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model GetStackGroupOperationResponseBody = {
  requestId?: string(name='RequestId'),
  stackGroupOperation?: {
    action?: string(name='Action'),
    administrationRoleName?: string(name='AdministrationRoleName'),
    createTime?: string(name='CreateTime'),
    deploymentTargets?: {
      accountIds?: [ string ](name='AccountIds'),
      rdFolderIds?: [ string ](name='RdFolderIds'),
    }(name='DeploymentTargets'),
    endTime?: string(name='EndTime'),
    executionRoleName?: string(name='ExecutionRoleName'),
    operationDescription?: string(name='OperationDescription'),
    operationId?: string(name='OperationId'),
    operationPreferences?: {
      failureToleranceCount?: int32(name='FailureToleranceCount'),
      failureTolerancePercentage?: int32(name='FailureTolerancePercentage'),
      maxConcurrentCount?: int32(name='MaxConcurrentCount'),
      maxConcurrentPercentage?: int32(name='MaxConcurrentPercentage'),
      regionIdsOrder?: [ string ](name='RegionIdsOrder'),
    }(name='OperationPreferences'),
    retainStacks?: boolean(name='RetainStacks'),
    stackGroupDriftDetectionDetail?: {
      cancelledStackInstancesCount?: int32(name='CancelledStackInstancesCount'),
      driftDetectionStatus?: string(name='DriftDetectionStatus'),
      driftDetectionTime?: string(name='DriftDetectionTime'),
      driftedStackInstancesCount?: int32(name='DriftedStackInstancesCount'),
      failedStackInstancesCount?: int32(name='FailedStackInstancesCount'),
      inProgressStackInstancesCount?: int32(name='InProgressStackInstancesCount'),
      inSyncStackInstancesCount?: int32(name='InSyncStackInstancesCount'),
      stackGroupDriftStatus?: string(name='StackGroupDriftStatus'),
      totalStackInstancesCount?: int32(name='TotalStackInstancesCount'),
    }(name='StackGroupDriftDetectionDetail'),
    stackGroupId?: string(name='StackGroupId'),
    stackGroupName?: string(name='StackGroupName'),
    status?: string(name='Status'),
  }(name='StackGroupOperation'),
}

model GetStackGroupOperationResponse = {
  headers: map[string]string(name='headers'),
  body: GetStackGroupOperationResponseBody(name='body'),
}

async function getStackGroupOperation(request: GetStackGroupOperationRequest): GetStackGroupOperationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetStackGroupOperation', 'POST', '/', 'json', false, 'json', request);
}

model GetStackInstanceRequest {
  regionId: string(name='RegionId', position='Query'),
  stackGroupName: string(name='StackGroupName', position='Query'),
  stackInstanceAccountId: string(name='StackInstanceAccountId', position='Query'),
  stackInstanceRegionId: string(name='StackInstanceRegionId', position='Query'),
}

model GetStackInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  stackInstance?: {
    accountId?: string(name='AccountId'),
    driftDetectionTime?: string(name='DriftDetectionTime'),
    parameterOverrides?: [ 
      {
        parameterKey?: string(name='ParameterKey'),
        parameterValue?: string(name='ParameterValue'),
      }
    ](name='ParameterOverrides'),
    rdFolderId?: string(name='RdFolderId'),
    regionId?: string(name='RegionId'),
    stackDriftStatus?: string(name='StackDriftStatus'),
    stackGroupId?: string(name='StackGroupId'),
    stackGroupName?: string(name='StackGroupName'),
    stackId?: string(name='StackId'),
    status?: string(name='Status'),
    statusReason?: string(name='StatusReason'),
  }(name='StackInstance'),
}

model GetStackInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: GetStackInstanceResponseBody(name='body'),
}

async function getStackInstance(request: GetStackInstanceRequest): GetStackInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetStackInstance', 'POST', '/', 'json', false, 'json', request);
}

model GetStackPolicyRequest {
  regionId: string(name='RegionId', position='Query'),
  stackId: string(name='StackId', position='Query'),
}

model GetStackPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  stackPolicyBody?: map[string]any(name='StackPolicyBody'),
}

model GetStackPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: GetStackPolicyResponseBody(name='body'),
}

async function getStackPolicy(request: GetStackPolicyRequest): GetStackPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetStackPolicy', 'POST', '/V2/GetStackPolicy', 'json', false, 'json', request);
}

model GetStackResourceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  logicalResourceId: string(name='LogicalResourceId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceAttributes?: [ string ](name='ResourceAttributes', position='Query'),
  showResourceAttributes?: boolean(name='ShowResourceAttributes', position='Query'),
  stackId: string(name='StackId', position='Query'),
}

model GetStackResourceResponseBody = {
  createTime?: string(name='CreateTime'),
  description?: string(name='Description'),
  driftDetectionTime?: string(name='DriftDetectionTime'),
  logicalResourceId?: string(name='LogicalResourceId'),
  metadata?: map[string]any(name='Metadata'),
  physicalResourceId?: string(name='PhysicalResourceId'),
  requestId?: string(name='RequestId'),
  resourceAttributes?: [  map[string]any ](name='ResourceAttributes'),
  resourceDriftStatus?: string(name='ResourceDriftStatus'),
  resourceType?: string(name='ResourceType'),
  stackId?: string(name='StackId'),
  stackName?: string(name='StackName'),
  status?: string(name='Status'),
  statusReason?: string(name='StatusReason'),
  updateTime?: string(name='UpdateTime'),
}

model GetStackResourceResponse = {
  headers: map[string]string(name='headers'),
  body: GetStackResourceResponseBody(name='body'),
}

async function getStackResource(request: GetStackResourceRequest): GetStackResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetStackResource', 'POST', '/', 'json', false, 'json', request);
}

model GetTemplateRequest {
  changeSetId?: string(name='ChangeSetId', position='Query'),
  includePermission?: string(name='IncludePermission', position='Query'),
  includeTags?: string(name='IncludeTags', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  stackGroupName?: string(name='StackGroupName', position='Query'),
  stackId?: string(name='StackId', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  templateStage?: string(name='TemplateStage', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model GetTemplateResponseBody = {
  changeSetId?: string(name='ChangeSetId'),
  createTime?: string(name='CreateTime'),
  description?: string(name='Description'),
  interface?: string(name='Interface'),
  ownerId?: string(name='OwnerId'),
  permissions?: [ 
    {
      accountId?: string(name='AccountId'),
      shareOption?: string(name='ShareOption'),
      shareSource?: string(name='ShareSource'),
      templateVersion?: string(name='TemplateVersion'),
      versionOption?: string(name='VersionOption'),
    }
  ](name='Permissions'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  shareType?: string(name='ShareType'),
  stackGroupName?: string(name='StackGroupName'),
  stackId?: string(name='StackId'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
  templateARN?: string(name='TemplateARN'),
  templateBody?: string(name='TemplateBody'),
  templateId?: string(name='TemplateId'),
  templateName?: string(name='TemplateName'),
  templateVersion?: string(name='TemplateVersion'),
  updateTime?: string(name='UpdateTime'),
}

model GetTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetTemplateResponseBody(name='body'),
}

async function getTemplate(request: GetTemplateRequest): GetTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTemplate', 'POST', '/', 'json', false, 'json', request);
}

model GetTemplateEstimateCostRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  parameters?: [ 
    {
      parameterKey: string(name='ParameterKey'),
      parameterValue: string(name='ParameterValue'),
    }
  ](name='Parameters', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  templateScratchId?: string(name='TemplateScratchId', position='Query'),
  templateScratchRegionId?: string(name='TemplateScratchRegionId', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model GetTemplateEstimateCostResponseBody = {
  requestId?: string(name='RequestId'),
  resources?: map[string]any(name='Resources'),
}

model GetTemplateEstimateCostResponse = {
  headers: map[string]string(name='headers'),
  body: GetTemplateEstimateCostResponseBody(name='body'),
}

async function getTemplateEstimateCost(request: GetTemplateEstimateCostRequest): GetTemplateEstimateCostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTemplateEstimateCost', 'POST', '/', 'json', false, 'json', request);
}

model GetTemplateParameterConstraintsRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  parameters?: [ 
    {
      parameterKey: string(name='ParameterKey'),
      parameterValue: string(name='ParameterValue'),
    }
  ](name='Parameters', position='Query'),
  parametersKeyFilter?: [ string ](name='ParametersKeyFilter', shrink='json', position='Query'),
  parametersOrder?: [ string ](name='ParametersOrder', shrink='json', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model GetTemplateParameterConstraintsResponseBody = {
  parameterConstraints?: [ 
    {
      allowedValues?: [ string ](name='AllowedValues'),
      associationParameterNames?: [ string ](name='AssociationParameterNames'),
      behavior?: string(name='Behavior'),
      behaviorReason?: string(name='BehaviorReason'),
      illegalValueByParameterConstraints?: [ any ](name='IllegalValueByParameterConstraints'),
      illegalValueByRules?: [ any ](name='IllegalValueByRules'),
      parameterKey?: string(name='ParameterKey'),
      type?: string(name='Type'),
    }
  ](name='ParameterConstraints'),
  requestId?: string(name='RequestId'),
}

model GetTemplateParameterConstraintsResponse = {
  headers: map[string]string(name='headers'),
  body: GetTemplateParameterConstraintsResponseBody(name='body'),
}

async function getTemplateParameterConstraints(request: GetTemplateParameterConstraintsRequest): GetTemplateParameterConstraintsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTemplateParameterConstraints', 'POST', '/', 'json', false, 'json', request);
}

model GetTemplateScratchRequest {
  regionId: string(name='RegionId', position='Query'),
  showDataOption?: string(name='ShowDataOption', position='Query'),
  templateScratchId?: string(name='TemplateScratchId', position='Query'),
}

model GetTemplateScratchResponseBody = {
  requestId?: string(name='RequestId'),
  templateScratch?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    failedCode?: string(name='FailedCode'),
    logicalIdStrategy?: string(name='LogicalIdStrategy'),
    preferenceParameters?: [ 
      {
        parameterKey?: string(name='ParameterKey'),
        parameterValue?: string(name='ParameterValue'),
      }
    ](name='PreferenceParameters'),
    sourceResourceGroup?: {
      resourceGroupId?: string(name='ResourceGroupId'),
      resourceTypeFilter?: [ string ](name='ResourceTypeFilter'),
    }(name='SourceResourceGroup'),
    sourceResources?: [ 
      {
        resourceId?: string(name='ResourceId'),
        resourceType?: string(name='ResourceType'),
      }
    ](name='SourceResources'),
    sourceTag?: {
      resourceTags?: map[string]any(name='ResourceTags'),
      resourceTypeFilter?: [ string ](name='ResourceTypeFilter'),
    }(name='SourceTag'),
    stackProvision?: {
      creatable?: boolean(name='Creatable'),
      importable?: boolean(name='Importable'),
    }(name='StackProvision'),
    stacks?: [ 
      {
        regionId?: string(name='RegionId'),
        stackId?: string(name='StackId'),
        usageType?: string(name='UsageType'),
      }
    ](name='Stacks'),
    status?: string(name='Status'),
    statusReason?: string(name='StatusReason'),
    templateScratchData?: map[string]any(name='TemplateScratchData'),
    templateScratchId?: string(name='TemplateScratchId'),
    templateScratchType?: string(name='TemplateScratchType'),
    updateTime?: string(name='UpdateTime'),
  }(name='TemplateScratch'),
}

model GetTemplateScratchResponse = {
  headers: map[string]string(name='headers'),
  body: GetTemplateScratchResponseBody(name='body'),
}

async function getTemplateScratch(request: GetTemplateScratchRequest): GetTemplateScratchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTemplateScratch', 'POST', '/', 'json', false, 'json', request);
}

model GetTemplateSummaryRequest {
  changeSetId?: string(name='ChangeSetId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  parameters?: [ 
    {
      parameterKey?: string(name='ParameterKey'),
      parameterValue?: string(name='ParameterValue'),
    }
  ](name='Parameters', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  stackGroupName?: string(name='StackGroupName', position='Query'),
  stackId?: string(name='StackId', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model GetTemplateSummaryResponseBody = {
  description?: string(name='Description'),
  metadata?: map[string]any(name='Metadata'),
  parameters?: [  map[string]any ](name='Parameters'),
  requestId?: string(name='RequestId'),
  resourceIdentifierSummaries?: [ 
    {
      logicalResourceIds?: [ string ](name='LogicalResourceIds'),
      resourceIdentifiers?: [ string ](name='ResourceIdentifiers'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='ResourceIdentifierSummaries'),
  resourceTypes?: [ string ](name='ResourceTypes'),
  version?: string(name='Version'),
}

model GetTemplateSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: GetTemplateSummaryResponseBody(name='body'),
}

async function getTemplateSummary(request: GetTemplateSummaryRequest): GetTemplateSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTemplateSummary', 'POST', '/', 'json', false, 'json', request);
}

model ListChangeSetsRequest {
  changeSetId?: string(name='ChangeSetId', position='Query'),
  changeSetName?: [ string ](name='ChangeSetName', position='Query'),
  executionStatus?: [ string ](name='ExecutionStatus', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  stackId: string(name='StackId', position='Query'),
  status?: [ string ](name='Status', position='Query'),
}

model ListChangeSetsResponseBody = {
  changeSets?: [ 
    {
      changeSetId?: string(name='ChangeSetId'),
      changeSetName?: string(name='ChangeSetName'),
      changeSetType?: string(name='ChangeSetType'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      executionStatus?: string(name='ExecutionStatus'),
      regionId?: string(name='RegionId'),
      stackId?: string(name='StackId'),
      stackName?: string(name='StackName'),
      status?: string(name='Status'),
      statusReason?: string(name='StatusReason'),
    }
  ](name='ChangeSets'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListChangeSetsResponse = {
  headers: map[string]string(name='headers'),
  body: ListChangeSetsResponseBody(name='body'),
}

async function listChangeSets(request: ListChangeSetsRequest): ListChangeSetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListChangeSets', 'POST', '/V2/ListChangeSets', 'json', false, 'json', request);
}

model ListResourceTypesRequest {
  entityType?: string(name='EntityType', position='Query'),
}

model ListResourceTypesResponseBody = {
  requestId?: string(name='RequestId'),
  resourceTypes?: [ string ](name='ResourceTypes'),
}

model ListResourceTypesResponse = {
  headers: map[string]string(name='headers'),
  body: ListResourceTypesResponseBody(name='body'),
}

async function listResourceTypes(request: ListResourceTypesRequest): ListResourceTypesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListResourceTypes', 'POST', '/', 'json', false, 'json', request);
}

model ListStackEventsRequest {
  logicalResourceId?: [ string ](name='LogicalResourceId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceType?: [ string ](name='ResourceType', position='Query'),
  stackId: string(name='StackId', position='Query'),
  status?: [ string ](name='Status', position='Query'),
}

model ListStackEventsResponseBody = {
  events?: [ 
    {
      createTime?: string(name='CreateTime'),
      eventId?: string(name='EventId'),
      logicalResourceId?: string(name='LogicalResourceId'),
      physicalResourceId?: string(name='PhysicalResourceId'),
      resourceType?: string(name='ResourceType'),
      stackId?: string(name='StackId'),
      stackName?: string(name='StackName'),
      status?: string(name='Status'),
      statusReason?: string(name='StatusReason'),
    }
  ](name='Events'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListStackEventsResponse = {
  headers: map[string]string(name='headers'),
  body: ListStackEventsResponseBody(name='body'),
}

async function listStackEvents(request: ListStackEventsRequest): ListStackEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListStackEvents', 'POST', '/V2/ListStackEvents', 'json', false, 'json', request);
}

model ListStackGroupOperationResultsRequest {
  operationId: string(name='OperationId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model ListStackGroupOperationResultsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  stackGroupOperationResults?: [ 
    {
      accountId?: string(name='AccountId'),
      rdFolderId?: string(name='RdFolderId'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      statusReason?: string(name='StatusReason'),
    }
  ](name='StackGroupOperationResults'),
  totalCount?: int32(name='TotalCount'),
}

model ListStackGroupOperationResultsResponse = {
  headers: map[string]string(name='headers'),
  body: ListStackGroupOperationResultsResponseBody(name='body'),
}

async function listStackGroupOperationResults(request: ListStackGroupOperationResultsRequest): ListStackGroupOperationResultsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListStackGroupOperationResults', 'POST', '/', 'json', false, 'json', request);
}

model ListStackGroupOperationsRequest {
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  stackGroupName: string(name='StackGroupName', position='Query'),
}

model ListStackGroupOperationsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  stackGroupOperations?: [ 
    {
      action?: string(name='Action'),
      createTime?: string(name='CreateTime'),
      endTime?: string(name='EndTime'),
      operationDescription?: string(name='OperationDescription'),
      operationId?: string(name='OperationId'),
      stackGroupId?: string(name='StackGroupId'),
      stackGroupName?: string(name='StackGroupName'),
      status?: string(name='Status'),
    }
  ](name='StackGroupOperations'),
  totalCount?: int32(name='TotalCount'),
}

model ListStackGroupOperationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListStackGroupOperationsResponseBody(name='body'),
}

async function listStackGroupOperations(request: ListStackGroupOperationsRequest): ListStackGroupOperationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListStackGroupOperations', 'POST', '/V2/ListStackGroupOperations', 'json', false, 'json', request);
}

model ListStackGroupsRequest {
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  status?: string(name='Status', position='Query'),
  tags?: [ 
    {
      key: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags', position='Query'),
}

model ListStackGroupsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  stackGroups?: [ 
    {
      autoDeployment?: {
        enabled?: boolean(name='Enabled'),
        retainStacksOnAccountRemoval?: boolean(name='RetainStacksOnAccountRemoval'),
      }(name='AutoDeployment'),
      description?: string(name='Description'),
      driftDetectionTime?: string(name='DriftDetectionTime'),
      permissionModel?: string(name='PermissionModel'),
      resourceGroupId?: string(name='ResourceGroupId'),
      stackGroupDriftStatus?: string(name='StackGroupDriftStatus'),
      stackGroupId?: string(name='StackGroupId'),
      stackGroupName?: string(name='StackGroupName'),
      status?: string(name='Status'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
    }
  ](name='StackGroups'),
  totalCount?: int32(name='TotalCount'),
}

model ListStackGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListStackGroupsResponseBody(name='body'),
}

async function listStackGroups(request: ListStackGroupsRequest): ListStackGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListStackGroups', 'POST', '/', 'json', false, 'json', request);
}

model ListStackInstancesRequest {
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  stackGroupName: string(name='StackGroupName', position='Query'),
  stackInstanceAccountId?: string(name='StackInstanceAccountId', position='Query'),
  stackInstanceRegionId?: string(name='StackInstanceRegionId', position='Query'),
}

model ListStackInstancesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  stackInstances?: [ 
    {
      accountId?: string(name='AccountId'),
      driftDetectionTime?: string(name='DriftDetectionTime'),
      rdFolderId?: string(name='RdFolderId'),
      regionId?: string(name='RegionId'),
      stackDriftStatus?: string(name='StackDriftStatus'),
      stackGroupId?: string(name='StackGroupId'),
      stackGroupName?: string(name='StackGroupName'),
      stackId?: string(name='StackId'),
      status?: string(name='Status'),
      statusReason?: string(name='StatusReason'),
    }
  ](name='StackInstances'),
  totalCount?: int32(name='TotalCount'),
}

model ListStackInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListStackInstancesResponseBody(name='body'),
}

async function listStackInstances(request: ListStackInstancesRequest): ListStackInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListStackInstances', 'POST', '/', 'json', false, 'json', request);
}

model ListStackOperationRisksRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  operationType?: string(name='OperationType', position='Query'),
  ramRoleName?: string(name='RamRoleName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  retainAllResources?: boolean(name='RetainAllResources', position='Query'),
  retainResources?: [ string ](name='RetainResources', position='Query'),
  stackId?: string(name='StackId', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model ListStackOperationRisksResponseBody = {
  missingPolicyActions?: [ string ](name='MissingPolicyActions'),
  requestId?: string(name='RequestId'),
  riskResources?: [ 
    {
      code?: string(name='Code'),
      logicalResourceId?: string(name='LogicalResourceId'),
      message?: string(name='Message'),
      physicalResourceId?: string(name='PhysicalResourceId'),
      reason?: string(name='Reason'),
      requestId?: string(name='RequestId'),
      resourceType?: string(name='ResourceType'),
      riskType?: string(name='RiskType'),
    }
  ](name='RiskResources'),
}

model ListStackOperationRisksResponse = {
  headers: map[string]string(name='headers'),
  body: ListStackOperationRisksResponseBody(name='body'),
}

async function listStackOperationRisks(request: ListStackOperationRisksRequest): ListStackOperationRisksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListStackOperationRisks', 'POST', '/', 'json', false, 'json', request);
}

model ListStackResourceDriftsRequest {
  maxResults?: long(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceDriftStatus?: [ string ](name='ResourceDriftStatus', position='Query'),
  stackId: string(name='StackId', position='Query'),
}

model ListStackResourceDriftsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  resourceDrifts?: [ 
    {
      actualProperties?: string(name='ActualProperties'),
      driftDetectionTime?: string(name='DriftDetectionTime'),
      expectedProperties?: string(name='ExpectedProperties'),
      logicalResourceId?: string(name='LogicalResourceId'),
      physicalResourceId?: string(name='PhysicalResourceId'),
      propertyDifferences?: [ 
        {
          actualValue?: string(name='ActualValue'),
          differenceType?: string(name='DifferenceType'),
          expectedValue?: string(name='ExpectedValue'),
          propertyPath?: string(name='PropertyPath'),
        }
      ](name='PropertyDifferences'),
      resourceDriftStatus?: string(name='ResourceDriftStatus'),
      resourceType?: string(name='ResourceType'),
      stackId?: string(name='StackId'),
    }
  ](name='ResourceDrifts'),
}

model ListStackResourceDriftsResponse = {
  headers: map[string]string(name='headers'),
  body: ListStackResourceDriftsResponseBody(name='body'),
}

async function listStackResourceDrifts(request: ListStackResourceDriftsRequest): ListStackResourceDriftsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListStackResourceDrifts', 'POST', '/V2/ListStackResourceDrifts', 'json', false, 'json', request);
}

model ListStackResourcesRequest {
  regionId: string(name='RegionId', position='Query'),
  stackId: string(name='StackId', position='Query'),
}

model ListStackResourcesResponseBody = {
  requestId?: string(name='RequestId'),
  resources?: [ 
    {
      createTime?: string(name='CreateTime'),
      driftDetectionTime?: string(name='DriftDetectionTime'),
      logicalResourceId?: string(name='LogicalResourceId'),
      physicalResourceId?: string(name='PhysicalResourceId'),
      resourceDriftStatus?: string(name='ResourceDriftStatus'),
      resourceType?: string(name='ResourceType'),
      stackId?: string(name='StackId'),
      stackName?: string(name='StackName'),
      status?: string(name='Status'),
      statusReason?: string(name='StatusReason'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Resources'),
}

model ListStackResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListStackResourcesResponseBody(name='body'),
}

async function listStackResources(request: ListStackResourcesRequest): ListStackResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListStackResources', 'POST', '/', 'json', false, 'json', request);
}

model ListStacksRequest {
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  parentStackId?: string(name='ParentStackId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  showNestedStack?: boolean(name='ShowNestedStack', position='Query'),
  stackId?: string(name='StackId', position='Query'),
  stackIds?: [ string ](name='StackIds', position='Query'),
  stackName?: [ string ](name='StackName', position='Query'),
  status?: [ string ](name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListStacksResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  stacks?: [ 
    {
      createTime?: string(name='CreateTime'),
      disableRollback?: boolean(name='DisableRollback'),
      driftDetectionTime?: string(name='DriftDetectionTime'),
      operationInfo?: {
        action?: string(name='Action'),
        code?: string(name='Code'),
        logicalResourceId?: string(name='LogicalResourceId'),
        message?: string(name='Message'),
        requestId?: string(name='RequestId'),
        resourceType?: string(name='ResourceType'),
      }(name='OperationInfo'),
      parentStackId?: string(name='ParentStackId'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      serviceManaged?: boolean(name='ServiceManaged'),
      serviceName?: string(name='ServiceName'),
      stackDriftStatus?: string(name='StackDriftStatus'),
      stackId?: string(name='StackId'),
      stackName?: string(name='StackName'),
      stackType?: string(name='StackType'),
      status?: string(name='Status'),
      statusReason?: string(name='StatusReason'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      timeoutInMinutes?: int32(name='TimeoutInMinutes'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Stacks'),
  totalCount?: int32(name='TotalCount'),
}

model ListStacksResponse = {
  headers: map[string]string(name='headers'),
  body: ListStacksResponseBody(name='body'),
}

async function listStacks(request: ListStacksRequest): ListStacksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListStacks', 'POST', '/', 'json', false, 'json', request);
}

model ListTagKeysRequest {
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
}

model ListTagKeysResponseBody = {
  keys?: [ string ](name='Keys'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListTagKeysResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagKeysResponseBody(name='body'),
}

async function listTagKeys(request: ListTagKeysRequest): ListTagKeysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagKeys', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ListTagValuesRequest {
  key: string(name='Key', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
}

model ListTagValuesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  values?: [ string ](name='Values'),
}

model ListTagValuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagValuesResponseBody(name='body'),
}

async function listTagValues(request: ListTagValuesRequest): ListTagValuesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagValues', 'POST', '/', 'json', false, 'json', request);
}

model ListTemplateScratchesRequest {
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  status?: string(name='Status', position='Query'),
  tags?: [ 
    {
      key: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags', position='Query'),
  templateScratchId?: string(name='TemplateScratchId', position='Query'),
  templateScratchType?: string(name='TemplateScratchType', position='Query'),
}

model ListTemplateScratchesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  templateScratches?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      failedCode?: string(name='FailedCode'),
      logicalIdStrategy?: string(name='LogicalIdStrategy'),
      preferenceParameters?: [ 
        {
          parameterKey?: string(name='ParameterKey'),
          parameterValue?: string(name='ParameterValue'),
        }
      ](name='PreferenceParameters'),
      sourceResourceGroup?: {
        resourceGroupId?: string(name='ResourceGroupId'),
        resourceTypeFilter?: [ string ](name='ResourceTypeFilter'),
      }(name='SourceResourceGroup'),
      sourceResources?: [ 
        {
          resourceId?: string(name='ResourceId'),
          resourceType?: string(name='ResourceType'),
        }
      ](name='SourceResources'),
      sourceTag?: {
        resourceTags?: map[string]any(name='ResourceTags'),
        resourceTypeFilter?: [ string ](name='ResourceTypeFilter'),
      }(name='SourceTag'),
      status?: string(name='Status'),
      statusReason?: string(name='StatusReason'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      templateScratchId?: string(name='TemplateScratchId'),
      templateScratchType?: string(name='TemplateScratchType'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='TemplateScratches'),
  totalCount?: int32(name='TotalCount'),
}

model ListTemplateScratchesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTemplateScratchesResponseBody(name='body'),
}

async function listTemplateScratches(request: ListTemplateScratchesRequest): ListTemplateScratchesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTemplateScratches', 'POST', '/', 'json', false, 'json', request);
}

model ListTemplateVersionsRequest {
  maxResults?: long(name='MaxResults', minimum=1, maximum=10000, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  templateId: string(name='TemplateId', position='Query'),
}

model ListTemplateVersionsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  versions?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Versions'),
}

model ListTemplateVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListTemplateVersionsResponseBody(name='body'),
}

async function listTemplateVersions(request: ListTemplateVersionsRequest): ListTemplateVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTemplateVersions', 'POST', '/', 'json', false, 'json', request);
}

model ListTemplatesRequest {
  includeTags?: string(name='IncludeTags', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  shareType?: string(name='ShareType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  templateName?: string(name='TemplateName', position='Query'),
}

model ListTemplatesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  templates?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      ownerId?: string(name='OwnerId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      shareType?: string(name='ShareType'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      templateARN?: string(name='TemplateARN'),
      templateId?: string(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      templateVersion?: string(name='TemplateVersion'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Templates'),
  totalCount?: int32(name='TotalCount'),
}

model ListTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTemplatesResponseBody(name='body'),
}

async function listTemplates(request: ListTemplatesRequest): ListTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTemplates', 'POST', '/', 'json', false, 'json', request);
}

model MoveResourceGroupRequest {
  newResourceGroupId: string(name='NewResourceGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MoveResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model PreviewStackRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  disableRollback?: boolean(name='DisableRollback', position='Query'),
  enablePreConfig?: boolean(name='EnablePreConfig', position='Query'),
  parallelism?: long(name='Parallelism', position='Query'),
  parameters?: [ 
    {
      parameterKey: string(name='ParameterKey'),
      parameterValue: string(name='ParameterValue'),
    }
  ](name='Parameters', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  stackId?: string(name='StackId', position='Query'),
  stackName?: string(name='StackName', position='Query'),
  stackPolicyBody?: string(name='StackPolicyBody', position='Query'),
  stackPolicyURL?: string(name='StackPolicyURL', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  templateScratchId?: string(name='TemplateScratchId', position='Query'),
  templateScratchRegionId?: string(name='TemplateScratchRegionId', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
  timeoutInMinutes?: long(name='TimeoutInMinutes', position='Query'),
}

model PreviewStackResponseBody = {
  requestId?: string(name='RequestId'),
  stack?: {
    description?: string(name='Description'),
    disableRollback?: boolean(name='DisableRollback'),
    log?: {
      terraformLogs?: [ 
        {
          command?: string(name='Command'),
          content?: string(name='Content'),
          stream?: string(name='Stream'),
        }
      ](name='TerraformLogs'),
    }(name='Log'),
    parameters?: [ 
      {
        parameterKey?: string(name='ParameterKey'),
        parameterValue?: string(name='ParameterValue'),
      }
    ](name='Parameters'),
    regionId?: string(name='RegionId'),
    resources?: [ 
      {
        acsResourceType?: string(name='AcsResourceType'),
        action?: string(name='Action'),
        description?: string(name='Description'),
        logicalResourceId?: string(name='LogicalResourceId'),
        properties?: map[string]any(name='Properties'),
        replacement?: string(name='Replacement'),
        requiredBy?: [ string ](name='RequiredBy'),
        resourceType?: string(name='ResourceType'),
        stack?: map[string]any(name='Stack'),
      }
    ](name='Resources'),
    stackName?: string(name='StackName'),
    stackPolicyBody?: map[string]any(name='StackPolicyBody'),
    templateDescription?: string(name='TemplateDescription'),
    timeoutInMinutes?: int32(name='TimeoutInMinutes'),
  }(name='Stack'),
}

model PreviewStackResponse = {
  headers: map[string]string(name='headers'),
  body: PreviewStackResponseBody(name='body'),
}

async function previewStack(request: PreviewStackRequest): PreviewStackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PreviewStack', 'POST', '/', 'json', false, 'json', request);
}

model SetDeletionProtectionRequest {
  deletionProtection: string(name='DeletionProtection', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  stackId: string(name='StackId', position='Query'),
}

model SetDeletionProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  body: SetDeletionProtectionResponseBody(name='body'),
}

async function setDeletionProtection(request: SetDeletionProtectionRequest): SetDeletionProtectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDeletionProtection', 'POST', '/V2/SetDeletionProtection', 'json', false, 'json', request);
}

model SetStackPolicyRequest {
  regionId: string(name='RegionId', position='Query'),
  stackId: string(name='StackId', position='Query'),
  stackPolicyBody?: string(name='StackPolicyBody', position='Query'),
  stackPolicyURL?: string(name='StackPolicyURL', position='Query'),
}

model SetStackPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetStackPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: SetStackPolicyResponseBody(name='body'),
}

async function setStackPolicy(request: SetStackPolicyRequest): SetStackPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetStackPolicy', 'POST', '/V2/SetStackPolicy', 'json', false, 'json', request);
}

model SetTemplatePermissionRequest {
  accountIds: [ string ](name='AccountIds', position='Query'),
  shareOption: string(name='ShareOption', position='Query'),
  templateId: string(name='TemplateId', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
  versionOption?: string(name='VersionOption', position='Query'),
}

model SetTemplatePermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetTemplatePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: SetTemplatePermissionResponseBody(name='body'),
}

async function setTemplatePermission(request: SetTemplatePermissionRequest): SetTemplatePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetTemplatePermission', 'POST', '/V2/SetTemplatePermission', 'json', false, 'json', request);
}

model SignalResourceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  logicalResourceId: string(name='LogicalResourceId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  stackId: string(name='StackId', position='Query'),
  status: string(name='Status', position='Query'),
  uniqueId: string(name='UniqueId', position='Query'),
}

model SignalResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model SignalResourceResponse = {
  headers: map[string]string(name='headers'),
  body: SignalResourceResponseBody(name='body'),
}

async function signalResource(request: SignalResourceRequest): SignalResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SignalResource', 'POST', '/V2/SignalResource', 'json', false, 'json', request);
}

model StopStackGroupOperationRequest {
  operationId: string(name='OperationId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model StopStackGroupOperationResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopStackGroupOperationResponse = {
  headers: map[string]string(name='headers'),
  body: StopStackGroupOperationResponseBody(name='body'),
}

async function stopStackGroupOperation(request: StopStackGroupOperationRequest): StopStackGroupOperationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopStackGroupOperation', 'POST', '/V2/StopStackGroupOperation', 'json', false, 'json', request);
}

model TagResourcesRequest {
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag: [ 
    {
      key: string(name='Key'),
      value: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tagKey?: [ string ](name='TagKey', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpdateStackRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  disableRollback?: boolean(name='DisableRollback', position='Query'),
  parallelism?: long(name='Parallelism', position='Query'),
  parameters?: [ 
    {
      parameterKey: string(name='ParameterKey'),
      parameterValue: string(name='ParameterValue'),
    }
  ](name='Parameters', position='Query'),
  ramRoleName?: string(name='RamRoleName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  replacementOption?: string(name='ReplacementOption', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  stackId: string(name='StackId', position='Query'),
  stackPolicyBody?: string(name='StackPolicyBody', position='Query'),
  stackPolicyDuringUpdateBody?: string(name='StackPolicyDuringUpdateBody', position='Query'),
  stackPolicyDuringUpdateURL?: string(name='StackPolicyDuringUpdateURL', position='Query'),
  stackPolicyURL?: string(name='StackPolicyURL', position='Query'),
  tags?: [ 
    {
      key: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
  timeoutInMinutes?: long(name='TimeoutInMinutes', position='Query'),
  usePreviousParameters?: boolean(name='UsePreviousParameters', position='Query'),
}

model UpdateStackResponseBody = {
  requestId?: string(name='RequestId'),
  stackId?: string(name='StackId'),
}

model UpdateStackResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateStackResponseBody(name='body'),
}

async function updateStack(request: UpdateStackRequest): UpdateStackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateStack', 'POST', '/', 'json', false, 'json', request);
}

model UpdateStackGroupRequest {
  accountIds?: [ string ](name='AccountIds', shrink='json', position='Query'),
  administrationRoleName?: string(name='AdministrationRoleName', position='Query'),
  autoDeployment?: {
    enabled?: boolean(name='Enabled'),
    retainStacksOnAccountRemoval?: boolean(name='RetainStacksOnAccountRemoval'),
  }(name='AutoDeployment', shrink='json', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  deploymentTargets?: {
    accountIds?: [ string ](name='AccountIds'),
    rdFolderIds?: [ string ](name='RdFolderIds'),
  }(name='DeploymentTargets', shrink='json', position='Query'),
  description?: string(name='Description', position='Query'),
  executionRoleName?: string(name='ExecutionRoleName', position='Query'),
  operationDescription?: string(name='OperationDescription', position='Query'),
  operationPreferences?: map[string]any(name='OperationPreferences', shrink='json', position='Query'),
  parameters?: [ 
    {
      parameterKey: string(name='ParameterKey'),
      parameterValue: string(name='ParameterValue'),
    }
  ](name='Parameters', position='Query'),
  permissionModel?: string(name='PermissionModel', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  regionIds?: [ string ](name='RegionIds', shrink='json', position='Query'),
  stackGroupName: string(name='StackGroupName', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
  templateVersion?: string(name='TemplateVersion', position='Query'),
}

model UpdateStackGroupResponseBody = {
  operationId?: string(name='OperationId'),
  requestId?: string(name='RequestId'),
}

model UpdateStackGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateStackGroupResponseBody(name='body'),
}

async function updateStackGroup(request: UpdateStackGroupRequest): UpdateStackGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateStackGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateStackInstancesRequest {
  accountIds?: [ string ](name='AccountIds', shrink='json', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  deploymentTargets?: {
    accountIds?: [ string ](name='AccountIds'),
    rdFolderIds?: [ string ](name='RdFolderIds'),
  }(name='DeploymentTargets', shrink='json', position='Query'),
  operationDescription?: string(name='OperationDescription', position='Query'),
  operationPreferences?: map[string]any(name='OperationPreferences', shrink='json', position='Query'),
  parameterOverrides?: [ 
    {
      parameterKey: string(name='ParameterKey'),
      parameterValue: string(name='ParameterValue'),
    }
  ](name='ParameterOverrides', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  regionIds: [ string ](name='RegionIds', shrink='json', position='Query'),
  stackGroupName: string(name='StackGroupName', position='Query'),
  timeoutInMinutes?: long(name='TimeoutInMinutes', minimum=10, maximum=1440, position='Query'),
}

model UpdateStackInstancesResponseBody = {
  operationId?: string(name='OperationId'),
  requestId?: string(name='RequestId'),
}

model UpdateStackInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateStackInstancesResponseBody(name='body'),
}

async function updateStackInstances(request: UpdateStackInstancesRequest): UpdateStackInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateStackInstances', 'POST', '/', 'json', false, 'json', request);
}

model UpdateStackTemplateByResourcesRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  logicalResourceId?: [ string ](name='LogicalResourceId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  stackId: string(name='StackId', position='Query'),
  templateFormat?: string(name='TemplateFormat', position='Query'),
}

model UpdateStackTemplateByResourcesResponseBody = {
  newTemplateBody?: string(name='NewTemplateBody'),
  oldTemplateBody?: string(name='OldTemplateBody'),
  requestId?: string(name='RequestId'),
}

model UpdateStackTemplateByResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateStackTemplateByResourcesResponseBody(name='body'),
}

async function updateStackTemplateByResources(request: UpdateStackTemplateByResourcesRequest): UpdateStackTemplateByResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateStackTemplateByResources', 'POST', '/V2/UpdateStackTemplateByResources', 'json', false, 'json', request);
}

model UpdateTemplateRequest {
  description?: string(name='Description', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateId: string(name='TemplateId', position='Query'),
  templateName?: string(name='TemplateName', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
}

model UpdateTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model UpdateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTemplateResponseBody(name='body'),
}

async function updateTemplate(request: UpdateTemplateRequest): UpdateTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTemplate', 'POST', '/V2/UpdateTemplate', 'json', false, 'json', request);
}

model UpdateTemplateScratchRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  executionMode?: string(name='ExecutionMode', position='Query'),
  logicalIdStrategy?: string(name='LogicalIdStrategy', position='Query'),
  preferenceParameters?: [ 
    {
      parameterKey: string(name='ParameterKey'),
      parameterValue: string(name='ParameterValue'),
    }
  ](name='PreferenceParameters', shrink='json', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  sourceResourceGroup?: {
    resourceGroupId: string(name='ResourceGroupId'),
    resourceTypeFilter?: [ string ](name='ResourceTypeFilter'),
  }(name='SourceResourceGroup', shrink='json', position='Query'),
  sourceResources?: [ 
    {
      resourceId: string(name='ResourceId'),
      resourceType: string(name='ResourceType'),
    }
  ](name='SourceResources', shrink='json', position='Query'),
  sourceTag?: {
    resourceTags: map[string]any(name='ResourceTags'),
    resourceTypeFilter?: [ string ](name='ResourceTypeFilter'),
  }(name='SourceTag', shrink='json', position='Query'),
  templateScratchId: string(name='TemplateScratchId', position='Query'),
}

model UpdateTemplateScratchResponseBody = {
  requestId?: string(name='RequestId'),
  templateScratchId?: string(name='TemplateScratchId'),
}

model UpdateTemplateScratchResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTemplateScratchResponseBody(name='body'),
}

async function updateTemplateScratch(request: UpdateTemplateScratchRequest): UpdateTemplateScratchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateTemplateScratch', 'POST', '/', 'json', false, 'json', request);
}

model ValidateTemplateRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  templateBody?: string(name='TemplateBody', position='Query'),
  templateURL?: string(name='TemplateURL', position='Query'),
  validationOption?: string(name='ValidationOption', position='Query'),
}

model ValidateTemplateResponseBody = {
  description?: string(name='Description'),
  outputs?: [ 
    {
      description?: string(name='Description'),
      label?: string(name='Label'),
      outputKey?: string(name='OutputKey'),
    }
  ](name='Outputs'),
  parameters?: [  map[string]any ](name='Parameters'),
  requestId?: string(name='RequestId'),
  resourceTypes?: {
    dataSources?: [ string ](name='DataSources'),
    resources?: [ string ](name='Resources'),
  }(name='ResourceTypes'),
  resources?: [ 
    {
      logicalResourceIdPattern?: string(name='LogicalResourceIdPattern'),
      resourcePath?: string(name='ResourcePath'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resources'),
}

model ValidateTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateTemplateResponseBody(name='body'),
}

async function validateTemplate(request: ValidateTemplateRequest): ValidateTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ValidateTemplate', 'POST', '/', 'json', false, 'json', request);
}

