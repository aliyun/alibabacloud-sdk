/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-hangzhou = 'lyj.cn-hangzhou.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('tdsr', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddHotspotFileRequest {
  fileName?: string(name='FileName'),
  sceneId?: string(name='SceneId'),
  type?: string(name='Type'),
}

model AddHotspotFileResponseBody = {
  code?: long(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddHotspotFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddHotspotFileResponseBody(name='body'),
}

async function addHotspotFileWithOptions(request: AddHotspotFileRequest, runtime: Util.RuntimeOptions): AddHotspotFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddHotspotFile',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addHotspotFile(request: AddHotspotFileRequest): AddHotspotFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return addHotspotFileWithOptions(request, runtime);
}

model AddMosaicsRequest {
  markPosition?: string(name='MarkPosition'),
  subSceneId?: string(name='SubSceneId'),
}

model AddMosaicsResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model AddMosaicsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddMosaicsResponseBody(name='body'),
}

async function addMosaicsWithOptions(request: AddMosaicsRequest, runtime: Util.RuntimeOptions): AddMosaicsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.markPosition)) {
    query['MarkPosition'] = request.markPosition;
  }
  if (!Util.isUnset(request.subSceneId)) {
    query['SubSceneId'] = request.subSceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddMosaics',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addMosaics(request: AddMosaicsRequest): AddMosaicsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMosaicsWithOptions(request, runtime);
}

model AddProjectRequest {
  businessId?: long(name='BusinessId'),
  name?: string(name='Name'),
}

model AddProjectResponseBody = {
  code?: long(name='Code'),
  id?: string(name='Id'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddProjectResponseBody(name='body'),
}

async function addProjectWithOptions(request: AddProjectRequest, runtime: Util.RuntimeOptions): AddProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessId)) {
    query['BusinessId'] = request.businessId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddProject',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addProject(request: AddProjectRequest): AddProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return addProjectWithOptions(request, runtime);
}

model AddRelativePositionRequest {
  relativePosition?: string(name='RelativePosition'),
  sceneId?: string(name='SceneId'),
}

model AddRelativePositionResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddRelativePositionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddRelativePositionResponseBody(name='body'),
}

async function addRelativePositionWithOptions(request: AddRelativePositionRequest, runtime: Util.RuntimeOptions): AddRelativePositionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.relativePosition)) {
    query['RelativePosition'] = request.relativePosition;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddRelativePosition',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addRelativePosition(request: AddRelativePositionRequest): AddRelativePositionResponse {
  var runtime = new Util.RuntimeOptions{};
  return addRelativePositionWithOptions(request, runtime);
}

model AddRoomPlanRequest {
  sceneId?: string(name='SceneId'),
}

model AddRoomPlanResponseBody = {
  code?: long(name='Code'),
  data?: {
    accessId?: string(name='AccessId'),
    callback?: string(name='Callback'),
    dir?: string(name='Dir'),
    expire?: string(name='Expire'),
    host?: string(name='Host'),
    policy?: string(name='Policy'),
    signature?: string(name='Signature'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddRoomPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddRoomPlanResponseBody(name='body'),
}

async function addRoomPlanWithOptions(request: AddRoomPlanRequest, runtime: Util.RuntimeOptions): AddRoomPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddRoomPlan',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addRoomPlan(request: AddRoomPlanRequest): AddRoomPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return addRoomPlanWithOptions(request, runtime);
}

model AddSceneRequest {
  customerUid?: string(name='CustomerUid'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
  type?: string(name='Type'),
}

model AddSceneResponseBody = {
  code?: long(name='Code'),
  id?: string(name='Id'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddSceneResponseBody(name='body'),
}

async function addSceneWithOptions(request: AddSceneRequest, runtime: Util.RuntimeOptions): AddSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customerUid)) {
    query['CustomerUid'] = request.customerUid;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddScene',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addScene(request: AddSceneRequest): AddSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSceneWithOptions(request, runtime);
}

model AddSubSceneRequest {
  name?: string(name='Name'),
  sceneId?: string(name='SceneId'),
  uploadType?: string(name='UploadType'),
}

model AddSubSceneResponseBody = {
  code?: long(name='Code'),
  id?: string(name='Id'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddSubSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddSubSceneResponseBody(name='body'),
}

async function addSubSceneWithOptions(request: AddSubSceneRequest, runtime: Util.RuntimeOptions): AddSubSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  if (!Util.isUnset(request.uploadType)) {
    query['UploadType'] = request.uploadType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddSubScene',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addSubScene(request: AddSubSceneRequest): AddSubSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSubSceneWithOptions(request, runtime);
}

model CheckUserPropertyRequest {
  uid?: string(name='Uid'),
}

model CheckUserPropertyResponseBody = {
  code?: long(name='Code'),
  match?: boolean(name='Match'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckUserPropertyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckUserPropertyResponseBody(name='body'),
}

async function checkUserPropertyWithOptions(request: CheckUserPropertyRequest, runtime: Util.RuntimeOptions): CheckUserPropertyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckUserProperty',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkUserProperty(request: CheckUserPropertyRequest): CheckUserPropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkUserPropertyWithOptions(request, runtime);
}

model CopySceneRequest {
  projectId?: string(name='ProjectId'),
  sceneId?: string(name='SceneId'),
  sceneName?: string(name='SceneName'),
}

model CopySceneResponseBody = {
  code?: long(name='Code'),
  data?: {
    taskId?: string(name='TaskId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CopySceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopySceneResponseBody(name='body'),
}

async function copySceneWithOptions(request: CopySceneRequest, runtime: Util.RuntimeOptions): CopySceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  if (!Util.isUnset(request.sceneName)) {
    query['SceneName'] = request.sceneName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CopyScene',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function copyScene(request: CopySceneRequest): CopySceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return copySceneWithOptions(request, runtime);
}

model CreateUploadPolicyRequest {
  option?: string(name='Option'),
  type?: string(name='Type'),
}

model CreateUploadPolicyResponseBody = {
  code?: long(name='Code'),
  data?: {
    accessId?: string(name='AccessId'),
    callback?: string(name='Callback'),
    dir?: string(name='Dir'),
    expire?: string(name='Expire'),
    host?: string(name='Host'),
    policy?: string(name='Policy'),
    signature?: string(name='Signature'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateUploadPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUploadPolicyResponseBody(name='body'),
}

async function createUploadPolicyWithOptions(request: CreateUploadPolicyRequest, runtime: Util.RuntimeOptions): CreateUploadPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.option)) {
    query['Option'] = request.option;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUploadPolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUploadPolicy(request: CreateUploadPolicyRequest): CreateUploadPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUploadPolicyWithOptions(request, runtime);
}

model DecryptContentRequest {
  content?: string(name='Content'),
}

model DecryptContentResponseBody = {
  code?: long(name='Code'),
  content?: string(name='Content'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DecryptContentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DecryptContentResponseBody(name='body'),
}

async function decryptContentWithOptions(request: DecryptContentRequest, runtime: Util.RuntimeOptions): DecryptContentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DecryptContent',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function decryptContent(request: DecryptContentRequest): DecryptContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return decryptContentWithOptions(request, runtime);
}

model DetailProjectRequest {
  id?: string(name='Id'),
}

model DetailProjectResponseBody = {
  businessId?: long(name='BusinessId'),
  businessName?: string(name='BusinessName'),
  code?: long(name='Code'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  id?: string(name='Id'),
  message?: string(name='Message'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  token?: string(name='Token'),
}

model DetailProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetailProjectResponseBody(name='body'),
}

async function detailProjectWithOptions(request: DetailProjectRequest, runtime: Util.RuntimeOptions): DetailProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetailProject',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detailProject(request: DetailProjectRequest): DetailProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return detailProjectWithOptions(request, runtime);
}

model DetailSceneRequest {
  id?: string(name='Id'),
}

model DetailSceneResponseBody = {
  captures?: [ 
    {
      title?: string(name='Title'),
      url?: string(name='Url'),
    }
  ](name='Captures'),
  code?: long(name='Code'),
  coverUrl?: string(name='CoverUrl'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  id?: string(name='Id'),
  message?: string(name='Message'),
  name?: string(name='Name'),
  previewToken?: string(name='PreviewToken'),
  published?: boolean(name='Published'),
  requestId?: string(name='RequestId'),
  sourceNum?: long(name='SourceNum'),
  status?: string(name='Status'),
  statusName?: string(name='StatusName'),
  subSceneNum?: long(name='SubSceneNum'),
  success?: boolean(name='Success'),
  type?: string(name='Type'),
}

model DetailSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetailSceneResponseBody(name='body'),
}

async function detailSceneWithOptions(request: DetailSceneRequest, runtime: Util.RuntimeOptions): DetailSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetailScene',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detailScene(request: DetailSceneRequest): DetailSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return detailSceneWithOptions(request, runtime);
}

model DetailSubSceneRequest {
  id?: string(name='Id'),
}

model DetailSubSceneResponseBody = {
  code?: long(name='Code'),
  coverUrl?: string(name='CoverUrl'),
  cubemapPath?: string(name='CubemapPath'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  id?: string(name='Id'),
  imageUrl?: string(name='ImageUrl'),
  layoutData?: string(name='LayoutData'),
  message?: string(name='Message'),
  name?: string(name='Name'),
  originUrl?: string(name='OriginUrl'),
  position?: string(name='Position'),
  requestId?: string(name='RequestId'),
  resourceId?: string(name='ResourceId'),
  status?: long(name='Status'),
  success?: boolean(name='Success'),
  type?: string(name='Type'),
  url?: string(name='Url'),
}

model DetailSubSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetailSubSceneResponseBody(name='body'),
}

async function detailSubSceneWithOptions(request: DetailSubSceneRequest, runtime: Util.RuntimeOptions): DetailSubSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetailSubScene',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detailSubScene(request: DetailSubSceneRequest): DetailSubSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return detailSubSceneWithOptions(request, runtime);
}

model DropProjectRequest {
  projectId?: string(name='ProjectId'),
}

model DropProjectResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DropProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DropProjectResponseBody(name='body'),
}

async function dropProjectWithOptions(request: DropProjectRequest, runtime: Util.RuntimeOptions): DropProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DropProject',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dropProject(request: DropProjectRequest): DropProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return dropProjectWithOptions(request, runtime);
}

model DropSceneRequest {
  id?: string(name='Id'),
}

model DropSceneResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DropSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DropSceneResponseBody(name='body'),
}

async function dropSceneWithOptions(request: DropSceneRequest, runtime: Util.RuntimeOptions): DropSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DropScene',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dropScene(request: DropSceneRequest): DropSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return dropSceneWithOptions(request, runtime);
}

model DropSubSceneRequest {
  id?: string(name='Id'),
}

model DropSubSceneResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DropSubSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DropSubSceneResponseBody(name='body'),
}

async function dropSubSceneWithOptions(request: DropSubSceneRequest, runtime: Util.RuntimeOptions): DropSubSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DropSubScene',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dropSubScene(request: DropSubSceneRequest): DropSubSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return dropSubSceneWithOptions(request, runtime);
}

model EncryptContentRequest {
  content?: string(name='Content'),
}

model EncryptContentResponseBody = {
  code?: long(name='Code'),
  content?: string(name='Content'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EncryptContentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EncryptContentResponseBody(name='body'),
}

async function encryptContentWithOptions(request: EncryptContentRequest, runtime: Util.RuntimeOptions): EncryptContentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EncryptContent',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function encryptContent(request: EncryptContentRequest): EncryptContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return encryptContentWithOptions(request, runtime);
}

model GetConnDataRequest {
  sceneId?: string(name='SceneId'),
}

model GetConnDataResponseBody = {
  code?: long(name='Code'),
  extend?: string(name='Extend'),
  list?: [ 
    {
      id?: string(name='Id'),
      mapId?: string(name='MapId'),
      type?: string(name='Type'),
    }
  ](name='List'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  version?: string(name='Version'),
}

model GetConnDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConnDataResponseBody(name='body'),
}

async function getConnDataWithOptions(request: GetConnDataRequest, runtime: Util.RuntimeOptions): GetConnDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConnData',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConnData(request: GetConnDataRequest): GetConnDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConnDataWithOptions(request, runtime);
}

model GetCopySceneTaskStatusRequest {
  taskId?: string(name='TaskId'),
}

model GetCopySceneTaskStatusResponseBody = {
  code?: long(name='Code'),
  data?: {
    progress?: long(name='Progress'),
    status?: string(name='Status'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetCopySceneTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCopySceneTaskStatusResponseBody(name='body'),
}

async function getCopySceneTaskStatusWithOptions(request: GetCopySceneTaskStatusRequest, runtime: Util.RuntimeOptions): GetCopySceneTaskStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCopySceneTaskStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCopySceneTaskStatus(request: GetCopySceneTaskStatusRequest): GetCopySceneTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCopySceneTaskStatusWithOptions(request, runtime);
}

model GetHotspotConfigRequest {
  domain?: string(name='Domain'),
  enabled?: boolean(name='Enabled'),
  previewToken?: string(name='PreviewToken'),
  type?: long(name='Type'),
}

model GetHotspotConfigResponseBody = {
  code?: long(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetHotspotConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetHotspotConfigResponseBody(name='body'),
}

async function getHotspotConfigWithOptions(request: GetHotspotConfigRequest, runtime: Util.RuntimeOptions): GetHotspotConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.previewToken)) {
    query['PreviewToken'] = request.previewToken;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHotspotConfig',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHotspotConfig(request: GetHotspotConfigRequest): GetHotspotConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHotspotConfigWithOptions(request, runtime);
}

model GetHotspotSceneDataRequest {
  domain?: string(name='Domain'),
  enabled?: boolean(name='Enabled'),
  previewToken?: string(name='PreviewToken'),
  type?: long(name='Type'),
}

model GetHotspotSceneDataResponseBody = {
  code?: long(name='Code'),
  data?: {
    modelToken?: string(name='ModelToken'),
    previewData?: string(name='PreviewData'),
    previewToken?: string(name='PreviewToken'),
    sceneType?: string(name='SceneType'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetHotspotSceneDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetHotspotSceneDataResponseBody(name='body'),
}

async function getHotspotSceneDataWithOptions(request: GetHotspotSceneDataRequest, runtime: Util.RuntimeOptions): GetHotspotSceneDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.previewToken)) {
    query['PreviewToken'] = request.previewToken;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHotspotSceneData',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHotspotSceneData(request: GetHotspotSceneDataRequest): GetHotspotSceneDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHotspotSceneDataWithOptions(request, runtime);
}

model GetHotspotTagRequest {
  domain?: string(name='Domain'),
  enabled?: boolean(name='Enabled'),
  previewToken?: string(name='PreviewToken'),
  subSceneUuid?: string(name='SubSceneUuid'),
  type?: string(name='Type'),
}

model GetHotspotTagResponseBody = {
  data?: string(name='Data'),
  errMessage?: string(name='ErrMessage'),
  objectString?: string(name='ObjectString'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetHotspotTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetHotspotTagResponseBody(name='body'),
}

async function getHotspotTagWithOptions(request: GetHotspotTagRequest, runtime: Util.RuntimeOptions): GetHotspotTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.previewToken)) {
    query['PreviewToken'] = request.previewToken;
  }
  if (!Util.isUnset(request.subSceneUuid)) {
    query['SubSceneUuid'] = request.subSceneUuid;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHotspotTag',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHotspotTag(request: GetHotspotTagRequest): GetHotspotTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHotspotTagWithOptions(request, runtime);
}

model GetLayoutDataRequest {
  subSceneId?: string(name='SubSceneId'),
}

model GetLayoutDataResponseBody = {
  code?: long(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetLayoutDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLayoutDataResponseBody(name='body'),
}

async function getLayoutDataWithOptions(request: GetLayoutDataRequest, runtime: Util.RuntimeOptions): GetLayoutDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.subSceneId)) {
    query['SubSceneId'] = request.subSceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLayoutData',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLayoutData(request: GetLayoutDataRequest): GetLayoutDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLayoutDataWithOptions(request, runtime);
}

model GetOriginLayoutDataRequest {
  subSceneId?: string(name='SubSceneId'),
}

model GetOriginLayoutDataResponseBody = {
  code?: long(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetOriginLayoutDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOriginLayoutDataResponseBody(name='body'),
}

async function getOriginLayoutDataWithOptions(request: GetOriginLayoutDataRequest, runtime: Util.RuntimeOptions): GetOriginLayoutDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.subSceneId)) {
    query['SubSceneId'] = request.subSceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOriginLayoutData',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOriginLayoutData(request: GetOriginLayoutDataRequest): GetOriginLayoutDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOriginLayoutDataWithOptions(request, runtime);
}

model GetOssPolicyRequest {
  subSceneId?: string(name='SubSceneId'),
}

model GetOssPolicyResponseBody = {
  accessId?: string(name='AccessId'),
  callback?: string(name='Callback'),
  code?: long(name='Code'),
  dir?: string(name='Dir'),
  expire?: string(name='Expire'),
  host?: string(name='Host'),
  message?: string(name='Message'),
  policy?: string(name='Policy'),
  requestId?: string(name='RequestId'),
  signature?: string(name='Signature'),
  success?: boolean(name='Success'),
}

model GetOssPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOssPolicyResponseBody(name='body'),
}

async function getOssPolicyWithOptions(request: GetOssPolicyRequest, runtime: Util.RuntimeOptions): GetOssPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.subSceneId)) {
    query['SubSceneId'] = request.subSceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOssPolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOssPolicy(request: GetOssPolicyRequest): GetOssPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOssPolicyWithOptions(request, runtime);
}

model GetPackSceneTaskStatusRequest {
  taskId?: string(name='TaskId'),
  type?: string(name='Type'),
}

model GetPackSceneTaskStatusResponseBody = {
  code?: long(name='Code'),
  data?: {
    progress?: long(name='Progress'),
    status?: string(name='Status'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPackSceneTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPackSceneTaskStatusResponseBody(name='body'),
}

async function getPackSceneTaskStatusWithOptions(request: GetPackSceneTaskStatusRequest, runtime: Util.RuntimeOptions): GetPackSceneTaskStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPackSceneTaskStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPackSceneTaskStatus(request: GetPackSceneTaskStatusRequest): GetPackSceneTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPackSceneTaskStatusWithOptions(request, runtime);
}

model GetRectifyImageRequest {
  subSceneId?: string(name='SubSceneId'),
}

model GetRectifyImageResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  url?: string(name='Url'),
}

model GetRectifyImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRectifyImageResponseBody(name='body'),
}

async function getRectifyImageWithOptions(request: GetRectifyImageRequest, runtime: Util.RuntimeOptions): GetRectifyImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.subSceneId)) {
    query['SubSceneId'] = request.subSceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRectifyImage',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRectifyImage(request: GetRectifyImageRequest): GetRectifyImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRectifyImageWithOptions(request, runtime);
}

model GetSceneBuildTaskStatusRequest {
  sceneId?: string(name='SceneId'),
}

model GetSceneBuildTaskStatusResponseBody = {
  code?: long(name='Code'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  sceneId?: string(name='SceneId'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
}

model GetSceneBuildTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSceneBuildTaskStatusResponseBody(name='body'),
}

async function getSceneBuildTaskStatusWithOptions(request: GetSceneBuildTaskStatusRequest, runtime: Util.RuntimeOptions): GetSceneBuildTaskStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSceneBuildTaskStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSceneBuildTaskStatus(request: GetSceneBuildTaskStatusRequest): GetSceneBuildTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSceneBuildTaskStatusWithOptions(request, runtime);
}

model GetScenePackUrlRequest {
  sceneId?: string(name='SceneId'),
}

model GetScenePackUrlResponseBody = {
  code?: long(name='Code'),
  data?: {
    expire?: string(name='Expire'),
    url?: string(name='Url'),
    valid?: boolean(name='Valid'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetScenePackUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetScenePackUrlResponseBody(name='body'),
}

async function getScenePackUrlWithOptions(request: GetScenePackUrlRequest, runtime: Util.RuntimeOptions): GetScenePackUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetScenePackUrl',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getScenePackUrl(request: GetScenePackUrlRequest): GetScenePackUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getScenePackUrlWithOptions(request, runtime);
}

model GetScenePreviewDataRequest {
  domain?: string(name='Domain'),
  enabled?: boolean(name='Enabled'),
  previewToken?: string(name='PreviewToken'),
  showTag?: boolean(name='ShowTag'),
}

model GetScenePreviewDataResponseBody = {
  code?: long(name='Code'),
  data?: {
    model?: {
      modelPath?: string(name='ModelPath'),
      panoList?: [ 
        {
          curRoomPicList?: [ string ](name='CurRoomPicList'),
          enabled?: boolean(name='Enabled'),
          floorIdx?: string(name='FloorIdx'),
          id?: string(name='Id'),
          mainImage?: boolean(name='MainImage'),
          neighbours?: [ string ](name='Neighbours'),
          position?: {
            rotation?: [ double ](name='Rotation'),
            spot?: [ double ](name='Spot'),
            viewpoint?: [ double ](name='Viewpoint'),
          }(name='Position'),
          rawName?: string(name='RawName'),
          resource?: string(name='Resource'),
          roomIdx?: string(name='RoomIdx'),
          subSceneId?: string(name='SubSceneId'),
          token?: string(name='Token'),
          virtualId?: string(name='VirtualId'),
          virtualName?: string(name='VirtualName'),
        }
      ](name='PanoList'),
      textureModelPath?: string(name='TextureModelPath'),
      texturePanoPath?: string(name='TexturePanoPath'),
    }(name='Model'),
    tags?: [ 
      {
        config?: {
          backgroundColor?: string(name='BackgroundColor'),
          buttonConfig?: {
            customText?: string(name='CustomText'),
            type?: string(name='Type'),
          }(name='ButtonConfig'),
          content?: string(name='Content'),
          formImgSize?: [ long ](name='FormImgSize'),
          formJumpType?: boolean(name='FormJumpType'),
          formSelectImgType?: string(name='FormSelectImgType'),
          images?: [ string ](name='Images'),
          isTagVisibleBy3d?: boolean(name='IsTagVisibleBy3d'),
          link?: string(name='Link'),
          panoId?: string(name='PanoId'),
          position?: [ double ](name='Position'),
          positionPanoCube?: [ double ](name='PositionPanoCube'),
          relatedPanoIds?: [ string ](name='RelatedPanoIds'),
          sceneId?: long(name='SceneId'),
          title?: string(name='Title'),
          video?: string(name='Video'),
        }(name='Config'),
        id?: string(name='Id'),
        position?: [ double ](name='Position'),
        positionPanoCube?: [ double ](name='PositionPanoCube'),
        type?: string(name='Type'),
      }
    ](name='Tags'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetScenePreviewDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetScenePreviewDataResponseBody(name='body'),
}

async function getScenePreviewDataWithOptions(request: GetScenePreviewDataRequest, runtime: Util.RuntimeOptions): GetScenePreviewDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.previewToken)) {
    query['PreviewToken'] = request.previewToken;
  }
  if (!Util.isUnset(request.showTag)) {
    query['ShowTag'] = request.showTag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetScenePreviewData',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getScenePreviewData(request: GetScenePreviewDataRequest): GetScenePreviewDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getScenePreviewDataWithOptions(request, runtime);
}

model GetScenePreviewInfoRequest {
  domain?: string(name='Domain'),
  enabled?: boolean(name='Enabled'),
  modelToken?: string(name='ModelToken'),
}

model GetScenePreviewInfoResponseBody = {
  code?: long(name='Code'),
  data?: {
    modelPath?: string(name='ModelPath'),
    panoList?: string(name='PanoList'),
    textureModelPath?: string(name='TextureModelPath'),
    texturePanoPath?: string(name='TexturePanoPath'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetScenePreviewInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetScenePreviewInfoResponseBody(name='body'),
}

async function getScenePreviewInfoWithOptions(request: GetScenePreviewInfoRequest, runtime: Util.RuntimeOptions): GetScenePreviewInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.modelToken)) {
    query['ModelToken'] = request.modelToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetScenePreviewInfo',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getScenePreviewInfo(request: GetScenePreviewInfoRequest): GetScenePreviewInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getScenePreviewInfoWithOptions(request, runtime);
}

model GetScenePreviewResourceRequest {
  draft?: boolean(name='Draft'),
  previewToken?: string(name='PreviewToken'),
}

model GetScenePreviewResourceResponseBody = {
  code?: long(name='Code'),
  data?: {
    name?: string(name='Name'),
    resourceDirectory?: {
      hotspotTagConfig?: string(name='HotspotTagConfig'),
      modelConfig?: string(name='ModelConfig'),
      orthomapConfig?: string(name='OrthomapConfig'),
      rootPath?: string(name='RootPath'),
    }(name='ResourceDirectory'),
    version?: string(name='Version'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetScenePreviewResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetScenePreviewResourceResponseBody(name='body'),
}

async function getScenePreviewResourceWithOptions(request: GetScenePreviewResourceRequest, runtime: Util.RuntimeOptions): GetScenePreviewResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.draft)) {
    query['Draft'] = request.draft;
  }
  if (!Util.isUnset(request.previewToken)) {
    query['PreviewToken'] = request.previewToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetScenePreviewResource',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getScenePreviewResource(request: GetScenePreviewResourceRequest): GetScenePreviewResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getScenePreviewResourceWithOptions(request, runtime);
}

model GetSingleConnDataRequest {
  subSceneId?: string(name='SubSceneId'),
}

model GetSingleConnDataResponseBody = {
  code?: long(name='Code'),
  list?: [ 
    {
      id?: string(name='Id'),
      mapId?: string(name='MapId'),
      type?: string(name='Type'),
    }
  ](name='List'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  version?: string(name='Version'),
}

model GetSingleConnDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSingleConnDataResponseBody(name='body'),
}

async function getSingleConnDataWithOptions(request: GetSingleConnDataRequest, runtime: Util.RuntimeOptions): GetSingleConnDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.subSceneId)) {
    query['SubSceneId'] = request.subSceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSingleConnData',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSingleConnData(request: GetSingleConnDataRequest): GetSingleConnDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSingleConnDataWithOptions(request, runtime);
}

model GetSourcePackStatusRequest {
  taskId?: string(name='TaskId'),
}

model GetSourcePackStatusResponseBody = {
  code?: long(name='Code'),
  data?: {
    progress?: long(name='Progress'),
    status?: string(name='Status'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  url?: string(name='Url'),
}

model GetSourcePackStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSourcePackStatusResponseBody(name='body'),
}

async function getSourcePackStatusWithOptions(request: GetSourcePackStatusRequest, runtime: Util.RuntimeOptions): GetSourcePackStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSourcePackStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSourcePackStatus(request: GetSourcePackStatusRequest): GetSourcePackStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSourcePackStatusWithOptions(request, runtime);
}

model GetSubSceneTaskStatusRequest {
  subSceneId?: string(name='SubSceneId'),
}

model GetSubSceneTaskStatusResponseBody = {
  code?: long(name='Code'),
  list?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      errorMsg?: string(name='ErrorMsg'),
      id?: string(name='Id'),
      sceneId?: string(name='SceneId'),
      status?: string(name='Status'),
      subSceneId?: string(name='SubSceneId'),
      type?: string(name='Type'),
    }
  ](name='List'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSubSceneTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSubSceneTaskStatusResponseBody(name='body'),
}

async function getSubSceneTaskStatusWithOptions(request: GetSubSceneTaskStatusRequest, runtime: Util.RuntimeOptions): GetSubSceneTaskStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.subSceneId)) {
    query['SubSceneId'] = request.subSceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSubSceneTaskStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSubSceneTaskStatus(request: GetSubSceneTaskStatusRequest): GetSubSceneTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSubSceneTaskStatusWithOptions(request, runtime);
}

model GetTaskStatusRequest {
  taskId?: string(name='TaskId'),
}

model GetTaskStatusResponseBody = {
  code?: long(name='Code'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
  type?: string(name='Type'),
}

model GetTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskStatusResponseBody(name='body'),
}

async function getTaskStatusWithOptions(request: GetTaskStatusRequest, runtime: Util.RuntimeOptions): GetTaskStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTaskStatus(request: GetTaskStatusRequest): GetTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskStatusWithOptions(request, runtime);
}

model GetWindowConfigRequest {
  previewToken?: string(name='PreviewToken'),
}

model GetWindowConfigResponseBody = {
  data?: map[string]any(name='Data'),
  errMessage?: string(name='ErrMessage'),
  objectString?: string(name='ObjectString'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetWindowConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWindowConfigResponseBody(name='body'),
}

async function getWindowConfigWithOptions(request: GetWindowConfigRequest, runtime: Util.RuntimeOptions): GetWindowConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.previewToken)) {
    query['PreviewToken'] = request.previewToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWindowConfig',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWindowConfig(request: GetWindowConfigRequest): GetWindowConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWindowConfigWithOptions(request, runtime);
}

model LabelBuildRequest {
  mode?: string(name='Mode'),
  modelStyle?: string(name='ModelStyle'),
  optimizeWallWidth?: string(name='OptimizeWallWidth'),
  planStyle?: string(name='PlanStyle'),
  sceneId?: string(name='SceneId'),
  wallHeight?: long(name='WallHeight'),
}

model LabelBuildResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model LabelBuildResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LabelBuildResponseBody(name='body'),
}

async function labelBuildWithOptions(request: LabelBuildRequest, runtime: Util.RuntimeOptions): LabelBuildResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.modelStyle)) {
    query['ModelStyle'] = request.modelStyle;
  }
  if (!Util.isUnset(request.optimizeWallWidth)) {
    query['OptimizeWallWidth'] = request.optimizeWallWidth;
  }
  if (!Util.isUnset(request.planStyle)) {
    query['PlanStyle'] = request.planStyle;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  if (!Util.isUnset(request.wallHeight)) {
    query['WallHeight'] = request.wallHeight;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'LabelBuild',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function labelBuild(request: LabelBuildRequest): LabelBuildResponse {
  var runtime = new Util.RuntimeOptions{};
  return labelBuildWithOptions(request, runtime);
}

model LinkImageRequest {
  cameraHeight?: int32(name='CameraHeight'),
  fileName?: string(name='FileName'),
  platform?: string(name='Platform'),
  subSceneId?: string(name='SubSceneId'),
}

model LinkImageResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resourceId?: string(name='ResourceId'),
  success?: boolean(name='Success'),
}

model LinkImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LinkImageResponseBody(name='body'),
}

async function linkImageWithOptions(request: LinkImageRequest, runtime: Util.RuntimeOptions): LinkImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cameraHeight)) {
    query['CameraHeight'] = request.cameraHeight;
  }
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.subSceneId)) {
    query['SubSceneId'] = request.subSceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'LinkImage',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function linkImage(request: LinkImageRequest): LinkImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return linkImageWithOptions(request, runtime);
}

model ListProjectRequest {
  name?: string(name='Name'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
}

model ListProjectResponseBody = {
  code?: long(name='Code'),
  count?: long(name='Count'),
  currentPage?: long(name='CurrentPage'),
  hasNext?: boolean(name='HasNext'),
  list?: [ 
    {
      businessId?: long(name='BusinessId'),
      businessName?: string(name='BusinessName'),
      createTime?: long(name='CreateTime'),
      id?: string(name='Id'),
      modifiedTime?: long(name='ModifiedTime'),
      name?: string(name='Name'),
      token?: string(name='Token'),
    }
  ](name='List'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalPage?: long(name='TotalPage'),
}

model ListProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProjectResponseBody(name='body'),
}

async function listProjectWithOptions(request: ListProjectRequest, runtime: Util.RuntimeOptions): ListProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProject',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProject(request: ListProjectRequest): ListProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectWithOptions(request, runtime);
}

model ListSceneRequest {
  name?: string(name='Name'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model ListSceneResponseBody = {
  code?: long(name='Code'),
  count?: long(name='Count'),
  currentPage?: long(name='CurrentPage'),
  hasNext?: boolean(name='HasNext'),
  list?: [ 
    {
      coverUrl?: string(name='CoverUrl'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      previewToken?: string(name='PreviewToken'),
      published?: boolean(name='Published'),
      sourceNum?: long(name='SourceNum'),
      status?: string(name='Status'),
      statusName?: string(name='StatusName'),
      subSceneNum?: long(name='SubSceneNum'),
      type?: string(name='Type'),
    }
  ](name='List'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalPage?: long(name='TotalPage'),
}

model ListSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSceneResponseBody(name='body'),
}

async function listSceneWithOptions(request: ListSceneRequest, runtime: Util.RuntimeOptions): ListSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListScene',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listScene(request: ListSceneRequest): ListSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSceneWithOptions(request, runtime);
}

model ListSubSceneRequest {
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
  sceneId?: string(name='SceneId'),
  showLayoutData?: boolean(name='ShowLayoutData'),
  sortField?: string(name='SortField'),
}

model ListSubSceneResponseBody = {
  code?: long(name='Code'),
  count?: long(name='Count'),
  currentPage?: long(name='CurrentPage'),
  hasNext?: boolean(name='HasNext'),
  list?: [ 
    {
      baseImageUrl?: string(name='BaseImageUrl'),
      coverUrl?: string(name='CoverUrl'),
      cubemapPath?: string(name='CubemapPath'),
      deleted?: boolean(name='Deleted'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      id?: string(name='Id'),
      layoutData?: string(name='LayoutData'),
      name?: string(name='Name'),
      originUrl?: string(name='OriginUrl'),
      resourceId?: string(name='ResourceId'),
      resourceName?: string(name='ResourceName'),
      status?: long(name='Status'),
      type?: string(name='Type'),
      url?: string(name='Url'),
    }
  ](name='List'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalPage?: long(name='TotalPage'),
}

model ListSubSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSubSceneResponseBody(name='body'),
}

async function listSubSceneWithOptions(request: ListSubSceneRequest, runtime: Util.RuntimeOptions): ListSubSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  if (!Util.isUnset(request.showLayoutData)) {
    query['ShowLayoutData'] = request.showLayoutData;
  }
  if (!Util.isUnset(request.sortField)) {
    query['SortField'] = request.sortField;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSubScene',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSubScene(request: ListSubSceneRequest): ListSubSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSubSceneWithOptions(request, runtime);
}

model OptimizeRightAngleRequest {
  subSceneId?: string(name='SubSceneId'),
}

model OptimizeRightAngleResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model OptimizeRightAngleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OptimizeRightAngleResponseBody(name='body'),
}

async function optimizeRightAngleWithOptions(request: OptimizeRightAngleRequest, runtime: Util.RuntimeOptions): OptimizeRightAngleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.subSceneId)) {
    query['SubSceneId'] = request.subSceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OptimizeRightAngle',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function optimizeRightAngle(request: OptimizeRightAngleRequest): OptimizeRightAngleResponse {
  var runtime = new Util.RuntimeOptions{};
  return optimizeRightAngleWithOptions(request, runtime);
}

model PackSceneRequest {
  sceneId?: string(name='SceneId'),
  type?: string(name='Type'),
}

model PackSceneResponseBody = {
  code?: long(name='Code'),
  data?: {
    taskId?: string(name='TaskId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PackSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PackSceneResponseBody(name='body'),
}

async function packSceneWithOptions(request: PackSceneRequest, runtime: Util.RuntimeOptions): PackSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PackScene',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function packScene(request: PackSceneRequest): PackSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return packSceneWithOptions(request, runtime);
}

model PackSourceRequest {
  sceneId?: string(name='SceneId'),
}

model PackSourceResponseBody = {
  code?: long(name='Code'),
  data?: {
    taskId?: string(name='TaskId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PackSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PackSourceResponseBody(name='body'),
}

async function packSourceWithOptions(request: PackSourceRequest, runtime: Util.RuntimeOptions): PackSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PackSource',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function packSource(request: PackSourceRequest): PackSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return packSourceWithOptions(request, runtime);
}

model PredImageRequest {
  correctVertical?: boolean(name='CorrectVertical'),
  countDetectDoor?: long(name='CountDetectDoor'),
  detectDoor?: boolean(name='DetectDoor'),
  subSceneId?: string(name='SubSceneId'),
}

model PredImageResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model PredImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PredImageResponseBody(name='body'),
}

async function predImageWithOptions(request: PredImageRequest, runtime: Util.RuntimeOptions): PredImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.correctVertical)) {
    query['CorrectVertical'] = request.correctVertical;
  }
  if (!Util.isUnset(request.countDetectDoor)) {
    query['CountDetectDoor'] = request.countDetectDoor;
  }
  if (!Util.isUnset(request.detectDoor)) {
    query['DetectDoor'] = request.detectDoor;
  }
  if (!Util.isUnset(request.subSceneId)) {
    query['SubSceneId'] = request.subSceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PredImage',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function predImage(request: PredImageRequest): PredImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return predImageWithOptions(request, runtime);
}

model PredictionWallLineRequest {
  cameraHeight?: long(name='CameraHeight'),
  url?: string(name='Url'),
}

model PredictionWallLineResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  subSceneId?: string(name='SubSceneId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model PredictionWallLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PredictionWallLineResponseBody(name='body'),
}

async function predictionWallLineWithOptions(request: PredictionWallLineRequest, runtime: Util.RuntimeOptions): PredictionWallLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cameraHeight)) {
    query['CameraHeight'] = request.cameraHeight;
  }
  if (!Util.isUnset(request.url)) {
    query['Url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PredictionWallLine',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function predictionWallLine(request: PredictionWallLineRequest): PredictionWallLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return predictionWallLineWithOptions(request, runtime);
}

model PublishHotspotRequest {
  paramTag?: string(name='ParamTag'),
  subSceneUuid?: string(name='SubSceneUuid'),
}

model PublishHotspotResponseBody = {
  data?: map[string]any(name='Data'),
  errMessage?: string(name='ErrMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PublishHotspotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishHotspotResponseBody(name='body'),
}

async function publishHotspotWithOptions(request: PublishHotspotRequest, runtime: Util.RuntimeOptions): PublishHotspotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.paramTag)) {
    query['ParamTag'] = request.paramTag;
  }
  if (!Util.isUnset(request.subSceneUuid)) {
    query['SubSceneUuid'] = request.subSceneUuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublishHotspot',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publishHotspot(request: PublishHotspotRequest): PublishHotspotResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishHotspotWithOptions(request, runtime);
}

model PublishHotspotConfigRequest {
  sceneId?: string(name='SceneId'),
}

model PublishHotspotConfigResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PublishHotspotConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishHotspotConfigResponseBody(name='body'),
}

async function publishHotspotConfigWithOptions(request: PublishHotspotConfigRequest, runtime: Util.RuntimeOptions): PublishHotspotConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublishHotspotConfig',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publishHotspotConfig(request: PublishHotspotConfigRequest): PublishHotspotConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishHotspotConfigWithOptions(request, runtime);
}

model PublishSceneRequest {
  sceneId?: string(name='SceneId'),
}

model PublishSceneResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  previewUrl?: string(name='PreviewUrl'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PublishSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishSceneResponseBody(name='body'),
}

async function publishSceneWithOptions(request: PublishSceneRequest, runtime: Util.RuntimeOptions): PublishSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublishScene',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publishScene(request: PublishSceneRequest): PublishSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishSceneWithOptions(request, runtime);
}

model PublishStatusRequest {
  sceneId?: string(name='SceneId'),
}

model PublishStatusResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
  syncStatus?: string(name='SyncStatus'),
}

model PublishStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishStatusResponseBody(name='body'),
}

async function publishStatusWithOptions(request: PublishStatusRequest, runtime: Util.RuntimeOptions): PublishStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublishStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function publishStatus(request: PublishStatusRequest): PublishStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return publishStatusWithOptions(request, runtime);
}

model RecoveryOriginImageRequest {
  subSceneId?: string(name='SubSceneId'),
}

model RecoveryOriginImageResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RecoveryOriginImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecoveryOriginImageResponseBody(name='body'),
}

async function recoveryOriginImageWithOptions(request: RecoveryOriginImageRequest, runtime: Util.RuntimeOptions): RecoveryOriginImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.subSceneId)) {
    query['SubSceneId'] = request.subSceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RecoveryOriginImage',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recoveryOriginImage(request: RecoveryOriginImageRequest): RecoveryOriginImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return recoveryOriginImageWithOptions(request, runtime);
}

model RectVerticalRequest {
  countDetectDoor?: int32(name='CountDetectDoor'),
  detectDoor?: boolean(name='DetectDoor'),
  subSceneId?: string(name='SubSceneId'),
  verticalRect?: string(name='VerticalRect'),
}

model RectVerticalResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model RectVerticalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RectVerticalResponseBody(name='body'),
}

async function rectVerticalWithOptions(request: RectVerticalRequest, runtime: Util.RuntimeOptions): RectVerticalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.countDetectDoor)) {
    query['CountDetectDoor'] = request.countDetectDoor;
  }
  if (!Util.isUnset(request.detectDoor)) {
    query['DetectDoor'] = request.detectDoor;
  }
  if (!Util.isUnset(request.subSceneId)) {
    query['SubSceneId'] = request.subSceneId;
  }
  if (!Util.isUnset(request.verticalRect)) {
    query['VerticalRect'] = request.verticalRect;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RectVertical',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rectVertical(request: RectVerticalRequest): RectVerticalResponse {
  var runtime = new Util.RuntimeOptions{};
  return rectVerticalWithOptions(request, runtime);
}

model RectifyImageRequest {
  cameraHeight?: long(name='CameraHeight'),
  url?: string(name='Url'),
}

model RectifyImageResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  subSceneId?: string(name='SubSceneId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model RectifyImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RectifyImageResponseBody(name='body'),
}

async function rectifyImageWithOptions(request: RectifyImageRequest, runtime: Util.RuntimeOptions): RectifyImageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cameraHeight)) {
    query['CameraHeight'] = request.cameraHeight;
  }
  if (!Util.isUnset(request.url)) {
    query['Url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RectifyImage',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rectifyImage(request: RectifyImageRequest): RectifyImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return rectifyImageWithOptions(request, runtime);
}

model RollbackSubSceneRequest {
  id?: string(name='Id'),
}

model RollbackSubSceneResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RollbackSubSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RollbackSubSceneResponseBody(name='body'),
}

async function rollbackSubSceneWithOptions(request: RollbackSubSceneRequest, runtime: Util.RuntimeOptions): RollbackSubSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RollbackSubScene',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rollbackSubScene(request: RollbackSubSceneRequest): RollbackSubSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return rollbackSubSceneWithOptions(request, runtime);
}

model SaveHotspotConfigRequest {
  paramTag?: string(name='ParamTag'),
  previewToken?: string(name='PreviewToken'),
}

model SaveHotspotConfigResponseBody = {
  errMessage?: string(name='ErrMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveHotspotConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveHotspotConfigResponseBody(name='body'),
}

async function saveHotspotConfigWithOptions(request: SaveHotspotConfigRequest, runtime: Util.RuntimeOptions): SaveHotspotConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.paramTag)) {
    query['ParamTag'] = request.paramTag;
  }
  if (!Util.isUnset(request.previewToken)) {
    query['PreviewToken'] = request.previewToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveHotspotConfig',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveHotspotConfig(request: SaveHotspotConfigRequest): SaveHotspotConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveHotspotConfigWithOptions(request, runtime);
}

model SaveHotspotTagRequest {
  paramTag?: string(name='ParamTag'),
  subSceneUuid?: string(name='SubSceneUuid'),
}

model SaveHotspotTagResponseBody = {
  errMessage?: string(name='ErrMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveHotspotTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveHotspotTagResponseBody(name='body'),
}

async function saveHotspotTagWithOptions(request: SaveHotspotTagRequest, runtime: Util.RuntimeOptions): SaveHotspotTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.paramTag)) {
    query['ParamTag'] = request.paramTag;
  }
  if (!Util.isUnset(request.subSceneUuid)) {
    query['SubSceneUuid'] = request.subSceneUuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveHotspotTag',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveHotspotTag(request: SaveHotspotTagRequest): SaveHotspotTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveHotspotTagWithOptions(request, runtime);
}

model SaveHotspotTagListRequest {
  hotspotListJson?: string(name='HotspotListJson'),
  sceneId?: string(name='SceneId'),
}

model SaveHotspotTagListResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveHotspotTagListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveHotspotTagListResponseBody(name='body'),
}

async function saveHotspotTagListWithOptions(request: SaveHotspotTagListRequest, runtime: Util.RuntimeOptions): SaveHotspotTagListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hotspotListJson)) {
    query['HotspotListJson'] = request.hotspotListJson;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveHotspotTagList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveHotspotTagList(request: SaveHotspotTagListRequest): SaveHotspotTagListResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveHotspotTagListWithOptions(request, runtime);
}

model SaveModelConfigRequest {
  data?: string(name='Data'),
  sceneId?: string(name='SceneId'),
}

model SaveModelConfigResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveModelConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveModelConfigResponseBody(name='body'),
}

async function saveModelConfigWithOptions(request: SaveModelConfigRequest, runtime: Util.RuntimeOptions): SaveModelConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveModelConfig',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveModelConfig(request: SaveModelConfigRequest): SaveModelConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveModelConfigWithOptions(request, runtime);
}

model ScenePublishRequest {
  sceneId?: string(name='SceneId'),
}

model ScenePublishResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  previewUrl?: string(name='PreviewUrl'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ScenePublishResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScenePublishResponseBody(name='body'),
}

async function scenePublishWithOptions(request: ScenePublishRequest, runtime: Util.RuntimeOptions): ScenePublishResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ScenePublish',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function scenePublish(request: ScenePublishRequest): ScenePublishResponse {
  var runtime = new Util.RuntimeOptions{};
  return scenePublishWithOptions(request, runtime);
}

model TempPreviewRequest {
  sceneId?: string(name='SceneId'),
}

model TempPreviewResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  previewUrl?: string(name='PreviewUrl'),
  requestId?: string(name='RequestId'),
  sceneId?: string(name='SceneId'),
  success?: boolean(name='Success'),
}

model TempPreviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TempPreviewResponseBody(name='body'),
}

async function tempPreviewWithOptions(request: TempPreviewRequest, runtime: Util.RuntimeOptions): TempPreviewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TempPreview',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tempPreview(request: TempPreviewRequest): TempPreviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return tempPreviewWithOptions(request, runtime);
}

model TempPreviewStatusRequest {
  sceneId?: string(name='SceneId'),
}

model TempPreviewStatusResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  success?: boolean(name='Success'),
}

model TempPreviewStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TempPreviewStatusResponseBody(name='body'),
}

async function tempPreviewStatusWithOptions(request: TempPreviewStatusRequest, runtime: Util.RuntimeOptions): TempPreviewStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TempPreviewStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tempPreviewStatus(request: TempPreviewStatusRequest): TempPreviewStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return tempPreviewStatusWithOptions(request, runtime);
}

model UpdateConnDataRequest {
  connData?: string(name='ConnData'),
  sceneId?: string(name='SceneId'),
}

model UpdateConnDataResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateConnDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateConnDataResponseBody(name='body'),
}

async function updateConnDataWithOptions(request: UpdateConnDataRequest, runtime: Util.RuntimeOptions): UpdateConnDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connData)) {
    query['ConnData'] = request.connData;
  }
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConnData',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateConnData(request: UpdateConnDataRequest): UpdateConnDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConnDataWithOptions(request, runtime);
}

model UpdateLayoutDataRequest {
  layoutData?: string(name='LayoutData'),
  subSceneId?: string(name='SubSceneId'),
}

model UpdateLayoutDataResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateLayoutDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLayoutDataResponseBody(name='body'),
}

async function updateLayoutDataWithOptions(request: UpdateLayoutDataRequest, runtime: Util.RuntimeOptions): UpdateLayoutDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.layoutData)) {
    query['LayoutData'] = request.layoutData;
  }
  if (!Util.isUnset(request.subSceneId)) {
    query['SubSceneId'] = request.subSceneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLayoutData',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLayoutData(request: UpdateLayoutDataRequest): UpdateLayoutDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLayoutDataWithOptions(request, runtime);
}

model UpdateProjectRequest {
  businessId?: string(name='BusinessId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
}

model UpdateProjectResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProjectResponseBody(name='body'),
}

async function updateProjectWithOptions(request: UpdateProjectRequest, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessId)) {
    query['BusinessId'] = request.businessId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProject',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProject(request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProjectWithOptions(request, runtime);
}

model UpdateSceneRequest {
  id?: string(name='Id'),
  name?: string(name='Name'),
}

model UpdateSceneResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSceneResponseBody(name='body'),
}

async function updateSceneWithOptions(request: UpdateSceneRequest, runtime: Util.RuntimeOptions): UpdateSceneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateScene',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateScene(request: UpdateSceneRequest): UpdateSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSceneWithOptions(request, runtime);
}

model UpdateSubSceneRequest {
  id?: string(name='Id'),
  name?: string(name='Name'),
  viewPoint?: [ double ](name='ViewPoint'),
}

model UpdateSubSceneShrinkRequest {
  id?: string(name='Id'),
  name?: string(name='Name'),
  viewPointShrink?: string(name='ViewPoint'),
}

model UpdateSubSceneResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSubSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSubSceneResponseBody(name='body'),
}

async function updateSubSceneWithOptions(tmpReq: UpdateSubSceneRequest, runtime: Util.RuntimeOptions): UpdateSubSceneResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateSubSceneShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.viewPoint)) {
    request.viewPointShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.viewPoint, 'ViewPoint', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.viewPointShrink)) {
    query['ViewPoint'] = request.viewPointShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSubScene',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSubScene(request: UpdateSubSceneRequest): UpdateSubSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSubSceneWithOptions(request, runtime);
}

model UpdateSubSceneSeqRequest {
  sceneId?: string(name='SceneId'),
  sortSubSceneIds?: [ string ](name='SortSubSceneIds'),
}

model UpdateSubSceneSeqShrinkRequest {
  sceneId?: string(name='SceneId'),
  sortSubSceneIdsShrink?: string(name='SortSubSceneIds'),
}

model UpdateSubSceneSeqResponseBody = {
  code?: long(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSubSceneSeqResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSubSceneSeqResponseBody(name='body'),
}

async function updateSubSceneSeqWithOptions(tmpReq: UpdateSubSceneSeqRequest, runtime: Util.RuntimeOptions): UpdateSubSceneSeqResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateSubSceneSeqShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.sortSubSceneIds)) {
    request.sortSubSceneIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sortSubSceneIds, 'SortSubSceneIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.sceneId)) {
    query['SceneId'] = request.sceneId;
  }
  if (!Util.isUnset(request.sortSubSceneIdsShrink)) {
    query['SortSubSceneIds'] = request.sortSubSceneIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSubSceneSeq',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSubSceneSeq(request: UpdateSubSceneSeqRequest): UpdateSubSceneSeqResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSubSceneSeqWithOptions(request, runtime);
}

