/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  @endpointMap = {
    cn-beijing = 'pai.cn-beijing.aliyuncs.com',
    cn-hangzhou = 'pai.cn-hangzhou.data.aliyun.com',
    cn-shanghai = 'pai.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'pai.cn-shenzhen.aliyuncs.com',
    cn-hongkong = 'pai.cn-hongkong.aliyuncs.com',
    ap-southeast-1 = 'pai.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'pai.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'pai.ap-southeast-3.aliyuncs.com',
    ap-southeast-5 = 'pai.ap-southeast-5.aliyuncs.com',
    us-west-1 = 'pai.us-west-1.aliyuncs.com',
    us-east-1 = 'pai.us-east-1.aliyuncs.com',
    eu-central-1 = 'pai.eu-central-1.aliyuncs.com',
    me-east-1 = 'pai.me-east-1.aliyuncs.com',
    ap-south-1 = 'pai.ap-south-1.aliyuncs.com',
    cn-qingdao = 'pai.cn-qingdao.aliyuncs.com',
    cn-zhangjiakou = 'pai.cn-zhangjiakou.aliyuncs.com',
  };
  checkConfig(config);
  @endpoint = getEndpoint('paistudio', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CreateExperimentRequest {
  workspaceId?: string(name='WorkspaceId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  source?: string(name='Source'),
  parentId?: string(name='ParentId'),
}

model CreateExperimentResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    experimentId?: string(name='ExperimentId'),
  }(name='Data'),
  code?: string(name='Code'),
}

model CreateExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExperimentResponseBody(name='body'),
}

async function createExperiment(request: CreateExperimentRequest): CreateExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createExperimentWithOptions(request, headers, runtime);
}

async function createExperimentWithOptions(request: CreateExperimentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateExperimentResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    body.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.name)) {
    body.Name = request.name;
  }
  if (!Util.isUnset(request.description)) {
    body.Description = request.description;
  }
  if (!Util.isUnset(request.source)) {
    body.Source = request.source;
  }
  if (!Util.isUnset(request.parentId)) {
    body.ParentId = request.parentId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateExperiment', '2020-11-23', 'HTTPS', 'POST', 'AK', `/api/core/v1.0/experiments`, 'json', req, runtime);
}

model CreateExperimentFolderRequest {
  workspaceId?: string(name='WorkspaceId'),
  name?: string(name='Name'),
  parentId?: string(name='ParentId'),
  source?: string(name='Source'),
}

model CreateExperimentFolderResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  data?: {
    folderUuid?: string(name='FolderUuid'),
  }(name='Data'),
}

model CreateExperimentFolderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExperimentFolderResponseBody(name='body'),
}

async function createExperimentFolder(request: CreateExperimentFolderRequest): CreateExperimentFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createExperimentFolderWithOptions(request, headers, runtime);
}

async function createExperimentFolderWithOptions(request: CreateExperimentFolderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateExperimentFolderResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    body.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.name)) {
    body.Name = request.name;
  }
  if (!Util.isUnset(request.parentId)) {
    body.ParentId = request.parentId;
  }
  if (!Util.isUnset(request.source)) {
    body.Source = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateExperimentFolder', '2020-11-23', 'HTTPS', 'POST', 'AK', `/api/core/v1.0/experiment-folders`, 'json', req, runtime);
}

model CreateJobRequest {
  experimentId?: string(name='ExperimentId'),
  executeType?: string(name='ExecuteType'),
  anchorNodeId?: string(name='AnchorNodeId'),
}

model CreateJobResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    jobId?: string(name='JobId'),
  }(name='Data'),
  code?: string(name='Code'),
}

model CreateJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateJobResponseBody(name='body'),
}

async function createJob(request: CreateJobRequest): CreateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createJobWithOptions(request, headers, runtime);
}

async function createJobWithOptions(request: CreateJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateJobResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.experimentId)) {
    query.ExperimentId = request.experimentId;
  }
  if (!Util.isUnset(request.executeType)) {
    query.ExecuteType = request.executeType;
  }
  if (!Util.isUnset(request.anchorNodeId)) {
    query.AnchorNodeId = request.anchorNodeId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateJob', '2020-11-23', 'HTTPS', 'POST', 'AK', `/api/core/v1.0/jobs`, 'json', req, runtime);
}

model CreateServiceRequest {
  workspaceId?: string(name='WorkspaceId'),
  serviceType?: string(name='ServiceType'),
  logDirectory?: string(name='LogDirectory'),
}

model CreateServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    serviceId?: string(name='ServiceId'),
    url?: string(name='Url'),
  }(name='Data'),
  code?: string(name='Code'),
}

model CreateServiceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceResponseBody(name='body'),
}

async function createService(request: CreateServiceRequest): CreateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceWithOptions(request, headers, runtime);
}

async function createServiceWithOptions(request: CreateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.serviceType)) {
    query.ServiceType = request.serviceType;
  }
  if (!Util.isUnset(request.logDirectory)) {
    query.LogDirectory = request.logDirectory;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('CreateService', '2020-11-23', 'HTTPS', 'POST', 'AK', `/api/core/v1.0/services`, 'json', req, runtime);
}

model DeleteAlgoRequest {
  pipelineId?: string(name='PipelineId'),
}

model DeleteAlgoResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
  code?: string(name='Code'),
}

model DeleteAlgoResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAlgoResponseBody(name='body'),
}

async function deleteAlgo(request: DeleteAlgoRequest): DeleteAlgoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteAlgoWithOptions(request, headers, runtime);
}

async function deleteAlgoWithOptions(request: DeleteAlgoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteAlgoResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.pipelineId)) {
    body.PipelineId = request.pipelineId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequestWithForm('DeleteAlgo', '2020-11-23', 'HTTPS', 'POST', 'AK', `/api/core/v1.0/algo/delete`, 'json', req, runtime);
}

model DeleteExperimentResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    experimentId?: string(name='ExperimentId'),
  }(name='Data'),
  code?: string(name='Code'),
}

model DeleteExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExperimentResponseBody(name='body'),
}

async function deleteExperiment(ExperimentId: string): DeleteExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteExperimentWithOptions(ExperimentId, headers, runtime);
}

async function deleteExperimentWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteExperimentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeleteExperiment', '2020-11-23', 'HTTPS', 'DELETE', 'AK', `/api/core/v1.0/experiments/${ExperimentId}`, 'json', req, runtime);
}

model DeleteExperimentFolderResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  data?: string(name='Data'),
}

model DeleteExperimentFolderResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExperimentFolderResponseBody(name='body'),
}

async function deleteExperimentFolder(FolderId: string): DeleteExperimentFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteExperimentFolderWithOptions(FolderId, headers, runtime);
}

async function deleteExperimentFolderWithOptions(FolderId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteExperimentFolderResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeleteExperimentFolder', '2020-11-23', 'HTTPS', 'DELETE', 'AK', `/api/core/v1.0/experiment-folders/${FolderId}`, 'json', req, runtime);
}

model GetAlgoDefRequest {
  provider?: string(name='Provider'),
  identifier?: string(name='Identifier'),
  version?: string(name='Version'),
  signature?: string(name='Signature'),
}

model GetAlgoDefResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: map[string]any(name='Data'),
  code?: string(name='Code'),
}

model GetAlgoDefResponse = {
  headers: map[string]string(name='headers'),
  body: GetAlgoDefResponseBody(name='body'),
}

async function getAlgoDef(request: GetAlgoDefRequest): GetAlgoDefResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgoDefWithOptions(request, headers, runtime);
}

async function getAlgoDefWithOptions(request: GetAlgoDefRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgoDefResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.provider)) {
    query.Provider = request.provider;
  }
  if (!Util.isUnset(request.identifier)) {
    query.Identifier = request.identifier;
  }
  if (!Util.isUnset(request.version)) {
    query.Version = request.version;
  }
  if (!Util.isUnset(request.signature)) {
    query.Signature = request.signature;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetAlgoDef', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/algo/detail`, 'json', req, runtime);
}

model GetAlgoTreeRequest {
  source?: string(name='Source'),
}

model GetAlgoTreeResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: map[string]any(name='Data'),
  code?: string(name='Code'),
}

model GetAlgoTreeResponse = {
  headers: map[string]string(name='headers'),
  body: GetAlgoTreeResponseBody(name='body'),
}

async function getAlgoTree(request: GetAlgoTreeRequest): GetAlgoTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAlgoTreeWithOptions(request, headers, runtime);
}

async function getAlgoTreeWithOptions(request: GetAlgoTreeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetAlgoTreeResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.source)) {
    query.Source = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetAlgoTree', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/algo/tree`, 'json', req, runtime);
}

model GetExperimentResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    deleted?: boolean(name='deleted'),
    gmtDeleted?: string(name='GmtDeleted'),
    operatorModified?: string(name='OperatorModified'),
    gmtModified?: string(name='GmtModified'),
    source?: string(name='Source'),
    creator?: string(name='Creator'),
    operatorDeleted?: string(name='OperatorDeleted'),
    parentUserId?: string(name='ParentUserId'),
    workspaceId?: string(name='WorkspaceId'),
    description?: string(name='Description'),
    version?: int32(name='Version'),
    isDeleted?: boolean(name='IsDeleted'),
    experimentId?: string(name='ExperimentId'),
    gmtCreate?: string(name='GmtCreate'),
    name?: string(name='Name'),
    content?: string(name='Content'),
    id?: int32(name='Id'),
  }(name='Data'),
  code?: string(name='Code'),
}

model GetExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: GetExperimentResponseBody(name='body'),
}

async function getExperiment(ExperimentId: string): GetExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentWithOptions(ExperimentId, headers, runtime);
}

async function getExperimentWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetExperiment', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/experiments/${ExperimentId}`, 'json', req, runtime);
}

model GetExperimentMetaResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  data?: {
    gmtCreate?: long(name='GmtCreate'),
    gmtModified?: long(name='GmtModified'),
    creator?: string(name='Creator'),
    operatorModified?: string(name='OperatorModified'),
    parentUserId?: string(name='ParentUserId'),
    workspaceId?: string(name='WorkspaceId'),
    experimentId?: string(name='ExperimentId'),
    name?: string(name='Name'),
    description?: string(name='Description'),
    source?: string(name='Source'),
  }(name='Data'),
}

model GetExperimentMetaResponse = {
  headers: map[string]string(name='headers'),
  body: GetExperimentMetaResponseBody(name='body'),
}

async function getExperimentMeta(ExperimentId: string): GetExperimentMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentMetaWithOptions(ExperimentId, headers, runtime);
}

async function getExperimentMetaWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentMetaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetExperimentMeta', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/experiments/${ExperimentId}/meta`, 'json', req, runtime);
}

model GetExperimentStatusResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    nodes?: [ 
      {
        status?: string(name='Status'),
        runNodeId?: string(name='RunNodeId'),
        executionId?: string(name='ExecutionId'),
        nodeId?: string(name='NodeId'),
        runId?: string(name='RunId'),
      }
    ](name='Nodes'),
    experimentId?: string(name='ExperimentId'),
  }(name='Data'),
  code?: string(name='Code'),
}

model GetExperimentStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetExperimentStatusResponseBody(name='body'),
}

async function getExperimentStatus(ExperimentId: string): GetExperimentStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getExperimentStatusWithOptions(ExperimentId, headers, runtime);
}

async function getExperimentStatusWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetExperimentStatusResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetExperimentStatus', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/experiments/${ExperimentId}/status`, 'json', req, runtime);
}

model GetJobRequest {
  queryDetail?: boolean(name='QueryDetail'),
}

model GetJobResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: string(name='Status'),
    createTime?: string(name='CreateTime'),
    jobId?: string(name='JobId'),
    anchorNodeId?: string(name='AnchorNodeId'),
    experimentId?: string(name='ExperimentId'),
    executeType?: string(name='ExecuteType'),
    snapshot?: string(name='Snapshot'),
    runId?: string(name='RunId'),
    creator?: string(name='Creator'),
  }(name='Data'),
  code?: string(name='Code'),
}

model GetJobResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobResponseBody(name='body'),
}

async function getJob(JobId: string, request: GetJobRequest): GetJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getJobWithOptions(JobId, request, headers, runtime);
}

async function getJobWithOptions(JobId: string, request: GetJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetJobResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.queryDetail)) {
    query.QueryDetail = request.queryDetail;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetJob', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/jobs/${JobId}`, 'json', req, runtime);
}

model GetNodeInputSchemaRequest {
  inputAnchor?: string(name='InputAnchor'),
}

model GetNodeInputSchemaResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    colTypes?: [ string ](name='ColTypes'),
    colNames?: [ string ](name='ColNames'),
  }(name='Data'),
  code?: string(name='Code'),
}

model GetNodeInputSchemaResponse = {
  headers: map[string]string(name='headers'),
  body: GetNodeInputSchemaResponseBody(name='body'),
}

async function getNodeInputSchema(ExperimentId: string, NodeId: string, request: GetNodeInputSchemaRequest): GetNodeInputSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNodeInputSchemaWithOptions(ExperimentId, NodeId, request, headers, runtime);
}

async function getNodeInputSchemaWithOptions(ExperimentId: string, NodeId: string, request: GetNodeInputSchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNodeInputSchemaResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.inputAnchor)) {
    query.InputAnchor = request.inputAnchor;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetNodeInputSchema', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/experiments/${ExperimentId}/nodes/${NodeId}/schema`, 'json', req, runtime);
}

model GetOdpsTableRequest {
  workspaceId?: string(name='WorkspaceId'),
  name?: string(name='Name'),
}

model GetOdpsTableResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    partitionColumns?: [ string ](name='PartitionColumns'),
    columns?: [ 
      {
        type?: string(name='Type'),
        preview?: [ string ](name='Preview'),
        name?: string(name='Name'),
      }
    ](name='Columns'),
  }(name='Data'),
  code?: string(name='Code'),
}

model GetOdpsTableResponse = {
  headers: map[string]string(name='headers'),
  body: GetOdpsTableResponseBody(name='body'),
}

async function getOdpsTable(request: GetOdpsTableRequest): GetOdpsTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOdpsTableWithOptions(request, headers, runtime);
}

async function getOdpsTableWithOptions(request: GetOdpsTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetOdpsTableResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetOdpsTable', '2020-11-23', 'HTTPS', 'POST', 'AK', `/api/core/v1.0/datasource/odps/table`, 'json', req, runtime);
}

model GetOutputModelInfoResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: map[string]any(name='Data'),
  code?: string(name='Code'),
}

model GetOutputModelInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetOutputModelInfoResponseBody(name='body'),
}

async function getOutputModelInfo(ExperimentId: string, NodeId: string): GetOutputModelInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOutputModelInfoWithOptions(ExperimentId, NodeId, headers, runtime);
}

async function getOutputModelInfoWithOptions(ExperimentId: string, NodeId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetOutputModelInfoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetOutputModelInfo', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/nodes/${ExperimentId}/${NodeId}/model`, 'json', req, runtime);
}

model GetOutputModeVisualRequest {
  exportParams?: string(name='ExportParams'),
}

model GetOutputModeVisualResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: map[string]any(name='Data'),
  code?: string(name='Code'),
}

model GetOutputModeVisualResponse = {
  headers: map[string]string(name='headers'),
  body: GetOutputModeVisualResponseBody(name='body'),
}

async function getOutputModeVisual(ExperimentId: string, NodeId: string, request: GetOutputModeVisualRequest): GetOutputModeVisualResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOutputModeVisualWithOptions(ExperimentId, NodeId, request, headers, runtime);
}

async function getOutputModeVisualWithOptions(ExperimentId: string, NodeId: string, request: GetOutputModeVisualRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetOutputModeVisualResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.exportParams)) {
    query.ExportParams = request.exportParams;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetOutputModeVisual', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/nodes/${ExperimentId}/${NodeId}/visual`, 'json', req, runtime);
}

model GetOutputPmmlPathResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
}

model GetOutputPmmlPathResponse = {
  headers: map[string]string(name='headers'),
  body: GetOutputPmmlPathResponseBody(name='body'),
}

async function getOutputPmmlPath(ExperimentId: string, NodeId: string): GetOutputPmmlPathResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getOutputPmmlPathWithOptions(ExperimentId, NodeId, headers, runtime);
}

async function getOutputPmmlPathWithOptions(ExperimentId: string, NodeId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetOutputPmmlPathResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetOutputPmmlPath', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/nodes/${ExperimentId}/${NodeId}/pmml`, 'json', req, runtime);
}

model GetServiceRequest {
  serviceType?: string(name='ServiceType'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetServiceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    message?: string(name='Message'),
    url?: string(name='Url'),
  }(name='Data'),
  code?: string(name='Code'),
}

model GetServiceResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceResponseBody(name='body'),
}

async function getService(ServiceId: string, request: GetServiceRequest): GetServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceWithOptions(ServiceId, request, headers, runtime);
}

async function getServiceWithOptions(ServiceId: string, request: GetServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.serviceType)) {
    query.ServiceType = request.serviceType;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetService', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/services/${ServiceId}`, 'json', req, runtime);
}

model GetStatisticsRequest {
  type?: string(name='Type'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetStatisticsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
}

model GetStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: GetStatisticsResponseBody(name='body'),
}

async function getStatistics(request: GetStatisticsRequest): GetStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getStatisticsWithOptions(request, headers, runtime);
}

async function getStatisticsWithOptions(request: GetStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetStatisticsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.type)) {
    query.Type = request.type;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetStatistics', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/statistics`, 'json', req, runtime);
}

model GetTemplateResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    description?: string(name='Description'),
    imageLink?: string(name='ImageLink'),
    docLink?: string(name='DocLink'),
    name?: string(name='Name'),
    templateId?: string(name='TemplateId'),
    content?: string(name='Content'),
    detail?: string(name='Detail'),
  }(name='Data'),
  code?: string(name='Code'),
}

model GetTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: GetTemplateResponseBody(name='body'),
}

async function getTemplate(TemplateId: string): GetTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTemplateWithOptions(TemplateId, headers, runtime);
}

async function getTemplateWithOptions(TemplateId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTemplateResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetTemplate', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/templates/${TemplateId}`, 'json', req, runtime);
}

model InitTemplateRequest {
  workspaceId?: string(name='WorkspaceId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  source?: string(name='Source'),
  parentId?: string(name='ParentId'),
}

model InitTemplateResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    gmtDeleted?: string(name='GmtDeleted'),
    operatorModified?: string(name='OperatorModified'),
    gmtModified?: string(name='GmtModified'),
    operatorDeleted?: string(name='OperatorDeleted'),
    parentUserId?: string(name='ParentUserId'),
    workspaceId?: string(name='WorkspaceId'),
    description?: string(name='Description'),
    operatorCreate?: string(name='OperatorCreate'),
    version?: int32(name='Version'),
    isDeleted?: boolean(name='IsDeleted'),
    experimentId?: string(name='ExperimentId'),
    gmtCreate?: string(name='GmtCreate'),
    name?: string(name='Name'),
    content?: string(name='Content'),
    id?: int32(name='Id'),
  }(name='Data'),
  code?: string(name='Code'),
}

model InitTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: InitTemplateResponseBody(name='body'),
}

async function initTemplate(TemplateId: string, request: InitTemplateRequest): InitTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return initTemplateWithOptions(TemplateId, request, headers, runtime);
}

async function initTemplateWithOptions(TemplateId: string, request: InitTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): InitTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    body.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.name)) {
    body.Name = request.name;
  }
  if (!Util.isUnset(request.description)) {
    body.Description = request.description;
  }
  if (!Util.isUnset(request.source)) {
    body.Source = request.source;
  }
  if (!Util.isUnset(request.parentId)) {
    body.ParentId = request.parentId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('InitTemplate', '2020-11-23', 'HTTPS', 'POST', 'AK', `/api/core/v1.0/templates/${TemplateId}/experiments`, 'json', req, runtime);
}

model ListAlgoDefsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  data?: [  map[string]any ](name='Data'),
  code?: string(name='Code'),
}

model ListAlgoDefsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlgoDefsResponseBody(name='body'),
}

async function listAlgoDefs(): ListAlgoDefsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAlgoDefsWithOptions(headers, runtime);
}

async function listAlgoDefsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListAlgoDefsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListAlgoDefs', '2020-11-23', 'HTTPS', 'POST', 'AK', `/api/core/v1.0/algo/detail`, 'json', req, runtime);
}

model ListExperimentNewRequest {
  workspaceId?: string(name='WorkspaceId'),
  folderId?: string(name='FolderId'),
  onlyFolder?: boolean(name='OnlyFolder'),
}

model ListExperimentNewResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  data?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      type?: string(name='Type'),
      hasChild?: boolean(name='HasChild'),
      icon?: string(name='Icon'),
    }
  ](name='Data'),
}

model ListExperimentNewResponse = {
  headers: map[string]string(name='headers'),
  body: ListExperimentNewResponseBody(name='body'),
}

async function listExperimentNew(request: ListExperimentNewRequest): ListExperimentNewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listExperimentNewWithOptions(request, headers, runtime);
}

async function listExperimentNewWithOptions(request: ListExperimentNewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListExperimentNewResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.folderId)) {
    query.FolderId = request.folderId;
  }
  if (!Util.isUnset(request.onlyFolder)) {
    query.OnlyFolder = request.onlyFolder;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListExperimentNew', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/experiment-folders`, 'json', req, runtime);
}

model ListExperimentsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sortDirection?: string(name='SortDirection'),
  experimentId?: string(name='ExperimentId'),
  name?: string(name='Name'),
  creator?: string(name='Creator'),
  source?: string(name='Source'),
  workspaceId?: string(name='WorkspaceId'),
  scope?: string(name='Scope'),
}

model ListExperimentsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      workspaceId?: string(name='WorkspaceId'),
      parentUserId?: string(name='ParentUserId'),
      description?: string(name='Description'),
      version?: long(name='Version'),
      experimentId?: string(name='ExperimentId'),
      gmtCreate?: long(name='GmtCreate'),
      source?: string(name='Source'),
      name?: string(name='Name'),
      gmtModified?: long(name='GmtModified'),
      creator?: string(name='Creator'),
    }
  ](name='Data'),
  code?: string(name='Code'),
}

model ListExperimentsResponse = {
  headers: map[string]string(name='headers'),
  body: ListExperimentsResponseBody(name='body'),
}

async function listExperiments(request: ListExperimentsRequest): ListExperimentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listExperimentsWithOptions(request, headers, runtime);
}

async function listExperimentsWithOptions(request: ListExperimentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListExperimentsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    query.PageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.sortDirection)) {
    query.SortDirection = request.sortDirection;
  }
  if (!Util.isUnset(request.experimentId)) {
    query.ExperimentId = request.experimentId;
  }
  if (!Util.isUnset(request.name)) {
    query.Name = request.name;
  }
  if (!Util.isUnset(request.creator)) {
    query.Creator = request.creator;
  }
  if (!Util.isUnset(request.source)) {
    query.Source = request.source;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.scope)) {
    query.Scope = request.scope;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListExperiments', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/experiments`, 'json', req, runtime);
}

model ListJobsRequest {
  experimentId?: string(name='ExperimentId'),
  creator?: string(name='Creator'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sortField?: string(name='SortField'),
  sortDirection?: string(name='SortDirection'),
}

model ListJobsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      status?: string(name='Status'),
      paiflowNodeId?: string(name='PaiflowNodeId'),
      jobId?: string(name='JobId'),
      createTime?: string(name='CreateTime'),
      experimentId?: string(name='ExperimentId'),
      creator?: string(name='Creator'),
      runId?: string(name='RunId'),
    }
  ](name='Data'),
  code?: string(name='Code'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listJobsWithOptions(request, headers, runtime);
}

async function listJobsWithOptions(request: ListJobsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.experimentId)) {
    query.ExperimentId = request.experimentId;
  }
  if (!Util.isUnset(request.creator)) {
    query.Creator = request.creator;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query.PageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.sortField)) {
    query.SortField = request.sortField;
  }
  if (!Util.isUnset(request.sortDirection)) {
    query.SortDirection = request.sortDirection;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListJobs', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/jobs`, 'json', req, runtime);
}

model ListServicesRequest {
  workspaceId?: string(name='WorkspaceId'),
  serviceType?: string(name='ServiceType'),
}

model ListServicesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: [ 
    {
      serviceId?: string(name='ServiceId'),
      url?: string(name='Url'),
    }
  ](name='Data'),
  code?: string(name='Code'),
}

model ListServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListServicesResponseBody(name='body'),
}

async function listServices(request: ListServicesRequest): ListServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServicesWithOptions(request, headers, runtime);
}

async function listServicesWithOptions(request: ListServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServicesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.serviceType)) {
    query.ServiceType = request.serviceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListServices', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/services`, 'json', req, runtime);
}

model ListTemplatesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sortDirection?: string(name='SortDirection'),
  tagId?: string(name='TagId'),
  source?: string(name='Source'),
}

model ListTemplatesResponseBody = {
  totalCount?: int32(name='TotalCount'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  maxResults?: int32(name='MaxResults'),
  data?: [ 
    {
      description?: string(name='Description'),
      imageLink?: string(name='ImageLink'),
      docLink?: string(name='DocLink'),
      name?: string(name='Name'),
      templateId?: string(name='TemplateId'),
      content?: string(name='Content'),
      detail?: string(name='Detail'),
    }
  ](name='Data'),
  code?: string(name='Code'),
}

model ListTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTemplatesResponseBody(name='body'),
}

async function listTemplates(request: ListTemplatesRequest): ListTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTemplatesWithOptions(request, headers, runtime);
}

async function listTemplatesWithOptions(request: ListTemplatesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTemplatesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    query.PageNumber = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query.PageSize = request.pageSize;
  }
  if (!Util.isUnset(request.sortDirection)) {
    query.SortDirection = request.sortDirection;
  }
  if (!Util.isUnset(request.tagId)) {
    query.TagId = request.tagId;
  }
  if (!Util.isUnset(request.source)) {
    query.Source = request.source;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListTemplates', '2020-11-23', 'HTTPS', 'GET', 'AK', `/api/core/v1.0/templates`, 'json', req, runtime);
}

model PreviewOdpsTableRequest {
  experimentId?: string(name='ExperimentId'),
  nodeId?: string(name='NodeId'),
  outputId?: string(name='OutputId'),
}

model PreviewOdpsTableResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
}

model PreviewOdpsTableResponse = {
  headers: map[string]string(name='headers'),
  body: PreviewOdpsTableResponseBody(name='body'),
}

async function previewOdpsTable(request: PreviewOdpsTableRequest): PreviewOdpsTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return previewOdpsTableWithOptions(request, headers, runtime);
}

async function previewOdpsTableWithOptions(request: PreviewOdpsTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PreviewOdpsTableResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.experimentId)) {
    query.ExperimentId = request.experimentId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query.NodeId = request.nodeId;
  }
  if (!Util.isUnset(request.outputId)) {
    query.OutputId = request.outputId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('PreviewOdpsTable', '2020-11-23', 'HTTPS', 'POST', 'AK', `/api/core/v1.0/datasource/odps/table/preview`, 'json', req, runtime);
}

model PublishAlgoRequest {
  provider?: string(name='Provider'),
  identifier?: string(name='Identifier'),
  version?: string(name='Version'),
  workspaceId?: string(name='WorkspaceId'),
  signature?: string(name='Signature'),
}

model PublishAlgoResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
}

model PublishAlgoResponse = {
  headers: map[string]string(name='headers'),
  body: PublishAlgoResponseBody(name='body'),
}

async function publishAlgo(request: PublishAlgoRequest): PublishAlgoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return publishAlgoWithOptions(request, headers, runtime);
}

async function publishAlgoWithOptions(request: PublishAlgoRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PublishAlgoResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.provider)) {
    query.Provider = request.provider;
  }
  if (!Util.isUnset(request.identifier)) {
    query.Identifier = request.identifier;
  }
  if (!Util.isUnset(request.version)) {
    query.Version = request.version;
  }
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.signature)) {
    query.Signature = request.signature;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('PublishAlgo', '2020-11-23', 'HTTPS', 'POST', 'AK', `/api/core/v1.0/algo/publish`, 'json', req, runtime);
}

model SearchExperimentRequest {
  workspaceId?: string(name='WorkspaceId'),
  keyword?: string(name='Keyword'),
}

model SearchExperimentResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  data?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      type?: string(name='Type'),
      hasChild?: boolean(name='HasChild'),
      icon?: string(name='Icon'),
    }
  ](name='Data'),
}

model SearchExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: SearchExperimentResponseBody(name='body'),
}

async function searchExperiment(request: SearchExperimentRequest): SearchExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchExperimentWithOptions(request, headers, runtime);
}

async function searchExperimentWithOptions(request: SearchExperimentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchExperimentResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.keyword)) {
    query.Keyword = request.keyword;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('SearchExperiment', '2020-11-23', 'HTTPS', 'POST', 'AK', `/api/core/v1.0/experiment_search`, 'json', req, runtime);
}

model SearchOdpsTableRequest {
  workspaceId?: string(name='WorkspaceId'),
  keyword?: string(name='Keyword'),
}

model SearchOdpsTableResponseBody = {
  totalCount?: int32(name='TotalCount'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: [ string ](name='Data'),
  code?: string(name='Code'),
}

model SearchOdpsTableResponse = {
  headers: map[string]string(name='headers'),
  body: SearchOdpsTableResponseBody(name='body'),
}

async function searchOdpsTable(request: SearchOdpsTableRequest): SearchOdpsTableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchOdpsTableWithOptions(request, headers, runtime);
}

async function searchOdpsTableWithOptions(request: SearchOdpsTableRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchOdpsTableResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.workspaceId)) {
    query.WorkspaceId = request.workspaceId;
  }
  if (!Util.isUnset(request.keyword)) {
    query.Keyword = request.keyword;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('SearchOdpsTable', '2020-11-23', 'HTTPS', 'POST', 'AK', `/api/core/v1.0/datasource/odps/search`, 'json', req, runtime);
}

model StopExperimentResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model StopExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: StopExperimentResponseBody(name='body'),
}

async function stopExperiment(ExperimentId: string): StopExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopExperimentWithOptions(ExperimentId, headers, runtime);
}

async function stopExperimentWithOptions(ExperimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopExperimentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('StopExperiment', '2020-11-23', 'HTTPS', 'POST', 'AK', `/api/core/v1.0/experiments/${ExperimentId}/stop`, 'json', req, runtime);
}

model StopJobResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model StopJobResponse = {
  headers: map[string]string(name='headers'),
  body: StopJobResponseBody(name='body'),
}

async function stopJob(JobId: string): StopJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopJobWithOptions(JobId, headers, runtime);
}

async function stopJobWithOptions(JobId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopJobResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('StopJob', '2020-11-23', 'HTTPS', 'POST', 'AK', `/api/core/v1.0/jobs/${JobId}/stop`, 'json', req, runtime);
}

model UpdateExperimentFolderRequest {
  name?: string(name='Name'),
  parentId?: string(name='ParentId'),
}

model UpdateExperimentFolderResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  data?: string(name='Data'),
}

model UpdateExperimentFolderResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExperimentFolderResponseBody(name='body'),
}

async function updateExperimentFolder(FolderId: string, request: UpdateExperimentFolderRequest): UpdateExperimentFolderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExperimentFolderWithOptions(FolderId, request, headers, runtime);
}

async function updateExperimentFolderWithOptions(FolderId: string, request: UpdateExperimentFolderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExperimentFolderResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    body.Name = request.name;
  }
  if (!Util.isUnset(request.parentId)) {
    body.ParentId = request.parentId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateExperimentFolder', '2020-11-23', 'HTTPS', 'PUT', 'AK', `/api/core/v1.0/experiment-folders/${FolderId}`, 'json', req, runtime);
}

model UpdateExperimentMetaRequest {
  name?: string(name='Name'),
  description?: string(name='Description'),
  parentId?: string(name='ParentId'),
}

model UpdateExperimentMetaResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    experimentId?: string(name='ExperimentId'),
  }(name='Data'),
  code?: string(name='Code'),
}

model UpdateExperimentMetaResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExperimentMetaResponseBody(name='body'),
}

async function updateExperimentMeta(ExperimentId: string, request: UpdateExperimentMetaRequest): UpdateExperimentMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExperimentMetaWithOptions(ExperimentId, request, headers, runtime);
}

async function updateExperimentMetaWithOptions(ExperimentId: string, request: UpdateExperimentMetaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExperimentMetaResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.name)) {
    body.Name = request.name;
  }
  if (!Util.isUnset(request.description)) {
    body.Description = request.description;
  }
  if (!Util.isUnset(request.parentId)) {
    body.ParentId = request.parentId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateExperimentMeta', '2020-11-23', 'HTTPS', 'PUT', 'AK', `/api/core/v1.0/experiments/${ExperimentId}/meta`, 'json', req, runtime);
}

