/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('devs', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model Artifact {
  createdTime?: string(name='createdTime', example='2021-11-19T09:34:38Z'),
  description?: string(name='description', example='test-description'),
  generation?: int32(name='generation', example='1'),
  kind?: string(name='kind', example='Artifact'),
  labels?: map[string]string(name='labels'),
  name?: string(name='name', description='This parameter is required.', example='my-artifact'),
  resourceVersion?: int32(name='resourceVersion', example='1'),
  spec?: ArtifactSpec(name='spec'),
  status?: ArtifactStatus(name='status'),
  uid?: string(name='uid', example='1455541096***548'),
  updatedTime?: string(name='updatedTime', example='2021-11-19T09:34:38Z'),
}

model ArtifactCode {
  checksum?: string(name='checksum'),
  url?: string(name='url'),
}

model ArtifactMeta {
  checksum?: string(name='checksum', example='CRC-64 code'),
  name?: string(name='name', example='my-artifact'),
}

model ArtifactSpec {
  runtime?: string(name='runtime', description='This parameter is required.', example='custom.debian10'),
  type?: string(name='type', description='This parameter is required.', example='FC代码包、工作流yaml'),
  uri?: string(name='uri', description='This parameter is required.', example='oss://cn-hangzhou/my-bucket/my.zip'),
}

model ArtifactStatus {
  arn?: string(name='arn', example='acs:devs:cn-hangzhou:123456:artifacts/my-first-artifact'),
  checksum?: string(name='checksum', example='2825179536350****'),
  size?: long(name='size', example='1024'),
}

model ArtifactTempBucketToken {
  credentials?: {
    accessKeyId?: string(name='accessKeyId'),
    accessKeySecret?: string(name='accessKeySecret'),
    securityToken?: string(name='securityToken'),
  }(name='credentials'),
  ossBucketName?: string(name='ossBucketName'),
  ossObjectName?: string(name='ossObjectName'),
  ossRegion?: string(name='ossRegion'),
}

model BranchFilter {
  name?: string(name='name', example='master'),
}

model BuildCacheConfig {
  keyPath?: map[string]any(name='keyPath', example='{ 	"3C75C832-0EAD-40D6-8FA1-2BA9171C926B": "~/.npm", 	"D256BB7A-1886-4A19-A75B-A1FDC23D5A00": "~/.cache" }'),
  paths?: [ string ](name='paths'),
}

model BuildConfig {
  default?: DefaultBuilderConfig(name='default'),
}

model Checkout {
  ref?: string(name='ref', example='+001691d0768ca49e9550beeb59fbc163f33b7e88:refs/remotes/origin/master'),
  remote?: string(name='remote', example='https:/your_token/@github.com/buptwzj/test-initRepo4.git'),
}

model CodeVersionReference {
  branch?: string(name='branch', example='main'),
  commitID?: string(name='commitID', example='12721ec262d03a93809ba2bbc717963cb298ceca'),
}

model Condition {
  expression?: string(name='expression'),
}

model Connection {
  createdTime?: string(name='createdTime', example='2021-11-19T09:34:38Z'),
  description?: string(name='description', example='test-description'),
  kind?: string(name='kind', example='Connection'),
  labels?: map[string]string(name='labels'),
  name?: string(name='name', description='This parameter is required.', example='my-connection'),
  spec?: ConnectionSpec(name='spec', description='This parameter is required.'),
  status?: ConnectionStatus(name='status'),
  uid?: string(name='uid', example='1455541096***548'),
}

model ConnectionSpec {
  account?: GitAccount(name='account'),
  gitlabConfig?: GitLabConfig(name='gitlabConfig'),
  platform?: string(name='platform', description='This parameter is required.', example='github'),
}

model ConnectionStatus {
  installation?: Installation(name='installation'),
}

model Context {
  data?: map[string]any(name='data'),
}

model ContextSchema {
  description?: string(name='description', example='[git](https://git-scm.com/) address for [git clone](https://git-scm.com/docs/git-clone).'),
  hint?: string(name='hint', example='git@gitlab.alibaba-inc.com:serverless/lambda.git'),
  name?: string(name='name', example='gitRepoUrl'),
  required?: boolean(name='required', example='true'),
  type?: string(name='type', example='string'),
}

model DefaultBuilderConfig {
  cache?: BuildCacheConfig(name='cache'),
  languages?: [ string ](name='languages'),
  rootPath?: string(name='rootPath', example='./src'),
  steps?: [ any ](name='steps'),
}

model DeleteModelOutput {
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeployCustomContainerAsyncOutput {
  data?: string(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId', description='This parameter is required.'),
  success?: boolean(name='success'),
}

model DeployCustomContainerInput {
  accountID?: string(name='accountID'),
  asyncInvokeConfig?: {
    asyncTask?: boolean(name='asyncTask'),
    destinationConfig?: {
      onFailure?: {
        destination?: string(name='destination'),
      }(name='onFailure'),
      onSuccess?: {
        destination?: string(name='destination'),
      }(name='onSuccess'),
    }(name='destinationConfig'),
    maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds'),
    maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts'),
  }(name='asyncInvokeConfig'),
  concurrencyConfig?: {
    reservedConcurrency?: int32(name='reservedConcurrency'),
  }(name='concurrencyConfig'),
  cpu?: float(name='cpu'),
  customContainerConfig?: {
    command?: [ string ](name='command'),
    entrypoint?: [ string ](name='entrypoint'),
    healthCheckConfig?: {
      failureThreshold?: int32(name='failureThreshold'),
      httpGetUrl?: string(name='httpGetUrl'),
      initialDelaySeconds?: int32(name='initialDelaySeconds'),
      periodSeconds?: int32(name='periodSeconds'),
      successThreshold?: int32(name='successThreshold'),
      timeoutSeconds?: long(name='timeoutSeconds'),
    }(name='healthCheckConfig'),
    image?: string(name='image'),
    instanceConcurrency?: int32(name='instanceConcurrency'),
    instanceLifecycleConfig?: {
      initializer?: {
        handler?: string(name='handler'),
        timeout?: int32(name='timeout'),
      }(name='initializer'),
      preStop?: {
        handler?: string(name='handler'),
        timeout?: int32(name='timeout'),
      }(name='preStop'),
    }(name='instanceLifecycleConfig'),
    port?: int32(name='port'),
    role?: string(name='role'),
  }(name='customContainerConfig'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  envName?: string(name='envName'),
  environmentVariables?: map[string]any(name='environmentVariables'),
  gpuConfig?: {
    gpuMemorySize?: long(name='gpuMemorySize'),
    gpuType?: string(name='gpuType'),
  }(name='gpuConfig'),
  httpTrigger?: {
    qualifier?: string(name='qualifier'),
    triggerConfig?: {
      authType?: string(name='authType'),
      disableURLInternet?: boolean(name='disableURLInternet'),
      dsableURLInternet?: boolean(name='dsableURLInternet'),
      methods?: [ string ](name='methods'),
    }(name='triggerConfig'),
  }(name='httpTrigger'),
  logConfig?: {
    enableInstanceMetrics?: boolean(name='enableInstanceMetrics'),
    enableRequestMetrics?: boolean(name='enableRequestMetrics'),
    logBeginRule?: string(name='logBeginRule'),
    logstore?: string(name='logstore'),
    project?: string(name='project'),
  }(name='logConfig'),
  memorySize?: int32(name='memorySize'),
  modelConfig?: {
    framework?: string(name='framework'),
    multiModelConfig?: [
      ModelConfig
    ](name='multiModelConfig', nullable=true),
    prefix?: string(name='prefix'),
    sourceType?: string(name='sourceType'),
    srcModelScopeModelID?: string(name='srcModelScopeModelID'),
    srcModelScopeModelRevision?: string(name='srcModelScopeModelRevision'),
    srcModelScopeToken?: string(name='srcModelScopeToken'),
    srcOssBucket?: string(name='srcOssBucket'),
    srcOssPath?: string(name='srcOssPath'),
    srcOssRegion?: string(name='srcOssRegion'),
    syncStrategy?: string(name='syncStrategy'),
  }(name='modelConfig'),
  name?: string(name='name', description='This parameter is required.'),
  nasConfig?: {
    groupId?: long(name='groupId'),
    mountPoints?: [ string ](name='mountPoints'),
    userId?: long(name='userId'),
  }(name='nasConfig'),
  originalName?: string(name='originalName'),
  ossMountConfig?: {
    mountPoints?: [ 
      {
        bucketName?: string(name='bucketName'),
        bucketPath?: string(name='bucketPath'),
        endpoint?: string(name='endpoint'),
        mountDir?: string(name='mountDir'),
        readOnly?: boolean(name='readOnly'),
      }
    ](name='mountPoints'),
  }(name='ossMountConfig'),
  projectName?: string(name='projectName'),
  provisionConfig?: {
    alwaysAllocateGPU?: boolean(name='alwaysAllocateGPU'),
    scheduledActions?: [ 
      {
        endTime?: string(name='endTime'),
        name?: string(name='name'),
        scheduleExpression?: string(name='scheduleExpression'),
        startTime?: string(name='startTime'),
        target?: int32(name='target'),
        timeZone?: string(name='timeZone'),
      }
    ](name='scheduledActions'),
    target?: long(name='target'),
  }(name='provisionConfig'),
  region?: string(name='region'),
  reportStatusURL?: string(name='reportStatusURL'),
  role?: string(name='role', description='This parameter is required.'),
  timeout?: int32(name='timeout'),
  traceId?: string(name='traceId'),
  vpcConfig?: {
    securityGroupId?: string(name='securityGroupId'),
    vSwitchIds?: [ string ](name='vSwitchIds'),
    vpcId?: string(name='vpcId'),
  }(name='vpcConfig'),
}

model DeployCustomContainerOutput {
  data?: {
    deploymentTaskID?: string(name='deploymentTaskID'),
    errorMessage?: string(name='errorMessage'),
    finished?: boolean(name='finished'),
    nasConfigStr?: string(name='nasConfigStr'),
    serviceName?: string(name='serviceName'),
    traceID?: string(name='traceID'),
    urlInternet?: string(name='urlInternet'),
    urlIntranet?: string(name='urlIntranet'),
    vpcConfigStr?: string(name='vpcConfigStr'),
  }(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId', description='This parameter is required.'),
  success?: boolean(name='success'),
}

model DeployEnvironmentOptions {
  services?: [ string ](name='services'),
}

model DeployHuggingFaceModelAsyncOutput {
  data?: string(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId', description='This parameter is required.'),
  success?: boolean(name='success'),
}

model DeployHuggingFaceModelInput {
  accountID?: string(name='accountID'),
  concurrencyConfig?: {
    reservedConcurrency?: int32(name='reservedConcurrency'),
  }(name='concurrencyConfig'),
  cpu?: float(name='cpu'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  envName?: string(name='envName'),
  environmentVariables?: map[string]any(name='environmentVariables'),
  gpuConfig?: {
    gpuMemorySize?: int32(name='gpuMemorySize'),
    gpuType?: string(name='gpuType'),
  }(name='gpuConfig'),
  httpTrigger?: {
    qualifier?: string(name='qualifier'),
    triggerConfig?: {
      authType?: string(name='authType'),
      disableURLInternet?: boolean(name='disableURLInternet'),
      dsableURLInternet?: boolean(name='dsableURLInternet'),
      methods?: [ string ](name='methods'),
    }(name='triggerConfig'),
  }(name='httpTrigger'),
  imageName?: string(name='imageName'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  logConfig?: {
    enableInstanceMetrics?: boolean(name='enableInstanceMetrics'),
    enableRequestMetrics?: boolean(name='enableRequestMetrics'),
    logBeginRule?: string(name='logBeginRule'),
    logstore?: string(name='logstore'),
    project?: string(name='project'),
  }(name='logConfig'),
  memorySize?: int32(name='memorySize'),
  modelConfig?: {
    fmkHuggingFaceConfig?: {
      framework?: string(name='framework'),
      task?: string(name='task'),
    }(name='fmkHuggingFaceConfig'),
    framework?: string(name='framework'),
    multiModelConfig?: [
      ModelConfig
    ](name='multiModelConfig', nullable=true),
    prefix?: string(name='prefix'),
    sourceType?: string(name='sourceType'),
    srcModelScopeModelID?: string(name='srcModelScopeModelID'),
    srcModelScopeModelRevision?: string(name='srcModelScopeModelRevision'),
    srcModelScopeToken?: string(name='srcModelScopeToken'),
    srcOssBucket?: string(name='srcOssBucket'),
    srcOssPath?: string(name='srcOssPath'),
    srcOssRegion?: string(name='srcOssRegion'),
    syncStrategy?: string(name='syncStrategy'),
  }(name='modelConfig'),
  name?: string(name='name', description='This parameter is required.'),
  nasConfig?: {
    groupId?: int32(name='groupId'),
    mountPoints?: [ string ](name='mountPoints'),
    userId?: int32(name='userId'),
  }(name='nasConfig'),
  originalName?: string(name='originalName'),
  projectName?: string(name='projectName'),
  provisionConfig?: {
    alwaysAllocateGPU?: boolean(name='alwaysAllocateGPU'),
    scheduledActions?: [ 
      {
        endTime?: string(name='endTime'),
        name?: string(name='name'),
        scheduleExpression?: string(name='scheduleExpression'),
        startTime?: string(name='startTime'),
        target?: int32(name='target'),
        timeZone?: string(name='timeZone'),
      }
    ](name='scheduledActions'),
    target?: int32(name='target'),
  }(name='provisionConfig'),
  region?: string(name='region'),
  reportStatusURL?: string(name='reportStatusURL'),
  role?: string(name='role', description='This parameter is required.'),
  timeout?: int32(name='timeout'),
  traceId?: string(name='traceId'),
  vpcConfig?: {
    securityGroupId?: string(name='securityGroupId'),
    vSwitchIds?: [ string ](name='vSwitchIds'),
    vpcId?: string(name='vpcId'),
  }(name='vpcConfig'),
}

model DeployHuggingFaceModelOutput {
  data?: {
    deploymentTaskID?: string(name='deploymentTaskID'),
    errorMessage?: string(name='errorMessage'),
    finished?: boolean(name='finished'),
    serviceName?: string(name='serviceName'),
    taskType?: string(name='taskType'),
    traceID?: string(name='traceID'),
    urlInternet?: string(name='urlInternet'),
    urlIntranet?: string(name='urlIntranet'),
  }(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId', description='This parameter is required.'),
  success?: boolean(name='success'),
}

model DeployModelScopeModelAsyncOutput {
  data?: string(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId', description='This parameter is required.'),
  success?: boolean(name='success'),
}

model DeployModelScopeModelInput {
  accountID?: string(name='accountID'),
  concurrencyConfig?: {
    reservedConcurrency?: int32(name='reservedConcurrency'),
  }(name='concurrencyConfig'),
  cpu?: float(name='cpu'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  envName?: string(name='envName'),
  environmentVariables?: map[string]any(name='environmentVariables'),
  gpuConfig?: {
    gpuMemorySize?: int32(name='gpuMemorySize'),
    gpuType?: string(name='gpuType'),
  }(name='gpuConfig'),
  httpTrigger?: {
    qualifier?: string(name='qualifier'),
    triggerConfig?: {
      authType?: string(name='authType'),
      disableURLInternet?: boolean(name='disableURLInternet'),
      dsableURLInternet?: boolean(name='dsableURLInternet'),
      methods?: [ string ](name='methods'),
    }(name='triggerConfig'),
  }(name='httpTrigger'),
  imageName?: string(name='imageName'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  logConfig?: {
    enableInstanceMetrics?: boolean(name='enableInstanceMetrics'),
    enableRequestMetrics?: boolean(name='enableRequestMetrics'),
    logBeginRule?: string(name='logBeginRule'),
    logstore?: string(name='logstore'),
    project?: string(name='project'),
  }(name='logConfig'),
  memorySize?: int32(name='memorySize'),
  modelConfig?: {
    framework?: string(name='framework'),
    multiModelConfig?: [
      ModelConfig
    ](name='multiModelConfig', nullable=true),
    prefix?: string(name='prefix'),
    sourceType?: string(name='sourceType'),
    srcModelScopeModelID?: string(name='srcModelScopeModelID'),
    srcModelScopeModelRevision?: string(name='srcModelScopeModelRevision'),
    srcModelScopeToken?: string(name='srcModelScopeToken'),
    srcOssBucket?: string(name='srcOssBucket'),
    srcOssPath?: string(name='srcOssPath'),
    srcOssRegion?: string(name='srcOssRegion'),
    syncStrategy?: string(name='syncStrategy'),
  }(name='modelConfig'),
  name?: string(name='name', description='This parameter is required.'),
  nasConfig?: {
    groupId?: int32(name='groupId'),
    mountPoints?: [ string ](name='mountPoints'),
    userId?: int32(name='userId'),
  }(name='nasConfig'),
  originalName?: string(name='originalName'),
  projectName?: string(name='projectName'),
  provisionConfig?: {
    alwaysAllocateGPU?: boolean(name='alwaysAllocateGPU'),
    scheduledActions?: [ 
      {
        endTime?: string(name='endTime'),
        name?: string(name='name'),
        scheduleExpression?: string(name='scheduleExpression'),
        startTime?: string(name='startTime'),
        target?: int32(name='target'),
        timeZone?: string(name='timeZone'),
      }
    ](name='scheduledActions'),
    target?: int32(name='target'),
  }(name='provisionConfig'),
  region?: string(name='region'),
  reportStatusURL?: string(name='reportStatusURL'),
  role?: string(name='role', description='This parameter is required.'),
  timeout?: int32(name='timeout'),
  traceId?: string(name='traceId'),
  vpcConfig?: {
    securityGroupId?: string(name='securityGroupId'),
    vSwitchIds?: [ string ](name='vSwitchIds'),
    vpcId?: string(name='vpcId'),
  }(name='vpcConfig'),
}

model DeployModelScopeModelOutput {
  data?: {
    deploymentTaskID?: string(name='deploymentTaskID'),
    errorMessage?: string(name='errorMessage'),
    finished?: boolean(name='finished'),
    serviceName?: string(name='serviceName'),
    taskType?: string(name='taskType'),
    traceID?: string(name='traceID'),
    urlInternet?: string(name='urlInternet'),
    urlIntranet?: string(name='urlIntranet'),
  }(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId', description='This parameter is required.'),
  success?: boolean(name='success'),
}

model DeployOllamaModelAsyncOutput {
  data?: string(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId', description='This parameter is required.'),
  success?: boolean(name='success'),
}

model DeployOllamaModelInput {
  accountID?: string(name='accountID'),
  concurrencyConfig?: {
    reservedConcurrency?: int32(name='reservedConcurrency'),
  }(name='concurrencyConfig'),
  cpu?: float(name='cpu'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  envName?: string(name='envName'),
  environmentVariables?: map[string]any(name='environmentVariables'),
  gpuConfig?: {
    gpuMemorySize?: int32(name='gpuMemorySize'),
    gpuType?: string(name='gpuType'),
  }(name='gpuConfig'),
  httpTrigger?: {
    qualifier?: string(name='qualifier'),
    triggerConfig?: {
      authType?: string(name='authType'),
      disableURLInternet?: boolean(name='disableURLInternet'),
      dsableURLInternet?: boolean(name='dsableURLInternet'),
      methods?: [ string ](name='methods'),
    }(name='triggerConfig'),
  }(name='httpTrigger'),
  imageName?: string(name='imageName'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  logConfig?: {
    enableInstanceMetrics?: boolean(name='enableInstanceMetrics'),
    enableRequestMetrics?: boolean(name='enableRequestMetrics'),
    logBeginRule?: string(name='logBeginRule'),
    logstore?: string(name='logstore'),
    project?: string(name='project'),
  }(name='logConfig'),
  memorySize?: int32(name='memorySize'),
  modelConfig?: {
    fmkOllamaConfig?: {
      minP?: float(name='minP'),
      mirostat?: int32(name='mirostat'),
      mirostatEta?: float(name='mirostatEta'),
      mirostatTau?: float(name='mirostatTau'),
      modelName?: string(name='modelName'),
      modelfileAdapter?: string(name='modelfileAdapter'),
      modelfileAdditionalFromsString?: string(name='modelfileAdditionalFromsString'),
      modelfileFullTextPostfix?: string(name='modelfileFullTextPostfix'),
      modelfileParams?: string(name='modelfileParams'),
      modelfileSystem?: string(name='modelfileSystem'),
      modelfileTemplate?: string(name='modelfileTemplate'),
      numCtx?: int32(name='numCtx'),
      numPredict?: int32(name='numPredict'),
      quantize?: string(name='quantize'),
      repeatLastN?: int32(name='repeatLastN'),
      repeatPenalty?: float(name='repeatPenalty'),
      seed?: int32(name='seed'),
      singleModelFile?: string(name='singleModelFile'),
      splitedModelStartFile?: string(name='splitedModelStartFile'),
      stop?: string(name='stop'),
      stream?: boolean(name='stream'),
      temperature?: float(name='temperature'),
      tfsZ?: float(name='tfsZ'),
      topK?: int32(name='topK'),
      topP?: float(name='topP'),
    }(name='fmkOllamaConfig'),
    framework?: string(name='framework'),
    multiModelConfig?: [
      ModelConfig
    ](name='multiModelConfig', nullable=true),
    prefix?: string(name='prefix'),
    sourceType?: string(name='sourceType'),
    srcModelScopeModelID?: string(name='srcModelScopeModelID'),
    srcModelScopeModelRevision?: string(name='srcModelScopeModelRevision'),
    srcModelScopeToken?: string(name='srcModelScopeToken'),
    srcOssBucket?: string(name='srcOssBucket'),
    srcOssPath?: string(name='srcOssPath'),
    srcOssRegion?: string(name='srcOssRegion'),
    syncStrategy?: string(name='syncStrategy'),
  }(name='modelConfig'),
  name?: string(name='name', description='This parameter is required.'),
  nasConfig?: {
    groupId?: int32(name='groupId'),
    mountPoints?: [ string ](name='mountPoints'),
    userId?: int32(name='userId'),
  }(name='nasConfig'),
  originalName?: string(name='originalName'),
  projectName?: string(name='projectName'),
  provisionConfig?: {
    alwaysAllocateGPU?: boolean(name='alwaysAllocateGPU'),
    scheduledActions?: [ 
      {
        endTime?: string(name='endTime'),
        name?: string(name='name'),
        scheduleExpression?: string(name='scheduleExpression'),
        startTime?: string(name='startTime'),
        target?: int32(name='target'),
        timeZone?: string(name='timeZone'),
      }
    ](name='scheduledActions'),
    target?: int32(name='target'),
  }(name='provisionConfig'),
  region?: string(name='region'),
  reportStatusURL?: string(name='reportStatusURL'),
  role?: string(name='role', description='This parameter is required.'),
  timeout?: int32(name='timeout'),
  traceId?: string(name='traceId'),
  vpcConfig?: {
    securityGroupId?: string(name='securityGroupId'),
    vSwitchIds?: [ string ](name='vSwitchIds'),
    vpcId?: string(name='vpcId'),
  }(name='vpcConfig'),
}

model DeployOllamaModelOutput {
  data?: {
    deploymentTaskID?: string(name='deploymentTaskID'),
    errorMessage?: string(name='errorMessage'),
    finished?: boolean(name='finished'),
    modelName?: string(name='modelName'),
    serviceName?: string(name='serviceName'),
    traceID?: string(name='traceID'),
    urlInternet?: string(name='urlInternet'),
    urlIntranet?: string(name='urlIntranet'),
  }(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId', description='This parameter is required.'),
  success?: boolean(name='success'),
}

model DeploySGLangModelAsyncOutput {
  data?: string(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId', description='This parameter is required.'),
  success?: boolean(name='success'),
}

model DeploySGLangModelInput {
  accountID?: string(name='accountID'),
  concurrencyConfig?: {
    reservedConcurrency?: int32(name='reservedConcurrency'),
  }(name='concurrencyConfig'),
  cpu?: float(name='cpu'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  envName?: string(name='envName'),
  environmentVariables?: map[string]any(name='environmentVariables'),
  gpuConfig?: {
    gpuMemorySize?: int32(name='gpuMemorySize'),
    gpuType?: string(name='gpuType'),
  }(name='gpuConfig'),
  httpTrigger?: {
    qualifier?: string(name='qualifier'),
    triggerConfig?: {
      authType?: string(name='authType'),
      disableURLInternet?: boolean(name='disableURLInternet'),
      dsableURLInternet?: boolean(name='dsableURLInternet'),
      methods?: [ string ](name='methods'),
    }(name='triggerConfig'),
  }(name='httpTrigger'),
  imageName?: string(name='imageName'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  logConfig?: {
    enableInstanceMetrics?: boolean(name='enableInstanceMetrics'),
    enableRequestMetrics?: boolean(name='enableRequestMetrics'),
    logBeginRule?: string(name='logBeginRule'),
    logstore?: string(name='logstore'),
    project?: string(name='project'),
  }(name='logConfig'),
  memorySize?: int32(name='memorySize'),
  modelConfig?: {
    fmkSGLangConfig?: {
      apiKey?: string(name='apiKey'),
      chatTemplate?: string(name='chatTemplate'),
      dtype?: string(name='dtype'),
      fullTextPostfix?: string(name='fullTextPostfix'),
      loadFormat?: string(name='loadFormat'),
      maxRunningRequests?: int32(name='maxRunningRequests'),
      maxTotalTokens?: int32(name='maxTotalTokens'),
      memFractionStatic?: float(name='memFractionStatic'),
      quantization?: string(name='quantization'),
      servedModelName?: string(name='servedModelName'),
    }(name='fmkSGLangConfig'),
    framework?: string(name='framework'),
    multiModelConfig?: [
      ModelConfig
    ](name='multiModelConfig', nullable=true),
    prefix?: string(name='prefix'),
    sourceType?: string(name='sourceType'),
    srcModelScopeModelID?: string(name='srcModelScopeModelID'),
    srcModelScopeModelRevision?: string(name='srcModelScopeModelRevision'),
    srcModelScopeToken?: string(name='srcModelScopeToken'),
    srcOssBucket?: string(name='srcOssBucket'),
    srcOssPath?: string(name='srcOssPath'),
    srcOssRegion?: string(name='srcOssRegion'),
    syncStrategy?: string(name='syncStrategy'),
  }(name='modelConfig'),
  name?: string(name='name', description='This parameter is required.'),
  nasConfig?: {
    groupId?: int32(name='groupId'),
    mountPoints?: [ 
      {
        enableTLS?: boolean(name='enableTLS'),
        mountDir?: string(name='mountDir'),
        serverAddr?: string(name='serverAddr'),
      }
    ](name='mountPoints'),
    userId?: int32(name='userId'),
  }(name='nasConfig'),
  originalName?: string(name='originalName'),
  projectName?: string(name='projectName'),
  provisionConfig?: {
    alwaysAllocateGPU?: boolean(name='alwaysAllocateGPU'),
    scheduledActions?: [ 
      {
        endTime?: string(name='endTime'),
        name?: string(name='name'),
        scheduleExpression?: string(name='scheduleExpression'),
        startTime?: string(name='startTime'),
        target?: int32(name='target'),
        timeZone?: string(name='timeZone'),
      }
    ](name='scheduledActions'),
    target?: int32(name='target'),
  }(name='provisionConfig'),
  region?: string(name='region'),
  reportStatusURL?: string(name='reportStatusURL'),
  role?: string(name='role', description='This parameter is required.'),
  timeout?: int32(name='timeout'),
  traceId?: string(name='traceId'),
  vpcConfig?: {
    securityGroupId?: string(name='securityGroupId'),
    vSwitchIds?: [ string ](name='vSwitchIds'),
    vpcId?: string(name='vpcId'),
  }(name='vpcConfig'),
}

model DeploySGLangModelOutput {
  data?: {
    deploymentTaskID?: string(name='deploymentTaskID'),
    errorMessage?: string(name='errorMessage'),
    finished?: boolean(name='finished'),
    modelName?: string(name='modelName'),
    serviceName?: string(name='serviceName'),
    traceID?: string(name='traceID'),
    urlInternet?: string(name='urlInternet'),
    urlIntranet?: string(name='urlIntranet'),
  }(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId', description='This parameter is required.'),
  success?: boolean(name='success'),
}

model DeployTensorRtModelAsyncOutput {
  data?: string(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId', description='This parameter is required.'),
  success?: boolean(name='success'),
}

model DeployTensorRtModelInput {
  accountID?: string(name='accountID'),
  concurrencyConfig?: {
    reservedConcurrency?: int32(name='reservedConcurrency'),
  }(name='concurrencyConfig'),
  cpu?: float(name='cpu'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  envName?: string(name='envName'),
  environmentVariables?: map[string]any(name='environmentVariables'),
  gpuConfig?: {
    gpuMemorySize?: int32(name='gpuMemorySize'),
    gpuType?: string(name='gpuType'),
  }(name='gpuConfig'),
  httpTrigger?: {
    qualifier?: string(name='qualifier'),
    triggerConfig?: {
      authType?: string(name='authType'),
      disableURLInternet?: boolean(name='disableURLInternet'),
      dsableURLInternet?: boolean(name='dsableURLInternet'),
      methods?: [ string ](name='methods'),
    }(name='triggerConfig'),
  }(name='httpTrigger'),
  imageName?: string(name='imageName'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  logConfig?: {
    enableInstanceMetrics?: boolean(name='enableInstanceMetrics'),
    enableRequestMetrics?: boolean(name='enableRequestMetrics'),
    logBeginRule?: string(name='logBeginRule'),
    logstore?: string(name='logstore'),
    project?: string(name='project'),
  }(name='logConfig'),
  memorySize?: int32(name='memorySize'),
  modelConfig?: {
    framework?: string(name='framework'),
    multiModelConfig?: [
      ModelConfig
    ](name='multiModelConfig', nullable=true),
    prefix?: string(name='prefix'),
    sourceType?: string(name='sourceType'),
    srcModelScopeModelID?: string(name='srcModelScopeModelID'),
    srcModelScopeModelRevision?: string(name='srcModelScopeModelRevision'),
    srcModelScopeToken?: string(name='srcModelScopeToken'),
    srcOssBucket?: string(name='srcOssBucket'),
    srcOssPath?: string(name='srcOssPath'),
    srcOssRegion?: string(name='srcOssRegion'),
    syncStrategy?: string(name='syncStrategy'),
  }(name='modelConfig'),
  name?: string(name='name', description='This parameter is required.'),
  nasConfig?: {
    groupId?: int32(name='groupId'),
    mountPoints?: [ 
      {
        enableTLS?: boolean(name='enableTLS'),
        mountDir?: string(name='mountDir'),
        serverAddr?: string(name='serverAddr'),
      }
    ](name='mountPoints'),
    userId?: int32(name='userId'),
  }(name='nasConfig'),
  originalName?: string(name='originalName'),
  projectName?: string(name='projectName'),
  provisionConfig?: {
    alwaysAllocateGPU?: boolean(name='alwaysAllocateGPU'),
    scheduledActions?: [ 
      {
        endTime?: string(name='endTime'),
        name?: string(name='name'),
        scheduleExpression?: string(name='scheduleExpression'),
        startTime?: string(name='startTime'),
        target?: int32(name='target'),
        timeZone?: string(name='timeZone'),
      }
    ](name='scheduledActions'),
    target?: int32(name='target'),
  }(name='provisionConfig'),
  region?: string(name='region'),
  reportStatusURL?: string(name='reportStatusURL'),
  role?: string(name='role', description='This parameter is required.'),
  timeout?: int32(name='timeout'),
  traceId?: string(name='traceId'),
  vpcConfig?: {
    securityGroupId?: string(name='securityGroupId'),
    vSwitchIds?: [ string ](name='vSwitchIds'),
    vpcId?: string(name='vpcId'),
  }(name='vpcConfig'),
}

model DeployTensorRtModelOutput {
  data?: {
    deploymentTaskID?: string(name='deploymentTaskID'),
    errorMessage?: string(name='errorMessage'),
    finished?: boolean(name='finished'),
    serviceName?: string(name='serviceName'),
    traceID?: string(name='traceID'),
    urlInternet?: string(name='urlInternet'),
    urlIntranet?: string(name='urlIntranet'),
  }(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId', description='This parameter is required.'),
  success?: boolean(name='success'),
}

model DeployVllmModelAsyncOutput {
  data?: string(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId', description='This parameter is required.'),
  success?: boolean(name='success'),
}

model DeployVllmModelInput {
  accountID?: string(name='accountID'),
  concurrencyConfig?: {
    reservedConcurrency?: int32(name='reservedConcurrency'),
  }(name='concurrencyConfig'),
  cpu?: float(name='cpu'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  envName?: string(name='envName'),
  environmentVariables?: map[string]any(name='environmentVariables'),
  gpuConfig?: {
    gpuMemorySize?: int32(name='gpuMemorySize'),
    gpuType?: string(name='gpuType'),
  }(name='gpuConfig'),
  httpTrigger?: {
    qualifier?: string(name='qualifier'),
    triggerConfig?: {
      authType?: string(name='authType'),
      disableURLInternet?: boolean(name='disableURLInternet'),
      dsableURLInternet?: boolean(name='dsableURLInternet'),
      methods?: [ string ](name='methods'),
    }(name='triggerConfig'),
  }(name='httpTrigger'),
  imageName?: string(name='imageName'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  logConfig?: {
    enableInstanceMetrics?: boolean(name='enableInstanceMetrics'),
    enableRequestMetrics?: boolean(name='enableRequestMetrics'),
    logBeginRule?: string(name='logBeginRule'),
    logstore?: string(name='logstore'),
    project?: string(name='project'),
  }(name='logConfig'),
  memorySize?: int32(name='memorySize'),
  modelConfig?: {
    fmkVllmConfig?: {
      apiKey?: string(name='apiKey'),
      blockSize?: int32(name='blockSize'),
      chatTemplate?: string(name='chatTemplate'),
      dtype?: string(name='dtype'),
      fullTextPostfix?: string(name='fullTextPostfix'),
      gpuMemoryUtilization?: float(name='gpuMemoryUtilization'),
      loadFormat?: string(name='loadFormat'),
      maxModelLen?: int32(name='maxModelLen'),
      maxParallelLoadingWorkers?: int32(name='maxParallelLoadingWorkers'),
      quantization?: string(name='quantization'),
      servedModelName?: string(name='servedModelName'),
      swapSpace?: int32(name='swapSpace'),
    }(name='fmkVllmConfig'),
    framework?: string(name='framework'),
    multiModelConfig?: [
      ModelConfig
    ](name='multiModelConfig', nullable=true),
    prefix?: string(name='prefix'),
    sourceType?: string(name='sourceType'),
    srcModelScopeModelID?: string(name='srcModelScopeModelID'),
    srcModelScopeModelRevision?: string(name='srcModelScopeModelRevision'),
    srcModelScopeToken?: string(name='srcModelScopeToken'),
    srcOssBucket?: string(name='srcOssBucket'),
    srcOssPath?: string(name='srcOssPath'),
    srcOssRegion?: string(name='srcOssRegion'),
    syncStrategy?: string(name='syncStrategy'),
  }(name='modelConfig'),
  name?: string(name='name', description='This parameter is required.'),
  nasConfig?: {
    groupId?: int32(name='groupId'),
    mountPoints?: [ 
      {
        enableTLS?: boolean(name='enableTLS'),
        mountDir?: string(name='mountDir'),
        serverAddr?: string(name='serverAddr'),
      }
    ](name='mountPoints'),
    userId?: int32(name='userId'),
  }(name='nasConfig'),
  originalName?: string(name='originalName'),
  projectName?: string(name='projectName'),
  provisionConfig?: {
    alwaysAllocateGPU?: boolean(name='alwaysAllocateGPU'),
    scheduledActions?: [ 
      {
        endTime?: string(name='endTime'),
        name?: string(name='name'),
        scheduleExpression?: string(name='scheduleExpression'),
        startTime?: string(name='startTime'),
        target?: int32(name='target'),
        timeZone?: string(name='timeZone'),
      }
    ](name='scheduledActions'),
    target?: int32(name='target'),
  }(name='provisionConfig'),
  region?: string(name='region'),
  reportStatusURL?: string(name='reportStatusURL'),
  role?: string(name='role', description='This parameter is required.'),
  timeout?: int32(name='timeout'),
  traceId?: string(name='traceId'),
  vpcConfig?: {
    securityGroupId?: string(name='securityGroupId'),
    vSwitchIds?: [ string ](name='vSwitchIds'),
    vpcId?: string(name='vpcId'),
  }(name='vpcConfig'),
}

model DeployVllmModelOutput {
  data?: {
    deploymentTaskID?: string(name='deploymentTaskID'),
    errorMessage?: string(name='errorMessage'),
    finished?: boolean(name='finished'),
    modelName?: string(name='modelName'),
    serviceName?: string(name='serviceName'),
    traceID?: string(name='traceID'),
    urlInternet?: string(name='urlInternet'),
    urlIntranet?: string(name='urlIntranet'),
  }(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId', description='This parameter is required.'),
  success?: boolean(name='success'),
}

model DownloadModelOutput {
  data?: {
    modelPath?: string(name='modelPath'),
    taskType?: string(name='taskType'),
  }(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId', description='This parameter is required.'),
  success?: boolean(name='success'),
}

model Environment {
  createdTime?: string(name='createdTime', example='2021-11-19T09:34:38Z'),
  description?: string(name='description', example='test env'),
  generation?: int32(name='generation', example='1'),
  kind?: string(name='kind', example='Environment'),
  labels?: map[string]string(name='labels'),
  name?: string(name='name', description='This parameter is required.', example='demo-env'),
  projectName?: string(name='projectName', example='demo-project'),
  spec?: EnvironmentSpec(name='spec', description='This parameter is required.'),
  status?: EnvironmentStatus(name='status'),
  uid?: string(name='uid', example='1455541096***548'),
}

model EnvironmentBaseline {
  servicesInstances?: map[string]ServiceInstance(name='servicesInstances'),
  variables?: map[string]Variable(name='variables'),
}

model EnvironmentChanges {
  services?: map[string]any(name='services'),
}

model EnvironmentDeployment {
  createdTime?: string(name='createdTime', example='2021-11-19T09:34:38Z'),
  description?: string(name='description', example='commit by xxx.'),
  kind?: string(name='kind', example='Deployment'),
  labels?: map[string]string(name='labels'),
  name?: string(name='name', description='This parameter is required.', example='my-deployment'),
  spec?: EnvironmentDeploymentSpec(name='spec'),
  status?: EnvironmentDeploymentStatus(name='status'),
  uid?: string(name='uid', example='1455541096***548'),
}

model EnvironmentDeploymentSpec {
  baseline?: EnvironmentSnapshot(name='baseline'),
  changes?: EnvironmentChanges(name='changes'),
  skipRemoveResources?: boolean(name='skipRemoveResources', example='false'),
  target?: EnvironmentStagedConfigs(name='target'),
  webhookCodeContext?: WebhookCodeContext(name='webhookCodeContext'),
}

model EnvironmentDeploymentStatus {
  finishedTime?: string(name='finishedTime'),
  phase?: string(name='phase', example='Running'),
  pipelineName?: string(name='pipelineName', example='my-pipeline'),
  serviceDeployments?: map[string]string(name='serviceDeployments'),
}

model EnvironmentSnapshot {
  services?: map[string]ServiceInstance(name='services'),
}

model EnvironmentSpec {
  roleArn?: string(name='roleArn', example='acs:ram::*******:role/aliyundevsdefaultrole'),
  stagedConfigs?: EnvironmentStagedConfigs(name='stagedConfigs'),
  type?: string(name='type', example='Testing'),
}

model EnvironmentStagedConfigs {
  services?: map[string]ServiceConfig(name='services'),
  variables?: map[string]Variable(name='variables'),
}

model EnvironmentStatus {
  latestEnvironmentDeploymentName?: string(name='latestEnvironmentDeploymentName'),
  observedGeneration?: long(name='observedGeneration', example='1'),
  observedTime?: string(name='observedTime', example='2021-11-19T09:34:38Z'),
  servicesInstances?: map[string]ServiceInstance(name='servicesInstances'),
  servicesWithPendingChanges?: [ string ](name='servicesWithPendingChanges'),
}

model EventFilterConfig {
  branch?: BranchFilter(name='branch'),
}

model FinalizeConfig {
  steps?: [ any ](name='steps'),
}

model GetModelStatusOutput {
  data?: {
    currentBytes?: long(name='currentBytes'),
    errMessage?: string(name='errMessage'),
    fileSize?: long(name='fileSize'),
    finished?: boolean(name='finished'),
    finishedTime?: long(name='finishedTime'),
    speed?: long(name='speed'),
    startTime?: long(name='startTime'),
    total?: long(name='total'),
  }(name='data'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GitAccount {
  avatar?: string(name='avatar', example='https://gitee.com/assets/no_portrait.png'),
  displayName?: string(name='displayName', example='your_displayname'),
  id?: string(name='id', example='1'),
  name?: string(name='name', example='your_username'),
  uri?: string(name='uri', example='https://gitlab.com'),
}

model GitEventSnapshot {
  branch?: string(name='branch', example='main'),
  commitID?: string(name='commitID', example='12721ec262d03a93809ba2bbc717963cb298ceca'),
  tag?: string(name='tag', example='1.0'),
}

model GitLabConfig {
  token?: string(name='token', example='your-token'),
  uri?: string(name='uri', example='http://gitlab.c16194660f14898a0810408171302ac.cn-shanghai.alicontainer.com/'),
}

model InitializeConfig {
  steps?: [ any ](name='steps'),
}

model Installation {
  actionUri?: string(name='actionUri', example='https://github.com/login/oauth/authorize?client_id=86059a1b2bb20d3e5fc3&scope=repo,repo:status,delete_repo'),
  message?: string(name='message', example='Please click \\"actionUri\\" to complete the OAuth authorization process'),
  stage?: string(name='stage', example='finished'),
}

model MCPInstallationConfig {
  mcpServers?: MCPServerInstallationConfig(name='mcpServers'),
}

model MCPServerInstallationConfig {
  args?: string(name='args'),
  command?: string(name='command'),
  env?: map[string]string(name='env'),
  transportType?: string(name='transportType'),
  url?: string(name='url'),
}

model ModelAsyncTask {
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  finished?: boolean(name='finished'),
  finishedTime?: long(name='finishedTime'),
  result?: any(name='result'),
  startTime?: long(name='startTime'),
  taskType?: string(name='taskType'),
  updateTime?: long(name='updateTime'),
}

model ModelConfig {
  bucket?: string(name='bucket'),
  framework?: string(name='framework'),
  model?: string(name='model'),
  multiModelConfig?: [
    ModelConfig
  ](name='multiModelConfig', nullable=true),
  path?: string(name='path'),
  prefix?: string(name='prefix'),
  region?: string(name='region'),
  reversion?: string(name='reversion'),
  token?: string(name='token'),
  type?: string(name='type', description='This parameter is required.', example='modelscope'),
}

model ModelFile {
  isDir?: boolean(name='isDir'),
  modeTime?: long(name='modeTime'),
  name?: string(name='name'),
  path?: string(name='path'),
  size?: long(name='size'),
}

model ModelFilePreview {
  content?: string(name='content'),
  hash?: string(name='hash'),
  isCompressedImage?: boolean(name='isCompressedImage'),
  isDir?: boolean(name='isDir'),
  name?: string(name='name'),
  path?: string(name='path'),
  size?: long(name='size'),
  unpreviewable?: boolean(name='unpreviewable'),
}

model ModelProvider {
  createdTime?: string(name='createdTime', example='2021-11-19T09:34:38Z'),
  description?: string(name='description', example='test-description'),
  kind?: string(name='kind', example='Toolset'),
  labels?: map[string]string(name='labels'),
  name?: string(name='name', description='This parameter is required.', example='my-toolset'),
  uid?: string(name='uid', example='1455541096***548'),
}

model ModelProviderAuthorization {
  authConfig?: map[string]string(name='authConfig'),
  type?: string(name='type', example='apiKey'),
}

model ModelProviderSchema {
  detail?: string(name='detail'),
  type?: string(name='type', example='OpenAPI'),
}

model ModelProviderSpec {
  authorization?: ModelProviderAuthorization(name='authorization'),
  schema?: ModelProviderSchema(name='schema'),
}

model ModelTask {
  currentBytes?: string(name='currentBytes'),
  errCode?: string(name='errCode'),
  errMsg?: string(name='errMsg'),
  extra?: any(name='extra'),
  fileSize?: double(name='fileSize', deprecated=true),
  finishTime?: double(name='finishTime', deprecated=true),
  finished?: boolean(name='finished'),
  finishedTime?: double(name='finishedTime'),
  id?: string(name='id'),
  params?: string(name='params'),
  result?: any(name='result'),
  speed?: string(name='speed'),
  startTime?: double(name='startTime'),
  status?: string(name='status'),
  taskId?: string(name='taskId'),
  taskType?: string(name='taskType'),
  total?: float(name='total', deprecated=true),
  totalBytes?: string(name='totalBytes'),
  updateTime?: double(name='updateTime'),
}

model OAuthCredential {
  createdTime?: long(name='createdTime', description='This parameter is required.', example='1716176924603'),
  expiration?: long(name='expiration', description='This parameter is required.', example='1716263324603'),
  refreshToken?: string(name='refreshToken', example='4d77bfae284770d94ebeed6b0199ebfd65e3943ba4f1e44dc36d792a93ba0d13'),
  scope?: string(name='scope', example='user_info projects pull_requests hook gists emails'),
  token?: string(name='token', description='This parameter is required.', example='4e84246b6b3962cd3d207aad1ea2f911'),
  type?: string(name='type', example='bearer'),
}

model OperationModelFileAction {
  action?: string(name='action', description='This parameter is required.'),
  destination?: string(name='destination'),
  source?: string(name='source'),
  target?: string(name='target'),
}

model OssSourceConfig {
  bucket?: string(name='bucket', example='demo-bucket'),
  object?: string(name='object', example='demo-object'),
}

model Pipeline {
  createdTime?: string(name='createdTime', example='2021-11-19T09:34:38Z'),
  description?: string(name='description', example='Pipeline example.'),
  generation?: int32(name='generation', example='1'),
  kind?: string(name='kind', example='Pipeline'),
  labels?: map[string]string(name='labels'),
  name?: string(name='name', description='This parameter is required.', example='my-pipeline'),
  resourceVersion?: int32(name='resourceVersion', example='1'),
  spec?: PipelineSpec(name='spec'),
  status?: PipelineStatus(name='status'),
  uid?: string(name='uid', example='1455541096***548'),
}

model PipelineSpec {
  context?: Context(name='context'),
  templateName?: string(name='templateName', example='my-pipeline-template'),
  templateSpec?: PipelineTemplateSpec(name='templateSpec'),
}

model PipelineStatus {
  latestExecError?: TaskExecError(name='latestExecError'),
  phase?: string(name='phase', example='Success'),
}

model PipelineTemplate {
  createdTime?: string(name='createdTime', example='2021-11-19T09:34:38Z'),
  deletionTime?: string(name='deletionTime', example='2021-11-19T09:34:38Z'),
  description?: string(name='description', example='PipelineTemplate example.'),
  generation?: int32(name='generation', example='1'),
  kind?: string(name='kind', example='PipelineTemplate'),
  labels?: map[string]string(name='labels'),
  name?: string(name='name', description='This parameter is required.', example='my-pipeline-template'),
  resourceVersion?: int32(name='resourceVersion', example='1'),
  spec?: PipelineTemplateSpec(name='spec'),
  uid?: string(name='uid', example='1455541096***548'),
}

model PipelineTemplateSpec {
  context?: Context(name='context'),
  tasks?: [
    TaskExec
  ](name='tasks'),
}

model Project {
  createdTime?: string(name='createdTime', example='2021-11-19T09:34:38Z'),
  description?: string(name='description', example='test-description'),
  kind?: string(name='kind', example='Project'),
  labels?: map[string]string(name='labels'),
  name?: string(name='name', description='This parameter is required.', example='my-project'),
  status?: ProjectStatus(name='status'),
  uid?: string(name='uid', example='1455541096***548'),
}

model ProjectSpec {
}

model ProjectStatus {
  services?: [
    ServiceMeta
  ](name='services'),
}

model PullRequestFilter {
  sourceBranch?: string(name='sourceBranch', example='feature-.*'),
  targetBranch?: string(name='targetBranch', example='master'),
  types?: [ string ](name='types'),
}

model PushFilter {
  branch?: string(name='branch', example='master'),
  tag?: string(name='tag', example='prod-.*'),
}

model Repository {
  createdTime?: string(name='createdTime', example='2021-11-19T09:34:38Z'),
  description?: string(name='description', example='test-description'),
  kind?: string(name='kind', example='Repository'),
  labels?: map[string]string(name='labels'),
  name?: string(name='name', description='This parameter is required.', example='my-repository'),
  spec?: RepositorySpec(name='spec', description='This parameter is required.'),
  uid?: string(name='uid', example='1455541096***548'),
}

model RepositorySourceConfig {
  codeVersion?: CodeVersionReference(name='codeVersion'),
  filter?: EventFilterConfig(name='filter'),
  repositoryName?: string(name='repositoryName', description='This parameter is required.', example='my-repository'),
}

model RepositorySpec {
  cloneUrl?: string(name='cloneUrl', description='This parameter is required.', example='https://github.com/DDofDD/start-springboot-lfgy.git'),
  connectionName?: string(name='connectionName', description='This parameter is required.', example='awesome-connection'),
  displayName?: string(name='displayName', example='my-repo-name'),
  id?: long(name='id', example='312649'),
  owner?: string(name='owner', example='my-org-name'),
  platform?: string(name='platform', example='github'),
  webUrl?: string(name='webUrl', example='https://github.com/my-org-name/my-repo-name'),
}

model RunAfter {
  name?: string(name='name', example='task-1'),
}

model ServiceBaseline {
  serviceInstance?: ServiceInstance(name='serviceInstance'),
}

model ServiceChanges {
  merge?: map[string]any(name='merge', example='{}: 不进行修改'),
}

model ServiceCommandStep {
  path?: string(name='path', example='./'),
  run?: string(name='run', example='s invoke'),
}

model ServiceComponentStep {
  component?: string(name='component', example='fc3 invoke'),
}

model ServiceConfig {
  artifact?: ArtifactMeta(name='artifact'),
  build?: BuildConfig(name='build'),
  component?: string(name='component', example='fc3@1.0.0'),
  props?: map[string]any(name='props'),
  source?: SourceConfig(name='source'),
  type?: string(name='type', example='Function'),
  variables?: map[string]Variable(name='variables'),
}

model ServiceDeployment {
  createdTime?: string(name='createdTime', example='2021-11-19T09:34:38Z'),
  description?: string(name='description', example='commit by xxx.'),
  environmentDeploymentName?: string(name='environmentDeploymentName', example='my-environment-deployment'),
  kind?: string(name='kind', example='Deployment'),
  labels?: map[string]string(name='labels'),
  name?: string(name='name', description='This parameter is required.', example='my-deployment'),
  status?: ServiceDeploymentStatus(name='status'),
  uid?: string(name='uid', example='1455541096***548'),
}

model ServiceDeploymentSpec {
  baseline?: ServiceBaseline(name='baseline'),
  changes?: ServiceChanges(name='changes'),
  skipRemoveResources?: boolean(name='skipRemoveResources', example='false'),
  target?: ServiceBaseline(name='target'),
}

model ServiceDeploymentStatus {
  finishedTime?: string(name='finishedTime'),
  phase?: string(name='phase', example='Running'),
  pipelineName?: string(name='pipelineName', example='my-pipeline'),
  startTime?: string(name='startTime'),
  taskName?: string(name='taskName', example='my-task'),
}

model ServiceInstance {
  config?: ServiceConfig(name='config'),
  latestDeployment?: {
    finishedTime?: string(name='finishedTime'),
    name?: string(name='name'),
    phase?: string(name='phase', example='Running'),
    startTime?: string(name='startTime'),
  }(name='latestDeployment'),
  outputs?: map[string]any(name='outputs', example='{}'),
  variables?: map[string]Variable(name='variables'),
}

model ServiceMeta {
  name?: string(name='name', example='my-service'),
  type?: string(name='type', example='fc3'),
}

model ServicePluginStep {
  args?: map[string]any(name='args', example='{"key":"value"}'),
  plugin?: string(name='plugin', example='dingding-robot'),
}

model SourceConfig {
  oss?: OssSourceConfig(name='oss'),
  repository?: RepositorySourceConfig(name='repository'),
  template?: TemplateSourceConfig(name='template'),
}

model Task {
  createdTime?: string(name='createdTime', example='2021-11-19T09:34:38Z'),
  description?: string(name='description', example='Task example.'),
  generation?: int32(name='generation', example='1'),
  kind?: string(name='kind', example='Task'),
  labels?: map[string]string(name='labels'),
  name?: string(name='name', description='This parameter is required.', example='my-task'),
  resourceVersion?: int32(name='resourceVersion', example='1'),
  spec?: TaskSpec(name='spec'),
  status?: TaskStatus(name='status'),
  uid?: string(name='uid', example='1455541096***548'),
}

model TaskExec {
  context?: Context(name='context'),
  name?: string(name='name', example='task-1'),
  runAfters?: [
    RunAfter
  ](name='runAfters'),
  taskTemplate?: string(name='taskTemplate', example='serverless-runner'),
}

model TaskExecError {
  code?: string(name='code', example='AccessDenied'),
  extraInfo?: string(name='extraInfo', example='部署辅助函数权限不足，需要添加额外的权限以解决问题。https://help.aliyun.com'),
  message?: string(name='message', example='部署服务[_appcenter-xxx]失败，权限不足'),
  requestId?: string(name='requestId', example='1-26d1287xxxxx'),
  title?: string(name='title', example='权限不足错误'),
}

model TaskInvocation {
  instanceID?: string(name='instanceID', example='c-nkj8shz7xxxx'),
  invocationID?: string(name='invocationID', example='E099843B-10A2-4936-9964-4E0EE263D564'),
  invocationTarget?: string(name='invocationTarget', example='acs:fc:cn-hangzhou:143xxxx:services/xxx.LATEST/functions/xxx'),
  output?: string(name='output', example='{"key1":"value1","key2":"value2"}'),
  requestID?: string(name='requestID', example='1B3058B1-F1C9-457C-B95C-2C250A4B3118'),
  slsLogStore?: string(name='slsLogStore', example='my-sls-logstore'),
  slsProject?: string(name='slsProject', example='my-sls-project'),
  status?: string(name='status', example='success'),
}

model TaskSpec {
  context?: Context(name='context'),
  templateName?: string(name='templateName', example='my-task-template'),
}

model TaskStatus {
  executionDetails?: [ string ](name='executionDetails'),
  invocations?: [
    TaskInvocation
  ](name='invocations'),
  latestExecError?: TaskExecError(name='latestExecError'),
  phase?: string(name='phase', example='Success'),
  statusGeneration?: long(name='statusGeneration', example='123'),
}

model TaskTemplate {
  createdTime?: string(name='createdTime', example='2021-11-19T09:34:38Z'),
  deletionTime?: string(name='deletionTime', example='2021-11-19T09:34:38Z'),
  description?: string(name='description', example='TaskTemplate example.'),
  generation?: int32(name='generation', example='1'),
  kind?: string(name='kind', example='TaskTemplate'),
  labels?: map[string]string(name='labels'),
  name?: string(name='name', description='This parameter is required.', example='my-task-template'),
  resourceVersion?: int32(name='resourceVersion', example='1'),
  spec?: TaskTemplateSpec(name='spec'),
  uid?: string(name='uid', example='1455541096***548'),
}

model TaskTemplateSpec {
  context?: Context(name='context'),
  description?: string(name='description', example='build&deploy.'),
  executeCondition?: Condition(name='executeCondition'),
  worker?: TaskWorker(name='worker'),
}

model TaskWorker {
  presetWorker?: string(name='presetWorker', example='serverless-runner'),
}

model Template {
  createdTime?: string(name='createdTime', example='2021-11-19T09:34:38Z'),
  description?: string(name='description', example='It is a template'),
  kind?: string(name='kind', example='Template'),
  labels?: map[string]string(name='labels'),
  name?: string(name='name', example='demo-template'),
  spec?: TemplateSpec(name='spec'),
  status?: TemplateStatus(name='status'),
  uid?: string(name='uid', example='1455541096***548'),
}

model TemplateConfig {
  parameters?: map[string]string(name='parameters', example='{"region":"cn-hangzhou"}'),
  serviceNameChanges?: map[string]string(name='serviceNameChanges', example='{"svc1":"svc2"}'),
  templateName?: string(name='templateName', description='This parameter is required.', example='start-springboot'),
  variableValues?: TemplateVariableValueMap(name='variableValues'),
}

model TemplateParameterSchema {
  default?: any(name='default', example='defaultValue'),
  description?: string(name='description', example='Parameters for testing'),
  enum?: [ string ](name='enum'),
  pattern?: string(name='pattern', example='"^[a-zA-Z._-]+$"'),
  required?: boolean(name='required', example='true'),
  roleExtension?: {
    authorities?: [ string ](name='authorities'),
    name?: string(name='name'),
    service?: string(name='service'),
  }(name='roleExtension'),
  sensitive?: boolean(name='sensitive', example='false'),
  title?: string(name='title', example='demo'),
  type?: string(name='type', description='This parameter is required.', example='string'),
}

model TemplateRevision {
  createdTime?: string(name='createdTime', example='2021-11-19T09:34:38Z'),
  description?: string(name='description', example='It is a template revision'),
  kind?: string(name='kind', example='TemplateRevision'),
  labels?: map[string]string(name='labels'),
  name?: string(name='name', example='demo-template'),
  spec?: TemplateSpec(name='spec'),
  status?: {
    packageUrl?: string(name='packageUrl', example='https://registry.serverless-devs.com/details.html?name=template-test&package_type=v3'),
    phase?: string(name='phase', example='Published'),
    pipelineName?: string(name='pipelineName', example='p-default'),
    templateUrl?: string(name='templateUrl', example='https://cap.console.aliyun.com/template-detail?template=adasdasdaewe-adadqwe'),
  }(name='status'),
  templateName?: string(name='templateName', example='demo-template'),
  uid?: string(name='uid', example='1455541096***548'),
}

model TemplateServiceConfig {
  artifact?: ArtifactMeta(name='artifact'),
  build?: BuildConfig(name='build'),
  component?: string(name='component', example='fc3@1.0.0'),
  props?: map[string]any(name='props'),
  source?: SourceConfig(name='source'),
  type?: string(name='type', example='Function'),
  variables?: map[string]TemplateParameterSchema(name='variables'),
}

model TemplateSourceConfig {
  downloadUrl?: string(name='downloadUrl', example='https://api.devsapp.cn/v3/packages/start-modelscope-v3/zipball/0.1.6'),
  name?: string(name='name', example='start-springboot-cap'),
}

model TemplateSpec {
  author?: string(name='author', description='This parameter is required.', example='CAP'),
  category?: string(name='category', description='This parameter is required.', example='AI'),
  license?: string(name='license', example='Apache-1.0'),
  packageName?: string(name='packageName', example='demo-package'),
  readme?: string(name='readme', description='This parameter is required.'),
  registryToken?: string(name='registryToken'),
  services?: map[string]TemplateServiceConfig(name='services'),
  source?: {
    repository?: RepositorySourceConfig(name='repository'),
  }(name='source'),
  variables?: map[string]TemplateParameterSchema(name='variables'),
  version?: string(name='version'),
}

model TemplateStatus {
  latestDeployment?: {
    finishedTime?: string(name='finishedTime'),
    phase?: string(name='phase', example='BuildFinished'),
    pipelineName?: string(name='pipelineName'),
    startTime?: string(name='startTime'),
  }(name='latestDeployment'),
  latestVersion?: string(name='latestVersion', example='1.0.0'),
  packageUrl?: string(name='packageUrl', example='https://registry.serverless-devs.com/details.html?name=template-test&package_type=v3'),
  phase?: string(name='phase', example='Published'),
  templateUrl?: string(name='templateUrl', example='https://cap.console.aliyun.com/template-detail?template=adasdasdaewe-adadqwe'),
}

model TemplateVariableValueMap {
  services?: map[string]object(name='services'),
  shared?: map[string]any(name='shared', example='{"TEST_KEY":"new_value"}'),
}

model Tool {
  method?: string(name='method'),
  path?: string(name='path'),
  toolId?: string(name='toolId'),
  toolName?: string(name='toolName'),
}

model Toolset {
  createdTime?: string(name='createdTime', example='2021-11-19T09:34:38Z'),
  description?: string(name='description', example='test-description'),
  kind?: string(name='kind', example='Toolset'),
  labels?: map[string]string(name='labels'),
  name?: string(name='name', description='This parameter is required.', example='my-toolset'),
  spec?: ToolsetSpec(name='spec'),
  status?: ToolsetStatus(name='status'),
  uid?: string(name='uid', example='1455541096***548'),
}

model ToolsetAuthorization {
  authConfig?: map[string]string(name='authConfig'),
  type?: string(name='type', example='apiKey'),
}

model ToolsetSchema {
  detail?: string(name='detail'),
  type?: string(name='type', example='OpenAPI'),
}

model ToolsetSpec {
  schema?: ToolsetSchema(name='schema'),
}

model ToolsetStatus {
  observedGeneration?: long(name='observedGeneration'),
  observedTime?: string(name='observedTime'),
  outputs?: map[string]any(name='outputs'),
  phase?: string(name='phase', example='Installed'),
}

model Variable {
  encrypted?: boolean(name='encrypted', example='false'),
  sensitive?: boolean(name='sensitive', example='false'),
  value?: any(name='value', example='object_value'),
}

model WebhookCodeContext {
  branch?: string(name='branch', example='master'),
  commitID?: string(name='commitID', example='b1dd9ba168dfef1cb3a1dd608b6054c771a93959'),
  description?: string(name='description', example='my PR decscription'),
  eventType?: string(name='eventType', example='PUSH'),
  message?: string(name='message', example='commit message'),
  prType?: string(name='prType', example='merged'),
  repoUrl?: string(name='repoUrl', example='https://codeup.aliyun.com/my-namespace/my-repo.git'),
  sourceBranch?: string(name='sourceBranch', example='master'),
  tag?: string(name='tag', example='release-0.0.1'),
  targetBranch?: string(name='targetBranch', example='master'),
  title?: string(name='title', example='# FIX'),
}

model OpenStructOssSourceConfig {
  bucket?: string(name='bucket', example='demo-bucket'),
  object?: string(name='object', example='demo-object'),
}

model ActivateConnectionRequest {
  account?: GitAccount(name='account'),
  credential?: OAuthCredential(name='credential'),
}

model ActivateConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Connection  
}

/**
 * @summary 激活身份绑定,完成OAuth授权
 *
 * @param request ActivateConnectionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ActivateConnectionResponse
 */
async function activateConnectionWithOptions(name: string, request: ActivateConnectionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ActivateConnectionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.account)) {
    body['account'] = request.account;
  }
  if (!Util.isUnset(request.credential)) {
    body['credential'] = request.credential;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ActivateConnection',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/connections/${OpenApiUtil.getEncodeParam(name)}/activate`,
    method = 'PATCH',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 激活身份绑定,完成OAuth授权
 *
 * @param request ActivateConnectionRequest
 * @return ActivateConnectionResponse
 */
async function activateConnection(name: string, request: ActivateConnectionRequest): ActivateConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return activateConnectionWithOptions(name, request, headers, runtime);
}

model CancelPipelineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Pipeline  
}

/**
 * @summary 取消流水线
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelPipelineResponse
 */
async function cancelPipelineWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): CancelPipelineResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CancelPipeline',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/pipelines/${OpenApiUtil.getEncodeParam(name)}/cancel`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 取消流水线
 *
 * @return CancelPipelineResponse
 */
async function cancelPipeline(name: string): CancelPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelPipelineWithOptions(name, headers, runtime);
}

model CancelTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Task  
}

/**
 * @summary 取消任务
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelTaskResponse
 */
async function cancelTaskWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): CancelTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CancelTask',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/tasks/${OpenApiUtil.getEncodeParam(name)}/cancel`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 取消任务
 *
 * @return CancelTaskResponse
 */
async function cancelTask(name: string): CancelTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cancelTaskWithOptions(name, headers, runtime);
}

model CreateArtifactRequest {
  body?: Artifact(name='body'),
}

model CreateArtifactResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Artifact  
}

/**
 * @summary 创建交付物存储
 *
 * @param request CreateArtifactRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateArtifactResponse
 */
async function createArtifactWithOptions(request: CreateArtifactRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateArtifactResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateArtifact',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/artifacts`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建交付物存储
 *
 * @param request CreateArtifactRequest
 * @return CreateArtifactResponse
 */
async function createArtifact(request: CreateArtifactRequest): CreateArtifactResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createArtifactWithOptions(request, headers, runtime);
}

model CreateEnvironmentRequest {
  body?: Environment(name='body'),
}

model CreateEnvironmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Environment  
}

/**
 * @summary 创建环境
 *
 * @param request CreateEnvironmentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEnvironmentResponse
 */
async function createEnvironmentWithOptions(projectName: string, request: CreateEnvironmentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateEnvironmentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEnvironment',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/projects/${OpenApiUtil.getEncodeParam(projectName)}/environments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建环境
 *
 * @param request CreateEnvironmentRequest
 * @return CreateEnvironmentResponse
 */
async function createEnvironment(projectName: string, request: CreateEnvironmentRequest): CreateEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createEnvironmentWithOptions(projectName, request, headers, runtime);
}

model CreatePipelineRequest {
  body?: Pipeline(name='body'),
}

model CreatePipelineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Pipeline  
}

/**
 * @summary 创建流水线
 *
 * @param request CreatePipelineRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePipelineResponse
 */
async function createPipelineWithOptions(request: CreatePipelineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePipelineResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePipeline',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/pipelines`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建流水线
 *
 * @param request CreatePipelineRequest
 * @return CreatePipelineResponse
 */
async function createPipeline(request: CreatePipelineRequest): CreatePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPipelineWithOptions(request, headers, runtime);
}

model CreateProjectRequest {
  body?: Project(name='body'),
}

model CreateProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Project  
}

/**
 * @summary 创建项目
 *
 * @param request CreateProjectRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProjectResponse
 */
async function createProjectWithOptions(request: CreateProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProject',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/projects`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建项目
 *
 * @param request CreateProjectRequest
 * @return CreateProjectResponse
 */
async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProjectWithOptions(request, headers, runtime);
}

model CreateTaskRequest {
  body?: Task(name='body'),
}

model CreateTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Task  
}

/**
 * @summary 创建任务
 *
 * @param request CreateTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTaskResponse
 */
async function createTaskWithOptions(request: CreateTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTask',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/tasks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建任务
 *
 * @param request CreateTaskRequest
 * @return CreateTaskResponse
 */
async function createTask(request: CreateTaskRequest): CreateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTaskWithOptions(request, headers, runtime);
}

model CreateToolsetRequest {
  body?: Toolset(name='body'),
}

model CreateToolsetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Toolset  
}

/**
 * @summary 创建工具集
 *
 * @param request CreateToolsetRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateToolsetResponse
 */
async function createToolsetWithOptions(request: CreateToolsetRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateToolsetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateToolset',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/toolsets`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建工具集
 *
 * @param request CreateToolsetRequest
 * @return CreateToolsetResponse
 */
async function createToolset(request: CreateToolsetRequest): CreateToolsetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createToolsetWithOptions(request, headers, runtime);
}

model DeleteArtifactResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 删除交付物
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteArtifactResponse
 */
async function deleteArtifactWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteArtifactResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteArtifact',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/artifacts/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除交付物
 *
 * @return DeleteArtifactResponse
 */
async function deleteArtifact(name: string): DeleteArtifactResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteArtifactWithOptions(name, headers, runtime);
}

model DeleteConnectionRequest {
  force?: boolean(name='force', example='true'),
}

model DeleteConnectionResponseBody = {
  requestId?: string(name='requestId', example='A5152937-1C8A-5260-90FA-520CEF028D2D'),
}

model DeleteConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteConnectionResponseBody(name='body'),
}

/**
 * @summary 删除身份绑定
 *
 * @param request DeleteConnectionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConnectionResponse
 */
async function deleteConnectionWithOptions(name: string, request: DeleteConnectionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConnectionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConnection',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/connections/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除身份绑定
 *
 * @param request DeleteConnectionRequest
 * @return DeleteConnectionResponse
 */
async function deleteConnection(name: string, request: DeleteConnectionRequest): DeleteConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConnectionWithOptions(name, request, headers, runtime);
}

model DeleteEnvironmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 删除环境
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEnvironmentResponse
 */
async function deleteEnvironmentWithOptions(projectName: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEnvironmentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteEnvironment',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/projects/${OpenApiUtil.getEncodeParam(projectName)}/environments/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除环境
 *
 * @return DeleteEnvironmentResponse
 */
async function deleteEnvironment(projectName: string, name: string): DeleteEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEnvironmentWithOptions(projectName, name, headers, runtime);
}

model DeleteProjectRequest {
  force?: boolean(name='force', example='true'),
}

model DeleteProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 删除项目
 *
 * @param request DeleteProjectRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteProjectResponse
 */
async function deleteProjectWithOptions(name: string, request: DeleteProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/projects/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除项目
 *
 * @param request DeleteProjectRequest
 * @return DeleteProjectResponse
 */
async function deleteProject(name: string, request: DeleteProjectRequest): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProjectWithOptions(name, request, headers, runtime);
}

model DeleteToolsetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @summary 删除工具集
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteToolsetResponse
 */
async function deleteToolsetWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteToolsetResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteToolset',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/toolsets/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除工具集
 *
 * @return DeleteToolsetResponse
 */
async function deleteToolset(name: string): DeleteToolsetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteToolsetWithOptions(name, headers, runtime);
}

model DeployEnvironmentRequest {
  body?: DeployEnvironmentOptions(name='body'),
}

model DeployEnvironmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnvironmentDeployment  
}

/**
 * @summary 手动触发环境部署
 *
 * @param request DeployEnvironmentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeployEnvironmentResponse
 */
async function deployEnvironmentWithOptions(projectName: string, name: string, request: DeployEnvironmentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeployEnvironmentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'DeployEnvironment',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/projects/${OpenApiUtil.getEncodeParam(projectName)}/environments/${OpenApiUtil.getEncodeParam(name)}/deploy`,
    method = 'PATCH',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 手动触发环境部署
 *
 * @param request DeployEnvironmentRequest
 * @return DeployEnvironmentResponse
 */
async function deployEnvironment(projectName: string, name: string, request: DeployEnvironmentRequest): DeployEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deployEnvironmentWithOptions(projectName, name, request, headers, runtime);
}

model FetchArtifactDownloadUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ArtifactCode  
}

/**
 * @summary 获取交付物的zip包临时下载地址url
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return FetchArtifactDownloadUrlResponse
 */
async function fetchArtifactDownloadUrlWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): FetchArtifactDownloadUrlResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'FetchArtifactDownloadUrl',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/artifacts/${OpenApiUtil.getEncodeParam(name)}/fetchCode`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取交付物的zip包临时下载地址url
 *
 * @return FetchArtifactDownloadUrlResponse
 */
async function fetchArtifactDownloadUrl(name: string): FetchArtifactDownloadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fetchArtifactDownloadUrlWithOptions(name, headers, runtime);
}

model FetchArtifactTempBucketTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ArtifactTempBucketToken  
}

/**
 * @summary 获取交付物临时上传的bucket、object和临时sts
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return FetchArtifactTempBucketTokenResponse
 */
async function fetchArtifactTempBucketTokenWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): FetchArtifactTempBucketTokenResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'FetchArtifactTempBucketToken',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/artifacts/action/fetchTempBucketToken`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取交付物临时上传的bucket、object和临时sts
 *
 * @return FetchArtifactTempBucketTokenResponse
 */
async function fetchArtifactTempBucketToken(): FetchArtifactTempBucketTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fetchArtifactTempBucketTokenWithOptions(headers, runtime);
}

model FetchConnectionCredentialResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OAuthCredential  
}

/**
 * @summary 查询身份绑定中的凭证信息
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return FetchConnectionCredentialResponse
 */
async function fetchConnectionCredentialWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): FetchConnectionCredentialResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'FetchConnectionCredential',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/connections/${OpenApiUtil.getEncodeParam(name)}/fetchCredential`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询身份绑定中的凭证信息
 *
 * @return FetchConnectionCredentialResponse
 */
async function fetchConnectionCredential(name: string): FetchConnectionCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fetchConnectionCredentialWithOptions(name, headers, runtime);
}

model GetArtifactResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Artifact  
}

/**
 * @summary 查询交付物
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetArtifactResponse
 */
async function getArtifactWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetArtifactResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetArtifact',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/artifacts/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询交付物
 *
 * @return GetArtifactResponse
 */
async function getArtifact(name: string): GetArtifactResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getArtifactWithOptions(name, headers, runtime);
}

model GetEnvironmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Environment  
}

/**
 * @summary 获取环境信息
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEnvironmentResponse
 */
async function getEnvironmentWithOptions(projectName: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetEnvironmentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetEnvironment',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/projects/${OpenApiUtil.getEncodeParam(projectName)}/environments/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取环境信息
 *
 * @return GetEnvironmentResponse
 */
async function getEnvironment(projectName: string, name: string): GetEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEnvironmentWithOptions(projectName, name, headers, runtime);
}

model GetEnvironmentDeploymentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnvironmentDeployment  
}

/**
 * @summary 查询环境部署信息
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEnvironmentDeploymentResponse
 */
async function getEnvironmentDeploymentWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetEnvironmentDeploymentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetEnvironmentDeployment',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/environmentdeployments/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询环境部署信息
 *
 * @return GetEnvironmentDeploymentResponse
 */
async function getEnvironmentDeployment(name: string): GetEnvironmentDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEnvironmentDeploymentWithOptions(name, headers, runtime);
}

model GetPipelineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Pipeline  
}

/**
 * @summary 查询流水线
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPipelineResponse
 */
async function getPipelineWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPipelineResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPipeline',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/pipelines/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询流水线
 *
 * @return GetPipelineResponse
 */
async function getPipeline(name: string): GetPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPipelineWithOptions(name, headers, runtime);
}

model GetProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Project  
}

/**
 * @summary 查询项目
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetProjectResponse
 */
async function getProjectWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProjectResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProject',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/projects/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询项目
 *
 * @return GetProjectResponse
 */
async function getProject(name: string): GetProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProjectWithOptions(name, headers, runtime);
}

model GetRepositoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Repository  
}

/**
 * @summary 查询仓库绑定
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRepositoryResponse
 */
async function getRepositoryWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepositoryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRepository',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/repositories/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询仓库绑定
 *
 * @return GetRepositoryResponse
 */
async function getRepository(name: string): GetRepositoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepositoryWithOptions(name, headers, runtime);
}

model GetServiceDeploymentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ServiceDeployment  
}

/**
 * @summary 查询服务部署信息
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetServiceDeploymentResponse
 */
async function getServiceDeploymentWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceDeploymentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetServiceDeployment',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/servicedeployments/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询服务部署信息
 *
 * @return GetServiceDeploymentResponse
 */
async function getServiceDeployment(name: string): GetServiceDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceDeploymentWithOptions(name, headers, runtime);
}

model GetTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Task  
}

/**
 * @summary 查询任务
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTaskResponse
 */
async function getTaskWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetTask',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/tasks/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询任务
 *
 * @return GetTaskResponse
 */
async function getTask(name: string): GetTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTaskWithOptions(name, headers, runtime);
}

model GetToolsetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Toolset  
}

/**
 * @summary 查询工具集
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetToolsetResponse
 */
async function getToolsetWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetToolsetResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetToolset',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/toolsets/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询工具集
 *
 * @return GetToolsetResponse
 */
async function getToolset(name: string): GetToolsetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getToolsetWithOptions(name, headers, runtime);
}

model ListConnectionsRequest {
  keyword?: string(name='keyword', example='auto-'),
  labelSelector?: [ string ](name='labelSelector'),
  pageNumber?: long(name='pageNumber', example='1'),
  pageSize?: long(name='pageSize', example='100'),
}

model ListConnectionsShrinkRequest {
  keyword?: string(name='keyword', example='auto-'),
  labelSelectorShrink?: string(name='labelSelector'),
  pageNumber?: long(name='pageNumber', example='1'),
  pageSize?: long(name='pageSize', example='100'),
}

model ListConnectionsResponseBody = {
  data?: [
    Connection
  ](name='data'),
  pageNumber?: long(name='pageNumber', example='1'),
  pageSize?: long(name='pageSize', example='100'),
  totalCount?: long(name='totalCount', example='1'),
}

model ListConnectionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListConnectionsResponseBody(name='body'),
}

/**
 * @summary 批量查询身份绑定
 *
 * @param tmpReq ListConnectionsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListConnectionsResponse
 */
async function listConnectionsWithOptions(tmpReq: ListConnectionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConnectionsResponse {
  Util.validateModel(tmpReq);
  var request = new ListConnectionsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.labelSelector)) {
    request.labelSelectorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labelSelector, 'labelSelector', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.labelSelectorShrink)) {
    query['labelSelector'] = request.labelSelectorShrink;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConnections',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/connections`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 批量查询身份绑定
 *
 * @param request ListConnectionsRequest
 * @return ListConnectionsResponse
 */
async function listConnections(request: ListConnectionsRequest): ListConnectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConnectionsWithOptions(request, headers, runtime);
}

model ListEnvironmentsRequest {
  keyword?: string(name='keyword', example='dev'),
  labelSelector?: [ string ](name='labelSelector'),
  pageNumber?: long(name='pageNumber', example='1'),
  pageSize?: long(name='pageSize', example='10'),
}

model ListEnvironmentsShrinkRequest {
  keyword?: string(name='keyword', example='dev'),
  labelSelectorShrink?: string(name='labelSelector'),
  pageNumber?: long(name='pageNumber', example='1'),
  pageSize?: long(name='pageSize', example='10'),
}

model ListEnvironmentsResponseBody = {
  data?: [
    Environment
  ](name='data'),
  pageNumber?: long(name='pageNumber', example='1'),
  pageSize?: long(name='pageSize', example='50'),
  totalCount?: long(name='totalCount', example='100'),
}

model ListEnvironmentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEnvironmentsResponseBody(name='body'),
}

/**
 * @summary 查询环境列表
 *
 * @param tmpReq ListEnvironmentsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListEnvironmentsResponse
 */
async function listEnvironmentsWithOptions(projectName: string, tmpReq: ListEnvironmentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEnvironmentsResponse {
  Util.validateModel(tmpReq);
  var request = new ListEnvironmentsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.labelSelector)) {
    request.labelSelectorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labelSelector, 'labelSelector', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.labelSelectorShrink)) {
    query['labelSelector'] = request.labelSelectorShrink;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEnvironments',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/projects/${OpenApiUtil.getEncodeParam(projectName)}/environments/`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询环境列表
 *
 * @param request ListEnvironmentsRequest
 * @return ListEnvironmentsResponse
 */
async function listEnvironments(projectName: string, request: ListEnvironmentsRequest): ListEnvironmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEnvironmentsWithOptions(projectName, request, headers, runtime);
}

model ListPipelinesRequest {
  labelSelector?: [ string ](name='labelSelector'),
}

model ListPipelinesShrinkRequest {
  labelSelectorShrink?: string(name='labelSelector'),
}

model ListPipelinesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [
    Pipeline
  ](name='body'),
}

/**
 * @summary 批量查询流水线
 *
 * @param tmpReq ListPipelinesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListPipelinesResponse
 */
async function listPipelinesWithOptions(tmpReq: ListPipelinesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPipelinesResponse {
  Util.validateModel(tmpReq);
  var request = new ListPipelinesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.labelSelector)) {
    request.labelSelectorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labelSelector, 'labelSelector', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.labelSelectorShrink)) {
    query['labelSelector'] = request.labelSelectorShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPipelines',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/pipelines`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 批量查询流水线
 *
 * @param request ListPipelinesRequest
 * @return ListPipelinesResponse
 */
async function listPipelines(request: ListPipelinesRequest): ListPipelinesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPipelinesWithOptions(request, headers, runtime);
}

model ListProjectsRequest {
  keyword?: string(name='keyword', example='spring-boot'),
  labelSelector?: [ string ](name='labelSelector'),
  pageNumber?: long(name='pageNumber', example='1'),
  pageSize?: long(name='pageSize', example='100'),
}

model ListProjectsShrinkRequest {
  keyword?: string(name='keyword', example='spring-boot'),
  labelSelectorShrink?: string(name='labelSelector'),
  pageNumber?: long(name='pageNumber', example='1'),
  pageSize?: long(name='pageSize', example='100'),
}

model ListProjectsResponseBody = {
  data?: [
    Project
  ](name='data'),
  pageNumber?: long(name='pageNumber', example='1'),
  pageSize?: long(name='pageSize', example='100'),
  totalCount?: long(name='totalCount', example='1'),
}

model ListProjectsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProjectsResponseBody(name='body'),
}

/**
 * @summary 批量查询项目
 *
 * @param tmpReq ListProjectsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProjectsResponse
 */
async function listProjectsWithOptions(tmpReq: ListProjectsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProjectsResponse {
  Util.validateModel(tmpReq);
  var request = new ListProjectsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.labelSelector)) {
    request.labelSelectorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labelSelector, 'labelSelector', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.labelSelectorShrink)) {
    query['labelSelector'] = request.labelSelectorShrink;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProjects',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/projects`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 批量查询项目
 *
 * @param request ListProjectsRequest
 * @return ListProjectsResponse
 */
async function listProjects(request: ListProjectsRequest): ListProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProjectsWithOptions(request, headers, runtime);
}

model ListServiceDeploymentsRequest {
  keyword?: string(name='keyword', example='demo'),
  labelSelector?: [ string ](name='labelSelector'),
  pageNumber?: long(name='pageNumber', example='1'),
  pageSize?: long(name='pageSize', example='10'),
}

model ListServiceDeploymentsShrinkRequest {
  keyword?: string(name='keyword', example='demo'),
  labelSelectorShrink?: string(name='labelSelector'),
  pageNumber?: long(name='pageNumber', example='1'),
  pageSize?: long(name='pageSize', example='10'),
}

model ListServiceDeploymentsResponseBody = {
  data?: [
    ServiceDeployment
  ](name='data'),
  pageNumber?: long(name='pageNumber', example='1'),
  pageSize?: long(name='pageSize', example='10'),
  totalCount?: long(name='totalCount', example='50'),
}

model ListServiceDeploymentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListServiceDeploymentsResponseBody(name='body'),
}

/**
 * @summary 批量查询服务部署信息
 *
 * @param tmpReq ListServiceDeploymentsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListServiceDeploymentsResponse
 */
async function listServiceDeploymentsWithOptions(tmpReq: ListServiceDeploymentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceDeploymentsResponse {
  Util.validateModel(tmpReq);
  var request = new ListServiceDeploymentsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.labelSelector)) {
    request.labelSelectorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labelSelector, 'labelSelector', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.labelSelectorShrink)) {
    query['labelSelector'] = request.labelSelectorShrink;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceDeployments',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/servicedeployments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 批量查询服务部署信息
 *
 * @param request ListServiceDeploymentsRequest
 * @return ListServiceDeploymentsResponse
 */
async function listServiceDeployments(request: ListServiceDeploymentsRequest): ListServiceDeploymentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceDeploymentsWithOptions(request, headers, runtime);
}

model ListTasksRequest {
  labelSelector?: [ string ](name='labelSelector'),
}

model ListTasksShrinkRequest {
  labelSelectorShrink?: string(name='labelSelector'),
}

model ListTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: [
    Task
  ](name='body'),
}

/**
 * @summary 批量查询任务
 *
 * @param tmpReq ListTasksRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTasksResponse
 */
async function listTasksWithOptions(tmpReq: ListTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTasksResponse {
  Util.validateModel(tmpReq);
  var request = new ListTasksShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.labelSelector)) {
    request.labelSelectorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labelSelector, 'labelSelector', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.labelSelectorShrink)) {
    query['labelSelector'] = request.labelSelectorShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTasks',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'array',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 批量查询任务
 *
 * @param request ListTasksRequest
 * @return ListTasksResponse
 */
async function listTasks(request: ListTasksRequest): ListTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTasksWithOptions(request, headers, runtime);
}

model ListToolsetsRequest {
  keyword?: string(name='keyword', example='demo'),
  labelSelector?: [ string ](name='labelSelector'),
  pageNumber?: long(name='pageNumber', example='1'),
  pageSize?: long(name='pageSize', example='10'),
}

model ListToolsetsShrinkRequest {
  keyword?: string(name='keyword', example='demo'),
  labelSelectorShrink?: string(name='labelSelector'),
  pageNumber?: long(name='pageNumber', example='1'),
  pageSize?: long(name='pageSize', example='10'),
}

model ListToolsetsResponseBody = {
  data?: [
    Toolset
  ](name='data'),
  pageNumber?: long(name='pageNumber', example='1'),
  pageSize?: long(name='pageSize', example='10'),
  totalCount?: long(name='totalCount', example='10'),
}

model ListToolsetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListToolsetsResponseBody(name='body'),
}

/**
 * @summary 批量查询工具集
 *
 * @param tmpReq ListToolsetsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListToolsetsResponse
 */
async function listToolsetsWithOptions(tmpReq: ListToolsetsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListToolsetsResponse {
  Util.validateModel(tmpReq);
  var request = new ListToolsetsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.labelSelector)) {
    request.labelSelectorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.labelSelector, 'labelSelector', 'simple');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.labelSelectorShrink)) {
    query['labelSelector'] = request.labelSelectorShrink;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListToolsets',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/toolsets`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 批量查询工具集
 *
 * @param request ListToolsetsRequest
 * @return ListToolsetsResponse
 */
async function listToolsets(request: ListToolsetsRequest): ListToolsetsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listToolsetsWithOptions(request, headers, runtime);
}

model PreviewEnvironmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnvironmentDeploymentSpec  
}

/**
 * @summary 预览环境变更信息
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PreviewEnvironmentResponse
 */
async function previewEnvironmentWithOptions(projectName: string, name: string, headers: map[string]string, runtime: Util.RuntimeOptions): PreviewEnvironmentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'PreviewEnvironment',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/projects/${OpenApiUtil.getEncodeParam(projectName)}/environments/${OpenApiUtil.getEncodeParam(name)}/preview`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 预览环境变更信息
 *
 * @return PreviewEnvironmentResponse
 */
async function previewEnvironment(projectName: string, name: string): PreviewEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return previewEnvironmentWithOptions(projectName, name, headers, runtime);
}

model PutArtifactRequest {
  body?: Artifact(name='body'),
  force?: boolean(name='force', example='false'),
}

model PutArtifactResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Artifact  
}

/**
 * @summary 更新交付物
 *
 * @param request PutArtifactRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutArtifactResponse
 */
async function putArtifactWithOptions(name: string, request: PutArtifactRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutArtifactResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PutArtifact',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/artifacts/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新交付物
 *
 * @param request PutArtifactRequest
 * @return PutArtifactResponse
 */
async function putArtifact(name: string, request: PutArtifactRequest): PutArtifactResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putArtifactWithOptions(name, request, headers, runtime);
}

model PutPipelineStatusRequest {
  body?: Pipeline(name='body'),
  force?: boolean(name='force', example='false'),
}

model PutPipelineStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Pipeline  
}

/**
 * @summary 更新流水线状态
 *
 * @param request PutPipelineStatusRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutPipelineStatusResponse
 */
async function putPipelineStatusWithOptions(name: string, request: PutPipelineStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutPipelineStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PutPipelineStatus',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/pipelines/${OpenApiUtil.getEncodeParam(name)}/status`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新流水线状态
 *
 * @param request PutPipelineStatusRequest
 * @return PutPipelineStatusResponse
 */
async function putPipelineStatus(name: string, request: PutPipelineStatusRequest): PutPipelineStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putPipelineStatusWithOptions(name, request, headers, runtime);
}

model PutTaskStatusRequest {
  body?: Task(name='body'),
  force?: boolean(name='force', example='false'),
}

model PutTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Task  
}

/**
 * @summary 更新替换任务状态
 *
 * @param request PutTaskStatusRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return PutTaskStatusResponse
 */
async function putTaskStatusWithOptions(name: string, request: PutTaskStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutTaskStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.force)) {
    query['force'] = request.force;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'PutTaskStatus',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/tasks/${OpenApiUtil.getEncodeParam(name)}/status`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新替换任务状态
 *
 * @param request PutTaskStatusRequest
 * @return PutTaskStatusResponse
 */
async function putTaskStatus(name: string, request: PutTaskStatusRequest): PutTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putTaskStatusWithOptions(name, request, headers, runtime);
}

model RenderServicesByTemplateRequest {
  parameters?: map[string]any(name='parameters', example='{"region":"cn-hangzhou"}'),
  projectName?: string(name='projectName', example='my-project'),
  serviceNameChanges?: map[string]string(name='serviceNameChanges', example='{"svc1":"svc2"}'),
  templateName?: string(name='templateName', description='This parameter is required.', example='start-springboot'),
  variableValues?: TemplateVariableValueMap(name='variableValues'),
}

model RenderServicesByTemplateResponseBody = {
  changedServiceNames?: map[string]string(name='changedServiceNames'),
  services?: map[string]ServiceConfig(name='services'),
  variables?: map[string]Variable(name='variables'),
}

model RenderServicesByTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenderServicesByTemplateResponseBody(name='body'),
}

/**
 * @summary 解析模板中的服务、变量配置
 *
 * @param request RenderServicesByTemplateRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenderServicesByTemplateResponse
 */
async function renderServicesByTemplateWithOptions(request: RenderServicesByTemplateRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RenderServicesByTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.parameters)) {
    body['parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.projectName)) {
    body['projectName'] = request.projectName;
  }
  if (!Util.isUnset(request.serviceNameChanges)) {
    body['serviceNameChanges'] = request.serviceNameChanges;
  }
  if (!Util.isUnset(request.templateName)) {
    body['templateName'] = request.templateName;
  }
  if (!Util.isUnset(request.variableValues)) {
    body['variableValues'] = request.variableValues;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RenderServicesByTemplate',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/templates/action/renderServices`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 解析模板中的服务、变量配置
 *
 * @param request RenderServicesByTemplateRequest
 * @return RenderServicesByTemplateResponse
 */
async function renderServicesByTemplate(request: RenderServicesByTemplateRequest): RenderServicesByTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return renderServicesByTemplateWithOptions(request, headers, runtime);
}

model ResumeTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Task  
}

/**
 * @summary 确认并继续执行任务
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResumeTaskResponse
 */
async function resumeTaskWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): ResumeTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ResumeTask',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/tasks/${OpenApiUtil.getEncodeParam(name)}/resume`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 确认并继续执行任务
 *
 * @return ResumeTaskResponse
 */
async function resumeTask(name: string): ResumeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return resumeTaskWithOptions(name, headers, runtime);
}

model RetryTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Task  
}

/**
 * @summary 重试执行任务
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return RetryTaskResponse
 */
async function retryTaskWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): RetryTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RetryTask',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/tasks/${OpenApiUtil.getEncodeParam(name)}/retry`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 重试执行任务
 *
 * @return RetryTaskResponse
 */
async function retryTask(name: string): RetryTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return retryTaskWithOptions(name, headers, runtime);
}

model StartPipelineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Pipeline  
}

/**
 * @summary 开始执行流水线
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartPipelineResponse
 */
async function startPipelineWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartPipelineResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartPipeline',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/pipelines/${OpenApiUtil.getEncodeParam(name)}/start`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 开始执行流水线
 *
 * @return StartPipelineResponse
 */
async function startPipeline(name: string): StartPipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startPipelineWithOptions(name, headers, runtime);
}

model StartTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Task  
}

/**
 * @summary 开始执行任务
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartTaskResponse
 */
async function startTaskWithOptions(name: string, headers: map[string]string, runtime: Util.RuntimeOptions): StartTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StartTask',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/tasks/${OpenApiUtil.getEncodeParam(name)}/start`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 开始执行任务
 *
 * @return StartTaskResponse
 */
async function startTask(name: string): StartTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startTaskWithOptions(name, headers, runtime);
}

model UpdateEnvironmentRequest {
  body?: Environment(name='body'),
}

model UpdateEnvironmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Environment  
}

/**
 * @summary 更新环境（局部更新）
 *
 * @param request UpdateEnvironmentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEnvironmentResponse
 */
async function updateEnvironmentWithOptions(projectName: string, name: string, request: UpdateEnvironmentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateEnvironmentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEnvironment',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/projects/${OpenApiUtil.getEncodeParam(projectName)}/environments/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新环境（局部更新）
 *
 * @param request UpdateEnvironmentRequest
 * @return UpdateEnvironmentResponse
 */
async function updateEnvironment(projectName: string, name: string, request: UpdateEnvironmentRequest): UpdateEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateEnvironmentWithOptions(projectName, name, request, headers, runtime);
}

model UpdateProjectRequest {
  body?: Project(name='body'),
}

model UpdateProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Project  
}

/**
 * @summary 更新替换应用
 *
 * @param request UpdateProjectRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateProjectResponse
 */
async function updateProjectWithOptions(name: string, request: UpdateProjectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProject',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/projects/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新替换应用
 *
 * @param request UpdateProjectRequest
 * @return UpdateProjectResponse
 */
async function updateProject(name: string, request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProjectWithOptions(name, request, headers, runtime);
}

model UpdateToolsetRequest {
  body?: Toolset(name='body'),
}

model UpdateToolsetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: Toolset  
}

/**
 * @summary 更新工具集
 *
 * @param request UpdateToolsetRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateToolsetResponse
 */
async function updateToolsetWithOptions(name: string, request: UpdateToolsetRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateToolsetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateToolset',
    version = '2023-07-14',
    protocol = 'HTTPS',
    pathname = `/2023-07-14/toolsets/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新工具集
 *
 * @param request UpdateToolsetRequest
 * @return UpdateToolsetResponse
 */
async function updateToolset(name: string, request: UpdateToolsetRequest): UpdateToolsetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateToolsetWithOptions(name, request, headers, runtime);
}

