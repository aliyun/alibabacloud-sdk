/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('face', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddFaceRequest {
  group?: string(name='Group'),
  person?: string(name='Person'),
  image?: string(name='Image'),
  imageUrl?: string(name='ImageUrl'),
  content?: string(name='Content'),
}

model AddFaceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model AddFaceResponse = {
  headers: map[string]string(name='headers'),
  body: AddFaceResponseBody(name='body'),
}

async function addFaceWithOptions(request: AddFaceRequest, runtime: Util.RuntimeOptions): AddFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddFace', '2018-12-03', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addFace(request: AddFaceRequest): AddFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFaceWithOptions(request, runtime);
}

model DeleteFaceRequest {
  group?: string(name='Group'),
  person?: string(name='Person'),
  image?: string(name='Image'),
}

model DeleteFaceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteFaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFaceResponseBody(name='body'),
}

async function deleteFaceWithOptions(request: DeleteFaceRequest, runtime: Util.RuntimeOptions): DeleteFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFace', '2018-12-03', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFace(request: DeleteFaceRequest): DeleteFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFaceWithOptions(request, runtime);
}

model DetectFaceRequest {
  imageUrl?: string(name='ImageUrl'),
  content?: string(name='Content'),
}

model DetectFaceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DetectFaceResponse = {
  headers: map[string]string(name='headers'),
  body: DetectFaceResponseBody(name='body'),
}

async function detectFaceWithOptions(request: DetectFaceRequest, runtime: Util.RuntimeOptions): DetectFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetectFace', '2018-12-03', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detectFace(request: DetectFaceRequest): DetectFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectFaceWithOptions(request, runtime);
}

model GetFaceAttributeRequest {
  imageUrl?: string(name='ImageUrl'),
  content?: string(name='Content'),
}

model GetFaceAttributeResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetFaceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: GetFaceAttributeResponseBody(name='body'),
}

async function getFaceAttributeWithOptions(request: GetFaceAttributeRequest, runtime: Util.RuntimeOptions): GetFaceAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetFaceAttribute', '2018-12-03', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getFaceAttribute(request: GetFaceAttributeRequest): GetFaceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFaceAttributeWithOptions(request, runtime);
}

model ListFaceRequest {
  group?: string(name='Group'),
  mark?: long(name='Mark'),
}

model ListFaceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListFaceResponse = {
  headers: map[string]string(name='headers'),
  body: ListFaceResponseBody(name='body'),
}

async function listFaceWithOptions(request: ListFaceRequest, runtime: Util.RuntimeOptions): ListFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFace', '2018-12-03', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFace(request: ListFaceRequest): ListFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFaceWithOptions(request, runtime);
}

model ListGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupResponseBody(name='body'),
}

async function listGroupWithOptions(runtime: Util.RuntimeOptions): ListGroupResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('ListGroup', '2018-12-03', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listGroup(): ListGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupWithOptions(runtime);
}

model RecognizeFaceRequest {
  group?: string(name='Group'),
  imageUrl?: string(name='ImageUrl'),
  content?: string(name='Content'),
}

model RecognizeFaceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model RecognizeFaceResponse = {
  headers: map[string]string(name='headers'),
  body: RecognizeFaceResponseBody(name='body'),
}

async function recognizeFaceWithOptions(request: RecognizeFaceRequest, runtime: Util.RuntimeOptions): RecognizeFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RecognizeFace', '2018-12-03', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function recognizeFace(request: RecognizeFaceRequest): RecognizeFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeFaceWithOptions(request, runtime);
}

model VerifyFaceRequest {
  imageUrl1?: string(name='ImageUrl1'),
  imageUrl2?: string(name='ImageUrl2'),
  content1?: string(name='Content1'),
  content2?: string(name='Content2'),
}

model VerifyFaceResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model VerifyFaceResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyFaceResponseBody(name='body'),
}

async function verifyFaceWithOptions(request: VerifyFaceRequest, runtime: Util.RuntimeOptions): VerifyFaceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('VerifyFace', '2018-12-03', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function verifyFace(request: VerifyFaceRequest): VerifyFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyFaceWithOptions(request, runtime);
}

