/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('trademark', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model QueryTradeProduceListRequest {
  registerNumber?: string(name='RegisterNumber'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  preOrderId?: string(name='PreOrderId'),
  buyerStatus?: int32(name='BuyerStatus'),
  sortOrder?: string(name='SortOrder'),
  sortFiled?: string(name='SortFiled'),
  bizId?: string(name='BizId'),
}

model QueryTradeProduceListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  totalPageNum?: int32(name='TotalPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalItemNum?: int32(name='TotalItemNum'),
  data?: {
    tradeProduces?: [ 
    {
      updateTime?: long(name='UpdateTime'),
      preAmount?: float(name='PreAmount'),
      createTime?: long(name='CreateTime'),
      userId?: string(name='UserId'),
      bizId?: string(name='BizId'),
      icon?: string(name='Icon'),
      buyerStatus?: int32(name='BuyerStatus'),
      source?: int32(name='Source'),
      operateNote?: string(name='OperateNote'),
      preOrderId?: string(name='PreOrderId'),
      allowCancel?: boolean(name='AllowCancel'),
      registerNumber?: string(name='RegisterNumber'),
      classification?: string(name='Classification'),
      finalAmount?: float(name='FinalAmount'),
      failReason?: int32(name='FailReason'),
    }
  ](name='TradeProduces')
  }(name='Data'),
}

model QueryTradeProduceListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTradeProduceListResponseBody(name='body'),
}

async function queryTradeProduceListWithOptions(request: QueryTradeProduceListRequest, runtime: Util.RuntimeOptions): QueryTradeProduceListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTradeProduceList', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTradeProduceList(request: QueryTradeProduceListRequest): QueryTradeProduceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeProduceListWithOptions(request, runtime);
}

model QueryTrademarkMonitorResultsRequest {
  ruleId?: long(name='RuleId'),
  actionType?: int32(name='ActionType'),
  procedureStatus?: int32(name='ProcedureStatus'),
  tmName?: string(name='TmName'),
  applyYear?: string(name='ApplyYear'),
  registrationNumber?: string(name='RegistrationNumber'),
  classification?: string(name='Classification'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model QueryTrademarkMonitorResultsResponseBody = {
  nextPage?: boolean(name='NextPage'),
  requestId?: string(name='RequestId'),
  prePage?: boolean(name='PrePage'),
  totalItemNum?: int32(name='TotalItemNum'),
  currentPageNum?: int32(name='CurrentPageNum'),
  totalPageNum?: int32(name='TotalPageNum'),
  pageSize?: int32(name='PageSize'),
  data?: {
    tmMonitorResult?: [ 
    {
      tmProcedureStatusDesc?: string(name='TmProcedureStatusDesc'),
      wuxiaoEndDate?: string(name='WuxiaoEndDate'),
      userId?: string(name='UserId'),
      ownerEnName?: string(name='OwnerEnName'),
      tmUid?: string(name='TmUid'),
      ownerName?: string(name='OwnerName'),
      dataUpdateTime?: long(name='DataUpdateTime'),
      chesanEndDate?: string(name='ChesanEndDate'),
      xuzhanEndDate?: string(name='XuzhanEndDate'),
      ruleId?: string(name='RuleId'),
      registrationNumber?: string(name='RegistrationNumber'),
      tmName?: string(name='TmName'),
      tmImage?: string(name='TmImage'),
      dataCreateTime?: long(name='DataCreateTime'),
      yiyiEndDate?: string(name='YiyiEndDate'),
      classification?: string(name='Classification'),
      applyDate?: string(name='ApplyDate'),
    }
  ](name='TmMonitorResult')
  }(name='Data'),
}

model QueryTrademarkMonitorResultsResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTrademarkMonitorResultsResponseBody(name='body'),
}

async function queryTrademarkMonitorResultsWithOptions(request: QueryTrademarkMonitorResultsRequest, runtime: Util.RuntimeOptions): QueryTrademarkMonitorResultsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTrademarkMonitorResults', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTrademarkMonitorResults(request: QueryTrademarkMonitorResultsRequest): QueryTrademarkMonitorResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkMonitorResultsWithOptions(request, runtime);
}

model CancelTradeOrderRequest {
  bizId?: string(name='BizId'),
}

model CancelTradeOrderResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model CancelTradeOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CancelTradeOrderResponseBody(name='body'),
}

async function cancelTradeOrderWithOptions(request: CancelTradeOrderRequest, runtime: Util.RuntimeOptions): CancelTradeOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelTradeOrder', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelTradeOrder(request: CancelTradeOrderRequest): CancelTradeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelTradeOrderWithOptions(request, runtime);
}

model DeleteTmMonitorRuleRequest {
  id?: long(name='Id'),
}

model DeleteTmMonitorRuleResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model DeleteTmMonitorRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTmMonitorRuleResponseBody(name='body'),
}

async function deleteTmMonitorRuleWithOptions(request: DeleteTmMonitorRuleRequest, runtime: Util.RuntimeOptions): DeleteTmMonitorRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteTmMonitorRule', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteTmMonitorRule(request: DeleteTmMonitorRuleRequest): DeleteTmMonitorRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTmMonitorRuleWithOptions(request, runtime);
}

model UploadNotaryDataRequest {
  notaryType?: int32(name='NotaryType'),
  bizOrderNo?: string(name='BizOrderNo'),
  uploadContext?: string(name='UploadContext'),
}

model UploadNotaryDataResponseBody = {
  userAuthUrl?: string(name='UserAuthUrl'),
  requestId?: string(name='RequestId'),
}

model UploadNotaryDataResponse = {
  headers: map[string]string(name='headers'),
  body: UploadNotaryDataResponseBody(name='body'),
}

async function uploadNotaryDataWithOptions(request: UploadNotaryDataRequest, runtime: Util.RuntimeOptions): UploadNotaryDataResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UploadNotaryData', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function uploadNotaryData(request: UploadNotaryDataRequest): UploadNotaryDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadNotaryDataWithOptions(request, runtime);
}

model CopyApplicantRequest {
  id?: long(name='Id'),
}

model CopyApplicantResponseBody = {
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model CopyApplicantResponse = {
  headers: map[string]string(name='headers'),
  body: CopyApplicantResponseBody(name='body'),
}

async function copyApplicantWithOptions(request: CopyApplicantRequest, runtime: Util.RuntimeOptions): CopyApplicantResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CopyApplicant', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function copyApplicant(request: CopyApplicantRequest): CopyApplicantResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyApplicantWithOptions(request, runtime);
}

model PartnerUpdateTrademarkNameRequest {
  tmIcon?: string(name='TmIcon', description='tmIcon'),
  aliyunKp?: string(name='AliyunKp', description='aliyunKp'),
  type?: int32(name='Type', description='type'),
  bizId?: string(name='BizId', description='bizId'),
  callerType?: string(name='CallerType', description='callerType'),
  callerParentId?: long(name='CallerParentId', description='callerParentId'),
  tmComment?: string(name='TmComment', description='tmComment'),
  tmName?: string(name='TmName', description='tmName'),
  bid?: string(name='Bid', description='bid'),
  eventSceneType?: string(name='EventSceneType'),
}

model PartnerUpdateTrademarkNameResponseBody = {
  allowRetry?: boolean(name='AllowRetry', description='allowRetry'),
  requestId?: string(name='RequestId', description='requestId'),
  errorMsg?: string(name='ErrorMsg', description='errorMsg'),
  httpStatusCode?: int32(name='HttpStatusCode', description='httpStatusCode'),
  dynamicCode?: string(name='DynamicCode', description='dynamicCode'),
  errorCode?: string(name='ErrorCode', description='errorCode'),
  dynamicMessage?: string(name='DynamicMessage', description='dynamicMessage'),
  success?: boolean(name='Success', description='success'),
  appName?: string(name='AppName', description='appName'),
}

model PartnerUpdateTrademarkNameResponse = {
  headers: map[string]string(name='headers'),
  body: PartnerUpdateTrademarkNameResponseBody(name='body'),
}

async function partnerUpdateTrademarkNameWithOptions(request: PartnerUpdateTrademarkNameRequest, runtime: Util.RuntimeOptions): PartnerUpdateTrademarkNameResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PartnerUpdateTrademarkName', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function partnerUpdateTrademarkName(request: PartnerUpdateTrademarkNameRequest): PartnerUpdateTrademarkNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return partnerUpdateTrademarkNameWithOptions(request, runtime);
}

model QueryIntentionDetailRequest {
  bizId?: string(name='BizId'),
}

model QueryIntentionDetailResponseBody = {
  status?: int32(name='Status'),
  type?: int32(name='Type'),
  updateTime?: long(name='UpdateTime'),
  relationBizId?: string(name='RelationBizId'),
  createTime?: long(name='CreateTime'),
  userId?: string(name='UserId'),
  bizId?: string(name='BizId'),
  partnerMobile?: string(name='PartnerMobile'),
  requestId?: string(name='RequestId'),
  description?: string(name='Description'),
  mobile?: string(name='Mobile'),
  registerNumber?: string(name='RegisterNumber'),
  classification?: string(name='Classification'),
  userName?: string(name='UserName'),
}

model QueryIntentionDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryIntentionDetailResponseBody(name='body'),
}

async function queryIntentionDetailWithOptions(request: QueryIntentionDetailRequest, runtime: Util.RuntimeOptions): QueryIntentionDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryIntentionDetail', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryIntentionDetail(request: QueryIntentionDetailRequest): QueryIntentionDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIntentionDetailWithOptions(request, runtime);
}

model QueryIntentionPriceRequest {
  intentionBizId?: string(name='IntentionBizId'),
  channel?: string(name='Channel'),
}

model QueryIntentionPriceResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  totalPageNum?: int32(name='TotalPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalItemNum?: int32(name='TotalItemNum'),
  data?: {
    tmProduces?: [ 
    {
      type?: int32(name='Type'),
      status?: int32(name='Status'),
      orderPrice?: float(name='OrderPrice'),
      updateTime?: long(name='UpdateTime'),
      materialName?: string(name='MaterialName'),
      createTime?: long(name='CreateTime'),
      bizId?: string(name='BizId'),
      servicePrice?: float(name='ServicePrice'),
      tmIcon?: string(name='TmIcon'),
      tmName?: string(name='TmName'),
      materialId?: string(name='MaterialId'),
      supplementId?: long(name='SupplementId'),
      loaUrl?: string(name='LoaUrl'),
      tmNumber?: string(name='TmNumber'),
      note?: string(name='Note'),
      supplementStatus?: int32(name='SupplementStatus'),
      totalPrice?: float(name='TotalPrice'),
      thirdClassification?: {
        thirdClassifications?: [ 
        {
          classificationName?: string(name='ClassificationName'),
          classificationCode?: string(name='ClassificationCode'),
        }
      ](name='ThirdClassifications')
      }(name='ThirdClassification'),
      firstClassification?: {
        classificationName?: string(name='ClassificationName'),
        classificationCode?: string(name='ClassificationCode'),
      }(name='FirstClassification'),
    }
  ](name='TmProduces')
  }(name='Data'),
}

model QueryIntentionPriceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryIntentionPriceResponseBody(name='body'),
}

async function queryIntentionPriceWithOptions(request: QueryIntentionPriceRequest, runtime: Util.RuntimeOptions): QueryIntentionPriceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryIntentionPrice', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryIntentionPrice(request: QueryIntentionPriceRequest): QueryIntentionPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIntentionPriceWithOptions(request, runtime);
}

model QueryOfficialFileCustomListRequest {
  pageSize?: int32(name='PageSize'),
  pageNum?: int32(name='PageNum'),
}

model QueryOfficialFileCustomListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  totalPageNum?: int32(name='TotalPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalItemNum?: int32(name='TotalItemNum'),
  data?: {
    customList?: [ 
    {
      status?: string(name='Status'),
      expireTime?: long(name='ExpireTime'),
      remark?: string(name='Remark'),
      downloadUrl?: string(name='DownloadUrl'),
      createTime?: long(name='CreateTime'),
      endAcceptTime?: long(name='EndAcceptTime'),
      startAcceptTime?: long(name='StartAcceptTime'),
    }
  ](name='CustomList')
  }(name='Data'),
}

model QueryOfficialFileCustomListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryOfficialFileCustomListResponseBody(name='body'),
}

async function queryOfficialFileCustomListWithOptions(request: QueryOfficialFileCustomListRequest, runtime: Util.RuntimeOptions): QueryOfficialFileCustomListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryOfficialFileCustomList', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryOfficialFileCustomList(request: QueryOfficialFileCustomListRequest): QueryOfficialFileCustomListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOfficialFileCustomListWithOptions(request, runtime);
}

model CheckTrademarkIconRequest {
  trademarkIconOssKey?: string(name='TrademarkIconOssKey'),
  eventSceneType?: int32(name='EventSceneType'),
}

model CheckTrademarkIconResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CheckTrademarkIconResponse = {
  headers: map[string]string(name='headers'),
  body: CheckTrademarkIconResponseBody(name='body'),
}

async function checkTrademarkIconWithOptions(request: CheckTrademarkIconRequest, runtime: Util.RuntimeOptions): CheckTrademarkIconResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CheckTrademarkIcon', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkTrademarkIcon(request: CheckTrademarkIconRequest): CheckTrademarkIconResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkTrademarkIconWithOptions(request, runtime);
}

model QuerySupplementDetailRequest {
  id?: long(name='Id'),
}

model QuerySupplementDetailResponseBody = {
  operateTime?: long(name='OperateTime'),
  serialNumber?: string(name='SerialNumber'),
  status?: int32(name='Status'),
  type?: int32(name='Type'),
  sbjDeadTime?: long(name='SbjDeadTime'),
  acceptDeadTime?: long(name='AcceptDeadTime'),
  sendTime?: long(name='SendTime'),
  acceptTime?: long(name='AcceptTime'),
  requestId?: string(name='RequestId'),
  tmNumber?: string(name='TmNumber'),
  uploadFileTemplateUrl?: string(name='UploadFileTemplateUrl'),
  content?: string(name='Content'),
  id?: long(name='Id'),
  fileTemplateUrls?: {
    fileTemplateUrls?: [ string ](name='FileTemplateUrls')
  }(name='FileTemplateUrls'),
}

model QuerySupplementDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySupplementDetailResponseBody(name='body'),
}

async function querySupplementDetailWithOptions(request: QuerySupplementDetailRequest, runtime: Util.RuntimeOptions): QuerySupplementDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QuerySupplementDetail', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function querySupplementDetail(request: QuerySupplementDetailRequest): QuerySupplementDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySupplementDetailWithOptions(request, runtime);
}

model UploadTrademarkOnSaleRequest {
  classificationCode?: string(name='ClassificationCode'),
  tmName?: string(name='TmName'),
  tmIcon?: string(name='TmIcon'),
  originalPrice?: float(name='OriginalPrice'),
  tmNumber?: string(name='TmNumber'),
  endTime?: long(name='EndTime'),
  beginTime?: long(name='BeginTime'),
  description?: string(name='Description'),
  label?: string(name='Label'),
  regAnnDate?: long(name='RegAnnDate'),
  ownerName?: string(name='OwnerName'),
  ownerEnName?: string(name='OwnerEnName'),
  secondaryClassification?: string(name='SecondaryClassification'),
  thirdClassification?: string(name='ThirdClassification'),
  type?: string(name='Type'),
  reason?: string(name='Reason'),
  status?: string(name='Status'),
}

model UploadTrademarkOnSaleResponseBody = {
  requestId?: string(name='RequestId'),
}

model UploadTrademarkOnSaleResponse = {
  headers: map[string]string(name='headers'),
  body: UploadTrademarkOnSaleResponseBody(name='body'),
}

async function uploadTrademarkOnSaleWithOptions(request: UploadTrademarkOnSaleRequest, runtime: Util.RuntimeOptions): UploadTrademarkOnSaleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UploadTrademarkOnSale', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function uploadTrademarkOnSale(request: UploadTrademarkOnSaleRequest): UploadTrademarkOnSaleResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadTrademarkOnSaleWithOptions(request, runtime);
}

model ApplyNotaryPostRequest {
  notaryOrderId?: long(name='NotaryOrderId'),
  receiverName?: string(name='ReceiverName'),
  receiverAddress?: string(name='ReceiverAddress'),
  receiverPhone?: string(name='ReceiverPhone'),
}

model ApplyNotaryPostResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model ApplyNotaryPostResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyNotaryPostResponseBody(name='body'),
}

async function applyNotaryPostWithOptions(request: ApplyNotaryPostRequest, runtime: Util.RuntimeOptions): ApplyNotaryPostResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ApplyNotaryPost', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function applyNotaryPost(request: ApplyNotaryPostRequest): ApplyNotaryPostResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyNotaryPostWithOptions(request, runtime);
}

model QueryTradeMarkApplicationsByIntentionRequest {
  intentionBizId?: string(name='IntentionBizId'),
  channel?: string(name='Channel'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tmProduceStatus?: string(name='TmProduceStatus'),
}

model QueryTradeMarkApplicationsByIntentionResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  totalPageNum?: int32(name='TotalPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalItemNum?: int32(name='TotalItemNum'),
  data?: {
    tmProduces?: [ 
    {
      principalDescription?: string(name='PrincipalDescription'),
      type?: int32(name='Type'),
      status?: int32(name='Status'),
      orderPrice?: float(name='OrderPrice'),
      updateTime?: long(name='UpdateTime'),
      materialName?: string(name='MaterialName'),
      principalValue?: int32(name='PrincipalValue'),
      createTime?: long(name='CreateTime'),
      bizId?: string(name='BizId'),
      servicePrice?: float(name='ServicePrice'),
      tmIcon?: string(name='TmIcon'),
      tmName?: string(name='TmName'),
      materialId?: string(name='MaterialId'),
      supplementId?: long(name='SupplementId'),
      loaUrl?: string(name='LoaUrl'),
      tmNumber?: string(name='TmNumber'),
      note?: string(name='Note'),
      supplementStatus?: int32(name='SupplementStatus'),
      totalPrice?: float(name='TotalPrice'),
      thirdClassification?: {
        thirdClassifications?: [ 
        {
          classificationName?: string(name='ClassificationName'),
          classificationCode?: string(name='ClassificationCode'),
        }
      ](name='ThirdClassifications')
      }(name='ThirdClassification'),
      firstClassification?: {
        classificationName?: string(name='ClassificationName'),
        classificationCode?: string(name='ClassificationCode'),
      }(name='FirstClassification'),
    }
  ](name='TmProduces')
  }(name='Data'),
}

model QueryTradeMarkApplicationsByIntentionResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTradeMarkApplicationsByIntentionResponseBody(name='body'),
}

async function queryTradeMarkApplicationsByIntentionWithOptions(request: QueryTradeMarkApplicationsByIntentionRequest, runtime: Util.RuntimeOptions): QueryTradeMarkApplicationsByIntentionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTradeMarkApplicationsByIntention', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTradeMarkApplicationsByIntention(request: QueryTradeMarkApplicationsByIntentionRequest): QueryTradeMarkApplicationsByIntentionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeMarkApplicationsByIntentionWithOptions(request, runtime);
}

model SaveExtensionAttributeRequest {
  bizId?: string(name='BizId'),
  attributeKey?: string(name='AttributeKey'),
  attributeValue?: string(name='AttributeValue'),
}

model SaveExtensionAttributeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveExtensionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: SaveExtensionAttributeResponseBody(name='body'),
}

async function saveExtensionAttributeWithOptions(request: SaveExtensionAttributeRequest, runtime: Util.RuntimeOptions): SaveExtensionAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveExtensionAttribute', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveExtensionAttribute(request: SaveExtensionAttributeRequest): SaveExtensionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveExtensionAttributeWithOptions(request, runtime);
}

model AcceptPartnerNotificationRequest {
  bizId?: string(name='BizId'),
  operation?: string(name='Operation'),
  material?: string(name='Material'),
  remark?: string(name='Remark'),
}

model AcceptPartnerNotificationResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model AcceptPartnerNotificationResponse = {
  headers: map[string]string(name='headers'),
  body: AcceptPartnerNotificationResponseBody(name='body'),
}

async function acceptPartnerNotificationWithOptions(request: AcceptPartnerNotificationRequest, runtime: Util.RuntimeOptions): AcceptPartnerNotificationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AcceptPartnerNotification', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function acceptPartnerNotification(request: AcceptPartnerNotificationRequest): AcceptPartnerNotificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return acceptPartnerNotificationWithOptions(request, runtime);
}

model SubmitSupplementRequest {
  id?: long(name='Id'),
  uploadOssKeyList?: map[string]any(name='UploadOssKeyList'),
  content?: string(name='Content'),
}

model SubmitSupplementShrinkRequest {
  id?: long(name='Id'),
  uploadOssKeyListShrink?: string(name='UploadOssKeyList'),
  content?: string(name='Content'),
}

model SubmitSupplementResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model SubmitSupplementResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitSupplementResponseBody(name='body'),
}

async function submitSupplementWithOptions(tmpReq: SubmitSupplementRequest, runtime: Util.RuntimeOptions): SubmitSupplementResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitSupplementShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.uploadOssKeyList)) {
    request.uploadOssKeyListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.uploadOssKeyList, 'UploadOssKeyList', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitSupplement', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitSupplement(request: SubmitSupplementRequest): SubmitSupplementResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSupplementWithOptions(request, runtime);
}

model ForceUploadTrademarkOnsaleRequest {
  classificationCode?: string(name='ClassificationCode'),
  tmName?: string(name='TmName'),
  tmIcon?: string(name='TmIcon'),
  originalPrice?: float(name='OriginalPrice'),
  tmNumber?: string(name='TmNumber'),
  endTime?: long(name='EndTime'),
  beginTime?: long(name='BeginTime'),
  description?: string(name='Description'),
  label?: string(name='Label'),
  regAnnDate?: long(name='RegAnnDate'),
  ownerName?: string(name='OwnerName'),
  ownerEnName?: string(name='OwnerEnName'),
  secondaryClassification?: string(name='SecondaryClassification'),
  thirdClassification?: string(name='ThirdClassification'),
  type?: string(name='Type'),
  reason?: string(name='Reason'),
}

model ForceUploadTrademarkOnsaleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ForceUploadTrademarkOnsaleResponse = {
  headers: map[string]string(name='headers'),
  body: ForceUploadTrademarkOnsaleResponseBody(name='body'),
}

async function forceUploadTrademarkOnsaleWithOptions(request: ForceUploadTrademarkOnsaleRequest, runtime: Util.RuntimeOptions): ForceUploadTrademarkOnsaleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ForceUploadTrademarkOnsale', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function forceUploadTrademarkOnsale(request: ForceUploadTrademarkOnsaleRequest): ForceUploadTrademarkOnsaleResponse {
  var runtime = new Util.RuntimeOptions{};
  return forceUploadTrademarkOnsaleWithOptions(request, runtime);
}

model BindMaterialRequest {
  materialId?: string(name='MaterialId'),
  bizId?: string(name='BizId'),
  loaOssKey?: string(name='LoaOssKey'),
  legalNoticeKey?: string(name='LegalNoticeKey'),
}

model BindMaterialResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindMaterialResponse = {
  headers: map[string]string(name='headers'),
  body: BindMaterialResponseBody(name='body'),
}

async function bindMaterialWithOptions(request: BindMaterialRequest, runtime: Util.RuntimeOptions): BindMaterialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('BindMaterial', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function bindMaterial(request: BindMaterialRequest): BindMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindMaterialWithOptions(request, runtime);
}

model GetDefaultPrincipalResponseBody = {
  principalDescription?: string(name='PrincipalDescription'),
  principalName?: string(name='PrincipalName'),
  requestId?: string(name='RequestId'),
  principalValue?: int32(name='PrincipalValue'),
}

model GetDefaultPrincipalResponse = {
  headers: map[string]string(name='headers'),
  body: GetDefaultPrincipalResponseBody(name='body'),
}

async function getDefaultPrincipalWithOptions(runtime: Util.RuntimeOptions): GetDefaultPrincipalResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('GetDefaultPrincipal', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getDefaultPrincipal(): GetDefaultPrincipalResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefaultPrincipalWithOptions(runtime);
}

model QueryCommunicationLogsRequest {
  bizId?: string(name='BizId'),
  type?: int32(name='Type'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model QueryCommunicationLogsResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    taskList?: [ 
    {
      note?: string(name='Note'),
      bizId?: string(name='BizId'),
      updateTime?: long(name='UpdateTime'),
      partnerCode?: string(name='PartnerCode'),
      createTime?: long(name='CreateTime'),
    }
  ](name='TaskList')
  }(name='Data'),
}

model QueryCommunicationLogsResponse = {
  headers: map[string]string(name='headers'),
  body: QueryCommunicationLogsResponseBody(name='body'),
}

async function queryCommunicationLogsWithOptions(request: QueryCommunicationLogsRequest, runtime: Util.RuntimeOptions): QueryCommunicationLogsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryCommunicationLogs', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryCommunicationLogs(request: QueryCommunicationLogsRequest): QueryCommunicationLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCommunicationLogsWithOptions(request, runtime);
}

model GenerateQrCodeRequest {
  uuid?: string(name='Uuid'),
  ossKey?: string(name='OssKey'),
  fieldKey?: string(name='FieldKey'),
}

model GenerateQrCodeResponseBody = {
  uuid?: string(name='Uuid'),
  requestId?: string(name='RequestId'),
  expireTime?: long(name='ExpireTime'),
  success?: boolean(name='Success'),
  qrcodeUrl?: string(name='QrcodeUrl'),
  fieldKey?: string(name='FieldKey'),
}

model GenerateQrCodeResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateQrCodeResponseBody(name='body'),
}

async function generateQrCodeWithOptions(request: GenerateQrCodeRequest, runtime: Util.RuntimeOptions): GenerateQrCodeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GenerateQrCode', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function generateQrCode(request: GenerateQrCodeRequest): GenerateQrCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateQrCodeWithOptions(request, runtime);
}

model ConfirmDissentOriginalRequest {
  bizId?: string(name='BizId'),
  contactName?: string(name='ContactName'),
  contactAddress?: string(name='ContactAddress'),
  contactNumber?: string(name='ContactNumber'),
  contactProvince?: string(name='ContactProvince'),
  contactCity?: string(name='ContactCity'),
  contactDistrict?: string(name='ContactDistrict'),
  contactCounty?: string(name='ContactCounty'),
}

model ConfirmDissentOriginalResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfirmDissentOriginalResponse = {
  headers: map[string]string(name='headers'),
  body: ConfirmDissentOriginalResponseBody(name='body'),
}

async function confirmDissentOriginalWithOptions(request: ConfirmDissentOriginalRequest, runtime: Util.RuntimeOptions): ConfirmDissentOriginalResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConfirmDissentOriginal', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function confirmDissentOriginal(request: ConfirmDissentOriginalRequest): ConfirmDissentOriginalResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmDissentOriginalWithOptions(request, runtime);
}

model ConvertImageToGrayRequest {
  ossKey?: string(name='OssKey'),
}

model ConvertImageToGrayResponseBody = {
  signatureUrl?: string(name='SignatureUrl'),
  requestId?: string(name='RequestId'),
}

model ConvertImageToGrayResponse = {
  headers: map[string]string(name='headers'),
  body: ConvertImageToGrayResponseBody(name='body'),
}

async function convertImageToGrayWithOptions(request: ConvertImageToGrayRequest, runtime: Util.RuntimeOptions): ConvertImageToGrayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConvertImageToGray', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function convertImageToGray(request: ConvertImageToGrayRequest): ConvertImageToGrayResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertImageToGrayWithOptions(request, runtime);
}

model QueryIntentionListRequest {
  type?: int32(name='Type'),
  status?: int32(name='Status'),
  pageSize?: int32(name='PageSize'),
  pageNum?: int32(name='PageNum'),
  sortFiled?: string(name='SortFiled'),
  sortOrder?: string(name='SortOrder'),
}

model QueryIntentionListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  totalPageNum?: int32(name='TotalPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalItemNum?: int32(name='TotalItemNum'),
  data?: {
    intention?: [ 
    {
      type?: int32(name='Type'),
      status?: int32(name='Status'),
      updateTime?: long(name='UpdateTime'),
      description?: string(name='Description'),
      registerNumber?: string(name='RegisterNumber'),
      createTime?: long(name='CreateTime'),
      userId?: string(name='UserId'),
      bizId?: string(name='BizId'),
      classification?: string(name='Classification'),
    }
  ](name='Intention')
  }(name='Data'),
}

model QueryIntentionListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryIntentionListResponseBody(name='body'),
}

async function queryIntentionListWithOptions(request: QueryIntentionListRequest, runtime: Util.RuntimeOptions): QueryIntentionListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryIntentionList', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryIntentionList(request: QueryIntentionListRequest): QueryIntentionListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIntentionListWithOptions(request, runtime);
}

model GetAuthorizationLetterVersionRequest {
  ossKey?: string(name='OssKey'),
}

model GetAuthorizationLetterVersionResponseBody = {
  version?: string(name='Version'),
  requestId?: string(name='RequestId'),
}

model GetAuthorizationLetterVersionResponse = {
  headers: map[string]string(name='headers'),
  body: GetAuthorizationLetterVersionResponseBody(name='body'),
}

async function getAuthorizationLetterVersionWithOptions(request: GetAuthorizationLetterVersionRequest, runtime: Util.RuntimeOptions): GetAuthorizationLetterVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetAuthorizationLetterVersion', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getAuthorizationLetterVersion(request: GetAuthorizationLetterVersionRequest): GetAuthorizationLetterVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuthorizationLetterVersionWithOptions(request, runtime);
}

model QueryTrademarkPriceRequest {
  userId?: long(name='UserId'),
  tmName?: string(name='TmName'),
  tmIcon?: string(name='TmIcon'),
  type?: int32(name='Type'),
  orderData?: map[string]any(name='OrderData'),
}

model QueryTrademarkPriceShrinkRequest {
  userId?: long(name='UserId'),
  tmName?: string(name='TmName'),
  tmIcon?: string(name='TmIcon'),
  type?: int32(name='Type'),
  orderDataShrink?: string(name='OrderData'),
}

model QueryTrademarkPriceResponseBody = {
  originalPrice?: float(name='OriginalPrice'),
  requestId?: string(name='RequestId'),
  discountPrice?: float(name='DiscountPrice'),
  currency?: string(name='Currency'),
  tradePrice?: float(name='TradePrice'),
  prices?: {
    prices?: [ 
    {
      originalPrice?: float(name='OriginalPrice'),
      discountPrice?: float(name='DiscountPrice'),
      currency?: string(name='Currency'),
      tradePrice?: float(name='TradePrice'),
      classificationCode?: string(name='ClassificationCode'),
    }
  ](name='Prices')
  }(name='Prices'),
}

model QueryTrademarkPriceResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTrademarkPriceResponseBody(name='body'),
}

async function queryTrademarkPriceWithOptions(tmpReq: QueryTrademarkPriceRequest, runtime: Util.RuntimeOptions): QueryTrademarkPriceResponse {
  Util.validateModel(tmpReq);
  var request = new QueryTrademarkPriceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.orderData)) {
    request.orderDataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.orderData, 'OrderData', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTrademarkPrice', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTrademarkPrice(request: QueryTrademarkPriceRequest): QueryTrademarkPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkPriceWithOptions(request, runtime);
}

model InsertTmMonitorRuleRequest {
  ruleSource?: string(name='RuleSource'),
  ruleName?: string(name='RuleName'),
  ruleType?: int32(name='RuleType'),
  ruleKeyword?: string(name='RuleKeyword'),
  startApplyDate?: string(name='StartApplyDate'),
  endApplyDate?: string(name='EndApplyDate'),
  classification?: map[string]any(name='Classification'),
  notifyStatus?: map[string]any(name='NotifyStatus'),
}

model InsertTmMonitorRuleShrinkRequest {
  ruleSource?: string(name='RuleSource'),
  ruleName?: string(name='RuleName'),
  ruleType?: int32(name='RuleType'),
  ruleKeyword?: string(name='RuleKeyword'),
  startApplyDate?: string(name='StartApplyDate'),
  endApplyDate?: string(name='EndApplyDate'),
  classificationShrink?: string(name='Classification'),
  notifyStatusShrink?: string(name='NotifyStatus'),
}

model InsertTmMonitorRuleResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model InsertTmMonitorRuleResponse = {
  headers: map[string]string(name='headers'),
  body: InsertTmMonitorRuleResponseBody(name='body'),
}

async function insertTmMonitorRuleWithOptions(tmpReq: InsertTmMonitorRuleRequest, runtime: Util.RuntimeOptions): InsertTmMonitorRuleResponse {
  Util.validateModel(tmpReq);
  var request = new InsertTmMonitorRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.classification)) {
    request.classificationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.classification, 'Classification', 'json');
  }
  if (!Util.isUnset(tmpReq.notifyStatus)) {
    request.notifyStatusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notifyStatus, 'NotifyStatus', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('InsertTmMonitorRule', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function insertTmMonitorRule(request: InsertTmMonitorRuleRequest): InsertTmMonitorRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertTmMonitorRuleWithOptions(request, runtime);
}

model QueryTrademarkMonitorRulesRequest {
  id?: string(name='Id'),
  ruleName?: string(name='RuleName'),
  notifyUpdate?: int32(name='NotifyUpdate'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model QueryTrademarkMonitorRulesResponseBody = {
  nextPage?: boolean(name='NextPage'),
  requestId?: string(name='RequestId'),
  prePage?: boolean(name='PrePage'),
  totalItemNum?: int32(name='TotalItemNum'),
  currentPageNum?: int32(name='CurrentPageNum'),
  totalPageNum?: int32(name='TotalPageNum'),
  pageSize?: int32(name='PageSize'),
  data?: {
    tmMonitorRule?: [ 
    {
      ruleStatus?: string(name='RuleStatus'),
      lastFinishTime?: string(name='LastFinishTime'),
      updateTime?: string(name='UpdateTime'),
      ruleType?: int32(name='RuleType'),
      createTime?: string(name='CreateTime'),
      userId?: string(name='UserId'),
      ruleExtend?: string(name='RuleExtend'),
      ruleName?: string(name='RuleName'),
      endTime?: string(name='EndTime'),
      startTime?: string(name='StartTime'),
      ruleKeyword?: string(name='RuleKeyword'),
      lastRunTime?: string(name='LastRunTime'),
      version?: int32(name='Version'),
      ruleSource?: string(name='RuleSource'),
      lastUpdateTime?: string(name='LastUpdateTime'),
      env?: string(name='Env'),
      notifyUpdate?: int32(name='NotifyUpdate'),
      ruleDetail?: string(name='RuleDetail'),
      id?: string(name='Id'),
    }
  ](name='TmMonitorRule')
  }(name='Data'),
}

model QueryTrademarkMonitorRulesResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTrademarkMonitorRulesResponseBody(name='body'),
}

async function queryTrademarkMonitorRulesWithOptions(request: QueryTrademarkMonitorRulesRequest, runtime: Util.RuntimeOptions): QueryTrademarkMonitorRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTrademarkMonitorRules', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTrademarkMonitorRules(request: QueryTrademarkMonitorRulesRequest): QueryTrademarkMonitorRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkMonitorRulesWithOptions(request, runtime);
}

model DenySupplementRequest {
  id?: long(name='Id'),
}

model DenySupplementResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model DenySupplementResponse = {
  headers: map[string]string(name='headers'),
  body: DenySupplementResponseBody(name='body'),
}

async function denySupplementWithOptions(request: DenySupplementRequest, runtime: Util.RuntimeOptions): DenySupplementResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DenySupplement', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function denySupplement(request: DenySupplementRequest): DenySupplementResponse {
  var runtime = new Util.RuntimeOptions{};
  return denySupplementWithOptions(request, runtime);
}

model QueryMaterialRequest {
  id?: long(name='Id'),
  queryUnconfirmedInfo?: boolean(name='QueryUnconfirmedInfo'),
}

model QueryMaterialResponseBody = {
  type?: int32(name='Type'),
  status?: int32(name='Status'),
  reviewApplicationFile?: string(name='ReviewApplicationFile'),
  contactDistrict?: string(name='ContactDistrict'),
  businessLicenceUrl?: string(name='BusinessLicenceUrl'),
  passportUrl?: string(name='PassportUrl'),
  contactProvince?: string(name='ContactProvince'),
  legalNoticeUrl?: string(name='LegalNoticeUrl'),
  city?: string(name='City'),
  EAddress?: string(name='EAddress'),
  contactCounty?: string(name='ContactCounty'),
  contactEmail?: string(name='ContactEmail'),
  requestId?: string(name='RequestId'),
  contactCity?: string(name='ContactCity'),
  region?: int32(name='Region'),
  loaUrl?: string(name='LoaUrl'),
  address?: string(name='Address'),
  note?: string(name='Note'),
  principalName?: int32(name='PrincipalName'),
  name?: string(name='Name'),
  principalDescription?: string(name='PrincipalDescription'),
  contactNumber?: string(name='ContactNumber'),
  contactAddress?: string(name='ContactAddress'),
  contactZipcode?: string(name='ContactZipcode'),
  contactName?: string(name='ContactName'),
  EName?: string(name='EName'),
  validDate?: long(name='ValidDate'),
  idCardUrl?: string(name='IdCardUrl'),
  expirationDate?: long(name='ExpirationDate'),
  cardNumber?: string(name='CardNumber'),
  country?: string(name='Country'),
  town?: string(name='Town'),
  loaStatus?: int32(name='LoaStatus'),
  reason?: string(name='Reason'),
  id?: long(name='Id'),
  province?: string(name='Province'),
  legalNoticeKey?: string(name='LegalNoticeKey'),
  reviewAdditionalFiles?: {
    reviewAdditionalFile?: [ string ](name='ReviewAdditionalFile')
  }(name='ReviewAdditionalFiles'),
}

model QueryMaterialResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMaterialResponseBody(name='body'),
}

async function queryMaterialWithOptions(request: QueryMaterialRequest, runtime: Util.RuntimeOptions): QueryMaterialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMaterial', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMaterial(request: QueryMaterialRequest): QueryMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMaterialWithOptions(request, runtime);
}

model CreateTrademarkOrderRequest {
  userId?: long(name='UserId'),
  tmName?: string(name='TmName'),
  tmIcon?: string(name='TmIcon'),
  type?: int32(name='Type'),
  orderData?: string(name='OrderData'),
  materialId?: string(name='MaterialId'),
  loaOssKey?: string(name='LoaOssKey'),
  isBlackIcon?: boolean(name='IsBlackIcon'),
  renewInfoId?: string(name='RenewInfoId'),
  rootCode?: string(name='RootCode'),
  channel?: string(name='Channel'),
  registerNumber?: string(name='RegisterNumber'),
  tmNameType?: string(name='TmNameType'),
  registerName?: string(name='RegisterName'),
  tmComment?: string(name='TmComment'),
  bizId?: string(name='BizId'),
  uid?: string(name='Uid'),
  partnerCode?: string(name='PartnerCode'),
  realUserName?: string(name='RealUserName'),
  phoneNum?: string(name='PhoneNum'),
  principalName?: int32(name='PrincipalName'),
  bigDipperSource?: string(name='BigDipperSource'),
  ua?: string(name='Ua'),
  legalNoticeKey?: string(name='LegalNoticeKey'),
}

model CreateTrademarkOrderResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  orderId?: long(name='OrderId'),
}

model CreateTrademarkOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTrademarkOrderResponseBody(name='body'),
}

async function createTrademarkOrderWithOptions(request: CreateTrademarkOrderRequest, runtime: Util.RuntimeOptions): CreateTrademarkOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateTrademarkOrder', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createTrademarkOrder(request: CreateTrademarkOrderRequest): CreateTrademarkOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTrademarkOrderWithOptions(request, runtime);
}

model QueryMaterialListRequest {
  name?: string(name='Name'),
  type?: int32(name='Type'),
  region?: int32(name='Region'),
  status?: int32(name='Status'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  cardNumber?: string(name='CardNumber'),
  principalName?: int32(name='PrincipalName'),
  materialId?: long(name='MaterialId'),
}

model QueryMaterialListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  totalPageNum?: int32(name='TotalPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalItemNum?: int32(name='TotalItemNum'),
  data?: {
    trademark?: [ 
    {
      principalDescription?: string(name='PrincipalDescription'),
      status?: int32(name='Status'),
      type?: int32(name='Type'),
      contactName?: string(name='ContactName'),
      cardNumber?: string(name='CardNumber'),
      validDate?: long(name='ValidDate'),
      region?: int32(name='Region'),
      principalName?: int32(name='PrincipalName'),
      loaStatus?: int32(name='LoaStatus'),
      name?: string(name='Name'),
      loaKey?: string(name='LoaKey'),
      id?: long(name='Id'),
      reason?: string(name='Reason'),
    }
  ](name='Trademark')
  }(name='Data'),
}

model QueryMaterialListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMaterialListResponseBody(name='body'),
}

async function queryMaterialListWithOptions(request: QueryMaterialListRequest, runtime: Util.RuntimeOptions): QueryMaterialListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMaterialList', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMaterialList(request: QueryMaterialListRequest): QueryMaterialListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMaterialListWithOptions(request, runtime);
}

model CheckTrademarkOrderRequest {
  userId?: long(name='UserId'),
  tmName?: string(name='TmName'),
  tmIcon?: string(name='TmIcon'),
  type?: int32(name='Type'),
  orderData?: string(name='OrderData'),
  materialId?: string(name='MaterialId'),
  loaOssKey?: string(name='LoaOssKey'),
  isBlackIcon?: boolean(name='IsBlackIcon'),
  renewInfoId?: string(name='RenewInfoId'),
  rootCode?: string(name='RootCode'),
  channel?: string(name='Channel'),
  registerNumber?: string(name='RegisterNumber'),
  tmNameType?: string(name='TmNameType'),
  registerName?: string(name='RegisterName'),
  tmComment?: string(name='TmComment'),
  bizId?: string(name='BizId'),
  uid?: string(name='Uid'),
  partnerCode?: string(name='PartnerCode'),
  realUserName?: string(name='RealUserName'),
  phoneNum?: string(name='PhoneNum'),
  logoGoodsId?: string(name='LogoGoodsId'),
}

model CheckTrademarkOrderResponseBody = {
  data?: map[string]any(name='Data'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckTrademarkOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CheckTrademarkOrderResponseBody(name='body'),
}

async function checkTrademarkOrderWithOptions(request: CheckTrademarkOrderRequest, runtime: Util.RuntimeOptions): CheckTrademarkOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CheckTrademarkOrder', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkTrademarkOrder(request: CheckTrademarkOrderRequest): CheckTrademarkOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkTrademarkOrderWithOptions(request, runtime);
}

model QueryTradeMarkApplicationsRequest {
  tmName?: string(name='TmName'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  materialName?: string(name='MaterialName'),
  tmNumber?: string(name='TmNumber'),
  orderId?: string(name='OrderId'),
  status?: int32(name='Status'),
  supplementStatus?: int32(name='SupplementStatus'),
  sortOrder?: string(name='SortOrder'),
  type?: string(name='Type'),
  bizId?: string(name='BizId'),
  intentionBizId?: string(name='IntentionBizId'),
  hidden?: int32(name='Hidden'),
  productType?: int32(name='ProductType'),
  logisticsNo?: string(name='LogisticsNo'),
  classificationCode?: string(name='ClassificationCode'),
  sortFiled?: string(name='SortFiled'),
}

model QueryTradeMarkApplicationsResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  totalPageNum?: int32(name='TotalPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalItemNum?: int32(name='TotalItemNum'),
  data?: {
    tmProduces?: [ 
    {
      type?: int32(name='Type'),
      status?: int32(name='Status'),
      orderPrice?: float(name='OrderPrice'),
      submitAuditTime?: long(name='SubmitAuditTime'),
      updateTime?: long(name='UpdateTime'),
      materialName?: string(name='MaterialName'),
      remark?: string(name='Remark'),
      createTime?: long(name='CreateTime'),
      userId?: string(name='UserId'),
      bizId?: string(name='BizId'),
      servicePrice?: float(name='ServicePrice'),
      tmIcon?: string(name='TmIcon'),
      tmName?: string(name='TmName'),
      materialId?: long(name='MaterialId'),
      supplementId?: long(name='SupplementId'),
      loaUrl?: string(name='LoaUrl'),
      tmNumber?: string(name='TmNumber'),
      note?: string(name='Note'),
      supplementStatus?: int32(name='SupplementStatus'),
      principalName?: int32(name='PrincipalName'),
      totalPrice?: float(name='TotalPrice'),
      submitTime?: long(name='SubmitTime'),
      orderId?: string(name='OrderId'),
      thirdClassification?: {
        thirdClassifications?: [ 
        {
          classificationName?: string(name='ClassificationName'),
          classificationCode?: string(name='ClassificationCode'),
        }
      ](name='ThirdClassifications')
      }(name='ThirdClassification'),
      flags?: {
        flags?: [ string ](name='Flags')
      }(name='Flags'),
      firstClassification?: {
        classificationName?: string(name='ClassificationName'),
        classificationCode?: string(name='ClassificationCode'),
      }(name='FirstClassification'),
      renewResponse?: {
        engName?: string(name='EngName'),
        registerTime?: long(name='RegisterTime'),
        engAddress?: string(name='EngAddress'),
        address?: string(name='Address'),
        name?: string(name='Name'),
        submitSbjtime?: long(name='SubmitSbjtime'),
      }(name='RenewResponse'),
    }
  ](name='TmProduces')
  }(name='Data'),
}

model QueryTradeMarkApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTradeMarkApplicationsResponseBody(name='body'),
}

async function queryTradeMarkApplicationsWithOptions(request: QueryTradeMarkApplicationsRequest, runtime: Util.RuntimeOptions): QueryTradeMarkApplicationsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTradeMarkApplications', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTradeMarkApplications(request: QueryTradeMarkApplicationsRequest): QueryTradeMarkApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeMarkApplicationsWithOptions(request, runtime);
}

model UpdateApplicantContacterRequest {
  contactAddress?: string(name='ContactAddress'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactEmail?: string(name='ContactEmail'),
  applicantId?: long(name='ApplicantId'),
  contactZipCode?: string(name='ContactZipCode'),
  bizId?: string(name='BizId'),
}

model UpdateApplicantContacterResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateApplicantContacterResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateApplicantContacterResponseBody(name='body'),
}

async function updateApplicantContacterWithOptions(request: UpdateApplicantContacterRequest, runtime: Util.RuntimeOptions): UpdateApplicantContacterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateApplicantContacter', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateApplicantContacter(request: UpdateApplicantContacterRequest): UpdateApplicantContacterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateApplicantContacterWithOptions(request, runtime);
}

model SaveTaskRequest {
  request?: string(name='Request'),
  bizType?: string(name='BizType'),
}

model SaveTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model SaveTaskResponse = {
  headers: map[string]string(name='headers'),
  body: SaveTaskResponseBody(name='body'),
}

async function saveTaskWithOptions(request: SaveTaskRequest, runtime: Util.RuntimeOptions): SaveTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveTask', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveTask(request: SaveTaskRequest): SaveTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskWithOptions(request, runtime);
}

model SubmitTrademarkApplicationComplaintRequest {
  bizId?: string(name='BizId'),
  files?: map[string]any(name='Files'),
  content?: string(name='Content'),
}

model SubmitTrademarkApplicationComplaintShrinkRequest {
  bizId?: string(name='BizId'),
  filesShrink?: string(name='Files'),
  content?: string(name='Content'),
}

model SubmitTrademarkApplicationComplaintResponseBody = {
  requestId?: string(name='RequestId'),
}

model SubmitTrademarkApplicationComplaintResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitTrademarkApplicationComplaintResponseBody(name='body'),
}

async function submitTrademarkApplicationComplaintWithOptions(tmpReq: SubmitTrademarkApplicationComplaintRequest, runtime: Util.RuntimeOptions): SubmitTrademarkApplicationComplaintResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitTrademarkApplicationComplaintShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.files)) {
    request.filesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.files, 'Files', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitTrademarkApplicationComplaint', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitTrademarkApplicationComplaint(request: SubmitTrademarkApplicationComplaintRequest): SubmitTrademarkApplicationComplaintResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitTrademarkApplicationComplaintWithOptions(request, runtime);
}

model WriteIntentionCommunicationLogRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
  reject?: boolean(name='Reject'),
}

model WriteIntentionCommunicationLogResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model WriteIntentionCommunicationLogResponse = {
  headers: map[string]string(name='headers'),
  body: WriteIntentionCommunicationLogResponseBody(name='body'),
}

async function writeIntentionCommunicationLogWithOptions(request: WriteIntentionCommunicationLogRequest, runtime: Util.RuntimeOptions): WriteIntentionCommunicationLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('WriteIntentionCommunicationLog', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function writeIntentionCommunicationLog(request: WriteIntentionCommunicationLogRequest): WriteIntentionCommunicationLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return writeIntentionCommunicationLogWithOptions(request, runtime);
}

model SaveTaskForOfficialFileCustomRequest {
  endAcceptTime?: long(name='EndAcceptTime'),
  startAcceptTime?: long(name='StartAcceptTime'),
}

model SaveTaskForOfficialFileCustomResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
}

model SaveTaskForOfficialFileCustomResponse = {
  headers: map[string]string(name='headers'),
  body: SaveTaskForOfficialFileCustomResponseBody(name='body'),
}

async function saveTaskForOfficialFileCustomWithOptions(request: SaveTaskForOfficialFileCustomRequest, runtime: Util.RuntimeOptions): SaveTaskForOfficialFileCustomResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveTaskForOfficialFileCustom', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveTaskForOfficialFileCustom(request: SaveTaskForOfficialFileCustomRequest): SaveTaskForOfficialFileCustomResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskForOfficialFileCustomWithOptions(request, runtime);
}

model DescirbeCombineTrademarkRequest {
  registrationNumber?: string(name='RegistrationNumber'),
  name?: string(name='Name'),
  ownerName?: string(name='OwnerName'),
  products?: string(name='Products'),
  accurateMatch?: boolean(name='AccurateMatch'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  classification?: string(name='Classification'),
  similarGroups?: string(name='SimilarGroups'),
}

model DescirbeCombineTrademarkResponseBody = {
  nextPage?: boolean(name='NextPage'),
  requestId?: string(name='RequestId'),
  totalPageNumber?: int32(name='TotalPageNumber'),
  prePage?: boolean(name='PrePage'),
  currentPageNumber?: int32(name='CurrentPageNumber'),
  totalItemNumber?: int32(name='TotalItemNumber'),
  pageSize?: int32(name='PageSize'),
  data?: [ 
    {
      status?: string(name='Status'),
      ownerAddress?: string(name='OwnerAddress'),
      preAnnDate?: string(name='PreAnnDate'),
      preAnnNumber?: string(name='PreAnnNumber'),
      intlRegDate?: string(name='IntlRegDate'),
      share?: string(name='Share'),
      ownerEnName?: string(name='OwnerEnName'),
      subsequentDesignationDate?: string(name='SubsequentDesignationDate'),
      indexId?: string(name='IndexId'),
      regAnnNumber?: string(name='RegAnnNumber'),
      registrationNumber?: string(name='RegistrationNumber'),
      secondAnnoType?: string(name='SecondAnnoType'),
      agency?: string(name='Agency'),
      ownerEnAddress?: string(name='OwnerEnAddress'),
      classification?: string(name='Classification'),
      name?: string(name='Name'),
      applyDate?: string(name='ApplyDate'),
      priorityDate?: string(name='PriorityDate'),
      productDescription?: string(name='ProductDescription'),
      image?: string(name='Image'),
      secondAnnoNumber?: string(name='SecondAnnoNumber'),
      registrationType?: string(name='RegistrationType'),
      firstAnnoNumber?: string(name='FirstAnnoNumber'),
      ownerName?: string(name='OwnerName'),
      regAnnDate?: string(name='RegAnnDate'),
      similarGroup?: string(name='SimilarGroup'),
      onSale?: int32(name='OnSale'),
      exclusiveDateLimit?: string(name='ExclusiveDateLimit'),
      firstAnnoType?: string(name='FirstAnnoType'),
      lastProcedureStatus?: string(name='LastProcedureStatus'),
      lawFinalStatus?: string(name='LawFinalStatus'),
      announcementList?: [ 
        {
          imageUrl?: string(name='ImageUrl'),
          annDate?: string(name='AnnDate'),
          originalImageUrl?: string(name='OriginalImageUrl'),
          annTypeName?: string(name='AnnTypeName'),
          annNumber?: string(name='AnnNumber'),
          annTypeCode?: string(name='AnnTypeCode'),
        }
      ](name='AnnouncementList'),
      procedures?: [ 
        {
          procedureStep?: string(name='ProcedureStep'),
          procedureResult?: string(name='ProcedureResult'),
          procedureCode?: string(name='ProcedureCode'),
          procedureDate?: string(name='ProcedureDate'),
          procedureName?: string(name='ProcedureName'),
        }
      ](name='Procedures'),
    }
  ](name='Data'),
}

model DescirbeCombineTrademarkResponse = {
  headers: map[string]string(name='headers'),
  body: DescirbeCombineTrademarkResponseBody(name='body'),
}

async function descirbeCombineTrademarkWithOptions(request: DescirbeCombineTrademarkRequest, runtime: Util.RuntimeOptions): DescirbeCombineTrademarkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescirbeCombineTrademark', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function descirbeCombineTrademark(request: DescirbeCombineTrademarkRequest): DescirbeCombineTrademarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return descirbeCombineTrademarkWithOptions(request, runtime);
}

model GetNotaryOrderRequest {
  notaryOrderId?: long(name='NotaryOrderId'),
}

model GetNotaryOrderResponseBody = {
  type?: string(name='Type'),
  orderPrice?: float(name='OrderPrice'),
  legalPersonIdCard?: string(name='LegalPersonIdCard'),
  businessLicenseId?: string(name='BusinessLicenseId'),
  notaryPostReceipt?: string(name='NotaryPostReceipt'),
  companyContactName?: string(name='CompanyContactName'),
  notaryStatus?: int32(name='NotaryStatus'),
  sellerBackOfIdCard?: string(name='SellerBackOfIdCard'),
  tmRegisterChangeCertificate?: string(name='TmRegisterChangeCertificate'),
  requestId?: string(name='RequestId'),
  legalPersonName?: string(name='LegalPersonName'),
  tmImage?: string(name='TmImage'),
  notaryAcceptDate?: long(name='NotaryAcceptDate'),
  errorCode?: string(name='ErrorCode'),
  aliyunOrderId?: string(name='AliyunOrderId'),
  notarySucceedDate?: long(name='NotarySucceedDate'),
  applyPostStatus?: int32(name='ApplyPostStatus'),
  errorMsg?: string(name='ErrorMsg'),
  name?: string(name='Name'),
  businessLicense?: string(name='BusinessLicense'),
  receiverName?: string(name='ReceiverName'),
  orderDate?: long(name='OrderDate'),
  companyContactPhone?: string(name='CompanyContactPhone'),
  notaryType?: int32(name='NotaryType'),
  notaryFailedDate?: long(name='NotaryFailedDate'),
  tmClassification?: string(name='TmClassification'),
  success?: boolean(name='Success'),
  bizId?: string(name='BizId'),
  notaryOrderId?: long(name='NotaryOrderId'),
  phone?: string(name='Phone'),
  receiverPhone?: string(name='ReceiverPhone'),
  tmRegisterCertificate?: string(name='TmRegisterCertificate'),
  tmName?: string(name='TmName'),
  tmRegisterNo?: string(name='TmRegisterNo'),
  sellerCompanyName?: string(name='SellerCompanyName'),
  tmAcceptCertificate?: string(name='TmAcceptCertificate'),
  receiverPostalCode?: string(name='ReceiverPostalCode'),
  notaryCertificate?: string(name='NotaryCertificate'),
  legalPersonPhone?: string(name='LegalPersonPhone'),
  notaryFailedReason?: string(name='NotaryFailedReason'),
  sellerFrontOfIdCard?: string(name='SellerFrontOfIdCard'),
  receiverAddress?: string(name='ReceiverAddress'),
  notaryPlatformName?: string(name='NotaryPlatformName'),
}

model GetNotaryOrderResponse = {
  headers: map[string]string(name='headers'),
  body: GetNotaryOrderResponseBody(name='body'),
}

async function getNotaryOrderWithOptions(request: GetNotaryOrderRequest, runtime: Util.RuntimeOptions): GetNotaryOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetNotaryOrder', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getNotaryOrder(request: GetNotaryOrderRequest): GetNotaryOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNotaryOrderWithOptions(request, runtime);
}

model ConfirmAdditionalMaterialRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
}

model ConfirmAdditionalMaterialResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model ConfirmAdditionalMaterialResponse = {
  headers: map[string]string(name='headers'),
  body: ConfirmAdditionalMaterialResponseBody(name='body'),
}

async function confirmAdditionalMaterialWithOptions(request: ConfirmAdditionalMaterialRequest, runtime: Util.RuntimeOptions): ConfirmAdditionalMaterialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConfirmAdditionalMaterial', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function confirmAdditionalMaterial(request: ConfirmAdditionalMaterialRequest): ConfirmAdditionalMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmAdditionalMaterialWithOptions(request, runtime);
}

model InsertRenewInfoRequest {
  name?: string(name='Name'),
  engName?: string(name='EngName'),
  address?: string(name='Address'),
  engAddress?: string(name='EngAddress'),
  registerTime?: long(name='RegisterTime'),
}

model InsertRenewInfoResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  id?: long(name='Id'),
}

model InsertRenewInfoResponse = {
  headers: map[string]string(name='headers'),
  body: InsertRenewInfoResponseBody(name='body'),
}

async function insertRenewInfoWithOptions(request: InsertRenewInfoRequest, runtime: Util.RuntimeOptions): InsertRenewInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('InsertRenewInfo', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function insertRenewInfo(request: InsertRenewInfoRequest): InsertRenewInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertRenewInfoWithOptions(request, runtime);
}

model QueryCredentialsInfoRequest {
  ossKey?: string(name='OssKey'),
  materialType?: string(name='MaterialType'),
  companyName?: string(name='CompanyName'),
}

model QueryCredentialsInfoResponseBody = {
  requestId?: string(name='RequestId'),
  credentialsInfo?: {
    cardNumber?: string(name='CardNumber'),
    address?: string(name='Address'),
    personName?: string(name='PersonName'),
    province?: string(name='Province'),
    companyName?: string(name='CompanyName'),
  }(name='CredentialsInfo'),
}

model QueryCredentialsInfoResponse = {
  headers: map[string]string(name='headers'),
  body: QueryCredentialsInfoResponseBody(name='body'),
}

async function queryCredentialsInfoWithOptions(request: QueryCredentialsInfoRequest, runtime: Util.RuntimeOptions): QueryCredentialsInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryCredentialsInfo', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryCredentialsInfo(request: QueryCredentialsInfoRequest): QueryCredentialsInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCredentialsInfoWithOptions(request, runtime);
}

model SearchTmOnsalesRequest {
  keyword?: string(name='Keyword'),
  classification?: string(name='Classification'),
  productCode?: string(name='ProductCode'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  registerNumber?: string(name='RegisterNumber'),
  tmName?: string(name='TmName'),
  topSearch?: string(name='TopSearch'),
  tag?: string(name='Tag'),
  orderPriceLeft?: long(name='OrderPriceLeft'),
  orderPriceRight?: long(name='OrderPriceRight'),
  regLeft?: int32(name='RegLeft'),
  regRight?: int32(name='RegRight'),
  sortName?: string(name='SortName'),
  sortOrder?: string(name='SortOrder'),
  queryAll?: boolean(name='QueryAll'),
}

model SearchTmOnsalesResponseBody = {
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  totalPageNumber?: int32(name='TotalPageNumber'),
  totalCount?: int32(name='TotalCount'),
  trademarks?: [ 
    {
      trademarkName?: string(name='TrademarkName'),
      status?: long(name='Status'),
      productDesc?: string(name='ProductDesc'),
      registrationNumber?: string(name='RegistrationNumber'),
      icon?: string(name='Icon'),
      partnerCode?: string(name='PartnerCode'),
      classification?: string(name='Classification'),
      uid?: string(name='Uid'),
      productCode?: string(name='ProductCode'),
      orderPrice?: string(name='OrderPrice'),
    }
  ](name='Trademarks'),
}

model SearchTmOnsalesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchTmOnsalesResponseBody(name='body'),
}

async function searchTmOnsalesWithOptions(request: SearchTmOnsalesRequest, runtime: Util.RuntimeOptions): SearchTmOnsalesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchTmOnsales', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchTmOnsales(request: SearchTmOnsalesRequest): SearchTmOnsalesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTmOnsalesWithOptions(request, runtime);
}

model GenerateUploadFilePolicyRequest {
  fileType?: string(name='FileType'),
  bizId?: string(name='BizId'),
}

model GenerateUploadFilePolicyResponseBody = {
  signature?: string(name='Signature'),
  host?: string(name='Host'),
  requestId?: string(name='RequestId'),
  expireTime?: long(name='ExpireTime'),
  encodedPolicy?: string(name='EncodedPolicy'),
  fileDir?: string(name='FileDir'),
  accessId?: string(name='AccessId'),
}

model GenerateUploadFilePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateUploadFilePolicyResponseBody(name='body'),
}

async function generateUploadFilePolicyWithOptions(request: GenerateUploadFilePolicyRequest, runtime: Util.RuntimeOptions): GenerateUploadFilePolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GenerateUploadFilePolicy', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function generateUploadFilePolicy(request: GenerateUploadFilePolicyRequest): GenerateUploadFilePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateUploadFilePolicyWithOptions(request, runtime);
}

model DeleteMaterialRequest {
  id?: long(name='Id'),
}

model DeleteMaterialResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model DeleteMaterialResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMaterialResponseBody(name='body'),
}

async function deleteMaterialWithOptions(request: DeleteMaterialRequest, runtime: Util.RuntimeOptions): DeleteMaterialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMaterial', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMaterial(request: DeleteMaterialRequest): DeleteMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMaterialWithOptions(request, runtime);
}

model WriteCommunicationLogRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
  targetId?: string(name='TargetId'),
}

model WriteCommunicationLogResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model WriteCommunicationLogResponse = {
  headers: map[string]string(name='headers'),
  body: WriteCommunicationLogResponseBody(name='body'),
}

async function writeCommunicationLogWithOptions(request: WriteCommunicationLogRequest, runtime: Util.RuntimeOptions): WriteCommunicationLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('WriteCommunicationLog', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function writeCommunicationLog(request: WriteCommunicationLogRequest): WriteCommunicationLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return writeCommunicationLogWithOptions(request, runtime);
}

model InsertTradeIntentionUserRequest {
  registerNumber?: string(name='RegisterNumber'),
  classification?: string(name='Classification'),
  type?: int32(name='Type'),
  mobile?: string(name='Mobile'),
  vcode?: string(name='Vcode'),
  partnerCode?: string(name='PartnerCode'),
  userName?: string(name='UserName'),
  description?: string(name='Description'),
  channel?: string(name='Channel'),
  token?: string(name='Token'),
  ua?: string(name='Ua'),
}

model InsertTradeIntentionUserResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InsertTradeIntentionUserResponse = {
  headers: map[string]string(name='headers'),
  body: InsertTradeIntentionUserResponseBody(name='body'),
}

async function insertTradeIntentionUserWithOptions(request: InsertTradeIntentionUserRequest, runtime: Util.RuntimeOptions): InsertTradeIntentionUserResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('InsertTradeIntentionUser', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function insertTradeIntentionUser(request: InsertTradeIntentionUserRequest): InsertTradeIntentionUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertTradeIntentionUserWithOptions(request, runtime);
}

model QueryExtensionAttributeRequest {
  bizId?: string(name='BizId'),
  attributeKey?: string(name='AttributeKey'),
}

model QueryExtensionAttributeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  attributeValue?: string(name='AttributeValue'),
}

model QueryExtensionAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: QueryExtensionAttributeResponseBody(name='body'),
}

async function queryExtensionAttributeWithOptions(request: QueryExtensionAttributeRequest, runtime: Util.RuntimeOptions): QueryExtensionAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryExtensionAttribute', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryExtensionAttribute(request: QueryExtensionAttributeRequest): QueryExtensionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryExtensionAttributeWithOptions(request, runtime);
}

model UpdateTrademarkOnsaleRequest {
  classificationCode?: string(name='ClassificationCode'),
  tmName?: string(name='TmName'),
  tmIcon?: string(name='TmIcon'),
  originalPrice?: float(name='OriginalPrice'),
  tmNumber?: string(name='TmNumber'),
  endTime?: long(name='EndTime'),
  beginTime?: long(name='BeginTime'),
  description?: string(name='Description'),
  label?: string(name='Label'),
  regAnnDate?: long(name='RegAnnDate'),
  ownerName?: string(name='OwnerName'),
  ownerEnName?: string(name='OwnerEnName'),
  secondaryClassification?: string(name='SecondaryClassification'),
  thirdClassification?: string(name='ThirdClassification'),
  type?: string(name='Type'),
  reason?: string(name='Reason'),
}

model UpdateTrademarkOnsaleResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTrademarkOnsaleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTrademarkOnsaleResponseBody(name='body'),
}

async function updateTrademarkOnsaleWithOptions(request: UpdateTrademarkOnsaleRequest, runtime: Util.RuntimeOptions): UpdateTrademarkOnsaleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateTrademarkOnsale', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateTrademarkOnsale(request: UpdateTrademarkOnsaleRequest): UpdateTrademarkOnsaleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTrademarkOnsaleWithOptions(request, runtime);
}

model QueryTradeProduceDetailRequest {
  bizId?: string(name='BizId'),
}

model QueryTradeProduceDetailResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    updateTime?: long(name='UpdateTime'),
    thirdCode?: string(name='ThirdCode'),
    share?: string(name='Share'),
    preAmount?: float(name='PreAmount'),
    createTime?: long(name='CreateTime'),
    userId?: string(name='UserId'),
    refundAmount?: float(name='RefundAmount'),
    icon?: string(name='Icon'),
    bizId?: string(name='BizId'),
    buyerStatus?: int32(name='BuyerStatus'),
    source?: int32(name='Source'),
    confiscateAmount?: float(name='ConfiscateAmount'),
    operateNote?: string(name='OperateNote'),
    preOrderId?: string(name='PreOrderId'),
    extend?: map[string]any(name='Extend'),
    tmName?: string(name='TmName'),
    exclusiveDateLimit?: string(name='ExclusiveDateLimit'),
    allowCancel?: boolean(name='AllowCancel'),
    registerNumber?: string(name='RegisterNumber'),
    finalAmount?: float(name='FinalAmount'),
    classification?: string(name='Classification'),
    paidAmount?: float(name='PaidAmount'),
  }(name='Data'),
}

model QueryTradeProduceDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTradeProduceDetailResponseBody(name='body'),
}

async function queryTradeProduceDetailWithOptions(request: QueryTradeProduceDetailRequest, runtime: Util.RuntimeOptions): QueryTradeProduceDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTradeProduceDetail', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTradeProduceDetail(request: QueryTradeProduceDetailRequest): QueryTradeProduceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeProduceDetailWithOptions(request, runtime);
}

model QueryQrCodeUploadStatusRequest {
  ossKey?: string(name='OssKey'),
  fieldKey?: string(name='FieldKey'),
  uuid?: string(name='Uuid'),
}

model QueryQrCodeUploadStatusResponseBody = {
  status?: int32(name='Status'),
  requestId?: string(name='RequestId'),
  ossUrl?: string(name='OssUrl'),
  ossKey?: string(name='OssKey'),
  success?: boolean(name='Success'),
}

model QueryQrCodeUploadStatusResponse = {
  headers: map[string]string(name='headers'),
  body: QueryQrCodeUploadStatusResponseBody(name='body'),
}

async function queryQrCodeUploadStatusWithOptions(request: QueryQrCodeUploadStatusRequest, runtime: Util.RuntimeOptions): QueryQrCodeUploadStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryQrCodeUploadStatus', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryQrCodeUploadStatus(request: QueryQrCodeUploadStatusRequest): QueryQrCodeUploadStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryQrCodeUploadStatusWithOptions(request, runtime);
}

model RejectApplicantRequest {
  instanceId?: string(name='InstanceId'),
  note?: string(name='Note'),
}

model RejectApplicantResponseBody = {
  requestId?: string(name='RequestId'),
}

model RejectApplicantResponse = {
  headers: map[string]string(name='headers'),
  body: RejectApplicantResponseBody(name='body'),
}

async function rejectApplicantWithOptions(request: RejectApplicantRequest, runtime: Util.RuntimeOptions): RejectApplicantResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RejectApplicant', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function rejectApplicant(request: RejectApplicantRequest): RejectApplicantResponse {
  var runtime = new Util.RuntimeOptions{};
  return rejectApplicantWithOptions(request, runtime);
}

model QueryTradeIntentionUserListRequest {
  begin?: long(name='Begin'),
  end?: long(name='End'),
  pageSize?: int32(name='PageSize'),
  pageNum?: int32(name='PageNum'),
  bizId?: string(name='BizId'),
  status?: int32(name='Status'),
}

model QueryTradeIntentionUserListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  totalPageNum?: int32(name='TotalPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalItemNum?: int32(name='TotalItemNum'),
  data?: {
    trademark?: [ 
    {
      type?: int32(name='Type'),
      status?: int32(name='Status'),
      description?: string(name='Description'),
      mobile?: string(name='Mobile'),
      registerNumber?: string(name='RegisterNumber'),
      bizId?: string(name='BizId'),
      classification?: string(name='Classification'),
      userName?: string(name='UserName'),
    }
  ](name='Trademark')
  }(name='Data'),
}

model QueryTradeIntentionUserListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTradeIntentionUserListResponseBody(name='body'),
}

async function queryTradeIntentionUserListWithOptions(request: QueryTradeIntentionUserListRequest, runtime: Util.RuntimeOptions): QueryTradeIntentionUserListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTradeIntentionUserList', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTradeIntentionUserList(request: QueryTradeIntentionUserListRequest): QueryTradeIntentionUserListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeIntentionUserListWithOptions(request, runtime);
}

model StoreMaterialTemporarilyRequest {
  contactZipcode?: string(name='ContactZipcode'),
  type?: string(name='Type'),
  region?: string(name='Region'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactEmail?: string(name='ContactEmail'),
  contactAddress?: string(name='ContactAddress'),
  loaOssKey?: string(name='LoaOssKey'),
  name?: string(name='Name'),
  cardNumber?: string(name='CardNumber'),
  province?: string(name='Province'),
  city?: string(name='City'),
  town?: string(name='Town'),
  address?: string(name='Address'),
  EName?: string(name='EName'),
  EAddress?: string(name='EAddress'),
  country?: string(name='Country'),
  idCardOssKey?: string(name='IdCardOssKey'),
  businessLicenceOssKey?: string(name='BusinessLicenceOssKey'),
  passportOssKey?: string(name='PassportOssKey'),
  legalNoticeOssKey?: string(name='LegalNoticeOssKey'),
  principalName?: int32(name='PrincipalName'),
  contactProvince?: string(name='ContactProvince'),
  contactCity?: string(name='ContactCity'),
  contactDistrict?: string(name='ContactDistrict'),
  contactCounty?: string(name='ContactCounty'),
}

model StoreMaterialTemporarilyResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
}

model StoreMaterialTemporarilyResponse = {
  headers: map[string]string(name='headers'),
  body: StoreMaterialTemporarilyResponseBody(name='body'),
}

async function storeMaterialTemporarilyWithOptions(request: StoreMaterialTemporarilyRequest, runtime: Util.RuntimeOptions): StoreMaterialTemporarilyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StoreMaterialTemporarily', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function storeMaterialTemporarily(request: StoreMaterialTemporarilyRequest): StoreMaterialTemporarilyResponse {
  var runtime = new Util.RuntimeOptions{};
  return storeMaterialTemporarilyWithOptions(request, runtime);
}

model RefuseAdditionalMaterialRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
}

model RefuseAdditionalMaterialResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model RefuseAdditionalMaterialResponse = {
  headers: map[string]string(name='headers'),
  body: RefuseAdditionalMaterialResponseBody(name='body'),
}

async function refuseAdditionalMaterialWithOptions(request: RefuseAdditionalMaterialRequest, runtime: Util.RuntimeOptions): RefuseAdditionalMaterialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RefuseAdditionalMaterial', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function refuseAdditionalMaterial(request: RefuseAdditionalMaterialRequest): RefuseAdditionalMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return refuseAdditionalMaterialWithOptions(request, runtime);
}

model ListNotaryInfosRequest {
  notaryType?: int32(name='NotaryType'),
  bizOrderNo?: string(name='BizOrderNo'),
  token?: string(name='Token'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model ListNotaryInfosResponseBody = {
  nextPage?: boolean(name='NextPage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  totalItemNum?: int32(name='TotalItemNum'),
  prePage?: boolean(name='PrePage'),
  currentPageNum?: int32(name='CurrentPageNum'),
  errorMsg?: string(name='ErrorMsg'),
  totalPageNum?: int32(name='TotalPageNum'),
  pageSize?: int32(name='PageSize'),
  data?: {
    notaryInfo?: [ 
    {
      token?: string(name='Token'),
      tmRegisterNo?: string(name='TmRegisterNo'),
      tmClassification?: string(name='TmClassification'),
      notaryFailedReason?: string(name='NotaryFailedReason'),
      gmtModified?: long(name='GmtModified'),
      notaryStatus?: int32(name='NotaryStatus'),
      bizOrderNo?: string(name='BizOrderNo'),
    }
  ](name='NotaryInfo')
  }(name='Data'),
}

model ListNotaryInfosResponse = {
  headers: map[string]string(name='headers'),
  body: ListNotaryInfosResponseBody(name='body'),
}

async function listNotaryInfosWithOptions(request: ListNotaryInfosRequest, runtime: Util.RuntimeOptions): ListNotaryInfosResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListNotaryInfos', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listNotaryInfos(request: ListNotaryInfosRequest): ListNotaryInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNotaryInfosWithOptions(request, runtime);
}

model GetDefaultPrincipalNameRequest {
  bizType?: string(name='BizType'),
}

model GetDefaultPrincipalNameResponseBody = {
  principalName?: int32(name='PrincipalName'),
  requestId?: string(name='RequestId'),
}

model GetDefaultPrincipalNameResponse = {
  headers: map[string]string(name='headers'),
  body: GetDefaultPrincipalNameResponseBody(name='body'),
}

async function getDefaultPrincipalNameWithOptions(request: GetDefaultPrincipalNameRequest, runtime: Util.RuntimeOptions): GetDefaultPrincipalNameResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetDefaultPrincipalName', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getDefaultPrincipalName(request: GetDefaultPrincipalNameRequest): GetDefaultPrincipalNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefaultPrincipalNameWithOptions(request, runtime);
}

model QueryTradeMarkApplicationDetailRequest {
  bizId?: string(name='BizId'),
}

model QueryTradeMarkApplicationDetailResponseBody = {
  type?: int32(name='Type'),
  status?: int32(name='Status'),
  acceptUrl?: string(name='AcceptUrl'),
  orderPrice?: float(name='OrderPrice'),
  submitAuditTime?: long(name='SubmitAuditTime'),
  updateTime?: long(name='UpdateTime'),
  createTime?: long(name='CreateTime'),
  notAcceptUrl?: string(name='NotAcceptUrl'),
  sendTime?: string(name='SendTime'),
  servicePrice?: float(name='ServicePrice'),
  partnerMobile?: string(name='PartnerMobile'),
  recvUserLogistics?: string(name='RecvUserLogistics'),
  requestId?: string(name='RequestId'),
  grayIconUrl?: string(name='GrayIconUrl'),
  materialId?: long(name='MaterialId'),
  sendSbjLogistics?: string(name='SendSbjLogistics'),
  sendUserLogistics?: string(name='SendUserLogistics'),
  loaUrl?: string(name='LoaUrl'),
  tmNumber?: string(name='TmNumber'),
  note?: string(name='Note'),
  principalName?: int32(name='PrincipalName'),
  partnerName?: string(name='PartnerName'),
  logisticsCertificateUrl?: string(name='LogisticsCertificateUrl'),
  bizId?: string(name='BizId'),
  partnerCode?: string(name='PartnerCode'),
  tmNameType?: int32(name='TmNameType'),
  extendInfo?: map[string]any(name='ExtendInfo'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  logisticsNo?: string(name='LogisticsNo'),
  totalPrice?: float(name='TotalPrice'),
  submitTime?: long(name='SubmitTime'),
  orderId?: string(name='OrderId'),
  receiptUrl?: {
    receiptUrl?: [ string ](name='ReceiptUrl')
  }(name='ReceiptUrl'),
  judgeResultUrl?: {
    judgeResultUrl?: [ string ](name='JudgeResultUrl')
  }(name='JudgeResultUrl'),
  flags?: {
    flag?: [ int32 ](name='Flag')
  }(name='Flags'),
  adminUploads?: {
    loaPicUrl?: string(name='LoaPicUrl'),
    licensePicUrl?: string(name='LicensePicUrl'),
  }(name='AdminUploads'),
  firstClassification?: {
    name?: string(name='Name'),
    code?: string(name='Code'),
  }(name='FirstClassification'),
  materialDetail?: {
    type?: int32(name='Type'),
    reviewApplicationFile?: string(name='ReviewApplicationFile'),
    status?: int32(name='Status'),
    businessLicenceUrl?: string(name='BusinessLicenceUrl'),
    passportUrl?: string(name='PassportUrl'),
    city?: string(name='City'),
    legalNoticeUrl?: string(name='LegalNoticeUrl'),
    EAddress?: string(name='EAddress'),
    contactEmail?: string(name='ContactEmail'),
    region?: int32(name='Region'),
    loaUrl?: string(name='LoaUrl'),
    address?: string(name='Address'),
    principalName?: int32(name='PrincipalName'),
    name?: string(name='Name'),
    contactNumber?: string(name='ContactNumber'),
    contactAddress?: string(name='ContactAddress'),
    contactZipcode?: string(name='ContactZipcode'),
    contactName?: string(name='ContactName'),
    EName?: string(name='EName'),
    cardNumber?: string(name='CardNumber'),
    expirationDate?: string(name='ExpirationDate'),
    idCardUrl?: string(name='IdCardUrl'),
    country?: string(name='Country'),
    town?: string(name='Town'),
    province?: string(name='Province'),
    detailedContactAddress?: string(name='DetailedContactAddress', description='详细收件地址'),
    reviewAdditionalFiles?: {
      reviewAdditionalFile?: [ string ](name='ReviewAdditionalFile')
    }(name='ReviewAdditionalFiles'),
  }(name='MaterialDetail'),
  renewResponse?: {
    engName?: string(name='EngName'),
    registerTime?: long(name='RegisterTime'),
    engAddress?: string(name='EngAddress'),
    address?: string(name='Address'),
    name?: string(name='Name'),
    submitSbjtime?: long(name='SubmitSbjtime'),
  }(name='RenewResponse'),
  reviewOfficialFiles?: {
    reviewKeep?: string(name='ReviewKeep'),
    reviewAudit?: string(name='ReviewAudit'),
    reviewPart?: string(name='ReviewPart'),
    reviewPass?: string(name='ReviewPass'),
    reviewSupplements?: {
      reviewSupplement?: [ string ](name='ReviewSupplement')
    }(name='ReviewSupplements'),
  }(name='ReviewOfficialFiles'),
  supplements?: {
    supplements?: [ 
    {
      type?: int32(name='Type'),
      operateTime?: long(name='OperateTime'),
      serialNumber?: string(name='SerialNumber'),
      status?: int32(name='Status'),
      sbjDeadTime?: long(name='SbjDeadTime'),
      acceptDeadTime?: long(name='AcceptDeadTime'),
      sendTime?: long(name='SendTime'),
      batchNum?: string(name='BatchNum'),
      acceptTime?: long(name='AcceptTime'),
      tmNumber?: string(name='TmNumber'),
      uploadFileTemplateUrl?: string(name='UploadFileTemplateUrl'),
      content?: string(name='Content'),
      id?: long(name='Id'),
      orderId?: string(name='OrderId'),
      fileTemplateUrls?: {
        fileTemplateUrls?: [ string ](name='FileTemplateUrls')
      }(name='FileTemplateUrls'),
    }
  ](name='Supplements')
  }(name='Supplements'),
  thirdClassification?: {
    thirdClassifications?: [ 
    {
      name?: string(name='Name'),
      code?: string(name='Code'),
    }
  ](name='ThirdClassifications')
  }(name='ThirdClassification'),
}

model QueryTradeMarkApplicationDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTradeMarkApplicationDetailResponseBody(name='body'),
}

async function queryTradeMarkApplicationDetailWithOptions(request: QueryTradeMarkApplicationDetailRequest, runtime: Util.RuntimeOptions): QueryTradeMarkApplicationDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTradeMarkApplicationDetail', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTradeMarkApplicationDetail(request: QueryTradeMarkApplicationDetailRequest): QueryTradeMarkApplicationDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeMarkApplicationDetailWithOptions(request, runtime);
}

model SaveClassificationConditionsRequest {
  type?: int32(name='Type'),
  bizId?: string(name='BizId'),
  condition?: string(name='Condition'),
}

model SaveClassificationConditionsResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  tagName?: string(name='TagName'),
  success?: boolean(name='Success'),
  invalidList?: [ 
    {
      parentCode?: string(name='ParentCode'),
      officialCode?: string(name='OfficialCode'),
      classificationName?: string(name='ClassificationName'),
      classificationCode?: string(name='ClassificationCode'),
    }
  ](name='InvalidList'),
}

model SaveClassificationConditionsResponse = {
  headers: map[string]string(name='headers'),
  body: SaveClassificationConditionsResponseBody(name='body'),
}

async function saveClassificationConditionsWithOptions(request: SaveClassificationConditionsRequest, runtime: Util.RuntimeOptions): SaveClassificationConditionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveClassificationConditions', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveClassificationConditions(request: SaveClassificationConditionsRequest): SaveClassificationConditionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveClassificationConditionsWithOptions(request, runtime);
}

model FillLogisticsRequest {
  bizId?: string(name='BizId'),
  logistics?: string(name='Logistics'),
}

model FillLogisticsResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model FillLogisticsResponse = {
  headers: map[string]string(name='headers'),
  body: FillLogisticsResponseBody(name='body'),
}

async function fillLogisticsWithOptions(request: FillLogisticsRequest, runtime: Util.RuntimeOptions): FillLogisticsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('FillLogistics', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function fillLogistics(request: FillLogisticsRequest): FillLogisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return fillLogisticsWithOptions(request, runtime);
}

model UpdateMaterialRequest {
  loaId?: long(name='LoaId'),
  contactAddress?: string(name='ContactAddress'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactEmail?: string(name='ContactEmail'),
  id?: long(name='Id'),
  contactZipcode?: string(name='ContactZipcode'),
  name?: string(name='Name'),
  cardNumber?: string(name='CardNumber'),
  province?: string(name='Province'),
  city?: string(name='City'),
  town?: string(name='Town'),
  address?: string(name='Address'),
  EName?: string(name='EName'),
  EAddress?: string(name='EAddress'),
  idCardOssKey?: string(name='IdCardOssKey'),
  businessLicenceOssKey?: string(name='BusinessLicenceOssKey'),
  passportOssKey?: string(name='PassportOssKey'),
  loaOssKey?: string(name='LoaOssKey'),
  legalNoticeOssKey?: string(name='LegalNoticeOssKey'),
  contactProvince?: string(name='ContactProvince'),
  contactCity?: string(name='ContactCity'),
  contactDistrict?: string(name='ContactDistrict'),
  contactCounty?: string(name='ContactCounty'),
}

model UpdateMaterialResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
}

model UpdateMaterialResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMaterialResponseBody(name='body'),
}

async function updateMaterialWithOptions(request: UpdateMaterialRequest, runtime: Util.RuntimeOptions): UpdateMaterialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateMaterial', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateMaterial(request: UpdateMaterialRequest): UpdateMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMaterialWithOptions(request, runtime);
}

model QueryTradeMarkApplicationLogsRequest {
  bizId?: string(name='BizId'),
}

model QueryTradeMarkApplicationLogsResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    data?: [ 
    {
      operateTime?: long(name='OperateTime'),
      operateType?: int32(name='OperateType'),
      extendContent?: string(name='ExtendContent'),
      bizId?: string(name='BizId'),
      note?: string(name='Note'),
      bizStatus?: int32(name='BizStatus'),
    }
  ](name='Data')
  }(name='Data'),
}

model QueryTradeMarkApplicationLogsResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTradeMarkApplicationLogsResponseBody(name='body'),
}

async function queryTradeMarkApplicationLogsWithOptions(request: QueryTradeMarkApplicationLogsRequest, runtime: Util.RuntimeOptions): QueryTradeMarkApplicationLogsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTradeMarkApplicationLogs', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTradeMarkApplicationLogs(request: QueryTradeMarkApplicationLogsRequest): QueryTradeMarkApplicationLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeMarkApplicationLogsWithOptions(request, runtime);
}

model RefundProduceRequest {
  bizId?: string(name='BizId'),
}

model RefundProduceResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model RefundProduceResponse = {
  headers: map[string]string(name='headers'),
  body: RefundProduceResponseBody(name='body'),
}

async function refundProduceWithOptions(request: RefundProduceRequest, runtime: Util.RuntimeOptions): RefundProduceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RefundProduce', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function refundProduce(request: RefundProduceRequest): RefundProduceResponse {
  var runtime = new Util.RuntimeOptions{};
  return refundProduceWithOptions(request, runtime);
}

model SyncTrademarkRequest {
  classificationCode?: string(name='ClassificationCode'),
  tmName?: string(name='TmName'),
  tmIcon?: string(name='TmIcon'),
  originalPrice?: float(name='OriginalPrice'),
  tmNumber?: string(name='TmNumber'),
  status?: string(name='Status'),
  endTime?: long(name='EndTime'),
  beginTime?: long(name='BeginTime'),
  description?: string(name='Description'),
  label?: string(name='Label'),
  regAnnDate?: long(name='RegAnnDate'),
  ownerName?: string(name='OwnerName'),
  ownerEnName?: string(name='OwnerEnName'),
  secondaryClassification?: string(name='SecondaryClassification'),
  thirdClassification?: string(name='ThirdClassification'),
  type?: string(name='Type'),
  reason?: string(name='Reason'),
}

model SyncTrademarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model SyncTrademarkResponse = {
  headers: map[string]string(name='headers'),
  body: SyncTrademarkResponseBody(name='body'),
}

async function syncTrademarkWithOptions(request: SyncTrademarkRequest, runtime: Util.RuntimeOptions): SyncTrademarkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SyncTrademark', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function syncTrademark(request: SyncTrademarkRequest): SyncTrademarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncTrademarkWithOptions(request, runtime);
}

model CombineLoaRequest {
  materialId?: string(name='MaterialId'),
  trademarkName?: string(name='TrademarkName'),
  materialName?: string(name='MaterialName'),
  nationality?: string(name='Nationality'),
  address?: string(name='Address'),
  tmProduceType?: string(name='TmProduceType'),
  principalName?: int32(name='PrincipalName'),
}

model CombineLoaResponseBody = {
  templateCombineUrl?: string(name='TemplateCombineUrl'),
  requestId?: string(name='RequestId'),
}

model CombineLoaResponse = {
  headers: map[string]string(name='headers'),
  body: CombineLoaResponseBody(name='body'),
}

async function combineLoaWithOptions(request: CombineLoaRequest, runtime: Util.RuntimeOptions): CombineLoaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CombineLoa', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function combineLoa(request: CombineLoaRequest): CombineLoaResponse {
  var runtime = new Util.RuntimeOptions{};
  return combineLoaWithOptions(request, runtime);
}

model FilterUnavailableCodesRequest {
  codes?: map[string]any(name='Codes'),
}

model FilterUnavailableCodesShrinkRequest {
  codesShrink?: string(name='Codes'),
}

model FilterUnavailableCodesResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    codes?: [ string ](name='Codes')
  }(name='Data'),
}

model FilterUnavailableCodesResponse = {
  headers: map[string]string(name='headers'),
  body: FilterUnavailableCodesResponseBody(name='body'),
}

async function filterUnavailableCodesWithOptions(tmpReq: FilterUnavailableCodesRequest, runtime: Util.RuntimeOptions): FilterUnavailableCodesResponse {
  Util.validateModel(tmpReq);
  var request = new FilterUnavailableCodesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.codes)) {
    request.codesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.codes, 'Codes', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('FilterUnavailableCodes', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function filterUnavailableCodes(request: FilterUnavailableCodesRequest): FilterUnavailableCodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return filterUnavailableCodesWithOptions(request, runtime);
}

model InsertMaterialRequest {
  contactZipcode?: string(name='ContactZipcode'),
  type?: int32(name='Type'),
  region?: int32(name='Region'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactEmail?: string(name='ContactEmail'),
  contactAddress?: string(name='ContactAddress'),
  loaOssKey?: string(name='LoaOssKey'),
  name?: string(name='Name'),
  cardNumber?: string(name='CardNumber'),
  province?: string(name='Province'),
  city?: string(name='City'),
  town?: string(name='Town'),
  address?: string(name='Address'),
  EName?: string(name='EName'),
  EAddress?: string(name='EAddress'),
  country?: string(name='Country'),
  idCardOssKey?: string(name='IdCardOssKey'),
  businessLicenceOssKey?: string(name='BusinessLicenceOssKey'),
  passportOssKey?: string(name='PassportOssKey'),
  legalNoticeOssKey?: string(name='LegalNoticeOssKey'),
  principalName?: int32(name='PrincipalName'),
  contactProvince?: string(name='ContactProvince'),
  contactCity?: string(name='ContactCity'),
  contactDistrict?: string(name='ContactDistrict'),
  contactCounty?: string(name='ContactCounty'),
}

model InsertMaterialResponseBody = {
  success?: boolean(name='Success'),
  requestId?: string(name='RequestId'),
}

model InsertMaterialResponse = {
  headers: map[string]string(name='headers'),
  body: InsertMaterialResponseBody(name='body'),
}

async function insertMaterialWithOptions(request: InsertMaterialRequest, runtime: Util.RuntimeOptions): InsertMaterialResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('InsertMaterial', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function insertMaterial(request: InsertMaterialRequest): InsertMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertMaterialWithOptions(request, runtime);
}

model SaveTradeMarkReviewMaterialDetailRequest {
  bizId?: string(name='BizId'),
  type?: int32(name='Type'),
  region?: int32(name='Region'),
  country?: string(name='Country'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactEmail?: string(name='ContactEmail'),
  contactAddress?: string(name='ContactAddress'),
  loaOssKey?: string(name='LoaOssKey'),
  name?: string(name='Name'),
  cardNumber?: string(name='CardNumber'),
  province?: string(name='Province'),
  address?: string(name='Address'),
  engName?: string(name='EngName'),
  engAddress?: string(name='EngAddress'),
  idCardOssKey?: string(name='IdCardOssKey'),
  businessLicenceOssKey?: string(name='BusinessLicenceOssKey'),
  passportOssKey?: string(name='PassportOssKey'),
  legalNoticeOssKey?: string(name='LegalNoticeOssKey'),
  applicationOssKey?: string(name='ApplicationOssKey'),
  additionalOssKeyList?: map[string]any(name='AdditionalOssKeyList'),
  submitType?: int32(name='SubmitType'),
}

model SaveTradeMarkReviewMaterialDetailShrinkRequest {
  bizId?: string(name='BizId'),
  type?: int32(name='Type'),
  region?: int32(name='Region'),
  country?: string(name='Country'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactEmail?: string(name='ContactEmail'),
  contactAddress?: string(name='ContactAddress'),
  loaOssKey?: string(name='LoaOssKey'),
  name?: string(name='Name'),
  cardNumber?: string(name='CardNumber'),
  province?: string(name='Province'),
  address?: string(name='Address'),
  engName?: string(name='EngName'),
  engAddress?: string(name='EngAddress'),
  idCardOssKey?: string(name='IdCardOssKey'),
  businessLicenceOssKey?: string(name='BusinessLicenceOssKey'),
  passportOssKey?: string(name='PassportOssKey'),
  legalNoticeOssKey?: string(name='LegalNoticeOssKey'),
  applicationOssKey?: string(name='ApplicationOssKey'),
  additionalOssKeyListShrink?: string(name='AdditionalOssKeyList'),
  submitType?: int32(name='SubmitType'),
}

model SaveTradeMarkReviewMaterialDetailResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveTradeMarkReviewMaterialDetailResponse = {
  headers: map[string]string(name='headers'),
  body: SaveTradeMarkReviewMaterialDetailResponseBody(name='body'),
}

async function saveTradeMarkReviewMaterialDetailWithOptions(tmpReq: SaveTradeMarkReviewMaterialDetailRequest, runtime: Util.RuntimeOptions): SaveTradeMarkReviewMaterialDetailResponse {
  Util.validateModel(tmpReq);
  var request = new SaveTradeMarkReviewMaterialDetailShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.additionalOssKeyList)) {
    request.additionalOssKeyListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.additionalOssKeyList, 'AdditionalOssKeyList', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveTradeMarkReviewMaterialDetail', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveTradeMarkReviewMaterialDetail(request: SaveTradeMarkReviewMaterialDetailRequest): SaveTradeMarkReviewMaterialDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTradeMarkReviewMaterialDetailWithOptions(request, runtime);
}

model QueryMonitorKeywordsRequest {
  ruleType?: int32(name='RuleType'),
  keywords?: [ string ](name='Keywords'),
}

model QueryMonitorKeywordsResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    keywords?: [ string ](name='Keywords')
  }(name='Data'),
}

model QueryMonitorKeywordsResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMonitorKeywordsResponseBody(name='body'),
}

async function queryMonitorKeywordsWithOptions(request: QueryMonitorKeywordsRequest, runtime: Util.RuntimeOptions): QueryMonitorKeywordsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMonitorKeywords', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMonitorKeywords(request: QueryMonitorKeywordsRequest): QueryMonitorKeywordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMonitorKeywordsWithOptions(request, runtime);
}

model QueryTaskListRequest {
  bizType?: string(name='BizType'),
  pageSize?: int32(name='PageSize'),
  pageNum?: int32(name='PageNum'),
}

model QueryTaskListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  totalPageNum?: int32(name='TotalPageNum'),
  requestId?: string(name='RequestId'),
  pageSize?: int32(name='PageSize'),
  totalItemNum?: int32(name='TotalItemNum'),
  data?: {
    taskList?: [ 
    {
      taskType?: string(name='TaskType'),
      result?: string(name='Result'),
      taskStatus?: string(name='TaskStatus'),
      completeTime?: long(name='CompleteTime'),
      createTime?: long(name='CreateTime'),
      errMsg?: string(name='ErrMsg'),
      fileName?: string(name='FileName'),
    }
  ](name='TaskList')
  }(name='Data'),
}

model QueryTaskListResponse = {
  headers: map[string]string(name='headers'),
  body: QueryTaskListResponseBody(name='body'),
}

async function queryTaskListWithOptions(request: QueryTaskListRequest, runtime: Util.RuntimeOptions): QueryTaskListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryTaskList', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryTaskList(request: QueryTaskListRequest): QueryTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskListWithOptions(request, runtime);
}

model UpdateTrademarkNameRequest {
  clientToken?: string(name='ClientToken', description='幂等参数'),
  bizId?: string(name='BizId', description='业务id'),
  tmName?: string(name='TmName', description='商标名称'),
  tmIcon?: string(name='TmIcon', description='商标图片'),
  tmComment?: string(name='TmComment'),
  type?: long(name='Type', description='商标类型'),
}

model UpdateTrademarkNameResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  success?: boolean(name='Success'),
}

model UpdateTrademarkNameResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTrademarkNameResponseBody(name='body'),
}

async function updateTrademarkNameWithOptions(request: UpdateTrademarkNameRequest, runtime: Util.RuntimeOptions): UpdateTrademarkNameResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateTrademarkName', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateTrademarkName(request: UpdateTrademarkNameRequest): UpdateTrademarkNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTrademarkNameWithOptions(request, runtime);
}

model CheckLoaFillRequest {
  ossKey?: string(name='OssKey'),
  type?: string(name='Type'),
}

model CheckLoaFillResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    addressFill?: boolean(name='AddressFill'),
    templateUrl?: string(name='TemplateUrl'),
    countryFill?: boolean(name='CountryFill'),
    nationalityFill?: boolean(name='NationalityFill'),
    stampFill?: boolean(name='StampFill'),
    tradeMarkNameFill?: boolean(name='TradeMarkNameFill'),
    materialNameFill?: boolean(name='MaterialNameFill'),
    errorMsgs?: {
      errorMsg?: [ string ](name='ErrorMsg')
    }(name='ErrorMsgs'),
  }(name='Data'),
}

model CheckLoaFillResponse = {
  headers: map[string]string(name='headers'),
  body: CheckLoaFillResponseBody(name='body'),
}

async function checkLoaFillWithOptions(request: CheckLoaFillRequest, runtime: Util.RuntimeOptions): CheckLoaFillResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CheckLoaFill', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkLoaFill(request: CheckLoaFillRequest): CheckLoaFillResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkLoaFillWithOptions(request, runtime);
}

model ConfirmApplicantRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
}

model ConfirmApplicantResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model ConfirmApplicantResponse = {
  headers: map[string]string(name='headers'),
  body: ConfirmApplicantResponseBody(name='body'),
}

async function confirmApplicantWithOptions(request: ConfirmApplicantRequest, runtime: Util.RuntimeOptions): ConfirmApplicantResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConfirmApplicant', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function confirmApplicant(request: ConfirmApplicantRequest): ConfirmApplicantResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmApplicantWithOptions(request, runtime);
}

model CreateIntentionOrderRequest {
  intentionBizId?: string(name='IntentionBizId'),
  channel?: string(name='Channel'),
}

model CreateIntentionOrderResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  data?: {
    orderIds?: [ string ](name='OrderIds')
  }(name='Data'),
}

model CreateIntentionOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIntentionOrderResponseBody(name='body'),
}

async function createIntentionOrderWithOptions(request: CreateIntentionOrderRequest, runtime: Util.RuntimeOptions): CreateIntentionOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIntentionOrder', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIntentionOrder(request: CreateIntentionOrderRequest): CreateIntentionOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIntentionOrderWithOptions(request, runtime);
}

model QueryOssResourcesRequest {
  bizId?: string(name='BizId'),
}

model QueryOssResourcesResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    taskList?: [ 
    {
      bizId?: string(name='BizId'),
      updateTime?: long(name='UpdateTime'),
      ossUrl?: string(name='OssUrl'),
      name?: string(name='Name'),
      createTime?: long(name='CreateTime'),
    }
  ](name='TaskList')
  }(name='Data'),
}

model QueryOssResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: QueryOssResourcesResponseBody(name='body'),
}

async function queryOssResourcesWithOptions(request: QueryOssResourcesRequest, runtime: Util.RuntimeOptions): QueryOssResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryOssResources', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryOssResources(request: QueryOssResourcesRequest): QueryOssResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOssResourcesWithOptions(request, runtime);
}

model RefuseApplicantRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
}

model RefuseApplicantResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model RefuseApplicantResponse = {
  headers: map[string]string(name='headers'),
  body: RefuseApplicantResponseBody(name='body'),
}

async function refuseApplicantWithOptions(request: RefuseApplicantRequest, runtime: Util.RuntimeOptions): RefuseApplicantResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RefuseApplicant', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function refuseApplicant(request: RefuseApplicantRequest): RefuseApplicantResponse {
  var runtime = new Util.RuntimeOptions{};
  return refuseApplicantWithOptions(request, runtime);
}

model CreateIntentionOrderGeneratingPayRequest {
  intentionBizId?: string(name='IntentionBizId'),
  paymentCallback?: string(name='PaymentCallback'),
  channel?: string(name='Channel'),
}

model CreateIntentionOrderGeneratingPayResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  payUrl?: string(name='PayUrl'),
  success?: boolean(name='Success'),
  orderIds?: [ long ](name='OrderIds'),
}

model CreateIntentionOrderGeneratingPayResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIntentionOrderGeneratingPayResponseBody(name='body'),
}

async function createIntentionOrderGeneratingPayWithOptions(request: CreateIntentionOrderGeneratingPayRequest, runtime: Util.RuntimeOptions): CreateIntentionOrderGeneratingPayResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateIntentionOrderGeneratingPay', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createIntentionOrderGeneratingPay(request: CreateIntentionOrderGeneratingPayRequest): CreateIntentionOrderGeneratingPayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIntentionOrderGeneratingPayWithOptions(request, runtime);
}

model ListNotaryOrdersRequest {
  startOrderDate?: long(name='StartOrderDate'),
  endOrderDate?: long(name='EndOrderDate'),
  notaryStatus?: int32(name='NotaryStatus'),
  aliyunOrderId?: string(name='AliyunOrderId'),
  sortByType?: string(name='SortByType'),
  sortKeyType?: int32(name='SortKeyType'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  bizId?: string(name='BizId'),
  notaryType?: int32(name='NotaryType'),
}

model ListNotaryOrdersResponseBody = {
  nextPage?: boolean(name='NextPage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
  totalItemNum?: int32(name='TotalItemNum'),
  prePage?: boolean(name='PrePage'),
  currentPageNum?: int32(name='CurrentPageNum'),
  errorMsg?: string(name='ErrorMsg'),
  totalPageNum?: int32(name='TotalPageNum'),
  pageSize?: int32(name='PageSize'),
  data?: {
    notaryOrder?: [ 
    {
      orderDate?: long(name='OrderDate'),
      orderPrice?: float(name='OrderPrice'),
      notaryType?: int32(name='NotaryType'),
      tmClassification?: string(name='TmClassification'),
      bizId?: string(name='BizId'),
      gmtModified?: long(name='GmtModified'),
      notaryStatus?: int32(name='NotaryStatus'),
      notaryOrderId?: long(name='NotaryOrderId'),
      tmName?: string(name='TmName'),
      tmRegisterNo?: string(name='TmRegisterNo'),
      tmImage?: string(name='TmImage'),
      aliyunOrderId?: string(name='AliyunOrderId'),
      applyPostStatus?: string(name='ApplyPostStatus'),
      notaryCertificate?: string(name='NotaryCertificate'),
      notaryPlatformName?: string(name='NotaryPlatformName'),
    }
  ](name='NotaryOrder')
  }(name='Data'),
}

model ListNotaryOrdersResponse = {
  headers: map[string]string(name='headers'),
  body: ListNotaryOrdersResponseBody(name='body'),
}

async function listNotaryOrdersWithOptions(request: ListNotaryOrdersRequest, runtime: Util.RuntimeOptions): ListNotaryOrdersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListNotaryOrders', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listNotaryOrders(request: ListNotaryOrdersRequest): ListNotaryOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNotaryOrdersWithOptions(request, runtime);
}

model GetSupportPrincipalNameResponseBody = {
  requestId?: string(name='RequestId'),
  principals?: [ 
    {
      principalDescription?: string(name='PrincipalDescription'),
      defaultPrincipal?: boolean(name='DefaultPrincipal'),
      principalValue?: int32(name='PrincipalValue'),
    }
  ](name='Principals'),
}

model GetSupportPrincipalNameResponse = {
  headers: map[string]string(name='headers'),
  body: GetSupportPrincipalNameResponseBody(name='body'),
}

async function getSupportPrincipalNameWithOptions(runtime: Util.RuntimeOptions): GetSupportPrincipalNameResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('GetSupportPrincipalName', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSupportPrincipalName(): GetSupportPrincipalNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSupportPrincipalNameWithOptions(runtime);
}

model StartNotaryRequest {
  notaryOrderId?: long(name='NotaryOrderId'),
}

model StartNotaryResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  notaryUrl?: string(name='NotaryUrl'),
  errorCode?: string(name='ErrorCode'),
}

model StartNotaryResponse = {
  headers: map[string]string(name='headers'),
  body: StartNotaryResponseBody(name='body'),
}

async function startNotaryWithOptions(request: StartNotaryRequest, runtime: Util.RuntimeOptions): StartNotaryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StartNotary', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function startNotary(request: StartNotaryRequest): StartNotaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return startNotaryWithOptions(request, runtime);
}

model UpdateSendMaterialNumRequest {
  bizId?: string(name='BizId'),
  num?: string(name='Num'),
  operateType?: int32(name='OperateType'),
}

model UpdateSendMaterialNumResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  errorCode?: string(name='ErrorCode'),
}

model UpdateSendMaterialNumResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSendMaterialNumResponseBody(name='body'),
}

async function updateSendMaterialNumWithOptions(request: UpdateSendMaterialNumRequest, runtime: Util.RuntimeOptions): UpdateSendMaterialNumResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateSendMaterialNum', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateSendMaterialNum(request: UpdateSendMaterialNumRequest): UpdateSendMaterialNumResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSendMaterialNumWithOptions(request, runtime);
}

model DeleteTrademarkApplicationRequest {
  bizId?: string(name='BizId'),
}

model DeleteTrademarkApplicationResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTrademarkApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTrademarkApplicationResponseBody(name='body'),
}

async function deleteTrademarkApplicationWithOptions(request: DeleteTrademarkApplicationRequest, runtime: Util.RuntimeOptions): DeleteTrademarkApplicationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteTrademarkApplication', '2018-07-24', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteTrademarkApplication(request: DeleteTrademarkApplicationRequest): DeleteTrademarkApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTrademarkApplicationWithOptions(request, runtime);
}

