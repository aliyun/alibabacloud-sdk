/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('trademark', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AcceptPartnerNotificationRequest {
  bizId?: string(name='BizId'),
  material?: string(name='Material'),
  operation?: string(name='Operation'),
  remark?: string(name='Remark'),
}

model AcceptPartnerNotificationResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AcceptPartnerNotificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AcceptPartnerNotificationResponseBody(name='body'),
}

async function acceptPartnerNotificationWithOptions(request: AcceptPartnerNotificationRequest, runtime: Util.RuntimeOptions): AcceptPartnerNotificationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.material)) {
    query['Material'] = request.material;
  }
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AcceptPartnerNotification',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function acceptPartnerNotification(request: AcceptPartnerNotificationRequest): AcceptPartnerNotificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return acceptPartnerNotificationWithOptions(request, runtime);
}

model ApplyNotaryPostRequest {
  notaryOrderId?: long(name='NotaryOrderId'),
  receiverAddress?: string(name='ReceiverAddress'),
  receiverName?: string(name='ReceiverName'),
  receiverPhone?: string(name='ReceiverPhone'),
}

model ApplyNotaryPostResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ApplyNotaryPostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyNotaryPostResponseBody(name='body'),
}

async function applyNotaryPostWithOptions(request: ApplyNotaryPostRequest, runtime: Util.RuntimeOptions): ApplyNotaryPostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.notaryOrderId)) {
    query['NotaryOrderId'] = request.notaryOrderId;
  }
  if (!Util.isUnset(request.receiverAddress)) {
    query['ReceiverAddress'] = request.receiverAddress;
  }
  if (!Util.isUnset(request.receiverName)) {
    query['ReceiverName'] = request.receiverName;
  }
  if (!Util.isUnset(request.receiverPhone)) {
    query['ReceiverPhone'] = request.receiverPhone;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyNotaryPost',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyNotaryPost(request: ApplyNotaryPostRequest): ApplyNotaryPostResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyNotaryPostWithOptions(request, runtime);
}

model AskAdjudicationFileRequest {
  bizId?: string(name='BizId'),
  contactAddress?: string(name='ContactAddress'),
  contactCity?: string(name='ContactCity'),
  contactCounty?: string(name='ContactCounty'),
  contactDistrict?: string(name='ContactDistrict'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactProvince?: string(name='ContactProvince'),
}

model AskAdjudicationFileResponseBody = {
  requestId?: string(name='RequestId'),
}

model AskAdjudicationFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AskAdjudicationFileResponseBody(name='body'),
}

async function askAdjudicationFileWithOptions(request: AskAdjudicationFileRequest, runtime: Util.RuntimeOptions): AskAdjudicationFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.contactAddress)) {
    query['ContactAddress'] = request.contactAddress;
  }
  if (!Util.isUnset(request.contactCity)) {
    query['ContactCity'] = request.contactCity;
  }
  if (!Util.isUnset(request.contactCounty)) {
    query['ContactCounty'] = request.contactCounty;
  }
  if (!Util.isUnset(request.contactDistrict)) {
    query['ContactDistrict'] = request.contactDistrict;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactNumber)) {
    query['ContactNumber'] = request.contactNumber;
  }
  if (!Util.isUnset(request.contactProvince)) {
    query['ContactProvince'] = request.contactProvince;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AskAdjudicationFile',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function askAdjudicationFile(request: AskAdjudicationFileRequest): AskAdjudicationFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return askAdjudicationFileWithOptions(request, runtime);
}

model BindMaterialRequest {
  bizId?: string(name='BizId', example='trademark_register-cn-11212'),
  legalNoticeKey?: string(name='LegalNoticeKey'),
  loaOssKey?: string(name='LoaOssKey', example='/test/loaosskey.jpg'),
  materialId?: string(name='MaterialId', example='11'),
}

model BindMaterialResponseBody = {
  requestId?: string(name='RequestId', example='0F23FFEA-6FF9-42CA-9819-6D63BEFE2C2D'),
}

model BindMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindMaterialResponseBody(name='body'),
}

async function bindMaterialWithOptions(request: BindMaterialRequest, runtime: Util.RuntimeOptions): BindMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.legalNoticeKey)) {
    query['LegalNoticeKey'] = request.legalNoticeKey;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    query['LoaOssKey'] = request.loaOssKey;
  }
  if (!Util.isUnset(request.materialId)) {
    query['MaterialId'] = request.materialId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindMaterial',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindMaterial(request: BindMaterialRequest): BindMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindMaterialWithOptions(request, runtime);
}

model CancelTradeOrderRequest {
  bizId?: string(name='BizId'),
}

model CancelTradeOrderResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelTradeOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelTradeOrderResponseBody(name='body'),
}

async function cancelTradeOrderWithOptions(request: CancelTradeOrderRequest, runtime: Util.RuntimeOptions): CancelTradeOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelTradeOrder',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelTradeOrder(request: CancelTradeOrderRequest): CancelTradeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelTradeOrderWithOptions(request, runtime);
}

model CheckFlsmFillRequest {
  applicantType?: string(name='ApplicantType'),
  ossKey?: string(name='OssKey'),
  personalType?: string(name='PersonalType'),
  wtrName?: string(name='WtrName'),
}

model CheckFlsmFillResponseBody = {
  requestId?: string(name='RequestId'),
  tips?: string(name='Tips'),
}

model CheckFlsmFillResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckFlsmFillResponseBody(name='body'),
}

async function checkFlsmFillWithOptions(request: CheckFlsmFillRequest, runtime: Util.RuntimeOptions): CheckFlsmFillResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicantType)) {
    query['ApplicantType'] = request.applicantType;
  }
  if (!Util.isUnset(request.ossKey)) {
    query['OssKey'] = request.ossKey;
  }
  if (!Util.isUnset(request.personalType)) {
    query['PersonalType'] = request.personalType;
  }
  if (!Util.isUnset(request.wtrName)) {
    query['WtrName'] = request.wtrName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckFlsmFill',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkFlsmFill(request: CheckFlsmFillRequest): CheckFlsmFillResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkFlsmFillWithOptions(request, runtime);
}

model CheckIfCollectedRequest {
  itemIdList?: string(name='ItemIdList'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  type?: int32(name='Type'),
}

model CheckIfCollectedResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    trademark?: [ 
    {
      id?: long(name='Id'),
      itemIdList?: string(name='ItemIdList'),
      name?: string(name='Name'),
      type?: int32(name='Type'),
    }
  ](name='Trademark')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model CheckIfCollectedResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckIfCollectedResponseBody(name='body'),
}

async function checkIfCollectedWithOptions(request: CheckIfCollectedRequest, runtime: Util.RuntimeOptions): CheckIfCollectedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.itemIdList)) {
    query['ItemIdList'] = request.itemIdList;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckIfCollected',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkIfCollected(request: CheckIfCollectedRequest): CheckIfCollectedResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkIfCollectedWithOptions(request, runtime);
}

model CheckLoaFillRequest {
  applicantType?: string(name='ApplicantType'),
  bizType?: string(name='BizType'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactZipcode?: string(name='ContactZipcode'),
  ossKey?: string(name='OssKey'),
  personalType?: string(name='PersonalType'),
  principalName?: string(name='PrincipalName'),
  type?: string(name='Type'),
  wtrName?: string(name='WtrName'),
}

model CheckLoaFillResponseBody = {
  data?: {
    addressFill?: boolean(name='AddressFill'),
    countryFill?: boolean(name='CountryFill'),
    errorMsgs?: {
      errorMsg?: [ string ](name='ErrorMsg')
    }(name='ErrorMsgs'),
    materialNameFill?: boolean(name='MaterialNameFill'),
    nationalityFill?: boolean(name='NationalityFill'),
    stampFill?: boolean(name='StampFill'),
    templateUrl?: string(name='TemplateUrl'),
    tips?: string(name='Tips'),
    tradeMarkNameFill?: boolean(name='TradeMarkNameFill'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CheckLoaFillResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckLoaFillResponseBody(name='body'),
}

async function checkLoaFillWithOptions(request: CheckLoaFillRequest, runtime: Util.RuntimeOptions): CheckLoaFillResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicantType)) {
    query['ApplicantType'] = request.applicantType;
  }
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactNumber)) {
    query['ContactNumber'] = request.contactNumber;
  }
  if (!Util.isUnset(request.contactZipcode)) {
    query['ContactZipcode'] = request.contactZipcode;
  }
  if (!Util.isUnset(request.ossKey)) {
    query['OssKey'] = request.ossKey;
  }
  if (!Util.isUnset(request.personalType)) {
    query['PersonalType'] = request.personalType;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.wtrName)) {
    query['WtrName'] = request.wtrName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckLoaFill',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkLoaFill(request: CheckLoaFillRequest): CheckLoaFillResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkLoaFillWithOptions(request, runtime);
}

model CheckTrademarkIconRequest {
  eventSceneType?: int32(name='EventSceneType'),
  trademarkIconOssKey?: string(name='TrademarkIconOssKey'),
}

model CheckTrademarkIconResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CheckTrademarkIconResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckTrademarkIconResponseBody(name='body'),
}

async function checkTrademarkIconWithOptions(request: CheckTrademarkIconRequest, runtime: Util.RuntimeOptions): CheckTrademarkIconResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventSceneType)) {
    query['EventSceneType'] = request.eventSceneType;
  }
  if (!Util.isUnset(request.trademarkIconOssKey)) {
    query['TrademarkIconOssKey'] = request.trademarkIconOssKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckTrademarkIcon',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkTrademarkIcon(request: CheckTrademarkIconRequest): CheckTrademarkIconResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkTrademarkIconWithOptions(request, runtime);
}

model CheckTrademarkOrderRequest {
  agreementId?: string(name='AgreementId'),
  bizId?: string(name='BizId'),
  channel?: string(name='Channel'),
  isBlackIcon?: boolean(name='IsBlackIcon'),
  loaOssKey?: string(name='LoaOssKey'),
  logoGoodsId?: string(name='LogoGoodsId'),
  materialId?: string(name='MaterialId'),
  orderData?: string(name='OrderData'),
  partnerCode?: string(name='PartnerCode'),
  phoneNum?: string(name='PhoneNum'),
  realUserName?: string(name='RealUserName'),
  registerName?: string(name='RegisterName'),
  registerNumber?: string(name='RegisterNumber'),
  renewInfoId?: string(name='RenewInfoId'),
  rootCode?: string(name='RootCode'),
  tmComment?: string(name='TmComment'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  tmNameType?: string(name='TmNameType'),
  type?: int32(name='Type'),
  uid?: string(name='Uid'),
  userId?: long(name='UserId'),
}

model CheckTrademarkOrderResponseBody = {
  data?: map[string]any(name='Data'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckTrademarkOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckTrademarkOrderResponseBody(name='body'),
}

async function checkTrademarkOrderWithOptions(request: CheckTrademarkOrderRequest, runtime: Util.RuntimeOptions): CheckTrademarkOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.agreementId)) {
    query['AgreementId'] = request.agreementId;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.isBlackIcon)) {
    query['IsBlackIcon'] = request.isBlackIcon;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    query['LoaOssKey'] = request.loaOssKey;
  }
  if (!Util.isUnset(request.logoGoodsId)) {
    query['LogoGoodsId'] = request.logoGoodsId;
  }
  if (!Util.isUnset(request.materialId)) {
    query['MaterialId'] = request.materialId;
  }
  if (!Util.isUnset(request.orderData)) {
    query['OrderData'] = request.orderData;
  }
  if (!Util.isUnset(request.partnerCode)) {
    query['PartnerCode'] = request.partnerCode;
  }
  if (!Util.isUnset(request.phoneNum)) {
    query['PhoneNum'] = request.phoneNum;
  }
  if (!Util.isUnset(request.realUserName)) {
    query['RealUserName'] = request.realUserName;
  }
  if (!Util.isUnset(request.registerName)) {
    query['RegisterName'] = request.registerName;
  }
  if (!Util.isUnset(request.registerNumber)) {
    query['RegisterNumber'] = request.registerNumber;
  }
  if (!Util.isUnset(request.renewInfoId)) {
    query['RenewInfoId'] = request.renewInfoId;
  }
  if (!Util.isUnset(request.rootCode)) {
    query['RootCode'] = request.rootCode;
  }
  if (!Util.isUnset(request.tmComment)) {
    query['TmComment'] = request.tmComment;
  }
  if (!Util.isUnset(request.tmIcon)) {
    query['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNameType)) {
    query['TmNameType'] = request.tmNameType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckTrademarkOrder',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkTrademarkOrder(request: CheckTrademarkOrderRequest): CheckTrademarkOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkTrademarkOrderWithOptions(request, runtime);
}

model CombineLoaRequest {
  address?: string(name='Address'),
  applicantType?: string(name='ApplicantType'),
  contactName?: string(name='ContactName'),
  contactPhone?: string(name='ContactPhone'),
  contactPostcode?: string(name='ContactPostcode'),
  materialId?: string(name='MaterialId', example='12'),
  materialName?: string(name='MaterialName'),
  nationality?: string(name='Nationality'),
  personalType?: string(name='PersonalType'),
  principalName?: int32(name='PrincipalName'),
  tmNumber?: string(name='TmNumber'),
  tmProduceType?: string(name='TmProduceType', example='1'),
  trademarkName?: string(name='TrademarkName'),
}

model CombineLoaResponseBody = {
  requestId?: string(name='RequestId', example='166BC359-A3D8-4287-BC39-56A144A1583A'),
  templateCombineUrl?: string(name='TemplateCombineUrl', example='https://trademark-loa.oss-cn-beijing.aliyuncs.com/usertrademark/1219541161213057_CD0D64DFC8D37DB2658A5BEA93BF480E.jpg?Expires=1545707150&OSSAccessKeyId=hObpgEXoca42qH3V&Signature=idfmwfKdGSha9PP3IPn2KCwhycM%3D'),
}

model CombineLoaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CombineLoaResponseBody(name='body'),
}

async function combineLoaWithOptions(request: CombineLoaRequest, runtime: Util.RuntimeOptions): CombineLoaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.applicantType)) {
    query['ApplicantType'] = request.applicantType;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactPhone)) {
    query['ContactPhone'] = request.contactPhone;
  }
  if (!Util.isUnset(request.contactPostcode)) {
    query['ContactPostcode'] = request.contactPostcode;
  }
  if (!Util.isUnset(request.materialId)) {
    query['MaterialId'] = request.materialId;
  }
  if (!Util.isUnset(request.materialName)) {
    query['MaterialName'] = request.materialName;
  }
  if (!Util.isUnset(request.nationality)) {
    query['Nationality'] = request.nationality;
  }
  if (!Util.isUnset(request.personalType)) {
    query['PersonalType'] = request.personalType;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  if (!Util.isUnset(request.tmNumber)) {
    query['TmNumber'] = request.tmNumber;
  }
  if (!Util.isUnset(request.tmProduceType)) {
    query['TmProduceType'] = request.tmProduceType;
  }
  if (!Util.isUnset(request.trademarkName)) {
    query['TrademarkName'] = request.trademarkName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CombineLoa',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function combineLoa(request: CombineLoaRequest): CombineLoaResponse {
  var runtime = new Util.RuntimeOptions{};
  return combineLoaWithOptions(request, runtime);
}

model CombineWTSRequest {
  address?: string(name='Address'),
  contact?: string(name='Contact'),
  contactAddressPost?: string(name='ContactAddressPost'),
  contactMobile?: string(name='ContactMobile'),
  materialId?: string(name='MaterialId'),
  materialName?: string(name='MaterialName'),
  nationality?: string(name='Nationality'),
  principalName?: string(name='PrincipalName'),
  tmNum?: string(name='TmNum'),
  tmProduceType?: string(name='TmProduceType'),
  trademarkName?: string(name='TrademarkName'),
  wtsType?: string(name='WtsType'),
}

model CombineWTSResponseBody = {
  requestId?: string(name='RequestId'),
  templateCombineUrl?: string(name='TemplateCombineUrl'),
}

model CombineWTSResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CombineWTSResponseBody(name='body'),
}

async function combineWTSWithOptions(request: CombineWTSRequest, runtime: Util.RuntimeOptions): CombineWTSResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.contact)) {
    query['Contact'] = request.contact;
  }
  if (!Util.isUnset(request.contactAddressPost)) {
    query['ContactAddressPost'] = request.contactAddressPost;
  }
  if (!Util.isUnset(request.contactMobile)) {
    query['ContactMobile'] = request.contactMobile;
  }
  if (!Util.isUnset(request.materialId)) {
    query['MaterialId'] = request.materialId;
  }
  if (!Util.isUnset(request.materialName)) {
    query['MaterialName'] = request.materialName;
  }
  if (!Util.isUnset(request.nationality)) {
    query['Nationality'] = request.nationality;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  if (!Util.isUnset(request.tmNum)) {
    query['TmNum'] = request.tmNum;
  }
  if (!Util.isUnset(request.tmProduceType)) {
    query['TmProduceType'] = request.tmProduceType;
  }
  if (!Util.isUnset(request.trademarkName)) {
    query['TrademarkName'] = request.trademarkName;
  }
  if (!Util.isUnset(request.wtsType)) {
    query['WtsType'] = request.wtsType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CombineWTS',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function combineWTS(request: CombineWTSRequest): CombineWTSResponse {
  var runtime = new Util.RuntimeOptions{};
  return combineWTSWithOptions(request, runtime);
}

model ComplementIntentionUserIdRequest {
  aliyunKp?: string(name='AliyunKp'),
  bid?: string(name='Bid'),
  bizId?: string(name='BizId'),
  callerParentId?: long(name='CallerParentId'),
  callerType?: string(name='CallerType'),
  complementUserId?: string(name='ComplementUserId'),
  type?: int32(name='Type'),
}

model ComplementIntentionUserIdResponseBody = {
  requestId?: string(name='RequestId'),
}

model ComplementIntentionUserIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ComplementIntentionUserIdResponseBody(name='body'),
}

async function complementIntentionUserIdWithOptions(request: ComplementIntentionUserIdRequest, runtime: Util.RuntimeOptions): ComplementIntentionUserIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunKp)) {
    query['AliyunKp'] = request.aliyunKp;
  }
  if (!Util.isUnset(request.bid)) {
    query['Bid'] = request.bid;
  }
  if (!Util.isUnset(request.callerParentId)) {
    query['CallerParentId'] = request.callerParentId;
  }
  if (!Util.isUnset(request.callerType)) {
    query['CallerType'] = request.callerType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.complementUserId)) {
    body['ComplementUserId'] = request.complementUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ComplementIntentionUserId',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function complementIntentionUserId(request: ComplementIntentionUserIdRequest): ComplementIntentionUserIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return complementIntentionUserIdWithOptions(request, runtime);
}

model ConfirmAdditionalMaterialRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
}

model ConfirmAdditionalMaterialResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConfirmAdditionalMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfirmAdditionalMaterialResponseBody(name='body'),
}

async function confirmAdditionalMaterialWithOptions(request: ConfirmAdditionalMaterialRequest, runtime: Util.RuntimeOptions): ConfirmAdditionalMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmAdditionalMaterial',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function confirmAdditionalMaterial(request: ConfirmAdditionalMaterialRequest): ConfirmAdditionalMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmAdditionalMaterialWithOptions(request, runtime);
}

model ConfirmApplicantRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
}

model ConfirmApplicantResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConfirmApplicantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfirmApplicantResponseBody(name='body'),
}

async function confirmApplicantWithOptions(request: ConfirmApplicantRequest, runtime: Util.RuntimeOptions): ConfirmApplicantResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmApplicant',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function confirmApplicant(request: ConfirmApplicantRequest): ConfirmApplicantResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmApplicantWithOptions(request, runtime);
}

model ConfirmDissentOriginalRequest {
  bizId?: string(name='BizId'),
  contactAddress?: string(name='ContactAddress'),
  contactCity?: string(name='ContactCity'),
  contactCounty?: string(name='ContactCounty'),
  contactDistrict?: string(name='ContactDistrict'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactProvince?: string(name='ContactProvince'),
  operateType?: string(name='OperateType'),
}

model ConfirmDissentOriginalResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfirmDissentOriginalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfirmDissentOriginalResponseBody(name='body'),
}

async function confirmDissentOriginalWithOptions(request: ConfirmDissentOriginalRequest, runtime: Util.RuntimeOptions): ConfirmDissentOriginalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.contactAddress)) {
    query['ContactAddress'] = request.contactAddress;
  }
  if (!Util.isUnset(request.contactCity)) {
    query['ContactCity'] = request.contactCity;
  }
  if (!Util.isUnset(request.contactCounty)) {
    query['ContactCounty'] = request.contactCounty;
  }
  if (!Util.isUnset(request.contactDistrict)) {
    query['ContactDistrict'] = request.contactDistrict;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactNumber)) {
    query['ContactNumber'] = request.contactNumber;
  }
  if (!Util.isUnset(request.contactProvince)) {
    query['ContactProvince'] = request.contactProvince;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmDissentOriginal',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function confirmDissentOriginal(request: ConfirmDissentOriginalRequest): ConfirmDissentOriginalResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmDissentOriginalWithOptions(request, runtime);
}

model ConvertImageToGrayRequest {
  ossKey?: string(name='OssKey'),
}

model ConvertImageToGrayResponseBody = {
  requestId?: string(name='RequestId'),
  signatureUrl?: string(name='SignatureUrl'),
}

model ConvertImageToGrayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConvertImageToGrayResponseBody(name='body'),
}

async function convertImageToGrayWithOptions(request: ConvertImageToGrayRequest, runtime: Util.RuntimeOptions): ConvertImageToGrayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ossKey)) {
    query['OssKey'] = request.ossKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConvertImageToGray',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function convertImageToGray(request: ConvertImageToGrayRequest): ConvertImageToGrayResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertImageToGrayWithOptions(request, runtime);
}

model CopyApplicantRequest {
  id?: long(name='Id'),
}

model CopyApplicantResponseBody = {
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model CopyApplicantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyApplicantResponseBody(name='body'),
}

async function copyApplicantWithOptions(request: CopyApplicantRequest, runtime: Util.RuntimeOptions): CopyApplicantResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CopyApplicant',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function copyApplicant(request: CopyApplicantRequest): CopyApplicantResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyApplicantWithOptions(request, runtime);
}

model CreateIntentionOrderRequest {
  channel?: string(name='Channel'),
  intentionBizId?: string(name='IntentionBizId'),
}

model CreateIntentionOrderResponseBody = {
  data?: {
    orderIds?: [ string ](name='OrderIds')
  }(name='Data'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateIntentionOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIntentionOrderResponseBody(name='body'),
}

async function createIntentionOrderWithOptions(request: CreateIntentionOrderRequest, runtime: Util.RuntimeOptions): CreateIntentionOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.intentionBizId)) {
    query['IntentionBizId'] = request.intentionBizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateIntentionOrder',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIntentionOrder(request: CreateIntentionOrderRequest): CreateIntentionOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIntentionOrderWithOptions(request, runtime);
}

model CreateIntentionOrderGeneratingPayRequest {
  channel?: string(name='Channel'),
  intentionBizId?: string(name='IntentionBizId'),
  paymentCallback?: string(name='PaymentCallback'),
}

model CreateIntentionOrderGeneratingPayResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  orderIds?: [ long ](name='OrderIds'),
  payUrl?: string(name='PayUrl'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateIntentionOrderGeneratingPayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIntentionOrderGeneratingPayResponseBody(name='body'),
}

async function createIntentionOrderGeneratingPayWithOptions(request: CreateIntentionOrderGeneratingPayRequest, runtime: Util.RuntimeOptions): CreateIntentionOrderGeneratingPayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.intentionBizId)) {
    query['IntentionBizId'] = request.intentionBizId;
  }
  if (!Util.isUnset(request.paymentCallback)) {
    query['PaymentCallback'] = request.paymentCallback;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateIntentionOrderGeneratingPay',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIntentionOrderGeneratingPay(request: CreateIntentionOrderGeneratingPayRequest): CreateIntentionOrderGeneratingPayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIntentionOrderGeneratingPayWithOptions(request, runtime);
}

model CreateTrademarkOrderRequest {
  agreementId?: string(name='AgreementId'),
  bigDipperSource?: string(name='BigDipperSource'),
  bizId?: string(name='BizId'),
  channel?: string(name='Channel', example='aliyun'),
  isBlackIcon?: boolean(name='IsBlackIcon', example='true'),
  legalNoticeKey?: string(name='LegalNoticeKey'),
  loaOssKey?: string(name='LoaOssKey', example='112.jpg'),
  materialId?: string(name='MaterialId', example='12'),
  orderData?: string(name='OrderData', example='{   "16": "160008,160130,160246,16090014,16090003,160014,160147,160243,16060007,160175",   "35": "35010071,350039,350084,350092,C350001,C350002,35010055,350046,350103,C350008,350106" }'),
  partnerCode?: string(name='PartnerCode'),
  phoneNum?: string(name='PhoneNum'),
  principalName?: int32(name='PrincipalName'),
  realUserName?: string(name='RealUserName'),
  registerName?: string(name='RegisterName'),
  registerNumber?: string(name='RegisterNumber', example='10011010'),
  renewInfoId?: string(name='RenewInfoId', example='121'),
  rootCode?: string(name='RootCode', example='1'),
  sessionId?: string(name='SessionId'),
  tmComment?: string(name='TmComment'),
  tmIcon?: string(name='TmIcon', example='icon/azaa6tm403.jpg'),
  tmName?: string(name='TmName'),
  tmNameType?: string(name='TmNameType', example='1'),
  type?: int32(name='Type', example='1'),
  ua?: string(name='Ua'),
  uid?: string(name='Uid'),
  userId?: long(name='UserId', example='11211'),
}

model CreateTrademarkOrderResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  orderId?: long(name='OrderId', example='202975794160629'),
  requestId?: string(name='RequestId', example='483637DD-1D82-4A73-8F68-0FCDA2F677D6'),
  success?: boolean(name='Success', example='true'),
}

model CreateTrademarkOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTrademarkOrderResponseBody(name='body'),
}

async function createTrademarkOrderWithOptions(request: CreateTrademarkOrderRequest, runtime: Util.RuntimeOptions): CreateTrademarkOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.agreementId)) {
    query['AgreementId'] = request.agreementId;
  }
  if (!Util.isUnset(request.bigDipperSource)) {
    query['BigDipperSource'] = request.bigDipperSource;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.isBlackIcon)) {
    query['IsBlackIcon'] = request.isBlackIcon;
  }
  if (!Util.isUnset(request.legalNoticeKey)) {
    query['LegalNoticeKey'] = request.legalNoticeKey;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    query['LoaOssKey'] = request.loaOssKey;
  }
  if (!Util.isUnset(request.materialId)) {
    query['MaterialId'] = request.materialId;
  }
  if (!Util.isUnset(request.orderData)) {
    query['OrderData'] = request.orderData;
  }
  if (!Util.isUnset(request.partnerCode)) {
    query['PartnerCode'] = request.partnerCode;
  }
  if (!Util.isUnset(request.phoneNum)) {
    query['PhoneNum'] = request.phoneNum;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  if (!Util.isUnset(request.realUserName)) {
    query['RealUserName'] = request.realUserName;
  }
  if (!Util.isUnset(request.registerName)) {
    query['RegisterName'] = request.registerName;
  }
  if (!Util.isUnset(request.registerNumber)) {
    query['RegisterNumber'] = request.registerNumber;
  }
  if (!Util.isUnset(request.renewInfoId)) {
    query['RenewInfoId'] = request.renewInfoId;
  }
  if (!Util.isUnset(request.rootCode)) {
    query['RootCode'] = request.rootCode;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.tmComment)) {
    query['TmComment'] = request.tmComment;
  }
  if (!Util.isUnset(request.tmIcon)) {
    query['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNameType)) {
    query['TmNameType'] = request.tmNameType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.ua)) {
    query['Ua'] = request.ua;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrademarkOrder',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTrademarkOrder(request: CreateTrademarkOrderRequest): CreateTrademarkOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTrademarkOrderWithOptions(request, runtime);
}

model DeleteMaterialRequest {
  id?: long(name='Id', example='1'),
}

model DeleteMaterialResponseBody = {
  errorCode?: string(name='ErrorCode', example='MATERIAL.NOT.EXIT'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId', example='ED93ADD0-034A-4B68-9AC7-61933DB0099C'),
  success?: boolean(name='Success', example='true'),
}

model DeleteMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMaterialResponseBody(name='body'),
}

async function deleteMaterialWithOptions(request: DeleteMaterialRequest, runtime: Util.RuntimeOptions): DeleteMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMaterial',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMaterial(request: DeleteMaterialRequest): DeleteMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMaterialWithOptions(request, runtime);
}

model DeleteTmMonitorRuleRequest {
  id?: long(name='Id'),
}

model DeleteTmMonitorRuleResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTmMonitorRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTmMonitorRuleResponseBody(name='body'),
}

async function deleteTmMonitorRuleWithOptions(request: DeleteTmMonitorRuleRequest, runtime: Util.RuntimeOptions): DeleteTmMonitorRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTmMonitorRule',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTmMonitorRule(request: DeleteTmMonitorRuleRequest): DeleteTmMonitorRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTmMonitorRuleWithOptions(request, runtime);
}

model DeleteTrademarkApplicationRequest {
  bizId?: string(name='BizId'),
}

model DeleteTrademarkApplicationResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTrademarkApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTrademarkApplicationResponseBody(name='body'),
}

async function deleteTrademarkApplicationWithOptions(request: DeleteTrademarkApplicationRequest, runtime: Util.RuntimeOptions): DeleteTrademarkApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTrademarkApplication',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTrademarkApplication(request: DeleteTrademarkApplicationRequest): DeleteTrademarkApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTrademarkApplicationWithOptions(request, runtime);
}

model DenySupplementRequest {
  id?: long(name='Id', example='12'),
}

model DenySupplementResponseBody = {
  errorCode?: string(name='ErrorCode', example='SUPPLEMENT_TIME_OUT_ERROR'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId', example='ED93ADD0-034A-4B68-9AC7-1121'),
  success?: boolean(name='Success', example='true'),
}

model DenySupplementResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DenySupplementResponseBody(name='body'),
}

async function denySupplementWithOptions(request: DenySupplementRequest, runtime: Util.RuntimeOptions): DenySupplementResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DenySupplement',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function denySupplement(request: DenySupplementRequest): DenySupplementResponse {
  var runtime = new Util.RuntimeOptions{};
  return denySupplementWithOptions(request, runtime);
}

model DescirbeCombineTrademarkRequest {
  accurateMatch?: boolean(name='AccurateMatch'),
  classification?: string(name='Classification'),
  name?: string(name='Name'),
  ownerName?: string(name='OwnerName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  products?: string(name='Products'),
  registrationNumber?: string(name='RegistrationNumber'),
  similarGroups?: string(name='SimilarGroups'),
}

model DescirbeCombineTrademarkResponseBody = {
  currentPageNumber?: int32(name='CurrentPageNumber'),
  data?: [ 
    {
      agency?: string(name='Agency'),
      announcementList?: [ 
        {
          annDate?: string(name='AnnDate'),
          annNumber?: string(name='AnnNumber'),
          annTypeCode?: string(name='AnnTypeCode'),
          annTypeName?: string(name='AnnTypeName'),
          imageUrl?: string(name='ImageUrl'),
          originalImageUrl?: string(name='OriginalImageUrl'),
        }
      ](name='AnnouncementList'),
      applyDate?: string(name='ApplyDate'),
      classification?: string(name='Classification'),
      exclusiveDateLimit?: string(name='ExclusiveDateLimit'),
      firstAnnoNumber?: string(name='FirstAnnoNumber'),
      firstAnnoType?: string(name='FirstAnnoType'),
      image?: string(name='Image'),
      indexId?: string(name='IndexId'),
      intlRegDate?: string(name='IntlRegDate'),
      lastProcedureStatus?: string(name='LastProcedureStatus'),
      lawFinalStatus?: string(name='LawFinalStatus'),
      name?: string(name='Name'),
      onSale?: int32(name='OnSale'),
      ownerAddress?: string(name='OwnerAddress'),
      ownerEnAddress?: string(name='OwnerEnAddress'),
      ownerEnName?: string(name='OwnerEnName'),
      ownerName?: string(name='OwnerName'),
      preAnnDate?: string(name='PreAnnDate'),
      preAnnNumber?: string(name='PreAnnNumber'),
      priorityDate?: string(name='PriorityDate'),
      procedures?: [ 
        {
          procedureCode?: string(name='ProcedureCode'),
          procedureDate?: string(name='ProcedureDate'),
          procedureName?: string(name='ProcedureName'),
          procedureResult?: string(name='ProcedureResult'),
          procedureStep?: string(name='ProcedureStep'),
        }
      ](name='Procedures'),
      productDescription?: string(name='ProductDescription'),
      regAnnDate?: string(name='RegAnnDate'),
      regAnnNumber?: string(name='RegAnnNumber'),
      registrationNumber?: string(name='RegistrationNumber'),
      registrationType?: string(name='RegistrationType'),
      secondAnnoNumber?: string(name='SecondAnnoNumber'),
      secondAnnoType?: string(name='SecondAnnoType'),
      share?: string(name='Share'),
      similarGroup?: string(name='SimilarGroup'),
      status?: string(name='Status'),
      subsequentDesignationDate?: string(name='SubsequentDesignationDate'),
    }
  ](name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNumber?: int32(name='TotalItemNumber'),
  totalPageNumber?: int32(name='TotalPageNumber'),
}

model DescirbeCombineTrademarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescirbeCombineTrademarkResponseBody(name='body'),
}

async function descirbeCombineTrademarkWithOptions(request: DescirbeCombineTrademarkRequest, runtime: Util.RuntimeOptions): DescirbeCombineTrademarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accurateMatch)) {
    query['AccurateMatch'] = request.accurateMatch;
  }
  if (!Util.isUnset(request.classification)) {
    query['Classification'] = request.classification;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerName)) {
    query['OwnerName'] = request.ownerName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.products)) {
    query['Products'] = request.products;
  }
  if (!Util.isUnset(request.registrationNumber)) {
    query['RegistrationNumber'] = request.registrationNumber;
  }
  if (!Util.isUnset(request.similarGroups)) {
    query['SimilarGroups'] = request.similarGroups;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescirbeCombineTrademark',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function descirbeCombineTrademark(request: DescirbeCombineTrademarkRequest): DescirbeCombineTrademarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return descirbeCombineTrademarkWithOptions(request, runtime);
}

model FillLogisticsRequest {
  bizId?: string(name='BizId'),
  logistics?: string(name='Logistics'),
}

model FillLogisticsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model FillLogisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FillLogisticsResponseBody(name='body'),
}

async function fillLogisticsWithOptions(request: FillLogisticsRequest, runtime: Util.RuntimeOptions): FillLogisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.logistics)) {
    query['Logistics'] = request.logistics;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FillLogistics',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function fillLogistics(request: FillLogisticsRequest): FillLogisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return fillLogisticsWithOptions(request, runtime);
}

model FilterUnavailableCodesRequest {
  codes?: map[string]any(name='Codes'),
}

model FilterUnavailableCodesShrinkRequest {
  codesShrink?: string(name='Codes'),
}

model FilterUnavailableCodesResponseBody = {
  data?: {
    codes?: [ string ](name='Codes')
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model FilterUnavailableCodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FilterUnavailableCodesResponseBody(name='body'),
}

async function filterUnavailableCodesWithOptions(tmpReq: FilterUnavailableCodesRequest, runtime: Util.RuntimeOptions): FilterUnavailableCodesResponse {
  Util.validateModel(tmpReq);
  var request = new FilterUnavailableCodesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.codes)) {
    request.codesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.codes, 'Codes', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.codesShrink)) {
    query['Codes'] = request.codesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FilterUnavailableCodes',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function filterUnavailableCodes(request: FilterUnavailableCodesRequest): FilterUnavailableCodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return filterUnavailableCodesWithOptions(request, runtime);
}

model ForceUploadTrademarkOnsaleRequest {
  beginTime?: long(name='BeginTime'),
  classificationCode?: string(name='ClassificationCode'),
  description?: string(name='Description'),
  endTime?: long(name='EndTime'),
  label?: string(name='Label'),
  originalPrice?: float(name='OriginalPrice'),
  ownerEnName?: string(name='OwnerEnName'),
  ownerName?: string(name='OwnerName'),
  reason?: string(name='Reason'),
  regAnnDate?: long(name='RegAnnDate'),
  secondaryClassification?: string(name='SecondaryClassification'),
  thirdClassification?: string(name='ThirdClassification'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  tmNumber?: string(name='TmNumber'),
  type?: string(name='Type'),
}

model ForceUploadTrademarkOnsaleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ForceUploadTrademarkOnsaleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ForceUploadTrademarkOnsaleResponseBody(name='body'),
}

async function forceUploadTrademarkOnsaleWithOptions(request: ForceUploadTrademarkOnsaleRequest, runtime: Util.RuntimeOptions): ForceUploadTrademarkOnsaleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.classificationCode)) {
    query['ClassificationCode'] = request.classificationCode;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.label)) {
    query['Label'] = request.label;
  }
  if (!Util.isUnset(request.originalPrice)) {
    query['OriginalPrice'] = request.originalPrice;
  }
  if (!Util.isUnset(request.ownerEnName)) {
    query['OwnerEnName'] = request.ownerEnName;
  }
  if (!Util.isUnset(request.ownerName)) {
    query['OwnerName'] = request.ownerName;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.regAnnDate)) {
    query['RegAnnDate'] = request.regAnnDate;
  }
  if (!Util.isUnset(request.secondaryClassification)) {
    query['SecondaryClassification'] = request.secondaryClassification;
  }
  if (!Util.isUnset(request.thirdClassification)) {
    query['ThirdClassification'] = request.thirdClassification;
  }
  if (!Util.isUnset(request.tmIcon)) {
    query['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNumber)) {
    query['TmNumber'] = request.tmNumber;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ForceUploadTrademarkOnsale',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function forceUploadTrademarkOnsale(request: ForceUploadTrademarkOnsaleRequest): ForceUploadTrademarkOnsaleResponse {
  var runtime = new Util.RuntimeOptions{};
  return forceUploadTrademarkOnsaleWithOptions(request, runtime);
}

model GenerateQrCodeRequest {
  fieldKey?: string(name='FieldKey'),
  ossKey?: string(name='OssKey'),
  uuid?: string(name='Uuid'),
}

model GenerateQrCodeResponseBody = {
  expireTime?: long(name='ExpireTime'),
  fieldKey?: string(name='FieldKey'),
  qrcodeUrl?: string(name='QrcodeUrl'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  uuid?: string(name='Uuid'),
}

model GenerateQrCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateQrCodeResponseBody(name='body'),
}

async function generateQrCodeWithOptions(request: GenerateQrCodeRequest, runtime: Util.RuntimeOptions): GenerateQrCodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fieldKey)) {
    query['FieldKey'] = request.fieldKey;
  }
  if (!Util.isUnset(request.ossKey)) {
    query['OssKey'] = request.ossKey;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateQrCode',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateQrCode(request: GenerateQrCodeRequest): GenerateQrCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateQrCodeWithOptions(request, runtime);
}

model GenerateUploadFilePolicyRequest {
  bizId?: string(name='BizId'),
  fileType?: string(name='FileType', example='ICON'),
}

model GenerateUploadFilePolicyResponseBody = {
  accessId?: string(name='AccessId', description='accessId', example='hObpgEXoca42qH3V'),
  encodedPolicy?: string(name='EncodedPolicy', description='osspolicy', example='eyJleHBpcmF0aW9uIjoiMjAxOC0xMi0yNVQwODozNDo0MC41ODVaIiwiY29uZGl0aW9ucyI6W1siY29udGVudC1sZW5ndGgtcmFuZ2UiLDAsMjA0ODAwXSxbInN0YXJ0cy13aXRoIiwiJGtleSIsIjEyMTk1NDExNjEyMTMwNTcvaWNvbiJdXX0='),
  expireTime?: long(name='ExpireTime', example='1545726880585'),
  fileDir?: string(name='FileDir', example='1219541161213057/icon'),
  host?: string(name='Host', example='//trade-mark-user-upload.oss-cn-beijing.aliyuncs.com/'),
  requestId?: string(name='RequestId', example='A891194E-BEB7-45EA-9A02-886B94479783'),
  signature?: string(name='Signature', example='ozjILaFe+DSgUPX2OOplFHYBJqk='),
}

model GenerateUploadFilePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateUploadFilePolicyResponseBody(name='body'),
}

async function generateUploadFilePolicyWithOptions(request: GenerateUploadFilePolicyRequest, runtime: Util.RuntimeOptions): GenerateUploadFilePolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.fileType)) {
    query['FileType'] = request.fileType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateUploadFilePolicy',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateUploadFilePolicy(request: GenerateUploadFilePolicyRequest): GenerateUploadFilePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateUploadFilePolicyWithOptions(request, runtime);
}

model GetAuthorizationLetterVersionRequest {
  ossKey?: string(name='OssKey'),
}

model GetAuthorizationLetterVersionResponseBody = {
  requestId?: string(name='RequestId'),
  version?: string(name='Version'),
}

model GetAuthorizationLetterVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAuthorizationLetterVersionResponseBody(name='body'),
}

async function getAuthorizationLetterVersionWithOptions(request: GetAuthorizationLetterVersionRequest, runtime: Util.RuntimeOptions): GetAuthorizationLetterVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ossKey)) {
    query['OssKey'] = request.ossKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAuthorizationLetterVersion',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAuthorizationLetterVersion(request: GetAuthorizationLetterVersionRequest): GetAuthorizationLetterVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuthorizationLetterVersionWithOptions(request, runtime);
}

model GetDefaultPrincipalResponseBody = {
  principalDescription?: string(name='PrincipalDescription'),
  principalName?: string(name='PrincipalName'),
  principalValue?: int32(name='PrincipalValue'),
  requestId?: string(name='RequestId'),
}

model GetDefaultPrincipalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDefaultPrincipalResponseBody(name='body'),
}

async function getDefaultPrincipalWithOptions(runtime: Util.RuntimeOptions): GetDefaultPrincipalResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetDefaultPrincipal',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDefaultPrincipal(): GetDefaultPrincipalResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefaultPrincipalWithOptions(runtime);
}

model GetDefaultPrincipalNameRequest {
  bizType?: string(name='BizType'),
}

model GetDefaultPrincipalNameResponseBody = {
  principalName?: int32(name='PrincipalName'),
  requestId?: string(name='RequestId'),
}

model GetDefaultPrincipalNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDefaultPrincipalNameResponseBody(name='body'),
}

async function getDefaultPrincipalNameWithOptions(request: GetDefaultPrincipalNameRequest, runtime: Util.RuntimeOptions): GetDefaultPrincipalNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDefaultPrincipalName',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDefaultPrincipalName(request: GetDefaultPrincipalNameRequest): GetDefaultPrincipalNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefaultPrincipalNameWithOptions(request, runtime);
}

model GetNotaryOrderRequest {
  notaryOrderId?: long(name='NotaryOrderId'),
}

model GetNotaryOrderResponseBody = {
  aliyunOrderId?: string(name='AliyunOrderId'),
  applyPostStatus?: int32(name='ApplyPostStatus'),
  bizId?: string(name='BizId'),
  businessLicense?: string(name='BusinessLicense'),
  businessLicenseId?: string(name='BusinessLicenseId'),
  companyContactName?: string(name='CompanyContactName'),
  companyContactPhone?: string(name='CompanyContactPhone'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  legalPersonIdCard?: string(name='LegalPersonIdCard'),
  legalPersonName?: string(name='LegalPersonName'),
  legalPersonPhone?: string(name='LegalPersonPhone'),
  name?: string(name='Name'),
  notaryAcceptDate?: long(name='NotaryAcceptDate'),
  notaryCertificate?: string(name='NotaryCertificate'),
  notaryFailedDate?: long(name='NotaryFailedDate'),
  notaryFailedReason?: string(name='NotaryFailedReason'),
  notaryOrderId?: long(name='NotaryOrderId'),
  notaryPlatformName?: string(name='NotaryPlatformName'),
  notaryPostReceipt?: string(name='NotaryPostReceipt'),
  notaryStatus?: int32(name='NotaryStatus'),
  notarySucceedDate?: long(name='NotarySucceedDate'),
  notaryType?: int32(name='NotaryType'),
  orderDate?: long(name='OrderDate'),
  orderPrice?: float(name='OrderPrice'),
  phone?: string(name='Phone'),
  receiverAddress?: string(name='ReceiverAddress'),
  receiverName?: string(name='ReceiverName'),
  receiverPhone?: string(name='ReceiverPhone'),
  receiverPostalCode?: string(name='ReceiverPostalCode'),
  requestId?: string(name='RequestId'),
  sellerBackOfIdCard?: string(name='SellerBackOfIdCard'),
  sellerCompanyName?: string(name='SellerCompanyName'),
  sellerFrontOfIdCard?: string(name='SellerFrontOfIdCard'),
  success?: boolean(name='Success'),
  tmAcceptCertificate?: string(name='TmAcceptCertificate'),
  tmClassification?: string(name='TmClassification'),
  tmImage?: string(name='TmImage'),
  tmName?: string(name='TmName'),
  tmRegisterCertificate?: string(name='TmRegisterCertificate'),
  tmRegisterChangeCertificate?: string(name='TmRegisterChangeCertificate'),
  tmRegisterNo?: string(name='TmRegisterNo'),
  type?: string(name='Type'),
}

model GetNotaryOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNotaryOrderResponseBody(name='body'),
}

async function getNotaryOrderWithOptions(request: GetNotaryOrderRequest, runtime: Util.RuntimeOptions): GetNotaryOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.notaryOrderId)) {
    query['NotaryOrderId'] = request.notaryOrderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNotaryOrder',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNotaryOrder(request: GetNotaryOrderRequest): GetNotaryOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNotaryOrderWithOptions(request, runtime);
}

model GetSupportPrincipalNameResponseBody = {
  principals?: [ 
    {
      defaultPrincipal?: boolean(name='DefaultPrincipal'),
      principalDescription?: string(name='PrincipalDescription'),
      principalValue?: int32(name='PrincipalValue'),
    }
  ](name='Principals'),
  requestId?: string(name='RequestId'),
}

model GetSupportPrincipalNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSupportPrincipalNameResponseBody(name='body'),
}

async function getSupportPrincipalNameWithOptions(runtime: Util.RuntimeOptions): GetSupportPrincipalNameResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetSupportPrincipalName',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSupportPrincipalName(): GetSupportPrincipalNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSupportPrincipalNameWithOptions(runtime);
}

model InsertMaterialRequest {
  address?: string(name='Address'),
  businessLicenceOssKey?: string(name='BusinessLicenceOssKey', example='sajkajk.key'),
  cardNumber?: string(name='CardNumber', example='121312312'),
  city?: string(name='City'),
  contactAddress?: string(name='ContactAddress'),
  contactCity?: string(name='ContactCity'),
  contactCounty?: string(name='ContactCounty'),
  contactDistrict?: string(name='ContactDistrict'),
  contactEmail?: string(name='ContactEmail', example='1233211@qq.com'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber', example='13112345678'),
  contactProvince?: string(name='ContactProvince'),
  contactZipcode?: string(name='ContactZipcode', example='111111'),
  country?: string(name='Country'),
  EAddress?: string(name='EAddress', example='english'),
  EName?: string(name='EName', example='jack'),
  idCardName?: string(name='IdCardName'),
  idCardNumber?: string(name='IdCardNumber'),
  idCardOssKey?: string(name='IdCardOssKey', example='asjkjakjasjk.key'),
  legalNoticeOssKey?: string(name='LegalNoticeOssKey', example='test/lege.jpg'),
  loaOssKey?: string(name='LoaOssKey', example='qwiqwioi.key'),
  name?: string(name='Name', example='jack'),
  passportOssKey?: string(name='PassportOssKey', example='sakasl.key'),
  personalType?: long(name='PersonalType'),
  principalName?: int32(name='PrincipalName'),
  province?: string(name='Province'),
  region?: int32(name='Region', example='1'),
  town?: string(name='Town'),
  type?: int32(name='Type', example='1'),
}

model InsertMaterialResponseBody = {
  requestId?: string(name='RequestId', example='FA4545CF-508D-4F5B-A6F5-932B7634055A'),
  success?: boolean(name='Success', example='true'),
}

model InsertMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertMaterialResponseBody(name='body'),
}

async function insertMaterialWithOptions(request: InsertMaterialRequest, runtime: Util.RuntimeOptions): InsertMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.businessLicenceOssKey)) {
    query['BusinessLicenceOssKey'] = request.businessLicenceOssKey;
  }
  if (!Util.isUnset(request.cardNumber)) {
    query['CardNumber'] = request.cardNumber;
  }
  if (!Util.isUnset(request.city)) {
    query['City'] = request.city;
  }
  if (!Util.isUnset(request.contactAddress)) {
    query['ContactAddress'] = request.contactAddress;
  }
  if (!Util.isUnset(request.contactCity)) {
    query['ContactCity'] = request.contactCity;
  }
  if (!Util.isUnset(request.contactCounty)) {
    query['ContactCounty'] = request.contactCounty;
  }
  if (!Util.isUnset(request.contactDistrict)) {
    query['ContactDistrict'] = request.contactDistrict;
  }
  if (!Util.isUnset(request.contactEmail)) {
    query['ContactEmail'] = request.contactEmail;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactNumber)) {
    query['ContactNumber'] = request.contactNumber;
  }
  if (!Util.isUnset(request.contactProvince)) {
    query['ContactProvince'] = request.contactProvince;
  }
  if (!Util.isUnset(request.contactZipcode)) {
    query['ContactZipcode'] = request.contactZipcode;
  }
  if (!Util.isUnset(request.country)) {
    query['Country'] = request.country;
  }
  if (!Util.isUnset(request.EAddress)) {
    query['EAddress'] = request.EAddress;
  }
  if (!Util.isUnset(request.EName)) {
    query['EName'] = request.EName;
  }
  if (!Util.isUnset(request.idCardName)) {
    query['IdCardName'] = request.idCardName;
  }
  if (!Util.isUnset(request.idCardNumber)) {
    query['IdCardNumber'] = request.idCardNumber;
  }
  if (!Util.isUnset(request.idCardOssKey)) {
    query['IdCardOssKey'] = request.idCardOssKey;
  }
  if (!Util.isUnset(request.legalNoticeOssKey)) {
    query['LegalNoticeOssKey'] = request.legalNoticeOssKey;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    query['LoaOssKey'] = request.loaOssKey;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.passportOssKey)) {
    query['PassportOssKey'] = request.passportOssKey;
  }
  if (!Util.isUnset(request.personalType)) {
    query['PersonalType'] = request.personalType;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  if (!Util.isUnset(request.province)) {
    query['Province'] = request.province;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.town)) {
    query['Town'] = request.town;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InsertMaterial',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function insertMaterial(request: InsertMaterialRequest): InsertMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertMaterialWithOptions(request, runtime);
}

model InsertRenewInfoRequest {
  address?: string(name='Address'),
  engAddress?: string(name='EngAddress', example='beijing'),
  engName?: string(name='EngName', example='aliyun'),
  name?: string(name='Name'),
  registerTime?: long(name='RegisterTime', example='1545731871738'),
}

model InsertRenewInfoResponseBody = {
  errorCode?: string(name='ErrorCode', example='PARAMETER.ILLEGALL'),
  errorMsg?: string(name='ErrorMsg'),
  id?: long(name='Id', example='12'),
  requestId?: string(name='RequestId', example='FA4545CF-508D-4F5B-A6F5-932B7634055A'),
  success?: boolean(name='Success', example='true'),
}

model InsertRenewInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertRenewInfoResponseBody(name='body'),
}

async function insertRenewInfoWithOptions(request: InsertRenewInfoRequest, runtime: Util.RuntimeOptions): InsertRenewInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.engAddress)) {
    query['EngAddress'] = request.engAddress;
  }
  if (!Util.isUnset(request.engName)) {
    query['EngName'] = request.engName;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.registerTime)) {
    query['RegisterTime'] = request.registerTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InsertRenewInfo',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function insertRenewInfo(request: InsertRenewInfoRequest): InsertRenewInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertRenewInfoWithOptions(request, runtime);
}

model InsertTmMonitorRuleRequest {
  classification?: map[string]any(name='Classification'),
  endApplyDate?: string(name='EndApplyDate'),
  notifyStatus?: map[string]any(name='NotifyStatus'),
  ruleKeyword?: string(name='RuleKeyword'),
  ruleName?: string(name='RuleName'),
  ruleSource?: string(name='RuleSource'),
  ruleType?: int32(name='RuleType'),
  startApplyDate?: string(name='StartApplyDate'),
}

model InsertTmMonitorRuleShrinkRequest {
  classificationShrink?: string(name='Classification'),
  endApplyDate?: string(name='EndApplyDate'),
  notifyStatusShrink?: string(name='NotifyStatus'),
  ruleKeyword?: string(name='RuleKeyword'),
  ruleName?: string(name='RuleName'),
  ruleSource?: string(name='RuleSource'),
  ruleType?: int32(name='RuleType'),
  startApplyDate?: string(name='StartApplyDate'),
}

model InsertTmMonitorRuleResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InsertTmMonitorRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertTmMonitorRuleResponseBody(name='body'),
}

async function insertTmMonitorRuleWithOptions(tmpReq: InsertTmMonitorRuleRequest, runtime: Util.RuntimeOptions): InsertTmMonitorRuleResponse {
  Util.validateModel(tmpReq);
  var request = new InsertTmMonitorRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.classification)) {
    request.classificationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.classification, 'Classification', 'json');
  }
  if (!Util.isUnset(tmpReq.notifyStatus)) {
    request.notifyStatusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notifyStatus, 'NotifyStatus', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.classificationShrink)) {
    query['Classification'] = request.classificationShrink;
  }
  if (!Util.isUnset(request.endApplyDate)) {
    query['EndApplyDate'] = request.endApplyDate;
  }
  if (!Util.isUnset(request.notifyStatusShrink)) {
    query['NotifyStatus'] = request.notifyStatusShrink;
  }
  if (!Util.isUnset(request.ruleKeyword)) {
    query['RuleKeyword'] = request.ruleKeyword;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleSource)) {
    query['RuleSource'] = request.ruleSource;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.startApplyDate)) {
    query['StartApplyDate'] = request.startApplyDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InsertTmMonitorRule',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function insertTmMonitorRule(request: InsertTmMonitorRuleRequest): InsertTmMonitorRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertTmMonitorRuleWithOptions(request, runtime);
}

model ListNotaryInfosRequest {
  bizOrderNo?: string(name='BizOrderNo', example='trademark_prepayment_pre-cn-123123test'),
  notaryType?: int32(name='NotaryType', example='1'),
  pageNum?: int32(name='PageNum', example='1'),
  pageSize?: int32(name='PageSize', example='50'),
  token?: string(name='Token', example='2dd2eed1-34d2-4142-811a-8861cf0076c3'),
}

model ListNotaryInfosResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum', example='1'),
  data?: {
    notaryInfo?: [ 
    {
      bizOrderNo?: string(name='BizOrderNo', example='trademark_prepayment_pre-cn-123123test'),
      gmtModified?: long(name='GmtModified', example='123231231213213'),
      notaryFailedReason?: string(name='NotaryFailedReason'),
      notaryStatus?: int32(name='NotaryStatus', example='1'),
      tmClassification?: string(name='TmClassification', example='23'),
      tmRegisterNo?: string(name='TmRegisterNo', example='123312'),
      token?: string(name='Token', description='token', example='2dd2eed1-34d2-4142-811a-8861cf0076c3'),
    }
  ](name='NotaryInfo')
  }(name='Data'),
  errorCode?: string(name='ErrorCode', example='PARAMETER.ILLEGAL'),
  errorMsg?: string(name='ErrorMsg'),
  nextPage?: boolean(name='NextPage', example='false'),
  pageSize?: int32(name='PageSize', example='50'),
  prePage?: boolean(name='PrePage', example='true'),
  requestId?: string(name='RequestId', example='1211212121-34d2-4142-811a-8861cf0076c3'),
  success?: boolean(name='Success', example='true'),
  totalItemNum?: int32(name='TotalItemNum', example='100'),
  totalPageNum?: int32(name='TotalPageNum', example='2'),
}

model ListNotaryInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNotaryInfosResponseBody(name='body'),
}

async function listNotaryInfosWithOptions(request: ListNotaryInfosRequest, runtime: Util.RuntimeOptions): ListNotaryInfosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizOrderNo)) {
    query['BizOrderNo'] = request.bizOrderNo;
  }
  if (!Util.isUnset(request.notaryType)) {
    query['NotaryType'] = request.notaryType;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNotaryInfos',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNotaryInfos(request: ListNotaryInfosRequest): ListNotaryInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNotaryInfosWithOptions(request, runtime);
}

model ListNotaryOrdersRequest {
  aliyunOrderId?: string(name='AliyunOrderId'),
  bizId?: string(name='BizId'),
  endOrderDate?: long(name='EndOrderDate'),
  notaryStatus?: int32(name='NotaryStatus'),
  notaryType?: int32(name='NotaryType'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  sortByType?: string(name='SortByType'),
  sortKeyType?: int32(name='SortKeyType'),
  startOrderDate?: long(name='StartOrderDate'),
}

model ListNotaryOrdersResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    notaryOrder?: [ 
    {
      aliyunOrderId?: string(name='AliyunOrderId'),
      applyPostStatus?: string(name='ApplyPostStatus'),
      bizId?: string(name='BizId'),
      gmtModified?: long(name='GmtModified'),
      notaryCertificate?: string(name='NotaryCertificate'),
      notaryOrderId?: long(name='NotaryOrderId'),
      notaryPlatformName?: string(name='NotaryPlatformName'),
      notaryStatus?: int32(name='NotaryStatus'),
      notaryType?: int32(name='NotaryType'),
      orderDate?: long(name='OrderDate'),
      orderPrice?: float(name='OrderPrice'),
      tmClassification?: string(name='TmClassification'),
      tmImage?: string(name='TmImage'),
      tmName?: string(name='TmName'),
      tmRegisterNo?: string(name='TmRegisterNo'),
    }
  ](name='NotaryOrder')
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model ListNotaryOrdersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNotaryOrdersResponseBody(name='body'),
}

async function listNotaryOrdersWithOptions(request: ListNotaryOrdersRequest, runtime: Util.RuntimeOptions): ListNotaryOrdersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunOrderId)) {
    query['AliyunOrderId'] = request.aliyunOrderId;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.endOrderDate)) {
    query['EndOrderDate'] = request.endOrderDate;
  }
  if (!Util.isUnset(request.notaryStatus)) {
    query['NotaryStatus'] = request.notaryStatus;
  }
  if (!Util.isUnset(request.notaryType)) {
    query['NotaryType'] = request.notaryType;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortByType)) {
    query['SortByType'] = request.sortByType;
  }
  if (!Util.isUnset(request.sortKeyType)) {
    query['SortKeyType'] = request.sortKeyType;
  }
  if (!Util.isUnset(request.startOrderDate)) {
    query['StartOrderDate'] = request.startOrderDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNotaryOrders',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNotaryOrders(request: ListNotaryOrdersRequest): ListNotaryOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNotaryOrdersWithOptions(request, runtime);
}

model ListTrademarkSbjKeyRequest {
  principalKey?: string(name='PrincipalKey'),
  principalName?: string(name='PrincipalName'),
}

model ListTrademarkSbjKeyResponseBody = {
  requestId?: string(name='RequestId'),
  tmSbjKeyInfo?: [ 
    {
      agentId?: string(name='AgentId'),
      agreeProt?: string(name='AgreeProt'),
      certInfo?: string(name='CertInfo'),
      clearData?: string(name='ClearData'),
      hashData?: string(name='HashData'),
      keyType?: int32(name='KeyType'),
      name?: string(name='Name'),
      pin?: string(name='Pin'),
      principalKey?: string(name='PrincipalKey'),
      principalName?: string(name='PrincipalName'),
      signCert?: string(name='SignCert'),
      signData?: string(name='SignData'),
      startValidDate?: string(name='StartValidDate'),
      submitSignData?: string(name='SubmitSignData'),
      typeCert?: string(name='TypeCert'),
      username?: string(name='Username'),
      validDate?: string(name='ValidDate'),
      tmurl?: string(name='tmurl'),
    }
  ](name='TmSbjKeyInfo'),
}

model ListTrademarkSbjKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTrademarkSbjKeyResponseBody(name='body'),
}

async function listTrademarkSbjKeyWithOptions(request: ListTrademarkSbjKeyRequest, runtime: Util.RuntimeOptions): ListTrademarkSbjKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.principalKey)) {
    query['PrincipalKey'] = request.principalKey;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTrademarkSbjKey',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTrademarkSbjKey(request: ListTrademarkSbjKeyRequest): ListTrademarkSbjKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTrademarkSbjKeyWithOptions(request, runtime);
}

model ModifySubmitTransferMaterailRequest {
  addr?: string(name='Addr'),
  assigneeProxy?: string(name='AssigneeProxy'),
  bizId?: string(name='BizId'),
  buyerBusinessLicense?: string(name='BuyerBusinessLicense'),
  buyerBusinessLicenseTranslation?: string(name='BuyerBusinessLicenseTranslation'),
  buyerIdCard?: string(name='BuyerIdCard'),
  cardNo?: string(name='CardNo'),
  cardType?: string(name='CardType'),
  complete?: boolean(name='Complete'),
  contactEmail?: string(name='ContactEmail'),
  contactMobile?: string(name='ContactMobile'),
  contactName?: string(name='ContactName'),
  name?: string(name='Name'),
  notarization?: string(name='Notarization'),
  note?: string(name='Note'),
  other?: map[string]any(name='Other'),
  registrationCert?: string(name='RegistrationCert'),
  sellerApply?: string(name='SellerApply'),
  sellerBusinessLicense?: string(name='SellerBusinessLicense'),
  sellerBusinessLicenseTranslation?: string(name='SellerBusinessLicenseTranslation'),
  sellerIdCard?: string(name='SellerIdCard'),
  sellerProxy?: string(name='SellerProxy'),
  tradeMaterialFullUpdate?: boolean(name='TradeMaterialFullUpdate'),
}

model ModifySubmitTransferMaterailShrinkRequest {
  addr?: string(name='Addr'),
  assigneeProxy?: string(name='AssigneeProxy'),
  bizId?: string(name='BizId'),
  buyerBusinessLicense?: string(name='BuyerBusinessLicense'),
  buyerBusinessLicenseTranslation?: string(name='BuyerBusinessLicenseTranslation'),
  buyerIdCard?: string(name='BuyerIdCard'),
  cardNo?: string(name='CardNo'),
  cardType?: string(name='CardType'),
  complete?: boolean(name='Complete'),
  contactEmail?: string(name='ContactEmail'),
  contactMobile?: string(name='ContactMobile'),
  contactName?: string(name='ContactName'),
  name?: string(name='Name'),
  notarization?: string(name='Notarization'),
  note?: string(name='Note'),
  otherShrink?: string(name='Other'),
  registrationCert?: string(name='RegistrationCert'),
  sellerApply?: string(name='SellerApply'),
  sellerBusinessLicense?: string(name='SellerBusinessLicense'),
  sellerBusinessLicenseTranslation?: string(name='SellerBusinessLicenseTranslation'),
  sellerIdCard?: string(name='SellerIdCard'),
  sellerProxy?: string(name='SellerProxy'),
  tradeMaterialFullUpdate?: boolean(name='TradeMaterialFullUpdate'),
}

model ModifySubmitTransferMaterailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifySubmitTransferMaterailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySubmitTransferMaterailResponseBody(name='body'),
}

async function modifySubmitTransferMaterailWithOptions(tmpReq: ModifySubmitTransferMaterailRequest, runtime: Util.RuntimeOptions): ModifySubmitTransferMaterailResponse {
  Util.validateModel(tmpReq);
  var request = new ModifySubmitTransferMaterailShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.other)) {
    request.otherShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.other, 'Other', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.assigneeProxy)) {
    query['AssigneeProxy'] = request.assigneeProxy;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.buyerBusinessLicenseTranslation)) {
    query['BuyerBusinessLicenseTranslation'] = request.buyerBusinessLicenseTranslation;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  if (!Util.isUnset(request.sellerBusinessLicenseTranslation)) {
    query['SellerBusinessLicenseTranslation'] = request.sellerBusinessLicenseTranslation;
  }
  if (!Util.isUnset(request.tradeMaterialFullUpdate)) {
    query['TradeMaterialFullUpdate'] = request.tradeMaterialFullUpdate;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.addr)) {
    body['Addr'] = request.addr;
  }
  if (!Util.isUnset(request.buyerBusinessLicense)) {
    body['BuyerBusinessLicense'] = request.buyerBusinessLicense;
  }
  if (!Util.isUnset(request.buyerIdCard)) {
    body['BuyerIdCard'] = request.buyerIdCard;
  }
  if (!Util.isUnset(request.cardNo)) {
    body['CardNo'] = request.cardNo;
  }
  if (!Util.isUnset(request.cardType)) {
    body['CardType'] = request.cardType;
  }
  if (!Util.isUnset(request.complete)) {
    body['Complete'] = request.complete;
  }
  if (!Util.isUnset(request.contactEmail)) {
    body['ContactEmail'] = request.contactEmail;
  }
  if (!Util.isUnset(request.contactMobile)) {
    body['ContactMobile'] = request.contactMobile;
  }
  if (!Util.isUnset(request.contactName)) {
    body['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.notarization)) {
    body['Notarization'] = request.notarization;
  }
  if (!Util.isUnset(request.otherShrink)) {
    body['Other'] = request.otherShrink;
  }
  if (!Util.isUnset(request.registrationCert)) {
    body['RegistrationCert'] = request.registrationCert;
  }
  if (!Util.isUnset(request.sellerApply)) {
    body['SellerApply'] = request.sellerApply;
  }
  if (!Util.isUnset(request.sellerBusinessLicense)) {
    body['SellerBusinessLicense'] = request.sellerBusinessLicense;
  }
  if (!Util.isUnset(request.sellerIdCard)) {
    body['SellerIdCard'] = request.sellerIdCard;
  }
  if (!Util.isUnset(request.sellerProxy)) {
    body['SellerProxy'] = request.sellerProxy;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifySubmitTransferMaterail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySubmitTransferMaterail(request: ModifySubmitTransferMaterailRequest): ModifySubmitTransferMaterailResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySubmitTransferMaterailWithOptions(request, runtime);
}

model OperateProduceRequest {
  bizId?: string(name='BizId'),
  bizType?: string(name='BizType'),
  extMap?: string(name='ExtMap'),
  operateType?: string(name='OperateType'),
}

model OperateProduceResponseBody = {
  requestId?: string(name='requestId'),
}

model OperateProduceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OperateProduceResponseBody(name='body'),
}

async function operateProduceWithOptions(request: OperateProduceRequest, runtime: Util.RuntimeOptions): OperateProduceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.extMap)) {
    query['ExtMap'] = request.extMap;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OperateProduce',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function operateProduce(request: OperateProduceRequest): OperateProduceResponse {
  var runtime = new Util.RuntimeOptions{};
  return operateProduceWithOptions(request, runtime);
}

model PartnerUpdateTrademarkNameRequest {
  aliyunKp?: string(name='AliyunKp'),
  bid?: string(name='Bid'),
  bizId?: string(name='BizId'),
  callerParentId?: long(name='CallerParentId'),
  callerType?: string(name='CallerType'),
  eventSceneType?: long(name='EventSceneType'),
  intentionBizId?: string(name='IntentionBizId'),
  tmComment?: string(name='TmComment'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  type?: int32(name='Type'),
}

model PartnerUpdateTrademarkNameResponseBody = {
  allowRetry?: boolean(name='AllowRetry'),
  appName?: string(name='AppName'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PartnerUpdateTrademarkNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PartnerUpdateTrademarkNameResponseBody(name='body'),
}

async function partnerUpdateTrademarkNameWithOptions(request: PartnerUpdateTrademarkNameRequest, runtime: Util.RuntimeOptions): PartnerUpdateTrademarkNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunKp)) {
    query['AliyunKp'] = request.aliyunKp;
  }
  if (!Util.isUnset(request.bid)) {
    query['Bid'] = request.bid;
  }
  if (!Util.isUnset(request.callerParentId)) {
    query['CallerParentId'] = request.callerParentId;
  }
  if (!Util.isUnset(request.callerType)) {
    query['CallerType'] = request.callerType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.eventSceneType)) {
    body['EventSceneType'] = request.eventSceneType;
  }
  if (!Util.isUnset(request.intentionBizId)) {
    body['IntentionBizId'] = request.intentionBizId;
  }
  if (!Util.isUnset(request.tmComment)) {
    body['TmComment'] = request.tmComment;
  }
  if (!Util.isUnset(request.tmIcon)) {
    body['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    body['TmName'] = request.tmName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PartnerUpdateTrademarkName',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function partnerUpdateTrademarkName(request: PartnerUpdateTrademarkNameRequest): PartnerUpdateTrademarkNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return partnerUpdateTrademarkNameWithOptions(request, runtime);
}

model QueryCommunicationLogsRequest {
  bizId?: string(name='BizId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  type?: int32(name='Type'),
}

model QueryCommunicationLogsResponseBody = {
  data?: {
    taskList?: [ 
    {
      bizId?: string(name='BizId'),
      createTime?: long(name='CreateTime'),
      note?: string(name='Note'),
      partnerCode?: string(name='PartnerCode'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='TaskList')
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryCommunicationLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryCommunicationLogsResponseBody(name='body'),
}

async function queryCommunicationLogsWithOptions(request: QueryCommunicationLogsRequest, runtime: Util.RuntimeOptions): QueryCommunicationLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryCommunicationLogs',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryCommunicationLogs(request: QueryCommunicationLogsRequest): QueryCommunicationLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCommunicationLogsWithOptions(request, runtime);
}

model QueryCredentialsInfoRequest {
  companyName?: string(name='CompanyName'),
  materialType?: string(name='MaterialType'),
  ossKey?: string(name='OssKey'),
}

model QueryCredentialsInfoResponseBody = {
  credentialsInfo?: {
    address?: string(name='Address'),
    cardNumber?: string(name='CardNumber'),
    companyName?: string(name='CompanyName'),
    personName?: string(name='PersonName'),
    province?: string(name='Province'),
  }(name='CredentialsInfo'),
  requestId?: string(name='RequestId'),
}

model QueryCredentialsInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryCredentialsInfoResponseBody(name='body'),
}

async function queryCredentialsInfoWithOptions(request: QueryCredentialsInfoRequest, runtime: Util.RuntimeOptions): QueryCredentialsInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.companyName)) {
    query['CompanyName'] = request.companyName;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.materialType)) {
    body['MaterialType'] = request.materialType;
  }
  if (!Util.isUnset(request.ossKey)) {
    body['OssKey'] = request.ossKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryCredentialsInfo',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryCredentialsInfo(request: QueryCredentialsInfoRequest): QueryCredentialsInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCredentialsInfoWithOptions(request, runtime);
}

model QueryExtensionAttributeRequest {
  attributeKey?: string(name='AttributeKey'),
  bizId?: string(name='BizId'),
}

model QueryExtensionAttributeResponseBody = {
  attributeValue?: string(name='AttributeValue'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryExtensionAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryExtensionAttributeResponseBody(name='body'),
}

async function queryExtensionAttributeWithOptions(request: QueryExtensionAttributeRequest, runtime: Util.RuntimeOptions): QueryExtensionAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.attributeKey)) {
    query['AttributeKey'] = request.attributeKey;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryExtensionAttribute',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryExtensionAttribute(request: QueryExtensionAttributeRequest): QueryExtensionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryExtensionAttributeWithOptions(request, runtime);
}

model QueryIntentionDetailRequest {
  bizId?: string(name='BizId'),
}

model QueryIntentionDetailResponseBody = {
  bizId?: string(name='BizId'),
  classification?: string(name='Classification'),
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  mobile?: string(name='Mobile'),
  partnerMobile?: string(name='PartnerMobile'),
  registerNumber?: string(name='RegisterNumber'),
  relationBizId?: string(name='RelationBizId'),
  requestId?: string(name='RequestId'),
  status?: int32(name='Status'),
  type?: int32(name='Type'),
  updateTime?: long(name='UpdateTime'),
  userId?: string(name='UserId'),
  userName?: string(name='UserName'),
}

model QueryIntentionDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryIntentionDetailResponseBody(name='body'),
}

async function queryIntentionDetailWithOptions(request: QueryIntentionDetailRequest, runtime: Util.RuntimeOptions): QueryIntentionDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryIntentionDetail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryIntentionDetail(request: QueryIntentionDetailRequest): QueryIntentionDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIntentionDetailWithOptions(request, runtime);
}

model QueryIntentionListRequest {
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  sortFiled?: string(name='SortFiled'),
  sortOrder?: string(name='SortOrder'),
  status?: int32(name='Status'),
  type?: int32(name='Type'),
}

model QueryIntentionListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    intention?: [ 
    {
      bizId?: string(name='BizId'),
      classification?: string(name='Classification'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      registerNumber?: string(name='RegisterNumber'),
      status?: int32(name='Status'),
      type?: int32(name='Type'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='Intention')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryIntentionListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryIntentionListResponseBody(name='body'),
}

async function queryIntentionListWithOptions(request: QueryIntentionListRequest, runtime: Util.RuntimeOptions): QueryIntentionListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortFiled)) {
    query['SortFiled'] = request.sortFiled;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryIntentionList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryIntentionList(request: QueryIntentionListRequest): QueryIntentionListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIntentionListWithOptions(request, runtime);
}

model QueryIntentionOwnerRequest {
  bizId?: string(name='BizId'),
}

model QueryIntentionOwnerResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  module?: {
    ownerId?: float(name='OwnerId'),
    ownerName?: string(name='OwnerName'),
  }(name='Module'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryIntentionOwnerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryIntentionOwnerResponseBody(name='body'),
}

async function queryIntentionOwnerWithOptions(request: QueryIntentionOwnerRequest, runtime: Util.RuntimeOptions): QueryIntentionOwnerResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryIntentionOwner',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryIntentionOwner(request: QueryIntentionOwnerRequest): QueryIntentionOwnerResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIntentionOwnerWithOptions(request, runtime);
}

model QueryIntentionPriceRequest {
  channel?: string(name='Channel'),
  intentionBizId?: string(name='IntentionBizId'),
}

model QueryIntentionPriceResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    tmProduces?: [ 
    {
      bizId?: string(name='BizId'),
      createTime?: long(name='CreateTime'),
      firstClassification?: {
        classificationCode?: string(name='ClassificationCode'),
        classificationName?: string(name='ClassificationName'),
      }(name='FirstClassification'),
      loaUrl?: string(name='LoaUrl'),
      materialId?: string(name='MaterialId'),
      materialName?: string(name='MaterialName'),
      note?: string(name='Note'),
      orderPrice?: float(name='OrderPrice'),
      servicePrice?: float(name='ServicePrice'),
      status?: int32(name='Status'),
      supplementId?: long(name='SupplementId'),
      supplementStatus?: int32(name='SupplementStatus'),
      thirdClassification?: {
        thirdClassifications?: [ 
        {
          classificationCode?: string(name='ClassificationCode'),
          classificationName?: string(name='ClassificationName'),
        }
      ](name='ThirdClassifications')
      }(name='ThirdClassification'),
      tmIcon?: string(name='TmIcon'),
      tmName?: string(name='TmName'),
      tmNumber?: string(name='TmNumber'),
      totalPrice?: float(name='TotalPrice'),
      type?: int32(name='Type'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='TmProduces')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryIntentionPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryIntentionPriceResponseBody(name='body'),
}

async function queryIntentionPriceWithOptions(request: QueryIntentionPriceRequest, runtime: Util.RuntimeOptions): QueryIntentionPriceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.intentionBizId)) {
    query['IntentionBizId'] = request.intentionBizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryIntentionPrice',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryIntentionPrice(request: QueryIntentionPriceRequest): QueryIntentionPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIntentionPriceWithOptions(request, runtime);
}

model QueryMaterialRequest {
  id?: long(name='Id', example='1'),
  queryUnconfirmedInfo?: boolean(name='QueryUnconfirmedInfo'),
}

model QueryMaterialResponseBody = {
  address?: string(name='Address'),
  businessLicenceUrl?: string(name='BusinessLicenceUrl', example='https://trade-mark-user-upload.oss-cn-beijing.aliyuncs.com/1219541161213057/passport/sdixdw73pl.jpg'),
  cardNumber?: string(name='CardNumber', example='121212'),
  city?: string(name='City'),
  contactAddress?: string(name='ContactAddress'),
  contactCity?: string(name='ContactCity'),
  contactCounty?: string(name='ContactCounty'),
  contactDistrict?: string(name='ContactDistrict'),
  contactEmail?: string(name='ContactEmail', example='aliyun@aliyun.com'),
  contactName?: string(name='ContactName', example='aliyun'),
  contactNumber?: string(name='ContactNumber', example='010-1231234'),
  contactProvince?: string(name='ContactProvince'),
  contactZipcode?: string(name='ContactZipcode', example='123456'),
  country?: string(name='Country'),
  EAddress?: string(name='EAddress', example='beijing'),
  EName?: string(name='EName', example='aliyun'),
  evidenceCatalogPath?: string(name='EvidenceCatalogPath'),
  evidenceOfservicePath?: string(name='EvidenceOfservicePath'),
  evidencePath?: string(name='EvidencePath'),
  expirationDate?: long(name='ExpirationDate', example='1545804527194'),
  factandreasonPdfPath?: string(name='FactandreasonPdfPath'),
  fgsqPath?: string(name='FgsqPath'),
  fileBgPath?: string(name='FileBgPath'),
  fileFsSqPath?: string(name='FileFsSqPath'),
  fileGtPath?: string(name='FileGtPath'),
  fileYgPath?: string(name='FileYgPath'),
  id?: long(name='Id', description='id', example='1'),
  idCardName?: string(name='IdCardName'),
  idCardNumber?: string(name='IdCardNumber'),
  idCardUrl?: string(name='IdCardUrl', example='https://trade-mark-user-upload.oss-cn-beijing.aliyuncs.com/1219541161213057/idcard.jpg'),
  legalNoticeKey?: string(name='LegalNoticeKey'),
  legalNoticeUrl?: string(name='LegalNoticeUrl', example='https://trade-mark-user-upload.oss-cn-beijing.aliyuncs.com/1219541161213057/legalnotice.jpg'),
  loaStatus?: int32(name='LoaStatus', example='1'),
  loaUrl?: string(name='LoaUrl', example='https://trade-mark-user-upload.oss-cn-beijing.aliyuncs.com/1219541161213057/loaurl.jpg'),
  materialVersion?: string(name='MaterialVersion'),
  name?: string(name='Name'),
  note?: string(name='Note'),
  passportUrl?: string(name='PassportUrl', example='https://trade-mark-user-upload.oss-cn-beijing.aliyuncs.com/1219541161213057/passport/sdixdw73pl.jpg'),
  personalType?: long(name='PersonalType'),
  principalDescription?: string(name='PrincipalDescription'),
  principalName?: int32(name='PrincipalName'),
  province?: string(name='Province'),
  reason?: string(name='Reason'),
  region?: int32(name='Region', example='1'),
  requestId?: string(name='RequestId'),
  reviewAdditionalFiles?: {
    reviewAdditionalFile?: [ string ](name='ReviewAdditionalFile')
  }(name='ReviewAdditionalFiles'),
  reviewApplicationFile?: string(name='ReviewApplicationFile'),
  status?: int32(name='Status', example='1'),
  supplementEvidenceCatalogFile?: string(name='SupplementEvidenceCatalogFile'),
  supplementEvidenceMaterialFile?: string(name='SupplementEvidenceMaterialFile'),
  supplementReasonFile?: string(name='SupplementReasonFile'),
  systemVersion?: string(name='SystemVersion'),
  town?: string(name='Town'),
  type?: int32(name='Type', example='1'),
  validDate?: long(name='ValidDate'),
}

model QueryMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMaterialResponseBody(name='body'),
}

async function queryMaterialWithOptions(request: QueryMaterialRequest, runtime: Util.RuntimeOptions): QueryMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.queryUnconfirmedInfo)) {
    query['QueryUnconfirmedInfo'] = request.queryUnconfirmedInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMaterial',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMaterial(request: QueryMaterialRequest): QueryMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMaterialWithOptions(request, runtime);
}

model QueryMaterialListRequest {
  cardNumber?: string(name='CardNumber', example='1234'),
  materialId?: long(name='MaterialId'),
  materialVersion?: string(name='MaterialVersion'),
  name?: string(name='Name'),
  pageNum?: int32(name='PageNum', example='1'),
  pageSize?: int32(name='PageSize', example='15'),
  principalName?: int32(name='PrincipalName'),
  region?: int32(name='Region', example='1'),
  status?: int32(name='Status', example='2'),
  systemVersion?: string(name='SystemVersion', example='V1'),
  type?: int32(name='Type', example='1'),
}

model QueryMaterialListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum', example='1'),
  data?: {
    trademark?: [ 
    {
      cardNumber?: string(name='CardNumber', example='12121212'),
      contactName?: string(name='ContactName', example='1212'),
      id?: long(name='Id', example='12'),
      loaKey?: string(name='LoaKey', example='test.key'),
      loaStatus?: int32(name='LoaStatus', example='1'),
      materialVersion?: string(name='MaterialVersion'),
      name?: string(name='Name'),
      principalDescription?: string(name='PrincipalDescription'),
      principalName?: int32(name='PrincipalName'),
      reason?: string(name='Reason'),
      region?: int32(name='Region', example='1'),
      status?: int32(name='Status', example='2'),
      systemVersion?: string(name='SystemVersion'),
      type?: int32(name='Type', example='1'),
      validDate?: long(name='ValidDate'),
    }
  ](name='Trademark')
  }(name='Data'),
  pageSize?: int32(name='PageSize', example='15'),
  requestId?: string(name='RequestId', example='11212'),
  totalItemNum?: int32(name='TotalItemNum', example='32'),
  totalPageNum?: int32(name='TotalPageNum', example='3'),
}

model QueryMaterialListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMaterialListResponseBody(name='body'),
}

async function queryMaterialListWithOptions(request: QueryMaterialListRequest, runtime: Util.RuntimeOptions): QueryMaterialListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cardNumber)) {
    query['CardNumber'] = request.cardNumber;
  }
  if (!Util.isUnset(request.materialId)) {
    query['MaterialId'] = request.materialId;
  }
  if (!Util.isUnset(request.materialVersion)) {
    query['MaterialVersion'] = request.materialVersion;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMaterialList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMaterialList(request: QueryMaterialListRequest): QueryMaterialListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMaterialListWithOptions(request, runtime);
}

model QueryMonitorKeywordsRequest {
  keywords?: [ string ](name='Keywords'),
  ruleType?: int32(name='RuleType'),
}

model QueryMonitorKeywordsResponseBody = {
  data?: {
    keywords?: [ string ](name='Keywords')
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryMonitorKeywordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMonitorKeywordsResponseBody(name='body'),
}

async function queryMonitorKeywordsWithOptions(request: QueryMonitorKeywordsRequest, runtime: Util.RuntimeOptions): QueryMonitorKeywordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keywords)) {
    query['Keywords'] = request.keywords;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMonitorKeywords',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMonitorKeywords(request: QueryMonitorKeywordsRequest): QueryMonitorKeywordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMonitorKeywordsWithOptions(request, runtime);
}

model QueryOfficialFileCustomListRequest {
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model QueryOfficialFileCustomListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    customList?: [ 
    {
      createTime?: long(name='CreateTime'),
      downloadUrl?: string(name='DownloadUrl'),
      endAcceptTime?: long(name='EndAcceptTime'),
      expireTime?: long(name='ExpireTime'),
      remark?: string(name='Remark'),
      startAcceptTime?: long(name='StartAcceptTime'),
      status?: string(name='Status'),
    }
  ](name='CustomList')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryOfficialFileCustomListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryOfficialFileCustomListResponseBody(name='body'),
}

async function queryOfficialFileCustomListWithOptions(request: QueryOfficialFileCustomListRequest, runtime: Util.RuntimeOptions): QueryOfficialFileCustomListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOfficialFileCustomList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOfficialFileCustomList(request: QueryOfficialFileCustomListRequest): QueryOfficialFileCustomListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOfficialFileCustomListWithOptions(request, runtime);
}

model QueryOrderLogisticsListRequest {
  fileType?: string(name='FileType'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
  produceOrderId?: string(name='ProduceOrderId'),
  registerNumber?: string(name='RegisterNumber'),
}

model QueryOrderLogisticsListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: [ 
    {
      bizId?: string(name='BizId'),
      fileIdentifier?: string(name='FileIdentifier'),
      fileType?: string(name='FileType'),
      logisticsNo?: string(name='LogisticsNo'),
      produceOrderId?: string(name='ProduceOrderId'),
      tmIcon?: string(name='TmIcon'),
      tmName?: string(name='TmName'),
      tmNumber?: string(name='TmNumber'),
    }
  ](name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryOrderLogisticsListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryOrderLogisticsListResponseBody(name='body'),
}

async function queryOrderLogisticsListWithOptions(request: QueryOrderLogisticsListRequest, runtime: Util.RuntimeOptions): QueryOrderLogisticsListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fileType)) {
    body['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.produceOrderId)) {
    body['ProduceOrderId'] = request.produceOrderId;
  }
  if (!Util.isUnset(request.registerNumber)) {
    body['RegisterNumber'] = request.registerNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryOrderLogisticsList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOrderLogisticsList(request: QueryOrderLogisticsListRequest): QueryOrderLogisticsListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOrderLogisticsListWithOptions(request, runtime);
}

model QueryOssResourcesRequest {
  bizId?: string(name='BizId'),
}

model QueryOssResourcesResponseBody = {
  data?: {
    taskList?: [ 
    {
      bizId?: string(name='BizId'),
      createTime?: long(name='CreateTime'),
      name?: string(name='Name'),
      ossUrl?: string(name='OssUrl'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='TaskList')
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryOssResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryOssResourcesResponseBody(name='body'),
}

async function queryOssResourcesWithOptions(request: QueryOssResourcesRequest, runtime: Util.RuntimeOptions): QueryOssResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOssResources',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOssResources(request: QueryOssResourcesRequest): QueryOssResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOssResourcesWithOptions(request, runtime);
}

model QueryProduceDetailRequest {
  applyNo?: string(name='ApplyNo'),
  bizId?: string(name='BizId'),
  orderId?: string(name='OrderId'),
}

model QueryProduceDetailResponseBody = {
  acceptUrl?: string(name='AcceptUrl'),
  agreementId?: string(name='AgreementId'),
  bizId?: string(name='BizId'),
  cnInfoUrl?: string(name='CnInfoUrl'),
  extendInfo?: map[string]any(name='ExtendInfo'),
  flags?: {
    flags?: [ string ](name='Flags')
  }(name='Flags'),
  grayIconUrl?: string(name='GrayIconUrl'),
  issueDate?: string(name='IssueDate'),
  leafCodes?: {
    leafCodes?: [ 
    {
      code?: string(name='Code'),
      name?: string(name='Name'),
    }
  ](name='LeafCodes')
  }(name='LeafCodes'),
  loaUrl?: string(name='LoaUrl'),
  materialDetail?: {
    address?: string(name='Address'),
    businessLicenceUrl?: string(name='BusinessLicenceUrl'),
    cardNumber?: string(name='CardNumber'),
    city?: string(name='City'),
    contactAddress?: string(name='ContactAddress'),
    contactEmail?: string(name='ContactEmail'),
    contactName?: string(name='ContactName'),
    contactNumber?: string(name='ContactNumber'),
    contactZipcode?: string(name='ContactZipcode'),
    country?: string(name='Country'),
    EAddress?: string(name='EAddress'),
    EName?: string(name='EName'),
    expirationDate?: string(name='ExpirationDate'),
    idCardUrl?: string(name='IdCardUrl'),
    loaUrl?: string(name='LoaUrl'),
    name?: string(name='Name'),
    passportUrl?: string(name='PassportUrl'),
    province?: string(name='Province'),
    region?: int32(name='Region'),
    status?: int32(name='Status'),
    town?: string(name='Town'),
    type?: int32(name='Type'),
  }(name='MaterialDetail'),
  note?: string(name='Note'),
  orderId?: string(name='OrderId'),
  principalName?: int32(name='PrincipalName'),
  requestId?: string(name='RequestId'),
  rootCode?: {
    code?: string(name='Code'),
    name?: string(name='Name'),
  }(name='RootCode'),
  status?: int32(name='Status'),
  submitCount?: int32(name='SubmitCount'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  tmNameType?: int32(name='TmNameType'),
  tmNumber?: string(name='TmNumber'),
  tmOrderId?: string(name='TmOrderId'),
  type?: int32(name='Type'),
}

model QueryProduceDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryProduceDetailResponseBody(name='body'),
}

async function queryProduceDetailWithOptions(request: QueryProduceDetailRequest, runtime: Util.RuntimeOptions): QueryProduceDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applyNo)) {
    query['ApplyNo'] = request.applyNo;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryProduceDetail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryProduceDetail(request: QueryProduceDetailRequest): QueryProduceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryProduceDetailWithOptions(request, runtime);
}

model QueryProduceListRequest {
  bizId?: string(name='BizId'),
  createTimeLeft?: long(name='CreateTimeLeft'),
  createTimeRight?: long(name='CreateTimeRight'),
  materialName?: string(name='MaterialName'),
  orderId?: string(name='OrderId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  status?: int32(name='Status'),
  tmName?: string(name='TmName'),
  tmNumber?: string(name='TmNumber'),
  type?: int32(name='Type'),
  userId?: string(name='UserId'),
}

model QueryProduceListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    tmProduces?: [ 
    {
      agreementId?: string(name='AgreementId'),
      bizId?: string(name='BizId'),
      classification?: {
        classificationCode?: string(name='ClassificationCode'),
        classificationName?: string(name='ClassificationName'),
      }(name='Classification'),
      createTime?: long(name='CreateTime'),
      loaUrl?: string(name='LoaUrl'),
      materialName?: string(name='MaterialName'),
      note?: string(name='Note'),
      orderId?: string(name='OrderId'),
      orderPrice?: float(name='OrderPrice'),
      principalName?: int32(name='PrincipalName'),
      receiptUrl?: string(name='ReceiptUrl'),
      status?: int32(name='Status'),
      submitCount?: int32(name='SubmitCount'),
      tmIcon?: string(name='TmIcon'),
      tmName?: string(name='TmName'),
      tmNumber?: string(name='TmNumber'),
      type?: int32(name='Type'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='TmProduces')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryProduceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryProduceListResponseBody(name='body'),
}

async function queryProduceListWithOptions(request: QueryProduceListRequest, runtime: Util.RuntimeOptions): QueryProduceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.createTimeLeft)) {
    query['CreateTimeLeft'] = request.createTimeLeft;
  }
  if (!Util.isUnset(request.createTimeRight)) {
    query['CreateTimeRight'] = request.createTimeRight;
  }
  if (!Util.isUnset(request.materialName)) {
    query['MaterialName'] = request.materialName;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNumber)) {
    query['TmNumber'] = request.tmNumber;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryProduceList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryProduceList(request: QueryProduceListRequest): QueryProduceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryProduceListWithOptions(request, runtime);
}

model QueryQrCodeUploadStatusRequest {
  fieldKey?: string(name='FieldKey'),
  ossKey?: string(name='OssKey'),
  uuid?: string(name='Uuid'),
}

model QueryQrCodeUploadStatusResponseBody = {
  ossKey?: string(name='OssKey'),
  ossUrl?: string(name='OssUrl'),
  requestId?: string(name='RequestId'),
  status?: int32(name='Status'),
  success?: boolean(name='Success'),
}

model QueryQrCodeUploadStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryQrCodeUploadStatusResponseBody(name='body'),
}

async function queryQrCodeUploadStatusWithOptions(request: QueryQrCodeUploadStatusRequest, runtime: Util.RuntimeOptions): QueryQrCodeUploadStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fieldKey)) {
    query['FieldKey'] = request.fieldKey;
  }
  if (!Util.isUnset(request.ossKey)) {
    query['OssKey'] = request.ossKey;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryQrCodeUploadStatus',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryQrCodeUploadStatus(request: QueryQrCodeUploadStatusRequest): QueryQrCodeUploadStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryQrCodeUploadStatusWithOptions(request, runtime);
}

model QuerySbjRuleRequest {
  bizType?: string(name='BizType'),
  ruleId?: string(name='RuleId'),
}

model QuerySbjRuleResponseBody = {
  bizType?: string(name='BizType'),
  requestId?: string(name='RequestId'),
  ruleId?: string(name='RuleId'),
  sbjRuleList?: {
    sbjRuleItem?: [ 
    {
      defaultValue?: string(name='DefaultValue'),
      espExtFieldName?: string(name='EspExtFieldName'),
      fieldName?: string(name='FieldName'),
      fileType?: string(name='FileType'),
      frontendOptions?: {
        frontendOption?: [ 
        {
          title?: string(name='title'),
          value?: string(name='value'),
        }
      ](name='FrontendOption')
      }(name='FrontendOptions'),
      frontendType?: string(name='FrontendType'),
      requiredExpression?: string(name='RequiredExpression'),
      sbjFieldId?: string(name='SbjFieldId'),
      showExpression?: string(name='ShowExpression'),
      trademarkServiceExpression?: string(name='TrademarkServiceExpression'),
      validateRegularExpression?: string(name='ValidateRegularExpression'),
    }
  ](name='SbjRuleItem')
  }(name='SbjRuleList'),
}

model QuerySbjRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySbjRuleResponseBody(name='body'),
}

async function querySbjRuleWithOptions(request: QuerySbjRuleRequest, runtime: Util.RuntimeOptions): QuerySbjRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySbjRule',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySbjRule(request: QuerySbjRuleRequest): QuerySbjRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySbjRuleWithOptions(request, runtime);
}

model QuerySupplementDetailRequest {
  id?: long(name='Id'),
}

model QuerySupplementDetailResponseBody = {
  acceptDeadTime?: long(name='AcceptDeadTime'),
  acceptTime?: long(name='AcceptTime'),
  content?: string(name='Content'),
  fileName?: string(name='FileName'),
  fileTemplateUrls?: {
    fileTemplateUrls?: [ string ](name='FileTemplateUrls')
  }(name='FileTemplateUrls'),
  id?: long(name='Id'),
  operateTime?: long(name='OperateTime'),
  reason?: string(name='Reason'),
  requestId?: string(name='RequestId'),
  sbjDeadTime?: long(name='SbjDeadTime'),
  sendTime?: long(name='SendTime'),
  serialNumber?: string(name='SerialNumber'),
  status?: int32(name='Status'),
  tmNumber?: string(name='TmNumber'),
  type?: int32(name='Type'),
  uploadFileTemplateUrl?: string(name='UploadFileTemplateUrl'),
}

model QuerySupplementDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySupplementDetailResponseBody(name='body'),
}

async function querySupplementDetailWithOptions(request: QuerySupplementDetailRequest, runtime: Util.RuntimeOptions): QuerySupplementDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySupplementDetail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySupplementDetail(request: QuerySupplementDetailRequest): QuerySupplementDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySupplementDetailWithOptions(request, runtime);
}

model QueryTaskListRequest {
  bizType?: string(name='BizType'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model QueryTaskListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    taskList?: [ 
    {
      completeTime?: long(name='CompleteTime'),
      createTime?: long(name='CreateTime'),
      errMsg?: string(name='ErrMsg'),
      fileName?: string(name='FileName'),
      result?: string(name='Result'),
      taskStatus?: string(name='TaskStatus'),
      taskType?: string(name='TaskType'),
    }
  ](name='TaskList')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTaskListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTaskListResponseBody(name='body'),
}

async function queryTaskListWithOptions(request: QueryTaskListRequest, runtime: Util.RuntimeOptions): QueryTaskListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTaskList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTaskList(request: QueryTaskListRequest): QueryTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskListWithOptions(request, runtime);
}

model QueryTmCollectionPageListRequest {
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model QueryTmCollectionPageListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    trademark?: [ 
    {
      classification?: string(name='Classification'),
      collected?: boolean(name='Collected'),
      collectionContent?: string(name='CollectionContent'),
      id?: long(name='Id'),
      itemId?: string(name='ItemId'),
      tmName?: string(name='TmName'),
    }
  ](name='Trademark')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTmCollectionPageListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTmCollectionPageListResponseBody(name='body'),
}

async function queryTmCollectionPageListWithOptions(request: QueryTmCollectionPageListRequest, runtime: Util.RuntimeOptions): QueryTmCollectionPageListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTmCollectionPageList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTmCollectionPageList(request: QueryTmCollectionPageListRequest): QueryTmCollectionPageListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTmCollectionPageListWithOptions(request, runtime);
}

model QueryTmSbjProduceRequest {
  highPriorityBizTypeStr?: string(name='HighPriorityBizTypeStr'),
  highPriorityMaterialNameStr?: string(name='HighPriorityMaterialNameStr'),
  highPriorityOrderIdStr?: string(name='HighPriorityOrderIdStr'),
  highPriorityUserIdStr?: string(name='HighPriorityUserIdStr'),
  principalKey?: string(name='PrincipalKey'),
  principalName?: string(name='PrincipalName'),
  producerType?: string(name='ProducerType'),
  queryOrderPageSize?: long(name='QueryOrderPageSize'),
}

model QueryTmSbjProduceResponseBody = {
  moudle?: {
    tmSbjProduceList?: [ 
    {
      bitFlag?: long(name='BitFlag'),
      bizId?: string(name='BizId'),
      classificationCode?: string(name='ClassificationCode'),
      deleteFlag?: string(name='DeleteFlag'),
      env?: string(name='Env'),
      extend?: {
        bid?: long(name='Bid'),
        blackIcon?: boolean(name='BlackIcon'),
        loaOssKey?: string(name='LoaOssKey'),
        logoGoodsId?: string(name='LogoGoodsId'),
        materialId?: string(name='MaterialId'),
        submitCount?: long(name='SubmitCount'),
        tmNametype?: long(name='TmNametype'),
      }(name='Extend'),
      loaId?: long(name='LoaId'),
      mainOrderId?: string(name='MainOrderId'),
      materialId?: long(name='MaterialId'),
      materialName?: string(name='MaterialName'),
      orderId?: string(name='OrderId'),
      orderPrice?: float(name='OrderPrice'),
      principalKey?: string(name='PrincipalKey'),
      principalName?: string(name='PrincipalName'),
      productType?: string(name='ProductType'),
      riskSource?: string(name='RiskSource'),
      status?: string(name='Status'),
      submitAuditTime?: long(name='SubmitAuditTime'),
      submitStatus?: string(name='SubmitStatus'),
      submitTime?: long(name='SubmitTime'),
      submitTimes?: long(name='SubmitTimes'),
      tmCode?: string(name='TmCode'),
      tmIcon?: string(name='TmIcon'),
      tmName?: string(name='TmName'),
      type?: string(name='Type'),
      userId?: string(name='UserId'),
    }
  ](name='TmSbjProduceList')
  }(name='Moudle'),
  requestId?: string(name='RequestId'),
}

model QueryTmSbjProduceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTmSbjProduceResponseBody(name='body'),
}

async function queryTmSbjProduceWithOptions(request: QueryTmSbjProduceRequest, runtime: Util.RuntimeOptions): QueryTmSbjProduceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.highPriorityBizTypeStr)) {
    query['HighPriorityBizTypeStr'] = request.highPriorityBizTypeStr;
  }
  if (!Util.isUnset(request.highPriorityMaterialNameStr)) {
    query['HighPriorityMaterialNameStr'] = request.highPriorityMaterialNameStr;
  }
  if (!Util.isUnset(request.highPriorityOrderIdStr)) {
    query['HighPriorityOrderIdStr'] = request.highPriorityOrderIdStr;
  }
  if (!Util.isUnset(request.highPriorityUserIdStr)) {
    query['HighPriorityUserIdStr'] = request.highPriorityUserIdStr;
  }
  if (!Util.isUnset(request.principalKey)) {
    query['PrincipalKey'] = request.principalKey;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  if (!Util.isUnset(request.producerType)) {
    query['ProducerType'] = request.producerType;
  }
  if (!Util.isUnset(request.queryOrderPageSize)) {
    query['QueryOrderPageSize'] = request.queryOrderPageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTmSbjProduce',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTmSbjProduce(request: QueryTmSbjProduceRequest): QueryTmSbjProduceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTmSbjProduceWithOptions(request, runtime);
}

model QueryTmSbjProduceDetailRequest {
  bizId?: string(name='BizId'),
  orderId?: string(name='OrderId'),
}

model QueryTmSbjProduceDetailResponseBody = {
  acceptUrl?: string(name='AcceptUrl'),
  bizId?: string(name='BizId'),
  cnInfoUrl?: string(name='CnInfoUrl'),
  extendInfo?: map[string]any(name='ExtendInfo'),
  flags?: {
    flags?: [ string ](name='Flags')
  }(name='Flags'),
  grayIconUrl?: string(name='GrayIconUrl'),
  issueDate?: string(name='IssueDate'),
  leafCodes?: {
    leafCodes?: [ 
    {
      code?: string(name='Code'),
      name?: string(name='Name'),
    }
  ](name='LeafCodes')
  }(name='LeafCodes'),
  loaUrl?: string(name='LoaUrl'),
  materialDetail?: {
    address?: string(name='Address'),
    businessLicenceUrl?: string(name='BusinessLicenceUrl'),
    cardNumber?: string(name='CardNumber'),
    city?: string(name='City'),
    contactAddress?: string(name='ContactAddress'),
    contactEmail?: string(name='ContactEmail'),
    contactName?: string(name='ContactName'),
    contactNumber?: string(name='ContactNumber'),
    contactProvince?: string(name='ContactProvince'),
    contactZipcode?: string(name='ContactZipcode'),
    country?: string(name='Country'),
    detailedContactAddress?: string(name='DetailedContactAddress'),
    EAddress?: string(name='EAddress'),
    EName?: string(name='EName'),
    expirationDate?: string(name='ExpirationDate'),
    idCardNumber?: string(name='IdCardNumber'),
    idCardUrl?: string(name='IdCardUrl'),
    loaUrl?: string(name='LoaUrl'),
    name?: string(name='Name'),
    passportUrl?: string(name='PassportUrl'),
    personalType?: int32(name='PersonalType'),
    province?: string(name='Province'),
    region?: int32(name='Region'),
    status?: int32(name='Status'),
    town?: string(name='Town'),
    type?: int32(name='Type'),
  }(name='MaterialDetail'),
  materialName?: string(name='MaterialName'),
  note?: string(name='Note'),
  orderId?: string(name='OrderId'),
  principalName?: int32(name='PrincipalName'),
  requestId?: string(name='RequestId'),
  rootCode?: {
    code?: string(name='Code'),
    name?: string(name='Name'),
  }(name='RootCode'),
  status?: int32(name='Status'),
  submitCount?: int32(name='SubmitCount'),
  submitStatus?: string(name='SubmitStatus'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  tmNameType?: int32(name='TmNameType'),
  tmNumber?: string(name='TmNumber'),
  tmOrderId?: string(name='TmOrderId'),
  type?: int32(name='Type'),
}

model QueryTmSbjProduceDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTmSbjProduceDetailResponseBody(name='body'),
}

async function queryTmSbjProduceDetailWithOptions(request: QueryTmSbjProduceDetailRequest, runtime: Util.RuntimeOptions): QueryTmSbjProduceDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTmSbjProduceDetail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTmSbjProduceDetail(request: QueryTmSbjProduceDetailRequest): QueryTmSbjProduceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTmSbjProduceDetailWithOptions(request, runtime);
}

model QueryTradeIntentionUserListRequest {
  begin?: long(name='Begin'),
  bizId?: string(name='BizId'),
  end?: long(name='End'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  status?: int32(name='Status'),
  type?: int32(name='Type'),
}

model QueryTradeIntentionUserListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    trademark?: [ 
    {
      bizId?: string(name='BizId'),
      classification?: string(name='Classification'),
      description?: string(name='Description'),
      documentDate?: string(name='DocumentDate'),
      documentName?: string(name='DocumentName'),
      documentUrl?: string(name='DocumentUrl'),
      grade?: int32(name='Grade'),
      mobile?: string(name='Mobile'),
      registerNumber?: string(name='RegisterNumber'),
      status?: int32(name='Status'),
      type?: int32(name='Type'),
      userName?: string(name='UserName'),
    }
  ](name='Trademark')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTradeIntentionUserListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTradeIntentionUserListResponseBody(name='body'),
}

async function queryTradeIntentionUserListWithOptions(request: QueryTradeIntentionUserListRequest, runtime: Util.RuntimeOptions): QueryTradeIntentionUserListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.begin)) {
    query['Begin'] = request.begin;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.end)) {
    query['End'] = request.end;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTradeIntentionUserList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTradeIntentionUserList(request: QueryTradeIntentionUserListRequest): QueryTradeIntentionUserListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeIntentionUserListWithOptions(request, runtime);
}

model QueryTradeMarkApplicationDetailRequest {
  bizId?: string(name='BizId'),
}

model QueryTradeMarkApplicationDetailResponseBody = {
  acceptUrl?: string(name='AcceptUrl'),
  adminUploads?: {
    licensePicUrl?: string(name='LicensePicUrl'),
    loaPicUrl?: string(name='LoaPicUrl'),
  }(name='AdminUploads'),
  bizId?: string(name='BizId'),
  createTime?: long(name='CreateTime'),
  extendInfo?: map[string]any(name='ExtendInfo'),
  firstClassification?: {
    code?: string(name='Code'),
    name?: string(name='Name'),
  }(name='FirstClassification'),
  flags?: {
    flag?: [ int32 ](name='Flag')
  }(name='Flags'),
  grayIconUrl?: string(name='GrayIconUrl'),
  judgeResultUrl?: {
    judgeResultUrl?: [ string ](name='JudgeResultUrl')
  }(name='JudgeResultUrl'),
  legalNoticeUrl?: string(name='LegalNoticeUrl'),
  loaUrl?: string(name='LoaUrl'),
  logisticsCertificateUrl?: string(name='LogisticsCertificateUrl'),
  logisticsNo?: string(name='LogisticsNo'),
  materialDetail?: {
    address?: string(name='Address'),
    businessLicenceUrl?: string(name='BusinessLicenceUrl'),
    cardNumber?: string(name='CardNumber'),
    city?: string(name='City'),
    contactAddress?: string(name='ContactAddress'),
    contactCity?: string(name='ContactCity'),
    contactDistrict?: string(name='ContactDistrict'),
    contactEmail?: string(name='ContactEmail'),
    contactName?: string(name='ContactName'),
    contactNumber?: string(name='ContactNumber'),
    contactProvince?: string(name='ContactProvince'),
    contactZipcode?: string(name='ContactZipcode'),
    country?: string(name='Country'),
    detailedContactAddress?: string(name='DetailedContactAddress'),
    EAddress?: string(name='EAddress'),
    EName?: string(name='EName'),
    expirationDate?: string(name='ExpirationDate'),
    factAndReasonPdfPath?: string(name='FactAndReasonPdfPath'),
    idCardName?: string(name='IdCardName'),
    idCardNumber?: string(name='IdCardNumber'),
    idCardUrl?: string(name='IdCardUrl'),
    legalNoticeUrl?: string(name='LegalNoticeUrl'),
    loaUrl?: string(name='LoaUrl'),
    materialVersion?: string(name='MaterialVersion'),
    name?: string(name='Name'),
    passportUrl?: string(name='PassportUrl'),
    personalType?: long(name='PersonalType'),
    principalName?: int32(name='PrincipalName'),
    province?: string(name='Province'),
    region?: int32(name='Region'),
    reviewAdditionalFiles?: {
      reviewAdditionalFile?: [ string ](name='ReviewAdditionalFile')
    }(name='ReviewAdditionalFiles'),
    reviewApplicationFile?: string(name='ReviewApplicationFile'),
    status?: int32(name='Status'),
    supplementEvidenceCatalogFile?: string(name='SupplementEvidenceCatalogFile'),
    supplementEvidenceMaterialFile?: string(name='SupplementEvidenceMaterialFile'),
    supplementReasonFile?: string(name='SupplementReasonFile'),
    town?: string(name='Town'),
    type?: int32(name='Type'),
  }(name='MaterialDetail'),
  materialId?: long(name='MaterialId'),
  notAcceptUrl?: string(name='NotAcceptUrl'),
  note?: string(name='Note'),
  orderId?: string(name='OrderId'),
  orderPrice?: float(name='OrderPrice'),
  partnerCode?: string(name='PartnerCode'),
  partnerMobile?: string(name='PartnerMobile'),
  partnerName?: string(name='PartnerName'),
  principalName?: int32(name='PrincipalName'),
  receiptUrl?: {
    receiptUrl?: [ string ](name='ReceiptUrl')
  }(name='ReceiptUrl'),
  recvUserLogistics?: string(name='RecvUserLogistics'),
  renewResponse?: {
    address?: string(name='Address'),
    engAddress?: string(name='EngAddress'),
    engName?: string(name='EngName'),
    name?: string(name='Name'),
    registerTime?: long(name='RegisterTime'),
    submitSbjtime?: long(name='SubmitSbjtime'),
  }(name='RenewResponse'),
  requestId?: string(name='RequestId'),
  reviewOfficialFiles?: {
    reviewAudit?: string(name='ReviewAudit'),
    reviewKeep?: string(name='ReviewKeep'),
    reviewPart?: string(name='ReviewPart'),
    reviewPass?: string(name='ReviewPass'),
    reviewSupplements?: {
      reviewSupplement?: [ string ](name='ReviewSupplement')
    }(name='ReviewSupplements'),
  }(name='ReviewOfficialFiles'),
  sendSbjLogistics?: string(name='SendSbjLogistics'),
  sendTime?: string(name='SendTime'),
  sendUserLogistics?: string(name='SendUserLogistics'),
  servicePrice?: float(name='ServicePrice'),
  specification?: int32(name='Specification'),
  status?: int32(name='Status'),
  submitAuditTime?: long(name='SubmitAuditTime'),
  submitTime?: long(name='SubmitTime'),
  supplements?: {
    supplements?: [ 
    {
      acceptDeadTime?: long(name='AcceptDeadTime'),
      acceptTime?: long(name='AcceptTime'),
      batchNum?: string(name='BatchNum'),
      content?: string(name='Content'),
      fileTemplateUrls?: {
        fileTemplateUrls?: [ string ](name='FileTemplateUrls')
      }(name='FileTemplateUrls'),
      filename?: string(name='Filename'),
      id?: long(name='Id'),
      operateTime?: long(name='OperateTime'),
      orderId?: string(name='OrderId'),
      sbjDeadTime?: long(name='SbjDeadTime'),
      sendTime?: long(name='SendTime'),
      serialNumber?: string(name='SerialNumber'),
      status?: int32(name='Status'),
      tmNumber?: string(name='TmNumber'),
      type?: int32(name='Type'),
      uploadFileTemplateUrl?: string(name='UploadFileTemplateUrl'),
    }
  ](name='Supplements')
  }(name='Supplements'),
  systemVersion?: string(name='SystemVersion'),
  thirdClassification?: {
    thirdClassifications?: [ 
    {
      code?: string(name='Code'),
      name?: string(name='Name'),
    }
  ](name='ThirdClassifications')
  }(name='ThirdClassification'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  tmNameType?: int32(name='TmNameType'),
  tmNumber?: string(name='TmNumber'),
  totalPrice?: float(name='TotalPrice'),
  type?: int32(name='Type'),
  updateTime?: long(name='UpdateTime'),
}

model QueryTradeMarkApplicationDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTradeMarkApplicationDetailResponseBody(name='body'),
}

async function queryTradeMarkApplicationDetailWithOptions(request: QueryTradeMarkApplicationDetailRequest, runtime: Util.RuntimeOptions): QueryTradeMarkApplicationDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTradeMarkApplicationDetail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTradeMarkApplicationDetail(request: QueryTradeMarkApplicationDetailRequest): QueryTradeMarkApplicationDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeMarkApplicationDetailWithOptions(request, runtime);
}

model QueryTradeMarkApplicationLogsRequest {
  bizId?: string(name='BizId'),
}

model QueryTradeMarkApplicationLogsResponseBody = {
  data?: {
    data?: [ 
    {
      bizId?: string(name='BizId'),
      bizStatus?: int32(name='BizStatus'),
      extendContent?: string(name='ExtendContent'),
      note?: string(name='Note'),
      operateTime?: long(name='OperateTime'),
      operateType?: int32(name='OperateType'),
      toBizStatus?: int32(name='ToBizStatus'),
    }
  ](name='Data')
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryTradeMarkApplicationLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTradeMarkApplicationLogsResponseBody(name='body'),
}

async function queryTradeMarkApplicationLogsWithOptions(request: QueryTradeMarkApplicationLogsRequest, runtime: Util.RuntimeOptions): QueryTradeMarkApplicationLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTradeMarkApplicationLogs',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTradeMarkApplicationLogs(request: QueryTradeMarkApplicationLogsRequest): QueryTradeMarkApplicationLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeMarkApplicationLogsWithOptions(request, runtime);
}

model QueryTradeMarkApplicationsRequest {
  bizId?: string(name='BizId'),
  classificationCode?: string(name='ClassificationCode'),
  hidden?: int32(name='Hidden'),
  intentionBizId?: string(name='IntentionBizId'),
  logisticsNo?: string(name='LogisticsNo'),
  materialName?: string(name='MaterialName'),
  orderId?: string(name='OrderId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  productType?: int32(name='ProductType'),
  sortFiled?: string(name='SortFiled'),
  sortOrder?: string(name='SortOrder'),
  specification?: int32(name='Specification'),
  status?: int32(name='Status'),
  supplementStatus?: int32(name='SupplementStatus'),
  tmName?: string(name='TmName'),
  tmNumber?: string(name='TmNumber'),
  type?: string(name='Type'),
}

model QueryTradeMarkApplicationsResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    tmProduces?: [ 
    {
      agreementId?: string(name='AgreementId'),
      bizId?: string(name='BizId'),
      createTime?: long(name='CreateTime'),
      firstClassification?: {
        classificationCode?: string(name='ClassificationCode'),
        classificationName?: string(name='ClassificationName'),
      }(name='FirstClassification'),
      flags?: {
        flags?: [ string ](name='Flags')
      }(name='Flags'),
      loaUrl?: string(name='LoaUrl'),
      materialId?: long(name='MaterialId'),
      materialName?: string(name='MaterialName'),
      note?: string(name='Note'),
      orderId?: string(name='OrderId'),
      orderPrice?: float(name='OrderPrice'),
      principalName?: int32(name='PrincipalName'),
      remark?: string(name='Remark'),
      renewResponse?: {
        address?: string(name='Address'),
        engAddress?: string(name='EngAddress'),
        engName?: string(name='EngName'),
        name?: string(name='Name'),
        registerTime?: long(name='RegisterTime'),
        submitSbjtime?: long(name='SubmitSbjtime'),
      }(name='RenewResponse'),
      servicePrice?: float(name='ServicePrice'),
      showGoToDefendButton?: boolean(name='ShowGoToDefendButton'),
      specification?: int32(name='Specification'),
      status?: int32(name='Status'),
      submitAuditTime?: long(name='SubmitAuditTime'),
      submitTime?: long(name='SubmitTime'),
      supplementId?: long(name='SupplementId'),
      supplementStatus?: int32(name='SupplementStatus'),
      systemVersion?: string(name='SystemVersion'),
      thirdClassification?: {
        thirdClassifications?: [ 
        {
          classificationCode?: string(name='ClassificationCode'),
          classificationName?: string(name='ClassificationName'),
        }
      ](name='ThirdClassifications')
      }(name='ThirdClassification'),
      tmIcon?: string(name='TmIcon'),
      tmName?: string(name='TmName'),
      tmNumber?: string(name='TmNumber'),
      totalPrice?: float(name='TotalPrice'),
      type?: int32(name='Type'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='TmProduces')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTradeMarkApplicationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTradeMarkApplicationsResponseBody(name='body'),
}

async function queryTradeMarkApplicationsWithOptions(request: QueryTradeMarkApplicationsRequest, runtime: Util.RuntimeOptions): QueryTradeMarkApplicationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.classificationCode)) {
    query['ClassificationCode'] = request.classificationCode;
  }
  if (!Util.isUnset(request.hidden)) {
    query['Hidden'] = request.hidden;
  }
  if (!Util.isUnset(request.intentionBizId)) {
    query['IntentionBizId'] = request.intentionBizId;
  }
  if (!Util.isUnset(request.logisticsNo)) {
    query['LogisticsNo'] = request.logisticsNo;
  }
  if (!Util.isUnset(request.materialName)) {
    query['MaterialName'] = request.materialName;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.sortFiled)) {
    query['SortFiled'] = request.sortFiled;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.specification)) {
    query['Specification'] = request.specification;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.supplementStatus)) {
    query['SupplementStatus'] = request.supplementStatus;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNumber)) {
    query['TmNumber'] = request.tmNumber;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTradeMarkApplications',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTradeMarkApplications(request: QueryTradeMarkApplicationsRequest): QueryTradeMarkApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeMarkApplicationsWithOptions(request, runtime);
}

model QueryTradeMarkApplicationsByIntentionRequest {
  channel?: string(name='Channel'),
  intentionBizId?: string(name='IntentionBizId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tmProduceStatus?: string(name='TmProduceStatus'),
}

model QueryTradeMarkApplicationsByIntentionResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    tmProduces?: [ 
    {
      bizId?: string(name='BizId'),
      createTime?: long(name='CreateTime'),
      firstClassification?: {
        classificationCode?: string(name='ClassificationCode'),
        classificationName?: string(name='ClassificationName'),
      }(name='FirstClassification'),
      loaUrl?: string(name='LoaUrl'),
      materialId?: string(name='MaterialId'),
      materialName?: string(name='MaterialName'),
      note?: string(name='Note'),
      orderPrice?: float(name='OrderPrice'),
      principalDescription?: string(name='PrincipalDescription'),
      principalValue?: int32(name='PrincipalValue'),
      servicePrice?: float(name='ServicePrice'),
      status?: int32(name='Status'),
      supplementId?: long(name='SupplementId'),
      supplementStatus?: int32(name='SupplementStatus'),
      thirdClassification?: {
        thirdClassifications?: [ 
        {
          classificationCode?: string(name='ClassificationCode'),
          classificationName?: string(name='ClassificationName'),
        }
      ](name='ThirdClassifications')
      }(name='ThirdClassification'),
      tmIcon?: string(name='TmIcon'),
      tmName?: string(name='TmName'),
      tmNumber?: string(name='TmNumber'),
      totalPrice?: float(name='TotalPrice'),
      type?: int32(name='Type'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='TmProduces')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTradeMarkApplicationsByIntentionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTradeMarkApplicationsByIntentionResponseBody(name='body'),
}

async function queryTradeMarkApplicationsByIntentionWithOptions(request: QueryTradeMarkApplicationsByIntentionRequest, runtime: Util.RuntimeOptions): QueryTradeMarkApplicationsByIntentionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.intentionBizId)) {
    query['IntentionBizId'] = request.intentionBizId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tmProduceStatus)) {
    query['TmProduceStatus'] = request.tmProduceStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTradeMarkApplicationsByIntention',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTradeMarkApplicationsByIntention(request: QueryTradeMarkApplicationsByIntentionRequest): QueryTradeMarkApplicationsByIntentionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeMarkApplicationsByIntentionWithOptions(request, runtime);
}

model QueryTradeProduceDetailRequest {
  bizId?: string(name='BizId'),
}

model QueryTradeProduceDetailResponseBody = {
  data?: {
    allowCancel?: boolean(name='AllowCancel'),
    bizId?: string(name='BizId'),
    buyerStatus?: int32(name='BuyerStatus'),
    classification?: string(name='Classification'),
    confiscateAmount?: float(name='ConfiscateAmount'),
    createTime?: long(name='CreateTime'),
    exclusiveDateLimit?: string(name='ExclusiveDateLimit'),
    extend?: map[string]any(name='Extend'),
    finalAmount?: float(name='FinalAmount'),
    icon?: string(name='Icon'),
    operateNote?: string(name='OperateNote'),
    paidAmount?: float(name='PaidAmount'),
    preAmount?: float(name='PreAmount'),
    preOrderId?: string(name='PreOrderId'),
    refundAmount?: float(name='RefundAmount'),
    registerNumber?: string(name='RegisterNumber'),
    share?: string(name='Share'),
    source?: int32(name='Source'),
    thirdCode?: string(name='ThirdCode'),
    tmName?: string(name='TmName'),
    updateTime?: long(name='UpdateTime'),
    userId?: string(name='UserId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryTradeProduceDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTradeProduceDetailResponseBody(name='body'),
}

async function queryTradeProduceDetailWithOptions(request: QueryTradeProduceDetailRequest, runtime: Util.RuntimeOptions): QueryTradeProduceDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTradeProduceDetail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTradeProduceDetail(request: QueryTradeProduceDetailRequest): QueryTradeProduceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeProduceDetailWithOptions(request, runtime);
}

model QueryTradeProduceListRequest {
  bizId?: string(name='BizId'),
  buyerStatus?: int32(name='BuyerStatus'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  preOrderId?: string(name='PreOrderId'),
  registerNumber?: string(name='RegisterNumber'),
  sortFiled?: string(name='SortFiled'),
  sortOrder?: string(name='SortOrder'),
}

model QueryTradeProduceListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    tradeProduces?: [ 
    {
      allowCancel?: boolean(name='AllowCancel'),
      bizId?: string(name='BizId'),
      buyerStatus?: int32(name='BuyerStatus'),
      classification?: string(name='Classification'),
      createTime?: long(name='CreateTime'),
      failReason?: int32(name='FailReason'),
      finalAmount?: float(name='FinalAmount'),
      icon?: string(name='Icon'),
      operateNote?: string(name='OperateNote'),
      preAmount?: float(name='PreAmount'),
      preOrderId?: string(name='PreOrderId'),
      registerNumber?: string(name='RegisterNumber'),
      source?: int32(name='Source'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='TradeProduces')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTradeProduceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTradeProduceListResponseBody(name='body'),
}

async function queryTradeProduceListWithOptions(request: QueryTradeProduceListRequest, runtime: Util.RuntimeOptions): QueryTradeProduceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.buyerStatus)) {
    query['BuyerStatus'] = request.buyerStatus;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.preOrderId)) {
    query['PreOrderId'] = request.preOrderId;
  }
  if (!Util.isUnset(request.registerNumber)) {
    query['RegisterNumber'] = request.registerNumber;
  }
  if (!Util.isUnset(request.sortFiled)) {
    query['SortFiled'] = request.sortFiled;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTradeProduceList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTradeProduceList(request: QueryTradeProduceListRequest): QueryTradeProduceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeProduceListWithOptions(request, runtime);
}

model QueryTrademarkDetailByApplyNumberRequest {
  applyNumber?: string(name='ApplyNumber'),
  env?: string(name='Env'),
}

model QueryTrademarkDetailByApplyNumberResponseBody = {
  moudle?: {
    bitFlag?: int32(name='BitFlag'),
    bizId?: string(name='BizId'),
    bizType?: string(name='BizType'),
    extendInfo?: map[string]any(name='ExtendInfo'),
    grayIconUrl?: string(name='GrayIconUrl'),
    icon?: string(name='Icon'),
    leafCodes?: {
      leafCode?: [ 
      {
        classificationCode?: string(name='ClassificationCode'),
        classificationName?: string(name='ClassificationName'),
      }
    ](name='leafCode')
    }(name='LeafCodes'),
    materialInfo?: {
      address?: string(name='Address'),
      businessLicenceUrl?: string(name='BusinessLicenceUrl'),
      cardNumber?: string(name='CardNumber'),
      cnInfoUrl?: string(name='CnInfoUrl'),
      contactAddress?: string(name='ContactAddress'),
      contactEmail?: string(name='ContactEmail'),
      contactName?: string(name='ContactName'),
      contactPhoneNumber?: string(name='ContactPhoneNumber'),
      contactZipCode?: string(name='ContactZipCode'),
      country?: string(name='Country'),
      EAddress?: string(name='EAddress'),
      EName?: string(name='EName'),
      idCardNumber?: string(name='IdCardNumber'),
      idCardUrl?: string(name='IdCardUrl'),
      loaKey?: string(name='LoaKey'),
      loaUrl?: string(name='LoaUrl'),
      name?: string(name='Name'),
      passportUrl?: string(name='PassportUrl'),
      personalType?: int32(name='PersonalType'),
      postCode?: string(name='PostCode'),
      province?: string(name='Province'),
      reasonFileOssKey?: string(name='ReasonFileOssKey'),
      region?: int32(name='Region'),
      reviewFileMap?: map[string]any(name='ReviewFileMap'),
      type?: int32(name='Type'),
    }(name='MaterialInfo'),
    orderId?: string(name='OrderId'),
    partnerCode?: string(name='PartnerCode'),
    principalKey?: string(name='PrincipalKey'),
    principalName?: string(name='PrincipalName'),
    produceType?: string(name='ProduceType'),
    rootCode?: {
      classificationCode?: string(name='ClassificationCode'),
      classificationName?: string(name='ClassificationName'),
    }(name='RootCode'),
    status?: string(name='Status'),
    statusStr?: string(name='StatusStr'),
    submitAuditTimeStr?: string(name='SubmitAuditTimeStr'),
    submitAuditTimeValue?: long(name='SubmitAuditTimeValue'),
    submitStatus?: string(name='SubmitStatus'),
    submitTimeStr?: string(name='SubmitTimeStr'),
    submitTimeValue?: long(name='SubmitTimeValue'),
    submitTimes?: int32(name='SubmitTimes'),
    trademarkName?: string(name='TrademarkName'),
    trademarkNameType?: int32(name='TrademarkNameType'),
    trademarkNumber?: string(name='TrademarkNumber'),
  }(name='Moudle'),
  requestId?: string(name='RequestId'),
}

model QueryTrademarkDetailByApplyNumberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkDetailByApplyNumberResponseBody(name='body'),
}

async function queryTrademarkDetailByApplyNumberWithOptions(request: QueryTrademarkDetailByApplyNumberRequest, runtime: Util.RuntimeOptions): QueryTrademarkDetailByApplyNumberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applyNumber)) {
    query['ApplyNumber'] = request.applyNumber;
  }
  if (!Util.isUnset(request.env)) {
    query['Env'] = request.env;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkDetailByApplyNumber',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkDetailByApplyNumber(request: QueryTrademarkDetailByApplyNumberRequest): QueryTrademarkDetailByApplyNumberResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkDetailByApplyNumberWithOptions(request, runtime);
}

model QueryTrademarkDetailByApplyNumberEspRequest {
  applyNumber?: string(name='ApplyNumber'),
  bizType?: string(name='BizType'),
}

model QueryTrademarkDetailByApplyNumberEspResponseBody = {
  moudle?: {
    bitFlag?: int32(name='BitFlag'),
    bizId?: string(name='BizId'),
    bizType?: string(name='BizType'),
    extendInfo?: map[string]any(name='ExtendInfo'),
    grayIconUrl?: string(name='GrayIconUrl'),
    icon?: string(name='Icon'),
    leafCodes?: {
      leafCode?: [ 
      {
        classificationCode?: string(name='ClassificationCode'),
        classificationName?: string(name='ClassificationName'),
      }
    ](name='leafCode')
    }(name='LeafCodes'),
    materialInfo?: {
      address?: string(name='Address'),
      businessLicenceUrl?: string(name='BusinessLicenceUrl'),
      cardNumber?: string(name='CardNumber'),
      cnInfoUrl?: string(name='CnInfoUrl'),
      contactAddress?: string(name='ContactAddress'),
      contactEmail?: string(name='ContactEmail'),
      contactName?: string(name='ContactName'),
      contactPhoneNumber?: string(name='ContactPhoneNumber'),
      contactZipCode?: string(name='ContactZipCode'),
      country?: string(name='Country'),
      EAddress?: string(name='EAddress'),
      EName?: string(name='EName'),
      idCardNumber?: string(name='IdCardNumber'),
      idCardUrl?: string(name='IdCardUrl'),
      loaKey?: string(name='LoaKey'),
      loaUrl?: string(name='LoaUrl'),
      name?: string(name='Name'),
      passportUrl?: string(name='PassportUrl'),
      personalType?: int32(name='PersonalType'),
      postCode?: string(name='PostCode'),
      province?: string(name='Province'),
      reasonFileOssKey?: string(name='ReasonFileOssKey'),
      region?: int32(name='Region'),
      reviewFileMap?: map[string]any(name='ReviewFileMap'),
      type?: int32(name='Type'),
    }(name='MaterialInfo'),
    orderId?: string(name='OrderId'),
    partnerCode?: string(name='PartnerCode'),
    principalKey?: string(name='PrincipalKey'),
    principalName?: string(name='PrincipalName'),
    produceType?: string(name='ProduceType'),
    rootCode?: {
      classificationCode?: string(name='ClassificationCode'),
      classificationName?: string(name='ClassificationName'),
    }(name='RootCode'),
    status?: string(name='Status'),
    statusStr?: string(name='StatusStr'),
    submitAuditTimeStr?: string(name='SubmitAuditTimeStr'),
    submitAuditTimeValue?: long(name='SubmitAuditTimeValue'),
    submitStatus?: string(name='SubmitStatus'),
    submitTimeStr?: string(name='SubmitTimeStr'),
    submitTimeValue?: long(name='SubmitTimeValue'),
    submitTimes?: int32(name='SubmitTimes'),
    trademarkName?: string(name='TrademarkName'),
    trademarkNameType?: int32(name='TrademarkNameType'),
    trademarkNumber?: string(name='TrademarkNumber'),
  }(name='Moudle'),
  requestId?: string(name='RequestId'),
}

model QueryTrademarkDetailByApplyNumberEspResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkDetailByApplyNumberEspResponseBody(name='body'),
}

async function queryTrademarkDetailByApplyNumberEspWithOptions(request: QueryTrademarkDetailByApplyNumberEspRequest, runtime: Util.RuntimeOptions): QueryTrademarkDetailByApplyNumberEspResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applyNumber)) {
    query['ApplyNumber'] = request.applyNumber;
  }
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkDetailByApplyNumberEsp',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkDetailByApplyNumberEsp(request: QueryTrademarkDetailByApplyNumberEspRequest): QueryTrademarkDetailByApplyNumberEspResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkDetailByApplyNumberEspWithOptions(request, runtime);
}

model QueryTrademarkModelDetailRequest {
  bizId?: string(name='BizId'),
  env?: string(name='Env'),
  orderId?: string(name='OrderId'),
  reviewSupplementMaterial?: boolean(name='ReviewSupplementMaterial'),
}

model QueryTrademarkModelDetailResponseBody = {
  moudle?: {
    bitFlag?: int32(name='BitFlag'),
    bizId?: string(name='BizId'),
    bizType?: string(name='BizType'),
    extendInfo?: map[string]any(name='ExtendInfo'),
    grayIconUrl?: string(name='GrayIconUrl'),
    icon?: string(name='Icon'),
    leafCodes?: {
      leafCode?: [ 
      {
        classificationCode?: string(name='ClassificationCode'),
        classificationName?: string(name='ClassificationName'),
      }
    ](name='leafCode')
    }(name='LeafCodes'),
    materialInfo?: {
      address?: string(name='Address'),
      businessLicenceUrl?: string(name='BusinessLicenceUrl'),
      cardNumber?: string(name='CardNumber'),
      cnInfoUrl?: string(name='CnInfoUrl'),
      contactAddress?: string(name='ContactAddress'),
      contactEmail?: string(name='ContactEmail'),
      contactName?: string(name='ContactName'),
      contactPhoneNumber?: string(name='ContactPhoneNumber'),
      contactZipCode?: string(name='ContactZipCode'),
      country?: string(name='Country'),
      EAddress?: string(name='EAddress'),
      EName?: string(name='EName'),
      idCardNumber?: string(name='IdCardNumber'),
      idCardUrl?: string(name='IdCardUrl'),
      loaKey?: string(name='LoaKey'),
      loaUrl?: string(name='LoaUrl'),
      name?: string(name='Name'),
      passportUrl?: string(name='PassportUrl'),
      personalType?: int32(name='PersonalType'),
      postCode?: string(name='PostCode'),
      province?: string(name='Province'),
      reasonFileOssKey?: string(name='ReasonFileOssKey'),
      region?: int32(name='Region'),
      reviewFileMap?: map[string]any(name='ReviewFileMap'),
      type?: int32(name='Type'),
    }(name='MaterialInfo'),
    orderId?: string(name='OrderId'),
    partnerCode?: string(name='PartnerCode'),
    principalKey?: string(name='PrincipalKey'),
    principalName?: string(name='PrincipalName'),
    produceType?: string(name='ProduceType'),
    requestId?: string(name='RequestId'),
    rootCode?: {
      classificationCode?: string(name='ClassificationCode'),
      classificationName?: string(name='ClassificationName'),
    }(name='RootCode'),
    status?: string(name='Status'),
    statusStr?: string(name='StatusStr'),
    submitAuditTimeStr?: string(name='SubmitAuditTimeStr'),
    submitAuditTimeValue?: long(name='SubmitAuditTimeValue'),
    submitStatus?: string(name='SubmitStatus'),
    submitTimeStr?: string(name='SubmitTimeStr'),
    submitTimeValue?: long(name='SubmitTimeValue'),
    submitTimes?: int32(name='SubmitTimes'),
    trademarkName?: string(name='TrademarkName'),
    trademarkNameType?: int32(name='TrademarkNameType'),
    trademarkNumber?: string(name='TrademarkNumber'),
  }(name='Moudle'),
}

model QueryTrademarkModelDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkModelDetailResponseBody(name='body'),
}

async function queryTrademarkModelDetailWithOptions(request: QueryTrademarkModelDetailRequest, runtime: Util.RuntimeOptions): QueryTrademarkModelDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.env)) {
    query['Env'] = request.env;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.reviewSupplementMaterial)) {
    query['ReviewSupplementMaterial'] = request.reviewSupplementMaterial;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkModelDetail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkModelDetail(request: QueryTrademarkModelDetailRequest): QueryTrademarkModelDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkModelDetailWithOptions(request, runtime);
}

model QueryTrademarkModelEspDetailRequest {
  bizId?: string(name='BizId'),
  bizType?: string(name='BizType'),
}

model QueryTrademarkModelEspDetailResponseBody = {
  moudle?: {
    bitFlag?: int32(name='BitFlag'),
    bizId?: string(name='BizId'),
    bizType?: string(name='BizType'),
    extendInfo?: map[string]any(name='ExtendInfo'),
    grayIconUrl?: string(name='GrayIconUrl'),
    icon?: string(name='Icon'),
    leafCodes?: {
      leafCode?: [ 
      {
        classificationCode?: string(name='ClassificationCode'),
        classificationName?: string(name='ClassificationName'),
      }
    ](name='leafCode')
    }(name='LeafCodes'),
    materialInfo?: {
      address?: string(name='Address'),
      businessLicenceUrl?: string(name='BusinessLicenceUrl'),
      cardNumber?: string(name='CardNumber'),
      cnInfoUrl?: string(name='CnInfoUrl'),
      contactAddress?: string(name='ContactAddress'),
      contactEmail?: string(name='ContactEmail'),
      contactZipCode?: string(name='ContactZipCode'),
      country?: string(name='Country'),
      EAddress?: string(name='EAddress'),
      EName?: string(name='EName'),
      idCardNumber?: string(name='IdCardNumber'),
      idCardUrl?: string(name='IdCardUrl'),
      loaKey?: string(name='LoaKey'),
      loaUrl?: string(name='LoaUrl'),
      name?: string(name='Name'),
      passportUrl?: string(name='PassportUrl'),
      personalType?: string(name='PersonalType'),
      postCode?: string(name='PostCode'),
      province?: string(name='Province'),
      reasonFileOssKey?: string(name='ReasonFileOssKey'),
      region?: int32(name='Region'),
      type?: int32(name='Type'),
    }(name='MaterialInfo'),
    orderId?: string(name='OrderId'),
    partnerCode?: string(name='PartnerCode'),
    principalKey?: string(name='PrincipalKey'),
    principalName?: string(name='PrincipalName'),
    produceType?: string(name='ProduceType'),
    requestId?: string(name='RequestId'),
    rootCode?: {
      classificationCode?: string(name='ClassificationCode'),
      classificationName?: string(name='ClassificationName'),
    }(name='RootCode'),
    status?: string(name='Status'),
    statusStr?: string(name='StatusStr'),
    submitAuditTime?: long(name='SubmitAuditTime'),
    submitStatus?: string(name='SubmitStatus'),
    submitTime?: long(name='SubmitTime'),
    submitTimes?: int32(name='SubmitTimes'),
    trademarkName?: string(name='TrademarkName'),
    trademarkNameType?: int32(name='TrademarkNameType'),
    trademarkNumber?: string(name='TrademarkNumber'),
  }(name='Moudle'),
}

model QueryTrademarkModelEspDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkModelEspDetailResponseBody(name='body'),
}

async function queryTrademarkModelEspDetailWithOptions(request: QueryTrademarkModelEspDetailRequest, runtime: Util.RuntimeOptions): QueryTrademarkModelEspDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkModelEspDetail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkModelEspDetail(request: QueryTrademarkModelEspDetailRequest): QueryTrademarkModelEspDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkModelEspDetailWithOptions(request, runtime);
}

model QueryTrademarkModelEspListRequest {
  bizId?: string(name='BizId'),
  bizType?: string(name='BizType'),
  env?: string(name='Env'),
  orderId?: string(name='OrderId'),
  orderIdsStr?: string(name='OrderIdsStr'),
  orderInstanceId?: string(name='OrderInstanceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  principalKey?: string(name='PrincipalKey'),
  principalName?: string(name='PrincipalName'),
  status?: string(name='Status'),
  submitStatus?: string(name='SubmitStatus'),
  submitTime?: string(name='SubmitTime'),
}

model QueryTrademarkModelEspListResponseBody = {
  moudle?: {
    data?: {
      item?: [ 
      {
        bitFlag?: int32(name='BitFlag'),
        bizId?: string(name='BizId'),
        bizType?: string(name='BizType'),
        extendInfo?: map[string]any(name='ExtendInfo'),
        grayIconUrl?: string(name='GrayIconUrl'),
        icon?: string(name='Icon'),
        leafCodes?: {
          leafCode?: [ 
          {
            classificationCode?: string(name='ClassificationCode'),
            classificationName?: string(name='ClassificationName'),
          }
        ](name='leafCode')
        }(name='LeafCodes'),
        materialInfo?: {
          address?: string(name='Address'),
          businessLicenceUrl?: string(name='BusinessLicenceUrl'),
          cardNumber?: string(name='CardNumber'),
          cnInfoUrl?: string(name='CnInfoUrl'),
          contactAddress?: string(name='ContactAddress'),
          contactEmail?: string(name='ContactEmail'),
          contactZipCode?: string(name='ContactZipCode'),
          country?: string(name='Country'),
          EAddress?: string(name='EAddress'),
          EName?: string(name='EName'),
          idCardNumber?: string(name='IdCardNumber'),
          idCardUrl?: string(name='IdCardUrl'),
          loaKey?: string(name='LoaKey'),
          loaUrl?: string(name='LoaUrl'),
          name?: string(name='Name'),
          passportUrl?: string(name='PassportUrl'),
          personalType?: string(name='PersonalType'),
          postCode?: string(name='PostCode'),
          province?: string(name='Province'),
          reasonFileOssKey?: string(name='ReasonFileOssKey'),
          region?: int32(name='Region'),
          type?: int32(name='Type'),
        }(name='MaterialInfo'),
        orderId?: string(name='OrderId'),
        partnerCode?: string(name='PartnerCode'),
        principalKey?: string(name='PrincipalKey'),
        principalName?: string(name='PrincipalName'),
        produceType?: string(name='ProduceType'),
        rootCode?: {
          classificationCode?: string(name='ClassificationCode'),
          classificationName?: string(name='ClassificationName'),
        }(name='RootCode'),
        status?: string(name='Status'),
        statusStr?: string(name='StatusStr'),
        submitAuditTime?: long(name='SubmitAuditTime'),
        submitStatus?: string(name='SubmitStatus'),
        submitTime?: long(name='SubmitTime'),
        submitTimes?: int32(name='SubmitTimes'),
        trademarkName?: string(name='TrademarkName'),
        trademarkNameType?: int32(name='TrademarkNameType'),
        trademarkNumber?: string(name='TrademarkNumber'),
      }
    ](name='item')
    }(name='Data'),
    requestId?: string(name='RequestId'),
    totalPageNum?: int32(name='TotalPageNum'),
  }(name='Moudle'),
}

model QueryTrademarkModelEspListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkModelEspListResponseBody(name='body'),
}

async function queryTrademarkModelEspListWithOptions(request: QueryTrademarkModelEspListRequest, runtime: Util.RuntimeOptions): QueryTrademarkModelEspListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.env)) {
    query['Env'] = request.env;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.orderIdsStr)) {
    query['OrderIdsStr'] = request.orderIdsStr;
  }
  if (!Util.isUnset(request.orderInstanceId)) {
    query['OrderInstanceId'] = request.orderInstanceId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.principalKey)) {
    query['PrincipalKey'] = request.principalKey;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.submitStatus)) {
    query['SubmitStatus'] = request.submitStatus;
  }
  if (!Util.isUnset(request.submitTime)) {
    query['SubmitTime'] = request.submitTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkModelEspList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkModelEspList(request: QueryTrademarkModelEspListRequest): QueryTrademarkModelEspListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkModelEspListWithOptions(request, runtime);
}

model QueryTrademarkModelListRequest {
  env?: string(name='Env'),
  orderIdsStr?: string(name='OrderIdsStr'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  principalKey?: string(name='PrincipalKey'),
  principalName?: string(name='PrincipalName'),
  produceTypesStr?: string(name='ProduceTypesStr'),
  status?: string(name='Status'),
  submitStart?: string(name='SubmitStart'),
  submitStatus?: string(name='SubmitStatus'),
  submitTime?: string(name='SubmitTime'),
}

model QueryTrademarkModelListResponseBody = {
  moudle?: {
    data?: {
      item?: [ 
      {
        bitFlag?: int32(name='BitFlag'),
        bizId?: string(name='BizId'),
        bizType?: string(name='BizType'),
        extendInfo?: map[string]any(name='ExtendInfo'),
        grayIconUrl?: string(name='GrayIconUrl'),
        icon?: string(name='Icon'),
        leafCodes?: {
          leafCode?: [ 
          {
            classificationCode?: string(name='ClassificationCode'),
            classificationName?: string(name='ClassificationName'),
          }
        ](name='leafCode')
        }(name='LeafCodes'),
        materialInfo?: {
          address?: string(name='Address'),
          businessLicenceUrl?: string(name='BusinessLicenceUrl'),
          cardNumber?: string(name='CardNumber'),
          cnInfoUrl?: string(name='CnInfoUrl'),
          contactAddress?: string(name='ContactAddress'),
          contactEmail?: string(name='ContactEmail'),
          contactZipCode?: string(name='ContactZipCode'),
          country?: string(name='Country'),
          EAddress?: string(name='EAddress'),
          EName?: string(name='EName'),
          idCardNumber?: string(name='IdCardNumber'),
          idCardUrl?: string(name='IdCardUrl'),
          loaKey?: string(name='LoaKey'),
          loaUrl?: string(name='LoaUrl'),
          name?: string(name='Name'),
          passportUrl?: string(name='PassportUrl'),
          personalType?: int32(name='PersonalType'),
          postCode?: string(name='PostCode'),
          province?: string(name='Province'),
          reasonFileOssKey?: string(name='ReasonFileOssKey'),
          region?: int32(name='Region'),
          type?: int32(name='Type'),
        }(name='MaterialInfo'),
        orderId?: string(name='OrderId'),
        partnerCode?: string(name='PartnerCode'),
        principalKey?: string(name='PrincipalKey'),
        principalName?: string(name='PrincipalName'),
        produceType?: string(name='ProduceType'),
        rootCode?: {
          classificationCode?: string(name='ClassificationCode'),
          classificationName?: string(name='ClassificationName'),
        }(name='RootCode'),
        status?: string(name='Status'),
        statusStr?: string(name='StatusStr'),
        submitAuditTimeStr?: string(name='SubmitAuditTimeStr'),
        submitAuditTimeValue?: long(name='SubmitAuditTimeValue'),
        submitStatus?: string(name='SubmitStatus'),
        submitTimeStr?: string(name='SubmitTimeStr'),
        submitTimeValue?: long(name='SubmitTimeValue'),
        submitTimes?: int32(name='SubmitTimes'),
        trademarkName?: string(name='TrademarkName'),
        trademarkNameType?: int32(name='TrademarkNameType'),
        trademarkNumber?: string(name='TrademarkNumber'),
      }
    ](name='item')
    }(name='Data'),
    requestId?: string(name='RequestId'),
    totalPageNum?: int32(name='TotalPageNum'),
  }(name='Moudle'),
}

model QueryTrademarkModelListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkModelListResponseBody(name='body'),
}

async function queryTrademarkModelListWithOptions(request: QueryTrademarkModelListRequest, runtime: Util.RuntimeOptions): QueryTrademarkModelListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.env)) {
    query['Env'] = request.env;
  }
  if (!Util.isUnset(request.orderIdsStr)) {
    query['OrderIdsStr'] = request.orderIdsStr;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.principalKey)) {
    query['PrincipalKey'] = request.principalKey;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  if (!Util.isUnset(request.produceTypesStr)) {
    query['ProduceTypesStr'] = request.produceTypesStr;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.submitStart)) {
    query['SubmitStart'] = request.submitStart;
  }
  if (!Util.isUnset(request.submitStatus)) {
    query['SubmitStatus'] = request.submitStatus;
  }
  if (!Util.isUnset(request.submitTime)) {
    query['SubmitTime'] = request.submitTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkModelList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkModelList(request: QueryTrademarkModelListRequest): QueryTrademarkModelListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkModelListWithOptions(request, runtime);
}

model QueryTrademarkMonitorResultsRequest {
  actionType?: int32(name='ActionType'),
  applyYear?: string(name='ApplyYear'),
  classification?: string(name='Classification'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  procedureStatus?: int32(name='ProcedureStatus'),
  registrationNumber?: string(name='RegistrationNumber'),
  ruleId?: long(name='RuleId'),
  tmName?: string(name='TmName'),
}

model QueryTrademarkMonitorResultsResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    tmMonitorResult?: [ 
    {
      applyDate?: string(name='ApplyDate'),
      chesanEndDate?: string(name='ChesanEndDate'),
      classification?: string(name='Classification'),
      dataCreateTime?: long(name='DataCreateTime'),
      dataUpdateTime?: long(name='DataUpdateTime'),
      ownerEnName?: string(name='OwnerEnName'),
      ownerName?: string(name='OwnerName'),
      registrationNumber?: string(name='RegistrationNumber'),
      ruleId?: string(name='RuleId'),
      tmImage?: string(name='TmImage'),
      tmName?: string(name='TmName'),
      tmProcedureStatusDesc?: string(name='TmProcedureStatusDesc'),
      tmUid?: string(name='TmUid'),
      userId?: string(name='UserId'),
      wuxiaoEndDate?: string(name='WuxiaoEndDate'),
      xuzhanEndDate?: string(name='XuzhanEndDate'),
      yiyiEndDate?: string(name='YiyiEndDate'),
    }
  ](name='TmMonitorResult')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTrademarkMonitorResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkMonitorResultsResponseBody(name='body'),
}

async function queryTrademarkMonitorResultsWithOptions(request: QueryTrademarkMonitorResultsRequest, runtime: Util.RuntimeOptions): QueryTrademarkMonitorResultsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.applyYear)) {
    query['ApplyYear'] = request.applyYear;
  }
  if (!Util.isUnset(request.classification)) {
    query['Classification'] = request.classification;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.procedureStatus)) {
    query['ProcedureStatus'] = request.procedureStatus;
  }
  if (!Util.isUnset(request.registrationNumber)) {
    query['RegistrationNumber'] = request.registrationNumber;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkMonitorResults',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkMonitorResults(request: QueryTrademarkMonitorResultsRequest): QueryTrademarkMonitorResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkMonitorResultsWithOptions(request, runtime);
}

model QueryTrademarkMonitorRulesRequest {
  id?: string(name='Id'),
  notifyUpdate?: int32(name='NotifyUpdate'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  ruleName?: string(name='RuleName'),
}

model QueryTrademarkMonitorRulesResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    tmMonitorRule?: [ 
    {
      createTime?: string(name='CreateTime'),
      endTime?: string(name='EndTime'),
      env?: string(name='Env'),
      id?: string(name='Id'),
      lastFinishTime?: string(name='LastFinishTime'),
      lastRunTime?: string(name='LastRunTime'),
      lastUpdateTime?: string(name='LastUpdateTime'),
      notifyUpdate?: int32(name='NotifyUpdate'),
      ruleDetail?: string(name='RuleDetail'),
      ruleExtend?: string(name='RuleExtend'),
      ruleKeyword?: string(name='RuleKeyword'),
      ruleName?: string(name='RuleName'),
      ruleSource?: string(name='RuleSource'),
      ruleStatus?: string(name='RuleStatus'),
      ruleType?: int32(name='RuleType'),
      startTime?: string(name='StartTime'),
      updateTime?: string(name='UpdateTime'),
      userId?: string(name='UserId'),
      version?: int32(name='Version'),
    }
  ](name='TmMonitorRule')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTrademarkMonitorRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkMonitorRulesResponseBody(name='body'),
}

async function queryTrademarkMonitorRulesWithOptions(request: QueryTrademarkMonitorRulesRequest, runtime: Util.RuntimeOptions): QueryTrademarkMonitorRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.notifyUpdate)) {
    query['NotifyUpdate'] = request.notifyUpdate;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkMonitorRules',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkMonitorRules(request: QueryTrademarkMonitorRulesRequest): QueryTrademarkMonitorRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkMonitorRulesWithOptions(request, runtime);
}

model QueryTrademarkOnSaleRequest {
  classification?: string(name='Classification'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  registerCode?: string(name='RegisterCode'),
  registerNumber?: string(name='RegisterNumber'),
  tmType?: string(name='TmType'),
}

model QueryTrademarkOnSaleResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  totalPageNumber?: int32(name='TotalPageNumber'),
  trademarks?: [ 
    {
      auditResult?: string(name='AuditResult'),
      classification?: string(name='Classification'),
      icon?: string(name='Icon'),
      orderPrice?: string(name='OrderPrice'),
      registrationNumber?: string(name='RegistrationNumber'),
      status?: long(name='Status'),
      tmType?: string(name='TmType'),
      trademarkName?: string(name='TrademarkName'),
    }
  ](name='Trademarks'),
}

model QueryTrademarkOnSaleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkOnSaleResponseBody(name='body'),
}

async function queryTrademarkOnSaleWithOptions(request: QueryTrademarkOnSaleRequest, runtime: Util.RuntimeOptions): QueryTrademarkOnSaleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.classification)) {
    query['Classification'] = request.classification;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.registerCode)) {
    query['RegisterCode'] = request.registerCode;
  }
  if (!Util.isUnset(request.registerNumber)) {
    query['RegisterNumber'] = request.registerNumber;
  }
  if (!Util.isUnset(request.tmType)) {
    query['TmType'] = request.tmType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkOnSale',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkOnSale(request: QueryTrademarkOnSaleRequest): QueryTrademarkOnSaleResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkOnSaleWithOptions(request, runtime);
}

model QueryTrademarkPriceRequest {
  orderData?: map[string]any(name='OrderData'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  type?: int32(name='Type'),
  userId?: long(name='UserId'),
}

model QueryTrademarkPriceShrinkRequest {
  orderDataShrink?: string(name='OrderData'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  type?: int32(name='Type'),
  userId?: long(name='UserId'),
}

model QueryTrademarkPriceResponseBody = {
  currency?: string(name='Currency'),
  discountPrice?: float(name='DiscountPrice'),
  originalPrice?: float(name='OriginalPrice'),
  prices?: {
    prices?: [ 
    {
      classificationCode?: string(name='ClassificationCode'),
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }
  ](name='Prices')
  }(name='Prices'),
  requestId?: string(name='RequestId'),
  tradePrice?: float(name='TradePrice'),
}

model QueryTrademarkPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkPriceResponseBody(name='body'),
}

async function queryTrademarkPriceWithOptions(tmpReq: QueryTrademarkPriceRequest, runtime: Util.RuntimeOptions): QueryTrademarkPriceResponse {
  Util.validateModel(tmpReq);
  var request = new QueryTrademarkPriceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.orderData)) {
    request.orderDataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.orderData, 'OrderData', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.orderDataShrink)) {
    query['OrderData'] = request.orderDataShrink;
  }
  if (!Util.isUnset(request.tmIcon)) {
    query['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkPrice',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkPrice(request: QueryTrademarkPriceRequest): QueryTrademarkPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkPriceWithOptions(request, runtime);
}

model QueryTrademarkUploadAuditResultRequest {
  classification?: string(name='Classification'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  registerCode?: string(name='RegisterCode'),
  registerNumber?: string(name='RegisterNumber'),
  tmType?: string(name='TmType'),
}

model QueryTrademarkUploadAuditResultResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  totalPageNumber?: int32(name='TotalPageNumber'),
  trademarks?: [ 
    {
      auditResult?: string(name='AuditResult'),
      classification?: string(name='Classification'),
      icon?: string(name='Icon'),
      orderPrice?: string(name='OrderPrice'),
      registrationNumber?: string(name='RegistrationNumber'),
      status?: long(name='Status'),
      tmType?: string(name='TmType'),
      trademarkName?: string(name='TrademarkName'),
    }
  ](name='Trademarks'),
}

model QueryTrademarkUploadAuditResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkUploadAuditResultResponseBody(name='body'),
}

async function queryTrademarkUploadAuditResultWithOptions(request: QueryTrademarkUploadAuditResultRequest, runtime: Util.RuntimeOptions): QueryTrademarkUploadAuditResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.classification)) {
    query['Classification'] = request.classification;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.registerCode)) {
    query['RegisterCode'] = request.registerCode;
  }
  if (!Util.isUnset(request.registerNumber)) {
    query['RegisterNumber'] = request.registerNumber;
  }
  if (!Util.isUnset(request.tmType)) {
    query['TmType'] = request.tmType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkUploadAuditResult',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkUploadAuditResult(request: QueryTrademarkUploadAuditResultRequest): QueryTrademarkUploadAuditResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkUploadAuditResultWithOptions(request, runtime);
}

model RecordBankBalanceRequest {
  actionDate?: long(name='ActionDate'),
  balance?: string(name='Balance'),
  principalName?: string(name='PrincipalName'),
}

model RecordBankBalanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
}

model RecordBankBalanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecordBankBalanceResponseBody(name='body'),
}

async function recordBankBalanceWithOptions(request: RecordBankBalanceRequest, runtime: Util.RuntimeOptions): RecordBankBalanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionDate)) {
    query['ActionDate'] = request.actionDate;
  }
  if (!Util.isUnset(request.balance)) {
    query['Balance'] = request.balance;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RecordBankBalance',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recordBankBalance(request: RecordBankBalanceRequest): RecordBankBalanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return recordBankBalanceWithOptions(request, runtime);
}

model RefundProduceRequest {
  bizId?: string(name='BizId', example='trademark_register-cn-o400xeo7n03'),
  refundType?: string(name='RefundType'),
}

model RefundProduceResponseBody = {
  errorCode?: string(name='ErrorCode', example='PARAMETER.ILLEGALL'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId', example='810A7DB3-C18A-437F-88AF-3C46154C2B2A'),
  success?: boolean(name='Success', example='true'),
}

model RefundProduceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefundProduceResponseBody(name='body'),
}

async function refundProduceWithOptions(request: RefundProduceRequest, runtime: Util.RuntimeOptions): RefundProduceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.refundType)) {
    query['RefundType'] = request.refundType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefundProduce',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refundProduce(request: RefundProduceRequest): RefundProduceResponse {
  var runtime = new Util.RuntimeOptions{};
  return refundProduceWithOptions(request, runtime);
}

model RefuseAdditionalMaterialRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
}

model RefuseAdditionalMaterialResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RefuseAdditionalMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefuseAdditionalMaterialResponseBody(name='body'),
}

async function refuseAdditionalMaterialWithOptions(request: RefuseAdditionalMaterialRequest, runtime: Util.RuntimeOptions): RefuseAdditionalMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefuseAdditionalMaterial',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refuseAdditionalMaterial(request: RefuseAdditionalMaterialRequest): RefuseAdditionalMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return refuseAdditionalMaterialWithOptions(request, runtime);
}

model RefuseApplicantRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
}

model RefuseApplicantResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RefuseApplicantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefuseApplicantResponseBody(name='body'),
}

async function refuseApplicantWithOptions(request: RefuseApplicantRequest, runtime: Util.RuntimeOptions): RefuseApplicantResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefuseApplicant',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refuseApplicant(request: RefuseApplicantRequest): RefuseApplicantResponse {
  var runtime = new Util.RuntimeOptions{};
  return refuseApplicantWithOptions(request, runtime);
}

model RejectApplicantRequest {
  instanceId?: string(name='InstanceId'),
  note?: string(name='Note'),
}

model RejectApplicantResponseBody = {
  requestId?: string(name='RequestId'),
}

model RejectApplicantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RejectApplicantResponseBody(name='body'),
}

async function rejectApplicantWithOptions(request: RejectApplicantRequest, runtime: Util.RuntimeOptions): RejectApplicantResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RejectApplicant',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rejectApplicant(request: RejectApplicantRequest): RejectApplicantResponse {
  var runtime = new Util.RuntimeOptions{};
  return rejectApplicantWithOptions(request, runtime);
}

model SaveClassificationConditionsRequest {
  bizId?: string(name='BizId'),
  condition?: string(name='Condition'),
  type?: int32(name='Type'),
}

model SaveClassificationConditionsResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  invalidList?: [ 
    {
      classificationCode?: string(name='ClassificationCode'),
      classificationName?: string(name='ClassificationName'),
      officialCode?: string(name='OfficialCode'),
      parentCode?: string(name='ParentCode'),
    }
  ](name='InvalidList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tagName?: string(name='TagName'),
}

model SaveClassificationConditionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveClassificationConditionsResponseBody(name='body'),
}

async function saveClassificationConditionsWithOptions(request: SaveClassificationConditionsRequest, runtime: Util.RuntimeOptions): SaveClassificationConditionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.condition)) {
    query['Condition'] = request.condition;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveClassificationConditions',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveClassificationConditions(request: SaveClassificationConditionsRequest): SaveClassificationConditionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveClassificationConditionsWithOptions(request, runtime);
}

model SaveExtensionAttributeRequest {
  attributeKey?: string(name='AttributeKey'),
  attributeValue?: string(name='AttributeValue'),
  bizId?: string(name='BizId'),
}

model SaveExtensionAttributeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveExtensionAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveExtensionAttributeResponseBody(name='body'),
}

async function saveExtensionAttributeWithOptions(request: SaveExtensionAttributeRequest, runtime: Util.RuntimeOptions): SaveExtensionAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.attributeKey)) {
    query['AttributeKey'] = request.attributeKey;
  }
  if (!Util.isUnset(request.attributeValue)) {
    query['AttributeValue'] = request.attributeValue;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveExtensionAttribute',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveExtensionAttribute(request: SaveExtensionAttributeRequest): SaveExtensionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveExtensionAttributeWithOptions(request, runtime);
}

model SaveTaskRequest {
  bizType?: string(name='BizType'),
  request?: string(name='Request'),
}

model SaveTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model SaveTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTaskResponseBody(name='body'),
}

async function saveTaskWithOptions(request: SaveTaskRequest, runtime: Util.RuntimeOptions): SaveTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.request)) {
    query['Request'] = request.request;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveTask',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveTask(request: SaveTaskRequest): SaveTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskWithOptions(request, runtime);
}

model SaveTaskForOfficialFileCustomRequest {
  endAcceptTime?: long(name='EndAcceptTime'),
  startAcceptTime?: long(name='StartAcceptTime'),
}

model SaveTaskForOfficialFileCustomResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveTaskForOfficialFileCustomResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTaskForOfficialFileCustomResponseBody(name='body'),
}

async function saveTaskForOfficialFileCustomWithOptions(request: SaveTaskForOfficialFileCustomRequest, runtime: Util.RuntimeOptions): SaveTaskForOfficialFileCustomResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endAcceptTime)) {
    query['EndAcceptTime'] = request.endAcceptTime;
  }
  if (!Util.isUnset(request.startAcceptTime)) {
    query['StartAcceptTime'] = request.startAcceptTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveTaskForOfficialFileCustom',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveTaskForOfficialFileCustom(request: SaveTaskForOfficialFileCustomRequest): SaveTaskForOfficialFileCustomResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskForOfficialFileCustomWithOptions(request, runtime);
}

model SaveTradeMarkReviewMaterialDetailRequest {
  additionalOssKeyList?: map[string]any(name='AdditionalOssKeyList'),
  address?: string(name='Address'),
  applicationOssKey?: string(name='ApplicationOssKey'),
  bizId?: string(name='BizId'),
  businessLicenceOssKey?: string(name='BusinessLicenceOssKey'),
  cardNumber?: string(name='CardNumber'),
  changeName?: boolean(name='ChangeName'),
  contactAddress?: string(name='ContactAddress'),
  contactEmail?: string(name='ContactEmail'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  country?: string(name='Country'),
  engAddress?: string(name='EngAddress'),
  engName?: string(name='EngName'),
  idCardOssKey?: string(name='IdCardOssKey'),
  legalNoticeOssKey?: string(name='LegalNoticeOssKey'),
  loaOssKey?: string(name='LoaOssKey'),
  name?: string(name='Name'),
  passportOssKey?: string(name='PassportOssKey'),
  province?: string(name='Province'),
  region?: int32(name='Region'),
  reviewMaterialAdditionalJson?: string(name='ReviewMaterialAdditionalJson'),
  separate?: boolean(name='Separate'),
  submitOnline?: boolean(name='SubmitOnline'),
  submitType?: int32(name='SubmitType'),
  supplementFlag?: boolean(name='SupplementFlag'),
  type?: int32(name='Type'),
}

model SaveTradeMarkReviewMaterialDetailShrinkRequest {
  additionalOssKeyListShrink?: string(name='AdditionalOssKeyList'),
  address?: string(name='Address'),
  applicationOssKey?: string(name='ApplicationOssKey'),
  bizId?: string(name='BizId'),
  businessLicenceOssKey?: string(name='BusinessLicenceOssKey'),
  cardNumber?: string(name='CardNumber'),
  changeName?: boolean(name='ChangeName'),
  contactAddress?: string(name='ContactAddress'),
  contactEmail?: string(name='ContactEmail'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  country?: string(name='Country'),
  engAddress?: string(name='EngAddress'),
  engName?: string(name='EngName'),
  idCardOssKey?: string(name='IdCardOssKey'),
  legalNoticeOssKey?: string(name='LegalNoticeOssKey'),
  loaOssKey?: string(name='LoaOssKey'),
  name?: string(name='Name'),
  passportOssKey?: string(name='PassportOssKey'),
  province?: string(name='Province'),
  region?: int32(name='Region'),
  reviewMaterialAdditionalJson?: string(name='ReviewMaterialAdditionalJson'),
  separate?: boolean(name='Separate'),
  submitOnline?: boolean(name='SubmitOnline'),
  submitType?: int32(name='SubmitType'),
  supplementFlag?: boolean(name='SupplementFlag'),
  type?: int32(name='Type'),
}

model SaveTradeMarkReviewMaterialDetailResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveTradeMarkReviewMaterialDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTradeMarkReviewMaterialDetailResponseBody(name='body'),
}

async function saveTradeMarkReviewMaterialDetailWithOptions(tmpReq: SaveTradeMarkReviewMaterialDetailRequest, runtime: Util.RuntimeOptions): SaveTradeMarkReviewMaterialDetailResponse {
  Util.validateModel(tmpReq);
  var request = new SaveTradeMarkReviewMaterialDetailShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.additionalOssKeyList)) {
    request.additionalOssKeyListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.additionalOssKeyList, 'AdditionalOssKeyList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.additionalOssKeyListShrink)) {
    body['AdditionalOssKeyList'] = request.additionalOssKeyListShrink;
  }
  if (!Util.isUnset(request.address)) {
    body['Address'] = request.address;
  }
  if (!Util.isUnset(request.applicationOssKey)) {
    body['ApplicationOssKey'] = request.applicationOssKey;
  }
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.businessLicenceOssKey)) {
    body['BusinessLicenceOssKey'] = request.businessLicenceOssKey;
  }
  if (!Util.isUnset(request.cardNumber)) {
    body['CardNumber'] = request.cardNumber;
  }
  if (!Util.isUnset(request.changeName)) {
    body['ChangeName'] = request.changeName;
  }
  if (!Util.isUnset(request.contactAddress)) {
    body['ContactAddress'] = request.contactAddress;
  }
  if (!Util.isUnset(request.contactEmail)) {
    body['ContactEmail'] = request.contactEmail;
  }
  if (!Util.isUnset(request.contactName)) {
    body['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactNumber)) {
    body['ContactNumber'] = request.contactNumber;
  }
  if (!Util.isUnset(request.country)) {
    body['Country'] = request.country;
  }
  if (!Util.isUnset(request.engAddress)) {
    body['EngAddress'] = request.engAddress;
  }
  if (!Util.isUnset(request.engName)) {
    body['EngName'] = request.engName;
  }
  if (!Util.isUnset(request.idCardOssKey)) {
    body['IdCardOssKey'] = request.idCardOssKey;
  }
  if (!Util.isUnset(request.legalNoticeOssKey)) {
    body['LegalNoticeOssKey'] = request.legalNoticeOssKey;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    body['LoaOssKey'] = request.loaOssKey;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.passportOssKey)) {
    body['PassportOssKey'] = request.passportOssKey;
  }
  if (!Util.isUnset(request.province)) {
    body['Province'] = request.province;
  }
  if (!Util.isUnset(request.region)) {
    body['Region'] = request.region;
  }
  if (!Util.isUnset(request.reviewMaterialAdditionalJson)) {
    body['ReviewMaterialAdditionalJson'] = request.reviewMaterialAdditionalJson;
  }
  if (!Util.isUnset(request.separate)) {
    body['Separate'] = request.separate;
  }
  if (!Util.isUnset(request.submitOnline)) {
    body['SubmitOnline'] = request.submitOnline;
  }
  if (!Util.isUnset(request.submitType)) {
    body['SubmitType'] = request.submitType;
  }
  if (!Util.isUnset(request.supplementFlag)) {
    body['SupplementFlag'] = request.supplementFlag;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveTradeMarkReviewMaterialDetail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveTradeMarkReviewMaterialDetail(request: SaveTradeMarkReviewMaterialDetailRequest): SaveTradeMarkReviewMaterialDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTradeMarkReviewMaterialDetailWithOptions(request, runtime);
}

model SbjOperateRequest {
  amount?: string(name='Amount'),
  applyNo?: string(name='ApplyNo'),
  auditStatus?: boolean(name='AuditStatus'),
  bizId?: string(name='BizId'),
  fileDate?: string(name='FileDate'),
  fileOssKey?: string(name='FileOssKey'),
  message?: string(name='Message'),
  operateType?: string(name='OperateType'),
  orderNo?: string(name='OrderNo'),
  receiptOssKey?: string(name='ReceiptOssKey'),
  submittedSuccess?: boolean(name='SubmittedSuccess'),
}

model SbjOperateResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SbjOperateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SbjOperateResponseBody(name='body'),
}

async function sbjOperateWithOptions(request: SbjOperateRequest, runtime: Util.RuntimeOptions): SbjOperateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.amount)) {
    query['Amount'] = request.amount;
  }
  if (!Util.isUnset(request.applyNo)) {
    query['ApplyNo'] = request.applyNo;
  }
  if (!Util.isUnset(request.auditStatus)) {
    query['AuditStatus'] = request.auditStatus;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.fileDate)) {
    query['FileDate'] = request.fileDate;
  }
  if (!Util.isUnset(request.fileOssKey)) {
    query['FileOssKey'] = request.fileOssKey;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.orderNo)) {
    query['OrderNo'] = request.orderNo;
  }
  if (!Util.isUnset(request.receiptOssKey)) {
    query['ReceiptOssKey'] = request.receiptOssKey;
  }
  if (!Util.isUnset(request.submittedSuccess)) {
    query['SubmittedSuccess'] = request.submittedSuccess;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SbjOperate',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sbjOperate(request: SbjOperateRequest): SbjOperateResponse {
  var runtime = new Util.RuntimeOptions{};
  return sbjOperateWithOptions(request, runtime);
}

model SbjOperateNewRequest {
  addSubmitCount?: boolean(name='AddSubmitCount'),
  allowResubmit?: boolean(name='AllowResubmit'),
  amount?: string(name='Amount'),
  applyNo?: string(name='ApplyNo'),
  auditStatus?: boolean(name='AuditStatus'),
  bizId?: string(name='BizId'),
  changeStatus?: boolean(name='ChangeStatus'),
  errorMsgScreenshot?: string(name='ErrorMsgScreenshot'),
  fileDate?: string(name='FileDate'),
  fileOssKey?: string(name='FileOssKey'),
  message?: string(name='Message'),
  operateType?: string(name='OperateType'),
  orderNo?: string(name='OrderNo'),
  receiptOssKey?: string(name='ReceiptOssKey'),
  submittedSuccess?: boolean(name='SubmittedSuccess'),
  successType?: string(name='SuccessType'),
}

model SbjOperateNewResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SbjOperateNewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SbjOperateNewResponseBody(name='body'),
}

async function sbjOperateNewWithOptions(request: SbjOperateNewRequest, runtime: Util.RuntimeOptions): SbjOperateNewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addSubmitCount)) {
    query['AddSubmitCount'] = request.addSubmitCount;
  }
  if (!Util.isUnset(request.allowResubmit)) {
    query['AllowResubmit'] = request.allowResubmit;
  }
  if (!Util.isUnset(request.amount)) {
    query['Amount'] = request.amount;
  }
  if (!Util.isUnset(request.applyNo)) {
    query['ApplyNo'] = request.applyNo;
  }
  if (!Util.isUnset(request.auditStatus)) {
    query['AuditStatus'] = request.auditStatus;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.changeStatus)) {
    query['ChangeStatus'] = request.changeStatus;
  }
  if (!Util.isUnset(request.errorMsgScreenshot)) {
    query['ErrorMsgScreenshot'] = request.errorMsgScreenshot;
  }
  if (!Util.isUnset(request.fileDate)) {
    query['FileDate'] = request.fileDate;
  }
  if (!Util.isUnset(request.fileOssKey)) {
    query['FileOssKey'] = request.fileOssKey;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.orderNo)) {
    query['OrderNo'] = request.orderNo;
  }
  if (!Util.isUnset(request.receiptOssKey)) {
    query['ReceiptOssKey'] = request.receiptOssKey;
  }
  if (!Util.isUnset(request.submittedSuccess)) {
    query['SubmittedSuccess'] = request.submittedSuccess;
  }
  if (!Util.isUnset(request.successType)) {
    query['SuccessType'] = request.successType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SbjOperateNew',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sbjOperateNew(request: SbjOperateNewRequest): SbjOperateNewResponse {
  var runtime = new Util.RuntimeOptions{};
  return sbjOperateNewWithOptions(request, runtime);
}

model SbrainServiceExecuteRequest {
  executeParams?: map[string]any(name='ExecuteParams'),
  productCode?: string(name='ProductCode'),
  referenceNo?: string(name='ReferenceNo'),
  referenceType?: string(name='ReferenceType'),
  sceneCode?: string(name='SceneCode'),
  schemeId?: long(name='SchemeId'),
  servicePlace?: string(name='ServicePlace'),
  source?: string(name='Source'),
  target?: string(name='Target'),
}

model SbrainServiceExecuteShrinkRequest {
  executeParamsShrink?: string(name='ExecuteParams'),
  productCode?: string(name='ProductCode'),
  referenceNo?: string(name='ReferenceNo'),
  referenceType?: string(name='ReferenceType'),
  sceneCode?: string(name='SceneCode'),
  schemeId?: long(name='SchemeId'),
  servicePlace?: string(name='ServicePlace'),
  source?: string(name='Source'),
  target?: string(name='Target'),
}

model SbrainServiceExecuteResponseBody = {
  data?: any(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SbrainServiceExecuteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SbrainServiceExecuteResponseBody(name='body'),
}

async function sbrainServiceExecuteWithOptions(tmpReq: SbrainServiceExecuteRequest, runtime: Util.RuntimeOptions): SbrainServiceExecuteResponse {
  Util.validateModel(tmpReq);
  var request = new SbrainServiceExecuteShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.executeParams)) {
    request.executeParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.executeParams, 'ExecuteParams', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.executeParamsShrink)) {
    query['ExecuteParams'] = request.executeParamsShrink;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.referenceNo)) {
    query['ReferenceNo'] = request.referenceNo;
  }
  if (!Util.isUnset(request.referenceType)) {
    query['ReferenceType'] = request.referenceType;
  }
  if (!Util.isUnset(request.sceneCode)) {
    query['SceneCode'] = request.sceneCode;
  }
  if (!Util.isUnset(request.schemeId)) {
    query['SchemeId'] = request.schemeId;
  }
  if (!Util.isUnset(request.servicePlace)) {
    query['ServicePlace'] = request.servicePlace;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SbrainServiceExecute',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sbrainServiceExecute(request: SbrainServiceExecuteRequest): SbrainServiceExecuteResponse {
  var runtime = new Util.RuntimeOptions{};
  return sbrainServiceExecuteWithOptions(request, runtime);
}

model SbrainServiceHasRunningTaskBatchQueryRequest {
  productCode?: string(name='ProductCode'),
  referenceNos?: [ string ](name='ReferenceNos'),
  referenceType?: string(name='ReferenceType'),
  source?: string(name='Source'),
  taskType?: string(name='TaskType'),
}

model SbrainServiceHasRunningTaskBatchQueryShrinkRequest {
  productCode?: string(name='ProductCode'),
  referenceNosShrink?: string(name='ReferenceNos'),
  referenceType?: string(name='ReferenceType'),
  source?: string(name='Source'),
  taskType?: string(name='TaskType'),
}

model SbrainServiceHasRunningTaskBatchQueryResponseBody = {
  data?: any(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SbrainServiceHasRunningTaskBatchQueryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SbrainServiceHasRunningTaskBatchQueryResponseBody(name='body'),
}

async function sbrainServiceHasRunningTaskBatchQueryWithOptions(tmpReq: SbrainServiceHasRunningTaskBatchQueryRequest, runtime: Util.RuntimeOptions): SbrainServiceHasRunningTaskBatchQueryResponse {
  Util.validateModel(tmpReq);
  var request = new SbrainServiceHasRunningTaskBatchQueryShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.referenceNos)) {
    request.referenceNosShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.referenceNos, 'ReferenceNos', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.referenceNosShrink)) {
    query['ReferenceNos'] = request.referenceNosShrink;
  }
  if (!Util.isUnset(request.referenceType)) {
    query['ReferenceType'] = request.referenceType;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SbrainServiceHasRunningTaskBatchQuery',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sbrainServiceHasRunningTaskBatchQuery(request: SbrainServiceHasRunningTaskBatchQueryRequest): SbrainServiceHasRunningTaskBatchQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  return sbrainServiceHasRunningTaskBatchQueryWithOptions(request, runtime);
}

model SbrainServiceSchemeMatchRequest {
  matchParams?: map[string]any(name='MatchParams'),
  productCode?: string(name='ProductCode'),
  referenceNo?: string(name='ReferenceNo'),
  referenceType?: string(name='ReferenceType'),
  sceneCode?: string(name='SceneCode'),
  source?: string(name='Source'),
}

model SbrainServiceSchemeMatchShrinkRequest {
  matchParamsShrink?: string(name='MatchParams'),
  productCode?: string(name='ProductCode'),
  referenceNo?: string(name='ReferenceNo'),
  referenceType?: string(name='ReferenceType'),
  sceneCode?: string(name='SceneCode'),
  source?: string(name='Source'),
}

model SbrainServiceSchemeMatchResponseBody = {
  data?: {
    sceneCode?: string(name='SceneCode'),
    schemeContent?: {
      contentIndex?: int32(name='ContentIndex'),
      contentModules?: [ 
        {
          tag?: string(name='Tag'),
          action?: string(name='action'),
          moduleData?: string(name='moduleData'),
          moduleDataSource?: string(name='moduleDataSource'),
          moduleDataSourceType?: string(name='moduleDataSourceType'),
          name?: string(name='name'),
          target?: string(name='target'),
        }
      ](name='ContentModules'),
      display?: string(name='Display'),
    }(name='SchemeContent'),
    schemeId?: long(name='SchemeId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SbrainServiceSchemeMatchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SbrainServiceSchemeMatchResponseBody(name='body'),
}

async function sbrainServiceSchemeMatchWithOptions(tmpReq: SbrainServiceSchemeMatchRequest, runtime: Util.RuntimeOptions): SbrainServiceSchemeMatchResponse {
  Util.validateModel(tmpReq);
  var request = new SbrainServiceSchemeMatchShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.matchParams)) {
    request.matchParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.matchParams, 'MatchParams', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.matchParamsShrink)) {
    query['MatchParams'] = request.matchParamsShrink;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.referenceNo)) {
    query['ReferenceNo'] = request.referenceNo;
  }
  if (!Util.isUnset(request.referenceType)) {
    query['ReferenceType'] = request.referenceType;
  }
  if (!Util.isUnset(request.sceneCode)) {
    query['SceneCode'] = request.sceneCode;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SbrainServiceSchemeMatch',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sbrainServiceSchemeMatch(request: SbrainServiceSchemeMatchRequest): SbrainServiceSchemeMatchResponse {
  var runtime = new Util.RuntimeOptions{};
  return sbrainServiceSchemeMatchWithOptions(request, runtime);
}

model SearchTmOnsalesRequest {
  classification?: string(name='Classification'),
  keyword?: string(name='Keyword'),
  orderPriceLeft?: long(name='OrderPriceLeft'),
  orderPriceRight?: long(name='OrderPriceRight'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  productCode?: string(name='ProductCode'),
  queryAll?: boolean(name='QueryAll'),
  regLeft?: int32(name='RegLeft'),
  regRight?: int32(name='RegRight'),
  registerNumber?: string(name='RegisterNumber'),
  sortName?: string(name='SortName'),
  sortOrder?: string(name='SortOrder'),
  tag?: string(name='Tag'),
  tmName?: string(name='TmName'),
  topSearch?: string(name='TopSearch'),
}

model SearchTmOnsalesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  totalPageNumber?: int32(name='TotalPageNumber'),
  trademarks?: [ 
    {
      classification?: string(name='Classification'),
      icon?: string(name='Icon'),
      orderPrice?: string(name='OrderPrice'),
      partnerCode?: string(name='PartnerCode'),
      productCode?: string(name='ProductCode'),
      productDesc?: string(name='ProductDesc'),
      registrationNumber?: string(name='RegistrationNumber'),
      status?: long(name='Status'),
      trademarkName?: string(name='TrademarkName'),
      uid?: string(name='Uid'),
    }
  ](name='Trademarks'),
}

model SearchTmOnsalesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTmOnsalesResponseBody(name='body'),
}

async function searchTmOnsalesWithOptions(request: SearchTmOnsalesRequest, runtime: Util.RuntimeOptions): SearchTmOnsalesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.classification)) {
    query['Classification'] = request.classification;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.orderPriceLeft)) {
    query['OrderPriceLeft'] = request.orderPriceLeft;
  }
  if (!Util.isUnset(request.orderPriceRight)) {
    query['OrderPriceRight'] = request.orderPriceRight;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.queryAll)) {
    query['QueryAll'] = request.queryAll;
  }
  if (!Util.isUnset(request.regLeft)) {
    query['RegLeft'] = request.regLeft;
  }
  if (!Util.isUnset(request.regRight)) {
    query['RegRight'] = request.regRight;
  }
  if (!Util.isUnset(request.registerNumber)) {
    query['RegisterNumber'] = request.registerNumber;
  }
  if (!Util.isUnset(request.sortName)) {
    query['SortName'] = request.sortName;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.topSearch)) {
    query['TopSearch'] = request.topSearch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchTmOnsales',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTmOnsales(request: SearchTmOnsalesRequest): SearchTmOnsalesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTmOnsalesWithOptions(request, runtime);
}

model StartNotaryRequest {
  notaryOrderId?: long(name='NotaryOrderId'),
}

model StartNotaryResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  notaryUrl?: string(name='NotaryUrl'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartNotaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartNotaryResponseBody(name='body'),
}

async function startNotaryWithOptions(request: StartNotaryRequest, runtime: Util.RuntimeOptions): StartNotaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.notaryOrderId)) {
    query['NotaryOrderId'] = request.notaryOrderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartNotary',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startNotary(request: StartNotaryRequest): StartNotaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return startNotaryWithOptions(request, runtime);
}

model StoreMaterialTemporarilyRequest {
  address?: string(name='Address'),
  businessLicenceOssKey?: string(name='BusinessLicenceOssKey'),
  cardNumber?: string(name='CardNumber'),
  city?: string(name='City'),
  contactAddress?: string(name='ContactAddress'),
  contactCity?: string(name='ContactCity'),
  contactCounty?: string(name='ContactCounty'),
  contactDistrict?: string(name='ContactDistrict'),
  contactEmail?: string(name='ContactEmail'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactProvince?: string(name='ContactProvince'),
  contactZipcode?: string(name='ContactZipcode'),
  country?: string(name='Country'),
  EAddress?: string(name='EAddress'),
  EName?: string(name='EName'),
  idCardName?: string(name='IdCardName'),
  idCardNumber?: string(name='IdCardNumber'),
  idCardOssKey?: string(name='IdCardOssKey'),
  legalNoticeOssKey?: string(name='LegalNoticeOssKey'),
  loaOssKey?: string(name='LoaOssKey'),
  name?: string(name='Name'),
  passportOssKey?: string(name='PassportOssKey'),
  personalType?: long(name='PersonalType'),
  principalName?: int32(name='PrincipalName'),
  province?: string(name='Province'),
  region?: string(name='Region'),
  town?: string(name='Town'),
  type?: string(name='Type'),
}

model StoreMaterialTemporarilyResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StoreMaterialTemporarilyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StoreMaterialTemporarilyResponseBody(name='body'),
}

async function storeMaterialTemporarilyWithOptions(request: StoreMaterialTemporarilyRequest, runtime: Util.RuntimeOptions): StoreMaterialTemporarilyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.businessLicenceOssKey)) {
    query['BusinessLicenceOssKey'] = request.businessLicenceOssKey;
  }
  if (!Util.isUnset(request.cardNumber)) {
    query['CardNumber'] = request.cardNumber;
  }
  if (!Util.isUnset(request.city)) {
    query['City'] = request.city;
  }
  if (!Util.isUnset(request.contactAddress)) {
    query['ContactAddress'] = request.contactAddress;
  }
  if (!Util.isUnset(request.contactCity)) {
    query['ContactCity'] = request.contactCity;
  }
  if (!Util.isUnset(request.contactCounty)) {
    query['ContactCounty'] = request.contactCounty;
  }
  if (!Util.isUnset(request.contactDistrict)) {
    query['ContactDistrict'] = request.contactDistrict;
  }
  if (!Util.isUnset(request.contactEmail)) {
    query['ContactEmail'] = request.contactEmail;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactNumber)) {
    query['ContactNumber'] = request.contactNumber;
  }
  if (!Util.isUnset(request.contactProvince)) {
    query['ContactProvince'] = request.contactProvince;
  }
  if (!Util.isUnset(request.contactZipcode)) {
    query['ContactZipcode'] = request.contactZipcode;
  }
  if (!Util.isUnset(request.country)) {
    query['Country'] = request.country;
  }
  if (!Util.isUnset(request.EAddress)) {
    query['EAddress'] = request.EAddress;
  }
  if (!Util.isUnset(request.EName)) {
    query['EName'] = request.EName;
  }
  if (!Util.isUnset(request.idCardName)) {
    query['IdCardName'] = request.idCardName;
  }
  if (!Util.isUnset(request.idCardNumber)) {
    query['IdCardNumber'] = request.idCardNumber;
  }
  if (!Util.isUnset(request.idCardOssKey)) {
    query['IdCardOssKey'] = request.idCardOssKey;
  }
  if (!Util.isUnset(request.legalNoticeOssKey)) {
    query['LegalNoticeOssKey'] = request.legalNoticeOssKey;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    query['LoaOssKey'] = request.loaOssKey;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.passportOssKey)) {
    query['PassportOssKey'] = request.passportOssKey;
  }
  if (!Util.isUnset(request.personalType)) {
    query['PersonalType'] = request.personalType;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  if (!Util.isUnset(request.province)) {
    query['Province'] = request.province;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.town)) {
    query['Town'] = request.town;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StoreMaterialTemporarily',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function storeMaterialTemporarily(request: StoreMaterialTemporarilyRequest): StoreMaterialTemporarilyResponse {
  var runtime = new Util.RuntimeOptions{};
  return storeMaterialTemporarilyWithOptions(request, runtime);
}

model SubmitSupplementRequest {
  content?: string(name='Content'),
  id?: long(name='Id'),
  operateType?: string(name='OperateType'),
  uploadOssKeyList?: map[string]any(name='UploadOssKeyList'),
}

model SubmitSupplementShrinkRequest {
  content?: string(name='Content'),
  id?: long(name='Id'),
  operateType?: string(name='OperateType'),
  uploadOssKeyListShrink?: string(name='UploadOssKeyList'),
}

model SubmitSupplementResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubmitSupplementResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitSupplementResponseBody(name='body'),
}

async function submitSupplementWithOptions(tmpReq: SubmitSupplementRequest, runtime: Util.RuntimeOptions): SubmitSupplementResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitSupplementShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.uploadOssKeyList)) {
    request.uploadOssKeyListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.uploadOssKeyList, 'UploadOssKeyList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.uploadOssKeyListShrink)) {
    query['UploadOssKeyList'] = request.uploadOssKeyListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitSupplement',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitSupplement(request: SubmitSupplementRequest): SubmitSupplementResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSupplementWithOptions(request, runtime);
}

model SubmitTrademarkApplicationComplaintRequest {
  bizId?: string(name='BizId'),
  content?: string(name='Content'),
  files?: map[string]any(name='Files'),
}

model SubmitTrademarkApplicationComplaintShrinkRequest {
  bizId?: string(name='BizId'),
  content?: string(name='Content'),
  filesShrink?: string(name='Files'),
}

model SubmitTrademarkApplicationComplaintResponseBody = {
  requestId?: string(name='RequestId'),
}

model SubmitTrademarkApplicationComplaintResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitTrademarkApplicationComplaintResponseBody(name='body'),
}

async function submitTrademarkApplicationComplaintWithOptions(tmpReq: SubmitTrademarkApplicationComplaintRequest, runtime: Util.RuntimeOptions): SubmitTrademarkApplicationComplaintResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitTrademarkApplicationComplaintShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.files)) {
    request.filesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.files, 'Files', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.filesShrink)) {
    query['Files'] = request.filesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitTrademarkApplicationComplaint',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitTrademarkApplicationComplaint(request: SubmitTrademarkApplicationComplaintRequest): SubmitTrademarkApplicationComplaintResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitTrademarkApplicationComplaintWithOptions(request, runtime);
}

model SyncTrademarkRequest {
  beginTime?: long(name='BeginTime'),
  classificationCode?: string(name='ClassificationCode'),
  description?: string(name='Description'),
  endTime?: long(name='EndTime'),
  label?: string(name='Label'),
  originalPrice?: float(name='OriginalPrice'),
  ownerEnName?: string(name='OwnerEnName'),
  ownerName?: string(name='OwnerName'),
  reason?: string(name='Reason'),
  regAnnDate?: long(name='RegAnnDate'),
  secondaryClassification?: string(name='SecondaryClassification'),
  status?: string(name='Status'),
  thirdClassification?: string(name='ThirdClassification'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  tmNumber?: string(name='TmNumber'),
  type?: string(name='Type'),
}

model SyncTrademarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model SyncTrademarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SyncTrademarkResponseBody(name='body'),
}

async function syncTrademarkWithOptions(request: SyncTrademarkRequest, runtime: Util.RuntimeOptions): SyncTrademarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.classificationCode)) {
    query['ClassificationCode'] = request.classificationCode;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.label)) {
    query['Label'] = request.label;
  }
  if (!Util.isUnset(request.originalPrice)) {
    query['OriginalPrice'] = request.originalPrice;
  }
  if (!Util.isUnset(request.ownerEnName)) {
    query['OwnerEnName'] = request.ownerEnName;
  }
  if (!Util.isUnset(request.ownerName)) {
    query['OwnerName'] = request.ownerName;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.regAnnDate)) {
    query['RegAnnDate'] = request.regAnnDate;
  }
  if (!Util.isUnset(request.secondaryClassification)) {
    query['SecondaryClassification'] = request.secondaryClassification;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.thirdClassification)) {
    query['ThirdClassification'] = request.thirdClassification;
  }
  if (!Util.isUnset(request.tmIcon)) {
    query['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNumber)) {
    query['TmNumber'] = request.tmNumber;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SyncTrademark',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function syncTrademark(request: SyncTrademarkRequest): SyncTrademarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncTrademarkWithOptions(request, runtime);
}

model UpdateApplicantContacterRequest {
  applicantId?: long(name='ApplicantId'),
  bizId?: string(name='BizId'),
  contactAddress?: string(name='ContactAddress'),
  contactCity?: string(name='ContactCity'),
  contactDistrict?: string(name='ContactDistrict'),
  contactEmail?: string(name='ContactEmail'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactProvince?: string(name='ContactProvince'),
  contactZipCode?: string(name='ContactZipCode'),
}

model UpdateApplicantContacterResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateApplicantContacterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApplicantContacterResponseBody(name='body'),
}

async function updateApplicantContacterWithOptions(request: UpdateApplicantContacterRequest, runtime: Util.RuntimeOptions): UpdateApplicantContacterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicantId)) {
    query['ApplicantId'] = request.applicantId;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.contactAddress)) {
    query['ContactAddress'] = request.contactAddress;
  }
  if (!Util.isUnset(request.contactCity)) {
    query['ContactCity'] = request.contactCity;
  }
  if (!Util.isUnset(request.contactDistrict)) {
    query['ContactDistrict'] = request.contactDistrict;
  }
  if (!Util.isUnset(request.contactEmail)) {
    query['ContactEmail'] = request.contactEmail;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactNumber)) {
    query['ContactNumber'] = request.contactNumber;
  }
  if (!Util.isUnset(request.contactProvince)) {
    query['ContactProvince'] = request.contactProvince;
  }
  if (!Util.isUnset(request.contactZipCode)) {
    query['ContactZipCode'] = request.contactZipCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApplicantContacter',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateApplicantContacter(request: UpdateApplicantContacterRequest): UpdateApplicantContacterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateApplicantContacterWithOptions(request, runtime);
}

model UpdateMaterialRequest {
  address?: string(name='Address'),
  businessLicenceOssKey?: string(name='BusinessLicenceOssKey'),
  cardNumber?: string(name='CardNumber'),
  city?: string(name='City'),
  contactAddress?: string(name='ContactAddress'),
  contactCity?: string(name='ContactCity'),
  contactCounty?: string(name='ContactCounty'),
  contactDistrict?: string(name='ContactDistrict'),
  contactEmail?: string(name='ContactEmail'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactProvince?: string(name='ContactProvince'),
  contactZipcode?: string(name='ContactZipcode'),
  EAddress?: string(name='EAddress'),
  EName?: string(name='EName'),
  id?: long(name='Id'),
  idCardName?: string(name='IdCardName'),
  idCardNumber?: string(name='IdCardNumber'),
  idCardOssKey?: string(name='IdCardOssKey'),
  legalNoticeOssKey?: string(name='LegalNoticeOssKey'),
  loaId?: long(name='LoaId'),
  loaOssKey?: string(name='LoaOssKey'),
  name?: string(name='Name'),
  passportOssKey?: string(name='PassportOssKey'),
  personalType?: long(name='PersonalType'),
  province?: string(name='Province'),
  town?: string(name='Town'),
}

model UpdateMaterialResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMaterialResponseBody(name='body'),
}

async function updateMaterialWithOptions(request: UpdateMaterialRequest, runtime: Util.RuntimeOptions): UpdateMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.businessLicenceOssKey)) {
    query['BusinessLicenceOssKey'] = request.businessLicenceOssKey;
  }
  if (!Util.isUnset(request.cardNumber)) {
    query['CardNumber'] = request.cardNumber;
  }
  if (!Util.isUnset(request.city)) {
    query['City'] = request.city;
  }
  if (!Util.isUnset(request.contactAddress)) {
    query['ContactAddress'] = request.contactAddress;
  }
  if (!Util.isUnset(request.contactCity)) {
    query['ContactCity'] = request.contactCity;
  }
  if (!Util.isUnset(request.contactCounty)) {
    query['ContactCounty'] = request.contactCounty;
  }
  if (!Util.isUnset(request.contactDistrict)) {
    query['ContactDistrict'] = request.contactDistrict;
  }
  if (!Util.isUnset(request.contactEmail)) {
    query['ContactEmail'] = request.contactEmail;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactNumber)) {
    query['ContactNumber'] = request.contactNumber;
  }
  if (!Util.isUnset(request.contactProvince)) {
    query['ContactProvince'] = request.contactProvince;
  }
  if (!Util.isUnset(request.contactZipcode)) {
    query['ContactZipcode'] = request.contactZipcode;
  }
  if (!Util.isUnset(request.EAddress)) {
    query['EAddress'] = request.EAddress;
  }
  if (!Util.isUnset(request.EName)) {
    query['EName'] = request.EName;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.idCardName)) {
    query['IdCardName'] = request.idCardName;
  }
  if (!Util.isUnset(request.idCardNumber)) {
    query['IdCardNumber'] = request.idCardNumber;
  }
  if (!Util.isUnset(request.idCardOssKey)) {
    query['IdCardOssKey'] = request.idCardOssKey;
  }
  if (!Util.isUnset(request.legalNoticeOssKey)) {
    query['LegalNoticeOssKey'] = request.legalNoticeOssKey;
  }
  if (!Util.isUnset(request.loaId)) {
    query['LoaId'] = request.loaId;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    query['LoaOssKey'] = request.loaOssKey;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.passportOssKey)) {
    query['PassportOssKey'] = request.passportOssKey;
  }
  if (!Util.isUnset(request.personalType)) {
    query['PersonalType'] = request.personalType;
  }
  if (!Util.isUnset(request.province)) {
    query['Province'] = request.province;
  }
  if (!Util.isUnset(request.town)) {
    query['Town'] = request.town;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMaterial',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMaterial(request: UpdateMaterialRequest): UpdateMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMaterialWithOptions(request, runtime);
}

model UpdateProduceRequest {
  bizId?: string(name='BizId'),
  bizType?: string(name='BizType'),
  extMap?: string(name='ExtMap'),
}

model UpdateProduceResponseBody = {
  requestId?: string(name='requestId'),
}

model UpdateProduceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProduceResponseBody(name='body'),
}

async function updateProduceWithOptions(request: UpdateProduceRequest, runtime: Util.RuntimeOptions): UpdateProduceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.extMap)) {
    query['ExtMap'] = request.extMap;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProduce',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProduce(request: UpdateProduceRequest): UpdateProduceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProduceWithOptions(request, runtime);
}

model UpdateProduceLoaIdRequest {
  bizId?: string(name='BizId'),
  loaOssKey?: string(name='LoaOssKey'),
}

model UpdateProduceLoaIdResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateProduceLoaIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProduceLoaIdResponseBody(name='body'),
}

async function updateProduceLoaIdWithOptions(request: UpdateProduceLoaIdRequest, runtime: Util.RuntimeOptions): UpdateProduceLoaIdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    body['LoaOssKey'] = request.loaOssKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProduceLoaId',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProduceLoaId(request: UpdateProduceLoaIdRequest): UpdateProduceLoaIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProduceLoaIdWithOptions(request, runtime);
}

model UpdateSendMaterialNumRequest {
  bizId?: string(name='BizId'),
  num?: string(name='Num'),
  operateType?: int32(name='OperateType'),
}

model UpdateSendMaterialNumResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSendMaterialNumResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSendMaterialNumResponseBody(name='body'),
}

async function updateSendMaterialNumWithOptions(request: UpdateSendMaterialNumRequest, runtime: Util.RuntimeOptions): UpdateSendMaterialNumResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.num)) {
    query['Num'] = request.num;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSendMaterialNum',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSendMaterialNum(request: UpdateSendMaterialNumRequest): UpdateSendMaterialNumResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSendMaterialNumWithOptions(request, runtime);
}

model UpdateTrademarkNameRequest {
  bizId?: string(name='BizId'),
  clientToken?: string(name='ClientToken'),
  tmComment?: string(name='TmComment'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  type?: long(name='Type'),
}

model UpdateTrademarkNameResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateTrademarkNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTrademarkNameResponseBody(name='body'),
}

async function updateTrademarkNameWithOptions(request: UpdateTrademarkNameRequest, runtime: Util.RuntimeOptions): UpdateTrademarkNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.tmComment)) {
    body['TmComment'] = request.tmComment;
  }
  if (!Util.isUnset(request.tmIcon)) {
    body['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    body['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrademarkName',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTrademarkName(request: UpdateTrademarkNameRequest): UpdateTrademarkNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTrademarkNameWithOptions(request, runtime);
}

model UpdateTrademarkOnsaleRequest {
  beginTime?: long(name='BeginTime'),
  classificationCode?: string(name='ClassificationCode'),
  description?: string(name='Description'),
  endTime?: long(name='EndTime'),
  label?: string(name='Label'),
  originalPrice?: float(name='OriginalPrice'),
  ownerEnName?: string(name='OwnerEnName'),
  ownerName?: string(name='OwnerName'),
  reason?: string(name='Reason'),
  regAnnDate?: long(name='RegAnnDate'),
  secondaryClassification?: string(name='SecondaryClassification'),
  thirdClassification?: string(name='ThirdClassification'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  tmNumber?: string(name='TmNumber'),
  tmType?: string(name='TmType'),
  tradeTmDetailJson?: string(name='TradeTmDetailJson'),
  type?: string(name='Type'),
}

model UpdateTrademarkOnsaleResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTrademarkOnsaleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTrademarkOnsaleResponseBody(name='body'),
}

async function updateTrademarkOnsaleWithOptions(request: UpdateTrademarkOnsaleRequest, runtime: Util.RuntimeOptions): UpdateTrademarkOnsaleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.classificationCode)) {
    query['ClassificationCode'] = request.classificationCode;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.label)) {
    query['Label'] = request.label;
  }
  if (!Util.isUnset(request.originalPrice)) {
    query['OriginalPrice'] = request.originalPrice;
  }
  if (!Util.isUnset(request.ownerEnName)) {
    query['OwnerEnName'] = request.ownerEnName;
  }
  if (!Util.isUnset(request.ownerName)) {
    query['OwnerName'] = request.ownerName;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.regAnnDate)) {
    query['RegAnnDate'] = request.regAnnDate;
  }
  if (!Util.isUnset(request.secondaryClassification)) {
    query['SecondaryClassification'] = request.secondaryClassification;
  }
  if (!Util.isUnset(request.thirdClassification)) {
    query['ThirdClassification'] = request.thirdClassification;
  }
  if (!Util.isUnset(request.tmIcon)) {
    query['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNumber)) {
    query['TmNumber'] = request.tmNumber;
  }
  if (!Util.isUnset(request.tmType)) {
    query['TmType'] = request.tmType;
  }
  if (!Util.isUnset(request.tradeTmDetailJson)) {
    query['TradeTmDetailJson'] = request.tradeTmDetailJson;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrademarkOnsale',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTrademarkOnsale(request: UpdateTrademarkOnsaleRequest): UpdateTrademarkOnsaleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTrademarkOnsaleWithOptions(request, runtime);
}

model UploadNotaryDataRequest {
  bizOrderNo?: string(name='BizOrderNo'),
  notaryType?: int32(name='NotaryType'),
  uploadContext?: string(name='UploadContext'),
}

model UploadNotaryDataResponseBody = {
  requestId?: string(name='RequestId'),
  userAuthUrl?: string(name='UserAuthUrl'),
}

model UploadNotaryDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadNotaryDataResponseBody(name='body'),
}

async function uploadNotaryDataWithOptions(request: UploadNotaryDataRequest, runtime: Util.RuntimeOptions): UploadNotaryDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizOrderNo)) {
    query['BizOrderNo'] = request.bizOrderNo;
  }
  if (!Util.isUnset(request.notaryType)) {
    query['NotaryType'] = request.notaryType;
  }
  if (!Util.isUnset(request.uploadContext)) {
    query['UploadContext'] = request.uploadContext;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadNotaryData',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadNotaryData(request: UploadNotaryDataRequest): UploadNotaryDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadNotaryDataWithOptions(request, runtime);
}

model UploadTrademarkOnSaleRequest {
  beginTime?: long(name='BeginTime'),
  classificationCode?: string(name='ClassificationCode'),
  description?: string(name='Description'),
  endTime?: long(name='EndTime'),
  label?: string(name='Label'),
  originalPrice?: float(name='OriginalPrice'),
  ownerEnName?: string(name='OwnerEnName'),
  ownerName?: string(name='OwnerName'),
  reason?: string(name='Reason'),
  regAnnDate?: long(name='RegAnnDate'),
  secondaryClassification?: string(name='SecondaryClassification'),
  status?: string(name='Status'),
  thirdClassification?: string(name='ThirdClassification'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  tmNumber?: string(name='TmNumber'),
  tmType?: string(name='TmType'),
  tradeTmDetailJson?: string(name='TradeTmDetailJson'),
  type?: string(name='Type'),
}

model UploadTrademarkOnSaleResponseBody = {
  requestId?: string(name='RequestId'),
}

model UploadTrademarkOnSaleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadTrademarkOnSaleResponseBody(name='body'),
}

async function uploadTrademarkOnSaleWithOptions(request: UploadTrademarkOnSaleRequest, runtime: Util.RuntimeOptions): UploadTrademarkOnSaleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.classificationCode)) {
    query['ClassificationCode'] = request.classificationCode;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.label)) {
    query['Label'] = request.label;
  }
  if (!Util.isUnset(request.originalPrice)) {
    query['OriginalPrice'] = request.originalPrice;
  }
  if (!Util.isUnset(request.ownerEnName)) {
    query['OwnerEnName'] = request.ownerEnName;
  }
  if (!Util.isUnset(request.ownerName)) {
    query['OwnerName'] = request.ownerName;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.regAnnDate)) {
    query['RegAnnDate'] = request.regAnnDate;
  }
  if (!Util.isUnset(request.secondaryClassification)) {
    query['SecondaryClassification'] = request.secondaryClassification;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.thirdClassification)) {
    query['ThirdClassification'] = request.thirdClassification;
  }
  if (!Util.isUnset(request.tmIcon)) {
    query['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNumber)) {
    query['TmNumber'] = request.tmNumber;
  }
  if (!Util.isUnset(request.tmType)) {
    query['TmType'] = request.tmType;
  }
  if (!Util.isUnset(request.tradeTmDetailJson)) {
    query['TradeTmDetailJson'] = request.tradeTmDetailJson;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadTrademarkOnSale',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadTrademarkOnSale(request: UploadTrademarkOnSaleRequest): UploadTrademarkOnSaleResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadTrademarkOnSaleWithOptions(request, runtime);
}

model WriteCommunicationLogRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
  targetId?: string(name='TargetId'),
}

model WriteCommunicationLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model WriteCommunicationLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: WriteCommunicationLogResponseBody(name='body'),
}

async function writeCommunicationLogWithOptions(request: WriteCommunicationLogRequest, runtime: Util.RuntimeOptions): WriteCommunicationLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'WriteCommunicationLog',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function writeCommunicationLog(request: WriteCommunicationLogRequest): WriteCommunicationLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return writeCommunicationLogWithOptions(request, runtime);
}

model WriteIntentionCommunicationLogRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
  reject?: boolean(name='Reject'),
}

model WriteIntentionCommunicationLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model WriteIntentionCommunicationLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: WriteIntentionCommunicationLogResponseBody(name='body'),
}

async function writeIntentionCommunicationLogWithOptions(request: WriteIntentionCommunicationLogRequest, runtime: Util.RuntimeOptions): WriteIntentionCommunicationLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  if (!Util.isUnset(request.reject)) {
    query['Reject'] = request.reject;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'WriteIntentionCommunicationLog',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function writeIntentionCommunicationLog(request: WriteIntentionCommunicationLogRequest): WriteIntentionCommunicationLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return writeIntentionCommunicationLogWithOptions(request, runtime);
}

