/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('trademark', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AcceptPartnerNotificationRequest {
  bizId?: string(name='BizId'),
  material?: string(name='Material'),
  operation?: string(name='Operation'),
  remark?: string(name='Remark'),
}

model AcceptPartnerNotificationResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AcceptPartnerNotificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AcceptPartnerNotificationResponseBody(name='body'),
}

async function acceptPartnerNotificationWithOptions(request: AcceptPartnerNotificationRequest, runtime: Util.RuntimeOptions): AcceptPartnerNotificationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.material)) {
    query['Material'] = request.material;
  }
  if (!Util.isUnset(request.operation)) {
    query['Operation'] = request.operation;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AcceptPartnerNotification',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function acceptPartnerNotification(request: AcceptPartnerNotificationRequest): AcceptPartnerNotificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return acceptPartnerNotificationWithOptions(request, runtime);
}

model ApplyNotaryPostRequest {
  notaryOrderId?: long(name='NotaryOrderId'),
  receiverAddress?: string(name='ReceiverAddress'),
  receiverName?: string(name='ReceiverName'),
  receiverPhone?: string(name='ReceiverPhone'),
}

model ApplyNotaryPostResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ApplyNotaryPostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyNotaryPostResponseBody(name='body'),
}

async function applyNotaryPostWithOptions(request: ApplyNotaryPostRequest, runtime: Util.RuntimeOptions): ApplyNotaryPostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.notaryOrderId)) {
    query['NotaryOrderId'] = request.notaryOrderId;
  }
  if (!Util.isUnset(request.receiverAddress)) {
    query['ReceiverAddress'] = request.receiverAddress;
  }
  if (!Util.isUnset(request.receiverName)) {
    query['ReceiverName'] = request.receiverName;
  }
  if (!Util.isUnset(request.receiverPhone)) {
    query['ReceiverPhone'] = request.receiverPhone;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyNotaryPost',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyNotaryPost(request: ApplyNotaryPostRequest): ApplyNotaryPostResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyNotaryPostWithOptions(request, runtime);
}

model AskAdjudicationFileRequest {
  bizId?: string(name='BizId'),
  contactAddress?: string(name='ContactAddress'),
  contactCity?: string(name='ContactCity'),
  contactCounty?: string(name='ContactCounty'),
  contactDistrict?: string(name='ContactDistrict'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactProvince?: string(name='ContactProvince'),
}

model AskAdjudicationFileResponseBody = {
  requestId?: string(name='RequestId'),
}

model AskAdjudicationFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AskAdjudicationFileResponseBody(name='body'),
}

async function askAdjudicationFileWithOptions(request: AskAdjudicationFileRequest, runtime: Util.RuntimeOptions): AskAdjudicationFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.contactAddress)) {
    query['ContactAddress'] = request.contactAddress;
  }
  if (!Util.isUnset(request.contactCity)) {
    query['ContactCity'] = request.contactCity;
  }
  if (!Util.isUnset(request.contactCounty)) {
    query['ContactCounty'] = request.contactCounty;
  }
  if (!Util.isUnset(request.contactDistrict)) {
    query['ContactDistrict'] = request.contactDistrict;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactNumber)) {
    query['ContactNumber'] = request.contactNumber;
  }
  if (!Util.isUnset(request.contactProvince)) {
    query['ContactProvince'] = request.contactProvince;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AskAdjudicationFile',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function askAdjudicationFile(request: AskAdjudicationFileRequest): AskAdjudicationFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return askAdjudicationFileWithOptions(request, runtime);
}

model BindMaterialRequest {
  bizId?: string(name='BizId'),
  legalNoticeKey?: string(name='LegalNoticeKey'),
  loaOssKey?: string(name='LoaOssKey'),
  materialId?: string(name='MaterialId'),
}

model BindMaterialResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindMaterialResponseBody(name='body'),
}

async function bindMaterialWithOptions(request: BindMaterialRequest, runtime: Util.RuntimeOptions): BindMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.legalNoticeKey)) {
    query['LegalNoticeKey'] = request.legalNoticeKey;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    query['LoaOssKey'] = request.loaOssKey;
  }
  if (!Util.isUnset(request.materialId)) {
    query['MaterialId'] = request.materialId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindMaterial',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindMaterial(request: BindMaterialRequest): BindMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindMaterialWithOptions(request, runtime);
}

model CancelTradeOrderRequest {
  bizId?: string(name='BizId'),
}

model CancelTradeOrderResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelTradeOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelTradeOrderResponseBody(name='body'),
}

async function cancelTradeOrderWithOptions(request: CancelTradeOrderRequest, runtime: Util.RuntimeOptions): CancelTradeOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelTradeOrder',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelTradeOrder(request: CancelTradeOrderRequest): CancelTradeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelTradeOrderWithOptions(request, runtime);
}

model CheckIfCollectedRequest {
  itemIdList?: string(name='ItemIdList'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  type?: int32(name='Type'),
}

model CheckIfCollectedResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    trademark?: [ 
    {
      id?: long(name='Id'),
      itemIdList?: string(name='ItemIdList'),
      name?: string(name='Name'),
      type?: int32(name='Type'),
    }
  ](name='Trademark')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model CheckIfCollectedResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckIfCollectedResponseBody(name='body'),
}

async function checkIfCollectedWithOptions(request: CheckIfCollectedRequest, runtime: Util.RuntimeOptions): CheckIfCollectedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.itemIdList)) {
    query['ItemIdList'] = request.itemIdList;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckIfCollected',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkIfCollected(request: CheckIfCollectedRequest): CheckIfCollectedResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkIfCollectedWithOptions(request, runtime);
}

model CheckLoaFillRequest {
  ossKey?: string(name='OssKey'),
  type?: string(name='Type'),
}

model CheckLoaFillResponseBody = {
  data?: {
    addressFill?: boolean(name='AddressFill'),
    countryFill?: boolean(name='CountryFill'),
    errorMsgs?: {
      errorMsg?: [ string ](name='ErrorMsg')
    }(name='ErrorMsgs'),
    materialNameFill?: boolean(name='MaterialNameFill'),
    nationalityFill?: boolean(name='NationalityFill'),
    stampFill?: boolean(name='StampFill'),
    templateUrl?: string(name='TemplateUrl'),
    tradeMarkNameFill?: boolean(name='TradeMarkNameFill'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CheckLoaFillResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckLoaFillResponseBody(name='body'),
}

async function checkLoaFillWithOptions(request: CheckLoaFillRequest, runtime: Util.RuntimeOptions): CheckLoaFillResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ossKey)) {
    query['OssKey'] = request.ossKey;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckLoaFill',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkLoaFill(request: CheckLoaFillRequest): CheckLoaFillResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkLoaFillWithOptions(request, runtime);
}

model CheckTrademarkIconRequest {
  eventSceneType?: int32(name='EventSceneType'),
  trademarkIconOssKey?: string(name='TrademarkIconOssKey'),
}

model CheckTrademarkIconResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CheckTrademarkIconResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckTrademarkIconResponseBody(name='body'),
}

async function checkTrademarkIconWithOptions(request: CheckTrademarkIconRequest, runtime: Util.RuntimeOptions): CheckTrademarkIconResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventSceneType)) {
    query['EventSceneType'] = request.eventSceneType;
  }
  if (!Util.isUnset(request.trademarkIconOssKey)) {
    query['TrademarkIconOssKey'] = request.trademarkIconOssKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckTrademarkIcon',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkTrademarkIcon(request: CheckTrademarkIconRequest): CheckTrademarkIconResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkTrademarkIconWithOptions(request, runtime);
}

model CheckTrademarkOrderRequest {
  bizId?: string(name='BizId'),
  channel?: string(name='Channel'),
  isBlackIcon?: boolean(name='IsBlackIcon'),
  loaOssKey?: string(name='LoaOssKey'),
  logoGoodsId?: string(name='LogoGoodsId'),
  materialId?: string(name='MaterialId'),
  orderData?: string(name='OrderData'),
  partnerCode?: string(name='PartnerCode'),
  phoneNum?: string(name='PhoneNum'),
  realUserName?: string(name='RealUserName'),
  registerName?: string(name='RegisterName'),
  registerNumber?: string(name='RegisterNumber'),
  renewInfoId?: string(name='RenewInfoId'),
  rootCode?: string(name='RootCode'),
  tmComment?: string(name='TmComment'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  tmNameType?: string(name='TmNameType'),
  type?: int32(name='Type'),
  uid?: string(name='Uid'),
  userId?: long(name='UserId'),
}

model CheckTrademarkOrderResponseBody = {
  data?: map[string]any(name='Data'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CheckTrademarkOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckTrademarkOrderResponseBody(name='body'),
}

async function checkTrademarkOrderWithOptions(request: CheckTrademarkOrderRequest, runtime: Util.RuntimeOptions): CheckTrademarkOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.isBlackIcon)) {
    query['IsBlackIcon'] = request.isBlackIcon;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    query['LoaOssKey'] = request.loaOssKey;
  }
  if (!Util.isUnset(request.logoGoodsId)) {
    query['LogoGoodsId'] = request.logoGoodsId;
  }
  if (!Util.isUnset(request.materialId)) {
    query['MaterialId'] = request.materialId;
  }
  if (!Util.isUnset(request.orderData)) {
    query['OrderData'] = request.orderData;
  }
  if (!Util.isUnset(request.partnerCode)) {
    query['PartnerCode'] = request.partnerCode;
  }
  if (!Util.isUnset(request.phoneNum)) {
    query['PhoneNum'] = request.phoneNum;
  }
  if (!Util.isUnset(request.realUserName)) {
    query['RealUserName'] = request.realUserName;
  }
  if (!Util.isUnset(request.registerName)) {
    query['RegisterName'] = request.registerName;
  }
  if (!Util.isUnset(request.registerNumber)) {
    query['RegisterNumber'] = request.registerNumber;
  }
  if (!Util.isUnset(request.renewInfoId)) {
    query['RenewInfoId'] = request.renewInfoId;
  }
  if (!Util.isUnset(request.rootCode)) {
    query['RootCode'] = request.rootCode;
  }
  if (!Util.isUnset(request.tmComment)) {
    query['TmComment'] = request.tmComment;
  }
  if (!Util.isUnset(request.tmIcon)) {
    query['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNameType)) {
    query['TmNameType'] = request.tmNameType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckTrademarkOrder',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkTrademarkOrder(request: CheckTrademarkOrderRequest): CheckTrademarkOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkTrademarkOrderWithOptions(request, runtime);
}

model CombineLoaRequest {
  address?: string(name='Address'),
  materialId?: string(name='MaterialId'),
  materialName?: string(name='MaterialName'),
  nationality?: string(name='Nationality'),
  principalName?: int32(name='PrincipalName'),
  tmNumber?: string(name='TmNumber'),
  tmProduceType?: string(name='TmProduceType'),
  trademarkName?: string(name='TrademarkName'),
}

model CombineLoaResponseBody = {
  requestId?: string(name='RequestId'),
  templateCombineUrl?: string(name='TemplateCombineUrl'),
}

model CombineLoaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CombineLoaResponseBody(name='body'),
}

async function combineLoaWithOptions(request: CombineLoaRequest, runtime: Util.RuntimeOptions): CombineLoaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.materialId)) {
    query['MaterialId'] = request.materialId;
  }
  if (!Util.isUnset(request.materialName)) {
    query['MaterialName'] = request.materialName;
  }
  if (!Util.isUnset(request.nationality)) {
    query['Nationality'] = request.nationality;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  if (!Util.isUnset(request.tmNumber)) {
    query['TmNumber'] = request.tmNumber;
  }
  if (!Util.isUnset(request.tmProduceType)) {
    query['TmProduceType'] = request.tmProduceType;
  }
  if (!Util.isUnset(request.trademarkName)) {
    query['TrademarkName'] = request.trademarkName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CombineLoa',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function combineLoa(request: CombineLoaRequest): CombineLoaResponse {
  var runtime = new Util.RuntimeOptions{};
  return combineLoaWithOptions(request, runtime);
}

model ComplementIntentionUserIdRequest {
  aliyunKp?: string(name='AliyunKp', description='aliyunKp'),
  bid?: string(name='Bid', description='bid'),
  bizId?: string(name='BizId', description='bizId'),
  callerParentId?: long(name='CallerParentId', description='callerParentId'),
  callerType?: string(name='CallerType', description='callerType'),
  complementUserId?: string(name='ComplementUserId'),
  type?: int32(name='Type', description='type'),
}

model ComplementIntentionUserIdResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ComplementIntentionUserIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ComplementIntentionUserIdResponseBody(name='body'),
}

async function complementIntentionUserIdWithOptions(request: ComplementIntentionUserIdRequest, runtime: Util.RuntimeOptions): ComplementIntentionUserIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunKp)) {
    query['AliyunKp'] = request.aliyunKp;
  }
  if (!Util.isUnset(request.bid)) {
    query['Bid'] = request.bid;
  }
  if (!Util.isUnset(request.callerParentId)) {
    query['CallerParentId'] = request.callerParentId;
  }
  if (!Util.isUnset(request.callerType)) {
    query['CallerType'] = request.callerType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.complementUserId)) {
    body['ComplementUserId'] = request.complementUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ComplementIntentionUserId',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function complementIntentionUserId(request: ComplementIntentionUserIdRequest): ComplementIntentionUserIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return complementIntentionUserIdWithOptions(request, runtime);
}

model ConfirmAdditionalMaterialRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
}

model ConfirmAdditionalMaterialResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConfirmAdditionalMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfirmAdditionalMaterialResponseBody(name='body'),
}

async function confirmAdditionalMaterialWithOptions(request: ConfirmAdditionalMaterialRequest, runtime: Util.RuntimeOptions): ConfirmAdditionalMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmAdditionalMaterial',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function confirmAdditionalMaterial(request: ConfirmAdditionalMaterialRequest): ConfirmAdditionalMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmAdditionalMaterialWithOptions(request, runtime);
}

model ConfirmApplicantRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
}

model ConfirmApplicantResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConfirmApplicantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfirmApplicantResponseBody(name='body'),
}

async function confirmApplicantWithOptions(request: ConfirmApplicantRequest, runtime: Util.RuntimeOptions): ConfirmApplicantResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmApplicant',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function confirmApplicant(request: ConfirmApplicantRequest): ConfirmApplicantResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmApplicantWithOptions(request, runtime);
}

model ConfirmDissentOriginalRequest {
  bizId?: string(name='BizId'),
  contactAddress?: string(name='ContactAddress'),
  contactCity?: string(name='ContactCity'),
  contactCounty?: string(name='ContactCounty'),
  contactDistrict?: string(name='ContactDistrict'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactProvince?: string(name='ContactProvince'),
}

model ConfirmDissentOriginalResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfirmDissentOriginalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfirmDissentOriginalResponseBody(name='body'),
}

async function confirmDissentOriginalWithOptions(request: ConfirmDissentOriginalRequest, runtime: Util.RuntimeOptions): ConfirmDissentOriginalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.contactAddress)) {
    query['ContactAddress'] = request.contactAddress;
  }
  if (!Util.isUnset(request.contactCity)) {
    query['ContactCity'] = request.contactCity;
  }
  if (!Util.isUnset(request.contactCounty)) {
    query['ContactCounty'] = request.contactCounty;
  }
  if (!Util.isUnset(request.contactDistrict)) {
    query['ContactDistrict'] = request.contactDistrict;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactNumber)) {
    query['ContactNumber'] = request.contactNumber;
  }
  if (!Util.isUnset(request.contactProvince)) {
    query['ContactProvince'] = request.contactProvince;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmDissentOriginal',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function confirmDissentOriginal(request: ConfirmDissentOriginalRequest): ConfirmDissentOriginalResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmDissentOriginalWithOptions(request, runtime);
}

model ConvertImageToGrayRequest {
  ossKey?: string(name='OssKey'),
}

model ConvertImageToGrayResponseBody = {
  requestId?: string(name='RequestId'),
  signatureUrl?: string(name='SignatureUrl'),
}

model ConvertImageToGrayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConvertImageToGrayResponseBody(name='body'),
}

async function convertImageToGrayWithOptions(request: ConvertImageToGrayRequest, runtime: Util.RuntimeOptions): ConvertImageToGrayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ossKey)) {
    query['OssKey'] = request.ossKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConvertImageToGray',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function convertImageToGray(request: ConvertImageToGrayRequest): ConvertImageToGrayResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertImageToGrayWithOptions(request, runtime);
}

model CopyApplicantRequest {
  id?: long(name='Id'),
}

model CopyApplicantResponseBody = {
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
}

model CopyApplicantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyApplicantResponseBody(name='body'),
}

async function copyApplicantWithOptions(request: CopyApplicantRequest, runtime: Util.RuntimeOptions): CopyApplicantResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CopyApplicant',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function copyApplicant(request: CopyApplicantRequest): CopyApplicantResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyApplicantWithOptions(request, runtime);
}

model CreateIntentionOrderRequest {
  channel?: string(name='Channel'),
  intentionBizId?: string(name='IntentionBizId'),
}

model CreateIntentionOrderResponseBody = {
  data?: {
    orderIds?: [ string ](name='OrderIds')
  }(name='Data'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateIntentionOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIntentionOrderResponseBody(name='body'),
}

async function createIntentionOrderWithOptions(request: CreateIntentionOrderRequest, runtime: Util.RuntimeOptions): CreateIntentionOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.intentionBizId)) {
    query['IntentionBizId'] = request.intentionBizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateIntentionOrder',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIntentionOrder(request: CreateIntentionOrderRequest): CreateIntentionOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIntentionOrderWithOptions(request, runtime);
}

model CreateIntentionOrderGeneratingPayRequest {
  channel?: string(name='Channel'),
  intentionBizId?: string(name='IntentionBizId'),
  paymentCallback?: string(name='PaymentCallback'),
}

model CreateIntentionOrderGeneratingPayResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  orderIds?: [ long ](name='OrderIds'),
  payUrl?: string(name='PayUrl'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateIntentionOrderGeneratingPayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIntentionOrderGeneratingPayResponseBody(name='body'),
}

async function createIntentionOrderGeneratingPayWithOptions(request: CreateIntentionOrderGeneratingPayRequest, runtime: Util.RuntimeOptions): CreateIntentionOrderGeneratingPayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.intentionBizId)) {
    query['IntentionBizId'] = request.intentionBizId;
  }
  if (!Util.isUnset(request.paymentCallback)) {
    query['PaymentCallback'] = request.paymentCallback;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateIntentionOrderGeneratingPay',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIntentionOrderGeneratingPay(request: CreateIntentionOrderGeneratingPayRequest): CreateIntentionOrderGeneratingPayResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIntentionOrderGeneratingPayWithOptions(request, runtime);
}

model CreateTrademarkOrderRequest {
  bigDipperSource?: string(name='BigDipperSource'),
  bizId?: string(name='BizId'),
  channel?: string(name='Channel'),
  isBlackIcon?: boolean(name='IsBlackIcon'),
  legalNoticeKey?: string(name='LegalNoticeKey'),
  loaOssKey?: string(name='LoaOssKey'),
  materialId?: string(name='MaterialId'),
  orderData?: string(name='OrderData'),
  partnerCode?: string(name='PartnerCode'),
  phoneNum?: string(name='PhoneNum'),
  principalName?: int32(name='PrincipalName'),
  realUserName?: string(name='RealUserName'),
  registerName?: string(name='RegisterName'),
  registerNumber?: string(name='RegisterNumber'),
  renewInfoId?: string(name='RenewInfoId'),
  rootCode?: string(name='RootCode'),
  sessionId?: string(name='SessionId'),
  tmComment?: string(name='TmComment'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  tmNameType?: string(name='TmNameType'),
  type?: int32(name='Type'),
  ua?: string(name='Ua'),
  uid?: string(name='Uid'),
  userId?: long(name='UserId'),
}

model CreateTrademarkOrderResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateTrademarkOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTrademarkOrderResponseBody(name='body'),
}

async function createTrademarkOrderWithOptions(request: CreateTrademarkOrderRequest, runtime: Util.RuntimeOptions): CreateTrademarkOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bigDipperSource)) {
    query['BigDipperSource'] = request.bigDipperSource;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.isBlackIcon)) {
    query['IsBlackIcon'] = request.isBlackIcon;
  }
  if (!Util.isUnset(request.legalNoticeKey)) {
    query['LegalNoticeKey'] = request.legalNoticeKey;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    query['LoaOssKey'] = request.loaOssKey;
  }
  if (!Util.isUnset(request.materialId)) {
    query['MaterialId'] = request.materialId;
  }
  if (!Util.isUnset(request.orderData)) {
    query['OrderData'] = request.orderData;
  }
  if (!Util.isUnset(request.partnerCode)) {
    query['PartnerCode'] = request.partnerCode;
  }
  if (!Util.isUnset(request.phoneNum)) {
    query['PhoneNum'] = request.phoneNum;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  if (!Util.isUnset(request.realUserName)) {
    query['RealUserName'] = request.realUserName;
  }
  if (!Util.isUnset(request.registerName)) {
    query['RegisterName'] = request.registerName;
  }
  if (!Util.isUnset(request.registerNumber)) {
    query['RegisterNumber'] = request.registerNumber;
  }
  if (!Util.isUnset(request.renewInfoId)) {
    query['RenewInfoId'] = request.renewInfoId;
  }
  if (!Util.isUnset(request.rootCode)) {
    query['RootCode'] = request.rootCode;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.tmComment)) {
    query['TmComment'] = request.tmComment;
  }
  if (!Util.isUnset(request.tmIcon)) {
    query['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNameType)) {
    query['TmNameType'] = request.tmNameType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.ua)) {
    query['Ua'] = request.ua;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrademarkOrder',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTrademarkOrder(request: CreateTrademarkOrderRequest): CreateTrademarkOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTrademarkOrderWithOptions(request, runtime);
}

model DeleteMaterialRequest {
  id?: long(name='Id'),
}

model DeleteMaterialResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMaterialResponseBody(name='body'),
}

async function deleteMaterialWithOptions(request: DeleteMaterialRequest, runtime: Util.RuntimeOptions): DeleteMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMaterial',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMaterial(request: DeleteMaterialRequest): DeleteMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMaterialWithOptions(request, runtime);
}

model DeleteTmMonitorRuleRequest {
  id?: long(name='Id'),
}

model DeleteTmMonitorRuleResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTmMonitorRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTmMonitorRuleResponseBody(name='body'),
}

async function deleteTmMonitorRuleWithOptions(request: DeleteTmMonitorRuleRequest, runtime: Util.RuntimeOptions): DeleteTmMonitorRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTmMonitorRule',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTmMonitorRule(request: DeleteTmMonitorRuleRequest): DeleteTmMonitorRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTmMonitorRuleWithOptions(request, runtime);
}

model DeleteTrademarkApplicationRequest {
  bizId?: string(name='BizId'),
}

model DeleteTrademarkApplicationResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTrademarkApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTrademarkApplicationResponseBody(name='body'),
}

async function deleteTrademarkApplicationWithOptions(request: DeleteTrademarkApplicationRequest, runtime: Util.RuntimeOptions): DeleteTrademarkApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTrademarkApplication',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTrademarkApplication(request: DeleteTrademarkApplicationRequest): DeleteTrademarkApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTrademarkApplicationWithOptions(request, runtime);
}

model DenySupplementRequest {
  id?: long(name='Id'),
}

model DenySupplementResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DenySupplementResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DenySupplementResponseBody(name='body'),
}

async function denySupplementWithOptions(request: DenySupplementRequest, runtime: Util.RuntimeOptions): DenySupplementResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DenySupplement',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function denySupplement(request: DenySupplementRequest): DenySupplementResponse {
  var runtime = new Util.RuntimeOptions{};
  return denySupplementWithOptions(request, runtime);
}

model DescirbeCombineTrademarkRequest {
  accurateMatch?: boolean(name='AccurateMatch'),
  classification?: string(name='Classification'),
  name?: string(name='Name'),
  ownerName?: string(name='OwnerName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  products?: string(name='Products'),
  registrationNumber?: string(name='RegistrationNumber'),
  similarGroups?: string(name='SimilarGroups'),
}

model DescirbeCombineTrademarkResponseBody = {
  currentPageNumber?: int32(name='CurrentPageNumber'),
  data?: [ 
    {
      agency?: string(name='Agency'),
      announcementList?: [ 
        {
          annDate?: string(name='AnnDate'),
          annNumber?: string(name='AnnNumber'),
          annTypeCode?: string(name='AnnTypeCode'),
          annTypeName?: string(name='AnnTypeName'),
          imageUrl?: string(name='ImageUrl'),
          originalImageUrl?: string(name='OriginalImageUrl'),
        }
      ](name='AnnouncementList'),
      applyDate?: string(name='ApplyDate'),
      classification?: string(name='Classification'),
      exclusiveDateLimit?: string(name='ExclusiveDateLimit'),
      firstAnnoNumber?: string(name='FirstAnnoNumber'),
      firstAnnoType?: string(name='FirstAnnoType'),
      image?: string(name='Image'),
      indexId?: string(name='IndexId'),
      intlRegDate?: string(name='IntlRegDate'),
      lastProcedureStatus?: string(name='LastProcedureStatus'),
      lawFinalStatus?: string(name='LawFinalStatus'),
      name?: string(name='Name'),
      onSale?: int32(name='OnSale'),
      ownerAddress?: string(name='OwnerAddress'),
      ownerEnAddress?: string(name='OwnerEnAddress'),
      ownerEnName?: string(name='OwnerEnName'),
      ownerName?: string(name='OwnerName'),
      preAnnDate?: string(name='PreAnnDate'),
      preAnnNumber?: string(name='PreAnnNumber'),
      priorityDate?: string(name='PriorityDate'),
      procedures?: [ 
        {
          procedureCode?: string(name='ProcedureCode'),
          procedureDate?: string(name='ProcedureDate'),
          procedureName?: string(name='ProcedureName'),
          procedureResult?: string(name='ProcedureResult'),
          procedureStep?: string(name='ProcedureStep'),
        }
      ](name='Procedures'),
      productDescription?: string(name='ProductDescription'),
      regAnnDate?: string(name='RegAnnDate'),
      regAnnNumber?: string(name='RegAnnNumber'),
      registrationNumber?: string(name='RegistrationNumber'),
      registrationType?: string(name='RegistrationType'),
      secondAnnoNumber?: string(name='SecondAnnoNumber'),
      secondAnnoType?: string(name='SecondAnnoType'),
      share?: string(name='Share'),
      similarGroup?: string(name='SimilarGroup'),
      status?: string(name='Status'),
      subsequentDesignationDate?: string(name='SubsequentDesignationDate'),
    }
  ](name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNumber?: int32(name='TotalItemNumber'),
  totalPageNumber?: int32(name='TotalPageNumber'),
}

model DescirbeCombineTrademarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescirbeCombineTrademarkResponseBody(name='body'),
}

async function descirbeCombineTrademarkWithOptions(request: DescirbeCombineTrademarkRequest, runtime: Util.RuntimeOptions): DescirbeCombineTrademarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accurateMatch)) {
    query['AccurateMatch'] = request.accurateMatch;
  }
  if (!Util.isUnset(request.classification)) {
    query['Classification'] = request.classification;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerName)) {
    query['OwnerName'] = request.ownerName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.products)) {
    query['Products'] = request.products;
  }
  if (!Util.isUnset(request.registrationNumber)) {
    query['RegistrationNumber'] = request.registrationNumber;
  }
  if (!Util.isUnset(request.similarGroups)) {
    query['SimilarGroups'] = request.similarGroups;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescirbeCombineTrademark',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function descirbeCombineTrademark(request: DescirbeCombineTrademarkRequest): DescirbeCombineTrademarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return descirbeCombineTrademarkWithOptions(request, runtime);
}

model FillLogisticsRequest {
  bizId?: string(name='BizId'),
  logistics?: string(name='Logistics'),
}

model FillLogisticsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model FillLogisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FillLogisticsResponseBody(name='body'),
}

async function fillLogisticsWithOptions(request: FillLogisticsRequest, runtime: Util.RuntimeOptions): FillLogisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.logistics)) {
    query['Logistics'] = request.logistics;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FillLogistics',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function fillLogistics(request: FillLogisticsRequest): FillLogisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return fillLogisticsWithOptions(request, runtime);
}

model FilterUnavailableCodesRequest {
  codes?: map[string]any(name='Codes'),
}

model FilterUnavailableCodesShrinkRequest {
  codesShrink?: string(name='Codes'),
}

model FilterUnavailableCodesResponseBody = {
  data?: {
    codes?: [ string ](name='Codes')
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model FilterUnavailableCodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FilterUnavailableCodesResponseBody(name='body'),
}

async function filterUnavailableCodesWithOptions(tmpReq: FilterUnavailableCodesRequest, runtime: Util.RuntimeOptions): FilterUnavailableCodesResponse {
  Util.validateModel(tmpReq);
  var request = new FilterUnavailableCodesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.codes)) {
    request.codesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.codes, 'Codes', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.codesShrink)) {
    query['Codes'] = request.codesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FilterUnavailableCodes',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function filterUnavailableCodes(request: FilterUnavailableCodesRequest): FilterUnavailableCodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return filterUnavailableCodesWithOptions(request, runtime);
}

model ForceUploadTrademarkOnsaleRequest {
  beginTime?: long(name='BeginTime'),
  classificationCode?: string(name='ClassificationCode'),
  description?: string(name='Description'),
  endTime?: long(name='EndTime'),
  label?: string(name='Label'),
  originalPrice?: float(name='OriginalPrice'),
  ownerEnName?: string(name='OwnerEnName'),
  ownerName?: string(name='OwnerName'),
  reason?: string(name='Reason'),
  regAnnDate?: long(name='RegAnnDate'),
  secondaryClassification?: string(name='SecondaryClassification'),
  thirdClassification?: string(name='ThirdClassification'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  tmNumber?: string(name='TmNumber'),
  type?: string(name='Type'),
}

model ForceUploadTrademarkOnsaleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ForceUploadTrademarkOnsaleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ForceUploadTrademarkOnsaleResponseBody(name='body'),
}

async function forceUploadTrademarkOnsaleWithOptions(request: ForceUploadTrademarkOnsaleRequest, runtime: Util.RuntimeOptions): ForceUploadTrademarkOnsaleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.classificationCode)) {
    query['ClassificationCode'] = request.classificationCode;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.label)) {
    query['Label'] = request.label;
  }
  if (!Util.isUnset(request.originalPrice)) {
    query['OriginalPrice'] = request.originalPrice;
  }
  if (!Util.isUnset(request.ownerEnName)) {
    query['OwnerEnName'] = request.ownerEnName;
  }
  if (!Util.isUnset(request.ownerName)) {
    query['OwnerName'] = request.ownerName;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.regAnnDate)) {
    query['RegAnnDate'] = request.regAnnDate;
  }
  if (!Util.isUnset(request.secondaryClassification)) {
    query['SecondaryClassification'] = request.secondaryClassification;
  }
  if (!Util.isUnset(request.thirdClassification)) {
    query['ThirdClassification'] = request.thirdClassification;
  }
  if (!Util.isUnset(request.tmIcon)) {
    query['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNumber)) {
    query['TmNumber'] = request.tmNumber;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ForceUploadTrademarkOnsale',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function forceUploadTrademarkOnsale(request: ForceUploadTrademarkOnsaleRequest): ForceUploadTrademarkOnsaleResponse {
  var runtime = new Util.RuntimeOptions{};
  return forceUploadTrademarkOnsaleWithOptions(request, runtime);
}

model GenerateQrCodeRequest {
  fieldKey?: string(name='FieldKey'),
  ossKey?: string(name='OssKey'),
  uuid?: string(name='Uuid'),
}

model GenerateQrCodeResponseBody = {
  expireTime?: long(name='ExpireTime'),
  fieldKey?: string(name='FieldKey'),
  qrcodeUrl?: string(name='QrcodeUrl'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  uuid?: string(name='Uuid'),
}

model GenerateQrCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateQrCodeResponseBody(name='body'),
}

async function generateQrCodeWithOptions(request: GenerateQrCodeRequest, runtime: Util.RuntimeOptions): GenerateQrCodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fieldKey)) {
    query['FieldKey'] = request.fieldKey;
  }
  if (!Util.isUnset(request.ossKey)) {
    query['OssKey'] = request.ossKey;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateQrCode',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateQrCode(request: GenerateQrCodeRequest): GenerateQrCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateQrCodeWithOptions(request, runtime);
}

model GenerateUploadFilePolicyRequest {
  bizId?: string(name='BizId'),
  fileType?: string(name='FileType'),
}

model GenerateUploadFilePolicyResponseBody = {
  accessId?: string(name='AccessId'),
  encodedPolicy?: string(name='EncodedPolicy'),
  expireTime?: long(name='ExpireTime'),
  fileDir?: string(name='FileDir'),
  host?: string(name='Host'),
  requestId?: string(name='RequestId'),
  signature?: string(name='Signature'),
}

model GenerateUploadFilePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateUploadFilePolicyResponseBody(name='body'),
}

async function generateUploadFilePolicyWithOptions(request: GenerateUploadFilePolicyRequest, runtime: Util.RuntimeOptions): GenerateUploadFilePolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.fileType)) {
    query['FileType'] = request.fileType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateUploadFilePolicy',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateUploadFilePolicy(request: GenerateUploadFilePolicyRequest): GenerateUploadFilePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateUploadFilePolicyWithOptions(request, runtime);
}

model GetAuthorizationLetterVersionRequest {
  ossKey?: string(name='OssKey'),
}

model GetAuthorizationLetterVersionResponseBody = {
  requestId?: string(name='RequestId'),
  version?: string(name='Version'),
}

model GetAuthorizationLetterVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAuthorizationLetterVersionResponseBody(name='body'),
}

async function getAuthorizationLetterVersionWithOptions(request: GetAuthorizationLetterVersionRequest, runtime: Util.RuntimeOptions): GetAuthorizationLetterVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ossKey)) {
    query['OssKey'] = request.ossKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAuthorizationLetterVersion',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAuthorizationLetterVersion(request: GetAuthorizationLetterVersionRequest): GetAuthorizationLetterVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAuthorizationLetterVersionWithOptions(request, runtime);
}

model GetDefaultPrincipalResponseBody = {
  principalDescription?: string(name='PrincipalDescription'),
  principalName?: string(name='PrincipalName'),
  principalValue?: int32(name='PrincipalValue'),
  requestId?: string(name='RequestId'),
}

model GetDefaultPrincipalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDefaultPrincipalResponseBody(name='body'),
}

async function getDefaultPrincipalWithOptions(runtime: Util.RuntimeOptions): GetDefaultPrincipalResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetDefaultPrincipal',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDefaultPrincipal(): GetDefaultPrincipalResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefaultPrincipalWithOptions(runtime);
}

model GetDefaultPrincipalNameRequest {
  bizType?: string(name='BizType'),
}

model GetDefaultPrincipalNameResponseBody = {
  principalName?: int32(name='PrincipalName'),
  requestId?: string(name='RequestId'),
}

model GetDefaultPrincipalNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDefaultPrincipalNameResponseBody(name='body'),
}

async function getDefaultPrincipalNameWithOptions(request: GetDefaultPrincipalNameRequest, runtime: Util.RuntimeOptions): GetDefaultPrincipalNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDefaultPrincipalName',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDefaultPrincipalName(request: GetDefaultPrincipalNameRequest): GetDefaultPrincipalNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefaultPrincipalNameWithOptions(request, runtime);
}

model GetNotaryOrderRequest {
  notaryOrderId?: long(name='NotaryOrderId'),
}

model GetNotaryOrderResponseBody = {
  aliyunOrderId?: string(name='AliyunOrderId'),
  applyPostStatus?: int32(name='ApplyPostStatus'),
  bizId?: string(name='BizId'),
  businessLicense?: string(name='BusinessLicense'),
  businessLicenseId?: string(name='BusinessLicenseId'),
  companyContactName?: string(name='CompanyContactName'),
  companyContactPhone?: string(name='CompanyContactPhone'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  legalPersonIdCard?: string(name='LegalPersonIdCard'),
  legalPersonName?: string(name='LegalPersonName'),
  legalPersonPhone?: string(name='LegalPersonPhone'),
  name?: string(name='Name'),
  notaryAcceptDate?: long(name='NotaryAcceptDate'),
  notaryCertificate?: string(name='NotaryCertificate'),
  notaryFailedDate?: long(name='NotaryFailedDate'),
  notaryFailedReason?: string(name='NotaryFailedReason'),
  notaryOrderId?: long(name='NotaryOrderId'),
  notaryPlatformName?: string(name='NotaryPlatformName'),
  notaryPostReceipt?: string(name='NotaryPostReceipt'),
  notaryStatus?: int32(name='NotaryStatus'),
  notarySucceedDate?: long(name='NotarySucceedDate'),
  notaryType?: int32(name='NotaryType'),
  orderDate?: long(name='OrderDate'),
  orderPrice?: float(name='OrderPrice'),
  phone?: string(name='Phone'),
  receiverAddress?: string(name='ReceiverAddress'),
  receiverName?: string(name='ReceiverName'),
  receiverPhone?: string(name='ReceiverPhone'),
  receiverPostalCode?: string(name='ReceiverPostalCode'),
  requestId?: string(name='RequestId'),
  sellerBackOfIdCard?: string(name='SellerBackOfIdCard'),
  sellerCompanyName?: string(name='SellerCompanyName'),
  sellerFrontOfIdCard?: string(name='SellerFrontOfIdCard'),
  success?: boolean(name='Success'),
  tmAcceptCertificate?: string(name='TmAcceptCertificate'),
  tmClassification?: string(name='TmClassification'),
  tmImage?: string(name='TmImage'),
  tmName?: string(name='TmName'),
  tmRegisterCertificate?: string(name='TmRegisterCertificate'),
  tmRegisterChangeCertificate?: string(name='TmRegisterChangeCertificate'),
  tmRegisterNo?: string(name='TmRegisterNo'),
  type?: string(name='Type'),
}

model GetNotaryOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetNotaryOrderResponseBody(name='body'),
}

async function getNotaryOrderWithOptions(request: GetNotaryOrderRequest, runtime: Util.RuntimeOptions): GetNotaryOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.notaryOrderId)) {
    query['NotaryOrderId'] = request.notaryOrderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetNotaryOrder',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNotaryOrder(request: GetNotaryOrderRequest): GetNotaryOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNotaryOrderWithOptions(request, runtime);
}

model GetSupportPrincipalNameResponseBody = {
  principals?: [ 
    {
      defaultPrincipal?: boolean(name='DefaultPrincipal'),
      principalDescription?: string(name='PrincipalDescription'),
      principalValue?: int32(name='PrincipalValue'),
    }
  ](name='Principals'),
  requestId?: string(name='RequestId'),
}

model GetSupportPrincipalNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSupportPrincipalNameResponseBody(name='body'),
}

async function getSupportPrincipalNameWithOptions(runtime: Util.RuntimeOptions): GetSupportPrincipalNameResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetSupportPrincipalName',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSupportPrincipalName(): GetSupportPrincipalNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSupportPrincipalNameWithOptions(runtime);
}

model InsertMaterialRequest {
  address?: string(name='Address'),
  businessLicenceOssKey?: string(name='BusinessLicenceOssKey'),
  cardNumber?: string(name='CardNumber'),
  city?: string(name='City'),
  contactAddress?: string(name='ContactAddress'),
  contactCity?: string(name='ContactCity'),
  contactCounty?: string(name='ContactCounty'),
  contactDistrict?: string(name='ContactDistrict'),
  contactEmail?: string(name='ContactEmail'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactProvince?: string(name='ContactProvince'),
  contactZipcode?: string(name='ContactZipcode'),
  country?: string(name='Country'),
  EAddress?: string(name='EAddress'),
  EName?: string(name='EName'),
  idCardName?: string(name='IdCardName'),
  idCardNumber?: string(name='IdCardNumber'),
  idCardOssKey?: string(name='IdCardOssKey'),
  legalNoticeOssKey?: string(name='LegalNoticeOssKey'),
  loaOssKey?: string(name='LoaOssKey'),
  name?: string(name='Name'),
  passportOssKey?: string(name='PassportOssKey'),
  personalType?: long(name='PersonalType'),
  principalName?: int32(name='PrincipalName'),
  province?: string(name='Province'),
  region?: int32(name='Region'),
  town?: string(name='Town'),
  type?: int32(name='Type'),
}

model InsertMaterialResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InsertMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertMaterialResponseBody(name='body'),
}

async function insertMaterialWithOptions(request: InsertMaterialRequest, runtime: Util.RuntimeOptions): InsertMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.businessLicenceOssKey)) {
    query['BusinessLicenceOssKey'] = request.businessLicenceOssKey;
  }
  if (!Util.isUnset(request.cardNumber)) {
    query['CardNumber'] = request.cardNumber;
  }
  if (!Util.isUnset(request.city)) {
    query['City'] = request.city;
  }
  if (!Util.isUnset(request.contactAddress)) {
    query['ContactAddress'] = request.contactAddress;
  }
  if (!Util.isUnset(request.contactCity)) {
    query['ContactCity'] = request.contactCity;
  }
  if (!Util.isUnset(request.contactCounty)) {
    query['ContactCounty'] = request.contactCounty;
  }
  if (!Util.isUnset(request.contactDistrict)) {
    query['ContactDistrict'] = request.contactDistrict;
  }
  if (!Util.isUnset(request.contactEmail)) {
    query['ContactEmail'] = request.contactEmail;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactNumber)) {
    query['ContactNumber'] = request.contactNumber;
  }
  if (!Util.isUnset(request.contactProvince)) {
    query['ContactProvince'] = request.contactProvince;
  }
  if (!Util.isUnset(request.contactZipcode)) {
    query['ContactZipcode'] = request.contactZipcode;
  }
  if (!Util.isUnset(request.country)) {
    query['Country'] = request.country;
  }
  if (!Util.isUnset(request.EAddress)) {
    query['EAddress'] = request.EAddress;
  }
  if (!Util.isUnset(request.EName)) {
    query['EName'] = request.EName;
  }
  if (!Util.isUnset(request.idCardName)) {
    query['IdCardName'] = request.idCardName;
  }
  if (!Util.isUnset(request.idCardNumber)) {
    query['IdCardNumber'] = request.idCardNumber;
  }
  if (!Util.isUnset(request.idCardOssKey)) {
    query['IdCardOssKey'] = request.idCardOssKey;
  }
  if (!Util.isUnset(request.legalNoticeOssKey)) {
    query['LegalNoticeOssKey'] = request.legalNoticeOssKey;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    query['LoaOssKey'] = request.loaOssKey;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.passportOssKey)) {
    query['PassportOssKey'] = request.passportOssKey;
  }
  if (!Util.isUnset(request.personalType)) {
    query['PersonalType'] = request.personalType;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  if (!Util.isUnset(request.province)) {
    query['Province'] = request.province;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.town)) {
    query['Town'] = request.town;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InsertMaterial',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function insertMaterial(request: InsertMaterialRequest): InsertMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertMaterialWithOptions(request, runtime);
}

model InsertRenewInfoRequest {
  address?: string(name='Address'),
  engAddress?: string(name='EngAddress'),
  engName?: string(name='EngName'),
  name?: string(name='Name'),
  registerTime?: long(name='RegisterTime'),
}

model InsertRenewInfoResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  id?: long(name='Id'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InsertRenewInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertRenewInfoResponseBody(name='body'),
}

async function insertRenewInfoWithOptions(request: InsertRenewInfoRequest, runtime: Util.RuntimeOptions): InsertRenewInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.engAddress)) {
    query['EngAddress'] = request.engAddress;
  }
  if (!Util.isUnset(request.engName)) {
    query['EngName'] = request.engName;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.registerTime)) {
    query['RegisterTime'] = request.registerTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InsertRenewInfo',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function insertRenewInfo(request: InsertRenewInfoRequest): InsertRenewInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertRenewInfoWithOptions(request, runtime);
}

model InsertTmMonitorRuleRequest {
  classification?: map[string]any(name='Classification'),
  endApplyDate?: string(name='EndApplyDate'),
  notifyStatus?: map[string]any(name='NotifyStatus'),
  ruleKeyword?: string(name='RuleKeyword'),
  ruleName?: string(name='RuleName'),
  ruleSource?: string(name='RuleSource'),
  ruleType?: int32(name='RuleType'),
  startApplyDate?: string(name='StartApplyDate'),
}

model InsertTmMonitorRuleShrinkRequest {
  classificationShrink?: string(name='Classification'),
  endApplyDate?: string(name='EndApplyDate'),
  notifyStatusShrink?: string(name='NotifyStatus'),
  ruleKeyword?: string(name='RuleKeyword'),
  ruleName?: string(name='RuleName'),
  ruleSource?: string(name='RuleSource'),
  ruleType?: int32(name='RuleType'),
  startApplyDate?: string(name='StartApplyDate'),
}

model InsertTmMonitorRuleResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InsertTmMonitorRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InsertTmMonitorRuleResponseBody(name='body'),
}

async function insertTmMonitorRuleWithOptions(tmpReq: InsertTmMonitorRuleRequest, runtime: Util.RuntimeOptions): InsertTmMonitorRuleResponse {
  Util.validateModel(tmpReq);
  var request = new InsertTmMonitorRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.classification)) {
    request.classificationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.classification, 'Classification', 'json');
  }
  if (!Util.isUnset(tmpReq.notifyStatus)) {
    request.notifyStatusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notifyStatus, 'NotifyStatus', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.classificationShrink)) {
    query['Classification'] = request.classificationShrink;
  }
  if (!Util.isUnset(request.endApplyDate)) {
    query['EndApplyDate'] = request.endApplyDate;
  }
  if (!Util.isUnset(request.notifyStatusShrink)) {
    query['NotifyStatus'] = request.notifyStatusShrink;
  }
  if (!Util.isUnset(request.ruleKeyword)) {
    query['RuleKeyword'] = request.ruleKeyword;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleSource)) {
    query['RuleSource'] = request.ruleSource;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.startApplyDate)) {
    query['StartApplyDate'] = request.startApplyDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InsertTmMonitorRule',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function insertTmMonitorRule(request: InsertTmMonitorRuleRequest): InsertTmMonitorRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertTmMonitorRuleWithOptions(request, runtime);
}

model ListNotaryInfosRequest {
  bizOrderNo?: string(name='BizOrderNo'),
  notaryType?: int32(name='NotaryType'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  token?: string(name='Token'),
}

model ListNotaryInfosResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    notaryInfo?: [ 
    {
      bizOrderNo?: string(name='BizOrderNo'),
      gmtModified?: long(name='GmtModified'),
      notaryFailedReason?: string(name='NotaryFailedReason'),
      notaryStatus?: int32(name='NotaryStatus'),
      tmClassification?: string(name='TmClassification'),
      tmRegisterNo?: string(name='TmRegisterNo'),
      token?: string(name='Token'),
    }
  ](name='NotaryInfo')
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model ListNotaryInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNotaryInfosResponseBody(name='body'),
}

async function listNotaryInfosWithOptions(request: ListNotaryInfosRequest, runtime: Util.RuntimeOptions): ListNotaryInfosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizOrderNo)) {
    query['BizOrderNo'] = request.bizOrderNo;
  }
  if (!Util.isUnset(request.notaryType)) {
    query['NotaryType'] = request.notaryType;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNotaryInfos',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNotaryInfos(request: ListNotaryInfosRequest): ListNotaryInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNotaryInfosWithOptions(request, runtime);
}

model ListNotaryOrdersRequest {
  aliyunOrderId?: string(name='AliyunOrderId'),
  bizId?: string(name='BizId'),
  endOrderDate?: long(name='EndOrderDate'),
  notaryStatus?: int32(name='NotaryStatus'),
  notaryType?: int32(name='NotaryType'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  sortByType?: string(name='SortByType'),
  sortKeyType?: int32(name='SortKeyType'),
  startOrderDate?: long(name='StartOrderDate'),
}

model ListNotaryOrdersResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    notaryOrder?: [ 
    {
      aliyunOrderId?: string(name='AliyunOrderId'),
      applyPostStatus?: string(name='ApplyPostStatus'),
      bizId?: string(name='BizId'),
      gmtModified?: long(name='GmtModified'),
      notaryCertificate?: string(name='NotaryCertificate'),
      notaryOrderId?: long(name='NotaryOrderId'),
      notaryPlatformName?: string(name='NotaryPlatformName'),
      notaryStatus?: int32(name='NotaryStatus'),
      notaryType?: int32(name='NotaryType'),
      orderDate?: long(name='OrderDate'),
      orderPrice?: float(name='OrderPrice'),
      tmClassification?: string(name='TmClassification'),
      tmImage?: string(name='TmImage'),
      tmName?: string(name='TmName'),
      tmRegisterNo?: string(name='TmRegisterNo'),
    }
  ](name='NotaryOrder')
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model ListNotaryOrdersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNotaryOrdersResponseBody(name='body'),
}

async function listNotaryOrdersWithOptions(request: ListNotaryOrdersRequest, runtime: Util.RuntimeOptions): ListNotaryOrdersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunOrderId)) {
    query['AliyunOrderId'] = request.aliyunOrderId;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.endOrderDate)) {
    query['EndOrderDate'] = request.endOrderDate;
  }
  if (!Util.isUnset(request.notaryStatus)) {
    query['NotaryStatus'] = request.notaryStatus;
  }
  if (!Util.isUnset(request.notaryType)) {
    query['NotaryType'] = request.notaryType;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortByType)) {
    query['SortByType'] = request.sortByType;
  }
  if (!Util.isUnset(request.sortKeyType)) {
    query['SortKeyType'] = request.sortKeyType;
  }
  if (!Util.isUnset(request.startOrderDate)) {
    query['StartOrderDate'] = request.startOrderDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNotaryOrders',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNotaryOrders(request: ListNotaryOrdersRequest): ListNotaryOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNotaryOrdersWithOptions(request, runtime);
}

model ModifySubmitTransferMaterailRequest {
  addr?: string(name='Addr'),
  assigneeProxy?: string(name='AssigneeProxy'),
  bizId?: string(name='BizId'),
  buyerBusinessLicense?: string(name='BuyerBusinessLicense'),
  buyerBusinessLicenseTranslation?: string(name='BuyerBusinessLicenseTranslation'),
  buyerIdCard?: string(name='BuyerIdCard'),
  cardNo?: string(name='CardNo'),
  cardType?: string(name='CardType'),
  complete?: boolean(name='Complete'),
  contactEmail?: string(name='ContactEmail'),
  contactMobile?: string(name='ContactMobile'),
  contactName?: string(name='ContactName'),
  name?: string(name='Name'),
  notarization?: string(name='Notarization'),
  note?: string(name='Note'),
  other?: map[string]any(name='Other'),
  registrationCert?: string(name='RegistrationCert'),
  sellerApply?: string(name='SellerApply'),
  sellerBusinessLicense?: string(name='SellerBusinessLicense'),
  sellerBusinessLicenseTranslation?: string(name='SellerBusinessLicenseTranslation'),
  sellerIdCard?: string(name='SellerIdCard'),
  sellerProxy?: string(name='SellerProxy'),
}

model ModifySubmitTransferMaterailShrinkRequest {
  addr?: string(name='Addr'),
  assigneeProxy?: string(name='AssigneeProxy'),
  bizId?: string(name='BizId'),
  buyerBusinessLicense?: string(name='BuyerBusinessLicense'),
  buyerBusinessLicenseTranslation?: string(name='BuyerBusinessLicenseTranslation'),
  buyerIdCard?: string(name='BuyerIdCard'),
  cardNo?: string(name='CardNo'),
  cardType?: string(name='CardType'),
  complete?: boolean(name='Complete'),
  contactEmail?: string(name='ContactEmail'),
  contactMobile?: string(name='ContactMobile'),
  contactName?: string(name='ContactName'),
  name?: string(name='Name'),
  notarization?: string(name='Notarization'),
  note?: string(name='Note'),
  otherShrink?: string(name='Other'),
  registrationCert?: string(name='RegistrationCert'),
  sellerApply?: string(name='SellerApply'),
  sellerBusinessLicense?: string(name='SellerBusinessLicense'),
  sellerBusinessLicenseTranslation?: string(name='SellerBusinessLicenseTranslation'),
  sellerIdCard?: string(name='SellerIdCard'),
  sellerProxy?: string(name='SellerProxy'),
}

model ModifySubmitTransferMaterailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model ModifySubmitTransferMaterailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySubmitTransferMaterailResponseBody(name='body'),
}

async function modifySubmitTransferMaterailWithOptions(tmpReq: ModifySubmitTransferMaterailRequest, runtime: Util.RuntimeOptions): ModifySubmitTransferMaterailResponse {
  Util.validateModel(tmpReq);
  var request = new ModifySubmitTransferMaterailShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.other)) {
    request.otherShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.other, 'Other', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.assigneeProxy)) {
    query['AssigneeProxy'] = request.assigneeProxy;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.buyerBusinessLicenseTranslation)) {
    query['BuyerBusinessLicenseTranslation'] = request.buyerBusinessLicenseTranslation;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  if (!Util.isUnset(request.sellerBusinessLicenseTranslation)) {
    query['SellerBusinessLicenseTranslation'] = request.sellerBusinessLicenseTranslation;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.addr)) {
    body['Addr'] = request.addr;
  }
  if (!Util.isUnset(request.buyerBusinessLicense)) {
    body['BuyerBusinessLicense'] = request.buyerBusinessLicense;
  }
  if (!Util.isUnset(request.buyerIdCard)) {
    body['BuyerIdCard'] = request.buyerIdCard;
  }
  if (!Util.isUnset(request.cardNo)) {
    body['CardNo'] = request.cardNo;
  }
  if (!Util.isUnset(request.cardType)) {
    body['CardType'] = request.cardType;
  }
  if (!Util.isUnset(request.complete)) {
    body['Complete'] = request.complete;
  }
  if (!Util.isUnset(request.contactEmail)) {
    body['ContactEmail'] = request.contactEmail;
  }
  if (!Util.isUnset(request.contactMobile)) {
    body['ContactMobile'] = request.contactMobile;
  }
  if (!Util.isUnset(request.contactName)) {
    body['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.notarization)) {
    body['Notarization'] = request.notarization;
  }
  if (!Util.isUnset(request.otherShrink)) {
    body['Other'] = request.otherShrink;
  }
  if (!Util.isUnset(request.registrationCert)) {
    body['RegistrationCert'] = request.registrationCert;
  }
  if (!Util.isUnset(request.sellerApply)) {
    body['SellerApply'] = request.sellerApply;
  }
  if (!Util.isUnset(request.sellerBusinessLicense)) {
    body['SellerBusinessLicense'] = request.sellerBusinessLicense;
  }
  if (!Util.isUnset(request.sellerIdCard)) {
    body['SellerIdCard'] = request.sellerIdCard;
  }
  if (!Util.isUnset(request.sellerProxy)) {
    body['SellerProxy'] = request.sellerProxy;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifySubmitTransferMaterail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySubmitTransferMaterail(request: ModifySubmitTransferMaterailRequest): ModifySubmitTransferMaterailResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySubmitTransferMaterailWithOptions(request, runtime);
}

model PartnerUpdateTrademarkNameRequest {
  aliyunKp?: string(name='AliyunKp', description='aliyunKp'),
  bid?: string(name='Bid', description='bid'),
  bizId?: string(name='BizId', description='bizId'),
  callerParentId?: long(name='CallerParentId', description='callerParentId'),
  callerType?: string(name='CallerType', description='callerType'),
  eventSceneType?: long(name='EventSceneType'),
  intentionBizId?: string(name='IntentionBizId', description='bizId'),
  tmComment?: string(name='TmComment', description='tmComment'),
  tmIcon?: string(name='TmIcon', description='tmIcon'),
  tmName?: string(name='TmName', description='tmName'),
  type?: int32(name='Type', description='type'),
}

model PartnerUpdateTrademarkNameResponseBody = {
  allowRetry?: boolean(name='AllowRetry', description='allowRetry'),
  appName?: string(name='AppName', description='appName'),
  dynamicCode?: string(name='DynamicCode', description='dynamicCode'),
  dynamicMessage?: string(name='DynamicMessage', description='dynamicMessage'),
  errorCode?: string(name='ErrorCode', description='errorCode'),
  errorMsg?: string(name='ErrorMsg', description='errorMsg'),
  httpStatusCode?: int32(name='HttpStatusCode', description='httpStatusCode'),
  requestId?: string(name='RequestId', description='requestId'),
  success?: boolean(name='Success', description='success'),
}

model PartnerUpdateTrademarkNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PartnerUpdateTrademarkNameResponseBody(name='body'),
}

async function partnerUpdateTrademarkNameWithOptions(request: PartnerUpdateTrademarkNameRequest, runtime: Util.RuntimeOptions): PartnerUpdateTrademarkNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunKp)) {
    query['AliyunKp'] = request.aliyunKp;
  }
  if (!Util.isUnset(request.bid)) {
    query['Bid'] = request.bid;
  }
  if (!Util.isUnset(request.callerParentId)) {
    query['CallerParentId'] = request.callerParentId;
  }
  if (!Util.isUnset(request.callerType)) {
    query['CallerType'] = request.callerType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.eventSceneType)) {
    body['EventSceneType'] = request.eventSceneType;
  }
  if (!Util.isUnset(request.intentionBizId)) {
    body['IntentionBizId'] = request.intentionBizId;
  }
  if (!Util.isUnset(request.tmComment)) {
    body['TmComment'] = request.tmComment;
  }
  if (!Util.isUnset(request.tmIcon)) {
    body['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    body['TmName'] = request.tmName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PartnerUpdateTrademarkName',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function partnerUpdateTrademarkName(request: PartnerUpdateTrademarkNameRequest): PartnerUpdateTrademarkNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return partnerUpdateTrademarkNameWithOptions(request, runtime);
}

model QueryCommunicationLogsRequest {
  bizId?: string(name='BizId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  type?: int32(name='Type'),
}

model QueryCommunicationLogsResponseBody = {
  data?: {
    taskList?: [ 
    {
      bizId?: string(name='BizId'),
      createTime?: long(name='CreateTime'),
      note?: string(name='Note'),
      partnerCode?: string(name='PartnerCode'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='TaskList')
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryCommunicationLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryCommunicationLogsResponseBody(name='body'),
}

async function queryCommunicationLogsWithOptions(request: QueryCommunicationLogsRequest, runtime: Util.RuntimeOptions): QueryCommunicationLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryCommunicationLogs',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryCommunicationLogs(request: QueryCommunicationLogsRequest): QueryCommunicationLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCommunicationLogsWithOptions(request, runtime);
}

model QueryCredentialsInfoRequest {
  companyName?: string(name='CompanyName'),
  materialType?: string(name='MaterialType'),
  ossKey?: string(name='OssKey'),
}

model QueryCredentialsInfoResponseBody = {
  credentialsInfo?: {
    address?: string(name='Address'),
    cardNumber?: string(name='CardNumber'),
    companyName?: string(name='CompanyName'),
    personName?: string(name='PersonName'),
    province?: string(name='Province'),
  }(name='CredentialsInfo'),
  requestId?: string(name='RequestId'),
}

model QueryCredentialsInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryCredentialsInfoResponseBody(name='body'),
}

async function queryCredentialsInfoWithOptions(request: QueryCredentialsInfoRequest, runtime: Util.RuntimeOptions): QueryCredentialsInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.companyName)) {
    query['CompanyName'] = request.companyName;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.materialType)) {
    body['MaterialType'] = request.materialType;
  }
  if (!Util.isUnset(request.ossKey)) {
    body['OssKey'] = request.ossKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryCredentialsInfo',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryCredentialsInfo(request: QueryCredentialsInfoRequest): QueryCredentialsInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCredentialsInfoWithOptions(request, runtime);
}

model QueryExtensionAttributeRequest {
  attributeKey?: string(name='AttributeKey'),
  bizId?: string(name='BizId'),
}

model QueryExtensionAttributeResponseBody = {
  attributeValue?: string(name='AttributeValue'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryExtensionAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryExtensionAttributeResponseBody(name='body'),
}

async function queryExtensionAttributeWithOptions(request: QueryExtensionAttributeRequest, runtime: Util.RuntimeOptions): QueryExtensionAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.attributeKey)) {
    query['AttributeKey'] = request.attributeKey;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryExtensionAttribute',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryExtensionAttribute(request: QueryExtensionAttributeRequest): QueryExtensionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryExtensionAttributeWithOptions(request, runtime);
}

model QueryIntentionDetailRequest {
  bizId?: string(name='BizId'),
}

model QueryIntentionDetailResponseBody = {
  bizId?: string(name='BizId'),
  classification?: string(name='Classification'),
  createTime?: long(name='CreateTime'),
  description?: string(name='Description'),
  mobile?: string(name='Mobile'),
  partnerMobile?: string(name='PartnerMobile'),
  registerNumber?: string(name='RegisterNumber'),
  relationBizId?: string(name='RelationBizId'),
  requestId?: string(name='RequestId'),
  status?: int32(name='Status'),
  type?: int32(name='Type'),
  updateTime?: long(name='UpdateTime'),
  userId?: string(name='UserId'),
  userName?: string(name='UserName'),
}

model QueryIntentionDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryIntentionDetailResponseBody(name='body'),
}

async function queryIntentionDetailWithOptions(request: QueryIntentionDetailRequest, runtime: Util.RuntimeOptions): QueryIntentionDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryIntentionDetail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryIntentionDetail(request: QueryIntentionDetailRequest): QueryIntentionDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIntentionDetailWithOptions(request, runtime);
}

model QueryIntentionListRequest {
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  sortFiled?: string(name='SortFiled'),
  sortOrder?: string(name='SortOrder'),
  status?: int32(name='Status'),
  type?: int32(name='Type'),
}

model QueryIntentionListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    intention?: [ 
    {
      bizId?: string(name='BizId'),
      classification?: string(name='Classification'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      registerNumber?: string(name='RegisterNumber'),
      status?: int32(name='Status'),
      type?: int32(name='Type'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='Intention')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryIntentionListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryIntentionListResponseBody(name='body'),
}

async function queryIntentionListWithOptions(request: QueryIntentionListRequest, runtime: Util.RuntimeOptions): QueryIntentionListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortFiled)) {
    query['SortFiled'] = request.sortFiled;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryIntentionList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryIntentionList(request: QueryIntentionListRequest): QueryIntentionListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIntentionListWithOptions(request, runtime);
}

model QueryIntentionOwnerRequest {
  bizId?: string(name='BizId'),
}

model QueryIntentionOwnerResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  module?: {
    ownerId?: float(name='OwnerId', description='id'),
    ownerName?: string(name='OwnerName', description=''),
  }(name='Module'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryIntentionOwnerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryIntentionOwnerResponseBody(name='body'),
}

async function queryIntentionOwnerWithOptions(request: QueryIntentionOwnerRequest, runtime: Util.RuntimeOptions): QueryIntentionOwnerResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryIntentionOwner',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryIntentionOwner(request: QueryIntentionOwnerRequest): QueryIntentionOwnerResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIntentionOwnerWithOptions(request, runtime);
}

model QueryIntentionPriceRequest {
  channel?: string(name='Channel'),
  intentionBizId?: string(name='IntentionBizId'),
}

model QueryIntentionPriceResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    tmProduces?: [ 
    {
      bizId?: string(name='BizId'),
      createTime?: long(name='CreateTime'),
      firstClassification?: {
        classificationCode?: string(name='ClassificationCode'),
        classificationName?: string(name='ClassificationName'),
      }(name='FirstClassification'),
      loaUrl?: string(name='LoaUrl'),
      materialId?: string(name='MaterialId'),
      materialName?: string(name='MaterialName'),
      note?: string(name='Note'),
      orderPrice?: float(name='OrderPrice'),
      servicePrice?: float(name='ServicePrice'),
      status?: int32(name='Status'),
      supplementId?: long(name='SupplementId'),
      supplementStatus?: int32(name='SupplementStatus'),
      thirdClassification?: {
        thirdClassifications?: [ 
        {
          classificationCode?: string(name='ClassificationCode'),
          classificationName?: string(name='ClassificationName'),
        }
      ](name='ThirdClassifications')
      }(name='ThirdClassification'),
      tmIcon?: string(name='TmIcon'),
      tmName?: string(name='TmName'),
      tmNumber?: string(name='TmNumber'),
      totalPrice?: float(name='TotalPrice'),
      type?: int32(name='Type'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='TmProduces')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryIntentionPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryIntentionPriceResponseBody(name='body'),
}

async function queryIntentionPriceWithOptions(request: QueryIntentionPriceRequest, runtime: Util.RuntimeOptions): QueryIntentionPriceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.intentionBizId)) {
    query['IntentionBizId'] = request.intentionBizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryIntentionPrice',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryIntentionPrice(request: QueryIntentionPriceRequest): QueryIntentionPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIntentionPriceWithOptions(request, runtime);
}

model QueryMaterialRequest {
  id?: long(name='Id'),
  queryUnconfirmedInfo?: boolean(name='QueryUnconfirmedInfo'),
}

model QueryMaterialResponseBody = {
  address?: string(name='Address'),
  businessLicenceUrl?: string(name='BusinessLicenceUrl'),
  cardNumber?: string(name='CardNumber'),
  city?: string(name='City'),
  contactAddress?: string(name='ContactAddress'),
  contactCity?: string(name='ContactCity'),
  contactCounty?: string(name='ContactCounty'),
  contactDistrict?: string(name='ContactDistrict'),
  contactEmail?: string(name='ContactEmail'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactProvince?: string(name='ContactProvince'),
  contactZipcode?: string(name='ContactZipcode'),
  country?: string(name='Country'),
  EAddress?: string(name='EAddress'),
  EName?: string(name='EName'),
  evidenceCatalogPath?: string(name='EvidenceCatalogPath'),
  evidenceOfservicePath?: string(name='EvidenceOfservicePath'),
  evidencePath?: string(name='EvidencePath'),
  expirationDate?: long(name='ExpirationDate'),
  factandreasonPdfPath?: string(name='FactandreasonPdfPath'),
  fgsqPath?: string(name='FgsqPath'),
  fileBgPath?: string(name='FileBgPath'),
  fileFsSqPath?: string(name='FileFsSqPath'),
  fileGtPath?: string(name='FileGtPath'),
  fileYgPath?: string(name='FileYgPath'),
  id?: long(name='Id'),
  idCardName?: string(name='IdCardName'),
  idCardNumber?: string(name='IdCardNumber'),
  idCardUrl?: string(name='IdCardUrl'),
  legalNoticeKey?: string(name='LegalNoticeKey'),
  legalNoticeUrl?: string(name='LegalNoticeUrl'),
  loaStatus?: int32(name='LoaStatus'),
  loaUrl?: string(name='LoaUrl'),
  materialVersion?: string(name='MaterialVersion'),
  name?: string(name='Name'),
  note?: string(name='Note'),
  passportUrl?: string(name='PassportUrl'),
  personalType?: long(name='PersonalType'),
  principalDescription?: string(name='PrincipalDescription'),
  principalName?: int32(name='PrincipalName'),
  province?: string(name='Province'),
  reason?: string(name='Reason'),
  region?: int32(name='Region'),
  requestId?: string(name='RequestId'),
  reviewAdditionalFiles?: {
    reviewAdditionalFile?: [ string ](name='ReviewAdditionalFile')
  }(name='ReviewAdditionalFiles'),
  reviewApplicationFile?: string(name='ReviewApplicationFile'),
  status?: int32(name='Status'),
  town?: string(name='Town'),
  type?: int32(name='Type'),
  validDate?: long(name='ValidDate'),
}

model QueryMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMaterialResponseBody(name='body'),
}

async function queryMaterialWithOptions(request: QueryMaterialRequest, runtime: Util.RuntimeOptions): QueryMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.queryUnconfirmedInfo)) {
    query['QueryUnconfirmedInfo'] = request.queryUnconfirmedInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMaterial',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMaterial(request: QueryMaterialRequest): QueryMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMaterialWithOptions(request, runtime);
}

model QueryMaterialListRequest {
  cardNumber?: string(name='CardNumber'),
  materialId?: long(name='MaterialId'),
  materialVersion?: string(name='MaterialVersion'),
  name?: string(name='Name'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  principalName?: int32(name='PrincipalName'),
  region?: int32(name='Region'),
  status?: int32(name='Status'),
  type?: int32(name='Type'),
}

model QueryMaterialListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    trademark?: [ 
    {
      cardNumber?: string(name='CardNumber'),
      contactName?: string(name='ContactName'),
      id?: long(name='Id'),
      loaKey?: string(name='LoaKey'),
      loaStatus?: int32(name='LoaStatus'),
      materialVersion?: string(name='MaterialVersion'),
      name?: string(name='Name'),
      principalDescription?: string(name='PrincipalDescription'),
      principalName?: int32(name='PrincipalName'),
      reason?: string(name='Reason'),
      region?: int32(name='Region'),
      status?: int32(name='Status'),
      type?: int32(name='Type'),
      validDate?: long(name='ValidDate'),
    }
  ](name='Trademark')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryMaterialListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMaterialListResponseBody(name='body'),
}

async function queryMaterialListWithOptions(request: QueryMaterialListRequest, runtime: Util.RuntimeOptions): QueryMaterialListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cardNumber)) {
    query['CardNumber'] = request.cardNumber;
  }
  if (!Util.isUnset(request.materialId)) {
    query['MaterialId'] = request.materialId;
  }
  if (!Util.isUnset(request.materialVersion)) {
    query['MaterialVersion'] = request.materialVersion;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMaterialList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMaterialList(request: QueryMaterialListRequest): QueryMaterialListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMaterialListWithOptions(request, runtime);
}

model QueryMonitorKeywordsRequest {
  keywords?: [ string ](name='Keywords'),
  ruleType?: int32(name='RuleType'),
}

model QueryMonitorKeywordsResponseBody = {
  data?: {
    keywords?: [ string ](name='Keywords')
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryMonitorKeywordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMonitorKeywordsResponseBody(name='body'),
}

async function queryMonitorKeywordsWithOptions(request: QueryMonitorKeywordsRequest, runtime: Util.RuntimeOptions): QueryMonitorKeywordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keywords)) {
    query['Keywords'] = request.keywords;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMonitorKeywords',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMonitorKeywords(request: QueryMonitorKeywordsRequest): QueryMonitorKeywordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMonitorKeywordsWithOptions(request, runtime);
}

model QueryOfficialFileCustomListRequest {
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model QueryOfficialFileCustomListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    customList?: [ 
    {
      createTime?: long(name='CreateTime'),
      downloadUrl?: string(name='DownloadUrl'),
      endAcceptTime?: long(name='EndAcceptTime'),
      expireTime?: long(name='ExpireTime'),
      remark?: string(name='Remark'),
      startAcceptTime?: long(name='StartAcceptTime'),
      status?: string(name='Status'),
    }
  ](name='CustomList')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryOfficialFileCustomListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryOfficialFileCustomListResponseBody(name='body'),
}

async function queryOfficialFileCustomListWithOptions(request: QueryOfficialFileCustomListRequest, runtime: Util.RuntimeOptions): QueryOfficialFileCustomListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOfficialFileCustomList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOfficialFileCustomList(request: QueryOfficialFileCustomListRequest): QueryOfficialFileCustomListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOfficialFileCustomListWithOptions(request, runtime);
}

model QueryOrderLogisticsListRequest {
  pageNum?: long(name='PageNum', description=''),
  pageSize?: long(name='PageSize', description=''),
  produceOrderId?: string(name='ProduceOrderId', description=''),
  registerNumber?: string(name='RegisterNumber', description=''),
}

model QueryOrderLogisticsListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: [ 
    {
      bizId?: string(name='BizId'),
      fileIdentifier?: string(name='FileIdentifier', description=''),
      fileType?: string(name='FileType', description=''),
      logisticsNo?: string(name='LogisticsNo', description=''),
      produceOrderId?: string(name='ProduceOrderId', description=''),
      tmIcon?: string(name='TmIcon'),
      tmName?: string(name='TmName', description=''),
      tmNumber?: string(name='TmNumber'),
    }
  ](name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryOrderLogisticsListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryOrderLogisticsListResponseBody(name='body'),
}

async function queryOrderLogisticsListWithOptions(request: QueryOrderLogisticsListRequest, runtime: Util.RuntimeOptions): QueryOrderLogisticsListResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.produceOrderId)) {
    body['ProduceOrderId'] = request.produceOrderId;
  }
  if (!Util.isUnset(request.registerNumber)) {
    body['RegisterNumber'] = request.registerNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryOrderLogisticsList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOrderLogisticsList(request: QueryOrderLogisticsListRequest): QueryOrderLogisticsListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOrderLogisticsListWithOptions(request, runtime);
}

model QueryOssResourcesRequest {
  bizId?: string(name='BizId'),
}

model QueryOssResourcesResponseBody = {
  data?: {
    taskList?: [ 
    {
      bizId?: string(name='BizId'),
      createTime?: long(name='CreateTime'),
      name?: string(name='Name'),
      ossUrl?: string(name='OssUrl'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='TaskList')
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryOssResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryOssResourcesResponseBody(name='body'),
}

async function queryOssResourcesWithOptions(request: QueryOssResourcesRequest, runtime: Util.RuntimeOptions): QueryOssResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOssResources',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOssResources(request: QueryOssResourcesRequest): QueryOssResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOssResourcesWithOptions(request, runtime);
}

model QueryProduceListRequest {
  bizId?: string(name='BizId'),
  createTimeLeft?: long(name='CreateTimeLeft'),
  createTimeRight?: long(name='CreateTimeRight'),
  materialName?: string(name='MaterialName'),
  orderId?: string(name='OrderId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  status?: int32(name='Status'),
  tmName?: string(name='TmName'),
  tmNumber?: string(name='TmNumber'),
  type?: int32(name='Type'),
  userId?: string(name='UserId'),
}

model QueryProduceListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    tmProduces?: [ 
    {
      bizId?: string(name='BizId'),
      classification?: {
        classificationCode?: string(name='ClassificationCode'),
        classificationName?: string(name='ClassificationName'),
      }(name='Classification'),
      createTime?: long(name='CreateTime'),
      loaUrl?: string(name='LoaUrl'),
      materialName?: string(name='MaterialName'),
      note?: string(name='Note'),
      orderId?: string(name='OrderId'),
      orderPrice?: float(name='OrderPrice'),
      principalName?: int32(name='PrincipalName'),
      receiptUrl?: string(name='ReceiptUrl'),
      status?: int32(name='Status'),
      submitCount?: int32(name='SubmitCount'),
      tmIcon?: string(name='TmIcon'),
      tmName?: string(name='TmName'),
      tmNumber?: string(name='TmNumber'),
      type?: int32(name='Type'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='TmProduces')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryProduceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryProduceListResponseBody(name='body'),
}

async function queryProduceListWithOptions(request: QueryProduceListRequest, runtime: Util.RuntimeOptions): QueryProduceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.createTimeLeft)) {
    query['CreateTimeLeft'] = request.createTimeLeft;
  }
  if (!Util.isUnset(request.createTimeRight)) {
    query['CreateTimeRight'] = request.createTimeRight;
  }
  if (!Util.isUnset(request.materialName)) {
    query['MaterialName'] = request.materialName;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNumber)) {
    query['TmNumber'] = request.tmNumber;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryProduceList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryProduceList(request: QueryProduceListRequest): QueryProduceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryProduceListWithOptions(request, runtime);
}

model QueryQrCodeUploadStatusRequest {
  fieldKey?: string(name='FieldKey'),
  ossKey?: string(name='OssKey'),
  uuid?: string(name='Uuid'),
}

model QueryQrCodeUploadStatusResponseBody = {
  ossKey?: string(name='OssKey'),
  ossUrl?: string(name='OssUrl'),
  requestId?: string(name='RequestId'),
  status?: int32(name='Status'),
  success?: boolean(name='Success'),
}

model QueryQrCodeUploadStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryQrCodeUploadStatusResponseBody(name='body'),
}

async function queryQrCodeUploadStatusWithOptions(request: QueryQrCodeUploadStatusRequest, runtime: Util.RuntimeOptions): QueryQrCodeUploadStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fieldKey)) {
    query['FieldKey'] = request.fieldKey;
  }
  if (!Util.isUnset(request.ossKey)) {
    query['OssKey'] = request.ossKey;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryQrCodeUploadStatus',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryQrCodeUploadStatus(request: QueryQrCodeUploadStatusRequest): QueryQrCodeUploadStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryQrCodeUploadStatusWithOptions(request, runtime);
}

model QuerySupplementDetailRequest {
  id?: long(name='Id'),
}

model QuerySupplementDetailResponseBody = {
  acceptDeadTime?: long(name='AcceptDeadTime'),
  acceptTime?: long(name='AcceptTime'),
  content?: string(name='Content'),
  fileTemplateUrls?: {
    fileTemplateUrls?: [ string ](name='FileTemplateUrls')
  }(name='FileTemplateUrls'),
  id?: long(name='Id'),
  operateTime?: long(name='OperateTime'),
  requestId?: string(name='RequestId'),
  sbjDeadTime?: long(name='SbjDeadTime'),
  sendTime?: long(name='SendTime'),
  serialNumber?: string(name='SerialNumber'),
  status?: int32(name='Status'),
  tmNumber?: string(name='TmNumber'),
  type?: int32(name='Type'),
  uploadFileTemplateUrl?: string(name='UploadFileTemplateUrl'),
}

model QuerySupplementDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySupplementDetailResponseBody(name='body'),
}

async function querySupplementDetailWithOptions(request: QuerySupplementDetailRequest, runtime: Util.RuntimeOptions): QuerySupplementDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySupplementDetail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySupplementDetail(request: QuerySupplementDetailRequest): QuerySupplementDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySupplementDetailWithOptions(request, runtime);
}

model QueryTaskListRequest {
  bizType?: string(name='BizType'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model QueryTaskListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    taskList?: [ 
    {
      completeTime?: long(name='CompleteTime'),
      createTime?: long(name='CreateTime'),
      errMsg?: string(name='ErrMsg'),
      fileName?: string(name='FileName'),
      result?: string(name='Result'),
      taskStatus?: string(name='TaskStatus'),
      taskType?: string(name='TaskType'),
    }
  ](name='TaskList')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTaskListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTaskListResponseBody(name='body'),
}

async function queryTaskListWithOptions(request: QueryTaskListRequest, runtime: Util.RuntimeOptions): QueryTaskListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTaskList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTaskList(request: QueryTaskListRequest): QueryTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskListWithOptions(request, runtime);
}

model QueryTmCollectionPageListRequest {
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model QueryTmCollectionPageListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    trademark?: [ 
    {
      classification?: string(name='Classification'),
      collected?: boolean(name='Collected'),
      collectionContent?: string(name='CollectionContent'),
      id?: long(name='Id'),
      itemId?: string(name='ItemId'),
      tmName?: string(name='TmName'),
    }
  ](name='Trademark')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTmCollectionPageListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTmCollectionPageListResponseBody(name='body'),
}

async function queryTmCollectionPageListWithOptions(request: QueryTmCollectionPageListRequest, runtime: Util.RuntimeOptions): QueryTmCollectionPageListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTmCollectionPageList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTmCollectionPageList(request: QueryTmCollectionPageListRequest): QueryTmCollectionPageListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTmCollectionPageListWithOptions(request, runtime);
}

model QueryTradeIntentionUserListRequest {
  begin?: long(name='Begin'),
  bizId?: string(name='BizId'),
  end?: long(name='End'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  status?: int32(name='Status'),
}

model QueryTradeIntentionUserListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    trademark?: [ 
    {
      bizId?: string(name='BizId'),
      classification?: string(name='Classification'),
      description?: string(name='Description'),
      documentDate?: string(name='DocumentDate'),
      documentName?: string(name='DocumentName'),
      documentUrl?: string(name='DocumentUrl'),
      mobile?: string(name='Mobile'),
      registerNumber?: string(name='RegisterNumber'),
      status?: int32(name='Status'),
      type?: int32(name='Type'),
      userName?: string(name='UserName'),
    }
  ](name='Trademark')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTradeIntentionUserListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTradeIntentionUserListResponseBody(name='body'),
}

async function queryTradeIntentionUserListWithOptions(request: QueryTradeIntentionUserListRequest, runtime: Util.RuntimeOptions): QueryTradeIntentionUserListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.begin)) {
    query['Begin'] = request.begin;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.end)) {
    query['End'] = request.end;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTradeIntentionUserList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTradeIntentionUserList(request: QueryTradeIntentionUserListRequest): QueryTradeIntentionUserListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeIntentionUserListWithOptions(request, runtime);
}

model QueryTradeMarkApplicationDetailRequest {
  bizId?: string(name='BizId'),
}

model QueryTradeMarkApplicationDetailResponseBody = {
  acceptUrl?: string(name='AcceptUrl'),
  adminUploads?: {
    licensePicUrl?: string(name='LicensePicUrl'),
    loaPicUrl?: string(name='LoaPicUrl'),
  }(name='AdminUploads'),
  bizId?: string(name='BizId'),
  createTime?: long(name='CreateTime'),
  extendInfo?: map[string]any(name='ExtendInfo'),
  firstClassification?: {
    code?: string(name='Code'),
    name?: string(name='Name'),
  }(name='FirstClassification'),
  flags?: {
    flag?: [ int32 ](name='Flag')
  }(name='Flags'),
  grayIconUrl?: string(name='GrayIconUrl'),
  judgeResultUrl?: {
    judgeResultUrl?: [ string ](name='JudgeResultUrl')
  }(name='JudgeResultUrl'),
  legalNoticeUrl?: string(name='LegalNoticeUrl'),
  loaUrl?: string(name='LoaUrl'),
  logisticsCertificateUrl?: string(name='LogisticsCertificateUrl'),
  logisticsNo?: string(name='LogisticsNo'),
  materialDetail?: {
    address?: string(name='Address'),
    businessLicenceUrl?: string(name='BusinessLicenceUrl'),
    cardNumber?: string(name='CardNumber'),
    city?: string(name='City'),
    contactAddress?: string(name='ContactAddress'),
    contactCity?: string(name='ContactCity'),
    contactDistrict?: string(name='ContactDistrict'),
    contactEmail?: string(name='ContactEmail'),
    contactName?: string(name='ContactName'),
    contactNumber?: string(name='ContactNumber'),
    contactProvince?: string(name='ContactProvince'),
    contactZipcode?: string(name='ContactZipcode'),
    country?: string(name='Country'),
    detailedContactAddress?: string(name='DetailedContactAddress', description=''),
    EAddress?: string(name='EAddress'),
    EName?: string(name='EName'),
    expirationDate?: string(name='ExpirationDate'),
    idCardName?: string(name='IdCardName'),
    idCardNumber?: string(name='IdCardNumber'),
    idCardUrl?: string(name='IdCardUrl'),
    legalNoticeUrl?: string(name='LegalNoticeUrl'),
    loaUrl?: string(name='LoaUrl'),
    materialVersion?: string(name='MaterialVersion'),
    name?: string(name='Name'),
    passportUrl?: string(name='PassportUrl'),
    personalType?: long(name='PersonalType'),
    principalName?: int32(name='PrincipalName'),
    province?: string(name='Province'),
    region?: int32(name='Region'),
    reviewAdditionalFiles?: {
      reviewAdditionalFile?: [ string ](name='ReviewAdditionalFile')
    }(name='ReviewAdditionalFiles'),
    reviewApplicationFile?: string(name='ReviewApplicationFile'),
    status?: int32(name='Status'),
    town?: string(name='Town'),
    type?: int32(name='Type'),
  }(name='MaterialDetail'),
  materialId?: long(name='MaterialId'),
  notAcceptUrl?: string(name='NotAcceptUrl'),
  note?: string(name='Note'),
  orderId?: string(name='OrderId'),
  orderPrice?: float(name='OrderPrice'),
  partnerCode?: string(name='PartnerCode'),
  partnerMobile?: string(name='PartnerMobile'),
  partnerName?: string(name='PartnerName'),
  principalName?: int32(name='PrincipalName'),
  receiptUrl?: {
    receiptUrl?: [ string ](name='ReceiptUrl')
  }(name='ReceiptUrl'),
  recvUserLogistics?: string(name='RecvUserLogistics'),
  renewResponse?: {
    address?: string(name='Address'),
    engAddress?: string(name='EngAddress'),
    engName?: string(name='EngName'),
    name?: string(name='Name'),
    registerTime?: long(name='RegisterTime'),
    submitSbjtime?: long(name='SubmitSbjtime'),
  }(name='RenewResponse'),
  requestId?: string(name='RequestId'),
  reviewOfficialFiles?: {
    reviewAudit?: string(name='ReviewAudit'),
    reviewKeep?: string(name='ReviewKeep'),
    reviewPart?: string(name='ReviewPart'),
    reviewPass?: string(name='ReviewPass'),
    reviewSupplements?: {
      reviewSupplement?: [ string ](name='ReviewSupplement')
    }(name='ReviewSupplements'),
  }(name='ReviewOfficialFiles'),
  sendSbjLogistics?: string(name='SendSbjLogistics'),
  sendTime?: string(name='SendTime'),
  sendUserLogistics?: string(name='SendUserLogistics'),
  servicePrice?: float(name='ServicePrice'),
  status?: int32(name='Status'),
  submitAuditTime?: long(name='SubmitAuditTime'),
  submitTime?: long(name='SubmitTime'),
  supplements?: {
    supplements?: [ 
    {
      acceptDeadTime?: long(name='AcceptDeadTime'),
      acceptTime?: long(name='AcceptTime'),
      batchNum?: string(name='BatchNum'),
      content?: string(name='Content'),
      fileTemplateUrls?: {
        fileTemplateUrls?: [ string ](name='FileTemplateUrls')
      }(name='FileTemplateUrls'),
      id?: long(name='Id'),
      operateTime?: long(name='OperateTime'),
      orderId?: string(name='OrderId'),
      sbjDeadTime?: long(name='SbjDeadTime'),
      sendTime?: long(name='SendTime'),
      serialNumber?: string(name='SerialNumber'),
      status?: int32(name='Status'),
      tmNumber?: string(name='TmNumber'),
      type?: int32(name='Type'),
      uploadFileTemplateUrl?: string(name='UploadFileTemplateUrl'),
    }
  ](name='Supplements')
  }(name='Supplements'),
  thirdClassification?: {
    thirdClassifications?: [ 
    {
      code?: string(name='Code'),
      name?: string(name='Name'),
    }
  ](name='ThirdClassifications')
  }(name='ThirdClassification'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  tmNameType?: int32(name='TmNameType'),
  tmNumber?: string(name='TmNumber'),
  totalPrice?: float(name='TotalPrice'),
  type?: int32(name='Type'),
  updateTime?: long(name='UpdateTime'),
}

model QueryTradeMarkApplicationDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTradeMarkApplicationDetailResponseBody(name='body'),
}

async function queryTradeMarkApplicationDetailWithOptions(request: QueryTradeMarkApplicationDetailRequest, runtime: Util.RuntimeOptions): QueryTradeMarkApplicationDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTradeMarkApplicationDetail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTradeMarkApplicationDetail(request: QueryTradeMarkApplicationDetailRequest): QueryTradeMarkApplicationDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeMarkApplicationDetailWithOptions(request, runtime);
}

model QueryTradeMarkApplicationLogsRequest {
  bizId?: string(name='BizId'),
}

model QueryTradeMarkApplicationLogsResponseBody = {
  data?: {
    data?: [ 
    {
      bizId?: string(name='BizId'),
      bizStatus?: int32(name='BizStatus'),
      extendContent?: string(name='ExtendContent'),
      note?: string(name='Note'),
      operateTime?: long(name='OperateTime'),
      operateType?: int32(name='OperateType'),
    }
  ](name='Data')
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryTradeMarkApplicationLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTradeMarkApplicationLogsResponseBody(name='body'),
}

async function queryTradeMarkApplicationLogsWithOptions(request: QueryTradeMarkApplicationLogsRequest, runtime: Util.RuntimeOptions): QueryTradeMarkApplicationLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTradeMarkApplicationLogs',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTradeMarkApplicationLogs(request: QueryTradeMarkApplicationLogsRequest): QueryTradeMarkApplicationLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeMarkApplicationLogsWithOptions(request, runtime);
}

model QueryTradeMarkApplicationsRequest {
  bizId?: string(name='BizId'),
  classificationCode?: string(name='ClassificationCode'),
  hidden?: int32(name='Hidden'),
  intentionBizId?: string(name='IntentionBizId'),
  logisticsNo?: string(name='LogisticsNo'),
  materialName?: string(name='MaterialName'),
  orderId?: string(name='OrderId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  productType?: int32(name='ProductType'),
  sortFiled?: string(name='SortFiled'),
  sortOrder?: string(name='SortOrder'),
  status?: int32(name='Status'),
  supplementStatus?: int32(name='SupplementStatus'),
  tmName?: string(name='TmName'),
  tmNumber?: string(name='TmNumber'),
  type?: string(name='Type'),
}

model QueryTradeMarkApplicationsResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    tmProduces?: [ 
    {
      bizId?: string(name='BizId'),
      createTime?: long(name='CreateTime'),
      firstClassification?: {
        classificationCode?: string(name='ClassificationCode'),
        classificationName?: string(name='ClassificationName'),
      }(name='FirstClassification'),
      flags?: {
        flags?: [ string ](name='Flags')
      }(name='Flags'),
      loaUrl?: string(name='LoaUrl'),
      materialId?: long(name='MaterialId'),
      materialName?: string(name='MaterialName'),
      note?: string(name='Note'),
      orderId?: string(name='OrderId'),
      orderPrice?: float(name='OrderPrice'),
      principalName?: int32(name='PrincipalName'),
      remark?: string(name='Remark'),
      renewResponse?: {
        address?: string(name='Address'),
        engAddress?: string(name='EngAddress'),
        engName?: string(name='EngName'),
        name?: string(name='Name'),
        registerTime?: long(name='RegisterTime'),
        submitSbjtime?: long(name='SubmitSbjtime'),
      }(name='RenewResponse'),
      servicePrice?: float(name='ServicePrice'),
      status?: int32(name='Status'),
      submitAuditTime?: long(name='SubmitAuditTime'),
      submitTime?: long(name='SubmitTime'),
      supplementId?: long(name='SupplementId'),
      supplementStatus?: int32(name='SupplementStatus'),
      thirdClassification?: {
        thirdClassifications?: [ 
        {
          classificationCode?: string(name='ClassificationCode'),
          classificationName?: string(name='ClassificationName'),
        }
      ](name='ThirdClassifications')
      }(name='ThirdClassification'),
      tmIcon?: string(name='TmIcon'),
      tmName?: string(name='TmName'),
      tmNumber?: string(name='TmNumber'),
      totalPrice?: float(name='TotalPrice'),
      type?: int32(name='Type'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='TmProduces')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTradeMarkApplicationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTradeMarkApplicationsResponseBody(name='body'),
}

async function queryTradeMarkApplicationsWithOptions(request: QueryTradeMarkApplicationsRequest, runtime: Util.RuntimeOptions): QueryTradeMarkApplicationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.classificationCode)) {
    query['ClassificationCode'] = request.classificationCode;
  }
  if (!Util.isUnset(request.hidden)) {
    query['Hidden'] = request.hidden;
  }
  if (!Util.isUnset(request.intentionBizId)) {
    query['IntentionBizId'] = request.intentionBizId;
  }
  if (!Util.isUnset(request.logisticsNo)) {
    query['LogisticsNo'] = request.logisticsNo;
  }
  if (!Util.isUnset(request.materialName)) {
    query['MaterialName'] = request.materialName;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.sortFiled)) {
    query['SortFiled'] = request.sortFiled;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.supplementStatus)) {
    query['SupplementStatus'] = request.supplementStatus;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNumber)) {
    query['TmNumber'] = request.tmNumber;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTradeMarkApplications',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTradeMarkApplications(request: QueryTradeMarkApplicationsRequest): QueryTradeMarkApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeMarkApplicationsWithOptions(request, runtime);
}

model QueryTradeMarkApplicationsByIntentionRequest {
  channel?: string(name='Channel'),
  intentionBizId?: string(name='IntentionBizId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tmProduceStatus?: string(name='TmProduceStatus'),
}

model QueryTradeMarkApplicationsByIntentionResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    tmProduces?: [ 
    {
      bizId?: string(name='BizId'),
      createTime?: long(name='CreateTime'),
      firstClassification?: {
        classificationCode?: string(name='ClassificationCode'),
        classificationName?: string(name='ClassificationName'),
      }(name='FirstClassification'),
      loaUrl?: string(name='LoaUrl'),
      materialId?: string(name='MaterialId'),
      materialName?: string(name='MaterialName'),
      note?: string(name='Note'),
      orderPrice?: float(name='OrderPrice'),
      principalDescription?: string(name='PrincipalDescription'),
      principalValue?: int32(name='PrincipalValue'),
      servicePrice?: float(name='ServicePrice'),
      status?: int32(name='Status'),
      supplementId?: long(name='SupplementId'),
      supplementStatus?: int32(name='SupplementStatus'),
      thirdClassification?: {
        thirdClassifications?: [ 
        {
          classificationCode?: string(name='ClassificationCode'),
          classificationName?: string(name='ClassificationName'),
        }
      ](name='ThirdClassifications')
      }(name='ThirdClassification'),
      tmIcon?: string(name='TmIcon'),
      tmName?: string(name='TmName'),
      tmNumber?: string(name='TmNumber'),
      totalPrice?: float(name='TotalPrice'),
      type?: int32(name='Type'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='TmProduces')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTradeMarkApplicationsByIntentionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTradeMarkApplicationsByIntentionResponseBody(name='body'),
}

async function queryTradeMarkApplicationsByIntentionWithOptions(request: QueryTradeMarkApplicationsByIntentionRequest, runtime: Util.RuntimeOptions): QueryTradeMarkApplicationsByIntentionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.intentionBizId)) {
    query['IntentionBizId'] = request.intentionBizId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tmProduceStatus)) {
    query['TmProduceStatus'] = request.tmProduceStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTradeMarkApplicationsByIntention',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTradeMarkApplicationsByIntention(request: QueryTradeMarkApplicationsByIntentionRequest): QueryTradeMarkApplicationsByIntentionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeMarkApplicationsByIntentionWithOptions(request, runtime);
}

model QueryTradeProduceDetailRequest {
  bizId?: string(name='BizId'),
}

model QueryTradeProduceDetailResponseBody = {
  data?: {
    allowCancel?: boolean(name='AllowCancel'),
    bizId?: string(name='BizId'),
    buyerStatus?: int32(name='BuyerStatus'),
    classification?: string(name='Classification'),
    confiscateAmount?: float(name='ConfiscateAmount'),
    createTime?: long(name='CreateTime'),
    exclusiveDateLimit?: string(name='ExclusiveDateLimit'),
    extend?: map[string]any(name='Extend'),
    finalAmount?: float(name='FinalAmount'),
    icon?: string(name='Icon'),
    operateNote?: string(name='OperateNote'),
    paidAmount?: float(name='PaidAmount'),
    preAmount?: float(name='PreAmount'),
    preOrderId?: string(name='PreOrderId'),
    refundAmount?: float(name='RefundAmount'),
    registerNumber?: string(name='RegisterNumber'),
    share?: string(name='Share'),
    source?: int32(name='Source'),
    thirdCode?: string(name='ThirdCode'),
    tmName?: string(name='TmName'),
    updateTime?: long(name='UpdateTime'),
    userId?: string(name='UserId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryTradeProduceDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTradeProduceDetailResponseBody(name='body'),
}

async function queryTradeProduceDetailWithOptions(request: QueryTradeProduceDetailRequest, runtime: Util.RuntimeOptions): QueryTradeProduceDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTradeProduceDetail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTradeProduceDetail(request: QueryTradeProduceDetailRequest): QueryTradeProduceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeProduceDetailWithOptions(request, runtime);
}

model QueryTradeProduceListRequest {
  bizId?: string(name='BizId'),
  buyerStatus?: int32(name='BuyerStatus'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  preOrderId?: string(name='PreOrderId'),
  registerNumber?: string(name='RegisterNumber'),
  sortFiled?: string(name='SortFiled'),
  sortOrder?: string(name='SortOrder'),
}

model QueryTradeProduceListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    tradeProduces?: [ 
    {
      allowCancel?: boolean(name='AllowCancel'),
      bizId?: string(name='BizId'),
      buyerStatus?: int32(name='BuyerStatus'),
      classification?: string(name='Classification'),
      createTime?: long(name='CreateTime'),
      failReason?: int32(name='FailReason'),
      finalAmount?: float(name='FinalAmount'),
      icon?: string(name='Icon'),
      operateNote?: string(name='OperateNote'),
      preAmount?: float(name='PreAmount'),
      preOrderId?: string(name='PreOrderId'),
      registerNumber?: string(name='RegisterNumber'),
      source?: int32(name='Source'),
      updateTime?: long(name='UpdateTime'),
      userId?: string(name='UserId'),
    }
  ](name='TradeProduces')
  }(name='Data'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTradeProduceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTradeProduceListResponseBody(name='body'),
}

async function queryTradeProduceListWithOptions(request: QueryTradeProduceListRequest, runtime: Util.RuntimeOptions): QueryTradeProduceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.buyerStatus)) {
    query['BuyerStatus'] = request.buyerStatus;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.preOrderId)) {
    query['PreOrderId'] = request.preOrderId;
  }
  if (!Util.isUnset(request.registerNumber)) {
    query['RegisterNumber'] = request.registerNumber;
  }
  if (!Util.isUnset(request.sortFiled)) {
    query['SortFiled'] = request.sortFiled;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTradeProduceList',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTradeProduceList(request: QueryTradeProduceListRequest): QueryTradeProduceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTradeProduceListWithOptions(request, runtime);
}

model QueryTrademarkDetailByApplyNumberRequest {
  applyNumber?: string(name='ApplyNumber'),
  env?: string(name='Env'),
}

model QueryTrademarkDetailByApplyNumberResponseBody = {
  moudle?: {
    bitFlag?: int32(name='BitFlag'),
    bizId?: string(name='BizId'),
    bizType?: string(name='BizType'),
    extendInfo?: map[string]any(name='ExtendInfo'),
    grayIconUrl?: string(name='GrayIconUrl'),
    icon?: string(name='Icon'),
    leafCodes?: {
      leafCode?: [ 
      {
        classificationCode?: string(name='ClassificationCode'),
        classificationName?: string(name='ClassificationName'),
      }
    ](name='leafCode')
    }(name='LeafCodes'),
    materialInfo?: {
      address?: string(name='Address'),
      businessLicenceUrl?: string(name='BusinessLicenceUrl'),
      cardNumber?: string(name='CardNumber'),
      cnInfoUrl?: string(name='CnInfoUrl'),
      contactAddress?: string(name='ContactAddress'),
      contactEmail?: string(name='ContactEmail'),
      contactName?: string(name='ContactName'),
      contactPhoneNumber?: string(name='ContactPhoneNumber'),
      contactZipCode?: string(name='ContactZipCode'),
      country?: string(name='Country'),
      EAddress?: string(name='EAddress'),
      EName?: string(name='EName'),
      idCardNumber?: string(name='IdCardNumber'),
      idCardUrl?: string(name='IdCardUrl'),
      loaKey?: string(name='LoaKey'),
      loaUrl?: string(name='LoaUrl'),
      name?: string(name='Name'),
      passportUrl?: string(name='PassportUrl'),
      personalType?: int32(name='PersonalType'),
      postCode?: string(name='PostCode'),
      province?: string(name='Province'),
      reasonFileOssKey?: string(name='ReasonFileOssKey'),
      region?: int32(name='Region'),
      reviewFileMap?: map[string]any(name='ReviewFileMap'),
      type?: int32(name='Type'),
    }(name='MaterialInfo'),
    orderId?: string(name='OrderId'),
    partnerCode?: string(name='PartnerCode'),
    principalKey?: string(name='PrincipalKey'),
    principalName?: string(name='PrincipalName'),
    produceType?: string(name='ProduceType'),
    rootCode?: {
      classificationCode?: string(name='ClassificationCode'),
      classificationName?: string(name='ClassificationName'),
    }(name='RootCode'),
    status?: string(name='Status'),
    statusStr?: string(name='StatusStr'),
    submitAuditTimeStr?: string(name='SubmitAuditTimeStr'),
    submitAuditTimeValue?: long(name='SubmitAuditTimeValue'),
    submitStatus?: string(name='SubmitStatus'),
    submitTimeStr?: string(name='SubmitTimeStr'),
    submitTimeValue?: long(name='SubmitTimeValue'),
    submitTimes?: int32(name='SubmitTimes'),
    trademarkName?: string(name='TrademarkName'),
    trademarkNameType?: int32(name='TrademarkNameType'),
    trademarkNumber?: string(name='TrademarkNumber'),
  }(name='Moudle'),
  requestId?: string(name='RequestId'),
}

model QueryTrademarkDetailByApplyNumberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkDetailByApplyNumberResponseBody(name='body'),
}

async function queryTrademarkDetailByApplyNumberWithOptions(request: QueryTrademarkDetailByApplyNumberRequest, runtime: Util.RuntimeOptions): QueryTrademarkDetailByApplyNumberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applyNumber)) {
    query['ApplyNumber'] = request.applyNumber;
  }
  if (!Util.isUnset(request.env)) {
    query['Env'] = request.env;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkDetailByApplyNumber',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkDetailByApplyNumber(request: QueryTrademarkDetailByApplyNumberRequest): QueryTrademarkDetailByApplyNumberResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkDetailByApplyNumberWithOptions(request, runtime);
}

model QueryTrademarkDetailByApplyNumberEspRequest {
  applyNumber?: string(name='ApplyNumber'),
  bizType?: string(name='BizType'),
}

model QueryTrademarkDetailByApplyNumberEspResponseBody = {
  moudle?: {
    bitFlag?: int32(name='BitFlag'),
    bizId?: string(name='BizId'),
    bizType?: string(name='BizType'),
    extendInfo?: map[string]any(name='ExtendInfo'),
    grayIconUrl?: string(name='GrayIconUrl'),
    icon?: string(name='Icon'),
    leafCodes?: {
      leafCode?: [ 
      {
        classificationCode?: string(name='ClassificationCode'),
        classificationName?: string(name='ClassificationName'),
      }
    ](name='leafCode')
    }(name='LeafCodes'),
    materialInfo?: {
      address?: string(name='Address'),
      businessLicenceUrl?: string(name='BusinessLicenceUrl'),
      cardNumber?: string(name='CardNumber'),
      cnInfoUrl?: string(name='CnInfoUrl'),
      contactAddress?: string(name='ContactAddress'),
      contactEmail?: string(name='ContactEmail'),
      contactName?: string(name='ContactName'),
      contactPhoneNumber?: string(name='ContactPhoneNumber'),
      contactZipCode?: string(name='ContactZipCode'),
      country?: string(name='Country'),
      EAddress?: string(name='EAddress'),
      EName?: string(name='EName'),
      idCardNumber?: string(name='IdCardNumber'),
      idCardUrl?: string(name='IdCardUrl'),
      loaKey?: string(name='LoaKey'),
      loaUrl?: string(name='LoaUrl'),
      name?: string(name='Name'),
      passportUrl?: string(name='PassportUrl'),
      personalType?: int32(name='PersonalType'),
      postCode?: string(name='PostCode'),
      province?: string(name='Province'),
      reasonFileOssKey?: string(name='ReasonFileOssKey'),
      region?: int32(name='Region'),
      reviewFileMap?: map[string]any(name='ReviewFileMap'),
      type?: int32(name='Type'),
    }(name='MaterialInfo'),
    orderId?: string(name='OrderId'),
    partnerCode?: string(name='PartnerCode'),
    principalKey?: string(name='PrincipalKey'),
    principalName?: string(name='PrincipalName'),
    produceType?: string(name='ProduceType'),
    rootCode?: {
      classificationCode?: string(name='ClassificationCode'),
      classificationName?: string(name='ClassificationName'),
    }(name='RootCode'),
    status?: string(name='Status'),
    statusStr?: string(name='StatusStr'),
    submitAuditTimeStr?: string(name='SubmitAuditTimeStr'),
    submitAuditTimeValue?: long(name='SubmitAuditTimeValue'),
    submitStatus?: string(name='SubmitStatus'),
    submitTimeStr?: string(name='SubmitTimeStr'),
    submitTimeValue?: long(name='SubmitTimeValue'),
    submitTimes?: int32(name='SubmitTimes'),
    trademarkName?: string(name='TrademarkName'),
    trademarkNameType?: int32(name='TrademarkNameType'),
    trademarkNumber?: string(name='TrademarkNumber'),
  }(name='Moudle'),
  requestId?: string(name='RequestId'),
}

model QueryTrademarkDetailByApplyNumberEspResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkDetailByApplyNumberEspResponseBody(name='body'),
}

async function queryTrademarkDetailByApplyNumberEspWithOptions(request: QueryTrademarkDetailByApplyNumberEspRequest, runtime: Util.RuntimeOptions): QueryTrademarkDetailByApplyNumberEspResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applyNumber)) {
    query['ApplyNumber'] = request.applyNumber;
  }
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkDetailByApplyNumberEsp',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkDetailByApplyNumberEsp(request: QueryTrademarkDetailByApplyNumberEspRequest): QueryTrademarkDetailByApplyNumberEspResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkDetailByApplyNumberEspWithOptions(request, runtime);
}

model QueryTrademarkMonitorResultsRequest {
  actionType?: int32(name='ActionType'),
  applyYear?: string(name='ApplyYear'),
  classification?: string(name='Classification'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  procedureStatus?: int32(name='ProcedureStatus'),
  registrationNumber?: string(name='RegistrationNumber'),
  ruleId?: long(name='RuleId'),
  tmName?: string(name='TmName'),
}

model QueryTrademarkMonitorResultsResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    tmMonitorResult?: [ 
    {
      applyDate?: string(name='ApplyDate'),
      chesanEndDate?: string(name='ChesanEndDate'),
      classification?: string(name='Classification'),
      dataCreateTime?: long(name='DataCreateTime'),
      dataUpdateTime?: long(name='DataUpdateTime'),
      ownerEnName?: string(name='OwnerEnName'),
      ownerName?: string(name='OwnerName'),
      registrationNumber?: string(name='RegistrationNumber'),
      ruleId?: string(name='RuleId'),
      tmImage?: string(name='TmImage'),
      tmName?: string(name='TmName'),
      tmProcedureStatusDesc?: string(name='TmProcedureStatusDesc'),
      tmUid?: string(name='TmUid'),
      userId?: string(name='UserId'),
      wuxiaoEndDate?: string(name='WuxiaoEndDate'),
      xuzhanEndDate?: string(name='XuzhanEndDate'),
      yiyiEndDate?: string(name='YiyiEndDate'),
    }
  ](name='TmMonitorResult')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTrademarkMonitorResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkMonitorResultsResponseBody(name='body'),
}

async function queryTrademarkMonitorResultsWithOptions(request: QueryTrademarkMonitorResultsRequest, runtime: Util.RuntimeOptions): QueryTrademarkMonitorResultsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.applyYear)) {
    query['ApplyYear'] = request.applyYear;
  }
  if (!Util.isUnset(request.classification)) {
    query['Classification'] = request.classification;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.procedureStatus)) {
    query['ProcedureStatus'] = request.procedureStatus;
  }
  if (!Util.isUnset(request.registrationNumber)) {
    query['RegistrationNumber'] = request.registrationNumber;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkMonitorResults',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkMonitorResults(request: QueryTrademarkMonitorResultsRequest): QueryTrademarkMonitorResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkMonitorResultsWithOptions(request, runtime);
}

model QueryTrademarkMonitorRulesRequest {
  id?: string(name='Id'),
  notifyUpdate?: int32(name='NotifyUpdate'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  ruleName?: string(name='RuleName'),
}

model QueryTrademarkMonitorRulesResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    tmMonitorRule?: [ 
    {
      createTime?: string(name='CreateTime'),
      endTime?: string(name='EndTime'),
      env?: string(name='Env'),
      id?: string(name='Id'),
      lastFinishTime?: string(name='LastFinishTime'),
      lastRunTime?: string(name='LastRunTime'),
      lastUpdateTime?: string(name='LastUpdateTime'),
      notifyUpdate?: int32(name='NotifyUpdate'),
      ruleDetail?: string(name='RuleDetail'),
      ruleExtend?: string(name='RuleExtend'),
      ruleKeyword?: string(name='RuleKeyword'),
      ruleName?: string(name='RuleName'),
      ruleSource?: string(name='RuleSource'),
      ruleStatus?: string(name='RuleStatus'),
      ruleType?: int32(name='RuleType'),
      startTime?: string(name='StartTime'),
      updateTime?: string(name='UpdateTime'),
      userId?: string(name='UserId'),
      version?: int32(name='Version'),
    }
  ](name='TmMonitorRule')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTrademarkMonitorRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkMonitorRulesResponseBody(name='body'),
}

async function queryTrademarkMonitorRulesWithOptions(request: QueryTrademarkMonitorRulesRequest, runtime: Util.RuntimeOptions): QueryTrademarkMonitorRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.notifyUpdate)) {
    query['NotifyUpdate'] = request.notifyUpdate;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkMonitorRules',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkMonitorRules(request: QueryTrademarkMonitorRulesRequest): QueryTrademarkMonitorRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkMonitorRulesWithOptions(request, runtime);
}

model QueryTrademarkOnSaleRequest {
  classification?: string(name='Classification'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  registerCode?: string(name='RegisterCode'),
  registerNumber?: string(name='RegisterNumber'),
  tmType?: string(name='TmType'),
}

model QueryTrademarkOnSaleResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  totalPageNumber?: int32(name='TotalPageNumber'),
  trademarks?: [ 
    {
      auditResult?: string(name='AuditResult'),
      classification?: string(name='Classification'),
      icon?: string(name='Icon'),
      orderPrice?: string(name='OrderPrice'),
      registrationNumber?: string(name='RegistrationNumber'),
      status?: long(name='Status'),
      tmType?: string(name='TmType'),
      trademarkName?: string(name='TrademarkName'),
    }
  ](name='Trademarks'),
}

model QueryTrademarkOnSaleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkOnSaleResponseBody(name='body'),
}

async function queryTrademarkOnSaleWithOptions(request: QueryTrademarkOnSaleRequest, runtime: Util.RuntimeOptions): QueryTrademarkOnSaleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.classification)) {
    query['Classification'] = request.classification;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.registerCode)) {
    query['RegisterCode'] = request.registerCode;
  }
  if (!Util.isUnset(request.registerNumber)) {
    query['RegisterNumber'] = request.registerNumber;
  }
  if (!Util.isUnset(request.tmType)) {
    query['TmType'] = request.tmType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkOnSale',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkOnSale(request: QueryTrademarkOnSaleRequest): QueryTrademarkOnSaleResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkOnSaleWithOptions(request, runtime);
}

model QueryTrademarkPriceRequest {
  orderData?: map[string]any(name='OrderData'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  type?: int32(name='Type'),
  userId?: long(name='UserId'),
}

model QueryTrademarkPriceShrinkRequest {
  orderDataShrink?: string(name='OrderData'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  type?: int32(name='Type'),
  userId?: long(name='UserId'),
}

model QueryTrademarkPriceResponseBody = {
  currency?: string(name='Currency'),
  discountPrice?: float(name='DiscountPrice'),
  originalPrice?: float(name='OriginalPrice'),
  prices?: {
    prices?: [ 
    {
      classificationCode?: string(name='ClassificationCode'),
      currency?: string(name='Currency'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }
  ](name='Prices')
  }(name='Prices'),
  requestId?: string(name='RequestId'),
  tradePrice?: float(name='TradePrice'),
}

model QueryTrademarkPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkPriceResponseBody(name='body'),
}

async function queryTrademarkPriceWithOptions(tmpReq: QueryTrademarkPriceRequest, runtime: Util.RuntimeOptions): QueryTrademarkPriceResponse {
  Util.validateModel(tmpReq);
  var request = new QueryTrademarkPriceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.orderData)) {
    request.orderDataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.orderData, 'OrderData', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.orderDataShrink)) {
    query['OrderData'] = request.orderDataShrink;
  }
  if (!Util.isUnset(request.tmIcon)) {
    query['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkPrice',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkPrice(request: QueryTrademarkPriceRequest): QueryTrademarkPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkPriceWithOptions(request, runtime);
}

model QueryTrademarkUploadAuditResultRequest {
  classification?: string(name='Classification'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  registerCode?: string(name='RegisterCode'),
  registerNumber?: string(name='RegisterNumber'),
  tmType?: string(name='TmType'),
}

model QueryTrademarkUploadAuditResultResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  totalPageNumber?: int32(name='TotalPageNumber'),
  trademarks?: [ 
    {
      auditResult?: string(name='AuditResult'),
      classification?: string(name='Classification'),
      icon?: string(name='Icon'),
      orderPrice?: string(name='OrderPrice'),
      registrationNumber?: string(name='RegistrationNumber'),
      status?: long(name='Status'),
      tmType?: string(name='TmType'),
      trademarkName?: string(name='TrademarkName'),
    }
  ](name='Trademarks'),
}

model QueryTrademarkUploadAuditResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTrademarkUploadAuditResultResponseBody(name='body'),
}

async function queryTrademarkUploadAuditResultWithOptions(request: QueryTrademarkUploadAuditResultRequest, runtime: Util.RuntimeOptions): QueryTrademarkUploadAuditResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.classification)) {
    query['Classification'] = request.classification;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.registerCode)) {
    query['RegisterCode'] = request.registerCode;
  }
  if (!Util.isUnset(request.registerNumber)) {
    query['RegisterNumber'] = request.registerNumber;
  }
  if (!Util.isUnset(request.tmType)) {
    query['TmType'] = request.tmType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTrademarkUploadAuditResult',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTrademarkUploadAuditResult(request: QueryTrademarkUploadAuditResultRequest): QueryTrademarkUploadAuditResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTrademarkUploadAuditResultWithOptions(request, runtime);
}

model RefundProduceRequest {
  bizId?: string(name='BizId'),
}

model RefundProduceResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RefundProduceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefundProduceResponseBody(name='body'),
}

async function refundProduceWithOptions(request: RefundProduceRequest, runtime: Util.RuntimeOptions): RefundProduceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefundProduce',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refundProduce(request: RefundProduceRequest): RefundProduceResponse {
  var runtime = new Util.RuntimeOptions{};
  return refundProduceWithOptions(request, runtime);
}

model RefuseAdditionalMaterialRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
}

model RefuseAdditionalMaterialResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RefuseAdditionalMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefuseAdditionalMaterialResponseBody(name='body'),
}

async function refuseAdditionalMaterialWithOptions(request: RefuseAdditionalMaterialRequest, runtime: Util.RuntimeOptions): RefuseAdditionalMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefuseAdditionalMaterial',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refuseAdditionalMaterial(request: RefuseAdditionalMaterialRequest): RefuseAdditionalMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return refuseAdditionalMaterialWithOptions(request, runtime);
}

model RefuseApplicantRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
}

model RefuseApplicantResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RefuseApplicantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefuseApplicantResponseBody(name='body'),
}

async function refuseApplicantWithOptions(request: RefuseApplicantRequest, runtime: Util.RuntimeOptions): RefuseApplicantResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefuseApplicant',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refuseApplicant(request: RefuseApplicantRequest): RefuseApplicantResponse {
  var runtime = new Util.RuntimeOptions{};
  return refuseApplicantWithOptions(request, runtime);
}

model RejectApplicantRequest {
  instanceId?: string(name='InstanceId'),
  note?: string(name='Note'),
}

model RejectApplicantResponseBody = {
  requestId?: string(name='RequestId'),
}

model RejectApplicantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RejectApplicantResponseBody(name='body'),
}

async function rejectApplicantWithOptions(request: RejectApplicantRequest, runtime: Util.RuntimeOptions): RejectApplicantResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RejectApplicant',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rejectApplicant(request: RejectApplicantRequest): RejectApplicantResponse {
  var runtime = new Util.RuntimeOptions{};
  return rejectApplicantWithOptions(request, runtime);
}

model SaveClassificationConditionsRequest {
  bizId?: string(name='BizId'),
  condition?: string(name='Condition'),
  type?: int32(name='Type'),
}

model SaveClassificationConditionsResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  invalidList?: [ 
    {
      classificationCode?: string(name='ClassificationCode'),
      classificationName?: string(name='ClassificationName'),
      officialCode?: string(name='OfficialCode'),
      parentCode?: string(name='ParentCode'),
    }
  ](name='InvalidList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tagName?: string(name='TagName'),
}

model SaveClassificationConditionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveClassificationConditionsResponseBody(name='body'),
}

async function saveClassificationConditionsWithOptions(request: SaveClassificationConditionsRequest, runtime: Util.RuntimeOptions): SaveClassificationConditionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.condition)) {
    query['Condition'] = request.condition;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveClassificationConditions',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveClassificationConditions(request: SaveClassificationConditionsRequest): SaveClassificationConditionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveClassificationConditionsWithOptions(request, runtime);
}

model SaveExtensionAttributeRequest {
  attributeKey?: string(name='AttributeKey'),
  attributeValue?: string(name='AttributeValue'),
  bizId?: string(name='BizId'),
}

model SaveExtensionAttributeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveExtensionAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveExtensionAttributeResponseBody(name='body'),
}

async function saveExtensionAttributeWithOptions(request: SaveExtensionAttributeRequest, runtime: Util.RuntimeOptions): SaveExtensionAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.attributeKey)) {
    query['AttributeKey'] = request.attributeKey;
  }
  if (!Util.isUnset(request.attributeValue)) {
    query['AttributeValue'] = request.attributeValue;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveExtensionAttribute',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveExtensionAttribute(request: SaveExtensionAttributeRequest): SaveExtensionAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveExtensionAttributeWithOptions(request, runtime);
}

model SaveTaskRequest {
  bizType?: string(name='BizType'),
  request?: string(name='Request'),
}

model SaveTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model SaveTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTaskResponseBody(name='body'),
}

async function saveTaskWithOptions(request: SaveTaskRequest, runtime: Util.RuntimeOptions): SaveTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.request)) {
    query['Request'] = request.request;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveTask',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveTask(request: SaveTaskRequest): SaveTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskWithOptions(request, runtime);
}

model SaveTaskForOfficialFileCustomRequest {
  endAcceptTime?: long(name='EndAcceptTime'),
  startAcceptTime?: long(name='StartAcceptTime'),
}

model SaveTaskForOfficialFileCustomResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveTaskForOfficialFileCustomResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTaskForOfficialFileCustomResponseBody(name='body'),
}

async function saveTaskForOfficialFileCustomWithOptions(request: SaveTaskForOfficialFileCustomRequest, runtime: Util.RuntimeOptions): SaveTaskForOfficialFileCustomResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endAcceptTime)) {
    query['EndAcceptTime'] = request.endAcceptTime;
  }
  if (!Util.isUnset(request.startAcceptTime)) {
    query['StartAcceptTime'] = request.startAcceptTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveTaskForOfficialFileCustom',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveTaskForOfficialFileCustom(request: SaveTaskForOfficialFileCustomRequest): SaveTaskForOfficialFileCustomResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskForOfficialFileCustomWithOptions(request, runtime);
}

model SaveTradeMarkReviewMaterialDetailRequest {
  additionalOssKeyList?: map[string]any(name='AdditionalOssKeyList'),
  address?: string(name='Address'),
  applicationOssKey?: string(name='ApplicationOssKey'),
  bizId?: string(name='BizId'),
  businessLicenceOssKey?: string(name='BusinessLicenceOssKey'),
  cardNumber?: string(name='CardNumber'),
  contactAddress?: string(name='ContactAddress'),
  contactEmail?: string(name='ContactEmail'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  country?: string(name='Country'),
  engAddress?: string(name='EngAddress'),
  engName?: string(name='EngName'),
  idCardOssKey?: string(name='IdCardOssKey'),
  legalNoticeOssKey?: string(name='LegalNoticeOssKey'),
  loaOssKey?: string(name='LoaOssKey'),
  name?: string(name='Name'),
  passportOssKey?: string(name='PassportOssKey'),
  province?: string(name='Province'),
  region?: int32(name='Region'),
  reviewMaterialAdditionalJson?: string(name='ReviewMaterialAdditionalJson'),
  separate?: boolean(name='Separate'),
  submitOnline?: boolean(name='SubmitOnline'),
  submitType?: int32(name='SubmitType'),
  type?: int32(name='Type'),
}

model SaveTradeMarkReviewMaterialDetailShrinkRequest {
  additionalOssKeyListShrink?: string(name='AdditionalOssKeyList'),
  address?: string(name='Address'),
  applicationOssKey?: string(name='ApplicationOssKey'),
  bizId?: string(name='BizId'),
  businessLicenceOssKey?: string(name='BusinessLicenceOssKey'),
  cardNumber?: string(name='CardNumber'),
  contactAddress?: string(name='ContactAddress'),
  contactEmail?: string(name='ContactEmail'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  country?: string(name='Country'),
  engAddress?: string(name='EngAddress'),
  engName?: string(name='EngName'),
  idCardOssKey?: string(name='IdCardOssKey'),
  legalNoticeOssKey?: string(name='LegalNoticeOssKey'),
  loaOssKey?: string(name='LoaOssKey'),
  name?: string(name='Name'),
  passportOssKey?: string(name='PassportOssKey'),
  province?: string(name='Province'),
  region?: int32(name='Region'),
  reviewMaterialAdditionalJson?: string(name='ReviewMaterialAdditionalJson'),
  separate?: boolean(name='Separate'),
  submitOnline?: boolean(name='SubmitOnline'),
  submitType?: int32(name='SubmitType'),
  type?: int32(name='Type'),
}

model SaveTradeMarkReviewMaterialDetailResponseBody = {
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveTradeMarkReviewMaterialDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTradeMarkReviewMaterialDetailResponseBody(name='body'),
}

async function saveTradeMarkReviewMaterialDetailWithOptions(tmpReq: SaveTradeMarkReviewMaterialDetailRequest, runtime: Util.RuntimeOptions): SaveTradeMarkReviewMaterialDetailResponse {
  Util.validateModel(tmpReq);
  var request = new SaveTradeMarkReviewMaterialDetailShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.additionalOssKeyList)) {
    request.additionalOssKeyListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.additionalOssKeyList, 'AdditionalOssKeyList', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.additionalOssKeyListShrink)) {
    body['AdditionalOssKeyList'] = request.additionalOssKeyListShrink;
  }
  if (!Util.isUnset(request.address)) {
    body['Address'] = request.address;
  }
  if (!Util.isUnset(request.applicationOssKey)) {
    body['ApplicationOssKey'] = request.applicationOssKey;
  }
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.businessLicenceOssKey)) {
    body['BusinessLicenceOssKey'] = request.businessLicenceOssKey;
  }
  if (!Util.isUnset(request.cardNumber)) {
    body['CardNumber'] = request.cardNumber;
  }
  if (!Util.isUnset(request.contactAddress)) {
    body['ContactAddress'] = request.contactAddress;
  }
  if (!Util.isUnset(request.contactEmail)) {
    body['ContactEmail'] = request.contactEmail;
  }
  if (!Util.isUnset(request.contactName)) {
    body['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactNumber)) {
    body['ContactNumber'] = request.contactNumber;
  }
  if (!Util.isUnset(request.country)) {
    body['Country'] = request.country;
  }
  if (!Util.isUnset(request.engAddress)) {
    body['EngAddress'] = request.engAddress;
  }
  if (!Util.isUnset(request.engName)) {
    body['EngName'] = request.engName;
  }
  if (!Util.isUnset(request.idCardOssKey)) {
    body['IdCardOssKey'] = request.idCardOssKey;
  }
  if (!Util.isUnset(request.legalNoticeOssKey)) {
    body['LegalNoticeOssKey'] = request.legalNoticeOssKey;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    body['LoaOssKey'] = request.loaOssKey;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.passportOssKey)) {
    body['PassportOssKey'] = request.passportOssKey;
  }
  if (!Util.isUnset(request.province)) {
    body['Province'] = request.province;
  }
  if (!Util.isUnset(request.region)) {
    body['Region'] = request.region;
  }
  if (!Util.isUnset(request.reviewMaterialAdditionalJson)) {
    body['ReviewMaterialAdditionalJson'] = request.reviewMaterialAdditionalJson;
  }
  if (!Util.isUnset(request.separate)) {
    body['Separate'] = request.separate;
  }
  if (!Util.isUnset(request.submitOnline)) {
    body['SubmitOnline'] = request.submitOnline;
  }
  if (!Util.isUnset(request.submitType)) {
    body['SubmitType'] = request.submitType;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveTradeMarkReviewMaterialDetail',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveTradeMarkReviewMaterialDetail(request: SaveTradeMarkReviewMaterialDetailRequest): SaveTradeMarkReviewMaterialDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTradeMarkReviewMaterialDetailWithOptions(request, runtime);
}

model SbjOperateRequest {
  amount?: string(name='Amount'),
  applyNo?: string(name='ApplyNo'),
  auditStatus?: boolean(name='AuditStatus'),
  bizId?: string(name='BizId'),
  fileDate?: string(name='FileDate'),
  fileOssKey?: string(name='FileOssKey'),
  message?: string(name='Message'),
  operateType?: string(name='OperateType'),
  orderNo?: string(name='OrderNo'),
  receiptOssKey?: string(name='ReceiptOssKey'),
  submittedSuccess?: boolean(name='SubmittedSuccess'),
}

model SbjOperateResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SbjOperateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SbjOperateResponseBody(name='body'),
}

async function sbjOperateWithOptions(request: SbjOperateRequest, runtime: Util.RuntimeOptions): SbjOperateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.amount)) {
    query['Amount'] = request.amount;
  }
  if (!Util.isUnset(request.applyNo)) {
    query['ApplyNo'] = request.applyNo;
  }
  if (!Util.isUnset(request.auditStatus)) {
    query['AuditStatus'] = request.auditStatus;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.fileDate)) {
    query['FileDate'] = request.fileDate;
  }
  if (!Util.isUnset(request.fileOssKey)) {
    query['FileOssKey'] = request.fileOssKey;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.orderNo)) {
    query['OrderNo'] = request.orderNo;
  }
  if (!Util.isUnset(request.receiptOssKey)) {
    query['ReceiptOssKey'] = request.receiptOssKey;
  }
  if (!Util.isUnset(request.submittedSuccess)) {
    query['SubmittedSuccess'] = request.submittedSuccess;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SbjOperate',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sbjOperate(request: SbjOperateRequest): SbjOperateResponse {
  var runtime = new Util.RuntimeOptions{};
  return sbjOperateWithOptions(request, runtime);
}

model SearchTmOnsalesRequest {
  classification?: string(name='Classification'),
  keyword?: string(name='Keyword'),
  orderPriceLeft?: long(name='OrderPriceLeft'),
  orderPriceRight?: long(name='OrderPriceRight'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  productCode?: string(name='ProductCode'),
  queryAll?: boolean(name='QueryAll'),
  regLeft?: int32(name='RegLeft'),
  regRight?: int32(name='RegRight'),
  registerNumber?: string(name='RegisterNumber'),
  sortName?: string(name='SortName'),
  sortOrder?: string(name='SortOrder'),
  tag?: string(name='Tag'),
  tmName?: string(name='TmName'),
  topSearch?: string(name='TopSearch'),
}

model SearchTmOnsalesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  totalPageNumber?: int32(name='TotalPageNumber'),
  trademarks?: [ 
    {
      classification?: string(name='Classification'),
      icon?: string(name='Icon'),
      orderPrice?: string(name='OrderPrice'),
      partnerCode?: string(name='PartnerCode'),
      productCode?: string(name='ProductCode'),
      productDesc?: string(name='ProductDesc'),
      registrationNumber?: string(name='RegistrationNumber'),
      status?: long(name='Status'),
      trademarkName?: string(name='TrademarkName'),
      uid?: string(name='Uid'),
    }
  ](name='Trademarks'),
}

model SearchTmOnsalesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTmOnsalesResponseBody(name='body'),
}

async function searchTmOnsalesWithOptions(request: SearchTmOnsalesRequest, runtime: Util.RuntimeOptions): SearchTmOnsalesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.classification)) {
    query['Classification'] = request.classification;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.orderPriceLeft)) {
    query['OrderPriceLeft'] = request.orderPriceLeft;
  }
  if (!Util.isUnset(request.orderPriceRight)) {
    query['OrderPriceRight'] = request.orderPriceRight;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.queryAll)) {
    query['QueryAll'] = request.queryAll;
  }
  if (!Util.isUnset(request.regLeft)) {
    query['RegLeft'] = request.regLeft;
  }
  if (!Util.isUnset(request.regRight)) {
    query['RegRight'] = request.regRight;
  }
  if (!Util.isUnset(request.registerNumber)) {
    query['RegisterNumber'] = request.registerNumber;
  }
  if (!Util.isUnset(request.sortName)) {
    query['SortName'] = request.sortName;
  }
  if (!Util.isUnset(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.topSearch)) {
    query['TopSearch'] = request.topSearch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchTmOnsales',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTmOnsales(request: SearchTmOnsalesRequest): SearchTmOnsalesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTmOnsalesWithOptions(request, runtime);
}

model StartNotaryRequest {
  notaryOrderId?: long(name='NotaryOrderId'),
}

model StartNotaryResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  notaryUrl?: string(name='NotaryUrl'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StartNotaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartNotaryResponseBody(name='body'),
}

async function startNotaryWithOptions(request: StartNotaryRequest, runtime: Util.RuntimeOptions): StartNotaryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.notaryOrderId)) {
    query['NotaryOrderId'] = request.notaryOrderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartNotary',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startNotary(request: StartNotaryRequest): StartNotaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return startNotaryWithOptions(request, runtime);
}

model StoreMaterialTemporarilyRequest {
  address?: string(name='Address'),
  businessLicenceOssKey?: string(name='BusinessLicenceOssKey'),
  cardNumber?: string(name='CardNumber'),
  city?: string(name='City'),
  contactAddress?: string(name='ContactAddress'),
  contactCity?: string(name='ContactCity'),
  contactCounty?: string(name='ContactCounty'),
  contactDistrict?: string(name='ContactDistrict'),
  contactEmail?: string(name='ContactEmail'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactProvince?: string(name='ContactProvince'),
  contactZipcode?: string(name='ContactZipcode'),
  country?: string(name='Country'),
  EAddress?: string(name='EAddress'),
  EName?: string(name='EName'),
  idCardName?: string(name='IdCardName'),
  idCardNumber?: string(name='IdCardNumber'),
  idCardOssKey?: string(name='IdCardOssKey'),
  legalNoticeOssKey?: string(name='LegalNoticeOssKey'),
  loaOssKey?: string(name='LoaOssKey'),
  name?: string(name='Name'),
  passportOssKey?: string(name='PassportOssKey'),
  personalType?: long(name='PersonalType'),
  principalName?: int32(name='PrincipalName'),
  province?: string(name='Province'),
  region?: string(name='Region'),
  town?: string(name='Town'),
  type?: string(name='Type'),
}

model StoreMaterialTemporarilyResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StoreMaterialTemporarilyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StoreMaterialTemporarilyResponseBody(name='body'),
}

async function storeMaterialTemporarilyWithOptions(request: StoreMaterialTemporarilyRequest, runtime: Util.RuntimeOptions): StoreMaterialTemporarilyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.businessLicenceOssKey)) {
    query['BusinessLicenceOssKey'] = request.businessLicenceOssKey;
  }
  if (!Util.isUnset(request.cardNumber)) {
    query['CardNumber'] = request.cardNumber;
  }
  if (!Util.isUnset(request.city)) {
    query['City'] = request.city;
  }
  if (!Util.isUnset(request.contactAddress)) {
    query['ContactAddress'] = request.contactAddress;
  }
  if (!Util.isUnset(request.contactCity)) {
    query['ContactCity'] = request.contactCity;
  }
  if (!Util.isUnset(request.contactCounty)) {
    query['ContactCounty'] = request.contactCounty;
  }
  if (!Util.isUnset(request.contactDistrict)) {
    query['ContactDistrict'] = request.contactDistrict;
  }
  if (!Util.isUnset(request.contactEmail)) {
    query['ContactEmail'] = request.contactEmail;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactNumber)) {
    query['ContactNumber'] = request.contactNumber;
  }
  if (!Util.isUnset(request.contactProvince)) {
    query['ContactProvince'] = request.contactProvince;
  }
  if (!Util.isUnset(request.contactZipcode)) {
    query['ContactZipcode'] = request.contactZipcode;
  }
  if (!Util.isUnset(request.country)) {
    query['Country'] = request.country;
  }
  if (!Util.isUnset(request.EAddress)) {
    query['EAddress'] = request.EAddress;
  }
  if (!Util.isUnset(request.EName)) {
    query['EName'] = request.EName;
  }
  if (!Util.isUnset(request.idCardName)) {
    query['IdCardName'] = request.idCardName;
  }
  if (!Util.isUnset(request.idCardNumber)) {
    query['IdCardNumber'] = request.idCardNumber;
  }
  if (!Util.isUnset(request.idCardOssKey)) {
    query['IdCardOssKey'] = request.idCardOssKey;
  }
  if (!Util.isUnset(request.legalNoticeOssKey)) {
    query['LegalNoticeOssKey'] = request.legalNoticeOssKey;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    query['LoaOssKey'] = request.loaOssKey;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.passportOssKey)) {
    query['PassportOssKey'] = request.passportOssKey;
  }
  if (!Util.isUnset(request.personalType)) {
    query['PersonalType'] = request.personalType;
  }
  if (!Util.isUnset(request.principalName)) {
    query['PrincipalName'] = request.principalName;
  }
  if (!Util.isUnset(request.province)) {
    query['Province'] = request.province;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.town)) {
    query['Town'] = request.town;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StoreMaterialTemporarily',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function storeMaterialTemporarily(request: StoreMaterialTemporarilyRequest): StoreMaterialTemporarilyResponse {
  var runtime = new Util.RuntimeOptions{};
  return storeMaterialTemporarilyWithOptions(request, runtime);
}

model SubmitSupplementRequest {
  content?: string(name='Content'),
  id?: long(name='Id'),
  uploadOssKeyList?: map[string]any(name='UploadOssKeyList'),
}

model SubmitSupplementShrinkRequest {
  content?: string(name='Content'),
  id?: long(name='Id'),
  uploadOssKeyListShrink?: string(name='UploadOssKeyList'),
}

model SubmitSupplementResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubmitSupplementResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitSupplementResponseBody(name='body'),
}

async function submitSupplementWithOptions(tmpReq: SubmitSupplementRequest, runtime: Util.RuntimeOptions): SubmitSupplementResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitSupplementShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.uploadOssKeyList)) {
    request.uploadOssKeyListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.uploadOssKeyList, 'UploadOssKeyList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.uploadOssKeyListShrink)) {
    query['UploadOssKeyList'] = request.uploadOssKeyListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitSupplement',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitSupplement(request: SubmitSupplementRequest): SubmitSupplementResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitSupplementWithOptions(request, runtime);
}

model SubmitTrademarkApplicationComplaintRequest {
  bizId?: string(name='BizId'),
  content?: string(name='Content'),
  files?: map[string]any(name='Files'),
}

model SubmitTrademarkApplicationComplaintShrinkRequest {
  bizId?: string(name='BizId'),
  content?: string(name='Content'),
  filesShrink?: string(name='Files'),
}

model SubmitTrademarkApplicationComplaintResponseBody = {
  requestId?: string(name='RequestId'),
}

model SubmitTrademarkApplicationComplaintResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitTrademarkApplicationComplaintResponseBody(name='body'),
}

async function submitTrademarkApplicationComplaintWithOptions(tmpReq: SubmitTrademarkApplicationComplaintRequest, runtime: Util.RuntimeOptions): SubmitTrademarkApplicationComplaintResponse {
  Util.validateModel(tmpReq);
  var request = new SubmitTrademarkApplicationComplaintShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.files)) {
    request.filesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.files, 'Files', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.filesShrink)) {
    query['Files'] = request.filesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitTrademarkApplicationComplaint',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitTrademarkApplicationComplaint(request: SubmitTrademarkApplicationComplaintRequest): SubmitTrademarkApplicationComplaintResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitTrademarkApplicationComplaintWithOptions(request, runtime);
}

model SyncTrademarkRequest {
  beginTime?: long(name='BeginTime'),
  classificationCode?: string(name='ClassificationCode'),
  description?: string(name='Description'),
  endTime?: long(name='EndTime'),
  label?: string(name='Label'),
  originalPrice?: float(name='OriginalPrice'),
  ownerEnName?: string(name='OwnerEnName'),
  ownerName?: string(name='OwnerName'),
  reason?: string(name='Reason'),
  regAnnDate?: long(name='RegAnnDate'),
  secondaryClassification?: string(name='SecondaryClassification'),
  status?: string(name='Status'),
  thirdClassification?: string(name='ThirdClassification'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  tmNumber?: string(name='TmNumber'),
  type?: string(name='Type'),
}

model SyncTrademarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model SyncTrademarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SyncTrademarkResponseBody(name='body'),
}

async function syncTrademarkWithOptions(request: SyncTrademarkRequest, runtime: Util.RuntimeOptions): SyncTrademarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.classificationCode)) {
    query['ClassificationCode'] = request.classificationCode;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.label)) {
    query['Label'] = request.label;
  }
  if (!Util.isUnset(request.originalPrice)) {
    query['OriginalPrice'] = request.originalPrice;
  }
  if (!Util.isUnset(request.ownerEnName)) {
    query['OwnerEnName'] = request.ownerEnName;
  }
  if (!Util.isUnset(request.ownerName)) {
    query['OwnerName'] = request.ownerName;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.regAnnDate)) {
    query['RegAnnDate'] = request.regAnnDate;
  }
  if (!Util.isUnset(request.secondaryClassification)) {
    query['SecondaryClassification'] = request.secondaryClassification;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.thirdClassification)) {
    query['ThirdClassification'] = request.thirdClassification;
  }
  if (!Util.isUnset(request.tmIcon)) {
    query['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNumber)) {
    query['TmNumber'] = request.tmNumber;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SyncTrademark',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function syncTrademark(request: SyncTrademarkRequest): SyncTrademarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncTrademarkWithOptions(request, runtime);
}

model UpdateApplicantContacterRequest {
  applicantId?: long(name='ApplicantId'),
  bizId?: string(name='BizId'),
  contactAddress?: string(name='ContactAddress'),
  contactCity?: string(name='ContactCity'),
  contactDistrict?: string(name='ContactDistrict'),
  contactEmail?: string(name='ContactEmail'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactProvince?: string(name='ContactProvince'),
  contactZipCode?: string(name='ContactZipCode'),
}

model UpdateApplicantContacterResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateApplicantContacterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApplicantContacterResponseBody(name='body'),
}

async function updateApplicantContacterWithOptions(request: UpdateApplicantContacterRequest, runtime: Util.RuntimeOptions): UpdateApplicantContacterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applicantId)) {
    query['ApplicantId'] = request.applicantId;
  }
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.contactAddress)) {
    query['ContactAddress'] = request.contactAddress;
  }
  if (!Util.isUnset(request.contactCity)) {
    query['ContactCity'] = request.contactCity;
  }
  if (!Util.isUnset(request.contactDistrict)) {
    query['ContactDistrict'] = request.contactDistrict;
  }
  if (!Util.isUnset(request.contactEmail)) {
    query['ContactEmail'] = request.contactEmail;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactNumber)) {
    query['ContactNumber'] = request.contactNumber;
  }
  if (!Util.isUnset(request.contactProvince)) {
    query['ContactProvince'] = request.contactProvince;
  }
  if (!Util.isUnset(request.contactZipCode)) {
    query['ContactZipCode'] = request.contactZipCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApplicantContacter',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateApplicantContacter(request: UpdateApplicantContacterRequest): UpdateApplicantContacterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateApplicantContacterWithOptions(request, runtime);
}

model UpdateMaterialRequest {
  address?: string(name='Address'),
  businessLicenceOssKey?: string(name='BusinessLicenceOssKey'),
  cardNumber?: string(name='CardNumber'),
  city?: string(name='City'),
  contactAddress?: string(name='ContactAddress'),
  contactCity?: string(name='ContactCity'),
  contactCounty?: string(name='ContactCounty'),
  contactDistrict?: string(name='ContactDistrict'),
  contactEmail?: string(name='ContactEmail'),
  contactName?: string(name='ContactName'),
  contactNumber?: string(name='ContactNumber'),
  contactProvince?: string(name='ContactProvince'),
  contactZipcode?: string(name='ContactZipcode'),
  EAddress?: string(name='EAddress'),
  EName?: string(name='EName'),
  id?: long(name='Id'),
  idCardName?: string(name='IdCardName'),
  idCardNumber?: string(name='IdCardNumber'),
  idCardOssKey?: string(name='IdCardOssKey'),
  legalNoticeOssKey?: string(name='LegalNoticeOssKey'),
  loaId?: long(name='LoaId'),
  loaOssKey?: string(name='LoaOssKey'),
  name?: string(name='Name'),
  passportOssKey?: string(name='PassportOssKey'),
  personalType?: long(name='PersonalType'),
  province?: string(name='Province'),
  town?: string(name='Town'),
}

model UpdateMaterialResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMaterialResponseBody(name='body'),
}

async function updateMaterialWithOptions(request: UpdateMaterialRequest, runtime: Util.RuntimeOptions): UpdateMaterialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.businessLicenceOssKey)) {
    query['BusinessLicenceOssKey'] = request.businessLicenceOssKey;
  }
  if (!Util.isUnset(request.cardNumber)) {
    query['CardNumber'] = request.cardNumber;
  }
  if (!Util.isUnset(request.city)) {
    query['City'] = request.city;
  }
  if (!Util.isUnset(request.contactAddress)) {
    query['ContactAddress'] = request.contactAddress;
  }
  if (!Util.isUnset(request.contactCity)) {
    query['ContactCity'] = request.contactCity;
  }
  if (!Util.isUnset(request.contactCounty)) {
    query['ContactCounty'] = request.contactCounty;
  }
  if (!Util.isUnset(request.contactDistrict)) {
    query['ContactDistrict'] = request.contactDistrict;
  }
  if (!Util.isUnset(request.contactEmail)) {
    query['ContactEmail'] = request.contactEmail;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.contactNumber)) {
    query['ContactNumber'] = request.contactNumber;
  }
  if (!Util.isUnset(request.contactProvince)) {
    query['ContactProvince'] = request.contactProvince;
  }
  if (!Util.isUnset(request.contactZipcode)) {
    query['ContactZipcode'] = request.contactZipcode;
  }
  if (!Util.isUnset(request.EAddress)) {
    query['EAddress'] = request.EAddress;
  }
  if (!Util.isUnset(request.EName)) {
    query['EName'] = request.EName;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.idCardName)) {
    query['IdCardName'] = request.idCardName;
  }
  if (!Util.isUnset(request.idCardNumber)) {
    query['IdCardNumber'] = request.idCardNumber;
  }
  if (!Util.isUnset(request.idCardOssKey)) {
    query['IdCardOssKey'] = request.idCardOssKey;
  }
  if (!Util.isUnset(request.legalNoticeOssKey)) {
    query['LegalNoticeOssKey'] = request.legalNoticeOssKey;
  }
  if (!Util.isUnset(request.loaId)) {
    query['LoaId'] = request.loaId;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    query['LoaOssKey'] = request.loaOssKey;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.passportOssKey)) {
    query['PassportOssKey'] = request.passportOssKey;
  }
  if (!Util.isUnset(request.personalType)) {
    query['PersonalType'] = request.personalType;
  }
  if (!Util.isUnset(request.province)) {
    query['Province'] = request.province;
  }
  if (!Util.isUnset(request.town)) {
    query['Town'] = request.town;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMaterial',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMaterial(request: UpdateMaterialRequest): UpdateMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMaterialWithOptions(request, runtime);
}

model UpdateProduceRequest {
  bizId?: string(name='BizId'),
  bizType?: string(name='BizType'),
  extMap?: string(name='ExtMap'),
}

model UpdateProduceResponseBody = {
  requestId?: string(name='requestId', description='Id of the request'),
}

model UpdateProduceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProduceResponseBody(name='body'),
}

async function updateProduceWithOptions(request: UpdateProduceRequest, runtime: Util.RuntimeOptions): UpdateProduceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.extMap)) {
    query['ExtMap'] = request.extMap;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProduce',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProduce(request: UpdateProduceRequest): UpdateProduceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProduceWithOptions(request, runtime);
}

model UpdateProduceLoaIdRequest {
  bizId?: string(name='BizId'),
  loaOssKey?: string(name='LoaOssKey'),
}

model UpdateProduceLoaIdResponseBody = {
  requestId?: string(name='RequestId', description='appName'),
  success?: boolean(name='Success', description='success'),
}

model UpdateProduceLoaIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProduceLoaIdResponseBody(name='body'),
}

async function updateProduceLoaIdWithOptions(request: UpdateProduceLoaIdRequest, runtime: Util.RuntimeOptions): UpdateProduceLoaIdResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.loaOssKey)) {
    body['LoaOssKey'] = request.loaOssKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProduceLoaId',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProduceLoaId(request: UpdateProduceLoaIdRequest): UpdateProduceLoaIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProduceLoaIdWithOptions(request, runtime);
}

model UpdateSendMaterialNumRequest {
  bizId?: string(name='BizId'),
  num?: string(name='Num'),
  operateType?: int32(name='OperateType'),
}

model UpdateSendMaterialNumResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSendMaterialNumResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSendMaterialNumResponseBody(name='body'),
}

async function updateSendMaterialNumWithOptions(request: UpdateSendMaterialNumRequest, runtime: Util.RuntimeOptions): UpdateSendMaterialNumResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.num)) {
    query['Num'] = request.num;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSendMaterialNum',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSendMaterialNum(request: UpdateSendMaterialNumRequest): UpdateSendMaterialNumResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSendMaterialNumWithOptions(request, runtime);
}

model UpdateTmMonitorRuleRequest {
  id?: long(name='Id'),
  notifyStatus?: [ int32 ](name='NotifyStatus'),
  ruleName?: string(name='RuleName'),
}

model UpdateTmMonitorRuleResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateTmMonitorRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTmMonitorRuleResponseBody(name='body'),
}

async function updateTmMonitorRuleWithOptions(request: UpdateTmMonitorRuleRequest, runtime: Util.RuntimeOptions): UpdateTmMonitorRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.notifyStatus)) {
    query['NotifyStatus'] = request.notifyStatus;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTmMonitorRule',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTmMonitorRule(request: UpdateTmMonitorRuleRequest): UpdateTmMonitorRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTmMonitorRuleWithOptions(request, runtime);
}

model UpdateTrademarkNameRequest {
  bizId?: string(name='BizId', description='id'),
  clientToken?: string(name='ClientToken', description=''),
  tmComment?: string(name='TmComment'),
  tmIcon?: string(name='TmIcon', description=''),
  tmName?: string(name='TmName', description=''),
  type?: long(name='Type', description=''),
}

model UpdateTrademarkNameResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model UpdateTrademarkNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTrademarkNameResponseBody(name='body'),
}

async function updateTrademarkNameWithOptions(request: UpdateTrademarkNameRequest, runtime: Util.RuntimeOptions): UpdateTrademarkNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.tmComment)) {
    body['TmComment'] = request.tmComment;
  }
  if (!Util.isUnset(request.tmIcon)) {
    body['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    body['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrademarkName',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTrademarkName(request: UpdateTrademarkNameRequest): UpdateTrademarkNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTrademarkNameWithOptions(request, runtime);
}

model UpdateTrademarkOnsaleRequest {
  beginTime?: long(name='BeginTime'),
  classificationCode?: string(name='ClassificationCode'),
  description?: string(name='Description'),
  endTime?: long(name='EndTime'),
  label?: string(name='Label'),
  originalPrice?: float(name='OriginalPrice'),
  ownerEnName?: string(name='OwnerEnName'),
  ownerName?: string(name='OwnerName'),
  reason?: string(name='Reason'),
  regAnnDate?: long(name='RegAnnDate'),
  secondaryClassification?: string(name='SecondaryClassification'),
  thirdClassification?: string(name='ThirdClassification'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  tmNumber?: string(name='TmNumber'),
  tmType?: string(name='TmType'),
  tradeTmDetailJson?: string(name='TradeTmDetailJson'),
  type?: string(name='Type'),
}

model UpdateTrademarkOnsaleResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTrademarkOnsaleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTrademarkOnsaleResponseBody(name='body'),
}

async function updateTrademarkOnsaleWithOptions(request: UpdateTrademarkOnsaleRequest, runtime: Util.RuntimeOptions): UpdateTrademarkOnsaleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.classificationCode)) {
    query['ClassificationCode'] = request.classificationCode;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.label)) {
    query['Label'] = request.label;
  }
  if (!Util.isUnset(request.originalPrice)) {
    query['OriginalPrice'] = request.originalPrice;
  }
  if (!Util.isUnset(request.ownerEnName)) {
    query['OwnerEnName'] = request.ownerEnName;
  }
  if (!Util.isUnset(request.ownerName)) {
    query['OwnerName'] = request.ownerName;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.regAnnDate)) {
    query['RegAnnDate'] = request.regAnnDate;
  }
  if (!Util.isUnset(request.secondaryClassification)) {
    query['SecondaryClassification'] = request.secondaryClassification;
  }
  if (!Util.isUnset(request.thirdClassification)) {
    query['ThirdClassification'] = request.thirdClassification;
  }
  if (!Util.isUnset(request.tmIcon)) {
    query['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNumber)) {
    query['TmNumber'] = request.tmNumber;
  }
  if (!Util.isUnset(request.tmType)) {
    query['TmType'] = request.tmType;
  }
  if (!Util.isUnset(request.tradeTmDetailJson)) {
    query['TradeTmDetailJson'] = request.tradeTmDetailJson;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrademarkOnsale',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTrademarkOnsale(request: UpdateTrademarkOnsaleRequest): UpdateTrademarkOnsaleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTrademarkOnsaleWithOptions(request, runtime);
}

model UploadNotaryDataRequest {
  bizOrderNo?: string(name='BizOrderNo'),
  notaryType?: int32(name='NotaryType'),
  uploadContext?: string(name='UploadContext'),
}

model UploadNotaryDataResponseBody = {
  requestId?: string(name='RequestId'),
  userAuthUrl?: string(name='UserAuthUrl'),
}

model UploadNotaryDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadNotaryDataResponseBody(name='body'),
}

async function uploadNotaryDataWithOptions(request: UploadNotaryDataRequest, runtime: Util.RuntimeOptions): UploadNotaryDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizOrderNo)) {
    query['BizOrderNo'] = request.bizOrderNo;
  }
  if (!Util.isUnset(request.notaryType)) {
    query['NotaryType'] = request.notaryType;
  }
  if (!Util.isUnset(request.uploadContext)) {
    query['UploadContext'] = request.uploadContext;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadNotaryData',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadNotaryData(request: UploadNotaryDataRequest): UploadNotaryDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadNotaryDataWithOptions(request, runtime);
}

model UploadTrademarkOnSaleRequest {
  beginTime?: long(name='BeginTime'),
  classificationCode?: string(name='ClassificationCode'),
  description?: string(name='Description'),
  endTime?: long(name='EndTime'),
  label?: string(name='Label'),
  originalPrice?: float(name='OriginalPrice'),
  ownerEnName?: string(name='OwnerEnName'),
  ownerName?: string(name='OwnerName'),
  reason?: string(name='Reason'),
  regAnnDate?: long(name='RegAnnDate'),
  secondaryClassification?: string(name='SecondaryClassification'),
  status?: string(name='Status'),
  thirdClassification?: string(name='ThirdClassification'),
  tmIcon?: string(name='TmIcon'),
  tmName?: string(name='TmName'),
  tmNumber?: string(name='TmNumber'),
  tmType?: string(name='TmType'),
  tradeTmDetailJson?: string(name='TradeTmDetailJson'),
  type?: string(name='Type'),
}

model UploadTrademarkOnSaleResponseBody = {
  requestId?: string(name='RequestId'),
}

model UploadTrademarkOnSaleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadTrademarkOnSaleResponseBody(name='body'),
}

async function uploadTrademarkOnSaleWithOptions(request: UploadTrademarkOnSaleRequest, runtime: Util.RuntimeOptions): UploadTrademarkOnSaleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.classificationCode)) {
    query['ClassificationCode'] = request.classificationCode;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.label)) {
    query['Label'] = request.label;
  }
  if (!Util.isUnset(request.originalPrice)) {
    query['OriginalPrice'] = request.originalPrice;
  }
  if (!Util.isUnset(request.ownerEnName)) {
    query['OwnerEnName'] = request.ownerEnName;
  }
  if (!Util.isUnset(request.ownerName)) {
    query['OwnerName'] = request.ownerName;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.regAnnDate)) {
    query['RegAnnDate'] = request.regAnnDate;
  }
  if (!Util.isUnset(request.secondaryClassification)) {
    query['SecondaryClassification'] = request.secondaryClassification;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.thirdClassification)) {
    query['ThirdClassification'] = request.thirdClassification;
  }
  if (!Util.isUnset(request.tmIcon)) {
    query['TmIcon'] = request.tmIcon;
  }
  if (!Util.isUnset(request.tmName)) {
    query['TmName'] = request.tmName;
  }
  if (!Util.isUnset(request.tmNumber)) {
    query['TmNumber'] = request.tmNumber;
  }
  if (!Util.isUnset(request.tmType)) {
    query['TmType'] = request.tmType;
  }
  if (!Util.isUnset(request.tradeTmDetailJson)) {
    query['TradeTmDetailJson'] = request.tradeTmDetailJson;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadTrademarkOnSale',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadTrademarkOnSale(request: UploadTrademarkOnSaleRequest): UploadTrademarkOnSaleResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadTrademarkOnSaleWithOptions(request, runtime);
}

model WriteCommunicationLogRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
  targetId?: string(name='TargetId'),
}

model WriteCommunicationLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model WriteCommunicationLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: WriteCommunicationLogResponseBody(name='body'),
}

async function writeCommunicationLogWithOptions(request: WriteCommunicationLogRequest, runtime: Util.RuntimeOptions): WriteCommunicationLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  if (!Util.isUnset(request.targetId)) {
    query['TargetId'] = request.targetId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'WriteCommunicationLog',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function writeCommunicationLog(request: WriteCommunicationLogRequest): WriteCommunicationLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return writeCommunicationLogWithOptions(request, runtime);
}

model WriteIntentionCommunicationLogRequest {
  bizId?: string(name='BizId'),
  note?: string(name='Note'),
  reject?: boolean(name='Reject'),
}

model WriteIntentionCommunicationLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model WriteIntentionCommunicationLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: WriteIntentionCommunicationLogResponseBody(name='body'),
}

async function writeIntentionCommunicationLogWithOptions(request: WriteIntentionCommunicationLogRequest, runtime: Util.RuntimeOptions): WriteIntentionCommunicationLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bizId)) {
    query['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  if (!Util.isUnset(request.reject)) {
    query['Reject'] = request.reject;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'WriteIntentionCommunicationLog',
    version = '2018-07-24',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function writeIntentionCommunicationLog(request: WriteIntentionCommunicationLogRequest): WriteIntentionCommunicationLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return writeIntentionCommunicationLogWithOptions(request, runtime);
}

