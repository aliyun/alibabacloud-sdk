/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'PAIABTest';
  @version = '2024-01-19';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model CheckLayerRequest {
  layerId?: string(name='LayerId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
  paramNames?: string(name='ParamNames', position='Query'),
}

model CheckLayerResponseBody = {
  checkResults?: [ 
    {
      experimentId?: string(name='ExperimentId'),
      experimentName?: string(name='ExperimentName'),
      paramName?: string(name='ParamName'),
    }
  ](name='CheckResults'),
  requestId?: string(name='RequestId'),
}

model CheckLayerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckLayerResponseBody(name='body'),
}

async function checkLayer(request: CheckLayerRequest): CheckLayerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CheckLayer', 'GET', '/api/v1/layers/{LayerId}/action/check', 'json', false, 'json', request);
}

model CreateCrowdRequest {
  regionid?: string(name='Regionid', position='Host'),
  description?: string(name='Description', position='Body'),
  label?: string(name='Label', position='Body'),
  name: string(name='Name', position='Body'),
  users: string(name='Users', position='Body'),
  workspaceId: string(name='WorkspaceId', position='Body'),
}

model CreateCrowdResponseBody = {
  crowdId?: string(name='CrowdId'),
  requestId?: string(name='RequestId'),
}

model CreateCrowdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCrowdResponseBody(name='body'),
}

async function createCrowd(request: CreateCrowdRequest): CreateCrowdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateCrowd', 'POST', '/api/v1/crowds', 'json', false, 'json', request);
}

model CreateDomainRequest {
  regionId?: string(name='RegionId', position='Host'),
  bucketType: string(name='BucketType', position='Body'),
  condition?: string(name='Condition', position='Body'),
  crowdIds?: string(name='CrowdIds', position='Body'),
  debugUsers?: string(name='DebugUsers', position='Body'),
  description?: string(name='Description', position='Body'),
  flow?: long(name='Flow', position='Body'),
  layerId: string(name='LayerId', position='Body'),
  name: string(name='Name', position='Body'),
  projectId: string(name='ProjectId', position='Body'),
  workspaceId: string(name='WorkspaceId', position='Body'),
}

model CreateDomainResponseBody = {
  domainId?: string(name='DomainId'),
  requestId?: string(name='RequestId'),
}

model CreateDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDomainResponseBody(name='body'),
}

async function createDomain(request: CreateDomainRequest): CreateDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateDomain', 'POST', '/api/v1/domains', 'json', false, 'json', request);
}

model CreateExperimentRequest {
  regionId?: string(name='RegionId', position='Host'),
  bucketType: string(name='BucketType', position='Body'),
  condition?: string(name='Condition', position='Body'),
  coreMetricId: string(name='CoreMetricId', position='Body'),
  crowdIds?: string(name='CrowdIds', position='Body'),
  debugUsers?: string(name='DebugUsers', position='Body'),
  description?: string(name='Description', position='Body'),
  endTime: string(name='EndTime', position='Body'),
  flow?: int32(name='Flow', position='Body'),
  focusMetricIds: string(name='FocusMetricIds', position='Body'),
  layerId: string(name='LayerId', position='Body'),
  name: string(name='Name', position='Body'),
  startTime: string(name='StartTime', position='Body'),
  workspaceId: string(name='WorkspaceId', position='Body'),
}

model CreateExperimentResponseBody = {
  experimentId?: string(name='ExperimentId'),
  requestId?: string(name='RequestId'),
}

model CreateExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateExperimentResponseBody(name='body'),
}

async function createExperiment(request: CreateExperimentRequest): CreateExperimentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateExperiment', 'POST', '/api/v1/experiments', 'json', false, 'json', request);
}

model CreateExperimentVersionRequest {
  regionId?: string(name='RegionId', position='Host'),
  config?: string(name='Config', position='Body'),
  crowdIds?: string(name='CrowdIds', position='Body'),
  debugUsers?: string(name='DebugUsers', position='Body'),
  description?: string(name='Description', position='Body'),
  experimentId: string(name='ExperimentId', position='Body'),
  flow?: int32(name='Flow', position='Body'),
  name: string(name='Name', position='Body'),
  type: string(name='Type', position='Body'),
}

model CreateExperimentVersionResponseBody = {
  experimentVersionId?: string(name='ExperimentVersionId'),
  requestId?: string(name='RequestId'),
}

model CreateExperimentVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateExperimentVersionResponseBody(name='body'),
}

async function createExperimentVersion(request: CreateExperimentVersionRequest): CreateExperimentVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateExperimentVersion', 'POST', '/api/v1/experimentversions', 'json', false, 'json', request);
}

model CreateFeatureRequest {
  regionId?: string(name='RegionId', position='Query'),
  name?: string(name='Name', position='Body'),
  status?: string(name='Status', position='Body'),
}

model CreateFeatureResponseBody = {
  featureId?: string(name='FeatureId'),
  requestId?: string(name='RequestId'),
}

model CreateFeatureResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFeatureResponseBody(name='body'),
}

async function createFeature(request: CreateFeatureRequest): CreateFeatureResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateFeature', 'POST', '/api/v1/features', 'json', false, 'json', request);
}

model CreateLayerRequest {
  regionId?: string(name='RegionId', position='Host'),
  description?: string(name='Description', position='Body'),
  domainId?: string(name='DomainId', position='Body'),
  name: string(name='Name', position='Body'),
  projectId: string(name='ProjectId', position='Body'),
  workspaceId: string(name='WorkspaceId', position='Body'),
}

model CreateLayerResponseBody = {
  layerId?: string(name='LayerId'),
  requestId?: string(name='RequestId'),
}

model CreateLayerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLayerResponseBody(name='body'),
}

async function createLayer(request: CreateLayerRequest): CreateLayerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateLayer', 'POST', '/api/v1/layers', 'json', false, 'json', request);
}

model CreateMetricRequest {
  regionId?: string(name='RegionId', position='Host'),
  definition: string(name='Definition', position='Body'),
  description?: string(name='Description', position='Body'),
  metricGroupId: string(name='MetricGroupId', position='Body'),
  name: string(name='Name', position='Body'),
  sourceTableMetaId: string(name='SourceTableMetaId', position='Body'),
}

model CreateMetricResponseBody = {
  metricId?: string(name='MetricId'),
  requestId?: string(name='RequestId'),
}

model CreateMetricResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMetricResponseBody(name='body'),
}

async function createMetric(request: CreateMetricRequest): CreateMetricResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateMetric', 'POST', '/api/v1/metrics', 'json', false, 'json', request);
}

model CreateMetricGroupRequest {
  regionId?: string(name='RegionId', position='Host'),
  description?: string(name='Description', position='Body'),
  name: string(name='Name', position='Body'),
  workspaceId: string(name='WorkspaceId', position='Body'),
}

model CreateMetricGroupResponseBody = {
  metricGroupId?: string(name='MetricGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateMetricGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMetricGroupResponseBody(name='body'),
}

async function createMetricGroup(request: CreateMetricGroupRequest): CreateMetricGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateMetricGroup', 'POST', '/api/v1/metricgroups', 'json', false, 'json', request);
}

model CreateProjectRequest {
  regionId?: string(name='RegionId', position='Host'),
  description?: string(name='Description', position='Body'),
  name: string(name='Name', position='Body'),
  workspaceId: string(name='WorkspaceId', position='Body'),
}

model CreateProjectResponseBody = {
  projectId?: string(name='ProjectId'),
  requestId?: string(name='RequestId'),
}

model CreateProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateProjectResponseBody(name='body'),
}

async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateProject', 'POST', '/api/v1/projects', 'json', false, 'json', request);
}

model CreateTableMetaRequest {
  regionId?: string(name='RegionId', position='Host'),
  datasourceInfo: string(name='DatasourceInfo', position='Body'),
  datasourceType: string(name='DatasourceType', position='Body'),
  description?: string(name='Description', position='Body'),
  fields: [ 
    {
      meaning: string(name='Meaning'),
      name: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='Fields', position='Body'),
  name: string(name='Name', position='Body'),
  tableName: string(name='TableName', position='Body'),
  workspaceId: string(name='WorkspaceId', position='Body'),
}

model CreateTableMetaResponseBody = {
  requestId?: string(name='RequestId'),
  tableMetaId?: string(name='TableMetaId'),
}

model CreateTableMetaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTableMetaResponseBody(name='body'),
}

async function createTableMeta(request: CreateTableMetaRequest): CreateTableMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateTableMeta', 'POST', '/api/v1/tablemetas', 'json', false, 'json', request);
}

model DeleteCrowdRequest {
  crowdId: string(name='CrowdId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model DeleteCrowdResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCrowdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCrowdResponseBody(name='body'),
}

async function deleteCrowd(request: DeleteCrowdRequest): DeleteCrowdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteCrowd', 'DELETE', '/api/v1/crowds/{CrowdId}', 'json', false, 'json', request);
}

model DeleteDomainRequest {
  domainId: string(name='DomainId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model DeleteDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDomainResponseBody(name='body'),
}

async function deleteDomain(request: DeleteDomainRequest): DeleteDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteDomain', 'DELETE', '/api/v1/domains/{DomainId}', 'json', false, 'json', request);
}

model DeleteExperimentRequest {
  experimentId: string(name='ExperimentId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model DeleteExperimentResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteExperimentResponseBody(name='body'),
}

async function deleteExperiment(request: DeleteExperimentRequest): DeleteExperimentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteExperiment', 'DELETE', '/api/v1/experiments/{ExperimentId}', 'json', false, 'json', request);
}

model DeleteExperimentVersionRequest {
  experimentVersionId: string(name='ExperimentVersionId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model DeleteExperimentVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExperimentVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteExperimentVersionResponseBody(name='body'),
}

async function deleteExperimentVersion(request: DeleteExperimentVersionRequest): DeleteExperimentVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteExperimentVersion', 'DELETE', '/api/v1/experimentversions/{ExperimentVersionId}', 'json', false, 'json', request);
}

model DeleteFeatureRequest {
  featureId: string(name='FeatureId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model DeleteFeatureResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFeatureResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFeatureResponseBody(name='body'),
}

async function deleteFeature(request: DeleteFeatureRequest): DeleteFeatureResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFeature', 'DELETE', '/api/v1/features/{FeatureId}', 'json', false, 'json', request);
}

model DeleteLayerRequest {
  layerId: string(name='LayerId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model DeleteLayerResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLayerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLayerResponseBody(name='body'),
}

async function deleteLayer(request: DeleteLayerRequest): DeleteLayerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteLayer', 'DELETE', '/api/v1/layers/{LayerId}', 'json', false, 'json', request);
}

model DeleteMetricRequest {
  metricId: string(name='MetricId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model DeleteMetricResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMetricResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMetricResponseBody(name='body'),
}

async function deleteMetric(request: DeleteMetricRequest): DeleteMetricResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteMetric', 'DELETE', '/api/v1/metrics/{MetricId}', 'json', false, 'json', request);
}

model DeleteMetricGroupRequest {
  metricGroupId: string(name='MetricGroupId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model DeleteMetricGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMetricGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMetricGroupResponseBody(name='body'),
}

async function deleteMetricGroup(request: DeleteMetricGroupRequest): DeleteMetricGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteMetricGroup', 'DELETE', '/api/v1/metricgroups/{MetricGroupId}', 'json', false, 'json', request);
}

model DeleteProjectRequest {
  projectId: string(name='ProjectId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model DeleteProjectResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteProjectResponseBody(name='body'),
}

async function deleteProject(request: DeleteProjectRequest): DeleteProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteProject', 'DELETE', '/api/v1/projects/{ProjectId}', 'json', false, 'json', request);
}

model DeleteTableMetaRequest {
  tableMetaId: string(name='TableMetaId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model DeleteTableMetaResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTableMetaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTableMetaResponseBody(name='body'),
}

async function deleteTableMeta(request: DeleteTableMetaRequest): DeleteTableMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteTableMeta', 'DELETE', '/api/v1/tablemetas/{TableMetaId}', 'json', false, 'json', request);
}

model GetCrowdRequest {
  crowdId: string(name='CrowdId', position='Path'),
  regionid?: string(name='Regionid', position='Host'),
}

model GetCrowdResponseBody = {
  crowdId?: string(name='CrowdId'),
  description?: string(name='Description'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  label?: string(name='Label'),
  name?: string(name='Name'),
  quantity?: string(name='Quantity'),
  requestId?: string(name='RequestId'),
  users?: string(name='Users'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetCrowdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCrowdResponseBody(name='body'),
}

async function getCrowd(request: GetCrowdRequest): GetCrowdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetCrowd', 'GET', '/api/v1/crowds/{CrowdId}', 'json', false, 'json', request);
}

model GetDomainRequest {
  domainId: string(name='DomainId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
  projectId?: string(name='ProjectId', position='Query'),
}

model GetDomainResponseBody = {
  bucketType?: string(name='BucketType'),
  buckets?: string(name='Buckets'),
  condition?: string(name='Condition'),
  crowdIds?: string(name='CrowdIds'),
  debugUsers?: string(name='DebugUsers'),
  description?: string(name='Description'),
  domainId?: string(name='DomainId'),
  flow?: long(name='Flow'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  isDefaultDomain?: boolean(name='IsDefaultDomain'),
  layerId?: string(name='LayerId'),
  layerName?: string(name='LayerName'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
  projectName?: string(name='ProjectName'),
  requestId?: string(name='RequestId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDomainResponseBody(name='body'),
}

async function getDomain(request: GetDomainRequest): GetDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetDomain', 'GET', '/api/v1/domains/{DomainId}', 'json', false, 'json', request);
}

model GetExperimentRequest {
  experimentId: string(name='ExperimentId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model GetExperimentResponseBody = {
  bucketType?: string(name='BucketType'),
  buckets?: string(name='Buckets'),
  condition?: string(name='Condition'),
  coreMetricId?: string(name='CoreMetricId'),
  crowdIds?: string(name='CrowdIds'),
  debugUsers?: string(name='DebugUsers'),
  description?: string(name='Description'),
  domainName?: string(name='DomainName'),
  endTime?: string(name='EndTime'),
  experimentId?: string(name='ExperimentId'),
  flow?: int32(name='Flow'),
  focusMetricIds?: string(name='FocusMetricIds'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  layerId?: string(name='LayerId'),
  layerName?: string(name='LayerName'),
  name?: string(name='Name'),
  owner?: string(name='Owner'),
  projectName?: string(name='ProjectName'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetExperimentResponseBody(name='body'),
}

async function getExperiment(request: GetExperimentRequest): GetExperimentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetExperiment', 'GET', '/api/v1/experiments/{ExperimentId}', 'json', false, 'json', request);
}

model GetExperimentVersionRequest {
  experimentVersionId: string(name='ExperimentVersionId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model GetExperimentVersionResponseBody = {
  buckets?: string(name='Buckets'),
  config?: string(name='Config'),
  crowdIds?: string(name='CrowdIds'),
  debugUsers?: string(name='DebugUsers'),
  description?: string(name='Description'),
  experimentId?: string(name='ExperimentId'),
  experimentVersionId?: string(name='ExperimentVersionId'),
  flow?: int32(name='Flow'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  type?: string(name='Type'),
}

model GetExperimentVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetExperimentVersionResponseBody(name='body'),
}

async function getExperimentVersion(request: GetExperimentVersionRequest): GetExperimentVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetExperimentVersion', 'GET', '/api/v1/experimentversions/{ExperimentVersionId}', 'json', false, 'json', request);
}

model GetFeatureRequest {
  featureId: string(name='FeatureId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model GetFeatureResponseBody = {
  condition?: string(name='Condition'),
  config?: string(name='Config'),
  domainId?: string(name='DomainId'),
  domainName?: string(name='DomainName'),
  experimentId?: string(name='ExperimentId'),
  experimentName?: string(name='ExperimentName'),
  experimentOwner?: string(name='ExperimentOwner'),
  experimentVersionId?: string(name='ExperimentVersionId'),
  experimentVersionName?: string(name='ExperimentVersionName'),
  featureId?: string(name='FeatureId'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
  projectName?: string(name='ProjectName'),
  releaseTime?: string(name='ReleaseTime'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetFeatureResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFeatureResponseBody(name='body'),
}

async function getFeature(request: GetFeatureRequest): GetFeatureResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFeature', 'GET', '/api/v1/features/{FeatureId}', 'json', false, 'json', request);
}

model GetLayerRequest {
  layerId: string(name='LayerId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model GetLayerResponseBody = {
  description?: string(name='Description'),
  domainId?: string(name='DomainId'),
  domainName?: string(name='DomainName'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  isDefaultLayer?: boolean(name='IsDefaultLayer'),
  layerId?: string(name='LayerId'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
  projectName?: string(name='ProjectName'),
  requestId?: string(name='RequestId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetLayerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLayerResponseBody(name='body'),
}

async function getLayer(request: GetLayerRequest): GetLayerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLayer', 'GET', '/api/v1/layers/{LayerId}', 'json', false, 'json', request);
}

model GetMetricRequest {
  metricId: string(name='MetricId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model GetMetricResponseBody = {
  definition?: string(name='Definition'),
  description?: string(name='Description'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  metricGroupId?: string(name='MetricGroupId'),
  metricId?: string(name='MetricId'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  sourceTableMetaId?: string(name='SourceTableMetaId'),
  sourceTableMetaName?: string(name='SourceTableMetaName'),
}

model GetMetricResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetricResponseBody(name='body'),
}

async function getMetric(request: GetMetricRequest): GetMetricResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetMetric', 'GET', '/api/v1/metrics/{MetricId}', 'json', false, 'json', request);
}

model GetMetricGroupRequest {
  metricGroupId: string(name='MetricGroupId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model GetMetricGroupResponseBody = {
  description?: string(name='Description'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  metricGroupId?: string(name='MetricGroupId'),
  metrics?: [ 
    {
      definition?: string(name='Definition'),
      description?: string(name='Description'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      metricId?: string(name='MetricId'),
      name?: string(name='Name'),
      relatedExperimentNumber?: long(name='RelatedExperimentNumber'),
      sourceTableMetaId?: string(name='SourceTableMetaId'),
    }
  ](name='Metrics'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetMetricGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetricGroupResponseBody(name='body'),
}

async function getMetricGroup(request: GetMetricGroupRequest): GetMetricGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetMetricGroup', 'GET', '/api/v1/metricgroups/{MetricGroupId}', 'json', false, 'json', request);
}

model GetProjectRequest {
  projectId: string(name='ProjectId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model GetProjectResponseBody = {
  defaultDomainId?: string(name='DefaultDomainId'),
  defaultLayerId?: string(name='DefaultLayerId'),
  description?: string(name='Description'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
  requestId?: string(name='RequestId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetProjectResponseBody(name='body'),
}

async function getProject(request: GetProjectRequest): GetProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetProject', 'GET', '/api/v1/projects/{ProjectId}', 'json', false, 'json', request);
}

model GetTableMetaRequest {
  tableMetaId: string(name='TableMetaId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model GetTableMetaResponseBody = {
  datasourceInfo?: string(name='DatasourceInfo'),
  datasourceType?: string(name='DatasourceType'),
  description?: string(name='Description'),
  fields?: [ 
    {
      meaning?: string(name='Meaning'),
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='Fields'),
  gmtCreateTime?: string(name='GmtCreateTime'),
  gmtModifiedTime?: string(name='GmtModifiedTime'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  tableMetaId?: string(name='TableMetaId'),
  tableName?: string(name='TableName'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetTableMetaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTableMetaResponseBody(name='body'),
}

async function getTableMeta(request: GetTableMetaRequest): GetTableMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTableMeta', 'GET', '/api/v1/tablemetas/{TableMetaId}', 'json', false, 'json', request);
}

model ListCrowdsRequest {
  all?: boolean(name='All', position='Query'),
  crowdId?: string(name='CrowdId', position='Query'),
  crowdName?: string(name='CrowdName', position='Query'),
  order?: string(name='Order', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  workspaceId?: string(name='WorkspaceId', position='Query'),
}

model ListCrowdsResponseBody = {
  crowds?: [ 
    {
      aliyunId?: string(name='AliyunId'),
      crowdId?: string(name='CrowdId'),
      description?: string(name='Description'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifyTime?: string(name='GmtModifyTime'),
      label?: string(name='Label'),
      name?: string(name='Name'),
      quantity?: string(name='Quantity'),
      users?: string(name='Users'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Crowds'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListCrowdsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCrowdsResponseBody(name='body'),
}

async function listCrowds(request: ListCrowdsRequest): ListCrowdsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListCrowds', 'GET', '/api/v1/crowds', 'json', false, 'json', request);
}

model ListDomainsRequest {
  all?: boolean(name='All', position='Query'),
  domainId?: string(name='DomainId', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  layerId?: string(name='LayerId', position='Query'),
  order?: string(name='Order', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  projectId?: string(name='ProjectId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  workspaceId?: string(name='WorkspaceId', position='Query'),
}

model ListDomainsResponseBody = {
  domains?: [ 
    {
      bucketType?: string(name='BucketType'),
      buckets?: string(name='Buckets'),
      condition?: string(name='Condition'),
      crowdIds?: string(name='CrowdIds'),
      debugUsers?: string(name='DebugUsers'),
      description?: string(name='Description'),
      domainId?: string(name='DomainId'),
      flow?: long(name='Flow'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      isDefaultDomain?: boolean(name='IsDefaultDomain'),
      layerId?: string(name='LayerId'),
      layerName?: string(name='LayerName'),
      name?: string(name='Name'),
      projectId?: string(name='ProjectId'),
      projectName?: string(name='ProjectName'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Domains'),
  requestId?: string(name='RequestId'),
  totalCount?: string(name='TotalCount'),
}

model ListDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDomainsResponseBody(name='body'),
}

async function listDomains(request: ListDomainsRequest): ListDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListDomains', 'GET', '/api/v1/domains', 'json', false, 'json', request);
}

model ListExperimentVersionsRequest {
  regionId?: string(name='RegionId', position='Host'),
  all?: boolean(name='All', position='Query'),
  experimentId?: string(name='ExperimentId', position='Query'),
  order?: string(name='Order', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
}

model ListExperimentVersionsResponseBody = {
  experimentVersions?: [ 
    {
      buckets?: string(name='Buckets'),
      config?: string(name='Config'),
      crowdIds?: string(name='CrowdIds'),
      debugUsers?: string(name='DebugUsers'),
      description?: string(name='Description'),
      experimentId?: string(name='ExperimentId'),
      experimentVersionId?: string(name='ExperimentVersionId'),
      flow?: int32(name='Flow'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='ExperimentVersions'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListExperimentVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListExperimentVersionsResponseBody(name='body'),
}

async function listExperimentVersions(request: ListExperimentVersionsRequest): ListExperimentVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListExperimentVersions', 'GET', '/api/v1/experimentversions', 'json', false, 'json', request);
}

model ListExperimentsRequest {
  regionId?: string(name='RegionId', position='Host'),
  all?: boolean(name='All', position='Query'),
  experimentId?: string(name='ExperimentId', position='Query'),
  experimentName?: string(name='ExperimentName', position='Query'),
  layerId?: string(name='LayerId', position='Query'),
  order?: string(name='Order', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  projectId?: string(name='ProjectId', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  status?: string(name='Status', position='Query'),
  workspaceId?: string(name='WorkspaceId', position='Query'),
}

model ListExperimentsResponseBody = {
  experiments?: [ 
    {
      bucketType?: string(name='BucketType'),
      buckets?: string(name='Buckets'),
      condition?: string(name='Condition'),
      coreMetricId?: string(name='CoreMetricId'),
      crowdIds?: string(name='CrowdIds'),
      debugUsers?: string(name='DebugUsers'),
      description?: string(name='Description'),
      domainName?: string(name='DomainName'),
      endTime?: string(name='EndTime'),
      experimentId?: string(name='ExperimentId'),
      flow?: int32(name='Flow'),
      focusMetricIds?: string(name='FocusMetricIds'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      layerId?: string(name='LayerId'),
      layerName?: string(name='LayerName'),
      name?: string(name='Name'),
      owner?: string(name='Owner'),
      projectName?: string(name='ProjectName'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Experiments'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListExperimentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListExperimentsResponseBody(name='body'),
}

async function listExperiments(request: ListExperimentsRequest): ListExperimentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListExperiments', 'GET', '/api/v1/experiments', 'json', false, 'json', request);
}

model ListFeaturesRequest {
  all?: boolean(name='All', position='Query'),
  domainId?: string(name='DomainId', position='Query'),
  featureId?: string(name='FeatureId', position='Query'),
  featureName?: string(name='FeatureName', position='Query'),
  order?: string(name='Order', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  status?: string(name='Status', position='Query'),
  workspaceId?: string(name='WorkspaceId', position='Query'),
}

model ListFeaturesResponseBody = {
  features?: [ 
    {
      config?: string(name='Config'),
      domainId?: string(name='DomainId'),
      domainName?: string(name='DomainName'),
      experimentId?: string(name='ExperimentId'),
      experimentName?: string(name='ExperimentName'),
      experimentOwner?: string(name='ExperimentOwner'),
      experimentVersionId?: string(name='ExperimentVersionId'),
      experimentVersionName?: string(name='ExperimentVersionName'),
      featureId?: string(name='FeatureId'),
      filter?: string(name='Filter'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      name?: string(name='Name'),
      projectId?: string(name='ProjectId'),
      projectName?: string(name='ProjectName'),
      releaseTime?: string(name='ReleaseTime'),
      status?: string(name='Status'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Features'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListFeaturesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListFeaturesResponseBody(name='body'),
}

async function listFeatures(request: ListFeaturesRequest): ListFeaturesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFeatures', 'GET', '/api/v1/features', 'json', false, 'json', request);
}

model ListLayersRequest {
  regionId?: string(name='RegionId', position='Host'),
  all?: boolean(name='All', position='Query'),
  domainId?: string(name='DomainId', position='Query'),
  layerId?: string(name='LayerId', position='Query'),
  layerName?: string(name='LayerName', position='Query'),
  order?: string(name='Order', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  projectId?: string(name='ProjectId', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  workspaceId?: string(name='WorkspaceId', position='Query'),
}

model ListLayersResponseBody = {
  layers?: [ 
    {
      description?: string(name='Description'),
      domainId?: string(name='DomainId'),
      domainName?: string(name='DomainName'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifyTime?: string(name='GmtModifyTime'),
      isDefaultLayer?: boolean(name='IsDefaultLayer'),
      layerId?: string(name='LayerId'),
      name?: string(name='Name'),
      projectId?: string(name='ProjectId'),
      projectName?: string(name='ProjectName'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Layers'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListLayersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLayersResponseBody(name='body'),
}

async function listLayers(request: ListLayersRequest): ListLayersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLayers', 'GET', '/api/v1/layers', 'json', false, 'json', request);
}

model ListMetricGroupsRequest {
  all?: boolean(name='All', position='Query'),
  metricGroupId?: string(name='MetricGroupId', position='Query'),
  metricGroupName?: string(name='MetricGroupName', position='Query'),
  order?: string(name='Order', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  workspaceId?: string(name='WorkspaceId', position='Query'),
}

model ListMetricGroupsResponseBody = {
  metricGroups?: [ 
    {
      description?: string(name='Description'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      metricGroupId?: string(name='MetricGroupId'),
      metrics?: [ 
        {
          definition?: string(name='Definition'),
          description?: string(name='Description'),
          gmtCreateTime?: string(name='GmtCreateTime'),
          gmtModifiedTime?: string(name='GmtModifiedTime'),
          metricId?: string(name='MetricId'),
          name?: string(name='Name'),
          relatedExperimentsNumber?: long(name='RelatedExperimentsNumber'),
          sourceTableMetaId?: string(name='SourceTableMetaId'),
        }
      ](name='Metrics'),
      name?: string(name='Name'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='MetricGroups'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListMetricGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMetricGroupsResponseBody(name='body'),
}

async function listMetricGroups(request: ListMetricGroupsRequest): ListMetricGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListMetricGroups', 'GET', '/api/v1/metricgroups', 'json', false, 'json', request);
}

model ListMetricsRequest {
  regionId?: string(name='RegionId', position='Host'),
  all?: string(name='All', position='Query'),
  metricGroupId?: string(name='MetricGroupId', position='Query'),
  metricId?: string(name='MetricId', position='Query'),
  metricName?: string(name='MetricName', position='Query'),
  order?: string(name='Order', position='Query'),
  pageNumber?: string(name='PageNumber', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
}

model ListMetricsResponseBody = {
  metrics?: [ 
    {
      definition?: string(name='Definition'),
      description?: string(name='Description'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      metricGroupId?: string(name='MetricGroupId'),
      metricId?: string(name='MetricId'),
      name?: string(name='Name'),
      sourceTableMetaId?: string(name='SourceTableMetaId'),
      sourceTableMetaName?: string(name='SourceTableMetaName'),
    }
  ](name='Metrics'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListMetricsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMetricsResponseBody(name='body'),
}

async function listMetrics(request: ListMetricsRequest): ListMetricsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListMetrics', 'GET', '/api/v1/metrics', 'json', false, 'json', request);
}

model ListProjectsRequest {
  regionId?: string(name='RegionId', position='Host'),
  all?: boolean(name='All', position='Query'),
  name?: string(name='Name', position='Query'),
  order?: string(name='Order', position='Query'),
  pageNumber?: string(name='PageNumber', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  projectId?: string(name='ProjectId', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  workspaceId?: string(name='WorkspaceId', position='Query'),
}

model ListProjectsResponseBody = {
  projects?: [ 
    {
      aliyunId?: string(name='AliyunId'),
      defaultDomainId?: string(name='DefaultDomainId'),
      defaultLayerId?: string(name='DefaultLayerId'),
      description?: string(name='Description'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      name?: string(name='Name'),
      projectId?: string(name='ProjectId'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='Projects'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListProjectsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProjectsResponseBody(name='body'),
}

async function listProjects(request: ListProjectsRequest): ListProjectsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListProjects', 'GET', '/api/v1/projects', 'json', false, 'json', request);
}

model ListTableMetasRequest {
  regionId?: string(name='RegionId', position='Host'),
  all?: boolean(name='All', position='Query'),
  datasourceType?: string(name='DatasourceType', position='Query'),
  order?: string(name='Order', position='Query'),
  pageNumber?: string(name='PageNumber', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  sortBy?: string(name='SortBy', position='Query'),
  tableMetaId?: string(name='TableMetaId', position='Query'),
  tableMetaName?: string(name='TableMetaName', position='Query'),
  workspaceId?: string(name='WorkspaceId', position='Query'),
}

model ListTableMetasResponseBody = {
  requestId?: string(name='RequestId'),
  tableMetas?: [ 
    {
      canDelete?: boolean(name='CanDelete'),
      datasourceInfo?: string(name='DatasourceInfo'),
      datasourceType?: string(name='DatasourceType'),
      description?: string(name='Description'),
      fields?: [ 
        {
          meaning?: string(name='Meaning'),
          name?: string(name='Name'),
          type?: string(name='Type'),
        }
      ](name='Fields'),
      gmtCreateTime?: string(name='GmtCreateTime'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      name?: string(name='Name'),
      tableMetaId?: string(name='TableMetaId'),
      tableName?: string(name='TableName'),
      workspaceId?: string(name='WorkspaceId'),
    }
  ](name='TableMetas'),
  totalCount?: long(name='TotalCount'),
}

model ListTableMetasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTableMetasResponseBody(name='body'),
}

async function listTableMetas(request: ListTableMetasRequest): ListTableMetasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTableMetas', 'GET', '/api/v1/tablemetas', 'json', false, 'json', request);
}

model PushAllExperimentVersionRequest {
  experimentVersionId: string(name='ExperimentVersionId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
  featureName: string(name='FeatureName', position='Body'),
}

model PushAllExperimentVersionResponseBody = {
  featureId?: string(name='FeatureId'),
  requestId?: string(name='RequestId'),
}

model PushAllExperimentVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushAllExperimentVersionResponseBody(name='body'),
}

async function pushAllExperimentVersion(request: PushAllExperimentVersionRequest): PushAllExperimentVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PushAllExperimentVersion', 'POST', '/api/v1/experimentversions/{ExperimentVersionId}/action/pushall', 'json', false, 'json', request);
}

model StartExperimentRequest {
  experimentId?: string(name='ExperimentId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model StartExperimentResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartExperimentResponseBody(name='body'),
}

async function startExperiment(request: StartExperimentRequest): StartExperimentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StartExperiment', 'POST', '/api/v1/experiments/{ExperimentId}/action/start', 'json', false, 'json', request);
}

model StopExperimentRequest {
  experimentId?: string(name='ExperimentId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
}

model StopExperimentResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopExperimentResponseBody(name='body'),
}

async function stopExperiment(request: StopExperimentRequest): StopExperimentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopExperiment', 'POST', '/api/v1/experiments/{ExperimentId}/action/stop', 'json', false, 'json', request);
}

model UpdateCrowdRequest {
  crowdId?: string(name='CrowdId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
  description?: string(name='Description', position='Body'),
  label?: string(name='Label', position='Body'),
  name?: string(name='Name', position='Body'),
  users?: string(name='Users', position='Body'),
}

model UpdateCrowdResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateCrowdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCrowdResponseBody(name='body'),
}

async function updateCrowd(request: UpdateCrowdRequest): UpdateCrowdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateCrowd', 'PUT', '/api/v1/crowds/{CrowdId}', 'json', false, 'json', request);
}

model UpdateDomainRequest {
  domainId: string(name='DomainId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
  bucketType: string(name='BucketType', position='Body'),
  condition?: string(name='Condition', position='Body'),
  crowIds?: string(name='CrowIds', position='Body'),
  debugUsers?: string(name='DebugUsers', position='Body'),
  description?: string(name='Description', position='Body'),
  flow?: long(name='Flow', position='Body'),
  name: string(name='Name', position='Body'),
  projectId: string(name='ProjectId', position='Body'),
}

model UpdateDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateDomainResponseBody(name='body'),
}

async function updateDomain(request: UpdateDomainRequest): UpdateDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateDomain', 'PUT', '/api/v1/domains/{DomainId}', 'json', false, 'json', request);
}

model UpdateExperimentRequest {
  experimentId: string(name='ExperimentId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
  bucketType: string(name='BucketType', position='Body'),
  condition?: string(name='Condition', position='Body'),
  coreMetricId: string(name='CoreMetricId', position='Body'),
  crowdIds?: string(name='CrowdIds', position='Body'),
  debugUsers?: string(name='DebugUsers', position='Body'),
  description?: string(name='Description', position='Body'),
  endTime: string(name='EndTime', position='Body'),
  flow?: int32(name='Flow', position='Body'),
  focusMetricIds: string(name='FocusMetricIds', position='Body'),
  name: string(name='Name', position='Body'),
  startTime: string(name='StartTime', position='Body'),
}

model UpdateExperimentResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateExperimentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateExperimentResponseBody(name='body'),
}

async function updateExperiment(request: UpdateExperimentRequest): UpdateExperimentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateExperiment', 'PUT', '/api/v1/experiments/{ExperimentId}', 'json', false, 'json', request);
}

model UpdateExperimentVersionRequest {
  experimentVersionId: string(name='ExperimentVersionId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
  config?: string(name='Config', position='Body'),
  crowdIds?: string(name='CrowdIds', position='Body'),
  debugUsers?: string(name='DebugUsers', position='Body'),
  description?: string(name='Description', position='Body'),
  flow?: int32(name='Flow', position='Body'),
  name: string(name='Name', position='Body'),
  type: string(name='Type', position='Body'),
}

model UpdateExperimentVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateExperimentVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateExperimentVersionResponseBody(name='body'),
}

async function updateExperimentVersion(request: UpdateExperimentVersionRequest): UpdateExperimentVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateExperimentVersion', 'PUT', '/api/v1/experimentversions/{ExperimentVersionId}', 'json', false, 'json', request);
}

model UpdateFeatureRequest {
  featureId: string(name='FeatureId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
  status: string(name='Status', position='Body'),
}

model UpdateFeatureResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateFeatureResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateFeatureResponseBody(name='body'),
}

async function updateFeature(request: UpdateFeatureRequest): UpdateFeatureResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateFeature', 'PUT', '/api/v1/features/{FeatureId}', 'json', false, 'json', request);
}

model UpdateLayerRequest {
  layerId: string(name='LayerId', position='Path'),
  regionid?: string(name='Regionid', position='Host'),
  description?: string(name='Description', position='Body'),
  domainId?: string(name='DomainId', position='Body'),
  name: string(name='Name', position='Body'),
  projectId: string(name='ProjectId', position='Body'),
}

model UpdateLayerResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateLayerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLayerResponseBody(name='body'),
}

async function updateLayer(request: UpdateLayerRequest): UpdateLayerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateLayer', 'PUT', '/api/v1/layers/{LayerId}', 'json', false, 'json', request);
}

model UpdateMetricRequest {
  metricId: string(name='MetricId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
  definition: string(name='Definition', position='Body'),
  description?: string(name='Description', position='Body'),
  name: string(name='Name', position='Body'),
  sourceTableMetaId?: string(name='SourceTableMetaId', position='Body'),
}

model UpdateMetricResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMetricResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMetricResponseBody(name='body'),
}

async function updateMetric(request: UpdateMetricRequest): UpdateMetricResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateMetric', 'PUT', '/api/v1/metrics/{MetricId}', 'json', false, 'json', request);
}

model UpdateMetricGroupRequest {
  metricGroupId: string(name='MetricGroupId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
  description?: string(name='Description', position='Body'),
  name: string(name='Name', position='Body'),
  workspaceId: string(name='WorkspaceId', position='Body'),
}

model UpdateMetricGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMetricGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMetricGroupResponseBody(name='body'),
}

async function updateMetricGroup(request: UpdateMetricGroupRequest): UpdateMetricGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateMetricGroup', 'PUT', '/api/v1/metricgroups/{MetricGroupId}', 'json', false, 'json', request);
}

model UpdateProjectRequest {
  projectId: string(name='ProjectId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
  description?: string(name='Description', position='Body'),
  name: string(name='Name', position='Body'),
}

model UpdateProjectResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateProjectResponseBody(name='body'),
}

async function updateProject(request: UpdateProjectRequest): UpdateProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateProject', 'PUT', '/api/v1/projects/{ProjectId}', 'json', false, 'json', request);
}

model UpdateTableMetaRequest {
  tableMetaId: string(name='TableMetaId', position='Path'),
  regionId?: string(name='RegionId', position='Host'),
  description?: string(name='Description', position='Body'),
  fields: [ 
    {
      meaning: string(name='Meaning'),
      name: string(name='Name'),
      type: string(name='Type'),
    }
  ](name='Fields', position='Body'),
  name: string(name='Name', position='Body'),
}

model UpdateTableMetaResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateTableMetaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateTableMetaResponseBody(name='body'),
}

async function updateTableMeta(request: UpdateTableMetaRequest): UpdateTableMetaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateTableMeta', 'PUT', '/api/v1/tablemetas/{TableMetaId}', 'json', false, 'json', request);
}

