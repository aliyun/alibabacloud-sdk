/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  @endpointMap = {
    cn-hangzhou = 'cro-vpc.cn-hangzhou.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('cro', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AccountRiskReportRequest {
  accountType?: int32(name='AccountType'),
  asToken?: string(name='AsToken'),
  clientType?: string(name='ClientType'),
  deviceEnvironment?: map[string]any(name='DeviceEnvironment'),
  entranceCode?: string(name='EntranceCode'),
  extraData?: map[string]any(name='ExtraData'),
  operateFailureReason?: string(name='OperateFailureReason'),
  operateResult?: boolean(name='OperateResult'),
  operateSubType?: string(name='OperateSubType'),
  operateTime?: long(name='OperateTime'),
  operateType?: string(name='OperateType'),
  siteCode?: string(name='SiteCode'),
  userId?: long(name='UserId'),
  userInfo?: map[string]any(name='UserInfo'),
}

model AccountRiskReportShrinkRequest {
  accountType?: int32(name='AccountType'),
  asToken?: string(name='AsToken'),
  clientType?: string(name='ClientType'),
  deviceEnvironmentShrink?: string(name='DeviceEnvironment'),
  entranceCode?: string(name='EntranceCode'),
  extraDataShrink?: string(name='ExtraData'),
  operateFailureReason?: string(name='OperateFailureReason'),
  operateResult?: boolean(name='OperateResult'),
  operateSubType?: string(name='OperateSubType'),
  operateTime?: long(name='OperateTime'),
  operateType?: string(name='OperateType'),
  siteCode?: string(name='SiteCode'),
  userId?: long(name='UserId'),
  userInfoShrink?: string(name='UserInfo'),
}

model AccountRiskReportResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AccountRiskReportResponse = {
  headers: map[string]string(name='headers'),
  body: AccountRiskReportResponseBody(name='body'),
}

async function accountRiskReportWithOptions(tmpReq: AccountRiskReportRequest, runtime: Util.RuntimeOptions): AccountRiskReportResponse {
  Util.validateModel(tmpReq);
  var request = new AccountRiskReportShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.deviceEnvironment)) {
    request.deviceEnvironmentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deviceEnvironment, 'DeviceEnvironment', 'json');
  }
  if (!Util.isUnset(tmpReq.extraData)) {
    request.extraDataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extraData, 'ExtraData', 'json');
  }
  if (!Util.isUnset(tmpReq.userInfo)) {
    request.userInfoShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userInfo, 'UserInfo', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.accountType)) {
    query['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.asToken)) {
    query['AsToken'] = request.asToken;
  }
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.entranceCode)) {
    query['EntranceCode'] = request.entranceCode;
  }
  if (!Util.isUnset(request.operateFailureReason)) {
    query['OperateFailureReason'] = request.operateFailureReason;
  }
  if (!Util.isUnset(request.operateResult)) {
    query['OperateResult'] = request.operateResult;
  }
  if (!Util.isUnset(request.operateSubType)) {
    query['OperateSubType'] = request.operateSubType;
  }
  if (!Util.isUnset(request.operateTime)) {
    query['OperateTime'] = request.operateTime;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.siteCode)) {
    query['SiteCode'] = request.siteCode;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.deviceEnvironmentShrink)) {
    body['DeviceEnvironment'] = request.deviceEnvironmentShrink;
  }
  if (!Util.isUnset(request.extraDataShrink)) {
    body['ExtraData'] = request.extraDataShrink;
  }
  if (!Util.isUnset(request.userInfoShrink)) {
    body['UserInfo'] = request.userInfoShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AccountRiskReport',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function accountRiskReport(request: AccountRiskReportRequest): AccountRiskReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return accountRiskReportWithOptions(request, runtime);
}

model ApplyWatermarkLicenseRequest {
  body?: string(name='Body'),
  fileType?: string(name='FileType'),
  input?: string(name='Input'),
  keyId?: string(name='KeyId'),
  nonce?: string(name='Nonce'),
  secretKey?: string(name='SecretKey'),
  sign?: string(name='Sign'),
  time?: string(name='Time'),
}

model ApplyWatermarkLicenseResponseBody = {
  domain?: string(name='Domain'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ApplyWatermarkLicenseResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyWatermarkLicenseResponseBody(name='body'),
}

async function applyWatermarkLicenseWithOptions(request: ApplyWatermarkLicenseRequest, runtime: Util.RuntimeOptions): ApplyWatermarkLicenseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.body)) {
    query['Body'] = request.body;
  }
  if (!Util.isUnset(request.fileType)) {
    query['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.input)) {
    query['Input'] = request.input;
  }
  if (!Util.isUnset(request.keyId)) {
    query['KeyId'] = request.keyId;
  }
  if (!Util.isUnset(request.nonce)) {
    query['Nonce'] = request.nonce;
  }
  if (!Util.isUnset(request.secretKey)) {
    query['SecretKey'] = request.secretKey;
  }
  if (!Util.isUnset(request.sign)) {
    query['Sign'] = request.sign;
  }
  if (!Util.isUnset(request.time)) {
    query['Time'] = request.time;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyWatermarkLicense',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyWatermarkLicense(request: ApplyWatermarkLicenseRequest): ApplyWatermarkLicenseResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyWatermarkLicenseWithOptions(request, runtime);
}

model CheckRealNameRequest {
  identityNumber?: string(name='IdentityNumber'),
  name?: string(name='Name'),
}

model CheckRealNameResponseBody = {
  code?: int32(name='Code'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CheckRealNameResponse = {
  headers: map[string]string(name='headers'),
  body: CheckRealNameResponseBody(name='body'),
}

async function checkRealNameWithOptions(request: CheckRealNameRequest, runtime: Util.RuntimeOptions): CheckRealNameResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckRealName',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkRealName(request: CheckRealNameRequest): CheckRealNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkRealNameWithOptions(request, runtime);
}

model EmbedWatermarkRequest {
  carrierLink?: string(name='CarrierLink'),
  extendParams?: map[string]any(name='ExtendParams'),
  fileType?: string(name='FileType'),
  invisibleText?: string(name='InvisibleText'),
  markMode?: string(name='MarkMode'),
  scene?: string(name='Scene'),
  visibleText?: string(name='VisibleText'),
}

model EmbedWatermarkShrinkRequest {
  carrierLink?: string(name='CarrierLink'),
  extendParamsShrink?: string(name='ExtendParams'),
  fileType?: string(name='FileType'),
  invisibleText?: string(name='InvisibleText'),
  markMode?: string(name='MarkMode'),
  scene?: string(name='Scene'),
  visibleText?: string(name='VisibleText'),
}

model EmbedWatermarkResponseBody = {
  code?: string(name='Code'),
  data?: {
    carrierLink?: string(name='CarrierLink'),
    outFileSize?: long(name='OutFileSize'),
  }(name='Data'),
  msg?: string(name='Msg'),
  success?: boolean(name='Success'),
}

model EmbedWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: EmbedWatermarkResponseBody(name='body'),
}

async function embedWatermarkWithOptions(tmpReq: EmbedWatermarkRequest, runtime: Util.RuntimeOptions): EmbedWatermarkResponse {
  Util.validateModel(tmpReq);
  var request = new EmbedWatermarkShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.extendParams)) {
    request.extendParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extendParams, 'ExtendParams', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.carrierLink)) {
    query['CarrierLink'] = request.carrierLink;
  }
  if (!Util.isUnset(request.fileType)) {
    query['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.invisibleText)) {
    query['InvisibleText'] = request.invisibleText;
  }
  if (!Util.isUnset(request.markMode)) {
    query['MarkMode'] = request.markMode;
  }
  if (!Util.isUnset(request.scene)) {
    query['Scene'] = request.scene;
  }
  if (!Util.isUnset(request.visibleText)) {
    query['VisibleText'] = request.visibleText;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.extendParamsShrink)) {
    body['ExtendParams'] = request.extendParamsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EmbedWatermark',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function embedWatermark(request: EmbedWatermarkRequest): EmbedWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return embedWatermarkWithOptions(request, runtime);
}

model ExtractWatermarkRequest {
  carrierLink?: string(name='CarrierLink'),
  extendParams?: map[string]any(name='ExtendParams'),
  fileType?: string(name='FileType'),
  scene?: string(name='Scene'),
}

model ExtractWatermarkShrinkRequest {
  carrierLink?: string(name='CarrierLink'),
  extendParamsShrink?: string(name='ExtendParams'),
  fileType?: string(name='FileType'),
  scene?: string(name='Scene'),
}

model ExtractWatermarkResponseBody = {
  code?: string(name='Code'),
  data?: {
    invisibleText?: string(name='InvisibleText'),
  }(name='Data'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExtractWatermarkResponse = {
  headers: map[string]string(name='headers'),
  body: ExtractWatermarkResponseBody(name='body'),
}

async function extractWatermarkWithOptions(tmpReq: ExtractWatermarkRequest, runtime: Util.RuntimeOptions): ExtractWatermarkResponse {
  Util.validateModel(tmpReq);
  var request = new ExtractWatermarkShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.extendParams)) {
    request.extendParamsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extendParams, 'ExtendParams', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.carrierLink)) {
    query['CarrierLink'] = request.carrierLink;
  }
  if (!Util.isUnset(request.fileType)) {
    query['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.scene)) {
    query['Scene'] = request.scene;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.extendParamsShrink)) {
    body['ExtendParams'] = request.extendParamsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ExtractWatermark',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function extractWatermark(request: ExtractWatermarkRequest): ExtractWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return extractWatermarkWithOptions(request, runtime);
}

model GetAccountIdentityInfoRequest {
  accountId?: string(name='AccountId'),
  biz?: string(name='Biz'),
  properties?: map[string]any(name='Properties'),
  source?: string(name='Source'),
}

model GetAccountIdentityInfoShrinkRequest {
  accountId?: string(name='AccountId'),
  biz?: string(name='Biz'),
  propertiesShrink?: string(name='Properties'),
  source?: string(name='Source'),
}

model GetAccountIdentityInfoResponseBody = {
  accountIdentityInfo?: {
    cardNumber?: string(name='CardNumber'),
    name?: string(name='Name'),
  }(name='AccountIdentityInfo'),
  requestId?: string(name='RequestId'),
}

model GetAccountIdentityInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccountIdentityInfoResponseBody(name='body'),
}

async function getAccountIdentityInfoWithOptions(tmpReq: GetAccountIdentityInfoRequest, runtime: Util.RuntimeOptions): GetAccountIdentityInfoResponse {
  Util.validateModel(tmpReq);
  var request = new GetAccountIdentityInfoShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.properties)) {
    request.propertiesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.properties, 'Properties', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.accountId)) {
    query['AccountId'] = request.accountId;
  }
  if (!Util.isUnset(request.biz)) {
    query['Biz'] = request.biz;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.propertiesShrink)) {
    body['Properties'] = request.propertiesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetAccountIdentityInfo',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAccountIdentityInfo(request: GetAccountIdentityInfoRequest): GetAccountIdentityInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountIdentityInfoWithOptions(request, runtime);
}

model GetCallRelationRequest {
  appName?: string(name='AppName'),
  appSource?: string(name='AppSource'),
}

model GetCallRelationResponseBody = {
  code?: int32(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    callAppList?: string(name='CallAppList'),
    calledAppList?: string(name='CalledAppList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetCallRelationResponse = {
  headers: map[string]string(name='headers'),
  body: GetCallRelationResponseBody(name='body'),
}

async function getCallRelationWithOptions(request: GetCallRelationRequest, runtime: Util.RuntimeOptions): GetCallRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.appSource)) {
    query['AppSource'] = request.appSource;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCallRelation',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCallRelation(request: GetCallRelationRequest): GetCallRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCallRelationWithOptions(request, runtime);
}

model GetVerifyResultRequest {
  accountId?: string(name='AccountId'),
  biz?: string(name='Biz'),
  properties?: map[string]any(name='Properties'),
  source?: string(name='Source'),
  ticketId?: string(name='TicketId'),
}

model GetVerifyResultShrinkRequest {
  accountId?: string(name='AccountId'),
  biz?: string(name='Biz'),
  propertiesShrink?: string(name='Properties'),
  source?: string(name='Source'),
  ticketId?: string(name='TicketId'),
}

model GetVerifyResultResponseBody = {
  requestId?: string(name='RequestId'),
  verifyResult?: {
    auditInfo?: {
      authorityComparableCode?: int32(name='AuthorityComparableCode'),
      cardAuthorityComparePass?: boolean(name='CardAuthorityComparePass'),
      cardCopyCheckPass?: boolean(name='CardCopyCheckPass'),
      externalFailReason?: string(name='ExternalFailReason'),
      faceAuthorityComparePass?: boolean(name='FaceAuthorityComparePass'),
      faceCardComparePass?: boolean(name='FaceCardComparePass'),
      faceCopyCheckPass?: boolean(name='FaceCopyCheckPass'),
      faceExpressionCheckPass?: boolean(name='FaceExpressionCheckPass'),
      idCardOcrCheckPass?: boolean(name='IdCardOcrCheckPass'),
      realNameCheckPass?: boolean(name='RealNameCheckPass'),
    }(name='AuditInfo'),
    cardInfo?: {
      backUrl?: string(name='BackUrl'),
      beginDate?: string(name='BeginDate'),
      cardNumber?: string(name='CardNumber'),
      endDate?: string(name='EndDate'),
      frontUrl?: string(name='FrontUrl'),
      name?: string(name='Name'),
    }(name='CardInfo'),
    faceInfo?: {
      biometricVideoUrl?: string(name='BiometricVideoUrl'),
      faceImageUrl?: string(name='FaceImageUrl'),
      originalFaceUrl?: string(name='OriginalFaceUrl'),
    }(name='FaceInfo'),
    message?: string(name='Message'),
    status?: int32(name='Status'),
    subStatus?: int32(name='SubStatus'),
  }(name='VerifyResult'),
}

model GetVerifyResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetVerifyResultResponseBody(name='body'),
}

async function getVerifyResultWithOptions(tmpReq: GetVerifyResultRequest, runtime: Util.RuntimeOptions): GetVerifyResultResponse {
  Util.validateModel(tmpReq);
  var request = new GetVerifyResultShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.properties)) {
    request.propertiesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.properties, 'Properties', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.accountId)) {
    query['AccountId'] = request.accountId;
  }
  if (!Util.isUnset(request.biz)) {
    query['Biz'] = request.biz;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.ticketId)) {
    query['TicketId'] = request.ticketId;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.propertiesShrink)) {
    body['Properties'] = request.propertiesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetVerifyResult',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVerifyResult(request: GetVerifyResultRequest): GetVerifyResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVerifyResultWithOptions(request, runtime);
}

model GetVerifyTokenRequest {
  accountId?: string(name='AccountId'),
  biz?: string(name='Biz'),
  cardNumber?: string(name='CardNumber'),
  cardType?: string(name='CardType'),
  clientInfo?: string(name='ClientInfo'),
  name?: string(name='Name'),
  privacyPolicyId?: long(name='PrivacyPolicyId'),
  source?: string(name='Source'),
  ticketId?: string(name='TicketId'),
}

model GetVerifyTokenResponseBody = {
  requestId?: string(name='RequestId'),
  verifyToken?: {
    expireTime?: long(name='ExpireTime'),
    token?: string(name='Token'),
    url?: string(name='Url'),
  }(name='VerifyToken'),
}

model GetVerifyTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GetVerifyTokenResponseBody(name='body'),
}

async function getVerifyTokenWithOptions(request: GetVerifyTokenRequest, runtime: Util.RuntimeOptions): GetVerifyTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountId)) {
    query['AccountId'] = request.accountId;
  }
  if (!Util.isUnset(request.biz)) {
    query['Biz'] = request.biz;
  }
  if (!Util.isUnset(request.cardNumber)) {
    query['CardNumber'] = request.cardNumber;
  }
  if (!Util.isUnset(request.cardType)) {
    query['CardType'] = request.cardType;
  }
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.privacyPolicyId)) {
    query['PrivacyPolicyId'] = request.privacyPolicyId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.ticketId)) {
    query['TicketId'] = request.ticketId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVerifyToken',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVerifyToken(request: GetVerifyTokenRequest): GetVerifyTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVerifyTokenWithOptions(request, runtime);
}

model GetWatermarkAppInfoRequest {
  body?: string(name='Body'),
  nonce?: string(name='Nonce'),
  sign?: string(name='Sign'),
  time?: string(name='Time'),
}

model GetWatermarkAppInfoResponseBody = {
  domain?: string(name='Domain'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetWatermarkAppInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetWatermarkAppInfoResponseBody(name='body'),
}

async function getWatermarkAppInfoWithOptions(request: GetWatermarkAppInfoRequest, runtime: Util.RuntimeOptions): GetWatermarkAppInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.body)) {
    query['Body'] = request.body;
  }
  if (!Util.isUnset(request.nonce)) {
    query['Nonce'] = request.nonce;
  }
  if (!Util.isUnset(request.sign)) {
    query['Sign'] = request.sign;
  }
  if (!Util.isUnset(request.time)) {
    query['Time'] = request.time;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWatermarkAppInfo',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWatermarkAppInfo(request: GetWatermarkAppInfoRequest): GetWatermarkAppInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWatermarkAppInfoWithOptions(request, runtime);
}

model IdentifyAccountModifyRiskRequest {
  accountType?: int32(name='AccountType'),
  deviceEnvironment?: map[string]any(name='DeviceEnvironment'),
  entranceCode?: string(name='EntranceCode'),
  extraData?: map[string]any(name='ExtraData'),
  operateSubType?: string(name='OperateSubType'),
  operateTime?: long(name='OperateTime'),
  siteCode?: string(name='SiteCode'),
  userId?: long(name='UserId'),
  userInfo?: map[string]any(name='UserInfo'),
  userInput?: string(name='UserInput'),
}

model IdentifyAccountModifyRiskShrinkRequest {
  accountType?: int32(name='AccountType'),
  deviceEnvironmentShrink?: string(name='DeviceEnvironment'),
  entranceCode?: string(name='EntranceCode'),
  extraDataShrink?: string(name='ExtraData'),
  operateSubType?: string(name='OperateSubType'),
  operateTime?: long(name='OperateTime'),
  siteCode?: string(name='SiteCode'),
  userId?: long(name='UserId'),
  userInfoShrink?: string(name='UserInfo'),
  userInput?: string(name='UserInput'),
}

model IdentifyAccountModifyRiskResponseBody = {
  code?: int32(name='Code'),
  data?: {
    asToken?: string(name='AsToken'),
    suggestion?: string(name='Suggestion'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model IdentifyAccountModifyRiskResponse = {
  headers: map[string]string(name='headers'),
  body: IdentifyAccountModifyRiskResponseBody(name='body'),
}

async function identifyAccountModifyRiskWithOptions(tmpReq: IdentifyAccountModifyRiskRequest, runtime: Util.RuntimeOptions): IdentifyAccountModifyRiskResponse {
  Util.validateModel(tmpReq);
  var request = new IdentifyAccountModifyRiskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.deviceEnvironment)) {
    request.deviceEnvironmentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deviceEnvironment, 'DeviceEnvironment', 'json');
  }
  if (!Util.isUnset(tmpReq.extraData)) {
    request.extraDataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extraData, 'ExtraData', 'json');
  }
  if (!Util.isUnset(tmpReq.userInfo)) {
    request.userInfoShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userInfo, 'UserInfo', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.accountType)) {
    query['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.entranceCode)) {
    query['EntranceCode'] = request.entranceCode;
  }
  if (!Util.isUnset(request.operateSubType)) {
    query['OperateSubType'] = request.operateSubType;
  }
  if (!Util.isUnset(request.operateTime)) {
    query['OperateTime'] = request.operateTime;
  }
  if (!Util.isUnset(request.siteCode)) {
    query['SiteCode'] = request.siteCode;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userInput)) {
    query['UserInput'] = request.userInput;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.deviceEnvironmentShrink)) {
    body['DeviceEnvironment'] = request.deviceEnvironmentShrink;
  }
  if (!Util.isUnset(request.extraDataShrink)) {
    body['ExtraData'] = request.extraDataShrink;
  }
  if (!Util.isUnset(request.userInfoShrink)) {
    body['UserInfo'] = request.userInfoShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'IdentifyAccountModifyRisk',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function identifyAccountModifyRisk(request: IdentifyAccountModifyRiskRequest): IdentifyAccountModifyRiskResponse {
  var runtime = new Util.RuntimeOptions{};
  return identifyAccountModifyRiskWithOptions(request, runtime);
}

model IdentifyLoginRiskRequest {
  accountType?: int32(name='AccountType'),
  deviceEnvironment?: map[string]any(name='DeviceEnvironment'),
  entranceCode?: string(name='EntranceCode'),
  extraData?: map[string]any(name='ExtraData'),
  operateSubType?: string(name='OperateSubType'),
  operateTime?: long(name='OperateTime'),
  siteCode?: string(name='SiteCode'),
  socialNetworkServiceType?: string(name='SocialNetworkServiceType'),
  userId?: long(name='UserId'),
  userInfo?: map[string]any(name='UserInfo'),
  userInput?: string(name='UserInput'),
}

model IdentifyLoginRiskShrinkRequest {
  accountType?: int32(name='AccountType'),
  deviceEnvironmentShrink?: string(name='DeviceEnvironment'),
  entranceCode?: string(name='EntranceCode'),
  extraDataShrink?: string(name='ExtraData'),
  operateSubType?: string(name='OperateSubType'),
  operateTime?: long(name='OperateTime'),
  siteCode?: string(name='SiteCode'),
  socialNetworkServiceType?: string(name='SocialNetworkServiceType'),
  userId?: long(name='UserId'),
  userInfoShrink?: string(name='UserInfo'),
  userInput?: string(name='UserInput'),
}

model IdentifyLoginRiskResponseBody = {
  code?: int32(name='Code'),
  data?: {
    asToken?: string(name='AsToken'),
    suggestion?: string(name='Suggestion'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model IdentifyLoginRiskResponse = {
  headers: map[string]string(name='headers'),
  body: IdentifyLoginRiskResponseBody(name='body'),
}

async function identifyLoginRiskWithOptions(tmpReq: IdentifyLoginRiskRequest, runtime: Util.RuntimeOptions): IdentifyLoginRiskResponse {
  Util.validateModel(tmpReq);
  var request = new IdentifyLoginRiskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.deviceEnvironment)) {
    request.deviceEnvironmentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deviceEnvironment, 'DeviceEnvironment', 'json');
  }
  if (!Util.isUnset(tmpReq.extraData)) {
    request.extraDataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extraData, 'ExtraData', 'json');
  }
  if (!Util.isUnset(tmpReq.userInfo)) {
    request.userInfoShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userInfo, 'UserInfo', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.accountType)) {
    query['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.entranceCode)) {
    query['EntranceCode'] = request.entranceCode;
  }
  if (!Util.isUnset(request.operateSubType)) {
    query['OperateSubType'] = request.operateSubType;
  }
  if (!Util.isUnset(request.operateTime)) {
    query['OperateTime'] = request.operateTime;
  }
  if (!Util.isUnset(request.siteCode)) {
    query['SiteCode'] = request.siteCode;
  }
  if (!Util.isUnset(request.socialNetworkServiceType)) {
    query['SocialNetworkServiceType'] = request.socialNetworkServiceType;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userInput)) {
    query['UserInput'] = request.userInput;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.deviceEnvironmentShrink)) {
    body['DeviceEnvironment'] = request.deviceEnvironmentShrink;
  }
  if (!Util.isUnset(request.extraDataShrink)) {
    body['ExtraData'] = request.extraDataShrink;
  }
  if (!Util.isUnset(request.userInfoShrink)) {
    body['UserInfo'] = request.userInfoShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'IdentifyLoginRisk',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function identifyLoginRisk(request: IdentifyLoginRiskRequest): IdentifyLoginRiskResponse {
  var runtime = new Util.RuntimeOptions{};
  return identifyLoginRiskWithOptions(request, runtime);
}

model IdentifyRegisterRiskRequest {
  accountType?: int32(name='AccountType'),
  deviceEnvironment?: map[string]any(name='DeviceEnvironment'),
  entranceCode?: string(name='EntranceCode'),
  extraData?: map[string]any(name='ExtraData'),
  operateSubType?: string(name='OperateSubType'),
  operateTime?: long(name='OperateTime'),
  siteCode?: string(name='SiteCode'),
  userId?: long(name='UserId'),
  userInfo?: map[string]any(name='UserInfo'),
  userInput?: string(name='UserInput'),
}

model IdentifyRegisterRiskShrinkRequest {
  accountType?: int32(name='AccountType'),
  deviceEnvironmentShrink?: string(name='DeviceEnvironment'),
  entranceCode?: string(name='EntranceCode'),
  extraDataShrink?: string(name='ExtraData'),
  operateSubType?: string(name='OperateSubType'),
  operateTime?: long(name='OperateTime'),
  siteCode?: string(name='SiteCode'),
  userId?: long(name='UserId'),
  userInfoShrink?: string(name='UserInfo'),
  userInput?: string(name='UserInput'),
}

model IdentifyRegisterRiskResponseBody = {
  code?: int32(name='Code'),
  data?: {
    asToken?: string(name='AsToken'),
    suggestion?: string(name='Suggestion'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model IdentifyRegisterRiskResponse = {
  headers: map[string]string(name='headers'),
  body: IdentifyRegisterRiskResponseBody(name='body'),
}

async function identifyRegisterRiskWithOptions(tmpReq: IdentifyRegisterRiskRequest, runtime: Util.RuntimeOptions): IdentifyRegisterRiskResponse {
  Util.validateModel(tmpReq);
  var request = new IdentifyRegisterRiskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.deviceEnvironment)) {
    request.deviceEnvironmentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deviceEnvironment, 'DeviceEnvironment', 'json');
  }
  if (!Util.isUnset(tmpReq.extraData)) {
    request.extraDataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extraData, 'ExtraData', 'json');
  }
  if (!Util.isUnset(tmpReq.userInfo)) {
    request.userInfoShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userInfo, 'UserInfo', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.accountType)) {
    query['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.entranceCode)) {
    query['EntranceCode'] = request.entranceCode;
  }
  if (!Util.isUnset(request.operateSubType)) {
    query['OperateSubType'] = request.operateSubType;
  }
  if (!Util.isUnset(request.operateTime)) {
    query['OperateTime'] = request.operateTime;
  }
  if (!Util.isUnset(request.siteCode)) {
    query['SiteCode'] = request.siteCode;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userInput)) {
    query['UserInput'] = request.userInput;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.deviceEnvironmentShrink)) {
    body['DeviceEnvironment'] = request.deviceEnvironmentShrink;
  }
  if (!Util.isUnset(request.extraDataShrink)) {
    body['ExtraData'] = request.extraDataShrink;
  }
  if (!Util.isUnset(request.userInfoShrink)) {
    body['UserInfo'] = request.userInfoShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'IdentifyRegisterRisk',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function identifyRegisterRisk(request: IdentifyRegisterRiskRequest): IdentifyRegisterRiskResponse {
  var runtime = new Util.RuntimeOptions{};
  return identifyRegisterRiskWithOptions(request, runtime);
}

model ListAstralnetAppUrlsRequest {
  appName?: string(name='AppName'),
  appSource?: string(name='AppSource'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListAstralnetAppUrlsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    item?: [ 
      {
        appName?: string(name='AppName'),
        class?: string(name='Class'),
        contentType?: string(name='ContentType'),
        filePath?: string(name='FilePath'),
        host?: string(name='Host'),
        method?: string(name='Method'),
        methodProfile?: string(name='MethodProfile'),
        parameters?: string(name='Parameters'),
        path?: string(name='Path'),
        responseBody?: string(name='ResponseBody'),
        urlPath?: string(name='UrlPath'),
        urlSuffixes?: string(name='UrlSuffixes'),
      }
    ](name='Item'),
    total?: int32(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAstralnetAppUrlsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAstralnetAppUrlsResponseBody(name='body'),
}

async function listAstralnetAppUrlsWithOptions(request: ListAstralnetAppUrlsRequest, runtime: Util.RuntimeOptions): ListAstralnetAppUrlsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.appSource)) {
    query['AppSource'] = request.appSource;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAstralnetAppUrls',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAstralnetAppUrls(request: ListAstralnetAppUrlsRequest): ListAstralnetAppUrlsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAstralnetAppUrlsWithOptions(request, runtime);
}

model PrecheckUsabilityRequest {
  accountId?: string(name='AccountId'),
  appKey?: string(name='AppKey'),
  biz?: string(name='Biz'),
  cardNumber?: string(name='CardNumber'),
  cardType?: string(name='CardType'),
  clientInfo?: string(name='ClientInfo'),
  name?: string(name='Name'),
  source?: string(name='Source'),
}

model PrecheckUsabilityResponseBody = {
  checkResult?: {
    authorityUsableCode?: int32(name='AuthorityUsableCode'),
    hitRisk?: boolean(name='HitRisk'),
    unavailableStatus?: boolean(name='UnavailableStatus'),
    usableClient?: boolean(name='UsableClient'),
  }(name='CheckResult'),
  requestId?: string(name='RequestId'),
}

model PrecheckUsabilityResponse = {
  headers: map[string]string(name='headers'),
  body: PrecheckUsabilityResponseBody(name='body'),
}

async function precheckUsabilityWithOptions(request: PrecheckUsabilityRequest, runtime: Util.RuntimeOptions): PrecheckUsabilityResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PrecheckUsability',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function precheckUsability(request: PrecheckUsabilityRequest): PrecheckUsabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return precheckUsabilityWithOptions(request, runtime);
}

model QueryJobStatusRequest {
  data?: map[string]any(name='Data'),
}

model QueryJobStatusShrinkRequest {
  dataShrink?: string(name='Data'),
}

model QueryJobStatusResponseBody = {
  code?: int32(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  status?: int32(name='Status'),
}

model QueryJobStatusResponse = {
  headers: map[string]string(name='headers'),
  body: QueryJobStatusResponseBody(name='body'),
}

async function queryJobStatusWithOptions(tmpReq: QueryJobStatusRequest, runtime: Util.RuntimeOptions): QueryJobStatusResponse {
  Util.validateModel(tmpReq);
  var request = new QueryJobStatusShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.data)) {
    request.dataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.data, 'Data', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.dataShrink)) {
    body['Data'] = request.dataShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryJobStatus',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryJobStatus(request: QueryJobStatusRequest): QueryJobStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryJobStatusWithOptions(request, runtime);
}

model ScanMobileAppRequest {
  data?: map[string]any(name='Data'),
}

model ScanMobileAppShrinkRequest {
  dataShrink?: string(name='Data'),
}

model ScanMobileAppResponseBody = {
  code?: int32(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  status?: int32(name='Status'),
}

model ScanMobileAppResponse = {
  headers: map[string]string(name='headers'),
  body: ScanMobileAppResponseBody(name='body'),
}

async function scanMobileAppWithOptions(tmpReq: ScanMobileAppRequest, runtime: Util.RuntimeOptions): ScanMobileAppResponse {
  Util.validateModel(tmpReq);
  var request = new ScanMobileAppShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.data)) {
    request.dataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.data, 'Data', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.dataShrink)) {
    body['Data'] = request.dataShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ScanMobileApp',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function scanMobileApp(request: ScanMobileAppRequest): ScanMobileAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return scanMobileAppWithOptions(request, runtime);
}

model ScanOpenSourceComplianceRequest {
  data?: map[string]any(name='Data'),
}

model ScanOpenSourceComplianceShrinkRequest {
  dataShrink?: string(name='Data'),
}

model ScanOpenSourceComplianceResponseBody = {
  code?: int32(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  status?: int32(name='Status'),
}

model ScanOpenSourceComplianceResponse = {
  headers: map[string]string(name='headers'),
  body: ScanOpenSourceComplianceResponseBody(name='body'),
}

async function scanOpenSourceComplianceWithOptions(tmpReq: ScanOpenSourceComplianceRequest, runtime: Util.RuntimeOptions): ScanOpenSourceComplianceResponse {
  Util.validateModel(tmpReq);
  var request = new ScanOpenSourceComplianceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.data)) {
    request.dataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.data, 'Data', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.dataShrink)) {
    body['Data'] = request.dataShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ScanOpenSourceCompliance',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function scanOpenSourceCompliance(request: ScanOpenSourceComplianceRequest): ScanOpenSourceComplianceResponse {
  var runtime = new Util.RuntimeOptions{};
  return scanOpenSourceComplianceWithOptions(request, runtime);
}

model SendAccountModifyResultRequest {
  accountType?: int32(name='AccountType'),
  actionSource?: string(name='ActionSource'),
  asToken?: string(name='AsToken'),
  deviceEnvironment?: map[string]any(name='DeviceEnvironment'),
  modifyFailureReason?: string(name='ModifyFailureReason'),
  modifyResult?: boolean(name='ModifyResult'),
  modifyType?: string(name='ModifyType'),
  newContent?: string(name='NewContent'),
  oldContent?: string(name='OldContent'),
  operateSubType?: string(name='OperateSubType'),
  operateTime?: long(name='OperateTime'),
  operateType?: string(name='OperateType'),
  siteCode?: string(name='SiteCode'),
  userId?: string(name='UserId'),
  userInfo?: map[string]any(name='UserInfo'),
}

model SendAccountModifyResultShrinkRequest {
  accountType?: int32(name='AccountType'),
  actionSource?: string(name='ActionSource'),
  asToken?: string(name='AsToken'),
  deviceEnvironmentShrink?: string(name='DeviceEnvironment'),
  modifyFailureReason?: string(name='ModifyFailureReason'),
  modifyResult?: boolean(name='ModifyResult'),
  modifyType?: string(name='ModifyType'),
  newContent?: string(name='NewContent'),
  oldContent?: string(name='OldContent'),
  operateSubType?: string(name='OperateSubType'),
  operateTime?: long(name='OperateTime'),
  operateType?: string(name='OperateType'),
  siteCode?: string(name='SiteCode'),
  userId?: string(name='UserId'),
  userInfoShrink?: string(name='UserInfo'),
}

model SendAccountModifyResultResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SendAccountModifyResultResponse = {
  headers: map[string]string(name='headers'),
  body: SendAccountModifyResultResponseBody(name='body'),
}

async function sendAccountModifyResultWithOptions(tmpReq: SendAccountModifyResultRequest, runtime: Util.RuntimeOptions): SendAccountModifyResultResponse {
  Util.validateModel(tmpReq);
  var request = new SendAccountModifyResultShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.deviceEnvironment)) {
    request.deviceEnvironmentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deviceEnvironment, 'DeviceEnvironment', 'json');
  }
  if (!Util.isUnset(tmpReq.userInfo)) {
    request.userInfoShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userInfo, 'UserInfo', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.accountType)) {
    query['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.actionSource)) {
    query['ActionSource'] = request.actionSource;
  }
  if (!Util.isUnset(request.asToken)) {
    query['AsToken'] = request.asToken;
  }
  if (!Util.isUnset(request.modifyFailureReason)) {
    query['ModifyFailureReason'] = request.modifyFailureReason;
  }
  if (!Util.isUnset(request.modifyResult)) {
    query['ModifyResult'] = request.modifyResult;
  }
  if (!Util.isUnset(request.modifyType)) {
    query['ModifyType'] = request.modifyType;
  }
  if (!Util.isUnset(request.newContent)) {
    query['NewContent'] = request.newContent;
  }
  if (!Util.isUnset(request.oldContent)) {
    query['OldContent'] = request.oldContent;
  }
  if (!Util.isUnset(request.operateSubType)) {
    query['OperateSubType'] = request.operateSubType;
  }
  if (!Util.isUnset(request.operateTime)) {
    query['OperateTime'] = request.operateTime;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.siteCode)) {
    query['SiteCode'] = request.siteCode;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.deviceEnvironmentShrink)) {
    body['DeviceEnvironment'] = request.deviceEnvironmentShrink;
  }
  if (!Util.isUnset(request.userInfoShrink)) {
    body['UserInfo'] = request.userInfoShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SendAccountModifyResult',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendAccountModifyResult(request: SendAccountModifyResultRequest): SendAccountModifyResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendAccountModifyResultWithOptions(request, runtime);
}

model SendIdentityValidateResultRequest {
  accountType?: int32(name='AccountType'),
  actionSource?: string(name='ActionSource'),
  asToken?: string(name='AsToken'),
  deviceEnvironment?: map[string]any(name='DeviceEnvironment'),
  entranceCode?: string(name='EntranceCode'),
  extraData?: map[string]any(name='ExtraData'),
  operateSubType?: string(name='OperateSubType'),
  operateTime?: long(name='OperateTime'),
  operateType?: string(name='OperateType'),
  siteCode?: string(name='SiteCode'),
  userId?: string(name='UserId'),
  userInfo?: map[string]any(name='UserInfo'),
  userInput?: string(name='UserInput'),
  validateFailureReason?: string(name='ValidateFailureReason'),
  validateResult?: boolean(name='ValidateResult'),
  validatorTypes?: map[string]any(name='ValidatorTypes'),
}

model SendIdentityValidateResultShrinkRequest {
  accountType?: int32(name='AccountType'),
  actionSource?: string(name='ActionSource'),
  asToken?: string(name='AsToken'),
  deviceEnvironmentShrink?: string(name='DeviceEnvironment'),
  entranceCode?: string(name='EntranceCode'),
  extraDataShrink?: string(name='ExtraData'),
  operateSubType?: string(name='OperateSubType'),
  operateTime?: long(name='OperateTime'),
  operateType?: string(name='OperateType'),
  siteCode?: string(name='SiteCode'),
  userId?: string(name='UserId'),
  userInfoShrink?: string(name='UserInfo'),
  userInput?: string(name='UserInput'),
  validateFailureReason?: string(name='ValidateFailureReason'),
  validateResult?: boolean(name='ValidateResult'),
  validatorTypesShrink?: string(name='ValidatorTypes'),
}

model SendIdentityValidateResultResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SendIdentityValidateResultResponse = {
  headers: map[string]string(name='headers'),
  body: SendIdentityValidateResultResponseBody(name='body'),
}

async function sendIdentityValidateResultWithOptions(tmpReq: SendIdentityValidateResultRequest, runtime: Util.RuntimeOptions): SendIdentityValidateResultResponse {
  Util.validateModel(tmpReq);
  var request = new SendIdentityValidateResultShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.deviceEnvironment)) {
    request.deviceEnvironmentShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deviceEnvironment, 'DeviceEnvironment', 'json');
  }
  if (!Util.isUnset(tmpReq.extraData)) {
    request.extraDataShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.extraData, 'ExtraData', 'json');
  }
  if (!Util.isUnset(tmpReq.userInfo)) {
    request.userInfoShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userInfo, 'UserInfo', 'json');
  }
  if (!Util.isUnset(tmpReq.validatorTypes)) {
    request.validatorTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.validatorTypes, 'ValidatorTypes', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.accountType)) {
    query['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.actionSource)) {
    query['ActionSource'] = request.actionSource;
  }
  if (!Util.isUnset(request.asToken)) {
    query['AsToken'] = request.asToken;
  }
  if (!Util.isUnset(request.entranceCode)) {
    query['EntranceCode'] = request.entranceCode;
  }
  if (!Util.isUnset(request.operateSubType)) {
    query['OperateSubType'] = request.operateSubType;
  }
  if (!Util.isUnset(request.operateTime)) {
    query['OperateTime'] = request.operateTime;
  }
  if (!Util.isUnset(request.operateType)) {
    query['OperateType'] = request.operateType;
  }
  if (!Util.isUnset(request.siteCode)) {
    query['SiteCode'] = request.siteCode;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userInput)) {
    query['UserInput'] = request.userInput;
  }
  if (!Util.isUnset(request.validateFailureReason)) {
    query['ValidateFailureReason'] = request.validateFailureReason;
  }
  if (!Util.isUnset(request.validateResult)) {
    query['ValidateResult'] = request.validateResult;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.deviceEnvironmentShrink)) {
    body['DeviceEnvironment'] = request.deviceEnvironmentShrink;
  }
  if (!Util.isUnset(request.extraDataShrink)) {
    body['ExtraData'] = request.extraDataShrink;
  }
  if (!Util.isUnset(request.userInfoShrink)) {
    body['UserInfo'] = request.userInfoShrink;
  }
  if (!Util.isUnset(request.validatorTypesShrink)) {
    body['ValidatorTypes'] = request.validatorTypesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SendIdentityValidateResult',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendIdentityValidateResult(request: SendIdentityValidateResultRequest): SendIdentityValidateResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendIdentityValidateResultWithOptions(request, runtime);
}

model UnbindAccountIdentityInfoRequest {
  accountId?: string(name='AccountId'),
  biz?: string(name='Biz'),
  source?: string(name='Source'),
}

model UnbindAccountIdentityInfoResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnbindAccountIdentityInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindAccountIdentityInfoResponseBody(name='body'),
}

async function unbindAccountIdentityInfoWithOptions(request: UnbindAccountIdentityInfoRequest, runtime: Util.RuntimeOptions): UnbindAccountIdentityInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountId)) {
    query['AccountId'] = request.accountId;
  }
  if (!Util.isUnset(request.biz)) {
    query['Biz'] = request.biz;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindAccountIdentityInfo',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindAccountIdentityInfo(request: UnbindAccountIdentityInfoRequest): UnbindAccountIdentityInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindAccountIdentityInfoWithOptions(request, runtime);
}

model UploadWatermarkLogRequest {
  body?: string(name='Body'),
  data?: string(name='Data'),
  nonce?: string(name='Nonce'),
  sign?: string(name='Sign'),
  time?: string(name='Time'),
}

model UploadWatermarkLogResponseBody = {
  domain?: string(name='Domain'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UploadWatermarkLogResponse = {
  headers: map[string]string(name='headers'),
  body: UploadWatermarkLogResponseBody(name='body'),
}

async function uploadWatermarkLogWithOptions(request: UploadWatermarkLogRequest, runtime: Util.RuntimeOptions): UploadWatermarkLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.body)) {
    query['Body'] = request.body;
  }
  if (!Util.isUnset(request.data)) {
    query['Data'] = request.data;
  }
  if (!Util.isUnset(request.nonce)) {
    query['Nonce'] = request.nonce;
  }
  if (!Util.isUnset(request.sign)) {
    query['Sign'] = request.sign;
  }
  if (!Util.isUnset(request.time)) {
    query['Time'] = request.time;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadWatermarkLog',
    version = '2020-01-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadWatermarkLog(request: UploadWatermarkLogRequest): UploadWatermarkLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadWatermarkLogWithOptions(request, runtime);
}

