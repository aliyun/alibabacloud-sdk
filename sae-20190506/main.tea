/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('sae', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AbortAndRollbackChangeOrderRequest {
  changeOrderId?: string(name='ChangeOrderId'),
}

model AbortAndRollbackChangeOrderResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model AbortAndRollbackChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AbortAndRollbackChangeOrderResponseBody(name='body'),
}

async function abortAndRollbackChangeOrder(request: AbortAndRollbackChangeOrderRequest): AbortAndRollbackChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return abortAndRollbackChangeOrderWithOptions(request, headers, runtime);
}

async function abortAndRollbackChangeOrderWithOptions(request: AbortAndRollbackChangeOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AbortAndRollbackChangeOrderResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.changeOrderId)) {
    query['ChangeOrderId'] = request.changeOrderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AbortAndRollbackChangeOrder',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/changeorder/AbortAndRollbackChangeOrder`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AbortChangeOrderRequest {
  changeOrderId?: string(name='ChangeOrderId'),
}

model AbortChangeOrderResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model AbortChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AbortChangeOrderResponseBody(name='body'),
}

async function abortChangeOrder(request: AbortChangeOrderRequest): AbortChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return abortChangeOrderWithOptions(request, headers, runtime);
}

async function abortChangeOrderWithOptions(request: AbortChangeOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AbortChangeOrderResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.changeOrderId)) {
    query['ChangeOrderId'] = request.changeOrderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AbortChangeOrder',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/changeorder/AbortChangeOrder`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchStartApplicationsRequest {
  appIds?: string(name='AppIds'),
  namespaceId?: string(name='NamespaceId'),
}

model BatchStartApplicationsResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model BatchStartApplicationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchStartApplicationsResponseBody(name='body'),
}

async function batchStartApplications(request: BatchStartApplicationsRequest): BatchStartApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchStartApplicationsWithOptions(request, headers, runtime);
}

async function batchStartApplicationsWithOptions(request: BatchStartApplicationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchStartApplicationsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appIds)) {
    query['AppIds'] = request.appIds;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchStartApplications',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/batchStartApplications`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchStopApplicationsRequest {
  appIds?: string(name='AppIds'),
  namespaceId?: string(name='NamespaceId'),
}

model BatchStopApplicationsResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model BatchStopApplicationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchStopApplicationsResponseBody(name='body'),
}

async function batchStopApplications(request: BatchStopApplicationsRequest): BatchStopApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchStopApplicationsWithOptions(request, headers, runtime);
}

async function batchStopApplicationsWithOptions(request: BatchStopApplicationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchStopApplicationsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appIds)) {
    query['AppIds'] = request.appIds;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchStopApplications',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/batchStopApplications`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BindSlbRequest {
  appId?: string(name='AppId'),
  internet?: string(name='Internet'),
  internetSlbId?: string(name='InternetSlbId'),
  intranet?: string(name='Intranet'),
  intranetSlbId?: string(name='IntranetSlbId'),
}

model BindSlbResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model BindSlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindSlbResponseBody(name='body'),
}

async function bindSlb(request: BindSlbRequest): BindSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return bindSlbWithOptions(request, headers, runtime);
}

async function bindSlbWithOptions(request: BindSlbRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BindSlbResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.internet)) {
    query['Internet'] = request.internet;
  }
  if (!Util.isUnset(request.internetSlbId)) {
    query['InternetSlbId'] = request.internetSlbId;
  }
  if (!Util.isUnset(request.intranet)) {
    query['Intranet'] = request.intranet;
  }
  if (!Util.isUnset(request.intranetSlbId)) {
    query['IntranetSlbId'] = request.intranetSlbId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindSlb',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/slb`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ConfirmPipelineBatchRequest {
  confirm?: boolean(name='Confirm'),
  pipelineId?: string(name='PipelineId'),
}

model ConfirmPipelineBatchResponseBody = {
  code?: string(name='Code'),
  data?: {
    pipelineId?: string(name='PipelineId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ConfirmPipelineBatchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfirmPipelineBatchResponseBody(name='body'),
}

async function confirmPipelineBatch(request: ConfirmPipelineBatchRequest): ConfirmPipelineBatchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return confirmPipelineBatchWithOptions(request, headers, runtime);
}

async function confirmPipelineBatchWithOptions(request: ConfirmPipelineBatchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ConfirmPipelineBatchResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.confirm)) {
    query['Confirm'] = request.confirm;
  }
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmPipelineBatch',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/changeorder/ConfirmPipelineBatch`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateApplicationRequest {
  acrAssumeRoleArn?: string(name='AcrAssumeRoleArn'),
  acrInstanceId?: string(name='AcrInstanceId'),
  appDescription?: string(name='AppDescription'),
  appName?: string(name='AppName'),
  associateEip?: boolean(name='AssociateEip'),
  autoConfig?: boolean(name='AutoConfig'),
  command?: string(name='Command'),
  commandArgs?: string(name='CommandArgs'),
  configMapMountDesc?: string(name='ConfigMapMountDesc'),
  cpu?: int32(name='Cpu'),
  customHostAlias?: string(name='CustomHostAlias'),
  deploy?: boolean(name='Deploy'),
  edasContainerVersion?: string(name='EdasContainerVersion'),
  envs?: string(name='Envs'),
  imagePullSecrets?: string(name='ImagePullSecrets'),
  imageUrl?: string(name='ImageUrl'),
  jarStartArgs?: string(name='JarStartArgs'),
  jarStartOptions?: string(name='JarStartOptions'),
  jdk?: string(name='Jdk'),
  kafkaConfigs?: string(name='KafkaConfigs'),
  liveness?: string(name='Liveness'),
  memory?: int32(name='Memory'),
  microRegistration?: string(name='MicroRegistration'),
  mountDesc?: string(name='MountDesc'),
  mountHost?: string(name='MountHost'),
  namespaceId?: string(name='NamespaceId'),
  nasConfigs?: string(name='NasConfigs'),
  nasId?: string(name='NasId'),
  ossAkId?: string(name='OssAkId'),
  ossAkSecret?: string(name='OssAkSecret'),
  ossMountDescs?: string(name='OssMountDescs'),
  packageType?: string(name='PackageType'),
  packageUrl?: string(name='PackageUrl'),
  packageVersion?: string(name='PackageVersion'),
  phpArmsConfigLocation?: string(name='PhpArmsConfigLocation'),
  phpConfig?: string(name='PhpConfig'),
  phpConfigLocation?: string(name='PhpConfigLocation'),
  postStart?: string(name='PostStart'),
  preStop?: string(name='PreStop'),
  programmingLanguage?: string(name='ProgrammingLanguage'),
  pvtzDiscoverySvc?: string(name='PvtzDiscoverySvc'),
  python?: string(name='Python'),
  pythonModules?: string(name='PythonModules'),
  readiness?: string(name='Readiness'),
  replicas?: int32(name='Replicas'),
  securityGroupId?: string(name='SecurityGroupId'),
  slsConfigs?: string(name='SlsConfigs'),
  terminationGracePeriodSeconds?: int32(name='TerminationGracePeriodSeconds'),
  timezone?: string(name='Timezone'),
  tomcatConfig?: string(name='TomcatConfig'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  warStartOptions?: string(name='WarStartOptions'),
  webContainer?: string(name='WebContainer'),
}

model CreateApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createApplicationWithOptions(request, headers, runtime);
}

async function createApplicationWithOptions(request: CreateApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.acrAssumeRoleArn)) {
    query['AcrAssumeRoleArn'] = request.acrAssumeRoleArn;
  }
  if (!Util.isUnset(request.appDescription)) {
    query['AppDescription'] = request.appDescription;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.autoConfig)) {
    query['AutoConfig'] = request.autoConfig;
  }
  if (!Util.isUnset(request.command)) {
    query['Command'] = request.command;
  }
  if (!Util.isUnset(request.commandArgs)) {
    query['CommandArgs'] = request.commandArgs;
  }
  if (!Util.isUnset(request.cpu)) {
    query['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.customHostAlias)) {
    query['CustomHostAlias'] = request.customHostAlias;
  }
  if (!Util.isUnset(request.deploy)) {
    query['Deploy'] = request.deploy;
  }
  if (!Util.isUnset(request.edasContainerVersion)) {
    query['EdasContainerVersion'] = request.edasContainerVersion;
  }
  if (!Util.isUnset(request.envs)) {
    query['Envs'] = request.envs;
  }
  if (!Util.isUnset(request.imagePullSecrets)) {
    query['ImagePullSecrets'] = request.imagePullSecrets;
  }
  if (!Util.isUnset(request.imageUrl)) {
    query['ImageUrl'] = request.imageUrl;
  }
  if (!Util.isUnset(request.jarStartArgs)) {
    query['JarStartArgs'] = request.jarStartArgs;
  }
  if (!Util.isUnset(request.jarStartOptions)) {
    query['JarStartOptions'] = request.jarStartOptions;
  }
  if (!Util.isUnset(request.jdk)) {
    query['Jdk'] = request.jdk;
  }
  if (!Util.isUnset(request.kafkaConfigs)) {
    query['KafkaConfigs'] = request.kafkaConfigs;
  }
  if (!Util.isUnset(request.liveness)) {
    query['Liveness'] = request.liveness;
  }
  if (!Util.isUnset(request.memory)) {
    query['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.microRegistration)) {
    query['MicroRegistration'] = request.microRegistration;
  }
  if (!Util.isUnset(request.mountDesc)) {
    query['MountDesc'] = request.mountDesc;
  }
  if (!Util.isUnset(request.mountHost)) {
    query['MountHost'] = request.mountHost;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.nasConfigs)) {
    query['NasConfigs'] = request.nasConfigs;
  }
  if (!Util.isUnset(request.nasId)) {
    query['NasId'] = request.nasId;
  }
  if (!Util.isUnset(request.packageType)) {
    query['PackageType'] = request.packageType;
  }
  if (!Util.isUnset(request.packageUrl)) {
    query['PackageUrl'] = request.packageUrl;
  }
  if (!Util.isUnset(request.packageVersion)) {
    query['PackageVersion'] = request.packageVersion;
  }
  if (!Util.isUnset(request.phpArmsConfigLocation)) {
    query['PhpArmsConfigLocation'] = request.phpArmsConfigLocation;
  }
  if (!Util.isUnset(request.phpConfigLocation)) {
    query['PhpConfigLocation'] = request.phpConfigLocation;
  }
  if (!Util.isUnset(request.postStart)) {
    query['PostStart'] = request.postStart;
  }
  if (!Util.isUnset(request.preStop)) {
    query['PreStop'] = request.preStop;
  }
  if (!Util.isUnset(request.programmingLanguage)) {
    query['ProgrammingLanguage'] = request.programmingLanguage;
  }
  if (!Util.isUnset(request.pvtzDiscoverySvc)) {
    query['PvtzDiscoverySvc'] = request.pvtzDiscoverySvc;
  }
  if (!Util.isUnset(request.python)) {
    query['Python'] = request.python;
  }
  if (!Util.isUnset(request.pythonModules)) {
    query['PythonModules'] = request.pythonModules;
  }
  if (!Util.isUnset(request.readiness)) {
    query['Readiness'] = request.readiness;
  }
  if (!Util.isUnset(request.replicas)) {
    query['Replicas'] = request.replicas;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.slsConfigs)) {
    query['SlsConfigs'] = request.slsConfigs;
  }
  if (!Util.isUnset(request.terminationGracePeriodSeconds)) {
    query['TerminationGracePeriodSeconds'] = request.terminationGracePeriodSeconds;
  }
  if (!Util.isUnset(request.timezone)) {
    query['Timezone'] = request.timezone;
  }
  if (!Util.isUnset(request.tomcatConfig)) {
    query['TomcatConfig'] = request.tomcatConfig;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.warStartOptions)) {
    query['WarStartOptions'] = request.warStartOptions;
  }
  if (!Util.isUnset(request.webContainer)) {
    query['WebContainer'] = request.webContainer;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.acrInstanceId)) {
    body['AcrInstanceId'] = request.acrInstanceId;
  }
  if (!Util.isUnset(request.associateEip)) {
    body['AssociateEip'] = request.associateEip;
  }
  if (!Util.isUnset(request.configMapMountDesc)) {
    body['ConfigMapMountDesc'] = request.configMapMountDesc;
  }
  if (!Util.isUnset(request.ossAkId)) {
    body['OssAkId'] = request.ossAkId;
  }
  if (!Util.isUnset(request.ossAkSecret)) {
    body['OssAkSecret'] = request.ossAkSecret;
  }
  if (!Util.isUnset(request.ossMountDescs)) {
    body['OssMountDescs'] = request.ossMountDescs;
  }
  if (!Util.isUnset(request.phpConfig)) {
    body['PhpConfig'] = request.phpConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateApplication',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/createApplication`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateApplicationScalingRuleRequest {
  appId?: string(name='AppId'),
  minReadyInstanceRatio?: int32(name='MinReadyInstanceRatio'),
  minReadyInstances?: int32(name='MinReadyInstances'),
  scalingRuleEnable?: boolean(name='ScalingRuleEnable'),
  scalingRuleMetric?: string(name='ScalingRuleMetric'),
  scalingRuleName?: string(name='ScalingRuleName'),
  scalingRuleTimer?: string(name='ScalingRuleTimer'),
  scalingRuleType?: string(name='ScalingRuleType'),
}

model CreateApplicationScalingRuleResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    createTime?: long(name='CreateTime'),
    lastDisableTime?: long(name='LastDisableTime'),
    metric?: {
      maxReplicas?: int32(name='MaxReplicas'),
      metrics?: [ 
        {
          metricTargetAverageUtilization?: int32(name='MetricTargetAverageUtilization'),
          metricType?: string(name='MetricType'),
        }
      ](name='Metrics'),
      minReplicas?: int32(name='MinReplicas'),
    }(name='Metric'),
    scaleRuleEnabled?: boolean(name='ScaleRuleEnabled'),
    scaleRuleName?: string(name='ScaleRuleName'),
    scaleRuleType?: string(name='ScaleRuleType'),
    timer?: {
      beginDate?: string(name='BeginDate'),
      endDate?: string(name='EndDate'),
      period?: string(name='Period'),
      schedules?: [ 
        {
          atTime?: string(name='AtTime'),
          targetReplicas?: int32(name='TargetReplicas'),
        }
      ](name='Schedules'),
    }(name='Timer'),
    updateTime?: long(name='UpdateTime'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model CreateApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateApplicationScalingRuleResponseBody(name='body'),
}

async function createApplicationScalingRule(request: CreateApplicationScalingRuleRequest): CreateApplicationScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createApplicationScalingRuleWithOptions(request, headers, runtime);
}

async function createApplicationScalingRuleWithOptions(request: CreateApplicationScalingRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateApplicationScalingRuleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.minReadyInstanceRatio)) {
    query['MinReadyInstanceRatio'] = request.minReadyInstanceRatio;
  }
  if (!Util.isUnset(request.minReadyInstances)) {
    query['MinReadyInstances'] = request.minReadyInstances;
  }
  if (!Util.isUnset(request.scalingRuleEnable)) {
    query['ScalingRuleEnable'] = request.scalingRuleEnable;
  }
  if (!Util.isUnset(request.scalingRuleMetric)) {
    query['ScalingRuleMetric'] = request.scalingRuleMetric;
  }
  if (!Util.isUnset(request.scalingRuleName)) {
    query['ScalingRuleName'] = request.scalingRuleName;
  }
  if (!Util.isUnset(request.scalingRuleTimer)) {
    query['ScalingRuleTimer'] = request.scalingRuleTimer;
  }
  if (!Util.isUnset(request.scalingRuleType)) {
    query['ScalingRuleType'] = request.scalingRuleType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateApplicationScalingRule',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/scale/applicationScalingRule`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateConfigMapRequest {
  data?: string(name='Data'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  namespaceId?: string(name='NamespaceId'),
}

model CreateConfigMapResponseBody = {
  code?: string(name='Code'),
  data?: {
    configMapId?: long(name='ConfigMapId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model CreateConfigMapResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateConfigMapResponseBody(name='body'),
}

async function createConfigMap(request: CreateConfigMapRequest): CreateConfigMapResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createConfigMapWithOptions(request, headers, runtime);
}

async function createConfigMapWithOptions(request: CreateConfigMapRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateConfigMapResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.data)) {
    body['Data'] = request.data;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConfigMap',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/configmap/configMap`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateGreyTagRouteRequest {
  albRules?: string(name='AlbRules'),
  appId?: string(name='AppId'),
  description?: string(name='Description'),
  dubboRules?: string(name='DubboRules'),
  name?: string(name='Name'),
  scRules?: string(name='ScRules'),
}

model CreateGreyTagRouteResponseBody = {
  code?: string(name='Code'),
  data?: {
    greyTagRouteId?: long(name='GreyTagRouteId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model CreateGreyTagRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGreyTagRouteResponseBody(name='body'),
}

async function createGreyTagRoute(request: CreateGreyTagRouteRequest): CreateGreyTagRouteResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createGreyTagRouteWithOptions(request, headers, runtime);
}

async function createGreyTagRouteWithOptions(request: CreateGreyTagRouteRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateGreyTagRouteResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.albRules)) {
    query['AlbRules'] = request.albRules;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dubboRules)) {
    query['DubboRules'] = request.dubboRules;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.scRules)) {
    query['ScRules'] = request.scRules;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGreyTagRoute',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/tagroute/greyTagRoute`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateIngressRequest {
  certId?: string(name='CertId'),
  defaultRule?: string(name='DefaultRule'),
  description?: string(name='Description'),
  listenerPort?: int32(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalanceType?: string(name='LoadBalanceType'),
  namespaceId?: string(name='NamespaceId'),
  rules?: string(name='Rules'),
  slbId?: string(name='SlbId'),
}

model CreateIngressResponseBody = {
  code?: string(name='Code'),
  data?: {
    ingressId?: long(name='IngressId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model CreateIngressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIngressResponseBody(name='body'),
}

async function createIngress(request: CreateIngressRequest): CreateIngressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createIngressWithOptions(request, headers, runtime);
}

async function createIngressWithOptions(request: CreateIngressRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateIngressResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.certId)) {
    query['CertId'] = request.certId;
  }
  if (!Util.isUnset(request.defaultRule)) {
    query['DefaultRule'] = request.defaultRule;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalanceType)) {
    query['LoadBalanceType'] = request.loadBalanceType;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.slbId)) {
    query['SlbId'] = request.slbId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.rules)) {
    body['Rules'] = request.rules;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIngress',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/ingress/Ingress`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateJobRequest {
  acrAssumeRoleArn?: string(name='AcrAssumeRoleArn'),
  appDescription?: string(name='AppDescription'),
  appName?: string(name='AppName'),
  associateEip?: boolean(name='AssociateEip'),
  autoConfig?: boolean(name='AutoConfig'),
  backoffLimit?: long(name='BackoffLimit'),
  command?: string(name='Command'),
  commandArgs?: string(name='CommandArgs'),
  concurrencyPolicy?: string(name='ConcurrencyPolicy'),
  configMapMountDesc?: string(name='ConfigMapMountDesc'),
  cpu?: int32(name='Cpu'),
  customHostAlias?: string(name='CustomHostAlias'),
  deploy?: boolean(name='Deploy'),
  edasContainerVersion?: string(name='EdasContainerVersion'),
  envs?: string(name='Envs'),
  imagePullSecrets?: string(name='ImagePullSecrets'),
  imageUrl?: string(name='ImageUrl'),
  jarStartArgs?: string(name='JarStartArgs'),
  jarStartOptions?: string(name='JarStartOptions'),
  jdk?: string(name='Jdk'),
  liveness?: string(name='Liveness'),
  memory?: int32(name='Memory'),
  mountDesc?: string(name='MountDesc'),
  mountHost?: string(name='MountHost'),
  namespaceId?: string(name='NamespaceId'),
  nasId?: string(name='NasId'),
  ossAkId?: string(name='OssAkId'),
  ossAkSecret?: string(name='OssAkSecret'),
  ossMountDescs?: string(name='OssMountDescs'),
  packageType?: string(name='PackageType'),
  packageUrl?: string(name='PackageUrl'),
  packageVersion?: string(name='PackageVersion'),
  phpArmsConfigLocation?: string(name='PhpArmsConfigLocation'),
  phpConfig?: string(name='PhpConfig'),
  phpConfigLocation?: string(name='PhpConfigLocation'),
  postStart?: string(name='PostStart'),
  preStop?: string(name='PreStop'),
  programmingLanguage?: string(name='ProgrammingLanguage'),
  python?: string(name='Python'),
  pythonModules?: string(name='PythonModules'),
  readiness?: string(name='Readiness'),
  refAppId?: string(name='RefAppId'),
  replicas?: int32(name='Replicas'),
  securityGroupId?: string(name='SecurityGroupId'),
  slice?: boolean(name='Slice'),
  sliceEnvs?: string(name='SliceEnvs'),
  slsConfigs?: string(name='SlsConfigs'),
  terminationGracePeriodSeconds?: int32(name='TerminationGracePeriodSeconds'),
  timeout?: long(name='Timeout'),
  timezone?: string(name='Timezone'),
  tomcatConfig?: string(name='TomcatConfig'),
  triggerConfig?: string(name='TriggerConfig'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  warStartOptions?: string(name='WarStartOptions'),
  webContainer?: string(name='WebContainer'),
  workload?: string(name='Workload'),
}

model CreateJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model CreateJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateJobResponseBody(name='body'),
}

async function createJob(request: CreateJobRequest): CreateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createJobWithOptions(request, headers, runtime);
}

async function createJobWithOptions(request: CreateJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateJobResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.acrAssumeRoleArn)) {
    query['AcrAssumeRoleArn'] = request.acrAssumeRoleArn;
  }
  if (!Util.isUnset(request.appDescription)) {
    query['AppDescription'] = request.appDescription;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.autoConfig)) {
    query['AutoConfig'] = request.autoConfig;
  }
  if (!Util.isUnset(request.backoffLimit)) {
    query['BackoffLimit'] = request.backoffLimit;
  }
  if (!Util.isUnset(request.command)) {
    query['Command'] = request.command;
  }
  if (!Util.isUnset(request.commandArgs)) {
    query['CommandArgs'] = request.commandArgs;
  }
  if (!Util.isUnset(request.concurrencyPolicy)) {
    query['ConcurrencyPolicy'] = request.concurrencyPolicy;
  }
  if (!Util.isUnset(request.cpu)) {
    query['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.customHostAlias)) {
    query['CustomHostAlias'] = request.customHostAlias;
  }
  if (!Util.isUnset(request.deploy)) {
    query['Deploy'] = request.deploy;
  }
  if (!Util.isUnset(request.edasContainerVersion)) {
    query['EdasContainerVersion'] = request.edasContainerVersion;
  }
  if (!Util.isUnset(request.envs)) {
    query['Envs'] = request.envs;
  }
  if (!Util.isUnset(request.imagePullSecrets)) {
    query['ImagePullSecrets'] = request.imagePullSecrets;
  }
  if (!Util.isUnset(request.imageUrl)) {
    query['ImageUrl'] = request.imageUrl;
  }
  if (!Util.isUnset(request.jarStartArgs)) {
    query['JarStartArgs'] = request.jarStartArgs;
  }
  if (!Util.isUnset(request.jarStartOptions)) {
    query['JarStartOptions'] = request.jarStartOptions;
  }
  if (!Util.isUnset(request.jdk)) {
    query['Jdk'] = request.jdk;
  }
  if (!Util.isUnset(request.liveness)) {
    query['Liveness'] = request.liveness;
  }
  if (!Util.isUnset(request.memory)) {
    query['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.mountDesc)) {
    query['MountDesc'] = request.mountDesc;
  }
  if (!Util.isUnset(request.mountHost)) {
    query['MountHost'] = request.mountHost;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.nasId)) {
    query['NasId'] = request.nasId;
  }
  if (!Util.isUnset(request.packageType)) {
    query['PackageType'] = request.packageType;
  }
  if (!Util.isUnset(request.packageUrl)) {
    query['PackageUrl'] = request.packageUrl;
  }
  if (!Util.isUnset(request.packageVersion)) {
    query['PackageVersion'] = request.packageVersion;
  }
  if (!Util.isUnset(request.phpArmsConfigLocation)) {
    query['PhpArmsConfigLocation'] = request.phpArmsConfigLocation;
  }
  if (!Util.isUnset(request.phpConfigLocation)) {
    query['PhpConfigLocation'] = request.phpConfigLocation;
  }
  if (!Util.isUnset(request.postStart)) {
    query['PostStart'] = request.postStart;
  }
  if (!Util.isUnset(request.preStop)) {
    query['PreStop'] = request.preStop;
  }
  if (!Util.isUnset(request.programmingLanguage)) {
    query['ProgrammingLanguage'] = request.programmingLanguage;
  }
  if (!Util.isUnset(request.python)) {
    query['Python'] = request.python;
  }
  if (!Util.isUnset(request.pythonModules)) {
    query['PythonModules'] = request.pythonModules;
  }
  if (!Util.isUnset(request.readiness)) {
    query['Readiness'] = request.readiness;
  }
  if (!Util.isUnset(request.refAppId)) {
    query['RefAppId'] = request.refAppId;
  }
  if (!Util.isUnset(request.replicas)) {
    query['Replicas'] = request.replicas;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.slice)) {
    query['Slice'] = request.slice;
  }
  if (!Util.isUnset(request.sliceEnvs)) {
    query['SliceEnvs'] = request.sliceEnvs;
  }
  if (!Util.isUnset(request.slsConfigs)) {
    query['SlsConfigs'] = request.slsConfigs;
  }
  if (!Util.isUnset(request.terminationGracePeriodSeconds)) {
    query['TerminationGracePeriodSeconds'] = request.terminationGracePeriodSeconds;
  }
  if (!Util.isUnset(request.timeout)) {
    query['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.timezone)) {
    query['Timezone'] = request.timezone;
  }
  if (!Util.isUnset(request.tomcatConfig)) {
    query['TomcatConfig'] = request.tomcatConfig;
  }
  if (!Util.isUnset(request.triggerConfig)) {
    query['TriggerConfig'] = request.triggerConfig;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.warStartOptions)) {
    query['WarStartOptions'] = request.warStartOptions;
  }
  if (!Util.isUnset(request.webContainer)) {
    query['WebContainer'] = request.webContainer;
  }
  if (!Util.isUnset(request.workload)) {
    query['Workload'] = request.workload;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.associateEip)) {
    body['AssociateEip'] = request.associateEip;
  }
  if (!Util.isUnset(request.configMapMountDesc)) {
    body['ConfigMapMountDesc'] = request.configMapMountDesc;
  }
  if (!Util.isUnset(request.ossAkId)) {
    body['OssAkId'] = request.ossAkId;
  }
  if (!Util.isUnset(request.ossAkSecret)) {
    body['OssAkSecret'] = request.ossAkSecret;
  }
  if (!Util.isUnset(request.ossMountDescs)) {
    body['OssMountDescs'] = request.ossMountDescs;
  }
  if (!Util.isUnset(request.phpConfig)) {
    body['PhpConfig'] = request.phpConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateJob',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/job/createJob`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateNamespaceRequest {
  namespaceDescription?: string(name='NamespaceDescription'),
  namespaceId?: string(name='NamespaceId'),
  namespaceName?: string(name='NamespaceName'),
}

model CreateNamespaceResponseBody = {
  code?: string(name='Code'),
  data?: {
    namespaceDescription?: string(name='NamespaceDescription'),
    namespaceId?: string(name='NamespaceId'),
    namespaceName?: string(name='NamespaceName'),
    regionId?: string(name='RegionId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model CreateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNamespaceResponseBody(name='body'),
}

async function createNamespace(request: CreateNamespaceRequest): CreateNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createNamespaceWithOptions(request, headers, runtime);
}

async function createNamespaceWithOptions(request: CreateNamespaceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateNamespaceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.namespaceDescription)) {
    query['NamespaceDescription'] = request.namespaceDescription;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNamespace',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/paas/namespace`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateSecretRequest {
  namespaceId?: string(name='NamespaceId'),
  secretData?: string(name='SecretData'),
  secretName?: string(name='SecretName'),
  secretType?: string(name='SecretType'),
}

model CreateSecretResponseBody = {
  code?: string(name='Code'),
  data?: {
    secretId?: long(name='SecretId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model CreateSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSecretResponseBody(name='body'),
}

async function createSecret(request: CreateSecretRequest): CreateSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSecretWithOptions(request, headers, runtime);
}

async function createSecretWithOptions(request: CreateSecretRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSecretResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.secretType)) {
    query['SecretType'] = request.secretType;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.secretData)) {
    body['SecretData'] = request.secretData;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSecret',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/secret/secret`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteApplicationRequest {
  appId?: string(name='AppId'),
}

model DeleteApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DeleteApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteApplicationResponseBody(name='body'),
}

async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteApplicationWithOptions(request, headers, runtime);
}

async function deleteApplicationWithOptions(request: DeleteApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApplication',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/deleteApplication`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteApplicationScalingRuleRequest {
  appId?: string(name='AppId'),
  scalingRuleName?: string(name='ScalingRuleName'),
}

model DeleteApplicationScalingRuleResponseBody = {
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model DeleteApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteApplicationScalingRuleResponseBody(name='body'),
}

async function deleteApplicationScalingRule(request: DeleteApplicationScalingRuleRequest): DeleteApplicationScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteApplicationScalingRuleWithOptions(request, headers, runtime);
}

async function deleteApplicationScalingRuleWithOptions(request: DeleteApplicationScalingRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteApplicationScalingRuleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.scalingRuleName)) {
    query['ScalingRuleName'] = request.scalingRuleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApplicationScalingRule',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/scale/applicationScalingRule`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteConfigMapRequest {
  configMapId?: long(name='ConfigMapId'),
}

model DeleteConfigMapResponseBody = {
  code?: string(name='Code'),
  data?: {
    configMapId?: long(name='ConfigMapId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DeleteConfigMapResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteConfigMapResponseBody(name='body'),
}

async function deleteConfigMap(request: DeleteConfigMapRequest): DeleteConfigMapResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteConfigMapWithOptions(request, headers, runtime);
}

async function deleteConfigMapWithOptions(request: DeleteConfigMapRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteConfigMapResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.configMapId)) {
    query['ConfigMapId'] = request.configMapId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConfigMap',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/configmap/configMap`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteGreyTagRouteRequest {
  greyTagRouteId?: long(name='GreyTagRouteId'),
}

model DeleteGreyTagRouteResponseBody = {
  code?: string(name='Code'),
  data?: {
    greyTagRouteId?: long(name='GreyTagRouteId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DeleteGreyTagRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGreyTagRouteResponseBody(name='body'),
}

async function deleteGreyTagRoute(request: DeleteGreyTagRouteRequest): DeleteGreyTagRouteResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGreyTagRouteWithOptions(request, headers, runtime);
}

async function deleteGreyTagRouteWithOptions(request: DeleteGreyTagRouteRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteGreyTagRouteResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.greyTagRouteId)) {
    query['GreyTagRouteId'] = request.greyTagRouteId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGreyTagRoute',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/tagroute/greyTagRoute`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteHistoryJobRequest {
  appId?: string(name='AppId'),
  jobId?: string(name='JobId'),
}

model DeleteHistoryJobResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DeleteHistoryJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHistoryJobResponseBody(name='body'),
}

async function deleteHistoryJob(request: DeleteHistoryJobRequest): DeleteHistoryJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteHistoryJobWithOptions(request, headers, runtime);
}

async function deleteHistoryJobWithOptions(request: DeleteHistoryJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteHistoryJobResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHistoryJob',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/job/deleteHistoryJob`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteIngressRequest {
  ingressId?: long(name='IngressId'),
}

model DeleteIngressResponseBody = {
  code?: string(name='Code'),
  data?: {
    ingressId?: long(name='IngressId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DeleteIngressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIngressResponseBody(name='body'),
}

async function deleteIngress(request: DeleteIngressRequest): DeleteIngressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteIngressWithOptions(request, headers, runtime);
}

async function deleteIngressWithOptions(request: DeleteIngressRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteIngressResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.ingressId)) {
    query['IngressId'] = request.ingressId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIngress',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/ingress/Ingress`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteJobRequest {
  appId?: string(name='AppId'),
}

model DeleteJobResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DeleteJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteJobResponseBody(name='body'),
}

async function deleteJob(request: DeleteJobRequest): DeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteJobWithOptions(request, headers, runtime);
}

async function deleteJobWithOptions(request: DeleteJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteJobResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteJob',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/job/deleteJob`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteNamespaceRequest {
  namespaceId?: string(name='NamespaceId'),
}

model DeleteNamespaceResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DeleteNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNamespaceResponseBody(name='body'),
}

async function deleteNamespace(request: DeleteNamespaceRequest): DeleteNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteNamespaceWithOptions(request, headers, runtime);
}

async function deleteNamespaceWithOptions(request: DeleteNamespaceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteNamespaceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNamespace',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/paas/namespace`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteSecretRequest {
  namespaceId?: string(name='NamespaceId'),
  secretId?: long(name='SecretId'),
}

model DeleteSecretResponseBody = {
  code?: string(name='Code'),
  data?: {
    secretId?: long(name='SecretId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DeleteSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSecretResponseBody(name='body'),
}

async function deleteSecret(request: DeleteSecretRequest): DeleteSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSecretWithOptions(request, headers, runtime);
}

async function deleteSecretWithOptions(request: DeleteSecretRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSecretResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.secretId)) {
    query['SecretId'] = request.secretId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecret',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/secret/secret`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeployApplicationRequest {
  acrAssumeRoleArn?: string(name='AcrAssumeRoleArn'),
  acrInstanceId?: string(name='AcrInstanceId'),
  appId?: string(name='AppId'),
  associateEip?: boolean(name='AssociateEip'),
  autoEnableApplicationScalingRule?: boolean(name='AutoEnableApplicationScalingRule'),
  batchWaitTime?: int32(name='BatchWaitTime'),
  changeOrderDesc?: string(name='ChangeOrderDesc'),
  command?: string(name='Command'),
  commandArgs?: string(name='CommandArgs'),
  configMapMountDesc?: string(name='ConfigMapMountDesc'),
  customHostAlias?: string(name='CustomHostAlias'),
  edasContainerVersion?: string(name='EdasContainerVersion'),
  enableAhas?: string(name='EnableAhas'),
  enableGreyTagRoute?: boolean(name='EnableGreyTagRoute'),
  envs?: string(name='Envs'),
  imagePullSecrets?: string(name='ImagePullSecrets'),
  imageUrl?: string(name='ImageUrl'),
  jarStartArgs?: string(name='JarStartArgs'),
  jarStartOptions?: string(name='JarStartOptions'),
  jdk?: string(name='Jdk'),
  kafkaConfigs?: string(name='KafkaConfigs'),
  liveness?: string(name='Liveness'),
  microRegistration?: string(name='MicroRegistration'),
  minReadyInstanceRatio?: int32(name='MinReadyInstanceRatio'),
  minReadyInstances?: int32(name='MinReadyInstances'),
  mountDesc?: string(name='MountDesc'),
  mountHost?: string(name='MountHost'),
  nasConfigs?: string(name='NasConfigs'),
  nasId?: string(name='NasId'),
  ossAkId?: string(name='OssAkId'),
  ossAkSecret?: string(name='OssAkSecret'),
  ossMountDescs?: string(name='OssMountDescs'),
  packageUrl?: string(name='PackageUrl'),
  packageVersion?: string(name='PackageVersion'),
  phpArmsConfigLocation?: string(name='PhpArmsConfigLocation'),
  phpConfig?: string(name='PhpConfig'),
  phpConfigLocation?: string(name='PhpConfigLocation'),
  postStart?: string(name='PostStart'),
  preStop?: string(name='PreStop'),
  pvtzDiscoverySvc?: string(name='PvtzDiscoverySvc'),
  python?: string(name='Python'),
  pythonModules?: string(name='PythonModules'),
  readiness?: string(name='Readiness'),
  slsConfigs?: string(name='SlsConfigs'),
  terminationGracePeriodSeconds?: int32(name='TerminationGracePeriodSeconds'),
  timezone?: string(name='Timezone'),
  tomcatConfig?: string(name='TomcatConfig'),
  updateStrategy?: string(name='UpdateStrategy'),
  warStartOptions?: string(name='WarStartOptions'),
  webContainer?: string(name='WebContainer'),
}

model DeployApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    changeOrderId?: string(name='ChangeOrderId'),
    isNeedApproval?: boolean(name='IsNeedApproval'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DeployApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeployApplicationResponseBody(name='body'),
}

async function deployApplication(request: DeployApplicationRequest): DeployApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deployApplicationWithOptions(request, headers, runtime);
}

async function deployApplicationWithOptions(request: DeployApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeployApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.acrAssumeRoleArn)) {
    query['AcrAssumeRoleArn'] = request.acrAssumeRoleArn;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.autoEnableApplicationScalingRule)) {
    query['AutoEnableApplicationScalingRule'] = request.autoEnableApplicationScalingRule;
  }
  if (!Util.isUnset(request.batchWaitTime)) {
    query['BatchWaitTime'] = request.batchWaitTime;
  }
  if (!Util.isUnset(request.changeOrderDesc)) {
    query['ChangeOrderDesc'] = request.changeOrderDesc;
  }
  if (!Util.isUnset(request.command)) {
    query['Command'] = request.command;
  }
  if (!Util.isUnset(request.commandArgs)) {
    query['CommandArgs'] = request.commandArgs;
  }
  if (!Util.isUnset(request.customHostAlias)) {
    query['CustomHostAlias'] = request.customHostAlias;
  }
  if (!Util.isUnset(request.edasContainerVersion)) {
    query['EdasContainerVersion'] = request.edasContainerVersion;
  }
  if (!Util.isUnset(request.enableAhas)) {
    query['EnableAhas'] = request.enableAhas;
  }
  if (!Util.isUnset(request.enableGreyTagRoute)) {
    query['EnableGreyTagRoute'] = request.enableGreyTagRoute;
  }
  if (!Util.isUnset(request.envs)) {
    query['Envs'] = request.envs;
  }
  if (!Util.isUnset(request.imagePullSecrets)) {
    query['ImagePullSecrets'] = request.imagePullSecrets;
  }
  if (!Util.isUnset(request.imageUrl)) {
    query['ImageUrl'] = request.imageUrl;
  }
  if (!Util.isUnset(request.jarStartArgs)) {
    query['JarStartArgs'] = request.jarStartArgs;
  }
  if (!Util.isUnset(request.jarStartOptions)) {
    query['JarStartOptions'] = request.jarStartOptions;
  }
  if (!Util.isUnset(request.jdk)) {
    query['Jdk'] = request.jdk;
  }
  if (!Util.isUnset(request.kafkaConfigs)) {
    query['KafkaConfigs'] = request.kafkaConfigs;
  }
  if (!Util.isUnset(request.liveness)) {
    query['Liveness'] = request.liveness;
  }
  if (!Util.isUnset(request.microRegistration)) {
    query['MicroRegistration'] = request.microRegistration;
  }
  if (!Util.isUnset(request.minReadyInstanceRatio)) {
    query['MinReadyInstanceRatio'] = request.minReadyInstanceRatio;
  }
  if (!Util.isUnset(request.minReadyInstances)) {
    query['MinReadyInstances'] = request.minReadyInstances;
  }
  if (!Util.isUnset(request.mountDesc)) {
    query['MountDesc'] = request.mountDesc;
  }
  if (!Util.isUnset(request.mountHost)) {
    query['MountHost'] = request.mountHost;
  }
  if (!Util.isUnset(request.nasConfigs)) {
    query['NasConfigs'] = request.nasConfigs;
  }
  if (!Util.isUnset(request.nasId)) {
    query['NasId'] = request.nasId;
  }
  if (!Util.isUnset(request.packageUrl)) {
    query['PackageUrl'] = request.packageUrl;
  }
  if (!Util.isUnset(request.packageVersion)) {
    query['PackageVersion'] = request.packageVersion;
  }
  if (!Util.isUnset(request.phpArmsConfigLocation)) {
    query['PhpArmsConfigLocation'] = request.phpArmsConfigLocation;
  }
  if (!Util.isUnset(request.phpConfigLocation)) {
    query['PhpConfigLocation'] = request.phpConfigLocation;
  }
  if (!Util.isUnset(request.postStart)) {
    query['PostStart'] = request.postStart;
  }
  if (!Util.isUnset(request.preStop)) {
    query['PreStop'] = request.preStop;
  }
  if (!Util.isUnset(request.pvtzDiscoverySvc)) {
    query['PvtzDiscoverySvc'] = request.pvtzDiscoverySvc;
  }
  if (!Util.isUnset(request.python)) {
    query['Python'] = request.python;
  }
  if (!Util.isUnset(request.pythonModules)) {
    query['PythonModules'] = request.pythonModules;
  }
  if (!Util.isUnset(request.readiness)) {
    query['Readiness'] = request.readiness;
  }
  if (!Util.isUnset(request.slsConfigs)) {
    query['SlsConfigs'] = request.slsConfigs;
  }
  if (!Util.isUnset(request.terminationGracePeriodSeconds)) {
    query['TerminationGracePeriodSeconds'] = request.terminationGracePeriodSeconds;
  }
  if (!Util.isUnset(request.timezone)) {
    query['Timezone'] = request.timezone;
  }
  if (!Util.isUnset(request.tomcatConfig)) {
    query['TomcatConfig'] = request.tomcatConfig;
  }
  if (!Util.isUnset(request.updateStrategy)) {
    query['UpdateStrategy'] = request.updateStrategy;
  }
  if (!Util.isUnset(request.warStartOptions)) {
    query['WarStartOptions'] = request.warStartOptions;
  }
  if (!Util.isUnset(request.webContainer)) {
    query['WebContainer'] = request.webContainer;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.acrInstanceId)) {
    body['AcrInstanceId'] = request.acrInstanceId;
  }
  if (!Util.isUnset(request.associateEip)) {
    body['AssociateEip'] = request.associateEip;
  }
  if (!Util.isUnset(request.configMapMountDesc)) {
    body['ConfigMapMountDesc'] = request.configMapMountDesc;
  }
  if (!Util.isUnset(request.ossAkId)) {
    body['OssAkId'] = request.ossAkId;
  }
  if (!Util.isUnset(request.ossAkSecret)) {
    body['OssAkSecret'] = request.ossAkSecret;
  }
  if (!Util.isUnset(request.ossMountDescs)) {
    body['OssMountDescs'] = request.ossMountDescs;
  }
  if (!Util.isUnset(request.phpConfig)) {
    body['PhpConfig'] = request.phpConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeployApplication',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/deployApplication`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeAppServiceDetailRequest {
  appId?: string(name='AppId'),
  serviceGroup?: string(name='ServiceGroup'),
  serviceName?: string(name='ServiceName'),
  serviceType?: string(name='ServiceType'),
  serviceVersion?: string(name='ServiceVersion'),
}

model DescribeAppServiceDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    dubboApplicationName?: string(name='DubboApplicationName'),
    edasAppName?: string(name='EdasAppName'),
    group?: string(name='Group'),
    metadata?: map[string]any(name='Metadata'),
    methods?: [ 
      {
        methodController?: string(name='MethodController'),
        name?: string(name='Name'),
        nameDetail?: string(name='NameDetail'),
        parameterDefinitions?: [ 
          {
            description?: string(name='Description'),
            name?: string(name='Name'),
            type?: string(name='Type'),
          }
        ](name='ParameterDefinitions'),
        parameterDetails?: [ string ](name='ParameterDetails'),
        parameterTypes?: [ string ](name='ParameterTypes'),
        paths?: [ string ](name='Paths'),
        requestMethods?: [ string ](name='RequestMethods'),
        returnDetails?: string(name='ReturnDetails'),
        returnType?: string(name='ReturnType'),
      }
    ](name='Methods'),
    serviceName?: string(name='ServiceName'),
    serviceType?: string(name='ServiceType'),
    springApplicationName?: string(name='SpringApplicationName'),
    version?: string(name='Version'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeAppServiceDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAppServiceDetailResponseBody(name='body'),
}

async function describeAppServiceDetail(request: DescribeAppServiceDetailRequest): DescribeAppServiceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeAppServiceDetailWithOptions(request, headers, runtime);
}

async function describeAppServiceDetailWithOptions(request: DescribeAppServiceDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeAppServiceDetailResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.serviceGroup)) {
    query['ServiceGroup'] = request.serviceGroup;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['ServiceType'] = request.serviceType;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query['ServiceVersion'] = request.serviceVersion;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAppServiceDetail',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/service/describeAppServiceDetail`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeApplicationConfigRequest {
  appId?: string(name='AppId'),
  versionId?: string(name='VersionId'),
}

model DescribeApplicationConfigResponseBody = {
  code?: string(name='Code'),
  data?: {
    acrAssumeRoleArn?: string(name='AcrAssumeRoleArn'),
    acrInstanceId?: string(name='AcrInstanceId'),
    appDescription?: string(name='AppDescription'),
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    associateEip?: boolean(name='AssociateEip'),
    batchWaitTime?: int32(name='BatchWaitTime'),
    command?: string(name='Command'),
    commandArgs?: string(name='CommandArgs'),
    configMapMountDesc?: [ 
      {
        configMapId?: long(name='ConfigMapId'),
        configMapName?: string(name='ConfigMapName'),
        key?: string(name='Key'),
        mountPath?: string(name='MountPath'),
      }
    ](name='ConfigMapMountDesc'),
    cpu?: int32(name='Cpu'),
    customHostAlias?: string(name='CustomHostAlias'),
    edasContainerVersion?: string(name='EdasContainerVersion'),
    enableAhas?: string(name='EnableAhas'),
    enableGreyTagRoute?: boolean(name='EnableGreyTagRoute'),
    envs?: string(name='Envs'),
    imagePullSecrets?: string(name='ImagePullSecrets'),
    imageUrl?: string(name='ImageUrl'),
    jarStartArgs?: string(name='JarStartArgs'),
    jarStartOptions?: string(name='JarStartOptions'),
    jdk?: string(name='Jdk'),
    kafkaConfigs?: string(name='KafkaConfigs'),
    liveness?: string(name='Liveness'),
    memory?: int32(name='Memory'),
    microRegistration?: string(name='MicroRegistration'),
    minReadyInstanceRatio?: int32(name='MinReadyInstanceRatio'),
    minReadyInstances?: int32(name='MinReadyInstances'),
    mountDesc?: [ 
      {
        mountPath?: string(name='MountPath'),
        nasPath?: string(name='NasPath'),
      }
    ](name='MountDesc'),
    mountHost?: string(name='MountHost'),
    mseApplicationId?: string(name='MseApplicationId'),
    namespaceId?: string(name='NamespaceId'),
    nasConfigs?: string(name='NasConfigs'),
    nasId?: string(name='NasId'),
    ossAkId?: string(name='OssAkId'),
    ossAkSecret?: string(name='OssAkSecret'),
    ossMountDescs?: [ 
      {
        bucketName?: string(name='bucketName'),
        bucketPath?: string(name='bucketPath'),
        mountPath?: string(name='mountPath'),
        readOnly?: boolean(name='readOnly'),
      }
    ](name='OssMountDescs'),
    packageType?: string(name='PackageType'),
    packageUrl?: string(name='PackageUrl'),
    packageVersion?: string(name='PackageVersion'),
    phpArmsConfigLocation?: string(name='PhpArmsConfigLocation'),
    phpConfig?: string(name='PhpConfig'),
    phpConfigLocation?: string(name='PhpConfigLocation'),
    postStart?: string(name='PostStart'),
    preStop?: string(name='PreStop'),
    programmingLanguage?: string(name='ProgrammingLanguage'),
    pvtzDiscovery?: string(name='PvtzDiscovery'),
    python?: string(name='Python'),
    pythonModules?: string(name='PythonModules'),
    readiness?: string(name='Readiness'),
    regionId?: string(name='RegionId'),
    replicas?: int32(name='Replicas'),
    securityGroupId?: string(name='SecurityGroupId'),
    slsConfigs?: string(name='SlsConfigs'),
    tags?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='Tags'),
    terminationGracePeriodSeconds?: int32(name='TerminationGracePeriodSeconds'),
    timezone?: string(name='Timezone'),
    tomcatConfig?: string(name='TomcatConfig'),
    updateStrategy?: string(name='UpdateStrategy'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
    warStartOptions?: string(name='WarStartOptions'),
    webContainer?: string(name='WebContainer'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeApplicationConfigResponseBody(name='body'),
}

async function describeApplicationConfig(request: DescribeApplicationConfigRequest): DescribeApplicationConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeApplicationConfigWithOptions(request, headers, runtime);
}

async function describeApplicationConfigWithOptions(request: DescribeApplicationConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeApplicationConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplicationConfig',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/describeApplicationConfig`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeApplicationGroupsRequest {
  appId?: string(name='AppId'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model DescribeApplicationGroupsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      edasContainerVersion?: string(name='EdasContainerVersion'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      groupType?: int32(name='GroupType'),
      imageUrl?: string(name='ImageUrl'),
      jdk?: string(name='Jdk'),
      packageType?: string(name='PackageType'),
      packageUrl?: string(name='PackageUrl'),
      packageVersion?: string(name='PackageVersion'),
      replicas?: int32(name='Replicas'),
      runningInstances?: int32(name='RunningInstances'),
      webContainer?: string(name='WebContainer'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeApplicationGroupsResponseBody(name='body'),
}

async function describeApplicationGroups(request: DescribeApplicationGroupsRequest): DescribeApplicationGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeApplicationGroupsWithOptions(request, headers, runtime);
}

async function describeApplicationGroupsWithOptions(request: DescribeApplicationGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeApplicationGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplicationGroups',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/describeApplicationGroups`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeApplicationImageRequest {
  appId?: string(name='AppId'),
  imageUrl?: string(name='ImageUrl'),
}

model DescribeApplicationImageResponseBody = {
  code?: string(name='Code'),
  data?: {
    crUrl?: string(name='CrUrl'),
    logo?: string(name='Logo'),
    regionId?: string(name='RegionId'),
    repoName?: string(name='RepoName'),
    repoNamespace?: string(name='RepoNamespace'),
    repoOriginType?: string(name='RepoOriginType'),
    repoTag?: string(name='RepoTag'),
    repoType?: string(name='RepoType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeApplicationImageResponseBody(name='body'),
}

async function describeApplicationImage(request: DescribeApplicationImageRequest): DescribeApplicationImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeApplicationImageWithOptions(request, headers, runtime);
}

async function describeApplicationImageWithOptions(request: DescribeApplicationImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeApplicationImageResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.imageUrl)) {
    query['ImageUrl'] = request.imageUrl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplicationImage',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/container/describeApplicationImage`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeApplicationInstancesRequest {
  appId?: string(name='AppId'),
  currentPage?: int32(name='CurrentPage'),
  groupId?: string(name='GroupId'),
  pageSize?: int32(name='PageSize'),
  reverse?: boolean(name='Reverse'),
}

model DescribeApplicationInstancesResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    instances?: [ 
      {
        createTimeStamp?: long(name='CreateTimeStamp'),
        debugStatus?: boolean(name='DebugStatus'),
        eip?: string(name='Eip'),
        finishTimeStamp?: long(name='FinishTimeStamp'),
        groupId?: string(name='GroupId'),
        imageUrl?: string(name='ImageUrl'),
        instanceContainerIp?: string(name='InstanceContainerIp'),
        instanceContainerRestarts?: long(name='InstanceContainerRestarts'),
        instanceContainerStatus?: string(name='InstanceContainerStatus'),
        instanceHealthStatus?: string(name='InstanceHealthStatus'),
        instanceId?: string(name='InstanceId'),
        packageVersion?: string(name='PackageVersion'),
        vSwitchId?: string(name='VSwitchId'),
      }
    ](name='Instances'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeApplicationInstancesResponseBody(name='body'),
}

async function describeApplicationInstances(request: DescribeApplicationInstancesRequest): DescribeApplicationInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeApplicationInstancesWithOptions(request, headers, runtime);
}

async function describeApplicationInstancesWithOptions(request: DescribeApplicationInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeApplicationInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.reverse)) {
    query['Reverse'] = request.reverse;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplicationInstances',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/describeApplicationInstances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeApplicationScalingRuleRequest {
  appId?: string(name='AppId'),
  scalingRuleName?: string(name='ScalingRuleName'),
}

model DescribeApplicationScalingRuleResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    createTime?: long(name='CreateTime'),
    lastDisableTime?: long(name='LastDisableTime'),
    metric?: {
      maxReplicas?: int32(name='MaxReplicas'),
      metrics?: [ 
        {
          metricTargetAverageUtilization?: int32(name='MetricTargetAverageUtilization'),
          metricType?: string(name='MetricType'),
        }
      ](name='Metrics'),
      metricsStatus?: {
        currentMetrics?: [ 
          {
            currentValue?: long(name='CurrentValue'),
            name?: string(name='Name'),
            type?: string(name='Type'),
          }
        ](name='CurrentMetrics'),
        currentReplicas?: long(name='CurrentReplicas'),
        desiredReplicas?: long(name='DesiredReplicas'),
        lastScaleTime?: string(name='LastScaleTime'),
        nextScaleMetrics?: [ 
          {
            name?: string(name='Name'),
            nextScaleInAverageUtilization?: int32(name='NextScaleInAverageUtilization'),
            nextScaleOutAverageUtilization?: int32(name='NextScaleOutAverageUtilization'),
          }
        ](name='NextScaleMetrics'),
        nextScaleTimePeriod?: int32(name='NextScaleTimePeriod'),
      }(name='MetricsStatus'),
      minReplicas?: int32(name='MinReplicas'),
      scaleDownRules?: {
        disabled?: boolean(name='Disabled'),
        stabilizationWindowSeconds?: long(name='StabilizationWindowSeconds'),
        step?: long(name='Step'),
      }(name='ScaleDownRules'),
      scaleUpRules?: {
        disabled?: boolean(name='Disabled'),
        stabilizationWindowSeconds?: long(name='StabilizationWindowSeconds'),
        step?: long(name='Step'),
      }(name='ScaleUpRules'),
    }(name='Metric'),
    scaleRuleEnabled?: boolean(name='ScaleRuleEnabled'),
    scaleRuleName?: string(name='ScaleRuleName'),
    scaleRuleType?: string(name='ScaleRuleType'),
    timer?: {
      beginDate?: string(name='BeginDate'),
      endDate?: string(name='EndDate'),
      period?: string(name='Period'),
      schedules?: [ 
        {
          atTime?: string(name='AtTime'),
          targetReplicas?: int32(name='TargetReplicas'),
        }
      ](name='Schedules'),
    }(name='Timer'),
    updateTime?: long(name='UpdateTime'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeApplicationScalingRuleResponseBody(name='body'),
}

async function describeApplicationScalingRule(request: DescribeApplicationScalingRuleRequest): DescribeApplicationScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeApplicationScalingRuleWithOptions(request, headers, runtime);
}

async function describeApplicationScalingRuleWithOptions(request: DescribeApplicationScalingRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeApplicationScalingRuleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.scalingRuleName)) {
    query['ScalingRuleName'] = request.scalingRuleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplicationScalingRule',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/scale/applicationScalingRule`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeApplicationScalingRulesRequest {
  appId?: string(name='AppId'),
}

model DescribeApplicationScalingRulesResponseBody = {
  data?: {
    applicationScalingRules?: [ 
      {
        appId?: string(name='AppId'),
        createTime?: long(name='CreateTime'),
        lastDisableTime?: long(name='LastDisableTime'),
        metric?: {
          maxReplicas?: int32(name='MaxReplicas'),
          metrics?: [ 
            {
              metricTargetAverageUtilization?: int32(name='MetricTargetAverageUtilization'),
              metricType?: string(name='MetricType'),
            }
          ](name='Metrics'),
          metricsStatus?: {
            currentMetrics?: [ 
              {
                currentValue?: long(name='CurrentValue'),
                name?: string(name='Name'),
                type?: string(name='Type'),
              }
            ](name='CurrentMetrics'),
            currentReplicas?: long(name='CurrentReplicas'),
            desiredReplicas?: long(name='DesiredReplicas'),
            lastScaleTime?: string(name='LastScaleTime'),
            maxReplicas?: long(name='MaxReplicas'),
            minReplicas?: long(name='MinReplicas'),
            nextScaleMetrics?: [ 
              {
                name?: string(name='Name'),
                nextScaleInAverageUtilization?: int32(name='NextScaleInAverageUtilization'),
                nextScaleOutAverageUtilization?: int32(name='NextScaleOutAverageUtilization'),
              }
            ](name='NextScaleMetrics'),
            nextScaleTimePeriod?: int32(name='NextScaleTimePeriod'),
          }(name='MetricsStatus'),
          minReplicas?: int32(name='MinReplicas'),
          scaleDownRules?: {
            disabled?: boolean(name='Disabled'),
            stabilizationWindowSeconds?: long(name='StabilizationWindowSeconds'),
            step?: long(name='Step'),
          }(name='ScaleDownRules'),
          scaleUpRules?: {
            disabled?: boolean(name='Disabled'),
            stabilizationWindowSeconds?: long(name='StabilizationWindowSeconds'),
            step?: long(name='Step'),
          }(name='ScaleUpRules'),
        }(name='Metric'),
        scaleRuleEnabled?: boolean(name='ScaleRuleEnabled'),
        scaleRuleName?: string(name='ScaleRuleName'),
        scaleRuleType?: string(name='ScaleRuleType'),
        timer?: {
          beginDate?: string(name='BeginDate'),
          endDate?: string(name='EndDate'),
          period?: string(name='Period'),
          schedules?: [ 
            {
              atTime?: string(name='AtTime'),
              maxReplicas?: long(name='MaxReplicas'),
              minReplicas?: long(name='MinReplicas'),
              targetReplicas?: int32(name='TargetReplicas'),
            }
          ](name='Schedules'),
        }(name='Timer'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='ApplicationScalingRules'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationScalingRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeApplicationScalingRulesResponseBody(name='body'),
}

async function describeApplicationScalingRules(request: DescribeApplicationScalingRulesRequest): DescribeApplicationScalingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeApplicationScalingRulesWithOptions(request, headers, runtime);
}

async function describeApplicationScalingRulesWithOptions(request: DescribeApplicationScalingRulesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeApplicationScalingRulesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplicationScalingRules',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/scale/applicationScalingRules`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeApplicationSlbsRequest {
  appId?: string(name='AppId'),
}

model DescribeApplicationSlbsResponseBody = {
  code?: string(name='Code'),
  data?: {
    internet?: [ 
      {
        httpsCertId?: string(name='HttpsCertId'),
        port?: int32(name='Port'),
        protocol?: string(name='Protocol'),
        targetPort?: int32(name='TargetPort'),
      }
    ](name='Internet'),
    internetIp?: string(name='InternetIp'),
    internetSlbExpired?: boolean(name='InternetSlbExpired'),
    internetSlbId?: string(name='InternetSlbId'),
    intranet?: [ 
      {
        httpsCertId?: string(name='HttpsCertId'),
        port?: int32(name='Port'),
        protocol?: string(name='Protocol'),
        targetPort?: int32(name='TargetPort'),
      }
    ](name='Intranet'),
    intranetIp?: string(name='IntranetIp'),
    intranetSlbExpired?: boolean(name='IntranetSlbExpired'),
    intranetSlbId?: string(name='IntranetSlbId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationSlbsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeApplicationSlbsResponseBody(name='body'),
}

async function describeApplicationSlbs(request: DescribeApplicationSlbsRequest): DescribeApplicationSlbsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeApplicationSlbsWithOptions(request, headers, runtime);
}

async function describeApplicationSlbsWithOptions(request: DescribeApplicationSlbsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeApplicationSlbsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplicationSlbs',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/slb`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeApplicationStatusRequest {
  appId?: string(name='AppId'),
}

model DescribeApplicationStatusResponseBody = {
  code?: string(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    armsAdvancedEnabled?: string(name='ArmsAdvancedEnabled'),
    armsApmInfo?: string(name='ArmsApmInfo'),
    createTime?: string(name='CreateTime'),
    currentStatus?: string(name='CurrentStatus'),
    enableAgent?: boolean(name='EnableAgent'),
    fileSizeLimit?: long(name='FileSizeLimit'),
    lastChangeOrderId?: string(name='LastChangeOrderId'),
    lastChangeOrderRunning?: boolean(name='LastChangeOrderRunning'),
    lastChangeOrderStatus?: string(name='LastChangeOrderStatus'),
    runningInstances?: int32(name='RunningInstances'),
    subStatus?: string(name='SubStatus'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeApplicationStatusResponseBody(name='body'),
}

async function describeApplicationStatus(request: DescribeApplicationStatusRequest): DescribeApplicationStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeApplicationStatusWithOptions(request, headers, runtime);
}

async function describeApplicationStatusWithOptions(request: DescribeApplicationStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeApplicationStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApplicationStatus',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/describeApplicationStatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeChangeOrderRequest {
  changeOrderId?: string(name='ChangeOrderId'),
}

model DescribeChangeOrderResponseBody = {
  code?: string(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    approvalId?: string(name='ApprovalId'),
    auto?: boolean(name='Auto'),
    batchCount?: int32(name='BatchCount'),
    batchType?: string(name='BatchType'),
    batchWaitTime?: int32(name='BatchWaitTime'),
    changeOrderId?: string(name='ChangeOrderId'),
    coType?: string(name='CoType'),
    coTypeCode?: string(name='CoTypeCode'),
    createTime?: string(name='CreateTime'),
    currentPipelineId?: string(name='CurrentPipelineId'),
    description?: string(name='Description'),
    errorMessage?: string(name='ErrorMessage'),
    pipelines?: [ 
      {
        batchType?: int32(name='BatchType'),
        parallelCount?: int32(name='ParallelCount'),
        pipelineId?: string(name='PipelineId'),
        pipelineName?: string(name='PipelineName'),
        startTime?: long(name='StartTime'),
        status?: int32(name='Status'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='Pipelines'),
    status?: int32(name='Status'),
    subStatus?: int32(name='SubStatus'),
    supportRollback?: boolean(name='SupportRollback'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeChangeOrderResponseBody(name='body'),
}

async function describeChangeOrder(request: DescribeChangeOrderRequest): DescribeChangeOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeChangeOrderWithOptions(request, headers, runtime);
}

async function describeChangeOrderWithOptions(request: DescribeChangeOrderRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeChangeOrderResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.changeOrderId)) {
    query['ChangeOrderId'] = request.changeOrderId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeChangeOrder',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/changeorder/DescribeChangeOrder`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeComponentsRequest {
  appId?: string(name='AppId'),
  type?: string(name='Type'),
}

model DescribeComponentsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      componentDescription?: string(name='ComponentDescription'),
      componentKey?: string(name='ComponentKey'),
      expired?: boolean(name='Expired'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeComponentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeComponentsResponseBody(name='body'),
}

async function describeComponents(request: DescribeComponentsRequest): DescribeComponentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeComponentsWithOptions(request, headers, runtime);
}

async function describeComponentsWithOptions(request: DescribeComponentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeComponentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeComponents',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/resource/components`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeConfigMapRequest {
  configMapId?: long(name='ConfigMapId'),
}

model DescribeConfigMapResponseBody = {
  code?: string(name='Code'),
  data?: {
    configMapId?: long(name='ConfigMapId'),
    createTime?: long(name='CreateTime'),
    data?: map[string]any(name='Data'),
    description?: string(name='Description'),
    name?: string(name='Name'),
    namespaceId?: string(name='NamespaceId'),
    relateApps?: [ 
      {
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
      }
    ](name='RelateApps'),
    updateTime?: long(name='UpdateTime'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeConfigMapResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeConfigMapResponseBody(name='body'),
}

async function describeConfigMap(request: DescribeConfigMapRequest): DescribeConfigMapResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeConfigMapWithOptions(request, headers, runtime);
}

async function describeConfigMapWithOptions(request: DescribeConfigMapRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeConfigMapResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.configMapId)) {
    query['ConfigMapId'] = request.configMapId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConfigMap',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/configmap/configMap`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeConfigurationPriceRequest {
  cpu?: int32(name='Cpu'),
  memory?: int32(name='Memory'),
  workload?: string(name='Workload'),
}

model DescribeConfigurationPriceResponseBody = {
  code?: string(name='Code'),
  data?: {
    bagUsage?: {
      cpu?: float(name='Cpu'),
      mem?: float(name='Mem'),
    }(name='BagUsage'),
    order?: {
      discountAmount?: float(name='DiscountAmount'),
      originalAmount?: float(name='OriginalAmount'),
      ruleIds?: [ string ](name='RuleIds'),
      tradeAmount?: float(name='TradeAmount'),
    }(name='Order'),
    rules?: [ 
      {
        name?: string(name='Name'),
        ruleDescId?: long(name='RuleDescId'),
      }
    ](name='Rules'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeConfigurationPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeConfigurationPriceResponseBody(name='body'),
}

async function describeConfigurationPrice(request: DescribeConfigurationPriceRequest): DescribeConfigurationPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeConfigurationPriceWithOptions(request, headers, runtime);
}

async function describeConfigurationPriceWithOptions(request: DescribeConfigurationPriceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeConfigurationPriceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.cpu)) {
    query['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.memory)) {
    query['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.workload)) {
    query['Workload'] = request.workload;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConfigurationPrice',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/paas/configurationPrice`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeEdasContainersResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      disabled?: boolean(name='Disabled'),
      edasContainerVersion?: string(name='EdasContainerVersion'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeEdasContainersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEdasContainersResponseBody(name='body'),
}

async function describeEdasContainers(): DescribeEdasContainersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeEdasContainersWithOptions(headers, runtime);
}

async function describeEdasContainersWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeEdasContainersResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeEdasContainers',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/resource/edasContainers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeGreyTagRouteRequest {
  greyTagRouteId?: long(name='GreyTagRouteId'),
}

model DescribeGreyTagRouteResponseBody = {
  code?: string(name='Code'),
  data?: {
    albRules?: [ 
      {
        condition?: string(name='condition'),
        ingressId?: string(name='ingressId'),
        items?: [ 
          {
            cond?: string(name='cond'),
            expr?: string(name='expr'),
            index?: int32(name='index'),
            name?: string(name='name'),
            operator?: string(name='operator'),
            type?: string(name='type'),
            value?: string(name='value'),
          }
        ](name='items'),
        serviceId?: string(name='serviceId'),
      }
    ](name='AlbRules'),
    appId?: string(name='AppId'),
    createTime?: long(name='CreateTime'),
    description?: string(name='Description'),
    dubboRules?: [ 
      {
        condition?: string(name='condition'),
        group?: string(name='group'),
        items?: [ 
          {
            cond?: string(name='cond'),
            expr?: string(name='expr'),
            index?: int32(name='index'),
            name?: string(name='name'),
            operator?: string(name='operator'),
            type?: string(name='type'),
            value?: string(name='value'),
          }
        ](name='items'),
        methodName?: string(name='methodName'),
        serviceName?: string(name='serviceName'),
        version?: string(name='version'),
      }
    ](name='DubboRules'),
    greyTagRouteId?: long(name='GreyTagRouteId'),
    name?: string(name='Name'),
    scRules?: [ 
      {
        condition?: string(name='condition'),
        items?: [ 
          {
            cond?: string(name='cond'),
            expr?: string(name='expr'),
            index?: int32(name='index'),
            name?: string(name='name'),
            operator?: string(name='operator'),
            type?: string(name='type'),
            value?: string(name='value'),
          }
        ](name='items'),
        path?: string(name='path'),
      }
    ](name='ScRules'),
    updateTime?: long(name='UpdateTime'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeGreyTagRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGreyTagRouteResponseBody(name='body'),
}

async function describeGreyTagRoute(request: DescribeGreyTagRouteRequest): DescribeGreyTagRouteResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeGreyTagRouteWithOptions(request, headers, runtime);
}

async function describeGreyTagRouteWithOptions(request: DescribeGreyTagRouteRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeGreyTagRouteResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.greyTagRouteId)) {
    query['GreyTagRouteId'] = request.greyTagRouteId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGreyTagRoute',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/tagroute/greyTagRoute`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeIngressRequest {
  ingressId?: long(name='IngressId'),
}

model DescribeIngressResponseBody = {
  code?: string(name='Code'),
  data?: {
    certId?: string(name='CertId'),
    defaultRule?: {
      appId?: string(name='AppId'),
      appName?: string(name='AppName'),
      backendProtocol?: string(name='BackendProtocol'),
      containerPort?: int32(name='ContainerPort'),
    }(name='DefaultRule'),
    description?: string(name='Description'),
    id?: long(name='Id'),
    listenerPort?: int32(name='ListenerPort'),
    listenerProtocol?: string(name='ListenerProtocol'),
    loadBalanceType?: string(name='LoadBalanceType'),
    name?: string(name='Name'),
    namespaceId?: string(name='NamespaceId'),
    rules?: [ 
      {
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        backendProtocol?: string(name='BackendProtocol'),
        containerPort?: int32(name='ContainerPort'),
        domain?: string(name='Domain'),
        path?: string(name='Path'),
      }
    ](name='Rules'),
    slbId?: string(name='SlbId'),
    slbType?: string(name='SlbType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeIngressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIngressResponseBody(name='body'),
}

async function describeIngress(request: DescribeIngressRequest): DescribeIngressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeIngressWithOptions(request, headers, runtime);
}

async function describeIngressWithOptions(request: DescribeIngressRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeIngressResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.ingressId)) {
    query['IngressId'] = request.ingressId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIngress',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/ingress/Ingress`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeInstanceLogRequest {
  instanceId?: string(name='InstanceId'),
}

model DescribeInstanceLogResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeInstanceLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceLogResponseBody(name='body'),
}

async function describeInstanceLog(request: DescribeInstanceLogRequest): DescribeInstanceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeInstanceLogWithOptions(request, headers, runtime);
}

async function describeInstanceLogWithOptions(request: DescribeInstanceLogRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeInstanceLogResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceLog',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/instance/describeInstanceLog`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeInstanceSpecificationsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      cpu?: int32(name='Cpu'),
      enable?: boolean(name='Enable'),
      id?: int32(name='Id'),
      memory?: int32(name='Memory'),
      specInfo?: string(name='SpecInfo'),
      version?: int32(name='Version'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeInstanceSpecificationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceSpecificationsResponseBody(name='body'),
}

async function describeInstanceSpecifications(): DescribeInstanceSpecificationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeInstanceSpecificationsWithOptions(headers, runtime);
}

async function describeInstanceSpecificationsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeInstanceSpecificationsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceSpecifications',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/paas/quota/instanceSpecifications`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeJobRequest {
  appId?: string(name='AppId'),
  jobId?: string(name='JobId'),
  versionId?: string(name='VersionId'),
}

model DescribeJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    acrAssumeRoleArn?: string(name='AcrAssumeRoleArn'),
    appDescription?: string(name='AppDescription'),
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    associateEip?: boolean(name='AssociateEip'),
    backoffLimit?: long(name='BackoffLimit'),
    batchWaitTime?: int32(name='BatchWaitTime'),
    command?: string(name='Command'),
    commandArgs?: string(name='CommandArgs'),
    concurrencyPolicy?: string(name='ConcurrencyPolicy'),
    configMapMountDesc?: [ 
      {
        configMapId?: long(name='ConfigMapId'),
        configMapName?: string(name='ConfigMapName'),
        key?: string(name='Key'),
        mountPath?: string(name='MountPath'),
      }
    ](name='ConfigMapMountDesc'),
    cpu?: int32(name='Cpu'),
    customHostAlias?: string(name='CustomHostAlias'),
    edasContainerVersion?: string(name='EdasContainerVersion'),
    enableAhas?: string(name='EnableAhas'),
    enableGreyTagRoute?: boolean(name='EnableGreyTagRoute'),
    envs?: string(name='Envs'),
    imagePullSecrets?: string(name='ImagePullSecrets'),
    imageUrl?: string(name='ImageUrl'),
    jarStartArgs?: string(name='JarStartArgs'),
    jarStartOptions?: string(name='JarStartOptions'),
    jdk?: string(name='Jdk'),
    liveness?: string(name='Liveness'),
    memory?: int32(name='Memory'),
    minReadyInstances?: int32(name='MinReadyInstances'),
    mountDesc?: [ 
      {
        mountPath?: string(name='MountPath'),
        nasPath?: string(name='NasPath'),
      }
    ](name='MountDesc'),
    mountHost?: string(name='MountHost'),
    mseApplicationId?: string(name='MseApplicationId'),
    namespaceId?: string(name='NamespaceId'),
    nasConfigs?: string(name='NasConfigs'),
    nasId?: string(name='NasId'),
    ossAkId?: string(name='OssAkId'),
    ossAkSecret?: string(name='OssAkSecret'),
    ossMountDescs?: [ 
      {
        bucketName?: string(name='bucketName'),
        bucketPath?: string(name='bucketPath'),
        mountPath?: string(name='mountPath'),
        readOnly?: boolean(name='readOnly'),
      }
    ](name='OssMountDescs'),
    packageType?: string(name='PackageType'),
    packageUrl?: string(name='PackageUrl'),
    packageVersion?: string(name='PackageVersion'),
    phpArmsConfigLocation?: string(name='PhpArmsConfigLocation'),
    phpConfig?: string(name='PhpConfig'),
    phpConfigLocation?: string(name='PhpConfigLocation'),
    postStart?: string(name='PostStart'),
    preStop?: string(name='PreStop'),
    programmingLanguage?: string(name='ProgrammingLanguage'),
    publicWebHookUrls?: [ string ](name='PublicWebHookUrls'),
    python?: string(name='Python'),
    pythonModules?: string(name='PythonModules'),
    readiness?: string(name='Readiness'),
    refAppId?: string(name='RefAppId'),
    refedAppIds?: [ string ](name='RefedAppIds'),
    regionId?: string(name='RegionId'),
    replicas?: int32(name='Replicas'),
    securityGroupId?: string(name='SecurityGroupId'),
    slice?: boolean(name='Slice'),
    sliceEnvs?: string(name='SliceEnvs'),
    slsConfigs?: string(name='SlsConfigs'),
    suspend?: boolean(name='Suspend'),
    tags?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='Tags'),
    terminationGracePeriodSeconds?: int32(name='TerminationGracePeriodSeconds'),
    timeout?: long(name='Timeout'),
    timezone?: string(name='Timezone'),
    tomcatConfig?: string(name='TomcatConfig'),
    triggerConfig?: string(name='TriggerConfig'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
    vpcWebHookUrls?: [ string ](name='VpcWebHookUrls'),
    warStartOptions?: string(name='WarStartOptions'),
    webContainer?: string(name='WebContainer'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeJobResponseBody(name='body'),
}

async function describeJob(request: DescribeJobRequest): DescribeJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeJobWithOptions(request, headers, runtime);
}

async function describeJobWithOptions(request: DescribeJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeJobResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeJob',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/job/describeJob`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeJobHistoryRequest {
  appId?: string(name='AppId'),
  currentPage?: long(name='CurrentPage'),
  pageSize?: long(name='PageSize'),
  state?: string(name='State'),
}

model DescribeJobHistoryResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: long(name='CurrentPage'),
    jobs?: [ 
      {
        active?: long(name='Active'),
        completionTime?: long(name='CompletionTime'),
        failed?: long(name='Failed'),
        jobId?: string(name='JobId'),
        message?: string(name='Message'),
        startTime?: long(name='StartTime'),
        state?: string(name='State'),
        succeeded?: long(name='Succeeded'),
      }
    ](name='Jobs'),
    pageSize?: long(name='PageSize'),
    totalSize?: long(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeJobHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeJobHistoryResponseBody(name='body'),
}

async function describeJobHistory(request: DescribeJobHistoryRequest): DescribeJobHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeJobHistoryWithOptions(request, headers, runtime);
}

async function describeJobHistoryWithOptions(request: DescribeJobHistoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeJobHistoryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeJobHistory',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/job/describeJobHistory`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeJobStatusRequest {
  appId?: string(name='AppId'),
  jobId?: string(name='JobId'),
}

model DescribeJobStatusResponseBody = {
  code?: string(name='Code'),
  data?: {
    active?: long(name='Active'),
    completionTime?: long(name='CompletionTime'),
    failed?: long(name='Failed'),
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    startTime?: long(name='StartTime'),
    state?: string(name='State'),
    succeeded?: long(name='Succeeded'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeJobStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeJobStatusResponseBody(name='body'),
}

async function describeJobStatus(request: DescribeJobStatusRequest): DescribeJobStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeJobStatusWithOptions(request, headers, runtime);
}

async function describeJobStatusWithOptions(request: DescribeJobStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeJobStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeJobStatus',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/job/describeJobStatus`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeNamespaceRequest {
  namespaceId?: string(name='NamespaceId'),
}

model DescribeNamespaceResponseBody = {
  code?: string(name='Code'),
  data?: {
    namespaceDescription?: string(name='NamespaceDescription'),
    namespaceId?: string(name='NamespaceId'),
    namespaceName?: string(name='NamespaceName'),
    regionId?: string(name='RegionId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNamespaceResponseBody(name='body'),
}

async function describeNamespace(request: DescribeNamespaceRequest): DescribeNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeNamespaceWithOptions(request, headers, runtime);
}

async function describeNamespaceWithOptions(request: DescribeNamespaceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeNamespaceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNamespace',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/paas/namespace`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeNamespaceListRequest {
  containCustom?: boolean(name='ContainCustom'),
  hybridCloudExclude?: boolean(name='HybridCloudExclude'),
}

model DescribeNamespaceListResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      agentInstall?: string(name='AgentInstall'),
      current?: boolean(name='Current'),
      custom?: boolean(name='Custom'),
      hybridCloudEnable?: boolean(name='HybridCloudEnable'),
      namespaceId?: string(name='NamespaceId'),
      namespaceName?: string(name='NamespaceName'),
      regionId?: string(name='RegionId'),
      securityGroupId?: string(name='SecurityGroupId'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeNamespaceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNamespaceListResponseBody(name='body'),
}

async function describeNamespaceList(request: DescribeNamespaceListRequest): DescribeNamespaceListResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeNamespaceListWithOptions(request, headers, runtime);
}

async function describeNamespaceListWithOptions(request: DescribeNamespaceListRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeNamespaceListResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.containCustom)) {
    query['ContainCustom'] = request.containCustom;
  }
  if (!Util.isUnset(request.hybridCloudExclude)) {
    query['HybridCloudExclude'] = request.hybridCloudExclude;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNamespaceList',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/namespace/describeNamespaceList`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeNamespaceResourcesRequest {
  namespaceId?: string(name='NamespaceId'),
}

model DescribeNamespaceResourcesResponseBody = {
  code?: string(name='Code'),
  data?: {
    appCount?: long(name='AppCount'),
    belongRegion?: string(name='BelongRegion'),
    description?: string(name='Description'),
    jumpServerAppId?: string(name='JumpServerAppId'),
    jumpServerIp?: string(name='JumpServerIp'),
    lastChangeOrderId?: string(name='LastChangeOrderId'),
    lastChangeOrderRunning?: boolean(name='LastChangeOrderRunning'),
    lastChangeOrderStatus?: string(name='LastChangeOrderStatus'),
    namespaceId?: string(name='NamespaceId'),
    namespaceName?: string(name='NamespaceName'),
    notificationExpired?: boolean(name='NotificationExpired'),
    securityGroupId?: string(name='SecurityGroupId'),
    tenantId?: string(name='TenantId'),
    userId?: string(name='UserId'),
    vSwitchId?: string(name='VSwitchId'),
    vSwitchName?: string(name='VSwitchName'),
    vpcId?: string(name='VpcId'),
    vpcName?: string(name='VpcName'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeNamespaceResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNamespaceResourcesResponseBody(name='body'),
}

async function describeNamespaceResources(request: DescribeNamespaceResourcesRequest): DescribeNamespaceResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeNamespaceResourcesWithOptions(request, headers, runtime);
}

async function describeNamespaceResourcesWithOptions(request: DescribeNamespaceResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeNamespaceResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNamespaceResources',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/namespace/describeNamespaceResources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeNamespacesRequest {
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model DescribeNamespacesResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    namespaces?: [ 
      {
        accessKey?: string(name='AccessKey'),
        addressServerHost?: string(name='AddressServerHost'),
        namespaceDescription?: string(name='NamespaceDescription'),
        namespaceId?: string(name='NamespaceId'),
        namespaceName?: string(name='NamespaceName'),
        regionId?: string(name='RegionId'),
        secretKey?: string(name='SecretKey'),
        tenantId?: string(name='TenantId'),
      }
    ](name='Namespaces'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeNamespacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNamespacesResponseBody(name='body'),
}

async function describeNamespaces(request: DescribeNamespacesRequest): DescribeNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeNamespacesWithOptions(request, headers, runtime);
}

async function describeNamespacesWithOptions(request: DescribeNamespacesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeNamespacesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNamespaces',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/paas/namespaces`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribePipelineRequest {
  pipelineId?: string(name='PipelineId'),
}

model DescribePipelineResponseBody = {
  code?: string(name='Code'),
  data?: {
    coStatus?: string(name='CoStatus'),
    currentStageId?: string(name='CurrentStageId'),
    nextPipelineId?: string(name='NextPipelineId'),
    pipelineId?: string(name='PipelineId'),
    pipelineName?: string(name='PipelineName'),
    pipelineStatus?: int32(name='PipelineStatus'),
    showBatch?: boolean(name='ShowBatch'),
    stageList?: [ 
      {
        executorType?: int32(name='ExecutorType'),
        stageId?: string(name='StageId'),
        stageName?: string(name='StageName'),
        status?: int32(name='Status'),
        taskList?: [ 
          {
            errorCode?: string(name='ErrorCode'),
            errorIgnore?: int32(name='ErrorIgnore'),
            errorMessage?: string(name='ErrorMessage'),
            message?: string(name='Message'),
            showManualIgnore?: boolean(name='ShowManualIgnore'),
            stageId?: string(name='StageId'),
            status?: int32(name='Status'),
            taskId?: string(name='TaskId'),
            taskName?: string(name='TaskName'),
          }
        ](name='TaskList'),
      }
    ](name='StageList'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribePipelineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePipelineResponseBody(name='body'),
}

async function describePipeline(request: DescribePipelineRequest): DescribePipelineResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describePipelineWithOptions(request, headers, runtime);
}

async function describePipelineWithOptions(request: DescribePipelineRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribePipelineResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pipelineId)) {
    query['PipelineId'] = request.pipelineId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePipeline',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/changeorder/DescribePipeline`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeRegionsResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName'),
      recommendZones?: {
        recommendZone?: [ string ](name='RecommendZone')
      }(name='RecommendZones'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(headers, runtime);
}

async function describeRegionsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/paas/regionConfig`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeSecretRequest {
  namespaceId?: string(name='NamespaceId'),
  secretId?: long(name='SecretId'),
}

model DescribeSecretResponseBody = {
  code?: string(name='Code'),
  data?: {
    createTime?: long(name='CreateTime'),
    namespaceId?: string(name='NamespaceId'),
    relateApps?: [ 
      {
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
      }
    ](name='RelateApps'),
    secretData?: map[string]string(name='SecretData'),
    secretId?: long(name='SecretId'),
    secretName?: string(name='SecretName'),
    secretType?: string(name='SecretType'),
    updateTime?: long(name='UpdateTime'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecretResponseBody(name='body'),
}

async function describeSecret(request: DescribeSecretRequest): DescribeSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSecretWithOptions(request, headers, runtime);
}

async function describeSecretWithOptions(request: DescribeSecretRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeSecretResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.secretId)) {
    query['SecretId'] = request.secretId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecret',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/secret/secret`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DisableApplicationScalingRuleRequest {
  appId?: string(name='AppId'),
  scalingRuleName?: string(name='ScalingRuleName'),
}

model DisableApplicationScalingRuleResponseBody = {
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model DisableApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableApplicationScalingRuleResponseBody(name='body'),
}

async function disableApplicationScalingRule(request: DisableApplicationScalingRuleRequest): DisableApplicationScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return disableApplicationScalingRuleWithOptions(request, headers, runtime);
}

async function disableApplicationScalingRuleWithOptions(request: DisableApplicationScalingRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DisableApplicationScalingRuleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.scalingRuleName)) {
    query['ScalingRuleName'] = request.scalingRuleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableApplicationScalingRule',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/scale/disableApplicationScalingRule`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model EnableApplicationScalingRuleRequest {
  appId?: string(name='AppId'),
  scalingRuleName?: string(name='ScalingRuleName'),
}

model EnableApplicationScalingRuleResponseBody = {
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model EnableApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableApplicationScalingRuleResponseBody(name='body'),
}

async function enableApplicationScalingRule(request: EnableApplicationScalingRuleRequest): EnableApplicationScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableApplicationScalingRuleWithOptions(request, headers, runtime);
}

async function enableApplicationScalingRuleWithOptions(request: EnableApplicationScalingRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): EnableApplicationScalingRuleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.scalingRuleName)) {
    query['ScalingRuleName'] = request.scalingRuleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableApplicationScalingRule',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/scale/enableApplicationScalingRule`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ExecJobRequest {
  appId?: string(name='AppId'),
  command?: string(name='Command'),
  commandArgs?: string(name='CommandArgs'),
  envs?: string(name='Envs'),
  eventId?: string(name='EventId'),
  jarStartArgs?: string(name='JarStartArgs'),
  jarStartOptions?: string(name='JarStartOptions'),
  time?: string(name='Time'),
  warStartOptions?: string(name='WarStartOptions'),
}

model ExecJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    msg?: string(name='Msg'),
    success?: string(name='Success'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ExecJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecJobResponseBody(name='body'),
}

async function execJob(request: ExecJobRequest): ExecJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return execJobWithOptions(request, headers, runtime);
}

async function execJobWithOptions(request: ExecJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ExecJobResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.command)) {
    query['Command'] = request.command;
  }
  if (!Util.isUnset(request.commandArgs)) {
    query['CommandArgs'] = request.commandArgs;
  }
  if (!Util.isUnset(request.envs)) {
    query['Envs'] = request.envs;
  }
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.jarStartArgs)) {
    query['JarStartArgs'] = request.jarStartArgs;
  }
  if (!Util.isUnset(request.jarStartOptions)) {
    query['JarStartOptions'] = request.jarStartOptions;
  }
  if (!Util.isUnset(request.time)) {
    query['Time'] = request.time;
  }
  if (!Util.isUnset(request.warStartOptions)) {
    query['WarStartOptions'] = request.warStartOptions;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecJob',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/job/execJob`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetJobHistoryRequest {
  appId?: string(name='AppId'),
  currentPage?: long(name='CurrentPage'),
  pageSize?: long(name='PageSize'),
}

model GetJobHistoryResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: long(name='CurrentPage'),
    jobs?: [ 
      {
        active?: long(name='Active'),
        completionTime?: long(name='CompletionTime'),
        failed?: long(name='Failed'),
        jobId?: string(name='JobId'),
        message?: string(name='Message'),
        startTime?: long(name='StartTime'),
        succeeded?: long(name='Succeeded'),
      }
    ](name='Jobs'),
    pageSize?: long(name='PageSize'),
    totalSize?: long(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model GetJobHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJobHistoryResponseBody(name='body'),
}

async function getJobHistory(request: GetJobHistoryRequest): GetJobHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getJobHistoryWithOptions(request, headers, runtime);
}

async function getJobHistoryWithOptions(request: GetJobHistoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetJobHistoryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJobHistory',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/job/getJobHistory`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAppEventsRequest {
  appId?: string(name='AppId'),
  currentPage?: int32(name='CurrentPage'),
  eventType?: string(name='EventType'),
  namespace?: string(name='Namespace'),
  objectKind?: string(name='ObjectKind'),
  objectName?: string(name='ObjectName'),
  pageSize?: int32(name='PageSize'),
  reason?: string(name='Reason'),
}

model ListAppEventsResponseBody = {
  code?: string(name='Code'),
  data?: {
    appEventEntity?: [ 
      {
        eventType?: string(name='EventType'),
        firstTimestamp?: string(name='FirstTimestamp'),
        lastTimestamp?: string(name='LastTimestamp'),
        message?: string(name='Message'),
        objectKind?: string(name='ObjectKind'),
        objectName?: string(name='ObjectName'),
        reason?: string(name='Reason'),
      }
    ](name='AppEventEntity'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAppEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAppEventsResponseBody(name='body'),
}

async function listAppEvents(request: ListAppEventsRequest): ListAppEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAppEventsWithOptions(request, headers, runtime);
}

async function listAppEventsWithOptions(request: ListAppEventsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAppEventsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.objectKind)) {
    query['ObjectKind'] = request.objectKind;
  }
  if (!Util.isUnset(request.objectName)) {
    query['ObjectName'] = request.objectName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAppEvents',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/listAppEvents`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAppServicesPageRequest {
  appId?: string(name='AppId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  serviceType?: string(name='ServiceType'),
}

model ListAppServicesPageResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      currentPage?: string(name='CurrentPage'),
      pageNumber?: string(name='PageNumber'),
      pageSize?: string(name='PageSize'),
      result?: [ 
        {
          edasAppId?: string(name='EdasAppId'),
          edasAppName?: string(name='EdasAppName'),
          group?: string(name='Group'),
          instanceNum?: long(name='InstanceNum'),
          serviceName?: string(name='ServiceName'),
          version?: string(name='Version'),
        }
      ](name='Result'),
      totalSize?: string(name='TotalSize'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListAppServicesPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAppServicesPageResponseBody(name='body'),
}

async function listAppServicesPage(request: ListAppServicesPageRequest): ListAppServicesPageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAppServicesPageWithOptions(request, headers, runtime);
}

async function listAppServicesPageWithOptions(request: ListAppServicesPageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAppServicesPageResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['ServiceType'] = request.serviceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAppServicesPage',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/service/listAppServicesPage`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListAppVersionsRequest {
  appId?: string(name='AppId'),
}

model ListAppVersionsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      buildPackageUrl?: string(name='BuildPackageUrl'),
      createTime?: string(name='CreateTime'),
      id?: string(name='Id'),
      type?: string(name='Type'),
      warUrl?: string(name='WarUrl'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAppVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAppVersionsResponseBody(name='body'),
}

async function listAppVersions(request: ListAppVersionsRequest): ListAppVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAppVersionsWithOptions(request, headers, runtime);
}

async function listAppVersionsWithOptions(request: ListAppVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAppVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAppVersions',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/listAppVersions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListApplicationsRequest {
  appName?: string(name='AppName'),
  currentPage?: int32(name='CurrentPage'),
  fieldType?: string(name='FieldType'),
  fieldValue?: string(name='FieldValue'),
  namespaceId?: string(name='NamespaceId'),
  orderBy?: string(name='OrderBy'),
  pageSize?: int32(name='PageSize'),
  reverse?: boolean(name='Reverse'),
  tags?: string(name='Tags'),
}

model ListApplicationsResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  data?: {
    applications?: [ 
      {
        appDeletingStatus?: boolean(name='AppDeletingStatus'),
        appDescription?: string(name='AppDescription'),
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        instances?: int32(name='Instances'),
        namespaceId?: string(name='NamespaceId'),
        regionId?: string(name='RegionId'),
        runningInstances?: int32(name='RunningInstances'),
        tags?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Tags'),
      }
    ](name='Applications'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalSize?: int32(name='TotalSize'),
}

model ListApplicationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListApplicationsResponseBody(name='body'),
}

async function listApplications(request: ListApplicationsRequest): ListApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listApplicationsWithOptions(request, headers, runtime);
}

async function listApplicationsWithOptions(request: ListApplicationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListApplicationsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.fieldType)) {
    query['FieldType'] = request.fieldType;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.reverse)) {
    query['Reverse'] = request.reverse;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApplications',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/listApplications`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListChangeOrdersRequest {
  appId?: string(name='AppId'),
  coStatus?: string(name='CoStatus'),
  coType?: string(name='CoType'),
  currentPage?: int32(name='CurrentPage'),
  key?: string(name='Key'),
  pageSize?: int32(name='PageSize'),
}

model ListChangeOrdersResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderList?: [ 
      {
        appId?: string(name='AppId'),
        batchCount?: int32(name='BatchCount'),
        batchType?: string(name='BatchType'),
        changeOrderId?: string(name='ChangeOrderId'),
        coType?: string(name='CoType'),
        coTypeCode?: string(name='CoTypeCode'),
        createTime?: string(name='CreateTime'),
        createUserId?: string(name='CreateUserId'),
        description?: string(name='Description'),
        finishTime?: string(name='FinishTime'),
        groupId?: string(name='GroupId'),
        source?: string(name='Source'),
        status?: int32(name='Status'),
        userId?: string(name='UserId'),
      }
    ](name='ChangeOrderList'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListChangeOrdersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListChangeOrdersResponseBody(name='body'),
}

async function listChangeOrders(request: ListChangeOrdersRequest): ListChangeOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listChangeOrdersWithOptions(request, headers, runtime);
}

async function listChangeOrdersWithOptions(request: ListChangeOrdersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListChangeOrdersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.coStatus)) {
    query['CoStatus'] = request.coStatus;
  }
  if (!Util.isUnset(request.coType)) {
    query['CoType'] = request.coType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListChangeOrders',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/changeorder/ListChangeOrders`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListConsumedServicesRequest {
  appId?: string(name='AppId'),
}

model ListConsumedServicesResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      appId?: string(name='AppId'),
      group2Ip?: string(name='Group2Ip'),
      groups?: [ string ](name='Groups'),
      ips?: [ string ](name='Ips'),
      name?: string(name='Name'),
      type?: string(name='Type'),
      version?: string(name='Version'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListConsumedServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConsumedServicesResponseBody(name='body'),
}

async function listConsumedServices(request: ListConsumedServicesRequest): ListConsumedServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listConsumedServicesWithOptions(request, headers, runtime);
}

async function listConsumedServicesWithOptions(request: ListConsumedServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListConsumedServicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConsumedServices',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/service/listConsumedServices`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListGreyTagRouteRequest {
  appId?: string(name='AppId'),
}

model ListGreyTagRouteResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        albRules?: [ 
          {
            condition?: string(name='condition'),
            ingressId?: string(name='ingressId'),
            items?: [ 
              {
                cond?: string(name='cond'),
                expr?: string(name='expr'),
                index?: int32(name='index'),
                name?: string(name='name'),
                operator?: string(name='operator'),
                type?: string(name='type'),
                value?: string(name='value'),
              }
            ](name='items'),
            serviceId?: string(name='serviceId'),
          }
        ](name='AlbRules'),
        createTime?: long(name='CreateTime'),
        description?: string(name='Description'),
        dubboRules?: [ 
          {
            condition?: string(name='condition'),
            group?: string(name='group'),
            items?: [ 
              {
                cond?: string(name='cond'),
                expr?: string(name='expr'),
                index?: int32(name='index'),
                name?: string(name='name'),
                operator?: string(name='operator'),
                type?: string(name='type'),
                value?: string(name='value'),
              }
            ](name='items'),
            methodName?: string(name='methodName'),
            serviceName?: string(name='serviceName'),
            version?: string(name='version'),
          }
        ](name='DubboRules'),
        greyTagRouteId?: long(name='GreyTagRouteId'),
        name?: string(name='Name'),
        scRules?: [ 
          {
            condition?: string(name='condition'),
            items?: [ 
              {
                cond?: string(name='cond'),
                expr?: string(name='expr'),
                index?: int32(name='index'),
                name?: string(name='name'),
                operator?: string(name='operator'),
                type?: string(name='type'),
                value?: string(name='value'),
              }
            ](name='items'),
            path?: string(name='path'),
          }
        ](name='ScRules'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='Result'),
    totalSize?: long(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListGreyTagRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGreyTagRouteResponseBody(name='body'),
}

async function listGreyTagRoute(request: ListGreyTagRouteRequest): ListGreyTagRouteResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGreyTagRouteWithOptions(request, headers, runtime);
}

async function listGreyTagRouteWithOptions(request: ListGreyTagRouteRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGreyTagRouteResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGreyTagRoute',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/tagroute/greyTagRouteList`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListIngressesRequest {
  appId?: string(name='AppId'),
  namespaceId?: string(name='NamespaceId'),
}

model ListIngressesResponseBody = {
  code?: string(name='Code'),
  data?: {
    ingressList?: [ 
      {
        certId?: string(name='CertId'),
        description?: string(name='Description'),
        id?: long(name='Id'),
        listenerPort?: string(name='ListenerPort'),
        listenerProtocol?: string(name='ListenerProtocol'),
        loadBalanceType?: string(name='LoadBalanceType'),
        name?: string(name='Name'),
        namespaceId?: string(name='NamespaceId'),
        slbId?: string(name='SlbId'),
        slbType?: string(name='SlbType'),
      }
    ](name='IngressList'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListIngressesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIngressesResponseBody(name='body'),
}

async function listIngresses(request: ListIngressesRequest): ListIngressesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIngressesWithOptions(request, headers, runtime);
}

async function listIngressesWithOptions(request: ListIngressesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListIngressesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIngresses',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/ingress/IngressList`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListJobsRequest {
  appName?: string(name='AppName'),
  currentPage?: int32(name='CurrentPage'),
  fieldType?: string(name='FieldType'),
  fieldValue?: string(name='FieldValue'),
  namespaceId?: string(name='NamespaceId'),
  orderBy?: string(name='OrderBy'),
  pageSize?: int32(name='PageSize'),
  reverse?: boolean(name='Reverse'),
  tags?: string(name='Tags'),
  workload?: string(name='Workload'),
}

model ListJobsResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  data?: {
    applications?: [ 
      {
        active?: long(name='Active'),
        appDeletingStatus?: boolean(name='AppDeletingStatus'),
        appDescription?: string(name='AppDescription'),
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        completionTime?: long(name='CompletionTime'),
        failed?: long(name='Failed'),
        instances?: int32(name='Instances'),
        lastChangeorderState?: string(name='LastChangeorderState'),
        lastJobState?: string(name='LastJobState'),
        lastStartTime?: long(name='LastStartTime'),
        namespaceId?: string(name='NamespaceId'),
        regionId?: string(name='RegionId'),
        runningInstances?: int32(name='RunningInstances'),
        succeeded?: long(name='Succeeded'),
        suspend?: boolean(name='Suspend'),
        tags?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Tags'),
        triggerConfig?: string(name='TriggerConfig'),
      }
    ](name='Applications'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalSize?: int32(name='TotalSize'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listJobsWithOptions(request, headers, runtime);
}

async function listJobsWithOptions(request: ListJobsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.fieldType)) {
    query['FieldType'] = request.fieldType;
  }
  if (!Util.isUnset(request.fieldValue)) {
    query['FieldValue'] = request.fieldValue;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.reverse)) {
    query['Reverse'] = request.reverse;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.workload)) {
    query['Workload'] = request.workload;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/job/listJobs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListLogConfigsRequest {
  appId?: string(name='AppId'),
  currentPage?: int32(name='CurrentPage'),
  pageSize?: int32(name='PageSize'),
}

model ListLogConfigsResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    logConfigs?: [ 
      {
        configName?: string(name='ConfigName'),
        createTime?: string(name='CreateTime'),
        logDir?: string(name='LogDir'),
        logType?: string(name='LogType'),
        regionId?: string(name='RegionId'),
        slsLogStore?: string(name='SlsLogStore'),
        slsProject?: string(name='SlsProject'),
        storeType?: string(name='StoreType'),
      }
    ](name='LogConfigs'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListLogConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogConfigsResponseBody(name='body'),
}

async function listLogConfigs(request: ListLogConfigsRequest): ListLogConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogConfigsWithOptions(request, headers, runtime);
}

async function listLogConfigsWithOptions(request: ListLogConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogConfigs',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/log/listLogConfigs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListNamespaceChangeOrdersRequest {
  coStatus?: string(name='CoStatus'),
  coType?: string(name='CoType'),
  currentPage?: int32(name='CurrentPage'),
  key?: string(name='Key'),
  namespaceId?: string(name='NamespaceId'),
  pageSize?: int32(name='PageSize'),
}

model ListNamespaceChangeOrdersResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderList?: [ 
      {
        batchCount?: int32(name='BatchCount'),
        batchType?: string(name='BatchType'),
        changeOrderId?: string(name='ChangeOrderId'),
        coType?: string(name='CoType'),
        coTypeCode?: string(name='CoTypeCode'),
        createTime?: string(name='CreateTime'),
        createUserId?: string(name='CreateUserId'),
        description?: string(name='Description'),
        finishTime?: string(name='FinishTime'),
        groupId?: string(name='GroupId'),
        namespaceId?: string(name='NamespaceId'),
        pipelines?: string(name='Pipelines'),
        source?: string(name='Source'),
        status?: int32(name='Status'),
        userId?: string(name='UserId'),
      }
    ](name='ChangeOrderList'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListNamespaceChangeOrdersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNamespaceChangeOrdersResponseBody(name='body'),
}

async function listNamespaceChangeOrders(request: ListNamespaceChangeOrdersRequest): ListNamespaceChangeOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listNamespaceChangeOrdersWithOptions(request, headers, runtime);
}

async function listNamespaceChangeOrdersWithOptions(request: ListNamespaceChangeOrdersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListNamespaceChangeOrdersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.coStatus)) {
    query['CoStatus'] = request.coStatus;
  }
  if (!Util.isUnset(request.coType)) {
    query['CoType'] = request.coType;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNamespaceChangeOrders',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/changeorder/listNamespaceChangeOrders`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListNamespacedConfigMapsRequest {
  namespaceId?: string(name='NamespaceId'),
}

model ListNamespacedConfigMapsResponseBody = {
  code?: string(name='Code'),
  data?: {
    configMaps?: [ 
      {
        configMapId?: long(name='ConfigMapId'),
        createTime?: long(name='CreateTime'),
        data?: map[string]any(name='Data'),
        description?: string(name='Description'),
        name?: string(name='Name'),
        namespaceId?: string(name='NamespaceId'),
        relateApps?: [ 
          {
            appId?: string(name='AppId'),
            appName?: string(name='AppName'),
          }
        ](name='RelateApps'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='ConfigMaps'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListNamespacedConfigMapsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNamespacedConfigMapsResponseBody(name='body'),
}

async function listNamespacedConfigMaps(request: ListNamespacedConfigMapsRequest): ListNamespacedConfigMapsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listNamespacedConfigMapsWithOptions(request, headers, runtime);
}

async function listNamespacedConfigMapsWithOptions(request: ListNamespacedConfigMapsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListNamespacedConfigMapsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNamespacedConfigMaps',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/configmap/listNamespacedConfigMaps`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPublishedServicesRequest {
  appId?: string(name='AppId'),
}

model ListPublishedServicesResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      appId?: string(name='AppId'),
      group2Ip?: string(name='Group2Ip'),
      groups?: [ string ](name='Groups'),
      ips?: [ string ](name='Ips'),
      name?: string(name='Name'),
      type?: string(name='Type'),
      version?: string(name='Version'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListPublishedServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPublishedServicesResponseBody(name='body'),
}

async function listPublishedServices(request: ListPublishedServicesRequest): ListPublishedServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPublishedServicesWithOptions(request, headers, runtime);
}

async function listPublishedServicesWithOptions(request: ListPublishedServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPublishedServicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPublishedServices',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/service/listPublishedServices`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSecretsRequest {
  namespaceId?: string(name='NamespaceId'),
}

model ListSecretsResponseBody = {
  code?: string(name='Code'),
  data?: {
    secrets?: [ 
      {
        createTime?: long(name='CreateTime'),
        namespaceId?: string(name='NamespaceId'),
        relateApps?: [ 
          {
            appId?: string(name='AppId'),
            appName?: string(name='AppName'),
          }
        ](name='RelateApps'),
        secretId?: long(name='SecretId'),
        secretName?: string(name='SecretName'),
        secretType?: string(name='SecretType'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='Secrets'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListSecretsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSecretsResponseBody(name='body'),
}

async function listSecrets(request: ListSecretsRequest): ListSecretsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSecretsWithOptions(request, headers, runtime);
}

async function listSecretsWithOptions(request: ListSecretsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSecretsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSecrets',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/secret/secrets`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceIds?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tags?: string(name='Tags'),
}

model ListTagResourcesResponseBody = {
  code?: string(name='Code'),
  data?: {
    nextToken?: string(name='NextToken'),
    tagResources?: [ 
      {
        resourceId?: string(name='ResourceId'),
        resourceType?: string(name='ResourceType'),
        tagKey?: string(name='TagKey'),
        tagValue?: string(name='TagValue'),
      }
    ](name='TagResources'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTagResourcesWithOptions(request, headers, runtime);
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model OpenSaeServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenSaeServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenSaeServiceResponseBody(name='body'),
}

async function openSaeService(): OpenSaeServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return openSaeServiceWithOptions(headers, runtime);
}

async function openSaeServiceWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): OpenSaeServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'OpenSaeService',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/service/open`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryResourceStaticsRequest {
  appId?: string(name='AppId'),
}

model QueryResourceStaticsResponseBody = {
  code?: string(name='Code'),
  data?: {
    realTimeRes?: {
      cpu?: float(name='Cpu'),
      memory?: float(name='Memory'),
    }(name='RealTimeRes'),
    summary?: {
      cpu?: float(name='Cpu'),
      memory?: float(name='Memory'),
    }(name='Summary'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model QueryResourceStaticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryResourceStaticsResponseBody(name='body'),
}

async function queryResourceStatics(request: QueryResourceStaticsRequest): QueryResourceStaticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryResourceStaticsWithOptions(request, headers, runtime);
}

async function queryResourceStaticsWithOptions(request: QueryResourceStaticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryResourceStaticsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryResourceStatics',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/paas/quota/queryResourceStatics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ReduceApplicationCapacityByInstanceIdsRequest {
  appId?: string(name='AppId'),
  instanceIds?: string(name='InstanceIds'),
}

model ReduceApplicationCapacityByInstanceIdsResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ReduceApplicationCapacityByInstanceIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReduceApplicationCapacityByInstanceIdsResponseBody(name='body'),
}

async function reduceApplicationCapacityByInstanceIds(request: ReduceApplicationCapacityByInstanceIdsRequest): ReduceApplicationCapacityByInstanceIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return reduceApplicationCapacityByInstanceIdsWithOptions(request, headers, runtime);
}

async function reduceApplicationCapacityByInstanceIdsWithOptions(request: ReduceApplicationCapacityByInstanceIdsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ReduceApplicationCapacityByInstanceIdsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReduceApplicationCapacityByInstanceIds',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/ScaleInApplicationWithInstanceIds`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RescaleApplicationRequest {
  appId?: string(name='AppId'),
  autoEnableApplicationScalingRule?: boolean(name='AutoEnableApplicationScalingRule'),
  minReadyInstanceRatio?: int32(name='MinReadyInstanceRatio'),
  minReadyInstances?: int32(name='MinReadyInstances'),
  replicas?: int32(name='Replicas'),
}

model RescaleApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RescaleApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RescaleApplicationResponseBody(name='body'),
}

async function rescaleApplication(request: RescaleApplicationRequest): RescaleApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return rescaleApplicationWithOptions(request, headers, runtime);
}

async function rescaleApplicationWithOptions(request: RescaleApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RescaleApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.autoEnableApplicationScalingRule)) {
    query['AutoEnableApplicationScalingRule'] = request.autoEnableApplicationScalingRule;
  }
  if (!Util.isUnset(request.minReadyInstanceRatio)) {
    query['MinReadyInstanceRatio'] = request.minReadyInstanceRatio;
  }
  if (!Util.isUnset(request.minReadyInstances)) {
    query['MinReadyInstances'] = request.minReadyInstances;
  }
  if (!Util.isUnset(request.replicas)) {
    query['Replicas'] = request.replicas;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RescaleApplication',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/rescaleApplication`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RescaleApplicationVerticallyRequest {
  appId?: string(name='AppId'),
  cpu?: string(name='Cpu'),
  memory?: string(name='Memory'),
}

model RescaleApplicationVerticallyResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model RescaleApplicationVerticallyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RescaleApplicationVerticallyResponseBody(name='body'),
}

async function rescaleApplicationVertically(request: RescaleApplicationVerticallyRequest): RescaleApplicationVerticallyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return rescaleApplicationVerticallyWithOptions(request, headers, runtime);
}

async function rescaleApplicationVerticallyWithOptions(request: RescaleApplicationVerticallyRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RescaleApplicationVerticallyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.cpu)) {
    query['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.memory)) {
    query['Memory'] = request.memory;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RescaleApplicationVertically',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/rescaleApplicationVertically`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RestartApplicationRequest {
  appId?: string(name='AppId'),
  minReadyInstanceRatio?: int32(name='MinReadyInstanceRatio'),
  minReadyInstances?: int32(name='MinReadyInstances'),
}

model RestartApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model RestartApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartApplicationResponseBody(name='body'),
}

async function restartApplication(request: RestartApplicationRequest): RestartApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartApplicationWithOptions(request, headers, runtime);
}

async function restartApplicationWithOptions(request: RestartApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.minReadyInstanceRatio)) {
    query['MinReadyInstanceRatio'] = request.minReadyInstanceRatio;
  }
  if (!Util.isUnset(request.minReadyInstances)) {
    query['MinReadyInstances'] = request.minReadyInstances;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartApplication',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/restartApplication`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RestartInstancesRequest {
  appId?: string(name='AppId'),
  instanceIds?: string(name='InstanceIds'),
}

model RestartInstancesResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model RestartInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartInstancesResponseBody(name='body'),
}

async function restartInstances(request: RestartInstancesRequest): RestartInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return restartInstancesWithOptions(request, headers, runtime);
}

async function restartInstancesWithOptions(request: RestartInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RestartInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartInstances',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/restartInstances`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RollbackApplicationRequest {
  appId?: string(name='AppId'),
  autoEnableApplicationScalingRule?: string(name='AutoEnableApplicationScalingRule'),
  batchWaitTime?: int32(name='BatchWaitTime'),
  minReadyInstanceRatio?: int32(name='MinReadyInstanceRatio'),
  minReadyInstances?: int32(name='MinReadyInstances'),
  updateStrategy?: string(name='UpdateStrategy'),
  versionId?: string(name='VersionId'),
}

model RollbackApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
    isNeedApproval?: boolean(name='IsNeedApproval'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model RollbackApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RollbackApplicationResponseBody(name='body'),
}

async function rollbackApplication(request: RollbackApplicationRequest): RollbackApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return rollbackApplicationWithOptions(request, headers, runtime);
}

async function rollbackApplicationWithOptions(request: RollbackApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RollbackApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.autoEnableApplicationScalingRule)) {
    query['AutoEnableApplicationScalingRule'] = request.autoEnableApplicationScalingRule;
  }
  if (!Util.isUnset(request.batchWaitTime)) {
    query['BatchWaitTime'] = request.batchWaitTime;
  }
  if (!Util.isUnset(request.minReadyInstanceRatio)) {
    query['MinReadyInstanceRatio'] = request.minReadyInstanceRatio;
  }
  if (!Util.isUnset(request.minReadyInstances)) {
    query['MinReadyInstances'] = request.minReadyInstances;
  }
  if (!Util.isUnset(request.updateStrategy)) {
    query['UpdateStrategy'] = request.updateStrategy;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RollbackApplication',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/rollbackApplication`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StartApplicationRequest {
  appId?: string(name='AppId'),
}

model StartApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model StartApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartApplicationResponseBody(name='body'),
}

async function startApplication(request: StartApplicationRequest): StartApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return startApplicationWithOptions(request, headers, runtime);
}

async function startApplicationWithOptions(request: StartApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StartApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartApplication',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/startApplication`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopApplicationRequest {
  appId?: string(name='AppId'),
}

model StopApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model StopApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopApplicationResponseBody(name='body'),
}

async function stopApplication(request: StopApplicationRequest): StopApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopApplicationWithOptions(request, headers, runtime);
}

async function stopApplicationWithOptions(request: StopApplicationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopApplicationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopApplication',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/stopApplication`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SuspendJobRequest {
  appId?: string(name='AppId'),
  suspend?: boolean(name='Suspend'),
}

model SuspendJobResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model SuspendJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SuspendJobResponseBody(name='body'),
}

async function suspendJob(request: SuspendJobRequest): SuspendJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return suspendJobWithOptions(request, headers, runtime);
}

async function suspendJobWithOptions(request: SuspendJobRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SuspendJobResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.suspend)) {
    query['Suspend'] = request.suspend;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SuspendJob',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/job/suspendJob`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceIds?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tags?: string(name='Tags'),
}

model TagResourcesResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourcesWithOptions(request, headers, runtime);
}

async function tagResourcesWithOptions(request: TagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIds)) {
    body['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    body['Tags'] = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/tags`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UnbindSlbRequest {
  appId?: string(name='AppId'),
  internet?: boolean(name='Internet'),
  intranet?: boolean(name='Intranet'),
}

model UnbindSlbResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UnbindSlbResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindSlbResponseBody(name='body'),
}

async function unbindSlb(request: UnbindSlbRequest): UnbindSlbResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unbindSlbWithOptions(request, headers, runtime);
}

async function unbindSlbWithOptions(request: UnbindSlbRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UnbindSlbResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.internet)) {
    query['Internet'] = request.internet;
  }
  if (!Util.isUnset(request.intranet)) {
    query['Intranet'] = request.intranet;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindSlb',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/slb`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UntagResourcesRequest {
  deleteAll?: boolean(name='DeleteAll'),
  regionId?: string(name='RegionId'),
  resourceIds?: string(name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagKeys?: string(name='TagKeys'),
}

model UntagResourcesResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourcesWithOptions(request, headers, runtime);
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.deleteAll)) {
    query['DeleteAll'] = request.deleteAll;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKeys)) {
    query['TagKeys'] = request.tagKeys;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/tags`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateAppSecurityGroupRequest {
  appId?: string(name='AppId'),
  securityGroupId?: string(name='SecurityGroupId'),
}

model UpdateAppSecurityGroupResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateAppSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppSecurityGroupResponseBody(name='body'),
}

async function updateAppSecurityGroup(request: UpdateAppSecurityGroupRequest): UpdateAppSecurityGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateAppSecurityGroupWithOptions(request, headers, runtime);
}

async function updateAppSecurityGroupWithOptions(request: UpdateAppSecurityGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateAppSecurityGroupResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppSecurityGroup',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/updateAppSecurityGroup`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateApplicationDescriptionRequest {
  appDescription?: string(name='AppDescription'),
  appId?: string(name='AppId'),
}

model UpdateApplicationDescriptionResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateApplicationDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApplicationDescriptionResponseBody(name='body'),
}

async function updateApplicationDescription(request: UpdateApplicationDescriptionRequest): UpdateApplicationDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateApplicationDescriptionWithOptions(request, headers, runtime);
}

async function updateApplicationDescriptionWithOptions(request: UpdateApplicationDescriptionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateApplicationDescriptionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appDescription)) {
    query['AppDescription'] = request.appDescription;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApplicationDescription',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/updateAppDescription`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateApplicationScalingRuleRequest {
  appId?: string(name='AppId'),
  minReadyInstanceRatio?: int32(name='MinReadyInstanceRatio'),
  minReadyInstances?: int32(name='MinReadyInstances'),
  scalingRuleMetric?: string(name='ScalingRuleMetric'),
  scalingRuleName?: string(name='ScalingRuleName'),
  scalingRuleTimer?: string(name='ScalingRuleTimer'),
}

model UpdateApplicationScalingRuleResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    createTime?: long(name='CreateTime'),
    lastDisableTime?: long(name='LastDisableTime'),
    metric?: {
      maxReplicas?: int32(name='MaxReplicas'),
      metrics?: [ 
        {
          metricTargetAverageUtilization?: int32(name='MetricTargetAverageUtilization'),
          metricType?: string(name='MetricType'),
        }
      ](name='Metrics'),
      minReplicas?: int32(name='MinReplicas'),
    }(name='Metric'),
    scaleRuleEnabled?: boolean(name='ScaleRuleEnabled'),
    scaleRuleName?: string(name='ScaleRuleName'),
    scaleRuleType?: string(name='ScaleRuleType'),
    timer?: {
      beginDate?: string(name='BeginDate'),
      endDate?: string(name='EndDate'),
      period?: string(name='Period'),
      schedules?: [ 
        {
          atTime?: string(name='AtTime'),
          targetReplicas?: int32(name='TargetReplicas'),
        }
      ](name='Schedules'),
    }(name='Timer'),
    updateTime?: long(name='UpdateTime'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model UpdateApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApplicationScalingRuleResponseBody(name='body'),
}

async function updateApplicationScalingRule(request: UpdateApplicationScalingRuleRequest): UpdateApplicationScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateApplicationScalingRuleWithOptions(request, headers, runtime);
}

async function updateApplicationScalingRuleWithOptions(request: UpdateApplicationScalingRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateApplicationScalingRuleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.minReadyInstanceRatio)) {
    query['MinReadyInstanceRatio'] = request.minReadyInstanceRatio;
  }
  if (!Util.isUnset(request.minReadyInstances)) {
    query['MinReadyInstances'] = request.minReadyInstances;
  }
  if (!Util.isUnset(request.scalingRuleMetric)) {
    query['ScalingRuleMetric'] = request.scalingRuleMetric;
  }
  if (!Util.isUnset(request.scalingRuleName)) {
    query['ScalingRuleName'] = request.scalingRuleName;
  }
  if (!Util.isUnset(request.scalingRuleTimer)) {
    query['ScalingRuleTimer'] = request.scalingRuleTimer;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApplicationScalingRule',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/scale/applicationScalingRule`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateApplicationVswitchesRequest {
  appId?: string(name='AppId'),
  vSwitchId?: string(name='VSwitchId'),
}

model UpdateApplicationVswitchesResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateApplicationVswitchesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApplicationVswitchesResponseBody(name='body'),
}

async function updateApplicationVswitches(request: UpdateApplicationVswitchesRequest): UpdateApplicationVswitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateApplicationVswitchesWithOptions(request, headers, runtime);
}

async function updateApplicationVswitchesWithOptions(request: UpdateApplicationVswitchesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateApplicationVswitchesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApplicationVswitches',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/app/updateAppVswitches`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateConfigMapRequest {
  configMapId?: long(name='ConfigMapId'),
  data?: string(name='Data'),
  description?: string(name='Description'),
}

model UpdateConfigMapResponseBody = {
  code?: string(name='Code'),
  data?: {
    configMapId?: string(name='ConfigMapId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateConfigMapResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateConfigMapResponseBody(name='body'),
}

async function updateConfigMap(request: UpdateConfigMapRequest): UpdateConfigMapResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateConfigMapWithOptions(request, headers, runtime);
}

async function updateConfigMapWithOptions(request: UpdateConfigMapRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateConfigMapResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.configMapId)) {
    query['ConfigMapId'] = request.configMapId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.data)) {
    body['Data'] = request.data;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConfigMap',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/configmap/configMap`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateGreyTagRouteRequest {
  albRules?: string(name='AlbRules'),
  description?: string(name='Description'),
  dubboRules?: string(name='DubboRules'),
  greyTagRouteId?: long(name='GreyTagRouteId'),
  scRules?: string(name='ScRules'),
}

model UpdateGreyTagRouteResponseBody = {
  code?: string(name='Code'),
  data?: {
    greyTagRouteId?: long(name='GreyTagRouteId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateGreyTagRouteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGreyTagRouteResponseBody(name='body'),
}

async function updateGreyTagRoute(request: UpdateGreyTagRouteRequest): UpdateGreyTagRouteResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateGreyTagRouteWithOptions(request, headers, runtime);
}

async function updateGreyTagRouteWithOptions(request: UpdateGreyTagRouteRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateGreyTagRouteResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.albRules)) {
    query['AlbRules'] = request.albRules;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dubboRules)) {
    query['DubboRules'] = request.dubboRules;
  }
  if (!Util.isUnset(request.greyTagRouteId)) {
    query['GreyTagRouteId'] = request.greyTagRouteId;
  }
  if (!Util.isUnset(request.scRules)) {
    query['ScRules'] = request.scRules;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGreyTagRoute',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/tagroute/greyTagRoute`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateIngressRequest {
  certId?: string(name='CertId'),
  defaultRule?: string(name='DefaultRule'),
  description?: string(name='Description'),
  ingressId?: long(name='IngressId'),
  listenerPort?: string(name='ListenerPort'),
  listenerProtocol?: string(name='ListenerProtocol'),
  loadBalanceType?: string(name='LoadBalanceType'),
  rules?: string(name='Rules'),
}

model UpdateIngressResponseBody = {
  code?: string(name='Code'),
  data?: {
    ingressId?: long(name='IngressId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateIngressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIngressResponseBody(name='body'),
}

async function updateIngress(request: UpdateIngressRequest): UpdateIngressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateIngressWithOptions(request, headers, runtime);
}

async function updateIngressWithOptions(request: UpdateIngressRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateIngressResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.certId)) {
    query['CertId'] = request.certId;
  }
  if (!Util.isUnset(request.defaultRule)) {
    query['DefaultRule'] = request.defaultRule;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.ingressId)) {
    query['IngressId'] = request.ingressId;
  }
  if (!Util.isUnset(request.listenerPort)) {
    query['ListenerPort'] = request.listenerPort;
  }
  if (!Util.isUnset(request.listenerProtocol)) {
    query['ListenerProtocol'] = request.listenerProtocol;
  }
  if (!Util.isUnset(request.loadBalanceType)) {
    query['LoadBalanceType'] = request.loadBalanceType;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.rules)) {
    body['Rules'] = request.rules;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIngress',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/ingress/Ingress`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateNamespaceRequest {
  namespaceDescription?: string(name='NamespaceDescription'),
  namespaceId?: string(name='NamespaceId'),
  namespaceName?: string(name='NamespaceName'),
}

model UpdateNamespaceResponseBody = {
  code?: string(name='Code'),
  data?: {
    namespaceDescription?: string(name='NamespaceDescription'),
    namespaceId?: string(name='NamespaceId'),
    namespaceName?: string(name='NamespaceName'),
    regionId?: string(name='RegionId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateNamespaceResponseBody(name='body'),
}

async function updateNamespace(request: UpdateNamespaceRequest): UpdateNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateNamespaceWithOptions(request, headers, runtime);
}

async function updateNamespaceWithOptions(request: UpdateNamespaceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateNamespaceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.namespaceDescription)) {
    query['NamespaceDescription'] = request.namespaceDescription;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNamespace',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/paas/namespace`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateNamespaceVpcRequest {
  namespaceId?: string(name='NamespaceId'),
  vpcId?: string(name='VpcId'),
}

model UpdateNamespaceVpcResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateNamespaceVpcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateNamespaceVpcResponseBody(name='body'),
}

async function updateNamespaceVpc(request: UpdateNamespaceVpcRequest): UpdateNamespaceVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateNamespaceVpcWithOptions(request, headers, runtime);
}

async function updateNamespaceVpcWithOptions(request: UpdateNamespaceVpcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateNamespaceVpcResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNamespaceVpc',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/namespace/updateNamespaceVpc`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateSecretRequest {
  namespaceId?: string(name='NamespaceId'),
  secretData?: string(name='SecretData'),
  secretId?: long(name='SecretId'),
}

model UpdateSecretResponseBody = {
  code?: string(name='Code'),
  data?: {
    secretId?: string(name='SecretId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSecretResponseBody(name='body'),
}

async function updateSecret(request: UpdateSecretRequest): UpdateSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSecretWithOptions(request, headers, runtime);
}

async function updateSecretWithOptions(request: UpdateSecretRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSecretResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.namespaceId)) {
    query['NamespaceId'] = request.namespaceId;
  }
  if (!Util.isUnset(request.secretId)) {
    query['SecretId'] = request.secretId;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.secretData)) {
    body['SecretData'] = request.secretData;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSecret',
    version = '2019-05-06',
    protocol = 'HTTPS',
    pathname = `/pop/v1/sam/secret/secret`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

