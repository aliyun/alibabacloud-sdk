/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'sae';
  @version = '2019-05-06';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AbortAndRollbackChangeOrderRequest {
  changeOrderId: string(name='ChangeOrderId', position='Query'),
}

model AbortAndRollbackChangeOrderResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model AbortAndRollbackChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  body: AbortAndRollbackChangeOrderResponseBody(name='body'),
}

async function abortAndRollbackChangeOrder(request: AbortAndRollbackChangeOrderRequest): AbortAndRollbackChangeOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AbortAndRollbackChangeOrder', 'PUT', '/pop/v1/sam/changeorder/AbortAndRollbackChangeOrder', 'json', false, 'json', request);
}

model AbortChangeOrderRequest {
  changeOrderId: string(name='ChangeOrderId', position='Query'),
}

model AbortChangeOrderResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model AbortChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  body: AbortChangeOrderResponseBody(name='body'),
}

async function abortChangeOrder(request: AbortChangeOrderRequest): AbortChangeOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'AbortChangeOrder', 'PUT', '/pop/v1/sam/changeorder/AbortChangeOrder', 'json', false, 'json', request);
}

model BatchStartApplicationsRequest {
  appIds?: string(name='AppIds', position='Query'),
  namespaceId: string(name='NamespaceId', position='Query'),
}

model BatchStartApplicationsResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model BatchStartApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchStartApplicationsResponseBody(name='body'),
}

async function batchStartApplications(request: BatchStartApplicationsRequest): BatchStartApplicationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchStartApplications', 'PUT', '/pop/v1/sam/app/batchStartApplications', 'json', false, 'json', request);
}

model BatchStopApplicationsRequest {
  appIds?: string(name='AppIds', position='Query'),
  namespaceId: string(name='NamespaceId', position='Query'),
}

model BatchStopApplicationsResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model BatchStopApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchStopApplicationsResponseBody(name='body'),
}

async function batchStopApplications(request: BatchStopApplicationsRequest): BatchStopApplicationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BatchStopApplications', 'PUT', '/pop/v1/sam/app/batchStopApplications', 'json', false, 'json', request);
}

model BindSlbRequest {
  appId: string(name='AppId', position='Query'),
  internet?: string(name='Internet', position='Query'),
  internetSlbId?: string(name='InternetSlbId', position='Query'),
  intranet?: string(name='Intranet', position='Query'),
  intranetSlbId?: string(name='IntranetSlbId', position='Query'),
}

model BindSlbResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model BindSlbResponse = {
  headers: map[string]string(name='headers'),
  body: BindSlbResponseBody(name='body'),
}

async function bindSlb(request: BindSlbRequest): BindSlbResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'BindSlb', 'POST', '/pop/v1/sam/app/slb', 'json', false, 'json', request);
}

model ConfirmPipelineBatchRequest {
  confirm: boolean(name='Confirm', position='Query'),
  pipelineId: string(name='PipelineId', position='Query'),
}

model ConfirmPipelineBatchResponseBody = {
  code?: string(name='Code'),
  data?: {
    pipelineId?: string(name='PipelineId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ConfirmPipelineBatchResponse = {
  headers: map[string]string(name='headers'),
  body: ConfirmPipelineBatchResponseBody(name='body'),
}

async function confirmPipelineBatch(request: ConfirmPipelineBatchRequest): ConfirmPipelineBatchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ConfirmPipelineBatch', 'GET', '/pop/v1/sam/changeorder/ConfirmPipelineBatch', 'json', false, 'json', request);
}

model CreateApplicationRequest {
  acrAssumeRoleArn?: string(name='AcrAssumeRoleArn', position='Query'),
  acrInstanceId?: string(name='AcrInstanceId', description='ACR 企业版实例 ID', position='Body'),
  appDescription?: string(name='AppDescription', position='Query'),
  appName: string(name='AppName', position='Query'),
  associateEip?: boolean(name='AssociateEip', description='是否绑定EIP', position='Body'),
  autoConfig?: boolean(name='AutoConfig', position='Query'),
  command?: string(name='Command', position='Query'),
  commandArgs?: string(name='CommandArgs', position='Query'),
  configMapMountDesc?: string(name='ConfigMapMountDesc', position='Body'),
  cpu?: int32(name='Cpu', position='Query'),
  customHostAlias?: string(name='CustomHostAlias', position='Query'),
  deploy?: boolean(name='Deploy', position='Query'),
  edasContainerVersion?: string(name='EdasContainerVersion', position='Query'),
  envs?: string(name='Envs', position='Query'),
  imageUrl?: string(name='ImageUrl', position='Query'),
  jarStartArgs?: string(name='JarStartArgs', position='Query'),
  jarStartOptions?: string(name='JarStartOptions', position='Query'),
  jdk?: string(name='Jdk', position='Query'),
  kafkaConfigs?: string(name='KafkaConfigs', position='Query'),
  kafkaEndpoint?: string(name='KafkaEndpoint', position='Query'),
  kafkaInstanceId?: string(name='KafkaInstanceId', position='Query'),
  kafkaLogfileConfig?: string(name='KafkaLogfileConfig', position='Query'),
  liveness?: string(name='Liveness', position='Query'),
  memory?: int32(name='Memory', position='Query'),
  mountDesc?: string(name='MountDesc', position='Query'),
  mountHost?: string(name='MountHost', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  nasId?: string(name='NasId', position='Query'),
  openCollectToKafka?: boolean(name='OpenCollectToKafka', position='Query'),
  ossAkId?: string(name='OssAkId', description='OSS使用的AKID', position='Body'),
  ossAkSecret?: string(name='OssAkSecret', description='OSS AKID对应的secret', position='Body'),
  ossMountDescs?: string(name='OssMountDescs', description='OSS挂载描述信息', position='Body'),
  packageType: string(name='PackageType', position='Query'),
  packageUrl?: string(name='PackageUrl', position='Query'),
  packageVersion?: string(name='PackageVersion', position='Query'),
  phpArmsConfigLocation?: string(name='PhpArmsConfigLocation', position='Query'),
  phpConfig?: string(name='PhpConfig', position='Body'),
  phpConfigLocation?: string(name='PhpConfigLocation', position='Query'),
  postStart?: string(name='PostStart', position='Query'),
  preStop?: string(name='PreStop', position='Query'),
  programmingLanguage?: string(name='ProgrammingLanguage', position='Query'),
  readiness?: string(name='Readiness', position='Query'),
  replicas: int32(name='Replicas', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  slsConfigs?: string(name='SlsConfigs', position='Query'),
  terminationGracePeriodSeconds?: int32(name='TerminationGracePeriodSeconds', minimum=0, maximum=6000, position='Query'),
  timezone?: string(name='Timezone', position='Query'),
  tomcatConfig?: string(name='TomcatConfig', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  warStartOptions?: string(name='WarStartOptions', position='Query'),
  webContainer?: string(name='WebContainer', position='Query'),
  mseFeatureConfig?: string(name='mseFeatureConfig', position='Query'),
}

model CreateApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateApplication', 'POST', '/pop/v1/sam/app/createApplication', 'json', true, 'form', request);
}

model CreateApplicationScalingRuleRequest {
  appId: string(name='AppId', position='Query'),
  minReadyInstanceRatio?: int32(name='MinReadyInstanceRatio', position='Query'),
  minReadyInstances?: int32(name='MinReadyInstances', position='Query'),
  scalingRuleEnable?: boolean(name='ScalingRuleEnable', position='Query'),
  scalingRuleMetric?: string(name='ScalingRuleMetric', position='Query'),
  scalingRuleName: string(name='ScalingRuleName', position='Query'),
  scalingRuleTimer?: string(name='ScalingRuleTimer', position='Query'),
  scalingRuleType: string(name='ScalingRuleType', position='Query'),
}

model CreateApplicationScalingRuleResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    createTime?: long(name='CreateTime'),
    lastDisableTime?: long(name='LastDisableTime'),
    metric?: {
      maxReplicas?: int32(name='MaxReplicas'),
      metrics?: [ 
        {
          metricTargetAverageUtilization?: int32(name='MetricTargetAverageUtilization'),
          metricType?: string(name='MetricType'),
        }
      ](name='Metrics'),
      minReplicas?: int32(name='MinReplicas'),
    }(name='Metric'),
    scaleRuleEnabled?: boolean(name='ScaleRuleEnabled'),
    scaleRuleName?: string(name='ScaleRuleName'),
    scaleRuleType?: string(name='ScaleRuleType'),
    timer?: {
      beginDate?: string(name='BeginDate'),
      endDate?: string(name='EndDate'),
      period?: string(name='Period'),
      schedules?: [ 
        {
          atTime?: string(name='AtTime'),
          targetReplicas?: int32(name='TargetReplicas'),
        }
      ](name='Schedules'),
    }(name='Timer'),
    updateTime?: long(name='UpdateTime'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model CreateApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationScalingRuleResponseBody(name='body'),
}

async function createApplicationScalingRule(request: CreateApplicationScalingRuleRequest): CreateApplicationScalingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateApplicationScalingRule', 'POST', '/pop/v1/sam/scale/applicationScalingRule', 'json', false, 'json', request);
}

model CreateConfigMapRequest {
  description?: string(name='Description', position='Query'),
  name: string(name='Name', position='Query'),
  namespaceId: string(name='NamespaceId', position='Query'),
}

model CreateConfigMapResponseBody = {
  code?: string(name='Code'),
  data?: {
    configMapId?: long(name='ConfigMapId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model CreateConfigMapResponse = {
  headers: map[string]string(name='headers'),
  body: CreateConfigMapResponseBody(name='body'),
}

async function createConfigMap(request: CreateConfigMapRequest): CreateConfigMapResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateConfigMap', 'POST', '/pop/v1/sam/configmap/configMap', 'json', false, 'json', request);
}

model CreateGreyTagRouteRequest {
  appId: string(name='AppId', description='应用ID', position='Query'),
  description?: string(name='Description', description='规则名称', position='Query'),
  dubboRules?: string(name='DubboRules', description='Dubbo规则', position='Query'),
  name: string(name='Name', description='规则名称', position='Query'),
  scRules?: string(name='ScRules', description='SpringCloud规则', position='Query'),
}

model CreateGreyTagRouteResponseBody = {
  code?: string(name='Code'),
  data?: {
    greyTagRouteId?: long(name='GreyTagRouteId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model CreateGreyTagRouteResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGreyTagRouteResponseBody(name='body'),
}

async function createGreyTagRoute(request: CreateGreyTagRouteRequest): CreateGreyTagRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateGreyTagRoute', 'POST', '/pop/v1/sam/tagroute/greyTagRoute', 'json', false, 'json', request);
}

model CreateIngressRequest {
  certId?: string(name='CertId', position='Query'),
  defaultRule: string(name='DefaultRule', position='Query'),
  description?: string(name='Description', position='Query'),
  listenerPort: int32(name='ListenerPort', position='Query'),
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalanceType?: string(name='LoadBalanceType', position='Query'),
  namespaceId: string(name='NamespaceId', position='Query'),
  rules: string(name='Rules', position='Body'),
  slbId: string(name='SlbId', position='Query'),
}

model CreateIngressResponseBody = {
  code?: string(name='Code'),
  data?: {
    ingressId?: long(name='IngressId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model CreateIngressResponse = {
  headers: map[string]string(name='headers'),
  body: CreateIngressResponseBody(name='body'),
}

async function createIngress(request: CreateIngressRequest): CreateIngressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateIngress', 'POST', '/pop/v1/sam/ingress/Ingress', 'json', true, 'form', request);
}

model CreateNamespaceRequest {
  namespaceDescription?: string(name='NamespaceDescription', position='Query'),
  namespaceId: string(name='NamespaceId', position='Query'),
  namespaceName: string(name='NamespaceName', position='Query'),
}

model CreateNamespaceResponseBody = {
  code?: string(name='Code'),
  data?: {
    namespaceDescription?: string(name='NamespaceDescription'),
    namespaceId?: string(name='NamespaceId'),
    namespaceName?: string(name='NamespaceName'),
    regionId?: string(name='RegionId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model CreateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNamespaceResponseBody(name='body'),
}

async function createNamespace(request: CreateNamespaceRequest): CreateNamespaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateNamespace', 'POST', '/pop/v1/paas/namespace', 'json', false, 'json', request);
}

model DeleteApplicationRequest {
  appId: string(name='AppId', position='Query'),
}

model DeleteApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DeleteApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApplicationResponseBody(name='body'),
}

async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteApplication', 'DELETE', '/pop/v1/sam/app/deleteApplication', 'json', false, 'json', request);
}

model DeleteApplicationScalingRuleRequest {
  appId: string(name='AppId', position='Query'),
  scalingRuleName: string(name='ScalingRuleName', position='Query'),
}

model DeleteApplicationScalingRuleResponseBody = {
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model DeleteApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApplicationScalingRuleResponseBody(name='body'),
}

async function deleteApplicationScalingRule(request: DeleteApplicationScalingRuleRequest): DeleteApplicationScalingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteApplicationScalingRule', 'DELETE', '/pop/v1/sam/scale/applicationScalingRule', 'json', false, 'json', request);
}

model DeleteConfigMapRequest {
  configMapId: long(name='ConfigMapId', position='Query'),
}

model DeleteConfigMapResponseBody = {
  code?: string(name='Code'),
  data?: {
    configMapId?: long(name='ConfigMapId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DeleteConfigMapResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteConfigMapResponseBody(name='body'),
}

async function deleteConfigMap(request: DeleteConfigMapRequest): DeleteConfigMapResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteConfigMap', 'DELETE', '/pop/v1/sam/configmap/configMap', 'json', false, 'json', request);
}

model DeleteGreyTagRouteRequest {
  greyTagRouteId: long(name='GreyTagRouteId', description='规则ID', position='Query'),
}

model DeleteGreyTagRouteResponseBody = {
  code?: string(name='Code'),
  data?: {
    greyTagRouteId?: long(name='GreyTagRouteId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DeleteGreyTagRouteResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGreyTagRouteResponseBody(name='body'),
}

async function deleteGreyTagRoute(request: DeleteGreyTagRouteRequest): DeleteGreyTagRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteGreyTagRoute', 'DELETE', '/pop/v1/sam/tagroute/greyTagRoute', 'json', false, 'json', request);
}

model DeleteIngressRequest {
  ingressId: long(name='IngressId', position='Query'),
}

model DeleteIngressResponseBody = {
  code?: string(name='Code'),
  data?: {
    ingressId?: long(name='IngressId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DeleteIngressResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteIngressResponseBody(name='body'),
}

async function deleteIngress(request: DeleteIngressRequest): DeleteIngressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteIngress', 'DELETE', '/pop/v1/sam/ingress/Ingress', 'json', false, 'json', request);
}

model DeleteNamespaceRequest {
  namespaceId: string(name='NamespaceId', position='Query'),
}

model DeleteNamespaceResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DeleteNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNamespaceResponseBody(name='body'),
}

async function deleteNamespace(request: DeleteNamespaceRequest): DeleteNamespaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteNamespace', 'DELETE', '/pop/v1/paas/namespace', 'json', false, 'json', request);
}

model DeployApplicationRequest {
  acrAssumeRoleArn?: string(name='AcrAssumeRoleArn', position='Query'),
  acrInstanceId?: string(name='AcrInstanceId', description='ACR 企业版实例 ID', position='Body'),
  appId: string(name='AppId', position='Query'),
  associateEip?: boolean(name='AssociateEip', description='是否绑定EIP', position='Body'),
  autoEnableApplicationScalingRule?: boolean(name='AutoEnableApplicationScalingRule', position='Query'),
  batchWaitTime?: int32(name='BatchWaitTime', position='Query'),
  changeOrderDesc?: string(name='ChangeOrderDesc', position='Query'),
  command?: string(name='Command', position='Query'),
  commandArgs?: string(name='CommandArgs', position='Query'),
  configMapMountDesc?: string(name='ConfigMapMountDesc', position='Body'),
  customHostAlias?: string(name='CustomHostAlias', position='Query'),
  edasContainerVersion?: string(name='EdasContainerVersion', position='Query'),
  enableAhas?: string(name='EnableAhas', position='Query'),
  enableGreyTagRoute?: boolean(name='EnableGreyTagRoute', description='是否开启发布流量灰度规则', position='Query'),
  envs?: string(name='Envs', position='Query'),
  imageUrl?: string(name='ImageUrl', position='Query'),
  jarStartArgs?: string(name='JarStartArgs', position='Query'),
  jarStartOptions?: string(name='JarStartOptions', position='Query'),
  jdk?: string(name='Jdk', position='Query'),
  kafkaConfigs?: string(name='KafkaConfigs', position='Query'),
  kafkaEndpoint?: string(name='KafkaEndpoint', position='Query'),
  kafkaInstanceId?: string(name='KafkaInstanceId', position='Query'),
  kafkaLogfileConfig?: string(name='KafkaLogfileConfig', position='Query'),
  liveness?: string(name='Liveness', position='Query'),
  minReadyInstanceRatio?: int32(name='MinReadyInstanceRatio', position='Query'),
  minReadyInstances?: int32(name='MinReadyInstances', position='Query'),
  mountDesc?: string(name='MountDesc', position='Query'),
  mountHost?: string(name='MountHost', position='Query'),
  mseFeatureConfig?: string(name='MseFeatureConfig', position='Query'),
  nasId?: string(name='NasId', position='Query'),
  openCollectToKafka?: boolean(name='OpenCollectToKafka', position='Query'),
  ossAkId?: string(name='OssAkId', description='OSS使用的AKID', position='Body'),
  ossAkSecret?: string(name='OssAkSecret', description='OSS AKID对应的secret', position='Body'),
  ossMountDescs?: string(name='OssMountDescs', description='OSS挂载描述信息', position='Body'),
  packageUrl?: string(name='PackageUrl', position='Query'),
  packageVersion?: string(name='PackageVersion', position='Query'),
  phpArmsConfigLocation?: string(name='PhpArmsConfigLocation', position='Query'),
  phpConfig?: string(name='PhpConfig', position='Body'),
  phpConfigLocation?: string(name='PhpConfigLocation', position='Query'),
  postStart?: string(name='PostStart', position='Query'),
  preStop?: string(name='PreStop', position='Query'),
  readiness?: string(name='Readiness', position='Query'),
  slsConfigs?: string(name='SlsConfigs', position='Query'),
  terminationGracePeriodSeconds?: int32(name='TerminationGracePeriodSeconds', minimum=0, maximum=6000, position='Query'),
  timezone?: string(name='Timezone', position='Query'),
  tomcatConfig?: string(name='TomcatConfig', position='Query'),
  updateStrategy?: string(name='UpdateStrategy', position='Query'),
  warStartOptions?: string(name='WarStartOptions', position='Query'),
  webContainer?: string(name='WebContainer', position='Query'),
}

model DeployApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    changeOrderId?: string(name='ChangeOrderId'),
    isNeedApproval?: boolean(name='IsNeedApproval'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DeployApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeployApplicationResponseBody(name='body'),
}

async function deployApplication(request: DeployApplicationRequest): DeployApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeployApplication', 'POST', '/pop/v1/sam/app/deployApplication', 'json', true, 'form', request);
}

model DescribeAppServiceDetailRequest {
  appId?: string(name='AppId', description='mse 的 appId', position='Query'),
  serviceGroup?: string(name='ServiceGroup', position='Query'),
  serviceName?: string(name='ServiceName', position='Query'),
  serviceType?: string(name='ServiceType', position='Query'),
  serviceVersion?: string(name='ServiceVersion', position='Query'),
}

model DescribeAppServiceDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    dubboApplicationName?: string(name='DubboApplicationName'),
    edasAppName?: string(name='EdasAppName'),
    group?: string(name='Group'),
    metadata?: map[string]any(name='Metadata'),
    methods?: [ 
      {
        methodController?: string(name='MethodController'),
        name?: string(name='Name'),
        nameDetail?: string(name='NameDetail'),
        parameterDefinitions?: [ 
          {
            description?: string(name='Description'),
            name?: string(name='Name'),
            type?: string(name='Type'),
          }
        ](name='ParameterDefinitions'),
        parameterDetails?: [ string ](name='ParameterDetails'),
        parameterTypes?: [ string ](name='ParameterTypes'),
        paths?: [ string ](name='Paths'),
        requestMethods?: [ string ](name='RequestMethods'),
        returnDetails?: string(name='ReturnDetails'),
        returnType?: string(name='ReturnType'),
      }
    ](name='Methods'),
    serviceName?: string(name='ServiceName'),
    serviceType?: string(name='ServiceType'),
    springApplicationName?: string(name='SpringApplicationName'),
    version?: string(name='Version'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeAppServiceDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAppServiceDetailResponseBody(name='body'),
}

async function describeAppServiceDetail(request: DescribeAppServiceDetailRequest): DescribeAppServiceDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeAppServiceDetail', 'GET', '/pop/v1/sam/service/describeAppServiceDetail', 'json', false, 'json', request);
}

model DescribeApplicationConfigRequest {
  appId: string(name='AppId', position='Query'),
  versionId?: string(name='VersionId', position='Query'),
}

model DescribeApplicationConfigResponseBody = {
  code?: string(name='Code'),
  data?: {
    acrAssumeRoleArn?: string(name='AcrAssumeRoleArn'),
    acrInstanceId?: string(name='AcrInstanceId', description='ACR 企业版实例 ID'),
    appDescription?: string(name='AppDescription'),
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    associateEip?: boolean(name='AssociateEip', description='是否绑定EIP'),
    batchWaitTime?: int32(name='BatchWaitTime'),
    command?: string(name='Command'),
    commandArgs?: string(name='CommandArgs'),
    configMapMountDesc?: [ 
      {
        configMapId?: long(name='ConfigMapId'),
        configMapName?: string(name='ConfigMapName'),
        key?: string(name='Key'),
        mountPath?: string(name='MountPath'),
      }
    ](name='ConfigMapMountDesc'),
    cpu?: int32(name='Cpu'),
    customHostAlias?: string(name='CustomHostAlias'),
    edasContainerVersion?: string(name='EdasContainerVersion'),
    enableAhas?: string(name='EnableAhas'),
    enableGreyTagRoute?: boolean(name='EnableGreyTagRoute', description='开启流量灰度'),
    envs?: string(name='Envs'),
    imageUrl?: string(name='ImageUrl'),
    jarStartArgs?: string(name='JarStartArgs'),
    jarStartOptions?: string(name='JarStartOptions'),
    jdk?: string(name='Jdk'),
    kafkaConfigs?: string(name='KafkaConfigs'),
    liveness?: string(name='Liveness'),
    memory?: int32(name='Memory'),
    minReadyInstanceRatio?: int32(name='MinReadyInstanceRatio'),
    minReadyInstances?: int32(name='MinReadyInstances'),
    mountDesc?: [ 
      {
        mountPath?: string(name='MountPath'),
        nasPath?: string(name='NasPath'),
      }
    ](name='MountDesc'),
    mountHost?: string(name='MountHost'),
    mseApplicationId?: string(name='MseApplicationId', description='对应MSE产品侧应用ID'),
    mseFeatureConfig?: string(name='MseFeatureConfig'),
    namespaceId?: string(name='NamespaceId'),
    nasId?: string(name='NasId'),
    ossAkId?: string(name='OssAkId', description='OSS读写的AK'),
    ossAkSecret?: string(name='OssAkSecret', description='OSS读写的secret'),
    ossMountDescs?: [ 
      {
        bucketName?: string(name='bucketName', description='Bucket名称'),
        bucketPath?: string(name='bucketPath', description='Bucket中Oss Key名称'),
        mountPath?: string(name='mountPath', description='挂载到容器的路径'),
        readOnly?: boolean(name='readOnly', description='是否只读'),
      }
    ](name='OssMountDescs', description='OSS挂载描述信息'),
    packageType?: string(name='PackageType'),
    packageUrl?: string(name='PackageUrl'),
    packageVersion?: string(name='PackageVersion'),
    phpArmsConfigLocation?: string(name='PhpArmsConfigLocation'),
    phpConfig?: string(name='PhpConfig'),
    phpConfigLocation?: string(name='PhpConfigLocation'),
    postStart?: string(name='PostStart'),
    preStop?: string(name='PreStop'),
    programmingLanguage?: string(name='ProgrammingLanguage'),
    readiness?: string(name='Readiness'),
    regionId?: string(name='RegionId'),
    replicas?: int32(name='Replicas'),
    securityGroupId?: string(name='SecurityGroupId'),
    slsConfigs?: string(name='SlsConfigs'),
    tags?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='Tags'),
    terminationGracePeriodSeconds?: int32(name='TerminationGracePeriodSeconds'),
    timezone?: string(name='Timezone'),
    tomcatConfig?: string(name='TomcatConfig'),
    updateStrategy?: string(name='UpdateStrategy'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
    warStartOptions?: string(name='WarStartOptions'),
    webContainer?: string(name='WebContainer'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationConfigResponseBody(name='body'),
}

async function describeApplicationConfig(request: DescribeApplicationConfigRequest): DescribeApplicationConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeApplicationConfig', 'GET', '/pop/v1/sam/app/describeApplicationConfig', 'json', false, 'json', request);
}

model DescribeApplicationGroupsRequest {
  appId: string(name='AppId', position='Query'),
  currentPage?: int32(name='CurrentPage', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model DescribeApplicationGroupsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      edasContainerVersion?: string(name='EdasContainerVersion'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      groupType?: int32(name='GroupType'),
      imageUrl?: string(name='ImageUrl'),
      jdk?: string(name='Jdk'),
      packageType?: string(name='PackageType'),
      packageUrl?: string(name='PackageUrl'),
      packageVersion?: string(name='PackageVersion'),
      replicas?: int32(name='Replicas'),
      runningInstances?: int32(name='RunningInstances'),
      webContainer?: string(name='WebContainer'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationGroupsResponseBody(name='body'),
}

async function describeApplicationGroups(request: DescribeApplicationGroupsRequest): DescribeApplicationGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeApplicationGroups', 'GET', '/pop/v1/sam/app/describeApplicationGroups', 'json', false, 'json', request);
}

model DescribeApplicationImageRequest {
  appId: string(name='AppId', position='Query'),
  imageUrl: string(name='ImageUrl', position='Query'),
}

model DescribeApplicationImageResponseBody = {
  code?: string(name='Code'),
  data?: {
    crUrl?: string(name='CrUrl'),
    logo?: string(name='Logo'),
    regionId?: string(name='RegionId'),
    repoName?: string(name='RepoName'),
    repoNamespace?: string(name='RepoNamespace'),
    repoOriginType?: string(name='RepoOriginType'),
    repoTag?: string(name='RepoTag'),
    repoType?: string(name='RepoType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationImageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationImageResponseBody(name='body'),
}

async function describeApplicationImage(request: DescribeApplicationImageRequest): DescribeApplicationImageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeApplicationImage', 'GET', '/pop/v1/sam/container/describeApplicationImage', 'json', false, 'json', request);
}

model DescribeApplicationInstancesRequest {
  appId: string(name='AppId', position='Query'),
  currentPage?: int32(name='CurrentPage', position='Query'),
  groupId: string(name='GroupId', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  reverse?: boolean(name='Reverse', position='Query'),
}

model DescribeApplicationInstancesResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    instances?: [ 
      {
        createTimeStamp?: long(name='CreateTimeStamp'),
        debugStatus?: boolean(name='DebugStatus'),
        eip?: string(name='Eip'),
        finishTimeStamp?: long(name='FinishTimeStamp'),
        groupId?: string(name='GroupId'),
        imageUrl?: string(name='ImageUrl'),
        instanceContainerIp?: string(name='InstanceContainerIp'),
        instanceContainerRestarts?: long(name='InstanceContainerRestarts'),
        instanceContainerStatus?: string(name='InstanceContainerStatus'),
        instanceHealthStatus?: string(name='InstanceHealthStatus'),
        instanceId?: string(name='InstanceId'),
        packageVersion?: string(name='PackageVersion'),
        vSwitchId?: string(name='VSwitchId'),
      }
    ](name='Instances'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationInstancesResponseBody(name='body'),
}

async function describeApplicationInstances(request: DescribeApplicationInstancesRequest): DescribeApplicationInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeApplicationInstances', 'GET', '/pop/v1/sam/app/describeApplicationInstances', 'json', false, 'json', request);
}

model DescribeApplicationScalingRuleRequest {
  appId: string(name='AppId', position='Query'),
  scalingRuleName: string(name='ScalingRuleName', position='Query'),
}

model DescribeApplicationScalingRuleResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    createTime?: long(name='CreateTime'),
    lastDisableTime?: long(name='LastDisableTime'),
    metric?: {
      maxReplicas?: int32(name='MaxReplicas'),
      metrics?: [ 
        {
          metricTargetAverageUtilization?: int32(name='MetricTargetAverageUtilization'),
          metricType?: string(name='MetricType'),
        }
      ](name='Metrics'),
      metricsStatus?: {
        currentMetrics?: [ 
          {
            currentValue?: long(name='CurrentValue'),
            name?: string(name='Name'),
            type?: string(name='Type'),
          }
        ](name='CurrentMetrics'),
        currentReplicas?: long(name='CurrentReplicas'),
        desiredReplicas?: long(name='DesiredReplicas'),
        lastScaleTime?: string(name='LastScaleTime'),
        nextScaleMetrics?: [ 
          {
            name?: string(name='Name'),
            nextScaleInAverageUtilization?: int32(name='NextScaleInAverageUtilization'),
            nextScaleOutAverageUtilization?: int32(name='NextScaleOutAverageUtilization'),
          }
        ](name='NextScaleMetrics'),
        nextScaleTimePeriod?: int32(name='NextScaleTimePeriod'),
      }(name='MetricsStatus'),
      minReplicas?: int32(name='MinReplicas'),
      scaleDownRules?: {
        disabled?: boolean(name='Disabled'),
        stabilizationWindowSeconds?: long(name='StabilizationWindowSeconds'),
        step?: long(name='Step'),
      }(name='ScaleDownRules'),
      scaleUpRules?: {
        disabled?: boolean(name='Disabled'),
        stabilizationWindowSeconds?: long(name='StabilizationWindowSeconds'),
        step?: long(name='Step'),
      }(name='ScaleUpRules'),
    }(name='Metric'),
    scaleRuleEnabled?: boolean(name='ScaleRuleEnabled'),
    scaleRuleName?: string(name='ScaleRuleName'),
    scaleRuleType?: string(name='ScaleRuleType'),
    timer?: {
      beginDate?: string(name='BeginDate'),
      endDate?: string(name='EndDate'),
      period?: string(name='Period'),
      schedules?: [ 
        {
          atTime?: string(name='AtTime'),
          targetReplicas?: int32(name='TargetReplicas'),
        }
      ](name='Schedules'),
    }(name='Timer'),
    updateTime?: long(name='UpdateTime'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationScalingRuleResponseBody(name='body'),
}

async function describeApplicationScalingRule(request: DescribeApplicationScalingRuleRequest): DescribeApplicationScalingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeApplicationScalingRule', 'GET', '/pop/v1/sam/scale/applicationScalingRule', 'json', false, 'json', request);
}

model DescribeApplicationScalingRulesRequest {
  appId: string(name='AppId', position='Query'),
}

model DescribeApplicationScalingRulesResponseBody = {
  data?: {
    applicationScalingRules?: [ 
      {
        appId?: string(name='AppId'),
        createTime?: long(name='CreateTime'),
        lastDisableTime?: long(name='LastDisableTime'),
        metric?: {
          maxReplicas?: int32(name='MaxReplicas'),
          metrics?: [ 
            {
              metricTargetAverageUtilization?: int32(name='MetricTargetAverageUtilization'),
              metricType?: string(name='MetricType'),
            }
          ](name='Metrics'),
          metricsStatus?: {
            currentMetrics?: [ 
              {
                currentValue?: long(name='CurrentValue'),
                name?: string(name='Name'),
                type?: string(name='Type'),
              }
            ](name='CurrentMetrics'),
            currentReplicas?: long(name='CurrentReplicas'),
            desiredReplicas?: long(name='DesiredReplicas'),
            lastScaleTime?: string(name='LastScaleTime'),
            maxReplicas?: long(name='MaxReplicas'),
            minReplicas?: long(name='MinReplicas'),
            nextScaleMetrics?: [ 
              {
                name?: string(name='Name'),
                nextScaleInAverageUtilization?: int32(name='NextScaleInAverageUtilization'),
                nextScaleOutAverageUtilization?: int32(name='NextScaleOutAverageUtilization'),
              }
            ](name='NextScaleMetrics'),
            nextScaleTimePeriod?: int32(name='NextScaleTimePeriod'),
          }(name='MetricsStatus'),
          minReplicas?: int32(name='MinReplicas'),
          scaleDownRules?: {
            disabled?: boolean(name='Disabled'),
            stabilizationWindowSeconds?: long(name='StabilizationWindowSeconds'),
            step?: long(name='Step'),
          }(name='ScaleDownRules'),
          scaleUpRules?: {
            disabled?: boolean(name='Disabled'),
            stabilizationWindowSeconds?: long(name='StabilizationWindowSeconds'),
            step?: long(name='Step'),
          }(name='ScaleUpRules'),
        }(name='Metric'),
        scaleRuleEnabled?: boolean(name='ScaleRuleEnabled'),
        scaleRuleName?: string(name='ScaleRuleName'),
        scaleRuleType?: string(name='ScaleRuleType'),
        timer?: {
          beginDate?: string(name='BeginDate'),
          endDate?: string(name='EndDate'),
          period?: string(name='Period'),
          schedules?: [ 
            {
              atTime?: string(name='AtTime'),
              maxReplicas?: long(name='MaxReplicas'),
              minReplicas?: long(name='MinReplicas'),
              targetReplicas?: int32(name='TargetReplicas'),
            }
          ](name='Schedules'),
        }(name='Timer'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='ApplicationScalingRules'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationScalingRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationScalingRulesResponseBody(name='body'),
}

async function describeApplicationScalingRules(request: DescribeApplicationScalingRulesRequest): DescribeApplicationScalingRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeApplicationScalingRules', 'GET', '/pop/v1/sam/scale/applicationScalingRules', 'json', false, 'json', request);
}

model DescribeApplicationSlbsRequest {
  appId: string(name='AppId', position='Query'),
}

model DescribeApplicationSlbsResponseBody = {
  code?: string(name='Code'),
  data?: {
    internet?: [ 
      {
        httpsCertId?: string(name='HttpsCertId'),
        port?: int32(name='Port'),
        protocol?: string(name='Protocol'),
        targetPort?: int32(name='TargetPort'),
      }
    ](name='Internet'),
    internetIp?: string(name='InternetIp'),
    internetSlbId?: string(name='InternetSlbId'),
    intranet?: [ 
      {
        httpsCertId?: string(name='HttpsCertId'),
        port?: int32(name='Port'),
        protocol?: string(name='Protocol'),
        targetPort?: int32(name='TargetPort'),
      }
    ](name='Intranet'),
    intranetIp?: string(name='IntranetIp'),
    intranetSlbId?: string(name='IntranetSlbId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationSlbsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationSlbsResponseBody(name='body'),
}

async function describeApplicationSlbs(request: DescribeApplicationSlbsRequest): DescribeApplicationSlbsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeApplicationSlbs', 'GET', '/pop/v1/sam/app/slb', 'json', false, 'json', request);
}

model DescribeApplicationStatusRequest {
  appId: string(name='AppId', position='Query'),
}

model DescribeApplicationStatusResponseBody = {
  code?: string(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    armsAdvancedEnabled?: string(name='ArmsAdvancedEnabled'),
    armsApmInfo?: string(name='ArmsApmInfo'),
    createTime?: string(name='CreateTime'),
    currentStatus?: string(name='CurrentStatus'),
    enableAgent?: boolean(name='EnableAgent'),
    fileSizeLimit?: long(name='FileSizeLimit'),
    lastChangeOrderId?: string(name='LastChangeOrderId'),
    lastChangeOrderRunning?: boolean(name='LastChangeOrderRunning'),
    lastChangeOrderStatus?: string(name='LastChangeOrderStatus'),
    runningInstances?: int32(name='RunningInstances'),
    subStatus?: string(name='SubStatus'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeApplicationStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeApplicationStatusResponseBody(name='body'),
}

async function describeApplicationStatus(request: DescribeApplicationStatusRequest): DescribeApplicationStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeApplicationStatus', 'GET', '/pop/v1/sam/app/describeApplicationStatus', 'json', false, 'json', request);
}

model DescribeChangeOrderRequest {
  changeOrderId: string(name='ChangeOrderId', position='Query'),
}

model DescribeChangeOrderResponseBody = {
  code?: string(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    approvalId?: string(name='ApprovalId'),
    auto?: boolean(name='Auto'),
    batchCount?: int32(name='BatchCount'),
    batchType?: string(name='BatchType'),
    batchWaitTime?: int32(name='BatchWaitTime'),
    changeOrderId?: string(name='ChangeOrderId'),
    coType?: string(name='CoType'),
    coTypeCode?: string(name='CoTypeCode'),
    createTime?: string(name='CreateTime'),
    currentPipelineId?: string(name='CurrentPipelineId'),
    description?: string(name='Description'),
    errorMessage?: string(name='ErrorMessage'),
    pipelines?: [ 
      {
        batchType?: int32(name='BatchType'),
        parallelCount?: int32(name='ParallelCount'),
        pipelineId?: string(name='PipelineId'),
        pipelineName?: string(name='PipelineName'),
        startTime?: long(name='StartTime'),
        status?: int32(name='Status'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='Pipelines'),
    status?: int32(name='Status'),
    subStatus?: int32(name='SubStatus'),
    supportRollback?: boolean(name='SupportRollback'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeChangeOrderResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeChangeOrderResponseBody(name='body'),
}

async function describeChangeOrder(request: DescribeChangeOrderRequest): DescribeChangeOrderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeChangeOrder', 'GET', '/pop/v1/sam/changeorder/DescribeChangeOrder', 'json', false, 'json', request);
}

model DescribeComponentsRequest {
  appId?: string(name='AppId', position='Query'),
  type: string(name='Type', position='Query'),
}

model DescribeComponentsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      componentDescription?: string(name='ComponentDescription'),
      componentKey?: string(name='ComponentKey'),
      expired?: boolean(name='Expired'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeComponentsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeComponentsResponseBody(name='body'),
}

async function describeComponents(request: DescribeComponentsRequest): DescribeComponentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeComponents', 'GET', '/pop/v1/sam/resource/components', 'json', false, 'json', request);
}

model DescribeConfigMapRequest {
  configMapId: long(name='ConfigMapId', position='Query'),
}

model DescribeConfigMapResponseBody = {
  code?: string(name='Code'),
  data?: {
    configMapId?: long(name='ConfigMapId'),
    createTime?: long(name='CreateTime'),
    data?: map[string]any(name='Data'),
    description?: string(name='Description'),
    name?: string(name='Name'),
    namespaceId?: string(name='NamespaceId'),
    relateApps?: [ 
      {
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
      }
    ](name='RelateApps'),
    updateTime?: long(name='UpdateTime'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeConfigMapResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeConfigMapResponseBody(name='body'),
}

async function describeConfigMap(request: DescribeConfigMapRequest): DescribeConfigMapResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeConfigMap', 'GET', '/pop/v1/sam/configmap/configMap', 'json', false, 'json', request);
}

model DescribeConfigurationPriceRequest {
  cpu: int32(name='Cpu', position='Query'),
  memory: int32(name='Memory', position='Query'),
  workload?: string(name='Workload', position='Query'),
}

model DescribeConfigurationPriceResponseBody = {
  code?: string(name='Code'),
  data?: {
    bagUsage?: {
      cpu?: float(name='Cpu'),
      mem?: float(name='Mem'),
    }(name='BagUsage'),
    order?: {
      discountAmount?: float(name='DiscountAmount'),
      originalAmount?: float(name='OriginalAmount'),
      ruleIds?: [ string ](name='RuleIds'),
      tradeAmount?: float(name='TradeAmount'),
    }(name='Order'),
    rules?: [ 
      {
        name?: string(name='Name'),
        ruleDescId?: long(name='RuleDescId'),
      }
    ](name='Rules'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeConfigurationPriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeConfigurationPriceResponseBody(name='body'),
}

async function describeConfigurationPrice(request: DescribeConfigurationPriceRequest): DescribeConfigurationPriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeConfigurationPrice', 'GET', '/pop/v1/paas/configurationPrice', 'json', false, 'json', request);
}

model DescribeEdasContainersRequest {
}

model DescribeEdasContainersResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      disabled?: boolean(name='Disabled'),
      edasContainerVersion?: string(name='EdasContainerVersion'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeEdasContainersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEdasContainersResponseBody(name='body'),
}

async function describeEdasContainers(request: DescribeEdasContainersRequest): DescribeEdasContainersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeEdasContainers', 'GET', '/pop/v1/sam/resource/edasContainers', 'json', false, 'json', request);
}

model DescribeGreyTagRouteRequest {
  greyTagRouteId: long(name='GreyTagRouteId', description='规则ID', minimum=1, position='Query'),
}

model DescribeGreyTagRouteResponseBody = {
  code?: string(name='Code'),
  data?: {
    appId?: string(name='AppId'),
    createTime?: long(name='CreateTime'),
    description?: string(name='Description'),
    dubboRules?: [ 
      {
        condition?: string(name='condition'),
        group?: string(name='group'),
        items?: [ 
          {
            cond?: string(name='cond'),
            expr?: string(name='expr'),
            index?: int32(name='index'),
            name?: string(name='name', description='abandon'),
            operator?: string(name='operator'),
            type?: string(name='type', description='abandon'),
            value?: string(name='value'),
          }
        ](name='items'),
        methodName?: string(name='methodName'),
        serviceName?: string(name='serviceName'),
        version?: string(name='version'),
      }
    ](name='DubboRules'),
    greyTagRouteId?: long(name='GreyTagRouteId'),
    name?: string(name='Name'),
    scRules?: [ 
      {
        condition?: string(name='condition'),
        items?: [ 
          {
            cond?: string(name='cond'),
            expr?: string(name='expr', description='abandon'),
            index?: int32(name='index', description='abandon'),
            name?: string(name='name'),
            operator?: string(name='operator'),
            type?: string(name='type'),
            value?: string(name='value'),
          }
        ](name='items'),
        path?: string(name='path'),
      }
    ](name='ScRules'),
    updateTime?: long(name='UpdateTime'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeGreyTagRouteResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGreyTagRouteResponseBody(name='body'),
}

async function describeGreyTagRoute(request: DescribeGreyTagRouteRequest): DescribeGreyTagRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeGreyTagRoute', 'GET', '/pop/v1/sam/tagroute/greyTagRoute', 'json', false, 'json', request);
}

model DescribeIngressRequest {
  ingressId: long(name='IngressId', position='Query'),
}

model DescribeIngressResponseBody = {
  code?: string(name='Code'),
  data?: {
    certId?: string(name='CertId'),
    defaultRule?: {
      appId?: string(name='AppId'),
      appName?: string(name='AppName'),
      backendProtocol?: string(name='BackendProtocol'),
      containerPort?: int32(name='ContainerPort'),
    }(name='DefaultRule'),
    description?: string(name='Description'),
    id?: long(name='Id'),
    listenerPort?: int32(name='ListenerPort'),
    listenerProtocol?: string(name='ListenerProtocol'),
    loadBalanceType?: string(name='LoadBalanceType'),
    name?: string(name='Name'),
    namespaceId?: string(name='NamespaceId'),
    rules?: [ 
      {
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        backendProtocol?: string(name='BackendProtocol'),
        containerPort?: int32(name='ContainerPort'),
        domain?: string(name='Domain'),
        path?: string(name='Path'),
      }
    ](name='Rules'),
    slbId?: string(name='SlbId'),
    slbType?: string(name='SlbType'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeIngressResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeIngressResponseBody(name='body'),
}

async function describeIngress(request: DescribeIngressRequest): DescribeIngressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeIngress', 'GET', '/pop/v1/sam/ingress/Ingress', 'json', false, 'json', request);
}

model DescribeInstanceLogRequest {
  instanceId: string(name='InstanceId', position='Query'),
}

model DescribeInstanceLogResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeInstanceLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceLogResponseBody(name='body'),
}

async function describeInstanceLog(request: DescribeInstanceLogRequest): DescribeInstanceLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeInstanceLog', 'GET', '/pop/v1/sam/instance/describeInstanceLog', 'json', false, 'json', request);
}

model DescribeInstanceSpecificationsRequest {
}

model DescribeInstanceSpecificationsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      cpu?: int32(name='Cpu'),
      enable?: boolean(name='Enable'),
      id?: int32(name='Id'),
      memory?: int32(name='Memory'),
      specInfo?: string(name='SpecInfo'),
      version?: int32(name='Version'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeInstanceSpecificationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceSpecificationsResponseBody(name='body'),
}

async function describeInstanceSpecifications(request: DescribeInstanceSpecificationsRequest): DescribeInstanceSpecificationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeInstanceSpecifications', 'GET', '/pop/v1/paas/quota/instanceSpecifications', 'json', false, 'json', request);
}

model DescribeNamespaceRequest {
  namespaceId: string(name='NamespaceId', position='Query'),
}

model DescribeNamespaceResponseBody = {
  code?: string(name='Code'),
  data?: {
    namespaceDescription?: string(name='NamespaceDescription'),
    namespaceId?: string(name='NamespaceId'),
    namespaceName?: string(name='NamespaceName'),
    regionId?: string(name='RegionId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNamespaceResponseBody(name='body'),
}

async function describeNamespace(request: DescribeNamespaceRequest): DescribeNamespaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeNamespace', 'GET', '/pop/v1/paas/namespace', 'json', false, 'json', request);
}

model DescribeNamespaceListRequest {
  containCustom?: boolean(name='ContainCustom', position='Query'),
  hybridCloudExclude?: boolean(name='HybridCloudExclude', position='Query'),
}

model DescribeNamespaceListResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      agentInstall?: string(name='AgentInstall'),
      current?: boolean(name='Current'),
      custom?: boolean(name='Custom'),
      hybridCloudEnable?: boolean(name='HybridCloudEnable'),
      namespaceId?: string(name='NamespaceId'),
      namespaceName?: string(name='NamespaceName'),
      regionId?: string(name='RegionId'),
      securityGroupId?: string(name='SecurityGroupId'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeNamespaceListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNamespaceListResponseBody(name='body'),
}

async function describeNamespaceList(request: DescribeNamespaceListRequest): DescribeNamespaceListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeNamespaceList', 'GET', '/pop/v1/sam/namespace/describeNamespaceList', 'json', false, 'json', request);
}

model DescribeNamespaceResourcesRequest {
  namespaceId?: string(name='NamespaceId', position='Query'),
}

model DescribeNamespaceResourcesResponseBody = {
  code?: string(name='Code'),
  data?: {
    appCount?: long(name='AppCount'),
    belongRegion?: string(name='BelongRegion'),
    description?: string(name='Description'),
    jumpServerAppId?: string(name='JumpServerAppId'),
    jumpServerIp?: string(name='JumpServerIp'),
    lastChangeOrderId?: string(name='LastChangeOrderId'),
    lastChangeOrderRunning?: boolean(name='LastChangeOrderRunning'),
    lastChangeOrderStatus?: string(name='LastChangeOrderStatus'),
    namespaceId?: string(name='NamespaceId'),
    namespaceName?: string(name='NamespaceName'),
    notificationExpired?: boolean(name='NotificationExpired'),
    securityGroupId?: string(name='SecurityGroupId'),
    tenantId?: string(name='TenantId'),
    userId?: string(name='UserId'),
    vSwitchId?: string(name='VSwitchId'),
    vSwitchName?: string(name='VSwitchName'),
    vpcId?: string(name='VpcId'),
    vpcName?: string(name='VpcName'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeNamespaceResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNamespaceResourcesResponseBody(name='body'),
}

async function describeNamespaceResources(request: DescribeNamespaceResourcesRequest): DescribeNamespaceResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeNamespaceResources', 'GET', '/pop/v1/sam/namespace/describeNamespaceResources', 'json', false, 'json', request);
}

model DescribeNamespacesRequest {
  currentPage: int32(name='CurrentPage', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
}

model DescribeNamespacesResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    namespaces?: [ 
      {
        accessKey?: string(name='AccessKey'),
        namespaceDescription?: string(name='NamespaceDescription'),
        namespaceId?: string(name='NamespaceId'),
        namespaceName?: string(name='NamespaceName'),
        regionId?: string(name='RegionId'),
        secretKey?: string(name='SecretKey'),
        tenantId?: string(name='TenantId'),
      }
    ](name='Namespaces'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribeNamespacesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNamespacesResponseBody(name='body'),
}

async function describeNamespaces(request: DescribeNamespacesRequest): DescribeNamespacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeNamespaces', 'GET', '/pop/v1/paas/namespaces', 'json', false, 'json', request);
}

model DescribePipelineRequest {
  pipelineId: string(name='PipelineId', position='Query'),
}

model DescribePipelineResponseBody = {
  code?: string(name='Code'),
  data?: {
    coStatus?: string(name='CoStatus'),
    currentStageId?: string(name='CurrentStageId'),
    nextPipelineId?: string(name='NextPipelineId'),
    pipelineId?: string(name='PipelineId'),
    pipelineName?: string(name='PipelineName'),
    pipelineStatus?: int32(name='PipelineStatus'),
    showBatch?: boolean(name='ShowBatch'),
    stageList?: [ 
      {
        executorType?: int32(name='ExecutorType'),
        stageId?: string(name='StageId'),
        stageName?: string(name='StageName'),
        status?: int32(name='Status'),
        taskList?: [ 
          {
            errorCode?: string(name='ErrorCode'),
            errorIgnore?: int32(name='ErrorIgnore'),
            errorMessage?: string(name='ErrorMessage'),
            message?: string(name='Message'),
            showManualIgnore?: boolean(name='ShowManualIgnore'),
            stageId?: string(name='StageId'),
            status?: int32(name='Status'),
            taskId?: string(name='TaskId'),
            taskName?: string(name='TaskName'),
          }
        ](name='TaskList'),
      }
    ](name='StageList'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model DescribePipelineResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePipelineResponseBody(name='body'),
}

async function describePipeline(request: DescribePipelineRequest): DescribePipelineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribePipeline', 'GET', '/pop/v1/sam/changeorder/DescribePipeline', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
}

model DescribeRegionsResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName'),
      recommendZones?: {
        recommendZone?: [ string ](name='RecommendZone')
      }(name='RecommendZones'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DescribeRegions', 'GET', '/pop/v1/paas/regionConfig', 'json', false, 'json', request);
}

model DisableApplicationScalingRuleRequest {
  appId: string(name='AppId', position='Query'),
  scalingRuleName: string(name='ScalingRuleName', position='Query'),
}

model DisableApplicationScalingRuleResponseBody = {
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model DisableApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableApplicationScalingRuleResponseBody(name='body'),
}

async function disableApplicationScalingRule(request: DisableApplicationScalingRuleRequest): DisableApplicationScalingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DisableApplicationScalingRule', 'PUT', '/pop/v1/sam/scale/disableApplicationScalingRule', 'json', false, 'json', request);
}

model EnableApplicationScalingRuleRequest {
  appId: string(name='AppId', position='Query'),
  scalingRuleName: string(name='ScalingRuleName', position='Query'),
}

model EnableApplicationScalingRuleResponseBody = {
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model EnableApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableApplicationScalingRuleResponseBody(name='body'),
}

async function enableApplicationScalingRule(request: EnableApplicationScalingRuleRequest): EnableApplicationScalingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'EnableApplicationScalingRule', 'PUT', '/pop/v1/sam/scale/enableApplicationScalingRule', 'json', false, 'json', request);
}

model ExecJobRequest {
  appId: string(name='AppId', position='Query'),
  command?: string(name='Command', position='Query'),
  commandArgs?: string(name='CommandArgs', position='Query'),
  envs?: string(name='Envs', position='Query'),
  eventId?: string(name='EventId', position='Query'),
  jarStartArgs?: string(name='JarStartArgs', position='Query'),
  jarStartOptions?: string(name='JarStartOptions', position='Query'),
  warStartOptions?: string(name='WarStartOptions', position='Query'),
}

model ExecJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    msg?: string(name='Msg'),
    success?: string(name='Success'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ExecJobResponse = {
  headers: map[string]string(name='headers'),
  body: ExecJobResponseBody(name='body'),
}

async function execJob(request: ExecJobRequest): ExecJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ExecJob', 'GET', '/pop/v1/sam/job/execJob', 'json', false, 'json', request);
}

model ListAppEventsRequest {
  appId?: string(name='AppId', position='Query'),
  currentPage?: int32(name='CurrentPage', position='Query'),
  eventType?: string(name='EventType', position='Query'),
  namespace: string(name='Namespace', position='Query'),
  objectKind?: string(name='ObjectKind', position='Query'),
  objectName?: string(name='ObjectName', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  reason?: string(name='Reason', position='Query'),
}

model ListAppEventsResponseBody = {
  code?: string(name='Code'),
  data?: {
    appEventEntity?: [ 
      {
        eventType?: string(name='EventType'),
        firstTimestamp?: string(name='FirstTimestamp'),
        lastTimestamp?: string(name='LastTimestamp'),
        message?: string(name='Message'),
        objectKind?: string(name='ObjectKind'),
        objectName?: string(name='ObjectName'),
        reason?: string(name='Reason'),
      }
    ](name='AppEventEntity'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAppEventsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAppEventsResponseBody(name='body'),
}

async function listAppEvents(request: ListAppEventsRequest): ListAppEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAppEvents', 'GET', '/pop/v1/sam/app/listAppEvents', 'json', false, 'json', request);
}

model ListAppServicesPageRequest {
  appId?: string(name='AppId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  serviceType?: string(name='ServiceType', position='Query'),
}

model ListAppServicesPageResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      currentPage?: string(name='CurrentPage'),
      pageNumber?: string(name='PageNumber'),
      pageSize?: string(name='PageSize'),
      result?: [ 
        {
          edasAppId?: string(name='EdasAppId'),
          edasAppName?: string(name='EdasAppName'),
          group?: string(name='Group'),
          instanceNum?: long(name='InstanceNum'),
          serviceName?: string(name='ServiceName'),
          version?: string(name='Version'),
        }
      ](name='Result'),
      totalSize?: string(name='TotalSize'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListAppServicesPageResponse = {
  headers: map[string]string(name='headers'),
  body: ListAppServicesPageResponseBody(name='body'),
}

async function listAppServicesPage(request: ListAppServicesPageRequest): ListAppServicesPageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAppServicesPage', 'GET', '/pop/v1/sam/service/listAppServicesPage', 'json', false, 'json', request);
}

model ListAppVersionsRequest {
  appId?: string(name='AppId', position='Query'),
}

model ListAppVersionsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      buildPackageUrl?: string(name='BuildPackageUrl'),
      createTime?: string(name='CreateTime'),
      id?: string(name='Id'),
      type?: string(name='Type'),
      warUrl?: string(name='WarUrl'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAppVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAppVersionsResponseBody(name='body'),
}

async function listAppVersions(request: ListAppVersionsRequest): ListAppVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAppVersions', 'GET', '/pop/v1/sam/app/listAppVersions', 'json', false, 'json', request);
}

model ListApplicationsRequest {
  appName?: string(name='AppName', position='Query'),
  currentPage?: int32(name='CurrentPage', position='Query'),
  fieldType?: string(name='FieldType', position='Query'),
  fieldValue?: string(name='FieldValue', position='Query'),
  namespaceId?: string(name='NamespaceId', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  reverse?: boolean(name='Reverse', position='Query'),
  tags?: string(name='Tags', position='Query'),
}

model ListApplicationsResponseBody = {
  code?: string(name='Code'),
  currentPage?: int32(name='CurrentPage'),
  data?: {
    applications?: [ 
      {
        appDeletingStatus?: boolean(name='AppDeletingStatus'),
        appDescription?: string(name='AppDescription'),
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        instances?: int32(name='Instances'),
        namespaceId?: string(name='NamespaceId'),
        regionId?: string(name='RegionId'),
        runningInstances?: int32(name='RunningInstances'),
        tags?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Tags'),
      }
    ](name='Applications'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalSize?: int32(name='TotalSize'),
}

model ListApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationsResponseBody(name='body'),
}

async function listApplications(request: ListApplicationsRequest): ListApplicationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListApplications', 'GET', '/pop/v1/sam/app/listApplications', 'json', false, 'json', request);
}

model ListChangeOrdersRequest {
  appId: string(name='AppId', position='Query'),
  coStatus?: string(name='CoStatus', position='Query'),
  coType?: string(name='CoType', position='Query'),
  currentPage?: int32(name='CurrentPage', position='Query'),
  key?: string(name='Key', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListChangeOrdersResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderList?: [ 
      {
        appId?: string(name='AppId'),
        batchCount?: int32(name='BatchCount'),
        batchType?: string(name='BatchType'),
        changeOrderId?: string(name='ChangeOrderId'),
        coType?: string(name='CoType'),
        coTypeCode?: string(name='CoTypeCode'),
        createTime?: string(name='CreateTime'),
        createUserId?: string(name='CreateUserId'),
        description?: string(name='Description'),
        finishTime?: string(name='FinishTime'),
        groupId?: string(name='GroupId'),
        source?: string(name='Source'),
        status?: int32(name='Status'),
        userId?: string(name='UserId'),
      }
    ](name='ChangeOrderList'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListChangeOrdersResponse = {
  headers: map[string]string(name='headers'),
  body: ListChangeOrdersResponseBody(name='body'),
}

async function listChangeOrders(request: ListChangeOrdersRequest): ListChangeOrdersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListChangeOrders', 'GET', '/pop/v1/sam/changeorder/ListChangeOrders', 'json', false, 'json', request);
}

model ListConsumedServicesRequest {
  appId: string(name='AppId', position='Query'),
}

model ListConsumedServicesResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      appId?: string(name='AppId'),
      group2Ip?: string(name='Group2Ip'),
      groups?: [ string ](name='Groups'),
      ips?: [ string ](name='Ips'),
      name?: string(name='Name'),
      type?: string(name='Type'),
      version?: string(name='Version'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListConsumedServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListConsumedServicesResponseBody(name='body'),
}

async function listConsumedServices(request: ListConsumedServicesRequest): ListConsumedServicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListConsumedServices', 'GET', '/pop/v1/sam/service/listConsumedServices', 'json', false, 'json', request);
}

model ListGreyTagRouteRequest {
  appId: string(name='AppId', description='应用ID', position='Query'),
}

model ListGreyTagRouteResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    result?: [ 
      {
        createTime?: long(name='CreateTime'),
        description?: string(name='Description'),
        dubboRules?: [ 
          {
            condition?: string(name='condition'),
            group?: string(name='group'),
            items?: [ 
              {
                cond?: string(name='cond'),
                expr?: string(name='expr'),
                index?: int32(name='index'),
                name?: string(name='name', description='abandon'),
                operator?: string(name='operator'),
                type?: string(name='type', description='abandon'),
                value?: string(name='value'),
              }
            ](name='items'),
            methodName?: string(name='methodName'),
            serviceName?: string(name='serviceName'),
            version?: string(name='version'),
          }
        ](name='DubboRules'),
        greyTagRouteId?: long(name='GreyTagRouteId'),
        name?: string(name='Name'),
        scRules?: [ 
          {
            condition?: string(name='condition'),
            items?: [ 
              {
                cond?: string(name='cond'),
                expr?: string(name='expr'),
                index?: int32(name='index', description='abandon'),
                name?: string(name='name'),
                operator?: string(name='operator'),
                type?: string(name='type'),
                value?: string(name='value'),
              }
            ](name='items'),
            path?: string(name='path'),
          }
        ](name='ScRules'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='Result'),
    totalSize?: long(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListGreyTagRouteResponse = {
  headers: map[string]string(name='headers'),
  body: ListGreyTagRouteResponseBody(name='body'),
}

async function listGreyTagRoute(request: ListGreyTagRouteRequest): ListGreyTagRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListGreyTagRoute', 'GET', '/pop/v1/sam/tagroute/greyTagRouteList', 'json', false, 'json', request);
}

model ListIngressesRequest {
  appId?: string(name='AppId', position='Query'),
  namespaceId: string(name='NamespaceId', position='Query'),
}

model ListIngressesResponseBody = {
  code?: string(name='Code'),
  data?: {
    ingressList?: [ 
      {
        certId?: string(name='CertId'),
        description?: string(name='Description'),
        id?: long(name='Id'),
        listenerPort?: string(name='ListenerPort'),
        listenerProtocol?: string(name='ListenerProtocol'),
        loadBalanceType?: string(name='LoadBalanceType'),
        name?: string(name='Name'),
        namespaceId?: string(name='NamespaceId'),
        slbId?: string(name='SlbId'),
        slbType?: string(name='SlbType'),
      }
    ](name='IngressList'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListIngressesResponse = {
  headers: map[string]string(name='headers'),
  body: ListIngressesResponseBody(name='body'),
}

async function listIngresses(request: ListIngressesRequest): ListIngressesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListIngresses', 'GET', '/pop/v1/sam/ingress/IngressList', 'json', false, 'json', request);
}

model ListLogConfigsRequest {
  appId: string(name='AppId', position='Query'),
  currentPage: int32(name='CurrentPage', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
}

model ListLogConfigsResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    logConfigs?: [ 
      {
        configName?: string(name='ConfigName'),
        createTime?: string(name='CreateTime'),
        logDir?: string(name='LogDir'),
        logType?: string(name='LogType'),
        regionId?: string(name='RegionId'),
        slsLogStore?: string(name='SlsLogStore'),
        slsProject?: string(name='SlsProject'),
        storeType?: string(name='StoreType'),
      }
    ](name='LogConfigs'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListLogConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListLogConfigsResponseBody(name='body'),
}

async function listLogConfigs(request: ListLogConfigsRequest): ListLogConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLogConfigs', 'GET', '/pop/v1/sam/log/listLogConfigs', 'json', false, 'json', request);
}

model ListNamespaceChangeOrdersRequest {
  coStatus?: string(name='CoStatus', position='Query'),
  coType?: string(name='CoType', position='Query'),
  currentPage?: int32(name='CurrentPage', position='Query'),
  key?: string(name='Key', position='Query'),
  namespaceId: string(name='NamespaceId', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
}

model ListNamespaceChangeOrdersResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderList?: [ 
      {
        batchCount?: int32(name='BatchCount'),
        batchType?: string(name='BatchType'),
        changeOrderId?: string(name='ChangeOrderId'),
        coType?: string(name='CoType'),
        coTypeCode?: string(name='CoTypeCode'),
        createTime?: string(name='CreateTime'),
        createUserId?: string(name='CreateUserId'),
        description?: string(name='Description'),
        finishTime?: string(name='FinishTime'),
        groupId?: string(name='GroupId'),
        namespaceId?: string(name='NamespaceId'),
        pipelines?: string(name='Pipelines'),
        source?: string(name='Source'),
        status?: int32(name='Status'),
        userId?: string(name='UserId'),
      }
    ](name='ChangeOrderList'),
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalSize?: int32(name='TotalSize'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListNamespaceChangeOrdersResponse = {
  headers: map[string]string(name='headers'),
  body: ListNamespaceChangeOrdersResponseBody(name='body'),
}

async function listNamespaceChangeOrders(request: ListNamespaceChangeOrdersRequest): ListNamespaceChangeOrdersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListNamespaceChangeOrders', 'GET', '/pop/v1/sam/changeorder/listNamespaceChangeOrders', 'json', false, 'json', request);
}

model ListNamespacedConfigMapsRequest {
  namespaceId: string(name='NamespaceId', position='Query'),
}

model ListNamespacedConfigMapsResponseBody = {
  code?: string(name='Code'),
  data?: {
    configMaps?: [ 
      {
        configMapId?: long(name='ConfigMapId'),
        createTime?: long(name='CreateTime'),
        data?: map[string]any(name='Data'),
        description?: string(name='Description'),
        name?: string(name='Name'),
        namespaceId?: string(name='NamespaceId'),
        relateApps?: [ 
          {
            appId?: string(name='AppId'),
            appName?: string(name='AppName'),
          }
        ](name='RelateApps'),
        updateTime?: long(name='UpdateTime'),
      }
    ](name='ConfigMaps'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListNamespacedConfigMapsResponse = {
  headers: map[string]string(name='headers'),
  body: ListNamespacedConfigMapsResponseBody(name='body'),
}

async function listNamespacedConfigMaps(request: ListNamespacedConfigMapsRequest): ListNamespacedConfigMapsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListNamespacedConfigMaps', 'GET', '/pop/v1/sam/configmap/listNamespacedConfigMaps', 'json', false, 'json', request);
}

model ListPublishedServicesRequest {
  appId: string(name='AppId', position='Query'),
}

model ListPublishedServicesResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      appId?: string(name='AppId'),
      group2Ip?: string(name='Group2Ip'),
      groups?: [ string ](name='Groups'),
      ips?: [ string ](name='Ips'),
      name?: string(name='Name'),
      type?: string(name='Type'),
      version?: string(name='Version'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListPublishedServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPublishedServicesResponseBody(name='body'),
}

async function listPublishedServices(request: ListPublishedServicesRequest): ListPublishedServicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListPublishedServices', 'GET', '/pop/v1/sam/service/listPublishedServices', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceIds?: string(name='ResourceIds', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tags?: string(name='Tags', position='Query'),
}

model ListTagResourcesResponseBody = {
  code?: string(name='Code'),
  data?: {
    nextToken?: string(name='NextToken'),
    tagResources?: [ 
      {
        resourceId?: string(name='ResourceId'),
        resourceType?: string(name='ResourceType'),
        tagKey?: string(name='TagKey'),
        tagValue?: string(name='TagValue'),
      }
    ](name='TagResources'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTagResources', 'GET', '/tags', 'json', false, 'json', request);
}

model OpenSaeServiceRequest {
}

model OpenSaeServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenSaeServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenSaeServiceResponseBody(name='body'),
}

async function openSaeService(request: OpenSaeServiceRequest): OpenSaeServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'OpenSaeService', 'POST', '/service/open', 'json', false, 'json', request);
}

model QueryResourceStaticsRequest {
  appId: string(name='AppId', position='Query'),
}

model QueryResourceStaticsResponseBody = {
  code?: string(name='Code'),
  data?: {
    realTimeRes?: {
      cpu?: float(name='Cpu'),
      memory?: float(name='Memory'),
    }(name='RealTimeRes'),
    summary?: {
      cpu?: float(name='Cpu'),
      memory?: float(name='Memory'),
    }(name='Summary'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model QueryResourceStaticsResponse = {
  headers: map[string]string(name='headers'),
  body: QueryResourceStaticsResponseBody(name='body'),
}

async function queryResourceStatics(request: QueryResourceStaticsRequest): QueryResourceStaticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'QueryResourceStatics', 'GET', '/pop/v1/paas/quota/queryResourceStatics', 'json', false, 'json', request);
}

model ReduceApplicationCapacityByInstanceIdsRequest {
  appId: string(name='AppId', position='Query'),
  instanceIds: string(name='InstanceIds', position='Query'),
}

model ReduceApplicationCapacityByInstanceIdsResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model ReduceApplicationCapacityByInstanceIdsResponse = {
  headers: map[string]string(name='headers'),
  body: ReduceApplicationCapacityByInstanceIdsResponseBody(name='body'),
}

async function reduceApplicationCapacityByInstanceIds(request: ReduceApplicationCapacityByInstanceIdsRequest): ReduceApplicationCapacityByInstanceIdsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ReduceApplicationCapacityByInstanceIds', 'PUT', '/pop/v1/sam/app/ScaleInApplicationWithInstanceIds', 'json', false, 'json', request);
}

model RescaleApplicationRequest {
  appId: string(name='AppId', position='Query'),
  autoEnableApplicationScalingRule?: boolean(name='AutoEnableApplicationScalingRule', position='Query'),
  minReadyInstanceRatio?: int32(name='MinReadyInstanceRatio', position='Query'),
  minReadyInstances?: int32(name='MinReadyInstances', position='Query'),
  replicas: int32(name='Replicas', position='Query'),
}

model RescaleApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RescaleApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RescaleApplicationResponseBody(name='body'),
}

async function rescaleApplication(request: RescaleApplicationRequest): RescaleApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RescaleApplication', 'PUT', '/pop/v1/sam/app/rescaleApplication', 'json', false, 'json', request);
}

model RescaleApplicationVerticallyRequest {
  appId: string(name='AppId', position='Query'),
  cpu: string(name='Cpu', position='Query'),
  memory: string(name='Memory', position='Query'),
}

model RescaleApplicationVerticallyResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model RescaleApplicationVerticallyResponse = {
  headers: map[string]string(name='headers'),
  body: RescaleApplicationVerticallyResponseBody(name='body'),
}

async function rescaleApplicationVertically(request: RescaleApplicationVerticallyRequest): RescaleApplicationVerticallyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RescaleApplicationVertically', 'POST', '/pop/v1/sam/app/rescaleApplicationVertically', 'json', false, 'json', request);
}

model RestartApplicationRequest {
  appId: string(name='AppId', position='Query'),
  minReadyInstanceRatio?: int32(name='MinReadyInstanceRatio', position='Query'),
  minReadyInstances?: int32(name='MinReadyInstances', position='Query'),
}

model RestartApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model RestartApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RestartApplicationResponseBody(name='body'),
}

async function restartApplication(request: RestartApplicationRequest): RestartApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RestartApplication', 'PUT', '/pop/v1/sam/app/restartApplication', 'json', false, 'json', request);
}

model RestartInstancesRequest {
  appId: string(name='AppId', position='Query'),
  instanceIds: string(name='InstanceIds', position='Query'),
}

model RestartInstancesResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model RestartInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: RestartInstancesResponseBody(name='body'),
}

async function restartInstances(request: RestartInstancesRequest): RestartInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RestartInstances', 'PUT', '/pop/v1/sam/app/restartInstances', 'json', false, 'json', request);
}

model RollbackApplicationRequest {
  appId: string(name='AppId', position='Query'),
  autoEnableApplicationScalingRule?: string(name='AutoEnableApplicationScalingRule', position='Query'),
  batchWaitTime?: int32(name='BatchWaitTime', position='Query'),
  minReadyInstanceRatio?: int32(name='MinReadyInstanceRatio', position='Query'),
  minReadyInstances?: int32(name='MinReadyInstances', position='Query'),
  updateStrategy?: string(name='UpdateStrategy', position='Query'),
  versionId: string(name='VersionId', position='Query'),
}

model RollbackApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
    isNeedApproval?: boolean(name='IsNeedApproval'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model RollbackApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: RollbackApplicationResponseBody(name='body'),
}

async function rollbackApplication(request: RollbackApplicationRequest): RollbackApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RollbackApplication', 'PUT', '/pop/v1/sam/app/rollbackApplication', 'json', false, 'json', request);
}

model StartApplicationRequest {
  appId: string(name='AppId', position='Query'),
}

model StartApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model StartApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: StartApplicationResponseBody(name='body'),
}

async function startApplication(request: StartApplicationRequest): StartApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StartApplication', 'PUT', '/pop/v1/sam/app/startApplication', 'json', false, 'json', request);
}

model StopApplicationRequest {
  appId: string(name='AppId', position='Query'),
}

model StopApplicationResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model StopApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: StopApplicationResponseBody(name='body'),
}

async function stopApplication(request: StopApplicationRequest): StopApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopApplication', 'PUT', '/pop/v1/sam/app/stopApplication', 'json', false, 'json', request);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId', position='Body'),
  resourceIds?: string(name='ResourceIds', position='Body'),
  resourceType?: string(name='ResourceType', position='Body'),
  tags?: string(name='Tags', position='Body'),
}

model TagResourcesResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'TagResources', 'POST', '/tags', 'json', true, 'form', request);
}

model UnbindSlbRequest {
  appId: string(name='AppId', position='Query'),
  internet?: boolean(name='Internet', position='Query'),
  intranet?: boolean(name='Intranet', position='Query'),
}

model UnbindSlbResponseBody = {
  code?: string(name='Code'),
  data?: {
    changeOrderId?: string(name='ChangeOrderId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UnbindSlbResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindSlbResponseBody(name='body'),
}

async function unbindSlb(request: UnbindSlbRequest): UnbindSlbResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UnbindSlb', 'DELETE', '/pop/v1/sam/app/slb', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  deleteAll?: boolean(name='DeleteAll', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceIds: string(name='ResourceIds', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tagKeys?: string(name='TagKeys', position='Query'),
}

model UntagResourcesResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UntagResources', 'DELETE', '/tags', 'json', false, 'json', request);
}

model UpdateAppSecurityGroupRequest {
  appId: string(name='AppId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
}

model UpdateAppSecurityGroupResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateAppSecurityGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAppSecurityGroupResponseBody(name='body'),
}

async function updateAppSecurityGroup(request: UpdateAppSecurityGroupRequest): UpdateAppSecurityGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateAppSecurityGroup', 'PUT', '/pop/v1/sam/app/updateAppSecurityGroup', 'json', false, 'json', request);
}

model UpdateApplicationDescriptionRequest {
  appDescription: string(name='AppDescription', position='Query'),
  appId: string(name='AppId', position='Query'),
}

model UpdateApplicationDescriptionResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateApplicationDescriptionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateApplicationDescriptionResponseBody(name='body'),
}

async function updateApplicationDescription(request: UpdateApplicationDescriptionRequest): UpdateApplicationDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateApplicationDescription', 'PUT', '/pop/v1/sam/app/updateAppDescription', 'json', false, 'json', request);
}

model UpdateApplicationScalingRuleRequest {
  appId: string(name='AppId', position='Query'),
  minReadyInstanceRatio?: int32(name='MinReadyInstanceRatio', position='Query'),
  minReadyInstances?: int32(name='MinReadyInstances', position='Query'),
  scalingRuleMetric?: string(name='ScalingRuleMetric', position='Query'),
  scalingRuleName: string(name='ScalingRuleName', position='Query'),
  scalingRuleTimer?: string(name='ScalingRuleTimer', position='Query'),
}

model UpdateApplicationScalingRuleResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    createTime?: long(name='CreateTime'),
    lastDisableTime?: long(name='LastDisableTime'),
    metric?: {
      maxReplicas?: int32(name='MaxReplicas'),
      metrics?: [ 
        {
          metricTargetAverageUtilization?: int32(name='MetricTargetAverageUtilization'),
          metricType?: string(name='MetricType'),
        }
      ](name='Metrics'),
      minReplicas?: int32(name='MinReplicas'),
    }(name='Metric'),
    scaleRuleEnabled?: boolean(name='ScaleRuleEnabled'),
    scaleRuleName?: string(name='ScaleRuleName'),
    scaleRuleType?: string(name='ScaleRuleType'),
    timer?: {
      beginDate?: string(name='BeginDate'),
      endDate?: string(name='EndDate'),
      period?: string(name='Period'),
      schedules?: [ 
        {
          atTime?: string(name='AtTime'),
          targetReplicas?: int32(name='TargetReplicas'),
        }
      ](name='Schedules'),
    }(name='Timer'),
    updateTime?: long(name='UpdateTime'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
  traceId?: string(name='TraceId'),
}

model UpdateApplicationScalingRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateApplicationScalingRuleResponseBody(name='body'),
}

async function updateApplicationScalingRule(request: UpdateApplicationScalingRuleRequest): UpdateApplicationScalingRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateApplicationScalingRule', 'PUT', '/pop/v1/sam/scale/applicationScalingRule', 'json', false, 'json', request);
}

model UpdateApplicationVswitchesRequest {
  appId: string(name='AppId', position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
}

model UpdateApplicationVswitchesResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateApplicationVswitchesResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateApplicationVswitchesResponseBody(name='body'),
}

async function updateApplicationVswitches(request: UpdateApplicationVswitchesRequest): UpdateApplicationVswitchesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateApplicationVswitches', 'PUT', '/pop/v1/sam/app/updateAppVswitches', 'json', false, 'json', request);
}

model UpdateConfigMapRequest {
  configMapId: long(name='ConfigMapId', position='Query'),
  description?: string(name='Description', position='Query'),
}

model UpdateConfigMapResponseBody = {
  code?: string(name='Code'),
  data?: {
    configMapId?: string(name='ConfigMapId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateConfigMapResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateConfigMapResponseBody(name='body'),
}

async function updateConfigMap(request: UpdateConfigMapRequest): UpdateConfigMapResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateConfigMap', 'PUT', '/pop/v1/sam/configmap/configMap', 'json', false, 'json', request);
}

model UpdateGreyTagRouteRequest {
  description?: string(name='Description', description='规则名称', position='Query'),
  dubboRules?: string(name='DubboRules', description='Dubbo规则', position='Query'),
  greyTagRouteId: long(name='GreyTagRouteId', description='规则ID', position='Query'),
  scRules?: string(name='ScRules', description='SpringCloud规则', position='Query'),
}

model UpdateGreyTagRouteResponseBody = {
  code?: string(name='Code'),
  data?: {
    greyTagRouteId?: long(name='GreyTagRouteId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateGreyTagRouteResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGreyTagRouteResponseBody(name='body'),
}

async function updateGreyTagRoute(request: UpdateGreyTagRouteRequest): UpdateGreyTagRouteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateGreyTagRoute', 'PUT', '/pop/v1/sam/tagroute/greyTagRoute', 'json', false, 'json', request);
}

model UpdateIngressRequest {
  certId?: string(name='CertId', position='Query'),
  defaultRule?: string(name='DefaultRule', position='Query'),
  description?: string(name='Description', position='Query'),
  ingressId: long(name='IngressId', position='Query'),
  listenerPort?: string(name='ListenerPort', position='Query'),
  listenerProtocol?: string(name='ListenerProtocol', position='Query'),
  loadBalanceType?: string(name='LoadBalanceType', position='Query'),
  rules?: string(name='Rules', position='Body'),
}

model UpdateIngressResponseBody = {
  code?: string(name='Code'),
  data?: {
    ingressId?: long(name='IngressId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateIngressResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateIngressResponseBody(name='body'),
}

async function updateIngress(request: UpdateIngressRequest): UpdateIngressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateIngress', 'PUT', '/pop/v1/sam/ingress/Ingress', 'json', true, 'form', request);
}

model UpdateNamespaceRequest {
  namespaceDescription?: string(name='NamespaceDescription', position='Query'),
  namespaceId: string(name='NamespaceId', position='Query'),
  namespaceName: string(name='NamespaceName', position='Query'),
}

model UpdateNamespaceResponseBody = {
  code?: string(name='Code'),
  data?: {
    namespaceDescription?: string(name='NamespaceDescription'),
    namespaceId?: string(name='NamespaceId'),
    namespaceName?: string(name='NamespaceName'),
    regionId?: string(name='RegionId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNamespaceResponseBody(name='body'),
}

async function updateNamespace(request: UpdateNamespaceRequest): UpdateNamespaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateNamespace', 'PUT', '/pop/v1/paas/namespace', 'json', false, 'json', request);
}

model UpdateNamespaceVpcRequest {
  namespaceId: string(name='NamespaceId', position='Query'),
  vpcId: string(name='VpcId', position='Query'),
}

model UpdateNamespaceVpcResponseBody = {
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  traceId?: string(name='TraceId'),
}

model UpdateNamespaceVpcResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateNamespaceVpcResponseBody(name='body'),
}

async function updateNamespaceVpc(request: UpdateNamespaceVpcRequest): UpdateNamespaceVpcResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateNamespaceVpc', 'POST', '/pop/v1/sam/namespace/updateNamespaceVpc', 'json', false, 'json', request);
}

