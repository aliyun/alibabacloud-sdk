/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('resourcesharing', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AcceptResourceShareInvitationRequest {
  resourceShareInvitationId?: string(name='ResourceShareInvitationId'),
}

model AcceptResourceShareInvitationResponseBody = {
  requestId?: string(name='RequestId'),
  resourceShareInvitation?: {
    createTime?: string(name='CreateTime'),
    receiverAccountId?: string(name='ReceiverAccountId'),
    resourceShareId?: string(name='ResourceShareId'),
    resourceShareInvitationId?: string(name='ResourceShareInvitationId'),
    resourceShareName?: string(name='ResourceShareName'),
    senderAccountId?: string(name='SenderAccountId'),
    status?: string(name='Status'),
  }(name='ResourceShareInvitation'),
}

model AcceptResourceShareInvitationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AcceptResourceShareInvitationResponseBody(name='body'),
}

async function acceptResourceShareInvitationWithOptions(request: AcceptResourceShareInvitationRequest, runtime: Util.RuntimeOptions): AcceptResourceShareInvitationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceShareInvitationId)) {
    query['ResourceShareInvitationId'] = request.resourceShareInvitationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AcceptResourceShareInvitation',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function acceptResourceShareInvitation(request: AcceptResourceShareInvitationRequest): AcceptResourceShareInvitationResponse {
  var runtime = new Util.RuntimeOptions{};
  return acceptResourceShareInvitationWithOptions(request, runtime);
}

model AssociateResourceShareRequest {
  permissionNames?: [ string ](name='PermissionNames'),
  resourceShareId?: string(name='ResourceShareId'),
  resources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resources'),
  targets?: [ string ](name='Targets'),
}

model AssociateResourceShareResponseBody = {
  requestId?: string(name='RequestId'),
  resourceShareAssociations?: [ 
    {
      associationStatus?: string(name='AssociationStatus'),
      associationStatusMessage?: string(name='AssociationStatusMessage'),
      associationType?: string(name='AssociationType'),
      createTime?: string(name='CreateTime'),
      entityId?: string(name='EntityId'),
      entityType?: string(name='EntityType'),
      resourceShareId?: string(name='ResourceShareId'),
      resourceShareName?: string(name='ResourceShareName'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ResourceShareAssociations'),
}

model AssociateResourceShareResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateResourceShareResponseBody(name='body'),
}

async function associateResourceShareWithOptions(request: AssociateResourceShareRequest, runtime: Util.RuntimeOptions): AssociateResourceShareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.permissionNames)) {
    query['PermissionNames'] = request.permissionNames;
  }
  if (!Util.isUnset(request.resourceShareId)) {
    query['ResourceShareId'] = request.resourceShareId;
  }
  if (!Util.isUnset(request.resources)) {
    query['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.targets)) {
    query['Targets'] = request.targets;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateResourceShare',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateResourceShare(request: AssociateResourceShareRequest): AssociateResourceShareResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateResourceShareWithOptions(request, runtime);
}

model AssociateResourceSharePermissionRequest {
  permissionName?: string(name='PermissionName'),
  replace?: boolean(name='Replace'),
  resourceShareId?: string(name='ResourceShareId'),
}

model AssociateResourceSharePermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateResourceSharePermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateResourceSharePermissionResponseBody(name='body'),
}

async function associateResourceSharePermissionWithOptions(request: AssociateResourceSharePermissionRequest, runtime: Util.RuntimeOptions): AssociateResourceSharePermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.permissionName)) {
    query['PermissionName'] = request.permissionName;
  }
  if (!Util.isUnset(request.replace)) {
    query['Replace'] = request.replace;
  }
  if (!Util.isUnset(request.resourceShareId)) {
    query['ResourceShareId'] = request.resourceShareId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateResourceSharePermission',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateResourceSharePermission(request: AssociateResourceSharePermissionRequest): AssociateResourceSharePermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateResourceSharePermissionWithOptions(request, runtime);
}

model CreateResourceShareRequest {
  allowExternalTargets?: boolean(name='AllowExternalTargets'),
  permissionNames?: [ string ](name='PermissionNames'),
  resourceShareName?: string(name='ResourceShareName'),
  resources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resources'),
  targets?: [ string ](name='Targets'),
}

model CreateResourceShareResponseBody = {
  requestId?: string(name='RequestId'),
  resourceShare?: {
    allowExternalTargets?: boolean(name='AllowExternalTargets'),
    createTime?: string(name='CreateTime'),
    resourceShareId?: string(name='ResourceShareId'),
    resourceShareName?: string(name='ResourceShareName'),
    resourceShareOwner?: string(name='ResourceShareOwner'),
    resourceShareStatus?: string(name='ResourceShareStatus'),
    updateTime?: string(name='UpdateTime'),
  }(name='ResourceShare'),
}

model CreateResourceShareResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceShareResponseBody(name='body'),
}

async function createResourceShareWithOptions(request: CreateResourceShareRequest, runtime: Util.RuntimeOptions): CreateResourceShareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowExternalTargets)) {
    query['AllowExternalTargets'] = request.allowExternalTargets;
  }
  if (!Util.isUnset(request.permissionNames)) {
    query['PermissionNames'] = request.permissionNames;
  }
  if (!Util.isUnset(request.resourceShareName)) {
    query['ResourceShareName'] = request.resourceShareName;
  }
  if (!Util.isUnset(request.resources)) {
    query['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.targets)) {
    query['Targets'] = request.targets;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceShare',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createResourceShare(request: CreateResourceShareRequest): CreateResourceShareResponse {
  var runtime = new Util.RuntimeOptions{};
  return createResourceShareWithOptions(request, runtime);
}

model DeleteResourceShareRequest {
  resourceShareId?: string(name='ResourceShareId'),
}

model DeleteResourceShareResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteResourceShareResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceShareResponseBody(name='body'),
}

async function deleteResourceShareWithOptions(request: DeleteResourceShareRequest, runtime: Util.RuntimeOptions): DeleteResourceShareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceShareId)) {
    query['ResourceShareId'] = request.resourceShareId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceShare',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteResourceShare(request: DeleteResourceShareRequest): DeleteResourceShareResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteResourceShareWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DisassociateResourceShareRequest {
  resourceOwner?: string(name='ResourceOwner'),
  resourceShareId?: string(name='ResourceShareId'),
  resources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resources'),
  targets?: [ string ](name='Targets'),
}

model DisassociateResourceShareResponseBody = {
  requestId?: string(name='RequestId'),
  resourceShareAssociations?: [ 
    {
      associationStatus?: string(name='AssociationStatus'),
      associationStatusMessage?: string(name='AssociationStatusMessage'),
      associationType?: string(name='AssociationType'),
      createTime?: string(name='CreateTime'),
      entityId?: string(name='EntityId'),
      entityType?: string(name='EntityType'),
      resourceShareId?: string(name='ResourceShareId'),
      resourceShareName?: string(name='ResourceShareName'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ResourceShareAssociations'),
}

model DisassociateResourceShareResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisassociateResourceShareResponseBody(name='body'),
}

async function disassociateResourceShareWithOptions(request: DisassociateResourceShareRequest, runtime: Util.RuntimeOptions): DisassociateResourceShareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceOwner)) {
    query['ResourceOwner'] = request.resourceOwner;
  }
  if (!Util.isUnset(request.resourceShareId)) {
    query['ResourceShareId'] = request.resourceShareId;
  }
  if (!Util.isUnset(request.resources)) {
    query['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.targets)) {
    query['Targets'] = request.targets;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisassociateResourceShare',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disassociateResourceShare(request: DisassociateResourceShareRequest): DisassociateResourceShareResponse {
  var runtime = new Util.RuntimeOptions{};
  return disassociateResourceShareWithOptions(request, runtime);
}

model DisassociateResourceSharePermissionRequest {
  permissionName?: string(name='PermissionName'),
  resourceShareId?: string(name='ResourceShareId'),
}

model DisassociateResourceSharePermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisassociateResourceSharePermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisassociateResourceSharePermissionResponseBody(name='body'),
}

async function disassociateResourceSharePermissionWithOptions(request: DisassociateResourceSharePermissionRequest, runtime: Util.RuntimeOptions): DisassociateResourceSharePermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.permissionName)) {
    query['PermissionName'] = request.permissionName;
  }
  if (!Util.isUnset(request.resourceShareId)) {
    query['ResourceShareId'] = request.resourceShareId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisassociateResourceSharePermission',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disassociateResourceSharePermission(request: DisassociateResourceSharePermissionRequest): DisassociateResourceSharePermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return disassociateResourceSharePermissionWithOptions(request, runtime);
}

model EnableSharingWithResourceDirectoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableSharingWithResourceDirectoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableSharingWithResourceDirectoryResponseBody(name='body'),
}

async function enableSharingWithResourceDirectoryWithOptions(runtime: Util.RuntimeOptions): EnableSharingWithResourceDirectoryResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'EnableSharingWithResourceDirectory',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableSharingWithResourceDirectory(): EnableSharingWithResourceDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableSharingWithResourceDirectoryWithOptions(runtime);
}

model GetPermissionRequest {
  permissionName?: string(name='PermissionName'),
  permissionVersion?: string(name='PermissionVersion'),
}

model GetPermissionResponseBody = {
  permission?: {
    createTime?: string(name='CreateTime'),
    defaultPermission?: boolean(name='DefaultPermission'),
    defaultVersion?: boolean(name='DefaultVersion'),
    permission?: string(name='Permission'),
    permissionName?: string(name='PermissionName'),
    permissionVersion?: string(name='PermissionVersion'),
    resourceType?: string(name='ResourceType'),
    updateTime?: string(name='UpdateTime'),
  }(name='Permission'),
  requestId?: string(name='RequestId'),
}

model GetPermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPermissionResponseBody(name='body'),
}

async function getPermissionWithOptions(request: GetPermissionRequest, runtime: Util.RuntimeOptions): GetPermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.permissionName)) {
    query['PermissionName'] = request.permissionName;
  }
  if (!Util.isUnset(request.permissionVersion)) {
    query['PermissionVersion'] = request.permissionVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPermission',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPermission(request: GetPermissionRequest): GetPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPermissionWithOptions(request, runtime);
}

model ListPermissionVersionsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  permissionName?: string(name='PermissionName'),
}

model ListPermissionVersionsResponseBody = {
  nextToken?: string(name='NextToken'),
  permissions?: [ 
    {
      createTime?: string(name='CreateTime'),
      defaultPermission?: boolean(name='DefaultPermission'),
      defaultVersion?: boolean(name='DefaultVersion'),
      permissionName?: string(name='PermissionName'),
      permissionVersion?: string(name='PermissionVersion'),
      resourceType?: string(name='ResourceType'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Permissions'),
  requestId?: string(name='RequestId'),
}

model ListPermissionVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPermissionVersionsResponseBody(name='body'),
}

async function listPermissionVersionsWithOptions(request: ListPermissionVersionsRequest, runtime: Util.RuntimeOptions): ListPermissionVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.permissionName)) {
    query['PermissionName'] = request.permissionName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPermissionVersions',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPermissionVersions(request: ListPermissionVersionsRequest): ListPermissionVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPermissionVersionsWithOptions(request, runtime);
}

model ListPermissionsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceType?: string(name='ResourceType'),
}

model ListPermissionsResponseBody = {
  nextToken?: string(name='NextToken'),
  permissions?: [ 
    {
      createTime?: string(name='CreateTime'),
      defaultPermission?: boolean(name='DefaultPermission'),
      defaultVersion?: boolean(name='DefaultVersion'),
      permissionName?: string(name='PermissionName'),
      permissionVersion?: string(name='PermissionVersion'),
      resourceType?: string(name='ResourceType'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Permissions'),
  requestId?: string(name='RequestId'),
}

model ListPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPermissionsResponseBody(name='body'),
}

async function listPermissionsWithOptions(request: ListPermissionsRequest, runtime: Util.RuntimeOptions): ListPermissionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPermissions',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPermissions(request: ListPermissionsRequest): ListPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPermissionsWithOptions(request, runtime);
}

model ListResourceShareAssociationsRequest {
  associationStatus?: string(name='AssociationStatus'),
  associationType?: string(name='AssociationType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceId?: string(name='ResourceId'),
  resourceShareIds?: [ string ](name='ResourceShareIds'),
  target?: string(name='Target'),
}

model ListResourceShareAssociationsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  resourceShareAssociations?: [ 
    {
      associationStatus?: string(name='AssociationStatus'),
      associationStatusMessage?: string(name='AssociationStatusMessage'),
      associationType?: string(name='AssociationType'),
      createTime?: string(name='CreateTime'),
      entityId?: string(name='EntityId'),
      entityType?: string(name='EntityType'),
      external?: boolean(name='External'),
      resourceShareId?: string(name='ResourceShareId'),
      resourceShareName?: string(name='ResourceShareName'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ResourceShareAssociations'),
}

model ListResourceShareAssociationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceShareAssociationsResponseBody(name='body'),
}

async function listResourceShareAssociationsWithOptions(request: ListResourceShareAssociationsRequest, runtime: Util.RuntimeOptions): ListResourceShareAssociationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.associationStatus)) {
    query['AssociationStatus'] = request.associationStatus;
  }
  if (!Util.isUnset(request.associationType)) {
    query['AssociationType'] = request.associationType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceShareIds)) {
    query['ResourceShareIds'] = request.resourceShareIds;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceShareAssociations',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceShareAssociations(request: ListResourceShareAssociationsRequest): ListResourceShareAssociationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceShareAssociationsWithOptions(request, runtime);
}

model ListResourceShareInvitationsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceShareIds?: [ string ](name='ResourceShareIds'),
  resourceShareInvitationIds?: [ string ](name='ResourceShareInvitationIds'),
}

model ListResourceShareInvitationsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  resourceShareInvitations?: [ 
    {
      createTime?: string(name='CreateTime'),
      receiverAccountId?: string(name='ReceiverAccountId'),
      resourceShareId?: string(name='ResourceShareId'),
      resourceShareInvitationId?: string(name='ResourceShareInvitationId'),
      resourceShareName?: string(name='ResourceShareName'),
      senderAccountId?: string(name='SenderAccountId'),
      status?: string(name='Status'),
    }
  ](name='ResourceShareInvitations'),
}

model ListResourceShareInvitationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceShareInvitationsResponseBody(name='body'),
}

async function listResourceShareInvitationsWithOptions(request: ListResourceShareInvitationsRequest, runtime: Util.RuntimeOptions): ListResourceShareInvitationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceShareIds)) {
    query['ResourceShareIds'] = request.resourceShareIds;
  }
  if (!Util.isUnset(request.resourceShareInvitationIds)) {
    query['ResourceShareInvitationIds'] = request.resourceShareInvitationIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceShareInvitations',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceShareInvitations(request: ListResourceShareInvitationsRequest): ListResourceShareInvitationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceShareInvitationsWithOptions(request, runtime);
}

model ListResourceSharePermissionsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceOwner?: string(name='ResourceOwner'),
  resourceShareId?: string(name='ResourceShareId'),
}

model ListResourceSharePermissionsResponseBody = {
  nextToken?: string(name='NextToken'),
  permissions?: [ 
    {
      createTime?: string(name='CreateTime'),
      defaultPermission?: boolean(name='DefaultPermission'),
      defaultVersion?: boolean(name='DefaultVersion'),
      permissionName?: string(name='PermissionName'),
      permissionVersion?: string(name='PermissionVersion'),
      resourceType?: string(name='ResourceType'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Permissions'),
  requestId?: string(name='RequestId'),
}

model ListResourceSharePermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceSharePermissionsResponseBody(name='body'),
}

async function listResourceSharePermissionsWithOptions(request: ListResourceSharePermissionsRequest, runtime: Util.RuntimeOptions): ListResourceSharePermissionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceOwner)) {
    query['ResourceOwner'] = request.resourceOwner;
  }
  if (!Util.isUnset(request.resourceShareId)) {
    query['ResourceShareId'] = request.resourceShareId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceSharePermissions',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceSharePermissions(request: ListResourceSharePermissionsRequest): ListResourceSharePermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceSharePermissionsWithOptions(request, runtime);
}

model ListResourceSharesRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  permissionName?: string(name='PermissionName'),
  resourceOwner?: string(name='ResourceOwner'),
  resourceShareIds?: [ string ](name='ResourceShareIds'),
  resourceShareName?: string(name='ResourceShareName'),
  resourceShareStatus?: string(name='ResourceShareStatus'),
}

model ListResourceSharesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  resourceShares?: [ 
    {
      allowExternalTargets?: boolean(name='AllowExternalTargets'),
      createTime?: string(name='CreateTime'),
      resourceShareId?: string(name='ResourceShareId'),
      resourceShareName?: string(name='ResourceShareName'),
      resourceShareOwner?: string(name='ResourceShareOwner'),
      resourceShareStatus?: string(name='ResourceShareStatus'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ResourceShares'),
}

model ListResourceSharesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceSharesResponseBody(name='body'),
}

async function listResourceSharesWithOptions(request: ListResourceSharesRequest, runtime: Util.RuntimeOptions): ListResourceSharesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.permissionName)) {
    query['PermissionName'] = request.permissionName;
  }
  if (!Util.isUnset(request.resourceOwner)) {
    query['ResourceOwner'] = request.resourceOwner;
  }
  if (!Util.isUnset(request.resourceShareIds)) {
    query['ResourceShareIds'] = request.resourceShareIds;
  }
  if (!Util.isUnset(request.resourceShareName)) {
    query['ResourceShareName'] = request.resourceShareName;
  }
  if (!Util.isUnset(request.resourceShareStatus)) {
    query['ResourceShareStatus'] = request.resourceShareStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceShares',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceShares(request: ListResourceSharesRequest): ListResourceSharesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceSharesWithOptions(request, runtime);
}

model ListSharedResourcesRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceIds?: [ string ](name='ResourceIds'),
  resourceOwner?: string(name='ResourceOwner'),
  resourceShareIds?: [ string ](name='ResourceShareIds'),
  resourceType?: string(name='ResourceType'),
  target?: string(name='Target'),
}

model ListSharedResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  sharedResources?: [ 
    {
      createTime?: string(name='CreateTime'),
      resourceId?: string(name='ResourceId'),
      resourceShareId?: string(name='ResourceShareId'),
      resourceStatus?: string(name='ResourceStatus'),
      resourceStatusMessage?: string(name='ResourceStatusMessage'),
      resourceType?: string(name='ResourceType'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='SharedResources'),
}

model ListSharedResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSharedResourcesResponseBody(name='body'),
}

async function listSharedResourcesWithOptions(request: ListSharedResourcesRequest, runtime: Util.RuntimeOptions): ListSharedResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceOwner)) {
    query['ResourceOwner'] = request.resourceOwner;
  }
  if (!Util.isUnset(request.resourceShareIds)) {
    query['ResourceShareIds'] = request.resourceShareIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSharedResources',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSharedResources(request: ListSharedResourcesRequest): ListSharedResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSharedResourcesWithOptions(request, runtime);
}

model ListSharedTargetsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceId?: string(name='ResourceId'),
  resourceOwner?: string(name='ResourceOwner'),
  resourceShareIds?: [ string ](name='ResourceShareIds'),
  resourceType?: string(name='ResourceType'),
  targets?: [ string ](name='Targets'),
}

model ListSharedTargetsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  sharedTargets?: [ 
    {
      createTime?: string(name='CreateTime'),
      external?: boolean(name='External'),
      resourceShareId?: string(name='ResourceShareId'),
      targetId?: string(name='TargetId'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='SharedTargets'),
}

model ListSharedTargetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSharedTargetsResponseBody(name='body'),
}

async function listSharedTargetsWithOptions(request: ListSharedTargetsRequest, runtime: Util.RuntimeOptions): ListSharedTargetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwner)) {
    query['ResourceOwner'] = request.resourceOwner;
  }
  if (!Util.isUnset(request.resourceShareIds)) {
    query['ResourceShareIds'] = request.resourceShareIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.targets)) {
    query['Targets'] = request.targets;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSharedTargets',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSharedTargets(request: ListSharedTargetsRequest): ListSharedTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSharedTargetsWithOptions(request, runtime);
}

model RejectResourceShareInvitationRequest {
  resourceShareInvitationId?: string(name='ResourceShareInvitationId'),
}

model RejectResourceShareInvitationResponseBody = {
  requestId?: string(name='RequestId'),
  resourceShareInvitation?: {
    createTime?: string(name='CreateTime'),
    receiverAccountId?: string(name='ReceiverAccountId'),
    resourceShareId?: string(name='ResourceShareId'),
    resourceShareInvitationId?: string(name='ResourceShareInvitationId'),
    resourceShareName?: string(name='ResourceShareName'),
    senderAccountId?: string(name='SenderAccountId'),
    status?: string(name='Status'),
  }(name='ResourceShareInvitation'),
}

model RejectResourceShareInvitationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RejectResourceShareInvitationResponseBody(name='body'),
}

async function rejectResourceShareInvitationWithOptions(request: RejectResourceShareInvitationRequest, runtime: Util.RuntimeOptions): RejectResourceShareInvitationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceShareInvitationId)) {
    query['ResourceShareInvitationId'] = request.resourceShareInvitationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RejectResourceShareInvitation',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rejectResourceShareInvitation(request: RejectResourceShareInvitationRequest): RejectResourceShareInvitationResponse {
  var runtime = new Util.RuntimeOptions{};
  return rejectResourceShareInvitationWithOptions(request, runtime);
}

model UpdateResourceShareRequest {
  allowExternalTargets?: boolean(name='AllowExternalTargets'),
  resourceShareId?: string(name='ResourceShareId'),
  resourceShareName?: string(name='ResourceShareName'),
}

model UpdateResourceShareResponseBody = {
  requestId?: string(name='RequestId'),
  resourceShare?: {
    allowExternalTargets?: boolean(name='AllowExternalTargets'),
    createTime?: string(name='CreateTime'),
    resourceShareId?: string(name='ResourceShareId'),
    resourceShareName?: string(name='ResourceShareName'),
    resourceShareOwner?: string(name='ResourceShareOwner'),
    resourceShareStatus?: string(name='ResourceShareStatus'),
    updateTime?: string(name='UpdateTime'),
  }(name='ResourceShare'),
}

model UpdateResourceShareResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateResourceShareResponseBody(name='body'),
}

async function updateResourceShareWithOptions(request: UpdateResourceShareRequest, runtime: Util.RuntimeOptions): UpdateResourceShareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowExternalTargets)) {
    query['AllowExternalTargets'] = request.allowExternalTargets;
  }
  if (!Util.isUnset(request.resourceShareId)) {
    query['ResourceShareId'] = request.resourceShareId;
  }
  if (!Util.isUnset(request.resourceShareName)) {
    query['ResourceShareName'] = request.resourceShareName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceShare',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateResourceShare(request: UpdateResourceShareRequest): UpdateResourceShareResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateResourceShareWithOptions(request, runtime);
}

