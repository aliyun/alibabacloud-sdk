/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('resourcesharing', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AssociateResourceShareRequest {
  resourceShareId?: string(name='ResourceShareId'),
  resources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resources'),
  targets?: [ string ](name='Targets'),
}

model AssociateResourceShareResponseBody = {
  requestId?: string(name='RequestId'),
  resourceShareAssociations?: [ 
    {
      associationStatus?: string(name='AssociationStatus'),
      associationStatusMessage?: string(name='AssociationStatusMessage'),
      associationType?: string(name='AssociationType'),
      createTime?: string(name='CreateTime'),
      entityId?: string(name='EntityId'),
      entityType?: string(name='EntityType'),
      resourceShareId?: string(name='ResourceShareId'),
      resourceShareName?: string(name='ResourceShareName'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ResourceShareAssociations'),
}

model AssociateResourceShareResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateResourceShareResponseBody(name='body'),
}

async function associateResourceShareWithOptions(request: AssociateResourceShareRequest, runtime: Util.RuntimeOptions): AssociateResourceShareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceShareId)) {
    query['ResourceShareId'] = request.resourceShareId;
  }
  if (!Util.isUnset(request.resources)) {
    query['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.targets)) {
    query['Targets'] = request.targets;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateResourceShare',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateResourceShare(request: AssociateResourceShareRequest): AssociateResourceShareResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateResourceShareWithOptions(request, runtime);
}

model CreateResourceShareRequest {
  resourceShareName?: string(name='ResourceShareName'),
  resources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resources'),
  targets?: [ string ](name='Targets'),
}

model CreateResourceShareResponseBody = {
  requestId?: string(name='RequestId'),
  resourceShare?: {
    createTime?: string(name='CreateTime'),
    resourceShareId?: string(name='ResourceShareId'),
    resourceShareName?: string(name='ResourceShareName'),
    resourceShareOwner?: string(name='ResourceShareOwner'),
    resourceShareStatus?: string(name='ResourceShareStatus'),
    updateTime?: string(name='UpdateTime'),
  }(name='ResourceShare'),
}

model CreateResourceShareResponse = {
  headers: map[string]string(name='headers'),
  body: CreateResourceShareResponseBody(name='body'),
}

async function createResourceShareWithOptions(request: CreateResourceShareRequest, runtime: Util.RuntimeOptions): CreateResourceShareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceShareName)) {
    query['ResourceShareName'] = request.resourceShareName;
  }
  if (!Util.isUnset(request.resources)) {
    query['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.targets)) {
    query['Targets'] = request.targets;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceShare',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createResourceShare(request: CreateResourceShareRequest): CreateResourceShareResponse {
  var runtime = new Util.RuntimeOptions{};
  return createResourceShareWithOptions(request, runtime);
}

model DeleteResourceShareRequest {
  resourceShareId?: string(name='ResourceShareId'),
}

model DeleteResourceShareResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteResourceShareResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteResourceShareResponseBody(name='body'),
}

async function deleteResourceShareWithOptions(request: DeleteResourceShareRequest, runtime: Util.RuntimeOptions): DeleteResourceShareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceShareId)) {
    query['ResourceShareId'] = request.resourceShareId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceShare',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteResourceShare(request: DeleteResourceShareRequest): DeleteResourceShareResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteResourceShareWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DisassociateResourceShareRequest {
  resourceShareId?: string(name='ResourceShareId'),
  resources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='Resources'),
  targets?: [ string ](name='Targets'),
}

model DisassociateResourceShareResponseBody = {
  requestId?: string(name='RequestId'),
  resourceShareAssociations?: [ 
    {
      associationStatus?: string(name='AssociationStatus'),
      associationStatusMessage?: string(name='AssociationStatusMessage'),
      associationType?: string(name='AssociationType'),
      createTime?: string(name='CreateTime'),
      entityId?: string(name='EntityId'),
      entityType?: string(name='EntityType'),
      resourceShareId?: string(name='ResourceShareId'),
      resourceShareName?: string(name='ResourceShareName'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ResourceShareAssociations'),
}

model DisassociateResourceShareResponse = {
  headers: map[string]string(name='headers'),
  body: DisassociateResourceShareResponseBody(name='body'),
}

async function disassociateResourceShareWithOptions(request: DisassociateResourceShareRequest, runtime: Util.RuntimeOptions): DisassociateResourceShareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceShareId)) {
    query['ResourceShareId'] = request.resourceShareId;
  }
  if (!Util.isUnset(request.resources)) {
    query['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.targets)) {
    query['Targets'] = request.targets;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisassociateResourceShare',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disassociateResourceShare(request: DisassociateResourceShareRequest): DisassociateResourceShareResponse {
  var runtime = new Util.RuntimeOptions{};
  return disassociateResourceShareWithOptions(request, runtime);
}

model EnableSharingWithResourceDirectoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableSharingWithResourceDirectoryResponse = {
  headers: map[string]string(name='headers'),
  body: EnableSharingWithResourceDirectoryResponseBody(name='body'),
}

async function enableSharingWithResourceDirectoryWithOptions(runtime: Util.RuntimeOptions): EnableSharingWithResourceDirectoryResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'EnableSharingWithResourceDirectory',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableSharingWithResourceDirectory(): EnableSharingWithResourceDirectoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableSharingWithResourceDirectoryWithOptions(runtime);
}

model ListResourceShareAssociationsRequest {
  associationStatus?: string(name='AssociationStatus'),
  associationType?: string(name='AssociationType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceId?: string(name='ResourceId'),
  resourceShareIds?: [ string ](name='ResourceShareIds'),
  target?: string(name='Target'),
}

model ListResourceShareAssociationsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  resourceShareAssociations?: [ 
    {
      associationStatus?: string(name='AssociationStatus'),
      associationStatusMessage?: string(name='AssociationStatusMessage'),
      associationType?: string(name='AssociationType'),
      createTime?: string(name='CreateTime'),
      entityId?: string(name='EntityId'),
      entityType?: string(name='EntityType'),
      resourceShareId?: string(name='ResourceShareId'),
      resourceShareName?: string(name='ResourceShareName'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ResourceShareAssociations'),
}

model ListResourceShareAssociationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListResourceShareAssociationsResponseBody(name='body'),
}

async function listResourceShareAssociationsWithOptions(request: ListResourceShareAssociationsRequest, runtime: Util.RuntimeOptions): ListResourceShareAssociationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.associationStatus)) {
    query['AssociationStatus'] = request.associationStatus;
  }
  if (!Util.isUnset(request.associationType)) {
    query['AssociationType'] = request.associationType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceShareIds)) {
    query['ResourceShareIds'] = request.resourceShareIds;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceShareAssociations',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceShareAssociations(request: ListResourceShareAssociationsRequest): ListResourceShareAssociationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceShareAssociationsWithOptions(request, runtime);
}

model ListResourceSharesRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceOwner?: string(name='ResourceOwner'),
  resourceShareIds?: [ string ](name='ResourceShareIds'),
  resourceShareName?: string(name='ResourceShareName'),
  resourceShareStatus?: string(name='ResourceShareStatus'),
}

model ListResourceSharesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  resourceShares?: [ 
    {
      createTime?: string(name='CreateTime'),
      resourceShareId?: string(name='ResourceShareId'),
      resourceShareName?: string(name='ResourceShareName'),
      resourceShareOwner?: string(name='ResourceShareOwner'),
      resourceShareStatus?: string(name='ResourceShareStatus'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ResourceShares'),
}

model ListResourceSharesResponse = {
  headers: map[string]string(name='headers'),
  body: ListResourceSharesResponseBody(name='body'),
}

async function listResourceSharesWithOptions(request: ListResourceSharesRequest, runtime: Util.RuntimeOptions): ListResourceSharesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceOwner)) {
    query['ResourceOwner'] = request.resourceOwner;
  }
  if (!Util.isUnset(request.resourceShareIds)) {
    query['ResourceShareIds'] = request.resourceShareIds;
  }
  if (!Util.isUnset(request.resourceShareName)) {
    query['ResourceShareName'] = request.resourceShareName;
  }
  if (!Util.isUnset(request.resourceShareStatus)) {
    query['ResourceShareStatus'] = request.resourceShareStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceShares',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceShares(request: ListResourceSharesRequest): ListResourceSharesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceSharesWithOptions(request, runtime);
}

model ListSharedResourcesRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceIds?: [ string ](name='ResourceIds'),
  resourceOwner?: string(name='ResourceOwner'),
  resourceShareIds?: [ string ](name='ResourceShareIds'),
  resourceType?: string(name='ResourceType'),
  target?: string(name='Target'),
}

model ListSharedResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  sharedResources?: [ 
    {
      createTime?: string(name='CreateTime'),
      resourceId?: string(name='ResourceId'),
      resourceShareId?: string(name='ResourceShareId'),
      resourceStatus?: string(name='ResourceStatus'),
      resourceStatusMessage?: string(name='ResourceStatusMessage'),
      resourceType?: string(name='ResourceType'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='SharedResources'),
}

model ListSharedResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListSharedResourcesResponseBody(name='body'),
}

async function listSharedResourcesWithOptions(request: ListSharedResourcesRequest, runtime: Util.RuntimeOptions): ListSharedResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceOwner)) {
    query['ResourceOwner'] = request.resourceOwner;
  }
  if (!Util.isUnset(request.resourceShareIds)) {
    query['ResourceShareIds'] = request.resourceShareIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.target)) {
    query['Target'] = request.target;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSharedResources',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSharedResources(request: ListSharedResourcesRequest): ListSharedResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSharedResourcesWithOptions(request, runtime);
}

model ListSharedTargetsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  resourceId?: string(name='ResourceId'),
  resourceOwner?: string(name='ResourceOwner'),
  resourceShareIds?: [ string ](name='ResourceShareIds'),
  resourceType?: string(name='ResourceType'),
  targets?: [ string ](name='Targets'),
}

model ListSharedTargetsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  sharedTargets?: [ 
    {
      createTime?: string(name='CreateTime'),
      resourceShareId?: string(name='ResourceShareId'),
      targetId?: string(name='TargetId'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='SharedTargets'),
}

model ListSharedTargetsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSharedTargetsResponseBody(name='body'),
}

async function listSharedTargetsWithOptions(request: ListSharedTargetsRequest, runtime: Util.RuntimeOptions): ListSharedTargetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwner)) {
    query['ResourceOwner'] = request.resourceOwner;
  }
  if (!Util.isUnset(request.resourceShareIds)) {
    query['ResourceShareIds'] = request.resourceShareIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.targets)) {
    query['Targets'] = request.targets;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSharedTargets',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSharedTargets(request: ListSharedTargetsRequest): ListSharedTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSharedTargetsWithOptions(request, runtime);
}

model UpdateResourceShareRequest {
  resourceShareId?: string(name='ResourceShareId'),
  resourceShareName?: string(name='ResourceShareName'),
}

model UpdateResourceShareResponseBody = {
  requestId?: string(name='RequestId'),
  resourceShare?: {
    createTime?: string(name='CreateTime'),
    resourceShareId?: string(name='ResourceShareId'),
    resourceShareName?: string(name='ResourceShareName'),
    resourceShareOwner?: string(name='ResourceShareOwner'),
    resourceShareStatus?: string(name='ResourceShareStatus'),
    updateTime?: string(name='UpdateTime'),
  }(name='ResourceShare'),
}

model UpdateResourceShareResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateResourceShareResponseBody(name='body'),
}

async function updateResourceShareWithOptions(request: UpdateResourceShareRequest, runtime: Util.RuntimeOptions): UpdateResourceShareResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceShareId)) {
    query['ResourceShareId'] = request.resourceShareId;
  }
  if (!Util.isUnset(request.resourceShareName)) {
    query['ResourceShareName'] = request.resourceShareName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceShare',
    version = '2020-01-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateResourceShare(request: UpdateResourceShareRequest): UpdateResourceShareResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateResourceShareWithOptions(request, runtime);
}

