/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-hangzhou = 'mpaas.aliyuncs.com',
    ap-northeast-1 = 'mpaas.aliyuncs.com',
    ap-northeast-2-pop = 'mpaas.aliyuncs.com',
    ap-south-1 = 'mpaas.aliyuncs.com',
    ap-southeast-1 = 'mpaas.aliyuncs.com',
    ap-southeast-2 = 'mpaas.aliyuncs.com',
    ap-southeast-3 = 'mpaas.aliyuncs.com',
    ap-southeast-5 = 'mpaas.aliyuncs.com',
    cn-beijing = 'mpaas.aliyuncs.com',
    cn-beijing-finance-1 = 'mpaas.aliyuncs.com',
    cn-beijing-finance-pop = 'mpaas.aliyuncs.com',
    cn-beijing-gov-1 = 'mpaas.aliyuncs.com',
    cn-beijing-nu16-b01 = 'mpaas.aliyuncs.com',
    cn-chengdu = 'mpaas.aliyuncs.com',
    cn-edge-1 = 'mpaas.aliyuncs.com',
    cn-fujian = 'mpaas.aliyuncs.com',
    cn-haidian-cm12-c01 = 'mpaas.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'mpaas.aliyuncs.com',
    cn-hangzhou-finance = 'mpaas.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'mpaas.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'mpaas.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'mpaas.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'mpaas.aliyuncs.com',
    cn-hangzhou-test-306 = 'mpaas.aliyuncs.com',
    cn-hongkong = 'mpaas.aliyuncs.com',
    cn-hongkong-finance-pop = 'mpaas.aliyuncs.com',
    cn-huhehaote = 'mpaas.aliyuncs.com',
    cn-north-2-gov-1 = 'mpaas.aliyuncs.com',
    cn-qingdao = 'mpaas.aliyuncs.com',
    cn-qingdao-nebula = 'mpaas.aliyuncs.com',
    cn-shanghai = 'mpaas.aliyuncs.com',
    cn-shanghai-et15-b01 = 'mpaas.aliyuncs.com',
    cn-shanghai-et2-b01 = 'mpaas.aliyuncs.com',
    cn-shanghai-finance-1 = 'mpaas.aliyuncs.com',
    cn-shanghai-inner = 'mpaas.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'mpaas.aliyuncs.com',
    cn-shenzhen = 'mpaas.aliyuncs.com',
    cn-shenzhen-finance-1 = 'mpaas.aliyuncs.com',
    cn-shenzhen-inner = 'mpaas.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'mpaas.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'mpaas.aliyuncs.com',
    cn-wuhan = 'mpaas.aliyuncs.com',
    cn-yushanfang = 'mpaas.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'mpaas.aliyuncs.com',
    cn-zhangjiakou = 'mpaas.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'mpaas.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'mpaas.aliyuncs.com',
    eu-central-1 = 'mpaas.aliyuncs.com',
    eu-west-1 = 'mpaas.aliyuncs.com',
    eu-west-1-oxs = 'mpaas.aliyuncs.com',
    me-east-1 = 'mpaas.aliyuncs.com',
    rus-west-1-pop = 'mpaas.aliyuncs.com',
    us-east-1 = 'mpaas.aliyuncs.com',
    us-west-1 = 'mpaas.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('mpaas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddMdsMiniConfigRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMiniConfigAddJsonStr?: string(name='MpaasMappcenterMiniConfigAddJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model AddMdsMiniConfigResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      requestId?: string(name='RequestId'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model AddMdsMiniConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddMdsMiniConfigResponseBody(name='body'),
}

async function addMdsMiniConfigWithOptions(request: AddMdsMiniConfigRequest, runtime: Util.RuntimeOptions): AddMdsMiniConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMiniConfigAddJsonStr)) {
    body['MpaasMappcenterMiniConfigAddJsonStr'] = request.mpaasMappcenterMiniConfigAddJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddMdsMiniConfig',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addMdsMiniConfig(request: AddMdsMiniConfigRequest): AddMdsMiniConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMdsMiniConfigWithOptions(request, runtime);
}

model CancelPushSchedulerRequest {
  appId?: string(name='AppId'),
  type?: int32(name='Type'),
  uniqueIds?: string(name='UniqueIds'),
  workspaceId?: string(name='WorkspaceId'),
}

model CancelPushSchedulerResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CancelPushSchedulerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelPushSchedulerResponseBody(name='body'),
}

async function cancelPushSchedulerWithOptions(request: CancelPushSchedulerRequest, runtime: Util.RuntimeOptions): CancelPushSchedulerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.uniqueIds)) {
    body['UniqueIds'] = request.uniqueIds;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CancelPushScheduler',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelPushScheduler(request: CancelPushSchedulerRequest): CancelPushSchedulerResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelPushSchedulerWithOptions(request, runtime);
}

model ChangeMcubeMiniTaskStatusRequest {
  appId?: string(name='AppId'),
  bizType?: string(name='BizType'),
  packageId?: long(name='PackageId'),
  taskId?: long(name='TaskId'),
  taskStatus?: long(name='TaskStatus'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ChangeMcubeMiniTaskStatusResponseBody = {
  changeMiniTaskStatusResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ChangeMiniTaskStatusResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ChangeMcubeMiniTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeMcubeMiniTaskStatusResponseBody(name='body'),
}

async function changeMcubeMiniTaskStatusWithOptions(request: ChangeMcubeMiniTaskStatusRequest, runtime: Util.RuntimeOptions): ChangeMcubeMiniTaskStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskStatus)) {
    body['TaskStatus'] = request.taskStatus;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ChangeMcubeMiniTaskStatus',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeMcubeMiniTaskStatus(request: ChangeMcubeMiniTaskStatusRequest): ChangeMcubeMiniTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeMcubeMiniTaskStatusWithOptions(request, runtime);
}

model ChangeMcubeNebulaTaskStatusRequest {
  appId?: string(name='AppId'),
  bizType?: string(name='BizType'),
  packageId?: string(name='PackageId'),
  taskId?: string(name='TaskId'),
  taskStatus?: int32(name='TaskStatus'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ChangeMcubeNebulaTaskStatusResponseBody = {
  changeMcubeNebulaTaskStatusResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ChangeMcubeNebulaTaskStatusResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ChangeMcubeNebulaTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeMcubeNebulaTaskStatusResponseBody(name='body'),
}

async function changeMcubeNebulaTaskStatusWithOptions(request: ChangeMcubeNebulaTaskStatusRequest, runtime: Util.RuntimeOptions): ChangeMcubeNebulaTaskStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskStatus)) {
    body['TaskStatus'] = request.taskStatus;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ChangeMcubeNebulaTaskStatus',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeMcubeNebulaTaskStatus(request: ChangeMcubeNebulaTaskStatusRequest): ChangeMcubeNebulaTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeMcubeNebulaTaskStatusWithOptions(request, runtime);
}

model ChangeMcubePublicTaskStatusRequest {
  appId?: string(name='AppId'),
  taskId?: string(name='TaskId'),
  taskStatus?: string(name='TaskStatus'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ChangeMcubePublicTaskStatusResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: string(name='Data'),
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model ChangeMcubePublicTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeMcubePublicTaskStatusResponseBody(name='body'),
}

async function changeMcubePublicTaskStatusWithOptions(request: ChangeMcubePublicTaskStatusRequest, runtime: Util.RuntimeOptions): ChangeMcubePublicTaskStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskStatus)) {
    body['TaskStatus'] = request.taskStatus;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ChangeMcubePublicTaskStatus',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeMcubePublicTaskStatus(request: ChangeMcubePublicTaskStatusRequest): ChangeMcubePublicTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeMcubePublicTaskStatusWithOptions(request, runtime);
}

model CopyMcdpGroupRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpGroupCopyJsonStr?: string(name='MpaasMappcenterMcdpGroupCopyJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CopyMcdpGroupResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CopyMcdpGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyMcdpGroupResponseBody(name='body'),
}

async function copyMcdpGroupWithOptions(request: CopyMcdpGroupRequest, runtime: Util.RuntimeOptions): CopyMcdpGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMcdpGroupCopyJsonStr)) {
    body['MpaasMappcenterMcdpGroupCopyJsonStr'] = request.mpaasMappcenterMcdpGroupCopyJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CopyMcdpGroup',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function copyMcdpGroup(request: CopyMcdpGroupRequest): CopyMcdpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyMcdpGroupWithOptions(request, runtime);
}

model CreateMcdpEventRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpEventCreateJsonStr?: string(name='MpaasMappcenterMcdpEventCreateJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcdpEventResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcdpEventResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMcdpEventResponseBody(name='body'),
}

async function createMcdpEventWithOptions(request: CreateMcdpEventRequest, runtime: Util.RuntimeOptions): CreateMcdpEventResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMcdpEventCreateJsonStr)) {
    body['MpaasMappcenterMcdpEventCreateJsonStr'] = request.mpaasMappcenterMcdpEventCreateJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcdpEvent',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcdpEvent(request: CreateMcdpEventRequest): CreateMcdpEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcdpEventWithOptions(request, runtime);
}

model CreateMcdpEventAttributeRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpEventAttributeCreateJsonStr?: string(name='MpaasMappcenterMcdpEventAttributeCreateJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcdpEventAttributeResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcdpEventAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMcdpEventAttributeResponseBody(name='body'),
}

async function createMcdpEventAttributeWithOptions(request: CreateMcdpEventAttributeRequest, runtime: Util.RuntimeOptions): CreateMcdpEventAttributeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMcdpEventAttributeCreateJsonStr)) {
    body['MpaasMappcenterMcdpEventAttributeCreateJsonStr'] = request.mpaasMappcenterMcdpEventAttributeCreateJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcdpEventAttribute',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcdpEventAttribute(request: CreateMcdpEventAttributeRequest): CreateMcdpEventAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcdpEventAttributeWithOptions(request, runtime);
}

model CreateMcdpGroupRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpGroupCreateJsonStr?: string(name='MpaasMappcenterMcdpGroupCreateJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcdpGroupResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcdpGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMcdpGroupResponseBody(name='body'),
}

async function createMcdpGroupWithOptions(request: CreateMcdpGroupRequest, runtime: Util.RuntimeOptions): CreateMcdpGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMcdpGroupCreateJsonStr)) {
    body['MpaasMappcenterMcdpGroupCreateJsonStr'] = request.mpaasMappcenterMcdpGroupCreateJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcdpGroup',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcdpGroup(request: CreateMcdpGroupRequest): CreateMcdpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcdpGroupWithOptions(request, runtime);
}

model CreateMcdpMaterialRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpMaterialCreateJsonStr?: string(name='MpaasMappcenterMcdpMaterialCreateJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcdpMaterialResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcdpMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMcdpMaterialResponseBody(name='body'),
}

async function createMcdpMaterialWithOptions(request: CreateMcdpMaterialRequest, runtime: Util.RuntimeOptions): CreateMcdpMaterialResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMcdpMaterialCreateJsonStr)) {
    body['MpaasMappcenterMcdpMaterialCreateJsonStr'] = request.mpaasMappcenterMcdpMaterialCreateJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcdpMaterial',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcdpMaterial(request: CreateMcdpMaterialRequest): CreateMcdpMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcdpMaterialWithOptions(request, runtime);
}

model CreateMcdpZoneRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpZoneCreateJsonStr?: string(name='MpaasMappcenterMcdpZoneCreateJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcdpZoneResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcdpZoneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMcdpZoneResponseBody(name='body'),
}

async function createMcdpZoneWithOptions(request: CreateMcdpZoneRequest, runtime: Util.RuntimeOptions): CreateMcdpZoneResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMcdpZoneCreateJsonStr)) {
    body['MpaasMappcenterMcdpZoneCreateJsonStr'] = request.mpaasMappcenterMcdpZoneCreateJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcdpZone',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcdpZone(request: CreateMcdpZoneRequest): CreateMcdpZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcdpZoneWithOptions(request, runtime);
}

model CreateMcubeMiniAppRequest {
  appId?: string(name='AppId'),
  h5Id?: string(name='H5Id'),
  h5Name?: string(name='H5Name'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeMiniAppResponseBody = {
  createMiniResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMiniResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeMiniAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMcubeMiniAppResponseBody(name='body'),
}

async function createMcubeMiniAppWithOptions(request: CreateMcubeMiniAppRequest, runtime: Util.RuntimeOptions): CreateMcubeMiniAppResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!Util.isUnset(request.h5Name)) {
    body['H5Name'] = request.h5Name;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcubeMiniApp',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcubeMiniApp(request: CreateMcubeMiniAppRequest): CreateMcubeMiniAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeMiniAppWithOptions(request, runtime);
}

model CreateMcubeMiniTaskRequest {
  appId?: string(name='AppId'),
  greyConfigInfo?: string(name='GreyConfigInfo'),
  greyEndtimeData?: string(name='GreyEndtimeData'),
  greyNum?: long(name='GreyNum'),
  memo?: string(name='Memo'),
  packageId?: long(name='PackageId'),
  publishMode?: long(name='PublishMode'),
  publishType?: long(name='PublishType'),
  tenantId?: string(name='TenantId'),
  whitelistIds?: string(name='WhitelistIds'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeMiniTaskResponseBody = {
  createMiniTaskResult?: {
    miniTaskId?: string(name='MiniTaskId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMiniTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeMiniTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMcubeMiniTaskResponseBody(name='body'),
}

async function createMcubeMiniTaskWithOptions(request: CreateMcubeMiniTaskRequest, runtime: Util.RuntimeOptions): CreateMcubeMiniTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.greyConfigInfo)) {
    body['GreyConfigInfo'] = request.greyConfigInfo;
  }
  if (!Util.isUnset(request.greyEndtimeData)) {
    body['GreyEndtimeData'] = request.greyEndtimeData;
  }
  if (!Util.isUnset(request.greyNum)) {
    body['GreyNum'] = request.greyNum;
  }
  if (!Util.isUnset(request.memo)) {
    body['Memo'] = request.memo;
  }
  if (!Util.isUnset(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!Util.isUnset(request.publishMode)) {
    body['PublishMode'] = request.publishMode;
  }
  if (!Util.isUnset(request.publishType)) {
    body['PublishType'] = request.publishType;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.whitelistIds)) {
    body['WhitelistIds'] = request.whitelistIds;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcubeMiniTask',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcubeMiniTask(request: CreateMcubeMiniTaskRequest): CreateMcubeMiniTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeMiniTaskWithOptions(request, runtime);
}

model CreateMcubeNebulaAppRequest {
  appId?: string(name='AppId'),
  h5Id?: string(name='H5Id'),
  h5Name?: string(name='H5Name'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeNebulaAppResponseBody = {
  createNebulaAppResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateNebulaAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeNebulaAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMcubeNebulaAppResponseBody(name='body'),
}

async function createMcubeNebulaAppWithOptions(request: CreateMcubeNebulaAppRequest, runtime: Util.RuntimeOptions): CreateMcubeNebulaAppResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!Util.isUnset(request.h5Name)) {
    body['H5Name'] = request.h5Name;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcubeNebulaApp',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcubeNebulaApp(request: CreateMcubeNebulaAppRequest): CreateMcubeNebulaAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeNebulaAppWithOptions(request, runtime);
}

model CreateMcubeNebulaResourceRequest {
  appId?: string(name='AppId'),
  autoInstall?: int32(name='AutoInstall'),
  clientVersionMax?: string(name='ClientVersionMax'),
  clientVersionMin?: string(name='ClientVersionMin'),
  customDomainName?: string(name='CustomDomainName'),
  extendInfo?: string(name='ExtendInfo'),
  fileUrl?: string(name='FileUrl'),
  h5Id?: string(name='H5Id'),
  h5Name?: string(name='H5Name'),
  h5Version?: string(name='H5Version'),
  installType?: int32(name='InstallType'),
  mainUrl?: string(name='MainUrl'),
  onexFlag?: boolean(name='OnexFlag'),
  platform?: string(name='Platform'),
  repeatNebula?: int32(name='RepeatNebula'),
  resourceType?: int32(name='ResourceType'),
  subUrl?: string(name='SubUrl'),
  tenantId?: string(name='TenantId'),
  vhost?: string(name='Vhost'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeNebulaResourceResponseBody = {
  createMcubeNebulaResourceReslult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaResourceId?: string(name='NebulaResourceId'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMcubeNebulaResourceReslult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeNebulaResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMcubeNebulaResourceResponseBody(name='body'),
}

async function createMcubeNebulaResourceWithOptions(request: CreateMcubeNebulaResourceRequest, runtime: Util.RuntimeOptions): CreateMcubeNebulaResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.autoInstall)) {
    body['AutoInstall'] = request.autoInstall;
  }
  if (!Util.isUnset(request.clientVersionMax)) {
    body['ClientVersionMax'] = request.clientVersionMax;
  }
  if (!Util.isUnset(request.clientVersionMin)) {
    body['ClientVersionMin'] = request.clientVersionMin;
  }
  if (!Util.isUnset(request.customDomainName)) {
    body['CustomDomainName'] = request.customDomainName;
  }
  if (!Util.isUnset(request.extendInfo)) {
    body['ExtendInfo'] = request.extendInfo;
  }
  if (!Util.isUnset(request.fileUrl)) {
    body['FileUrl'] = request.fileUrl;
  }
  if (!Util.isUnset(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!Util.isUnset(request.h5Name)) {
    body['H5Name'] = request.h5Name;
  }
  if (!Util.isUnset(request.h5Version)) {
    body['H5Version'] = request.h5Version;
  }
  if (!Util.isUnset(request.installType)) {
    body['InstallType'] = request.installType;
  }
  if (!Util.isUnset(request.mainUrl)) {
    body['MainUrl'] = request.mainUrl;
  }
  if (!Util.isUnset(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!Util.isUnset(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.repeatNebula)) {
    body['RepeatNebula'] = request.repeatNebula;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.subUrl)) {
    body['SubUrl'] = request.subUrl;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.vhost)) {
    body['Vhost'] = request.vhost;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcubeNebulaResource',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcubeNebulaResource(request: CreateMcubeNebulaResourceRequest): CreateMcubeNebulaResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeNebulaResourceWithOptions(request, runtime);
}

model CreateMcubeNebulaTaskRequest {
  appCode?: string(name='AppCode'),
  appId?: string(name='AppId'),
  bizType?: string(name='BizType'),
  creator?: string(name='Creator'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  gmtModifiedStr?: string(name='GmtModifiedStr'),
  greyConfigInfo?: string(name='GreyConfigInfo'),
  greyEndtime?: string(name='GreyEndtime'),
  greyEndtimeData?: string(name='GreyEndtimeData'),
  greyEndtimeStr?: string(name='GreyEndtimeStr'),
  greyNum?: int32(name='GreyNum'),
  greyUrl?: string(name='GreyUrl'),
  id?: long(name='Id'),
  memo?: string(name='Memo'),
  modifier?: string(name='Modifier'),
  packageId?: long(name='PackageId'),
  percent?: int32(name='Percent'),
  platform?: string(name='Platform'),
  productId?: string(name='ProductId'),
  productVersion?: string(name='ProductVersion'),
  publishMode?: int32(name='PublishMode'),
  publishType?: int32(name='PublishType'),
  releaseVersion?: string(name='ReleaseVersion'),
  resIds?: string(name='ResIds'),
  serialVersionUID?: long(name='SerialVersionUID'),
  status?: int32(name='Status'),
  syncMode?: string(name='SyncMode'),
  syncResult?: string(name='SyncResult'),
  taskName?: string(name='TaskName'),
  taskStatus?: int32(name='TaskStatus'),
  taskType?: int32(name='TaskType'),
  taskVersion?: long(name='TaskVersion'),
  tenantId?: string(name='TenantId'),
  upgradeNoticeNum?: long(name='UpgradeNoticeNum'),
  upgradeProgress?: string(name='UpgradeProgress'),
  whitelistIds?: string(name='WhitelistIds'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeNebulaTaskResponseBody = {
  createMcubeNebulaTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaTaskId?: string(name='NebulaTaskId'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMcubeNebulaTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeNebulaTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMcubeNebulaTaskResponseBody(name='body'),
}

async function createMcubeNebulaTaskWithOptions(request: CreateMcubeNebulaTaskRequest, runtime: Util.RuntimeOptions): CreateMcubeNebulaTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appCode)) {
    body['AppCode'] = request.appCode;
  }
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.creator)) {
    body['Creator'] = request.creator;
  }
  if (!Util.isUnset(request.gmtCreate)) {
    body['GmtCreate'] = request.gmtCreate;
  }
  if (!Util.isUnset(request.gmtModified)) {
    body['GmtModified'] = request.gmtModified;
  }
  if (!Util.isUnset(request.gmtModifiedStr)) {
    body['GmtModifiedStr'] = request.gmtModifiedStr;
  }
  if (!Util.isUnset(request.greyConfigInfo)) {
    body['GreyConfigInfo'] = request.greyConfigInfo;
  }
  if (!Util.isUnset(request.greyEndtime)) {
    body['GreyEndtime'] = request.greyEndtime;
  }
  if (!Util.isUnset(request.greyEndtimeData)) {
    body['GreyEndtimeData'] = request.greyEndtimeData;
  }
  if (!Util.isUnset(request.greyEndtimeStr)) {
    body['GreyEndtimeStr'] = request.greyEndtimeStr;
  }
  if (!Util.isUnset(request.greyNum)) {
    body['GreyNum'] = request.greyNum;
  }
  if (!Util.isUnset(request.greyUrl)) {
    body['GreyUrl'] = request.greyUrl;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.memo)) {
    body['Memo'] = request.memo;
  }
  if (!Util.isUnset(request.modifier)) {
    body['Modifier'] = request.modifier;
  }
  if (!Util.isUnset(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!Util.isUnset(request.percent)) {
    body['Percent'] = request.percent;
  }
  if (!Util.isUnset(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.productId)) {
    body['ProductId'] = request.productId;
  }
  if (!Util.isUnset(request.productVersion)) {
    body['ProductVersion'] = request.productVersion;
  }
  if (!Util.isUnset(request.publishMode)) {
    body['PublishMode'] = request.publishMode;
  }
  if (!Util.isUnset(request.publishType)) {
    body['PublishType'] = request.publishType;
  }
  if (!Util.isUnset(request.releaseVersion)) {
    body['ReleaseVersion'] = request.releaseVersion;
  }
  if (!Util.isUnset(request.resIds)) {
    body['ResIds'] = request.resIds;
  }
  if (!Util.isUnset(request.serialVersionUID)) {
    body['SerialVersionUID'] = request.serialVersionUID;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.syncMode)) {
    body['SyncMode'] = request.syncMode;
  }
  if (!Util.isUnset(request.syncResult)) {
    body['SyncResult'] = request.syncResult;
  }
  if (!Util.isUnset(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskStatus)) {
    body['TaskStatus'] = request.taskStatus;
  }
  if (!Util.isUnset(request.taskType)) {
    body['TaskType'] = request.taskType;
  }
  if (!Util.isUnset(request.taskVersion)) {
    body['TaskVersion'] = request.taskVersion;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.upgradeNoticeNum)) {
    body['UpgradeNoticeNum'] = request.upgradeNoticeNum;
  }
  if (!Util.isUnset(request.upgradeProgress)) {
    body['UpgradeProgress'] = request.upgradeProgress;
  }
  if (!Util.isUnset(request.whitelistIds)) {
    body['WhitelistIds'] = request.whitelistIds;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcubeNebulaTask',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcubeNebulaTask(request: CreateMcubeNebulaTaskRequest): CreateMcubeNebulaTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeNebulaTaskWithOptions(request, runtime);
}

model CreateMcubeUpgradePackageRequest {
  appId?: string(name='AppId'),
  appVersion?: string(name='AppVersion'),
  appstoreUrl?: string(name='AppstoreUrl'),
  bundleId?: string(name='BundleId'),
  customDomainName?: string(name='CustomDomainName'),
  desc?: string(name='Desc'),
  downloadUrl?: string(name='DownloadUrl'),
  fileUrl?: string(name='FileUrl'),
  iconFileUrl?: string(name='IconFileUrl'),
  installAmount?: int32(name='InstallAmount'),
  iosSymbolfileUrl?: string(name='IosSymbolfileUrl'),
  isEnterprise?: int32(name='IsEnterprise'),
  needCheck?: int32(name='NeedCheck'),
  onexFlag?: boolean(name='OnexFlag'),
  platform?: string(name='Platform'),
  tenantId?: string(name='TenantId'),
  validDays?: int32(name='ValidDays'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeUpgradePackageResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: string(name='Data'),
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeUpgradePackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMcubeUpgradePackageResponseBody(name='body'),
}

async function createMcubeUpgradePackageWithOptions(request: CreateMcubeUpgradePackageRequest, runtime: Util.RuntimeOptions): CreateMcubeUpgradePackageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersion)) {
    body['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.appstoreUrl)) {
    body['AppstoreUrl'] = request.appstoreUrl;
  }
  if (!Util.isUnset(request.bundleId)) {
    body['BundleId'] = request.bundleId;
  }
  if (!Util.isUnset(request.customDomainName)) {
    body['CustomDomainName'] = request.customDomainName;
  }
  if (!Util.isUnset(request.desc)) {
    body['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.downloadUrl)) {
    body['DownloadUrl'] = request.downloadUrl;
  }
  if (!Util.isUnset(request.fileUrl)) {
    body['FileUrl'] = request.fileUrl;
  }
  if (!Util.isUnset(request.iconFileUrl)) {
    body['IconFileUrl'] = request.iconFileUrl;
  }
  if (!Util.isUnset(request.installAmount)) {
    body['InstallAmount'] = request.installAmount;
  }
  if (!Util.isUnset(request.iosSymbolfileUrl)) {
    body['IosSymbolfileUrl'] = request.iosSymbolfileUrl;
  }
  if (!Util.isUnset(request.isEnterprise)) {
    body['IsEnterprise'] = request.isEnterprise;
  }
  if (!Util.isUnset(request.needCheck)) {
    body['NeedCheck'] = request.needCheck;
  }
  if (!Util.isUnset(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!Util.isUnset(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.validDays)) {
    body['ValidDays'] = request.validDays;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcubeUpgradePackage',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcubeUpgradePackage(request: CreateMcubeUpgradePackageRequest): CreateMcubeUpgradePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeUpgradePackageWithOptions(request, runtime);
}

model CreateMcubeUpgradeTaskRequest {
  appId?: string(name='AppId'),
  greyConfigInfo?: string(name='GreyConfigInfo'),
  greyEndtimeData?: string(name='GreyEndtimeData'),
  greyNum?: int32(name='GreyNum'),
  historyForce?: int32(name='HistoryForce'),
  memo?: string(name='Memo'),
  packageInfoId?: long(name='PackageInfoId'),
  publishMode?: int32(name='PublishMode'),
  publishType?: int32(name='PublishType'),
  tenantId?: string(name='TenantId'),
  upgradeContent?: string(name='UpgradeContent'),
  upgradeType?: int32(name='UpgradeType'),
  whitelistIds?: string(name='WhitelistIds'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeUpgradeTaskResponseBody = {
  createTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    upgradeTaskId?: string(name='upgradeTaskId'),
  }(name='CreateTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeUpgradeTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMcubeUpgradeTaskResponseBody(name='body'),
}

async function createMcubeUpgradeTaskWithOptions(request: CreateMcubeUpgradeTaskRequest, runtime: Util.RuntimeOptions): CreateMcubeUpgradeTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.greyConfigInfo)) {
    body['GreyConfigInfo'] = request.greyConfigInfo;
  }
  if (!Util.isUnset(request.greyEndtimeData)) {
    body['GreyEndtimeData'] = request.greyEndtimeData;
  }
  if (!Util.isUnset(request.greyNum)) {
    body['GreyNum'] = request.greyNum;
  }
  if (!Util.isUnset(request.historyForce)) {
    body['HistoryForce'] = request.historyForce;
  }
  if (!Util.isUnset(request.memo)) {
    body['Memo'] = request.memo;
  }
  if (!Util.isUnset(request.packageInfoId)) {
    body['PackageInfoId'] = request.packageInfoId;
  }
  if (!Util.isUnset(request.publishMode)) {
    body['PublishMode'] = request.publishMode;
  }
  if (!Util.isUnset(request.publishType)) {
    body['PublishType'] = request.publishType;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.upgradeContent)) {
    body['UpgradeContent'] = request.upgradeContent;
  }
  if (!Util.isUnset(request.upgradeType)) {
    body['UpgradeType'] = request.upgradeType;
  }
  if (!Util.isUnset(request.whitelistIds)) {
    body['WhitelistIds'] = request.whitelistIds;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcubeUpgradeTask',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcubeUpgradeTask(request: CreateMcubeUpgradeTaskRequest): CreateMcubeUpgradeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeUpgradeTaskWithOptions(request, runtime);
}

model CreateMcubeVhostRequest {
  appId?: string(name='AppId'),
  tenantId?: string(name='TenantId'),
  vhost?: string(name='Vhost'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeVhostResponseBody = {
  createVhostResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateVhostResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeVhostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMcubeVhostResponseBody(name='body'),
}

async function createMcubeVhostWithOptions(request: CreateMcubeVhostRequest, runtime: Util.RuntimeOptions): CreateMcubeVhostResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.vhost)) {
    body['Vhost'] = request.vhost;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcubeVhost',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcubeVhost(request: CreateMcubeVhostRequest): CreateMcubeVhostResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeVhostWithOptions(request, runtime);
}

model CreateMcubeWhitelistRequest {
  appId?: string(name='AppId'),
  tenantId?: string(name='TenantId'),
  whiteListName?: string(name='WhiteListName'),
  whitelistType?: string(name='WhitelistType'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeWhitelistResponseBody = {
  createWhitelistResult?: {
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    whitelistId?: string(name='WhitelistId'),
  }(name='CreateWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMcubeWhitelistResponseBody(name='body'),
}

async function createMcubeWhitelistWithOptions(request: CreateMcubeWhitelistRequest, runtime: Util.RuntimeOptions): CreateMcubeWhitelistResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.whiteListName)) {
    body['WhiteListName'] = request.whiteListName;
  }
  if (!Util.isUnset(request.whitelistType)) {
    body['WhitelistType'] = request.whitelistType;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcubeWhitelist',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcubeWhitelist(request: CreateMcubeWhitelistRequest): CreateMcubeWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeWhitelistWithOptions(request, runtime);
}

model CreateMcubeWhitelistForIdeRequest {
  appId?: string(name='AppId'),
  tenantId?: string(name='TenantId'),
  userId?: string(name='UserId'),
  whitelistValue?: string(name='WhitelistValue'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeWhitelistForIdeResponseBody = {
  createWhitelistForIdeResult?: {
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    whitelistId?: string(name='WhitelistId'),
  }(name='CreateWhitelistForIdeResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeWhitelistForIdeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMcubeWhitelistForIdeResponseBody(name='body'),
}

async function createMcubeWhitelistForIdeWithOptions(request: CreateMcubeWhitelistForIdeRequest, runtime: Util.RuntimeOptions): CreateMcubeWhitelistForIdeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.whitelistValue)) {
    body['WhitelistValue'] = request.whitelistValue;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMcubeWhitelistForIde',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMcubeWhitelistForIde(request: CreateMcubeWhitelistForIdeRequest): CreateMcubeWhitelistForIdeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMcubeWhitelistForIdeWithOptions(request, runtime);
}

model CreateMdsMiniprogramTaskRequest {
  appId?: string(name='AppId'),
  greyConfigInfo?: string(name='GreyConfigInfo'),
  greyEndtimeData?: string(name='GreyEndtimeData'),
  greyNum?: string(name='GreyNum'),
  id?: long(name='Id'),
  memo?: string(name='Memo'),
  packageId?: long(name='PackageId'),
  publishMode?: string(name='PublishMode'),
  publishType?: long(name='PublishType'),
  syncMode?: string(name='SyncMode'),
  tenantId?: string(name='TenantId'),
  whitelistIds?: string(name='WhitelistIds'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMdsMiniprogramTaskResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      requestId?: string(name='RequestId'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMdsMiniprogramTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMdsMiniprogramTaskResponseBody(name='body'),
}

async function createMdsMiniprogramTaskWithOptions(request: CreateMdsMiniprogramTaskRequest, runtime: Util.RuntimeOptions): CreateMdsMiniprogramTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.greyConfigInfo)) {
    body['GreyConfigInfo'] = request.greyConfigInfo;
  }
  if (!Util.isUnset(request.greyEndtimeData)) {
    body['GreyEndtimeData'] = request.greyEndtimeData;
  }
  if (!Util.isUnset(request.greyNum)) {
    body['GreyNum'] = request.greyNum;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.memo)) {
    body['Memo'] = request.memo;
  }
  if (!Util.isUnset(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!Util.isUnset(request.publishMode)) {
    body['PublishMode'] = request.publishMode;
  }
  if (!Util.isUnset(request.publishType)) {
    body['PublishType'] = request.publishType;
  }
  if (!Util.isUnset(request.syncMode)) {
    body['SyncMode'] = request.syncMode;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.whitelistIds)) {
    body['WhitelistIds'] = request.whitelistIds;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMdsMiniprogramTask',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMdsMiniprogramTask(request: CreateMdsMiniprogramTaskRequest): CreateMdsMiniprogramTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMdsMiniprogramTaskWithOptions(request, runtime);
}

model CreateMsaEnhanceRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMsaEnhanceCreateJsonStr?: string(name='MpaasMappcenterMsaEnhanceCreateJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMsaEnhanceResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMsaEnhanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMsaEnhanceResponseBody(name='body'),
}

async function createMsaEnhanceWithOptions(request: CreateMsaEnhanceRequest, runtime: Util.RuntimeOptions): CreateMsaEnhanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMsaEnhanceCreateJsonStr)) {
    body['MpaasMappcenterMsaEnhanceCreateJsonStr'] = request.mpaasMappcenterMsaEnhanceCreateJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMsaEnhance',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMsaEnhance(request: CreateMsaEnhanceRequest): CreateMsaEnhanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMsaEnhanceWithOptions(request, runtime);
}

model CreateOpenGlobalDataRequest {
  appId?: string(name='AppId'),
  appMaxVersion?: string(name='AppMaxVersion'),
  appMinVersion?: string(name='AppMinVersion'),
  bizType?: string(name='BizType'),
  extAttrStr?: string(name='ExtAttrStr'),
  maxUid?: long(name='MaxUid'),
  minUid?: long(name='MinUid'),
  osType?: string(name='OsType'),
  payload?: string(name='Payload'),
  thirdMsgId?: string(name='ThirdMsgId'),
  uids?: string(name='Uids'),
  validTimeEnd?: long(name='ValidTimeEnd'),
  validTimeStart?: long(name='ValidTimeStart'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateOpenGlobalDataResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateOpenGlobalDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOpenGlobalDataResponseBody(name='body'),
}

async function createOpenGlobalDataWithOptions(request: CreateOpenGlobalDataRequest, runtime: Util.RuntimeOptions): CreateOpenGlobalDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appMaxVersion)) {
    body['AppMaxVersion'] = request.appMaxVersion;
  }
  if (!Util.isUnset(request.appMinVersion)) {
    body['AppMinVersion'] = request.appMinVersion;
  }
  if (!Util.isUnset(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.extAttrStr)) {
    body['ExtAttrStr'] = request.extAttrStr;
  }
  if (!Util.isUnset(request.maxUid)) {
    body['MaxUid'] = request.maxUid;
  }
  if (!Util.isUnset(request.minUid)) {
    body['MinUid'] = request.minUid;
  }
  if (!Util.isUnset(request.osType)) {
    body['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.payload)) {
    body['Payload'] = request.payload;
  }
  if (!Util.isUnset(request.thirdMsgId)) {
    body['ThirdMsgId'] = request.thirdMsgId;
  }
  if (!Util.isUnset(request.uids)) {
    body['Uids'] = request.uids;
  }
  if (!Util.isUnset(request.validTimeEnd)) {
    body['ValidTimeEnd'] = request.validTimeEnd;
  }
  if (!Util.isUnset(request.validTimeStart)) {
    body['ValidTimeStart'] = request.validTimeStart;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOpenGlobalData',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOpenGlobalData(request: CreateOpenGlobalDataRequest): CreateOpenGlobalDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOpenGlobalDataWithOptions(request, runtime);
}

model CreateOpenSingleDataRequest {
  appId?: string(name='AppId'),
  appMaxVersion?: string(name='AppMaxVersion'),
  appMinVersion?: string(name='AppMinVersion'),
  bizType?: string(name='BizType'),
  checkOnline?: boolean(name='CheckOnline'),
  extAttrStr?: string(name='ExtAttrStr'),
  linkToken?: string(name='LinkToken'),
  osType?: string(name='OsType'),
  payload?: string(name='Payload'),
  thirdMsgId?: string(name='ThirdMsgId'),
  validTimeEnd?: long(name='ValidTimeEnd'),
  validTimeStart?: long(name='ValidTimeStart'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateOpenSingleDataResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateOpenSingleDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOpenSingleDataResponseBody(name='body'),
}

async function createOpenSingleDataWithOptions(request: CreateOpenSingleDataRequest, runtime: Util.RuntimeOptions): CreateOpenSingleDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appMaxVersion)) {
    body['AppMaxVersion'] = request.appMaxVersion;
  }
  if (!Util.isUnset(request.appMinVersion)) {
    body['AppMinVersion'] = request.appMinVersion;
  }
  if (!Util.isUnset(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.checkOnline)) {
    body['CheckOnline'] = request.checkOnline;
  }
  if (!Util.isUnset(request.extAttrStr)) {
    body['ExtAttrStr'] = request.extAttrStr;
  }
  if (!Util.isUnset(request.linkToken)) {
    body['LinkToken'] = request.linkToken;
  }
  if (!Util.isUnset(request.osType)) {
    body['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.payload)) {
    body['Payload'] = request.payload;
  }
  if (!Util.isUnset(request.thirdMsgId)) {
    body['ThirdMsgId'] = request.thirdMsgId;
  }
  if (!Util.isUnset(request.validTimeEnd)) {
    body['ValidTimeEnd'] = request.validTimeEnd;
  }
  if (!Util.isUnset(request.validTimeStart)) {
    body['ValidTimeStart'] = request.validTimeStart;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOpenSingleData',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOpenSingleData(request: CreateOpenSingleDataRequest): CreateOpenSingleDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOpenSingleDataWithOptions(request, runtime);
}

model DeleteCubecardWhitelistContentRequest {
  appId?: string(name='AppId'),
  tenantId?: string(name='TenantId'),
  whitelistId?: string(name='WhitelistId'),
  whitelistValue?: string(name='WhitelistValue'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteCubecardWhitelistContentResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteCubecardWhitelistContentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCubecardWhitelistContentResponseBody(name='body'),
}

async function deleteCubecardWhitelistContentWithOptions(request: DeleteCubecardWhitelistContentRequest, runtime: Util.RuntimeOptions): DeleteCubecardWhitelistContentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.whitelistId)) {
    body['WhitelistId'] = request.whitelistId;
  }
  if (!Util.isUnset(request.whitelistValue)) {
    body['WhitelistValue'] = request.whitelistValue;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCubecardWhitelistContent',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCubecardWhitelistContent(request: DeleteCubecardWhitelistContentRequest): DeleteCubecardWhitelistContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCubecardWhitelistContentWithOptions(request, runtime);
}

model DeleteMcdpAimRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpAimDeleteJsonStr?: string(name='MpaasMappcenterMcdpAimDeleteJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcdpAimResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcdpAimResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMcdpAimResponseBody(name='body'),
}

async function deleteMcdpAimWithOptions(request: DeleteMcdpAimRequest, runtime: Util.RuntimeOptions): DeleteMcdpAimResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMcdpAimDeleteJsonStr)) {
    body['MpaasMappcenterMcdpAimDeleteJsonStr'] = request.mpaasMappcenterMcdpAimDeleteJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMcdpAim',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMcdpAim(request: DeleteMcdpAimRequest): DeleteMcdpAimResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcdpAimWithOptions(request, runtime);
}

model DeleteMcdpCrowdRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpCrowdDeleteJsonStr?: string(name='MpaasMappcenterMcdpCrowdDeleteJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcdpCrowdResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcdpCrowdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMcdpCrowdResponseBody(name='body'),
}

async function deleteMcdpCrowdWithOptions(request: DeleteMcdpCrowdRequest, runtime: Util.RuntimeOptions): DeleteMcdpCrowdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMcdpCrowdDeleteJsonStr)) {
    body['MpaasMappcenterMcdpCrowdDeleteJsonStr'] = request.mpaasMappcenterMcdpCrowdDeleteJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMcdpCrowd',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMcdpCrowd(request: DeleteMcdpCrowdRequest): DeleteMcdpCrowdResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcdpCrowdWithOptions(request, runtime);
}

model DeleteMcdpEventAttributeByIdRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpEventAttributeDeleteJsonStr?: string(name='MpaasMappcenterMcdpEventAttributeDeleteJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcdpEventAttributeByIdResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcdpEventAttributeByIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMcdpEventAttributeByIdResponseBody(name='body'),
}

async function deleteMcdpEventAttributeByIdWithOptions(request: DeleteMcdpEventAttributeByIdRequest, runtime: Util.RuntimeOptions): DeleteMcdpEventAttributeByIdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMcdpEventAttributeDeleteJsonStr)) {
    body['MpaasMappcenterMcdpEventAttributeDeleteJsonStr'] = request.mpaasMappcenterMcdpEventAttributeDeleteJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMcdpEventAttributeById',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMcdpEventAttributeById(request: DeleteMcdpEventAttributeByIdRequest): DeleteMcdpEventAttributeByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcdpEventAttributeByIdWithOptions(request, runtime);
}

model DeleteMcdpEventByIdRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpEventDeleteJsonStr?: string(name='MpaasMappcenterMcdpEventDeleteJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcdpEventByIdResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcdpEventByIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMcdpEventByIdResponseBody(name='body'),
}

async function deleteMcdpEventByIdWithOptions(request: DeleteMcdpEventByIdRequest, runtime: Util.RuntimeOptions): DeleteMcdpEventByIdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMcdpEventDeleteJsonStr)) {
    body['MpaasMappcenterMcdpEventDeleteJsonStr'] = request.mpaasMappcenterMcdpEventDeleteJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMcdpEventById',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMcdpEventById(request: DeleteMcdpEventByIdRequest): DeleteMcdpEventByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcdpEventByIdWithOptions(request, runtime);
}

model DeleteMcdpMaterialRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpMaterialDeleteJsonStr?: string(name='MpaasMappcenterMcdpMaterialDeleteJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcdpMaterialResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcdpMaterialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMcdpMaterialResponseBody(name='body'),
}

async function deleteMcdpMaterialWithOptions(request: DeleteMcdpMaterialRequest, runtime: Util.RuntimeOptions): DeleteMcdpMaterialResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMcdpMaterialDeleteJsonStr)) {
    body['MpaasMappcenterMcdpMaterialDeleteJsonStr'] = request.mpaasMappcenterMcdpMaterialDeleteJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMcdpMaterial',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMcdpMaterial(request: DeleteMcdpMaterialRequest): DeleteMcdpMaterialResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcdpMaterialWithOptions(request, runtime);
}

model DeleteMcdpZoneRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpZoneDeleteJsonStr?: string(name='MpaasMappcenterMcdpZoneDeleteJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcdpZoneResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcdpZoneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMcdpZoneResponseBody(name='body'),
}

async function deleteMcdpZoneWithOptions(request: DeleteMcdpZoneRequest, runtime: Util.RuntimeOptions): DeleteMcdpZoneResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMcdpZoneDeleteJsonStr)) {
    body['MpaasMappcenterMcdpZoneDeleteJsonStr'] = request.mpaasMappcenterMcdpZoneDeleteJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMcdpZone',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMcdpZone(request: DeleteMcdpZoneRequest): DeleteMcdpZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcdpZoneWithOptions(request, runtime);
}

model DeleteMcubeMiniAppRequest {
  appId?: string(name='AppId'),
  h5Id?: string(name='H5Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcubeMiniAppResponseBody = {
  deleteMiniResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteMiniResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeMiniAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMcubeMiniAppResponseBody(name='body'),
}

async function deleteMcubeMiniAppWithOptions(request: DeleteMcubeMiniAppRequest, runtime: Util.RuntimeOptions): DeleteMcubeMiniAppResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMcubeMiniApp',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMcubeMiniApp(request: DeleteMcubeMiniAppRequest): DeleteMcubeMiniAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcubeMiniAppWithOptions(request, runtime);
}

model DeleteMcubeNebulaAppRequest {
  appId?: string(name='AppId'),
  h5Id?: string(name='H5Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcubeNebulaAppResponseBody = {
  deleteMcubeNebulaAppResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteMcubeNebulaAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeNebulaAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMcubeNebulaAppResponseBody(name='body'),
}

async function deleteMcubeNebulaAppWithOptions(request: DeleteMcubeNebulaAppRequest, runtime: Util.RuntimeOptions): DeleteMcubeNebulaAppResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMcubeNebulaApp',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMcubeNebulaApp(request: DeleteMcubeNebulaAppRequest): DeleteMcubeNebulaAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcubeNebulaAppWithOptions(request, runtime);
}

model DeleteMcubeUpgradeResourceRequest {
  appId?: string(name='AppId'),
  id?: string(name='Id'),
  platform?: string(name='Platform'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcubeUpgradeResourceResponseBody = {
  deleteResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeUpgradeResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMcubeUpgradeResourceResponseBody(name='body'),
}

async function deleteMcubeUpgradeResourceWithOptions(request: DeleteMcubeUpgradeResourceRequest, runtime: Util.RuntimeOptions): DeleteMcubeUpgradeResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMcubeUpgradeResource',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMcubeUpgradeResource(request: DeleteMcubeUpgradeResourceRequest): DeleteMcubeUpgradeResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcubeUpgradeResourceWithOptions(request, runtime);
}

model DeleteMcubeWhitelistRequest {
  appId?: string(name='AppId'),
  id?: long(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcubeWhitelistResponseBody = {
  deleteWhitelistResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMcubeWhitelistResponseBody(name='body'),
}

async function deleteMcubeWhitelistWithOptions(request: DeleteMcubeWhitelistRequest, runtime: Util.RuntimeOptions): DeleteMcubeWhitelistResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMcubeWhitelist',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMcubeWhitelist(request: DeleteMcubeWhitelistRequest): DeleteMcubeWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMcubeWhitelistWithOptions(request, runtime);
}

model DeleteMdsWhitelistContentRequest {
  appId?: string(name='AppId'),
  tenantId?: string(name='TenantId'),
  whitelistId?: string(name='WhitelistId'),
  whitelistValue?: string(name='WhitelistValue'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMdsWhitelistContentResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMdsWhitelistContentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMdsWhitelistContentResponseBody(name='body'),
}

async function deleteMdsWhitelistContentWithOptions(request: DeleteMdsWhitelistContentRequest, runtime: Util.RuntimeOptions): DeleteMdsWhitelistContentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.whitelistId)) {
    body['WhitelistId'] = request.whitelistId;
  }
  if (!Util.isUnset(request.whitelistValue)) {
    body['WhitelistValue'] = request.whitelistValue;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMdsWhitelistContent',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMdsWhitelistContent(request: DeleteMdsWhitelistContentRequest): DeleteMdsWhitelistContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMdsWhitelistContentWithOptions(request, runtime);
}

model ExistMcubeRsaKeyRequest {
  appId?: string(name='AppId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ExistMcubeRsaKeyResponseBody = {
  checkRsaKeyResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CheckRsaKeyResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ExistMcubeRsaKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExistMcubeRsaKeyResponseBody(name='body'),
}

async function existMcubeRsaKeyWithOptions(request: ExistMcubeRsaKeyRequest, runtime: Util.RuntimeOptions): ExistMcubeRsaKeyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ExistMcubeRsaKey',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function existMcubeRsaKey(request: ExistMcubeRsaKeyRequest): ExistMcubeRsaKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return existMcubeRsaKeyWithOptions(request, runtime);
}

model ExportMappCenterAppConfigRequest {
  appId?: string(name='AppId'),
  certRsaBase64?: string(name='CertRsaBase64'),
  identifier?: string(name='Identifier'),
  onexFlag?: boolean(name='OnexFlag'),
  systemType?: string(name='SystemType'),
  workspaceId?: string(name='WorkspaceId'),
}

model ExportMappCenterAppConfigResponseBody = {
  exportMappCenterAppConfigResult?: {
    configDownloadUrl?: string(name='ConfigDownloadUrl'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ExportMappCenterAppConfigResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ExportMappCenterAppConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExportMappCenterAppConfigResponseBody(name='body'),
}

async function exportMappCenterAppConfigWithOptions(request: ExportMappCenterAppConfigRequest, runtime: Util.RuntimeOptions): ExportMappCenterAppConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.certRsaBase64)) {
    body['CertRsaBase64'] = request.certRsaBase64;
  }
  if (!Util.isUnset(request.identifier)) {
    body['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!Util.isUnset(request.systemType)) {
    body['SystemType'] = request.systemType;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ExportMappCenterAppConfig',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function exportMappCenterAppConfig(request: ExportMappCenterAppConfigRequest): ExportMappCenterAppConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportMappCenterAppConfigWithOptions(request, runtime);
}

model GetFileTokenForUploadToMsaRequest {
  appId?: string(name='AppId'),
  onexFlag?: boolean(name='OnexFlag'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetFileTokenForUploadToMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    content?: {
      accessid?: string(name='Accessid'),
      dir?: string(name='Dir'),
      expire?: string(name='Expire'),
      host?: string(name='Host'),
      policy?: string(name='Policy'),
      signature?: string(name='Signature'),
    }(name='Content'),
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: string(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetFileTokenForUploadToMsaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFileTokenForUploadToMsaResponseBody(name='body'),
}

async function getFileTokenForUploadToMsaWithOptions(request: GetFileTokenForUploadToMsaRequest, runtime: Util.RuntimeOptions): GetFileTokenForUploadToMsaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetFileTokenForUploadToMsa',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFileTokenForUploadToMsa(request: GetFileTokenForUploadToMsaRequest): GetFileTokenForUploadToMsaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileTokenForUploadToMsaWithOptions(request, runtime);
}

model GetLogUrlInMsaRequest {
  appId?: string(name='AppId'),
  id?: long(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetLogUrlInMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetLogUrlInMsaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLogUrlInMsaResponseBody(name='body'),
}

async function getLogUrlInMsaWithOptions(request: GetLogUrlInMsaRequest, runtime: Util.RuntimeOptions): GetLogUrlInMsaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetLogUrlInMsa',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLogUrlInMsa(request: GetLogUrlInMsaRequest): GetLogUrlInMsaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLogUrlInMsaWithOptions(request, runtime);
}

model GetMcubeFileTokenRequest {
  appId?: string(name='AppId'),
  onexFlag?: boolean(name='OnexFlag'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetMcubeFileTokenResponseBody = {
  getFileTokenResult?: {
    fileToken?: {
      accessid?: string(name='Accessid'),
      dir?: string(name='Dir'),
      expire?: string(name='Expire'),
      host?: string(name='Host'),
      policy?: string(name='Policy'),
      signature?: string(name='Signature'),
    }(name='FileToken'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetFileTokenResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeFileTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMcubeFileTokenResponseBody(name='body'),
}

async function getMcubeFileTokenWithOptions(request: GetMcubeFileTokenRequest, runtime: Util.RuntimeOptions): GetMcubeFileTokenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMcubeFileToken',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMcubeFileToken(request: GetMcubeFileTokenRequest): GetMcubeFileTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMcubeFileTokenWithOptions(request, runtime);
}

model GetMcubeNebulaResourceRequest {
  appId?: string(name='AppId'),
  id?: string(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetMcubeNebulaResourceResponseBody = {
  getNebulaResourceResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaResourceInfo?: {
      appCode?: string(name='AppCode'),
      autoInstall?: int32(name='AutoInstall'),
      clientVersionMax?: string(name='ClientVersionMax'),
      clientVersionMin?: string(name='ClientVersionMin'),
      creator?: string(name='Creator'),
      downloadUrl?: string(name='DownloadUrl'),
      extendInfo?: string(name='ExtendInfo'),
      extraData?: string(name='ExtraData'),
      fallbackBaseUrl?: string(name='FallbackBaseUrl'),
      fileSize?: string(name='FileSize'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      h5Id?: string(name='H5Id'),
      h5Name?: string(name='H5Name'),
      h5Version?: string(name='H5Version'),
      id?: long(name='Id'),
      installType?: int32(name='InstallType'),
      mainUrl?: string(name='MainUrl'),
      memo?: string(name='Memo'),
      metaId?: long(name='MetaId'),
      modifier?: string(name='Modifier'),
      packageType?: int32(name='PackageType'),
      platform?: string(name='Platform'),
      publishPeriod?: int32(name='PublishPeriod'),
      resourceType?: string(name='ResourceType'),
      status?: int32(name='Status'),
      vhost?: string(name='Vhost'),
    }(name='NebulaResourceInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetNebulaResourceResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeNebulaResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMcubeNebulaResourceResponseBody(name='body'),
}

async function getMcubeNebulaResourceWithOptions(request: GetMcubeNebulaResourceRequest, runtime: Util.RuntimeOptions): GetMcubeNebulaResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMcubeNebulaResource',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMcubeNebulaResource(request: GetMcubeNebulaResourceRequest): GetMcubeNebulaResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMcubeNebulaResourceWithOptions(request, runtime);
}

model GetMcubeNebulaTaskDetailRequest {
  appId?: string(name='AppId'),
  taskId?: long(name='TaskId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetMcubeNebulaTaskDetailResponseBody = {
  getMcubeNebulaTaskDetailResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaTaskDetail?: {
      appCode?: string(name='AppCode'),
      appId?: string(name='AppId'),
      atomic?: int32(name='Atomic'),
      baseInfoId?: long(name='BaseInfoId'),
      bizType?: string(name='BizType'),
      creator?: string(name='Creator'),
      cronexpress?: int32(name='Cronexpress'),
      downloadUrl?: string(name='DownloadUrl'),
      extraData?: string(name='ExtraData'),
      fileSize?: string(name='FileSize'),
      fullRepair?: int32(name='FullRepair'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      gmtModifiedStr?: string(name='GmtModifiedStr'),
      greyConfigInfo?: string(name='GreyConfigInfo'),
      greyEndtime?: string(name='GreyEndtime'),
      greyEndtimeData?: string(name='GreyEndtimeData'),
      greyEndtimeStr?: string(name='GreyEndtimeStr'),
      greyNum?: int32(name='GreyNum'),
      greyUrl?: string(name='GreyUrl'),
      id?: long(name='Id'),
      issueDesc?: string(name='IssueDesc'),
      memo?: string(name='Memo'),
      modifier?: string(name='Modifier'),
      ossPath?: string(name='OssPath'),
      packageId?: long(name='PackageId'),
      percent?: int32(name='Percent'),
      platform?: string(name='Platform'),
      productId?: string(name='ProductId'),
      productVersion?: string(name='ProductVersion'),
      publishMode?: int32(name='PublishMode'),
      publishPeriod?: int32(name='PublishPeriod'),
      publishType?: int32(name='PublishType'),
      quickRollback?: int32(name='QuickRollback'),
      releaseVersion?: string(name='ReleaseVersion'),
      ruleJsonList?: [ 
        {
          operation?: string(name='Operation'),
          ruleElement?: string(name='RuleElement'),
          ruleType?: string(name='RuleType'),
          value?: string(name='Value'),
        }
      ](name='RuleJsonList'),
      sourceId?: string(name='SourceId'),
      sourceName?: string(name='SourceName'),
      sourceType?: string(name='SourceType'),
      status?: int32(name='Status'),
      syncResult?: string(name='SyncResult'),
      syncType?: int32(name='SyncType'),
      taskName?: string(name='TaskName'),
      taskStatus?: int32(name='TaskStatus'),
      taskType?: int32(name='TaskType'),
      taskVersion?: long(name='TaskVersion'),
      upgradeNoticeNum?: long(name='UpgradeNoticeNum'),
      upgradeProgress?: string(name='UpgradeProgress'),
      whitelistIds?: string(name='WhitelistIds'),
      workspaceId?: string(name='WorkspaceId'),
    }(name='NebulaTaskDetail'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetMcubeNebulaTaskDetailResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeNebulaTaskDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMcubeNebulaTaskDetailResponseBody(name='body'),
}

async function getMcubeNebulaTaskDetailWithOptions(request: GetMcubeNebulaTaskDetailRequest, runtime: Util.RuntimeOptions): GetMcubeNebulaTaskDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMcubeNebulaTaskDetail',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMcubeNebulaTaskDetail(request: GetMcubeNebulaTaskDetailRequest): GetMcubeNebulaTaskDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMcubeNebulaTaskDetailWithOptions(request, runtime);
}

model GetMcubeUpgradePackageInfoRequest {
  appId?: string(name='AppId'),
  packageId?: long(name='PackageId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetMcubeUpgradePackageInfoResponseBody = {
  getPackageResult?: {
    errorCode?: string(name='ErrorCode'),
    packageInfo?: {
      mobileTestFlightConfigDO?: {
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        installAmount?: int32(name='InstallAmount'),
        invalidTime?: string(name='InvalidTime'),
        upgradeId?: long(name='UpgradeId'),
      }(name='MobileTestFlightConfigDO'),
      upgradeBaseInfoDO?: {
        allowCreateTask?: boolean(name='AllowCreateTask'),
        appCode?: string(name='AppCode'),
        appstoreUrl?: string(name='AppstoreUrl'),
        backLog?: string(name='BackLog'),
        changeLog?: string(name='ChangeLog'),
        clientFileSize?: int32(name='ClientFileSize'),
        clientName?: string(name='ClientName'),
        cpId?: string(name='CpId'),
        creator?: string(name='Creator'),
        downloadUrl?: string(name='DownloadUrl'),
        globalVariables?: string(name='GlobalVariables'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateStr?: string(name='GmtCreateStr'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedStr?: string(name='GmtModifiedStr'),
        id?: long(name='Id'),
        innerVersion?: string(name='InnerVersion'),
        iosSymbol?: string(name='IosSymbol'),
        isEnterprise?: int32(name='IsEnterprise'),
        isRc?: int32(name='IsRc'),
        isRelease?: int32(name='IsRelease'),
        maxVersion?: string(name='MaxVersion'),
        md5?: string(name='Md5'),
        modifier?: string(name='Modifier'),
        needCheck?: int32(name='NeedCheck'),
        ossPath?: string(name='OssPath'),
        packageType?: string(name='PackageType'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productName?: string(name='ProductName'),
        productVersion?: string(name='ProductVersion'),
        publishPeriod?: int32(name='PublishPeriod'),
        qrcodeUrl?: string(name='QrcodeUrl'),
        releaseType?: string(name='ReleaseType'),
        releaseWindow?: string(name='ReleaseWindow'),
        scmDownloadUrl?: string(name='ScmDownloadUrl'),
        serverVersion?: int32(name='ServerVersion'),
        verificationCode?: string(name='VerificationCode'),
        verifyResult?: int32(name='VerifyResult'),
        versionCode?: string(name='VersionCode'),
      }(name='UpgradeBaseInfoDO'),
    }(name='PackageInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetPackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeUpgradePackageInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMcubeUpgradePackageInfoResponseBody(name='body'),
}

async function getMcubeUpgradePackageInfoWithOptions(request: GetMcubeUpgradePackageInfoRequest, runtime: Util.RuntimeOptions): GetMcubeUpgradePackageInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMcubeUpgradePackageInfo',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMcubeUpgradePackageInfo(request: GetMcubeUpgradePackageInfoRequest): GetMcubeUpgradePackageInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMcubeUpgradePackageInfoWithOptions(request, runtime);
}

model GetMcubeUpgradeTaskInfoRequest {
  appId?: string(name='AppId'),
  taskId?: long(name='TaskId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetMcubeUpgradeTaskInfoResponseBody = {
  getTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    taskInfo?: {
      appCode?: string(name='AppCode'),
      appId?: string(name='AppId'),
      appstoreUrl?: string(name='AppstoreUrl'),
      creater?: string(name='Creater'),
      creator?: string(name='Creator'),
      downloadUrl?: string(name='DownloadUrl'),
      greyConfigInfo?: string(name='GreyConfigInfo'),
      greyEndtimeData?: string(name='GreyEndtimeData'),
      greyNum?: int32(name='GreyNum'),
      historyForce?: int32(name='HistoryForce'),
      id?: long(name='Id'),
      isEnterprise?: int32(name='IsEnterprise'),
      isOfficial?: int32(name='IsOfficial'),
      isRc?: int32(name='IsRc'),
      isRelease?: int32(name='IsRelease'),
      memo?: string(name='Memo'),
      modifier?: string(name='Modifier'),
      netType?: string(name='NetType'),
      osVersion?: string(name='OsVersion'),
      packageInfoId?: long(name='PackageInfoId'),
      packageType?: string(name='PackageType'),
      platform?: string(name='Platform'),
      productId?: string(name='ProductId'),
      publishMode?: int32(name='PublishMode'),
      publishType?: int32(name='PublishType'),
      pushContent?: string(name='PushContent'),
      qrcodeUrl?: string(name='QrcodeUrl'),
      ruleJsonList?: [ 
        {
          operation?: string(name='Operation'),
          ruleElement?: string(name='RuleElement'),
          ruleType?: string(name='RuleType'),
          value?: string(name='Value'),
        }
      ](name='RuleJsonList'),
      silentType?: int32(name='SilentType'),
      taskStatus?: int32(name='TaskStatus'),
      upgradeContent?: string(name='UpgradeContent'),
      upgradeType?: int32(name='UpgradeType'),
      upgradeValidTime?: int32(name='UpgradeValidTime'),
      whitelist?: [ 
        {
          appCode?: string(name='AppCode'),
          id?: long(name='Id'),
          idType?: string(name='IdType'),
          platform?: string(name='Platform'),
          status?: int32(name='Status'),
          userType?: string(name='UserType'),
          whiteListCount?: long(name='WhiteListCount'),
          whiteListName?: string(name='WhiteListName'),
          whitelistType?: string(name='WhitelistType'),
        }
      ](name='Whitelist'),
      whitelistIds?: string(name='WhitelistIds'),
      workspaceId?: string(name='WorkspaceId'),
    }(name='TaskInfo'),
  }(name='GetTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeUpgradeTaskInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMcubeUpgradeTaskInfoResponseBody(name='body'),
}

async function getMcubeUpgradeTaskInfoWithOptions(request: GetMcubeUpgradeTaskInfoRequest, runtime: Util.RuntimeOptions): GetMcubeUpgradeTaskInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMcubeUpgradeTaskInfo',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMcubeUpgradeTaskInfo(request: GetMcubeUpgradeTaskInfoRequest): GetMcubeUpgradeTaskInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMcubeUpgradeTaskInfoWithOptions(request, runtime);
}

model GetMdsMiniConfigRequest {
  appId?: string(name='AppId'),
  h5Id?: string(name='H5Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetMdsMiniConfigResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: {
        apiConfigList?: [ 
          {
            appCode?: string(name='AppCode'),
            configStatus?: long(name='ConfigStatus'),
            configType?: string(name='ConfigType'),
            configValue?: string(name='ConfigValue'),
            description?: string(name='Description'),
            gmtCreate?: string(name='GmtCreate'),
            gmtModified?: string(name='GmtModified'),
            h5Id?: string(name='H5Id'),
            h5Name?: string(name='H5Name'),
            id?: long(name='Id'),
          }
        ](name='ApiConfigList'),
        appCode?: string(name='AppCode'),
        enableServerDomainCount?: string(name='EnableServerDomainCount'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
        privilegeSwitch?: {
          appCode?: string(name='AppCode'),
          configStatus?: long(name='ConfigStatus'),
          configType?: string(name='ConfigType'),
          configValue?: string(name='ConfigValue'),
          description?: string(name='Description'),
          gmtCreate?: string(name='GmtCreate'),
          gmtModified?: string(name='GmtModified'),
          h5Id?: string(name='H5Id'),
          h5Name?: string(name='H5Name'),
          id?: long(name='Id'),
        }(name='PrivilegeSwitch'),
        serverDomainConfigList?: [ 
          {
            appCode?: string(name='AppCode'),
            configStatus?: long(name='ConfigStatus'),
            configType?: string(name='ConfigType'),
            configValue?: string(name='ConfigValue'),
            description?: string(name='Description'),
            gmtCreate?: string(name='GmtCreate'),
            gmtModified?: string(name='GmtModified'),
            h5Id?: string(name='H5Id'),
            h5Name?: string(name='H5Name'),
            id?: long(name='Id'),
          }
        ](name='ServerDomainConfigList'),
        webviewDomainConfigList?: [ 
          {
            appCode?: string(name='AppCode'),
            configStatus?: long(name='ConfigStatus'),
            configType?: string(name='ConfigType'),
            configValue?: string(name='ConfigValue'),
            description?: string(name='Description'),
            gmtCreate?: string(name='GmtCreate'),
            gmtModified?: string(name='GmtModified'),
            h5Id?: string(name='H5Id'),
            h5Name?: string(name='H5Name'),
            id?: long(name='Id'),
          }
        ](name='WebviewDomainConfigList'),
      }(name='Content'),
      requestId?: string(name='RequestId'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMdsMiniConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMdsMiniConfigResponseBody(name='body'),
}

async function getMdsMiniConfigWithOptions(request: GetMdsMiniConfigRequest, runtime: Util.RuntimeOptions): GetMdsMiniConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMdsMiniConfig',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMdsMiniConfig(request: GetMdsMiniConfigRequest): GetMdsMiniConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMdsMiniConfigWithOptions(request, runtime);
}

model GetUserAppDonwloadUrlInMsaRequest {
  appId?: string(name='AppId'),
  id?: long(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetUserAppDonwloadUrlInMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: {
      filename?: string(name='Filename'),
      url?: string(name='Url'),
    }(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetUserAppDonwloadUrlInMsaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserAppDonwloadUrlInMsaResponseBody(name='body'),
}

async function getUserAppDonwloadUrlInMsaWithOptions(request: GetUserAppDonwloadUrlInMsaRequest, runtime: Util.RuntimeOptions): GetUserAppDonwloadUrlInMsaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetUserAppDonwloadUrlInMsa',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserAppDonwloadUrlInMsa(request: GetUserAppDonwloadUrlInMsaRequest): GetUserAppDonwloadUrlInMsaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserAppDonwloadUrlInMsaWithOptions(request, runtime);
}

model GetUserAppEnhanceProcessInMsaRequest {
  appId?: string(name='AppId'),
  id?: long(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetUserAppEnhanceProcessInMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: {
      afterMd5?: string(name='AfterMd5'),
      afterSize?: long(name='AfterSize'),
      appCode?: string(name='AppCode'),
      appPackage?: string(name='AppPackage'),
      assetsFileList?: [ string ](name='AssetsFileList'),
      beforeMd5?: string(name='BeforeMd5'),
      beforeSize?: long(name='BeforeSize'),
      classForest?: [ string ](name='ClassForest'),
      enhanceMapping?: [ 
        {
          info?: string(name='Info'),
          reason?: string(name='Reason'),
          type?: string(name='Type'),
        }
      ](name='EnhanceMapping'),
      enhanceRules?: [ string ](name='EnhanceRules'),
      enhancedAssetsFiles?: [ string ](name='EnhancedAssetsFiles'),
      enhancedClasses?: [ string ](name='EnhancedClasses'),
      enhancedSoFiles?: [ string ](name='EnhancedSoFiles'),
      id?: long(name='Id'),
      label?: string(name='Label'),
      progress?: long(name='Progress'),
      soFileList?: [ string ](name='SoFileList'),
      status?: long(name='Status'),
      taskType?: string(name='TaskType'),
      versionCode?: string(name='VersionCode'),
      versionName?: string(name='VersionName'),
    }(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetUserAppEnhanceProcessInMsaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserAppEnhanceProcessInMsaResponseBody(name='body'),
}

async function getUserAppEnhanceProcessInMsaWithOptions(request: GetUserAppEnhanceProcessInMsaRequest, runtime: Util.RuntimeOptions): GetUserAppEnhanceProcessInMsaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetUserAppEnhanceProcessInMsa',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserAppEnhanceProcessInMsa(request: GetUserAppEnhanceProcessInMsaRequest): GetUserAppEnhanceProcessInMsaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserAppEnhanceProcessInMsaWithOptions(request, runtime);
}

model GetUserAppUploadProcessInMsaRequest {
  appId?: string(name='AppId'),
  id?: long(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetUserAppUploadProcessInMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: {
      apkInfo?: {
        afterMd5?: string(name='AfterMd5'),
        afterSize?: long(name='AfterSize'),
        appCode?: string(name='AppCode'),
        appPackage?: string(name='AppPackage'),
        assetsFileList?: [ string ](name='AssetsFileList'),
        beforeMd5?: string(name='BeforeMd5'),
        beforeSize?: long(name='BeforeSize'),
        classForest?: string(name='ClassForest'),
        enhanceMapping?: [ 
          {
            info?: string(name='Info'),
            reason?: string(name='Reason'),
            type?: string(name='Type'),
          }
        ](name='EnhanceMapping'),
        enhanceRules?: [ string ](name='EnhanceRules'),
        enhancedAssetsFiles?: [ string ](name='EnhancedAssetsFiles'),
        enhancedClasses?: [ string ](name='EnhancedClasses'),
        enhancedSoFiles?: [ string ](name='EnhancedSoFiles'),
        id?: long(name='Id'),
        label?: string(name='Label'),
        progress?: long(name='Progress'),
        soFileList?: [ string ](name='SoFileList'),
        status?: long(name='Status'),
        taskType?: string(name='TaskType'),
        versionCode?: string(name='VersionCode'),
        versionName?: string(name='VersionName'),
      }(name='ApkInfo'),
      enhanceTaskId?: long(name='EnhanceTaskId'),
      id?: long(name='Id'),
      progress?: long(name='Progress'),
      status?: long(name='Status'),
    }(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetUserAppUploadProcessInMsaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserAppUploadProcessInMsaResponseBody(name='body'),
}

async function getUserAppUploadProcessInMsaWithOptions(request: GetUserAppUploadProcessInMsaRequest, runtime: Util.RuntimeOptions): GetUserAppUploadProcessInMsaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetUserAppUploadProcessInMsa',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserAppUploadProcessInMsa(request: GetUserAppUploadProcessInMsaRequest): GetUserAppUploadProcessInMsaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserAppUploadProcessInMsaWithOptions(request, runtime);
}

model ListMappCenterAppsResponseBody = {
  listMappCenterAppResult?: {
    mappCenterAppList?: [ 
      {
        androidConfig?: {
          certRSA?: string(name='CertRSA'),
          packageName?: string(name='PackageName'),
        }(name='AndroidConfig'),
        appDesc?: string(name='AppDesc'),
        appIcon?: string(name='AppIcon'),
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        appSecret?: string(name='AppSecret'),
        creator?: string(name='Creator'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        iosConfig?: {
          bundleId?: string(name='BundleId'),
        }(name='IosConfig'),
        modifier?: string(name='Modifier'),
        monitorJson?: string(name='MonitorJson'),
        status?: long(name='Status'),
        tenantId?: string(name='TenantId'),
        type?: long(name='Type'),
      }
    ](name='MappCenterAppList'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMappCenterAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMappCenterAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMappCenterAppsResponseBody(name='body'),
}

async function listMappCenterAppsWithOptions(runtime: Util.RuntimeOptions): ListMappCenterAppsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListMappCenterApps',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMappCenterApps(): ListMappCenterAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMappCenterAppsWithOptions(runtime);
}

model ListMappCenterWorkspacesResponseBody = {
  listMappCenterWorkspaceResult?: {
    mappCenterWorkspaceList?: [ 
      {
        compatibleId?: string(name='CompatibleId'),
        createTime?: string(name='CreateTime'),
        displayName?: string(name='DisplayName'),
        id?: string(name='Id'),
        region?: string(name='Region'),
        status?: string(name='Status'),
        tenantId?: string(name='TenantId'),
        type?: string(name='Type'),
        uid?: long(name='Uid'),
        updateTime?: string(name='UpdateTime'),
        workspaceId?: string(name='WorkspaceId'),
        zones?: string(name='Zones'),
      }
    ](name='MappCenterWorkspaceList'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    userId?: string(name='UserId'),
  }(name='ListMappCenterWorkspaceResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMappCenterWorkspacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMappCenterWorkspacesResponseBody(name='body'),
}

async function listMappCenterWorkspacesWithOptions(runtime: Util.RuntimeOptions): ListMappCenterWorkspacesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListMappCenterWorkspaces',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMappCenterWorkspaces(): ListMappCenterWorkspacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMappCenterWorkspacesWithOptions(runtime);
}

model ListMcdpAimRequest {
  appId?: string(name='AppId'),
  emptyTag?: string(name='EmptyTag'),
  keyword?: string(name='Keyword'),
  name?: string(name='Name'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  sort?: string(name='Sort'),
  sortField?: string(name='SortField'),
  tenantId?: string(name='TenantId'),
  type?: string(name='Type'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcdpAimResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcdpAimResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMcdpAimResponseBody(name='body'),
}

async function listMcdpAimWithOptions(request: ListMcdpAimRequest, runtime: Util.RuntimeOptions): ListMcdpAimResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.emptyTag)) {
    body['EmptyTag'] = request.emptyTag;
  }
  if (!Util.isUnset(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNo)) {
    body['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sort)) {
    body['Sort'] = request.sort;
  }
  if (!Util.isUnset(request.sortField)) {
    body['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMcdpAim',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMcdpAim(request: ListMcdpAimRequest): ListMcdpAimResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcdpAimWithOptions(request, runtime);
}

model ListMcubeMiniAppsRequest {
  appId?: string(name='AppId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeMiniAppsResponseBody = {
  listMiniResult?: {
    miniProgramList?: [ 
      {
        appCode?: string(name='AppCode'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
      }
    ](name='MiniProgramList'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMiniResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeMiniAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMcubeMiniAppsResponseBody(name='body'),
}

async function listMcubeMiniAppsWithOptions(request: ListMcubeMiniAppsRequest, runtime: Util.RuntimeOptions): ListMcubeMiniAppsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMcubeMiniApps',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMcubeMiniApps(request: ListMcubeMiniAppsRequest): ListMcubeMiniAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeMiniAppsWithOptions(request, runtime);
}

model ListMcubeMiniPackagesRequest {
  appId?: string(name='AppId'),
  h5Id?: string(name='H5Id'),
  packageTypes?: string(name='PackageTypes'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeMiniPackagesResponseBody = {
  listMiniPackageResult?: {
    miniPackageList?: [ 
      {
        appCode?: string(name='AppCode'),
        autoInstall?: long(name='AutoInstall'),
        clientVersionMax?: string(name='ClientVersionMax'),
        clientVersionMin?: string(name='ClientVersionMin'),
        downloadUrl?: string(name='DownloadUrl'),
        extendInfo?: string(name='ExtendInfo'),
        extraData?: string(name='ExtraData'),
        fallbackBaseUrl?: string(name='FallbackBaseUrl'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
        h5Version?: string(name='H5Version'),
        id?: long(name='Id'),
        installType?: long(name='InstallType'),
        mainUrl?: string(name='MainUrl'),
        memo?: string(name='Memo'),
        packageType?: long(name='PackageType'),
        platform?: string(name='Platform'),
        publishPeriod?: long(name='PublishPeriod'),
        resourceType?: long(name='ResourceType'),
        status?: long(name='Status'),
      }
    ](name='MiniPackageList'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMiniPackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeMiniPackagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMcubeMiniPackagesResponseBody(name='body'),
}

async function listMcubeMiniPackagesWithOptions(request: ListMcubeMiniPackagesRequest, runtime: Util.RuntimeOptions): ListMcubeMiniPackagesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!Util.isUnset(request.packageTypes)) {
    body['PackageTypes'] = request.packageTypes;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMcubeMiniPackages',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMcubeMiniPackages(request: ListMcubeMiniPackagesRequest): ListMcubeMiniPackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeMiniPackagesWithOptions(request, runtime);
}

model ListMcubeMiniTasksRequest {
  appId?: string(name='AppId'),
  id?: string(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeMiniTasksResponseBody = {
  listMiniTaskResult?: {
    miniTaskList?: [ 
      {
        appCode?: string(name='AppCode'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtime?: string(name='GreyEndtime'),
        greyEndtimeData?: string(name='GreyEndtimeData'),
        greyNum?: long(name='GreyNum'),
        id?: long(name='Id'),
        memo?: string(name='Memo'),
        packageId?: long(name='PackageId'),
        platform?: string(name='Platform'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: long(name='PublishMode'),
        publishType?: long(name='PublishType'),
        status?: string(name='Status'),
        taskStatus?: long(name='TaskStatus'),
        whitelistIds?: string(name='WhitelistIds'),
      }
    ](name='MiniTaskList'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMiniTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeMiniTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMcubeMiniTasksResponseBody(name='body'),
}

async function listMcubeMiniTasksWithOptions(request: ListMcubeMiniTasksRequest, runtime: Util.RuntimeOptions): ListMcubeMiniTasksResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMcubeMiniTasks',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMcubeMiniTasks(request: ListMcubeMiniTasksRequest): ListMcubeMiniTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeMiniTasksWithOptions(request, runtime);
}

model ListMcubeNebulaAppsRequest {
  appId?: string(name='AppId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeNebulaAppsResponseBody = {
  listMcubeNebulaAppsResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaAppInfos?: [ 
      {
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
      }
    ](name='NebulaAppInfos'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMcubeNebulaAppsResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeNebulaAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMcubeNebulaAppsResponseBody(name='body'),
}

async function listMcubeNebulaAppsWithOptions(request: ListMcubeNebulaAppsRequest, runtime: Util.RuntimeOptions): ListMcubeNebulaAppsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMcubeNebulaApps',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMcubeNebulaApps(request: ListMcubeNebulaAppsRequest): ListMcubeNebulaAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeNebulaAppsWithOptions(request, runtime);
}

model ListMcubeNebulaResourcesRequest {
  appId?: string(name='AppId'),
  h5Id?: string(name='H5Id'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeNebulaResourcesResponseBody = {
  listMcubeNebulaResourceResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaResourceInfo?: [ 
      {
        appCode?: string(name='AppCode'),
        autoInstall?: int32(name='AutoInstall'),
        clientVersionMax?: string(name='ClientVersionMax'),
        clientVersionMin?: string(name='ClientVersionMin'),
        creator?: string(name='Creator'),
        debugUrl?: string(name='DebugUrl'),
        downloadUrl?: string(name='DownloadUrl'),
        extendInfo?: string(name='ExtendInfo'),
        extraData?: string(name='ExtraData'),
        fallbackBaseUrl?: string(name='FallbackBaseUrl'),
        fileSize?: string(name='FileSize'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
        h5Version?: string(name='H5Version'),
        id?: long(name='Id'),
        installType?: int32(name='InstallType'),
        lazyLoad?: int32(name='LazyLoad'),
        mainUrl?: string(name='MainUrl'),
        md5?: string(name='Md5'),
        memo?: string(name='Memo'),
        metaId?: long(name='MetaId'),
        modifier?: string(name='Modifier'),
        packageType?: int32(name='PackageType'),
        platform?: string(name='Platform'),
        publishPeriod?: int32(name='PublishPeriod'),
        releaseVersion?: string(name='ReleaseVersion'),
        resourceType?: string(name='ResourceType'),
        status?: int32(name='Status'),
        vhost?: string(name='Vhost'),
      }
    ](name='NebulaResourceInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMcubeNebulaResourceResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeNebulaResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMcubeNebulaResourcesResponseBody(name='body'),
}

async function listMcubeNebulaResourcesWithOptions(request: ListMcubeNebulaResourcesRequest, runtime: Util.RuntimeOptions): ListMcubeNebulaResourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMcubeNebulaResources',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMcubeNebulaResources(request: ListMcubeNebulaResourcesRequest): ListMcubeNebulaResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeNebulaResourcesWithOptions(request, runtime);
}

model ListMcubeNebulaTasksRequest {
  appId?: string(name='AppId'),
  id?: long(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeNebulaTasksResponseBody = {
  listMcubeNebulaTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaTaskInfo?: [ 
      {
        appCode?: string(name='AppCode'),
        bizType?: string(name='BizType'),
        creator?: string(name='Creator'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedStr?: string(name='GmtModifiedStr'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtime?: string(name='GreyEndtime'),
        greyEndtimeData?: string(name='GreyEndtimeData'),
        greyEndtimeStr?: string(name='GreyEndtimeStr'),
        greyNum?: int32(name='GreyNum'),
        greyUrl?: string(name='GreyUrl'),
        id?: long(name='Id'),
        memo?: string(name='Memo'),
        modifier?: string(name='Modifier'),
        packageId?: long(name='PackageId'),
        percent?: int32(name='Percent'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: int32(name='PublishMode'),
        publishType?: int32(name='PublishType'),
        releaseVersion?: string(name='ReleaseVersion'),
        status?: int32(name='Status'),
        syncResult?: string(name='SyncResult'),
        taskName?: string(name='TaskName'),
        taskStatus?: int32(name='TaskStatus'),
        taskType?: int32(name='TaskType'),
        taskVersion?: long(name='TaskVersion'),
        upgradeNoticeNum?: long(name='UpgradeNoticeNum'),
        upgradeProgress?: string(name='UpgradeProgress'),
        whitelistIds?: string(name='WhitelistIds'),
      }
    ](name='NebulaTaskInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMcubeNebulaTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeNebulaTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMcubeNebulaTasksResponseBody(name='body'),
}

async function listMcubeNebulaTasksWithOptions(request: ListMcubeNebulaTasksRequest, runtime: Util.RuntimeOptions): ListMcubeNebulaTasksResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMcubeNebulaTasks',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMcubeNebulaTasks(request: ListMcubeNebulaTasksRequest): ListMcubeNebulaTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeNebulaTasksWithOptions(request, runtime);
}

model ListMcubeUpgradePackagesRequest {
  appId?: string(name='AppId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeUpgradePackagesResponseBody = {
  listPackagesResult?: {
    errorCode?: string(name='ErrorCode'),
    packages?: [ 
      {
        allowCreateTask?: boolean(name='AllowCreateTask'),
        appCode?: string(name='AppCode'),
        appstoreUrl?: string(name='AppstoreUrl'),
        backLog?: string(name='BackLog'),
        changeLog?: string(name='ChangeLog'),
        clientFileSize?: int32(name='ClientFileSize'),
        clientName?: string(name='ClientName'),
        cpId?: string(name='CpId'),
        creator?: string(name='Creator'),
        downloadUrl?: string(name='DownloadUrl'),
        globalVariables?: string(name='GlobalVariables'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateStr?: string(name='GmtCreateStr'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedStr?: string(name='GmtModifiedStr'),
        id?: long(name='Id'),
        innerVersion?: string(name='InnerVersion'),
        iosSymbol?: string(name='IosSymbol'),
        isEnterprise?: int32(name='IsEnterprise'),
        isRc?: int32(name='IsRc'),
        isRelease?: int32(name='IsRelease'),
        maxVersion?: string(name='MaxVersion'),
        md5?: string(name='Md5'),
        modifier?: string(name='Modifier'),
        needCheck?: int32(name='NeedCheck'),
        ossPath?: string(name='OssPath'),
        packageType?: string(name='PackageType'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productName?: string(name='ProductName'),
        productVersion?: string(name='ProductVersion'),
        publishPeriod?: int32(name='PublishPeriod'),
        qrcodeUrl?: string(name='QrcodeUrl'),
        releaseType?: string(name='ReleaseType'),
        releaseWindow?: string(name='ReleaseWindow'),
        scmDownloadUrl?: string(name='ScmDownloadUrl'),
        serverVersion?: int32(name='ServerVersion'),
        verificationCode?: string(name='VerificationCode'),
        verifyResult?: int32(name='VerifyResult'),
        versionCode?: string(name='VersionCode'),
      }
    ](name='Packages'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListPackagesResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeUpgradePackagesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMcubeUpgradePackagesResponseBody(name='body'),
}

async function listMcubeUpgradePackagesWithOptions(request: ListMcubeUpgradePackagesRequest, runtime: Util.RuntimeOptions): ListMcubeUpgradePackagesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMcubeUpgradePackages',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMcubeUpgradePackages(request: ListMcubeUpgradePackagesRequest): ListMcubeUpgradePackagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeUpgradePackagesWithOptions(request, runtime);
}

model ListMcubeUpgradeTasksRequest {
  appId?: string(name='AppId'),
  packageId?: string(name='PackageId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeUpgradeTasksResponseBody = {
  listTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    taskInfo?: [ 
      {
        appCode?: string(name='AppCode'),
        creator?: string(name='Creator'),
        devicePercent?: int32(name='DevicePercent'),
        executionOrder?: int32(name='ExecutionOrder'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateStr?: string(name='GmtCreateStr'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedStr?: string(name='GmtModifiedStr'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtime?: string(name='GreyEndtime'),
        greyNotice?: int32(name='GreyNotice'),
        greyNum?: int32(name='GreyNum'),
        greyPausePoint?: int32(name='GreyPausePoint'),
        greyPauseType?: int32(name='GreyPauseType'),
        greyUv?: int32(name='GreyUv'),
        historyForce?: int32(name='HistoryForce'),
        huobanNoticeId?: string(name='HuobanNoticeId'),
        huobanUrl?: string(name='HuobanUrl'),
        id?: long(name='Id'),
        innerVersion?: string(name='InnerVersion'),
        isEnterprise?: int32(name='IsEnterprise'),
        isOfficial?: int32(name='IsOfficial'),
        isPush?: int32(name='IsPush'),
        isRelease?: int32(name='IsRelease'),
        maxVersion?: string(name='MaxVersion'),
        memo?: string(name='Memo'),
        modifier?: string(name='Modifier'),
        packageInfoId?: long(name='PackageInfoId'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: int32(name='PublishMode'),
        publishType?: int32(name='PublishType'),
        pushContent?: string(name='PushContent'),
        realGreyEndtime?: string(name='RealGreyEndtime'),
        realGreyEndtimeStr?: string(name='RealGreyEndtimeStr'),
        realGreyEndtype?: int32(name='RealGreyEndtype'),
        realGreyNum?: int32(name='RealGreyNum'),
        realGreyUv?: int32(name='RealGreyUv'),
        silentType?: int32(name='SilentType'),
        syncResult?: string(name='SyncResult'),
        taskStatus?: int32(name='TaskStatus'),
        upgradeContent?: string(name='UpgradeContent'),
        upgradeType?: int32(name='UpgradeType'),
        upgradeValidTime?: int32(name='UpgradeValidTime'),
        whitelistIds?: string(name='WhitelistIds'),
      }
    ](name='TaskInfo'),
  }(name='ListTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeUpgradeTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMcubeUpgradeTasksResponseBody(name='body'),
}

async function listMcubeUpgradeTasksWithOptions(request: ListMcubeUpgradeTasksRequest, runtime: Util.RuntimeOptions): ListMcubeUpgradeTasksResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMcubeUpgradeTasks',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMcubeUpgradeTasks(request: ListMcubeUpgradeTasksRequest): ListMcubeUpgradeTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeUpgradeTasksWithOptions(request, runtime);
}

model ListMcubeWhitelistsRequest {
  appId?: string(name='AppId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeWhitelistsResponseBody = {
  listWhitelistResult?: {
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    whitelists?: [ 
      {
        appCode?: string(name='AppCode'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        whiteListCount?: long(name='WhiteListCount'),
        whiteListName?: string(name='WhiteListName'),
        whitelistType?: string(name='WhitelistType'),
      }
    ](name='Whitelists'),
  }(name='ListWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeWhitelistsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMcubeWhitelistsResponseBody(name='body'),
}

async function listMcubeWhitelistsWithOptions(request: ListMcubeWhitelistsRequest, runtime: Util.RuntimeOptions): ListMcubeWhitelistsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMcubeWhitelists',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMcubeWhitelists(request: ListMcubeWhitelistsRequest): ListMcubeWhitelistsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMcubeWhitelistsWithOptions(request, runtime);
}

model ListMgsApiRequest {
  apiStatus?: string(name='ApiStatus'),
  apiType?: string(name='ApiType'),
  appId?: string(name='AppId'),
  format?: string(name='Format'),
  host?: string(name='Host'),
  needEncrypt?: string(name='NeedEncrypt'),
  needEtag?: string(name='NeedEtag'),
  needSign?: string(name='NeedSign'),
  operationType?: string(name='OperationType'),
  optFuzzy?: string(name='OptFuzzy'),
  pageIndex?: long(name='PageIndex'),
  pageSize?: long(name='PageSize'),
  sysId?: long(name='SysId'),
  sysName?: string(name='SysName'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMgsApiResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    errorMessage?: string(name='ErrorMessage'),
    success?: boolean(name='Success'),
    value?: [ 
      {
        apiInvoker?: {
          httpInvoker?: {
            charset?: string(name='Charset'),
            contentType?: string(name='ContentType'),
            host?: string(name='Host'),
            method?: string(name='Method'),
            path?: string(name='Path'),
          }(name='HttpInvoker'),
          rpcInvoker?: string(name='RpcInvoker'),
        }(name='ApiInvoker'),
        apiName?: string(name='ApiName'),
        apiStatus?: string(name='ApiStatus'),
        apiType?: string(name='ApiType'),
        appId?: string(name='AppId'),
        authRuleName?: string(name='AuthRuleName'),
        cacheRule?: {
          cacheKey?: string(name='CacheKey'),
          needCache?: boolean(name='NeedCache'),
          ttl?: long(name='Ttl'),
        }(name='CacheRule'),
        charset?: string(name='Charset'),
        circuitBreakerRule?: {
          appId?: string(name='AppId'),
          defaultResponse?: string(name='DefaultResponse'),
          errorThreshold?: long(name='ErrorThreshold'),
          id?: long(name='Id'),
          model?: string(name='Model'),
          openTimeoutSeconds?: long(name='OpenTimeoutSeconds'),
          slowRatioThreshold?: double(name='SlowRatioThreshold'),
          switchStatus?: string(name='SwitchStatus'),
          windowsInSeconds?: long(name='WindowsInSeconds'),
          workspaceId?: string(name='WorkspaceId'),
        }(name='CircuitBreakerRule'),
        contentType?: string(name='ContentType'),
        description?: string(name='Description'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        headerRule?: [ 
          {
            headerKey?: string(name='HeaderKey'),
            location?: string(name='Location'),
            type?: string(name='Type'),
            value?: string(name='Value'),
          }
        ](name='HeaderRule'),
        headerRules?: [ 
          {
            headerKey?: string(name='HeaderKey'),
            location?: string(name='Location'),
            type?: string(name='Type'),
            value?: string(name='Value'),
          }
        ](name='HeaderRules'),
        host?: string(name='Host'),
        id?: long(name='Id'),
        interfaceType?: string(name='InterfaceType'),
        limitRule?: {
          defaultResponse?: string(name='DefaultResponse'),
          i18nResponse?: string(name='I18nResponse'),
          interval?: long(name='Interval'),
          limit?: long(name='Limit'),
          mode?: string(name='Mode'),
        }(name='LimitRule'),
        method?: string(name='Method'),
        methodName?: string(name='MethodName'),
        migrateRule?: {
          flowPercent?: long(name='FlowPercent'),
          needMigrate?: boolean(name='NeedMigrate'),
          needSwitchCompletely?: boolean(name='NeedSwitchCompletely'),
          sysId?: long(name='SysId'),
          sysName?: string(name='SysName'),
          upstreamType?: string(name='UpstreamType'),
        }(name='MigrateRule'),
        mockRule?: {
          mockData?: string(name='MockData'),
          needMock?: boolean(name='NeedMock'),
          percentage?: long(name='Percentage'),
          type?: string(name='Type'),
        }(name='MockRule'),
        needETag?: string(name='NeedETag'),
        needEncrypt?: string(name='NeedEncrypt'),
        needJsonp?: string(name='NeedJsonp'),
        needSign?: string(name='NeedSign'),
        operationType?: string(name='OperationType'),
        paramGetMethod?: string(name='ParamGetMethod'),
        path?: string(name='Path'),
        requestBodyModel?: string(name='RequestBodyModel'),
        requestParams?: [ 
          {
            apiId?: string(name='ApiId'),
            appId?: string(name='AppId'),
            defaultValue?: string(name='DefaultValue'),
            description?: string(name='Description'),
            id?: long(name='Id'),
            location?: string(name='Location'),
            name?: string(name='Name'),
            refType?: string(name='RefType'),
            type?: string(name='Type'),
            workspaceId?: string(name='WorkspaceId'),
          }
        ](name='RequestParams'),
        responseBodyModel?: string(name='ResponseBodyModel'),
        sysId?: long(name='SysId'),
        sysName?: string(name='SysName'),
        timeout?: string(name='Timeout'),
        workspaceId?: string(name='WorkspaceId'),
      }
    ](name='Value'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMgsApiResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMgsApiResponseBody(name='body'),
}

async function listMgsApiWithOptions(request: ListMgsApiRequest, runtime: Util.RuntimeOptions): ListMgsApiResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apiStatus)) {
    body['ApiStatus'] = request.apiStatus;
  }
  if (!Util.isUnset(request.apiType)) {
    body['ApiType'] = request.apiType;
  }
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.format)) {
    body['Format'] = request.format;
  }
  if (!Util.isUnset(request.host)) {
    body['Host'] = request.host;
  }
  if (!Util.isUnset(request.needEncrypt)) {
    body['NeedEncrypt'] = request.needEncrypt;
  }
  if (!Util.isUnset(request.needEtag)) {
    body['NeedEtag'] = request.needEtag;
  }
  if (!Util.isUnset(request.needSign)) {
    body['NeedSign'] = request.needSign;
  }
  if (!Util.isUnset(request.operationType)) {
    body['OperationType'] = request.operationType;
  }
  if (!Util.isUnset(request.optFuzzy)) {
    body['OptFuzzy'] = request.optFuzzy;
  }
  if (!Util.isUnset(request.pageIndex)) {
    body['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sysId)) {
    body['SysId'] = request.sysId;
  }
  if (!Util.isUnset(request.sysName)) {
    body['SysName'] = request.sysName;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMgsApi',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMgsApi(request: ListMgsApiRequest): ListMgsApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMgsApiWithOptions(request, runtime);
}

model LogMsaQueryRequest {
  appId?: string(name='AppId'),
  id?: string(name='Id'),
  onexFlag?: string(name='OnexFlag'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model LogMsaQueryResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model LogMsaQueryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LogMsaQueryResponseBody(name='body'),
}

async function logMsaQueryWithOptions(request: LogMsaQueryRequest, runtime: Util.RuntimeOptions): LogMsaQueryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'LogMsaQuery',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function logMsaQuery(request: LogMsaQueryRequest): LogMsaQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  return logMsaQueryWithOptions(request, runtime);
}

model OpenApiAddActiveCodeRequest {
  appId?: string(name='AppId'),
  mpaasMqcpOpenApiAddActiveCodeReqJsonStr?: string(name='MpaasMqcpOpenApiAddActiveCodeReqJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model OpenApiAddActiveCodeResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
}

model OpenApiAddActiveCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenApiAddActiveCodeResponseBody(name='body'),
}

async function openApiAddActiveCodeWithOptions(request: OpenApiAddActiveCodeRequest, runtime: Util.RuntimeOptions): OpenApiAddActiveCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMqcpOpenApiAddActiveCodeReqJsonStr)) {
    body['MpaasMqcpOpenApiAddActiveCodeReqJsonStr'] = request.mpaasMqcpOpenApiAddActiveCodeReqJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OpenApiAddActiveCode',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openApiAddActiveCode(request: OpenApiAddActiveCodeRequest): OpenApiAddActiveCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return openApiAddActiveCodeWithOptions(request, runtime);
}

model OpenApiAddActiveSceneRequest {
  appId?: string(name='AppId'),
  mpaasMqcpOpenApiAddActiveSceneReqJsonStr?: string(name='MpaasMqcpOpenApiAddActiveSceneReqJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model OpenApiAddActiveSceneResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
}

model OpenApiAddActiveSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenApiAddActiveSceneResponseBody(name='body'),
}

async function openApiAddActiveSceneWithOptions(request: OpenApiAddActiveSceneRequest, runtime: Util.RuntimeOptions): OpenApiAddActiveSceneResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMqcpOpenApiAddActiveSceneReqJsonStr)) {
    body['MpaasMqcpOpenApiAddActiveSceneReqJsonStr'] = request.mpaasMqcpOpenApiAddActiveSceneReqJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OpenApiAddActiveScene',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openApiAddActiveScene(request: OpenApiAddActiveSceneRequest): OpenApiAddActiveSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return openApiAddActiveSceneWithOptions(request, runtime);
}

model OpenApiCallbackRequest {
  appId?: string(name='AppId'),
  mpaasMqcpOpenApiCallbackRequestJsonStr?: string(name='MpaasMqcpOpenApiCallbackRequestJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model OpenApiCallbackResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
}

model OpenApiCallbackResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenApiCallbackResponseBody(name='body'),
}

async function openApiCallbackWithOptions(request: OpenApiCallbackRequest, runtime: Util.RuntimeOptions): OpenApiCallbackResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMqcpOpenApiCallbackRequestJsonStr)) {
    body['MpaasMqcpOpenApiCallbackRequestJsonStr'] = request.mpaasMqcpOpenApiCallbackRequestJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OpenApiCallback',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openApiCallback(request: OpenApiCallbackRequest): OpenApiCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return openApiCallbackWithOptions(request, runtime);
}

model OpenApiDecodeRequest {
  appId?: string(name='AppId'),
  mpaasMqcpOpenApiDecodeRequestJsonStr?: string(name='MpaasMqcpOpenApiDecodeRequestJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model OpenApiDecodeResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
}

model OpenApiDecodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenApiDecodeResponseBody(name='body'),
}

async function openApiDecodeWithOptions(request: OpenApiDecodeRequest, runtime: Util.RuntimeOptions): OpenApiDecodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMqcpOpenApiDecodeRequestJsonStr)) {
    body['MpaasMqcpOpenApiDecodeRequestJsonStr'] = request.mpaasMqcpOpenApiDecodeRequestJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OpenApiDecode',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openApiDecode(request: OpenApiDecodeRequest): OpenApiDecodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return openApiDecodeWithOptions(request, runtime);
}

model OpenApiDeleteActiveCodeRequest {
  appId?: string(name='AppId'),
  mpaasMqcpOpenApiDeleteActiveCodeReqJsonStr?: string(name='MpaasMqcpOpenApiDeleteActiveCodeReqJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model OpenApiDeleteActiveCodeResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
}

model OpenApiDeleteActiveCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenApiDeleteActiveCodeResponseBody(name='body'),
}

async function openApiDeleteActiveCodeWithOptions(request: OpenApiDeleteActiveCodeRequest, runtime: Util.RuntimeOptions): OpenApiDeleteActiveCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMqcpOpenApiDeleteActiveCodeReqJsonStr)) {
    body['MpaasMqcpOpenApiDeleteActiveCodeReqJsonStr'] = request.mpaasMqcpOpenApiDeleteActiveCodeReqJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OpenApiDeleteActiveCode',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openApiDeleteActiveCode(request: OpenApiDeleteActiveCodeRequest): OpenApiDeleteActiveCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return openApiDeleteActiveCodeWithOptions(request, runtime);
}

model OpenApiEncodeRequest {
  appId?: string(name='AppId'),
  mpaasMqcpOpenApiEncodeRequestJsonStr?: string(name='MpaasMqcpOpenApiEncodeRequestJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model OpenApiEncodeResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
}

model OpenApiEncodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenApiEncodeResponseBody(name='body'),
}

async function openApiEncodeWithOptions(request: OpenApiEncodeRequest, runtime: Util.RuntimeOptions): OpenApiEncodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMqcpOpenApiEncodeRequestJsonStr)) {
    body['MpaasMqcpOpenApiEncodeRequestJsonStr'] = request.mpaasMqcpOpenApiEncodeRequestJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OpenApiEncode',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openApiEncode(request: OpenApiEncodeRequest): OpenApiEncodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return openApiEncodeWithOptions(request, runtime);
}

model OpenApiQueryActiveCodeRequest {
  appId?: string(name='AppId'),
  mpaasMqcpOpenApiQueryActiveCodeReqJsonStr?: string(name='MpaasMqcpOpenApiQueryActiveCodeReqJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model OpenApiQueryActiveCodeResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model OpenApiQueryActiveCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenApiQueryActiveCodeResponseBody(name='body'),
}

async function openApiQueryActiveCodeWithOptions(request: OpenApiQueryActiveCodeRequest, runtime: Util.RuntimeOptions): OpenApiQueryActiveCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMqcpOpenApiQueryActiveCodeReqJsonStr)) {
    body['MpaasMqcpOpenApiQueryActiveCodeReqJsonStr'] = request.mpaasMqcpOpenApiQueryActiveCodeReqJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OpenApiQueryActiveCode',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openApiQueryActiveCode(request: OpenApiQueryActiveCodeRequest): OpenApiQueryActiveCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return openApiQueryActiveCodeWithOptions(request, runtime);
}

model OpenApiQueryActiveSceneRequest {
  appId?: string(name='AppId'),
  mpaasMqcpOpenApiQueryActiveSceneReqJsonStr?: string(name='MpaasMqcpOpenApiQueryActiveSceneReqJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model OpenApiQueryActiveSceneResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
}

model OpenApiQueryActiveSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenApiQueryActiveSceneResponseBody(name='body'),
}

async function openApiQueryActiveSceneWithOptions(request: OpenApiQueryActiveSceneRequest, runtime: Util.RuntimeOptions): OpenApiQueryActiveSceneResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMqcpOpenApiQueryActiveSceneReqJsonStr)) {
    body['MpaasMqcpOpenApiQueryActiveSceneReqJsonStr'] = request.mpaasMqcpOpenApiQueryActiveSceneReqJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OpenApiQueryActiveScene',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openApiQueryActiveScene(request: OpenApiQueryActiveSceneRequest): OpenApiQueryActiveSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return openApiQueryActiveSceneWithOptions(request, runtime);
}

model OpenApiUniqueEncodeRequest {
  appId?: string(name='AppId'),
  mpaasMqcpOpenApiUniqueEncodeRequestJsonStr?: string(name='MpaasMqcpOpenApiUniqueEncodeRequestJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model OpenApiUniqueEncodeResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
}

model OpenApiUniqueEncodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenApiUniqueEncodeResponseBody(name='body'),
}

async function openApiUniqueEncodeWithOptions(request: OpenApiUniqueEncodeRequest, runtime: Util.RuntimeOptions): OpenApiUniqueEncodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMqcpOpenApiUniqueEncodeRequestJsonStr)) {
    body['MpaasMqcpOpenApiUniqueEncodeRequestJsonStr'] = request.mpaasMqcpOpenApiUniqueEncodeRequestJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OpenApiUniqueEncode',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openApiUniqueEncode(request: OpenApiUniqueEncodeRequest): OpenApiUniqueEncodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return openApiUniqueEncodeWithOptions(request, runtime);
}

model OpenApiUpdateActiveCodeRequest {
  appId?: string(name='AppId'),
  mpaasMqcpOpenApiUpdateActiveCodeReqJsonStr?: string(name='MpaasMqcpOpenApiUpdateActiveCodeReqJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model OpenApiUpdateActiveCodeResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
}

model OpenApiUpdateActiveCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenApiUpdateActiveCodeResponseBody(name='body'),
}

async function openApiUpdateActiveCodeWithOptions(request: OpenApiUpdateActiveCodeRequest, runtime: Util.RuntimeOptions): OpenApiUpdateActiveCodeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMqcpOpenApiUpdateActiveCodeReqJsonStr)) {
    body['MpaasMqcpOpenApiUpdateActiveCodeReqJsonStr'] = request.mpaasMqcpOpenApiUpdateActiveCodeReqJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OpenApiUpdateActiveCode',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openApiUpdateActiveCode(request: OpenApiUpdateActiveCodeRequest): OpenApiUpdateActiveCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return openApiUpdateActiveCodeWithOptions(request, runtime);
}

model OpenApiUpdateActiveSceneRequest {
  appId?: string(name='AppId'),
  mpaasMqcpOpenApiUpdateActiveSceneReqJsonStr?: string(name='MpaasMqcpOpenApiUpdateActiveSceneReqJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model OpenApiUpdateActiveSceneResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
}

model OpenApiUpdateActiveSceneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenApiUpdateActiveSceneResponseBody(name='body'),
}

async function openApiUpdateActiveSceneWithOptions(request: OpenApiUpdateActiveSceneRequest, runtime: Util.RuntimeOptions): OpenApiUpdateActiveSceneResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMqcpOpenApiUpdateActiveSceneReqJsonStr)) {
    body['MpaasMqcpOpenApiUpdateActiveSceneReqJsonStr'] = request.mpaasMqcpOpenApiUpdateActiveSceneReqJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OpenApiUpdateActiveScene',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openApiUpdateActiveScene(request: OpenApiUpdateActiveSceneRequest): OpenApiUpdateActiveSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  return openApiUpdateActiveSceneWithOptions(request, runtime);
}

model PushBindRequest {
  appId?: string(name='AppId'),
  deliveryToken?: string(name='DeliveryToken'),
  osType?: int32(name='OsType'),
  phoneNumber?: string(name='PhoneNumber'),
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model PushBindResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushBindResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PushBindResponseBody(name='body'),
}

async function pushBindWithOptions(request: PushBindRequest, runtime: Util.RuntimeOptions): PushBindResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.deliveryToken)) {
    body['DeliveryToken'] = request.deliveryToken;
  }
  if (!Util.isUnset(request.osType)) {
    body['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.phoneNumber)) {
    body['PhoneNumber'] = request.phoneNumber;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PushBind',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pushBind(request: PushBindRequest): PushBindResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushBindWithOptions(request, runtime);
}

model PushBroadcastRequest {
  androidChannel?: int32(name='AndroidChannel'),
  appId?: string(name='AppId'),
  bindPeriod?: int32(name='BindPeriod'),
  classification?: string(name='Classification'),
  deliveryType?: long(name='DeliveryType'),
  expiredSeconds?: long(name='ExpiredSeconds'),
  extendedParams?: string(name='ExtendedParams'),
  msgkey?: string(name='Msgkey'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  pushStatus?: long(name='PushStatus'),
  silent?: long(name='Silent'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  taskName?: string(name='TaskName'),
  templateKeyValue?: string(name='TemplateKeyValue'),
  templateName?: string(name='TemplateName'),
  unBindPeriod?: long(name='UnBindPeriod'),
  workspaceId?: string(name='WorkspaceId'),
}

model PushBroadcastResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushBroadcastResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PushBroadcastResponseBody(name='body'),
}

async function pushBroadcastWithOptions(request: PushBroadcastRequest, runtime: Util.RuntimeOptions): PushBroadcastResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.androidChannel)) {
    body['AndroidChannel'] = request.androidChannel;
  }
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.bindPeriod)) {
    body['BindPeriod'] = request.bindPeriod;
  }
  if (!Util.isUnset(request.classification)) {
    body['Classification'] = request.classification;
  }
  if (!Util.isUnset(request.deliveryType)) {
    body['DeliveryType'] = request.deliveryType;
  }
  if (!Util.isUnset(request.expiredSeconds)) {
    body['ExpiredSeconds'] = request.expiredSeconds;
  }
  if (!Util.isUnset(request.extendedParams)) {
    body['ExtendedParams'] = request.extendedParams;
  }
  if (!Util.isUnset(request.msgkey)) {
    body['Msgkey'] = request.msgkey;
  }
  if (!Util.isUnset(request.notifyType)) {
    body['NotifyType'] = request.notifyType;
  }
  if (!Util.isUnset(request.pushAction)) {
    body['PushAction'] = request.pushAction;
  }
  if (!Util.isUnset(request.pushStatus)) {
    body['PushStatus'] = request.pushStatus;
  }
  if (!Util.isUnset(request.silent)) {
    body['Silent'] = request.silent;
  }
  if (!Util.isUnset(request.strategyContent)) {
    body['StrategyContent'] = request.strategyContent;
  }
  if (!Util.isUnset(request.strategyType)) {
    body['StrategyType'] = request.strategyType;
  }
  if (!Util.isUnset(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.templateKeyValue)) {
    body['TemplateKeyValue'] = request.templateKeyValue;
  }
  if (!Util.isUnset(request.templateName)) {
    body['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.unBindPeriod)) {
    body['UnBindPeriod'] = request.unBindPeriod;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PushBroadcast',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pushBroadcast(request: PushBroadcastRequest): PushBroadcastResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushBroadcastWithOptions(request, runtime);
}

model PushMultipleRequest {
  appId?: string(name='AppId'),
  classification?: string(name='Classification'),
  deliveryType?: long(name='DeliveryType'),
  expiredSeconds?: long(name='ExpiredSeconds'),
  extendedParams?: string(name='ExtendedParams'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  silent?: long(name='Silent'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  targetMsg?: [ 
    {
      extendedParams?: string(name='ExtendedParams'),
      msgKey?: string(name='MsgKey'),
      target?: string(name='Target'),
      templateKeyValue?: string(name='TemplateKeyValue'),
    }
  ](name='TargetMsg'),
  taskName?: string(name='TaskName'),
  templateName?: string(name='TemplateName'),
  workspaceId?: string(name='WorkspaceId'),
}

model PushMultipleResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushMultipleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PushMultipleResponseBody(name='body'),
}

async function pushMultipleWithOptions(request: PushMultipleRequest, runtime: Util.RuntimeOptions): PushMultipleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.classification)) {
    body['Classification'] = request.classification;
  }
  if (!Util.isUnset(request.deliveryType)) {
    body['DeliveryType'] = request.deliveryType;
  }
  if (!Util.isUnset(request.expiredSeconds)) {
    body['ExpiredSeconds'] = request.expiredSeconds;
  }
  if (!Util.isUnset(request.extendedParams)) {
    body['ExtendedParams'] = request.extendedParams;
  }
  if (!Util.isUnset(request.notifyType)) {
    body['NotifyType'] = request.notifyType;
  }
  if (!Util.isUnset(request.pushAction)) {
    body['PushAction'] = request.pushAction;
  }
  if (!Util.isUnset(request.silent)) {
    body['Silent'] = request.silent;
  }
  if (!Util.isUnset(request.strategyContent)) {
    body['StrategyContent'] = request.strategyContent;
  }
  if (!Util.isUnset(request.strategyType)) {
    body['StrategyType'] = request.strategyType;
  }
  if (!Util.isUnset(request.targetMsg)) {
    body['TargetMsg'] = request.targetMsg;
  }
  if (!Util.isUnset(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.templateName)) {
    body['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PushMultiple',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pushMultiple(request: PushMultipleRequest): PushMultipleResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushMultipleWithOptions(request, runtime);
}

model PushReportRequest {
  appId?: string(name='AppId'),
  appVersion?: string(name='AppVersion'),
  channel?: string(name='Channel'),
  connectType?: string(name='ConnectType'),
  deliveryToken?: string(name='DeliveryToken'),
  imei?: string(name='Imei'),
  imsi?: string(name='Imsi'),
  model?: string(name='Model'),
  osType?: int32(name='OsType'),
  pushVersion?: string(name='PushVersion'),
  thirdChannel?: int32(name='ThirdChannel'),
  thirdChannelDeviceToken?: string(name='ThirdChannelDeviceToken'),
  workspaceId?: string(name='WorkspaceId'),
}

model PushReportResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PushReportResponseBody(name='body'),
}

async function pushReportWithOptions(request: PushReportRequest, runtime: Util.RuntimeOptions): PushReportResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersion)) {
    body['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.channel)) {
    body['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.connectType)) {
    body['ConnectType'] = request.connectType;
  }
  if (!Util.isUnset(request.deliveryToken)) {
    body['DeliveryToken'] = request.deliveryToken;
  }
  if (!Util.isUnset(request.imei)) {
    body['Imei'] = request.imei;
  }
  if (!Util.isUnset(request.imsi)) {
    body['Imsi'] = request.imsi;
  }
  if (!Util.isUnset(request.model)) {
    body['Model'] = request.model;
  }
  if (!Util.isUnset(request.osType)) {
    body['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.pushVersion)) {
    body['PushVersion'] = request.pushVersion;
  }
  if (!Util.isUnset(request.thirdChannel)) {
    body['ThirdChannel'] = request.thirdChannel;
  }
  if (!Util.isUnset(request.thirdChannelDeviceToken)) {
    body['ThirdChannelDeviceToken'] = request.thirdChannelDeviceToken;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PushReport',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pushReport(request: PushReportRequest): PushReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushReportWithOptions(request, runtime);
}

model PushSimpleRequest {
  appId?: string(name='AppId'),
  classification?: string(name='Classification'),
  content?: string(name='Content'),
  deliveryType?: long(name='DeliveryType'),
  expiredSeconds?: long(name='ExpiredSeconds'),
  extendedParams?: string(name='ExtendedParams'),
  iconUrls?: string(name='IconUrls'),
  imageUrls?: string(name='ImageUrls'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  pushStyle?: int32(name='PushStyle'),
  silent?: long(name='Silent'),
  smsSignName?: string(name='SmsSignName'),
  smsStrategy?: int32(name='SmsStrategy'),
  smsTemplateCode?: string(name='SmsTemplateCode'),
  smsTemplateParam?: string(name='SmsTemplateParam'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  targetMsgkey?: string(name='TargetMsgkey'),
  taskName?: string(name='TaskName'),
  title?: string(name='Title'),
  uri?: string(name='Uri'),
  workspaceId?: string(name='WorkspaceId'),
}

model PushSimpleResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushSimpleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PushSimpleResponseBody(name='body'),
}

async function pushSimpleWithOptions(request: PushSimpleRequest, runtime: Util.RuntimeOptions): PushSimpleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.classification)) {
    body['Classification'] = request.classification;
  }
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.deliveryType)) {
    body['DeliveryType'] = request.deliveryType;
  }
  if (!Util.isUnset(request.expiredSeconds)) {
    body['ExpiredSeconds'] = request.expiredSeconds;
  }
  if (!Util.isUnset(request.extendedParams)) {
    body['ExtendedParams'] = request.extendedParams;
  }
  if (!Util.isUnset(request.iconUrls)) {
    body['IconUrls'] = request.iconUrls;
  }
  if (!Util.isUnset(request.imageUrls)) {
    body['ImageUrls'] = request.imageUrls;
  }
  if (!Util.isUnset(request.notifyType)) {
    body['NotifyType'] = request.notifyType;
  }
  if (!Util.isUnset(request.pushAction)) {
    body['PushAction'] = request.pushAction;
  }
  if (!Util.isUnset(request.pushStyle)) {
    body['PushStyle'] = request.pushStyle;
  }
  if (!Util.isUnset(request.silent)) {
    body['Silent'] = request.silent;
  }
  if (!Util.isUnset(request.smsSignName)) {
    body['SmsSignName'] = request.smsSignName;
  }
  if (!Util.isUnset(request.smsStrategy)) {
    body['SmsStrategy'] = request.smsStrategy;
  }
  if (!Util.isUnset(request.smsTemplateCode)) {
    body['SmsTemplateCode'] = request.smsTemplateCode;
  }
  if (!Util.isUnset(request.smsTemplateParam)) {
    body['SmsTemplateParam'] = request.smsTemplateParam;
  }
  if (!Util.isUnset(request.strategyContent)) {
    body['StrategyContent'] = request.strategyContent;
  }
  if (!Util.isUnset(request.strategyType)) {
    body['StrategyType'] = request.strategyType;
  }
  if (!Util.isUnset(request.targetMsgkey)) {
    body['TargetMsgkey'] = request.targetMsgkey;
  }
  if (!Util.isUnset(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  if (!Util.isUnset(request.uri)) {
    body['Uri'] = request.uri;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PushSimple',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pushSimple(request: PushSimpleRequest): PushSimpleResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushSimpleWithOptions(request, runtime);
}

model PushTemplateRequest {
  appId?: string(name='AppId'),
  classification?: string(name='Classification'),
  deliveryType?: long(name='DeliveryType'),
  expiredSeconds?: long(name='ExpiredSeconds'),
  extendedParams?: string(name='ExtendedParams'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  silent?: long(name='Silent'),
  smsSignName?: string(name='SmsSignName'),
  smsStrategy?: int32(name='SmsStrategy'),
  smsTemplateCode?: string(name='SmsTemplateCode'),
  smsTemplateParam?: string(name='SmsTemplateParam'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  targetMsgkey?: string(name='TargetMsgkey'),
  taskName?: string(name='TaskName'),
  templateKeyValue?: string(name='TemplateKeyValue'),
  templateName?: string(name='TemplateName'),
  workspaceId?: string(name='WorkspaceId'),
}

model PushTemplateResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PushTemplateResponseBody(name='body'),
}

async function pushTemplateWithOptions(request: PushTemplateRequest, runtime: Util.RuntimeOptions): PushTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.classification)) {
    body['Classification'] = request.classification;
  }
  if (!Util.isUnset(request.deliveryType)) {
    body['DeliveryType'] = request.deliveryType;
  }
  if (!Util.isUnset(request.expiredSeconds)) {
    body['ExpiredSeconds'] = request.expiredSeconds;
  }
  if (!Util.isUnset(request.extendedParams)) {
    body['ExtendedParams'] = request.extendedParams;
  }
  if (!Util.isUnset(request.notifyType)) {
    body['NotifyType'] = request.notifyType;
  }
  if (!Util.isUnset(request.pushAction)) {
    body['PushAction'] = request.pushAction;
  }
  if (!Util.isUnset(request.silent)) {
    body['Silent'] = request.silent;
  }
  if (!Util.isUnset(request.smsSignName)) {
    body['SmsSignName'] = request.smsSignName;
  }
  if (!Util.isUnset(request.smsStrategy)) {
    body['SmsStrategy'] = request.smsStrategy;
  }
  if (!Util.isUnset(request.smsTemplateCode)) {
    body['SmsTemplateCode'] = request.smsTemplateCode;
  }
  if (!Util.isUnset(request.smsTemplateParam)) {
    body['SmsTemplateParam'] = request.smsTemplateParam;
  }
  if (!Util.isUnset(request.strategyContent)) {
    body['StrategyContent'] = request.strategyContent;
  }
  if (!Util.isUnset(request.strategyType)) {
    body['StrategyType'] = request.strategyType;
  }
  if (!Util.isUnset(request.targetMsgkey)) {
    body['TargetMsgkey'] = request.targetMsgkey;
  }
  if (!Util.isUnset(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.templateKeyValue)) {
    body['TemplateKeyValue'] = request.templateKeyValue;
  }
  if (!Util.isUnset(request.templateName)) {
    body['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PushTemplate',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pushTemplate(request: PushTemplateRequest): PushTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushTemplateWithOptions(request, runtime);
}

model PushUnBindRequest {
  appId?: string(name='AppId'),
  deliveryToken?: string(name='DeliveryToken'),
  userId?: string(name='UserId'),
  workspaceId?: string(name='WorkspaceId'),
}

model PushUnBindResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushUnBindResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PushUnBindResponseBody(name='body'),
}

async function pushUnBindWithOptions(request: PushUnBindRequest, runtime: Util.RuntimeOptions): PushUnBindResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.deliveryToken)) {
    body['DeliveryToken'] = request.deliveryToken;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PushUnBind',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pushUnBind(request: PushUnBindRequest): PushUnBindResponse {
  var runtime = new Util.RuntimeOptions{};
  return pushUnBindWithOptions(request, runtime);
}

model QueryMappCenterAppRequest {
  appId?: string(name='AppId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMappCenterAppResponseBody = {
  queryMappCenterAppResult?: {
    mappCenterApp?: {
      androidConfig?: {
        certRSA?: string(name='CertRSA'),
        packageName?: string(name='PackageName'),
      }(name='AndroidConfig'),
      appDesc?: string(name='AppDesc'),
      appIcon?: string(name='AppIcon'),
      appId?: string(name='AppId'),
      appName?: string(name='AppName'),
      appSecret?: string(name='AppSecret'),
      creator?: string(name='Creator'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
      iosConfig?: {
        bundleId?: string(name='BundleId'),
      }(name='IosConfig'),
      modifier?: string(name='Modifier'),
      monitorJson?: string(name='MonitorJson'),
      status?: long(name='Status'),
      tenantId?: string(name='TenantId'),
      type?: long(name='Type'),
    }(name='MappCenterApp'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryMappCenterAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMappCenterAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMappCenterAppResponseBody(name='body'),
}

async function queryMappCenterAppWithOptions(request: QueryMappCenterAppRequest, runtime: Util.RuntimeOptions): QueryMappCenterAppResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryMappCenterApp',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMappCenterApp(request: QueryMappCenterAppRequest): QueryMappCenterAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMappCenterAppWithOptions(request, runtime);
}

model QueryMcdpAimRequest {
  appId?: string(name='AppId'),
  id?: long(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMcdpAimResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcdpAimResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMcdpAimResponseBody(name='body'),
}

async function queryMcdpAimWithOptions(request: QueryMcdpAimRequest, runtime: Util.RuntimeOptions): QueryMcdpAimResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryMcdpAim',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMcdpAim(request: QueryMcdpAimRequest): QueryMcdpAimResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMcdpAimWithOptions(request, runtime);
}

model QueryMcdpZoneRequest {
  appId?: string(name='AppId'),
  id?: long(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMcdpZoneResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcdpZoneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMcdpZoneResponseBody(name='body'),
}

async function queryMcdpZoneWithOptions(request: QueryMcdpZoneRequest, runtime: Util.RuntimeOptions): QueryMcdpZoneResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryMcdpZone',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMcdpZone(request: QueryMcdpZoneRequest): QueryMcdpZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMcdpZoneWithOptions(request, runtime);
}

model QueryMcubeMiniPackageRequest {
  appId?: string(name='AppId'),
  h5Id?: string(name='H5Id'),
  id?: string(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMcubeMiniPackageResponseBody = {
  queryMiniPackageResult?: {
    miniPackageInfo?: {
      appCode?: string(name='AppCode'),
      autoInstall?: long(name='AutoInstall'),
      clientVersionMax?: string(name='ClientVersionMax'),
      clientVersionMin?: string(name='ClientVersionMin'),
      downloadUrl?: string(name='DownloadUrl'),
      extendInfo?: string(name='ExtendInfo'),
      extraData?: string(name='ExtraData'),
      fallbackBaseUrl?: string(name='FallbackBaseUrl'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      h5Id?: string(name='H5Id'),
      h5Name?: string(name='H5Name'),
      h5Version?: string(name='H5Version'),
      id?: long(name='Id'),
      installType?: long(name='InstallType'),
      mainUrl?: string(name='MainUrl'),
      memo?: string(name='Memo'),
      packageType?: long(name='PackageType'),
      platform?: string(name='Platform'),
      publishPeriod?: long(name='PublishPeriod'),
      resourceType?: long(name='ResourceType'),
      status?: long(name='Status'),
    }(name='MiniPackageInfo'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryMiniPackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcubeMiniPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMcubeMiniPackageResponseBody(name='body'),
}

async function queryMcubeMiniPackageWithOptions(request: QueryMcubeMiniPackageRequest, runtime: Util.RuntimeOptions): QueryMcubeMiniPackageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryMcubeMiniPackage',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMcubeMiniPackage(request: QueryMcubeMiniPackageRequest): QueryMcubeMiniPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMcubeMiniPackageWithOptions(request, runtime);
}

model QueryMcubeMiniTaskRequest {
  appId?: string(name='AppId'),
  taskId?: long(name='TaskId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMcubeMiniTaskResponseBody = {
  queryMiniTaskResult?: {
    miniTaskInfo?: {
      appCode?: string(name='AppCode'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      greyConfigInfo?: string(name='GreyConfigInfo'),
      greyEndtime?: string(name='GreyEndtime'),
      greyEndtimeData?: string(name='GreyEndtimeData'),
      greyNum?: long(name='GreyNum'),
      id?: long(name='Id'),
      memo?: string(name='Memo'),
      packageId?: long(name='PackageId'),
      platform?: string(name='Platform'),
      productVersion?: string(name='ProductVersion'),
      publishMode?: long(name='PublishMode'),
      publishType?: long(name='PublishType'),
      status?: string(name='Status'),
      taskStatus?: long(name='TaskStatus'),
      whitelistIds?: string(name='WhitelistIds'),
    }(name='MiniTaskInfo'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryMiniTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcubeMiniTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMcubeMiniTaskResponseBody(name='body'),
}

async function queryMcubeMiniTaskWithOptions(request: QueryMcubeMiniTaskRequest, runtime: Util.RuntimeOptions): QueryMcubeMiniTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryMcubeMiniTask',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMcubeMiniTask(request: QueryMcubeMiniTaskRequest): QueryMcubeMiniTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMcubeMiniTaskWithOptions(request, runtime);
}

model QueryMcubeVhostRequest {
  appId?: string(name='AppId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMcubeVhostResponseBody = {
  queryVhostResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryVhostResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcubeVhostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMcubeVhostResponseBody(name='body'),
}

async function queryMcubeVhostWithOptions(request: QueryMcubeVhostRequest, runtime: Util.RuntimeOptions): QueryMcubeVhostResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryMcubeVhost',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMcubeVhost(request: QueryMcubeVhostRequest): QueryMcubeVhostResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMcubeVhostWithOptions(request, runtime);
}

model QueryMdsUpgradeTaskDetailRequest {
  appId?: string(name='AppId'),
  taskId?: long(name='TaskId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMdsUpgradeTaskDetailResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: {
        appCode?: string(name='AppCode'),
        appId?: string(name='AppId'),
        appstoreurl?: string(name='Appstoreurl'),
        channelContains?: string(name='ChannelContains'),
        channelExcludes?: string(name='ChannelExcludes'),
        cityContains?: string(name='CityContains'),
        cityExcludes?: string(name='CityExcludes'),
        creator?: string(name='Creator'),
        deviceGreyNum?: long(name='DeviceGreyNum'),
        devicePercent?: long(name='DevicePercent'),
        downloadUrl?: string(name='DownloadUrl'),
        executionOrder?: long(name='ExecutionOrder'),
        gmtCreateStr?: string(name='GmtCreateStr'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtimeData?: string(name='GreyEndtimeData'),
        greyNotice?: long(name='GreyNotice'),
        greyNum?: long(name='GreyNum'),
        greyUv?: long(name='GreyUv'),
        id?: long(name='Id'),
        innerVersion?: string(name='InnerVersion'),
        isEnterprise?: long(name='IsEnterprise'),
        isOfficial?: long(name='IsOfficial'),
        isPush?: long(name='IsPush'),
        isRc?: long(name='IsRc'),
        isRelease?: long(name='IsRelease'),
        memo?: string(name='Memo'),
        mobileModelContains?: string(name='MobileModelContains'),
        mobileModelExcludes?: string(name='MobileModelExcludes'),
        modifier?: string(name='Modifier'),
        netType?: string(name='NetType'),
        osVersion?: string(name='OsVersion'),
        packageInfoId?: long(name='PackageInfoId'),
        packageType?: string(name='PackageType'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: long(name='PublishMode'),
        publishType?: long(name='PublishType'),
        pushContent?: string(name='PushContent'),
        qrcodeUrl?: string(name='QrcodeUrl'),
        releaseType?: string(name='ReleaseType'),
        ruleJsonList?: [ 
          {
            operation?: string(name='Operation'),
            ruleElement?: string(name='RuleElement'),
            ruleType?: string(name='RuleType'),
            value?: string(name='Value'),
          }
        ](name='RuleJsonList'),
        silentType?: long(name='SilentType'),
        syncMode?: string(name='SyncMode'),
        syncResult?: string(name='SyncResult'),
        taskStatus?: long(name='TaskStatus'),
        upgradeContent?: string(name='UpgradeContent'),
        upgradeType?: long(name='UpgradeType'),
        upgradeValidTime?: long(name='UpgradeValidTime'),
        whitelist?: [ 
          {
            appCode?: string(name='AppCode'),
            business?: string(name='Business'),
            gmtModified?: string(name='GmtModified'),
            id?: long(name='Id'),
            idType?: string(name='IdType'),
            platform?: string(name='Platform'),
            status?: long(name='Status'),
            whiteListCount?: long(name='WhiteListCount'),
            whiteListName?: string(name='WhiteListName'),
          }
        ](name='Whitelist'),
        whitelistIds?: string(name='WhitelistIds'),
      }(name='Content'),
      errorCode?: string(name='ErrorCode'),
      requestId?: string(name='RequestId'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMdsUpgradeTaskDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMdsUpgradeTaskDetailResponseBody(name='body'),
}

async function queryMdsUpgradeTaskDetailWithOptions(request: QueryMdsUpgradeTaskDetailRequest, runtime: Util.RuntimeOptions): QueryMdsUpgradeTaskDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryMdsUpgradeTaskDetail',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMdsUpgradeTaskDetail(request: QueryMdsUpgradeTaskDetailRequest): QueryMdsUpgradeTaskDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMdsUpgradeTaskDetailWithOptions(request, runtime);
}

model QueryMgsApipageRequest {
  apiStatus?: string(name='ApiStatus'),
  apiType?: string(name='ApiType'),
  appId?: string(name='AppId'),
  format?: string(name='Format'),
  host?: string(name='Host'),
  needEncrypt?: string(name='NeedEncrypt'),
  needEtag?: string(name='NeedEtag'),
  needSign?: string(name='NeedSign'),
  operationType?: string(name='OperationType'),
  optFuzzy?: string(name='OptFuzzy'),
  pageIndex?: long(name='PageIndex'),
  pageSize?: long(name='PageSize'),
  sysId?: long(name='SysId'),
  sysName?: string(name='SysName'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMgsApipageResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    current?: long(name='Current'),
    list?: [ 
      {
        apiInvoker?: {
          httpInvoker?: {
            charset?: string(name='Charset'),
            contentType?: string(name='ContentType'),
            host?: string(name='Host'),
            method?: string(name='Method'),
            path?: string(name='Path'),
          }(name='HttpInvoker'),
          rpcInvoker?: string(name='RpcInvoker'),
        }(name='ApiInvoker'),
        apiName?: string(name='ApiName'),
        apiStatus?: string(name='ApiStatus'),
        apiType?: string(name='ApiType'),
        appId?: string(name='AppId'),
        authRuleName?: string(name='AuthRuleName'),
        cacheRule?: {
          cacheKey?: string(name='CacheKey'),
          needCache?: boolean(name='NeedCache'),
          ttl?: long(name='Ttl'),
        }(name='CacheRule'),
        charset?: string(name='Charset'),
        circuitBreakerRule?: {
          appId?: string(name='AppId'),
          defaultResponse?: string(name='DefaultResponse'),
          errorThreshold?: long(name='ErrorThreshold'),
          id?: long(name='Id'),
          model?: string(name='Model'),
          openTimeoutSeconds?: long(name='OpenTimeoutSeconds'),
          slowRatioThreshold?: double(name='SlowRatioThreshold'),
          switchStatus?: string(name='SwitchStatus'),
          windowsInSeconds?: long(name='WindowsInSeconds'),
          workspaceId?: string(name='WorkspaceId'),
        }(name='CircuitBreakerRule'),
        contentType?: string(name='ContentType'),
        description?: string(name='Description'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        headerRule?: [ 
          {
            headerKey?: string(name='HeaderKey'),
            location?: string(name='Location'),
            type?: string(name='Type'),
            value?: string(name='Value'),
          }
        ](name='HeaderRule'),
        headerRules?: [ 
          {
            headerKey?: string(name='HeaderKey'),
            location?: string(name='Location'),
            type?: string(name='Type'),
            value?: string(name='Value'),
          }
        ](name='HeaderRules'),
        host?: string(name='Host'),
        id?: long(name='Id'),
        interfaceType?: string(name='InterfaceType'),
        limitRule?: {
          defaultResponse?: string(name='DefaultResponse'),
          i18nResponse?: string(name='I18nResponse'),
          interval?: long(name='Interval'),
          limit?: long(name='Limit'),
          mode?: string(name='Mode'),
        }(name='LimitRule'),
        method?: string(name='Method'),
        methodName?: string(name='MethodName'),
        migrateRule?: {
          flowPercent?: long(name='FlowPercent'),
          needMigrate?: boolean(name='NeedMigrate'),
          needSwitchCompletely?: boolean(name='NeedSwitchCompletely'),
          sysId?: long(name='SysId'),
          sysName?: string(name='SysName'),
          upstreamType?: string(name='UpstreamType'),
        }(name='MigrateRule'),
        mockRule?: {
          mockData?: string(name='MockData'),
          needMock?: boolean(name='NeedMock'),
          percentage?: long(name='Percentage'),
          type?: string(name='Type'),
        }(name='MockRule'),
        needETag?: string(name='NeedETag'),
        needEncrypt?: string(name='NeedEncrypt'),
        needJsonp?: string(name='NeedJsonp'),
        needSign?: string(name='NeedSign'),
        operationType?: string(name='OperationType'),
        paramGetMethod?: string(name='ParamGetMethod'),
        path?: string(name='Path'),
        requestBodyModel?: string(name='RequestBodyModel'),
        requestParams?: [ 
          {
            apiId?: string(name='ApiId'),
            appId?: string(name='AppId'),
            defaultValue?: string(name='DefaultValue'),
            description?: string(name='Description'),
            id?: long(name='Id'),
            location?: string(name='Location'),
            name?: string(name='Name'),
            refType?: string(name='RefType'),
            type?: string(name='Type'),
            workspaceId?: string(name='WorkspaceId'),
          }
        ](name='RequestParams'),
        responseBodyModel?: string(name='ResponseBodyModel'),
        sysId?: long(name='SysId'),
        sysName?: string(name='SysName'),
        timeout?: string(name='Timeout'),
        workspaceId?: string(name='WorkspaceId'),
      }
    ](name='List'),
    pageSize?: long(name='PageSize'),
    total?: long(name='Total'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMgsApipageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMgsApipageResponseBody(name='body'),
}

async function queryMgsApipageWithOptions(request: QueryMgsApipageRequest, runtime: Util.RuntimeOptions): QueryMgsApipageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apiStatus)) {
    body['ApiStatus'] = request.apiStatus;
  }
  if (!Util.isUnset(request.apiType)) {
    body['ApiType'] = request.apiType;
  }
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.format)) {
    body['Format'] = request.format;
  }
  if (!Util.isUnset(request.host)) {
    body['Host'] = request.host;
  }
  if (!Util.isUnset(request.needEncrypt)) {
    body['NeedEncrypt'] = request.needEncrypt;
  }
  if (!Util.isUnset(request.needEtag)) {
    body['NeedEtag'] = request.needEtag;
  }
  if (!Util.isUnset(request.needSign)) {
    body['NeedSign'] = request.needSign;
  }
  if (!Util.isUnset(request.operationType)) {
    body['OperationType'] = request.operationType;
  }
  if (!Util.isUnset(request.optFuzzy)) {
    body['OptFuzzy'] = request.optFuzzy;
  }
  if (!Util.isUnset(request.pageIndex)) {
    body['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sysId)) {
    body['SysId'] = request.sysId;
  }
  if (!Util.isUnset(request.sysName)) {
    body['SysName'] = request.sysName;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryMgsApipage',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMgsApipage(request: QueryMgsApipageRequest): QueryMgsApipageResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMgsApipageWithOptions(request, runtime);
}

model QueryMgsApirestRequest {
  appId?: string(name='AppId'),
  format?: string(name='Format'),
  id?: long(name='Id'),
  tenantId?: string(name='TenantId'),
  type?: string(name='Type'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMgsApirestResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    errorMessage?: string(name='ErrorMessage'),
    success?: boolean(name='Success'),
    value?: {
      apiInvoker?: {
        httpInvoker?: {
          charset?: string(name='Charset'),
          contentType?: string(name='ContentType'),
          host?: string(name='Host'),
          method?: string(name='Method'),
          path?: string(name='Path'),
        }(name='HttpInvoker'),
        rpcInvoker?: string(name='RpcInvoker'),
      }(name='ApiInvoker'),
      apiName?: string(name='ApiName'),
      apiStatus?: string(name='ApiStatus'),
      apiType?: string(name='ApiType'),
      appId?: string(name='AppId'),
      authRuleName?: string(name='AuthRuleName'),
      cacheRule?: {
        cacheKey?: string(name='CacheKey'),
        needCache?: boolean(name='NeedCache'),
        ttl?: long(name='Ttl'),
      }(name='CacheRule'),
      charset?: string(name='Charset'),
      circuitBreakerRule?: {
        appId?: string(name='AppId'),
        defaultResponse?: string(name='DefaultResponse'),
        errorThreshold?: long(name='ErrorThreshold'),
        id?: long(name='Id'),
        model?: string(name='Model'),
        openTimeoutSeconds?: long(name='OpenTimeoutSeconds'),
        slowRatioThreshold?: double(name='SlowRatioThreshold'),
        switchStatus?: string(name='SwitchStatus'),
        windowsInSeconds?: long(name='WindowsInSeconds'),
        workspaceId?: string(name='WorkspaceId'),
      }(name='CircuitBreakerRule'),
      contentType?: string(name='ContentType'),
      defaultLimitRule?: {
        configId?: int32(name='ConfigId'),
        defaultLimit?: boolean(name='DefaultLimit'),
      }(name='DefaultLimitRule'),
      description?: string(name='Description'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      headerRule?: [ 
        {
          headerKey?: string(name='HeaderKey'),
          location?: string(name='Location'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='HeaderRule'),
      headerRules?: [ 
        {
          headerKey?: string(name='HeaderKey'),
          location?: string(name='Location'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='HeaderRules'),
      host?: string(name='Host'),
      id?: long(name='Id'),
      interfaceType?: string(name='InterfaceType'),
      limitRule?: {
        defaultResponse?: string(name='DefaultResponse'),
        i18nResponse?: string(name='I18nResponse'),
        interval?: long(name='Interval'),
        limit?: long(name='Limit'),
        mode?: string(name='Mode'),
      }(name='LimitRule'),
      method?: string(name='Method'),
      methodName?: string(name='MethodName'),
      migrateRule?: {
        flowPercent?: long(name='FlowPercent'),
        needMigrate?: boolean(name='NeedMigrate'),
        needSwitchCompletely?: boolean(name='NeedSwitchCompletely'),
        sysId?: long(name='SysId'),
        sysName?: string(name='SysName'),
        upstreamType?: string(name='UpstreamType'),
      }(name='MigrateRule'),
      mockRule?: {
        mockData?: string(name='MockData'),
        needMock?: boolean(name='NeedMock'),
        percentage?: long(name='Percentage'),
        type?: string(name='Type'),
      }(name='MockRule'),
      needETag?: string(name='NeedETag'),
      needEncrypt?: string(name='NeedEncrypt'),
      needJsonp?: string(name='NeedJsonp'),
      needSign?: string(name='NeedSign'),
      operationType?: string(name='OperationType'),
      paramGetMethod?: string(name='ParamGetMethod'),
      path?: string(name='Path'),
      requestBodyModel?: string(name='RequestBodyModel'),
      requestParams?: [ 
        {
          apiId?: string(name='ApiId'),
          appId?: string(name='AppId'),
          defaultValue?: string(name='DefaultValue'),
          description?: string(name='Description'),
          id?: long(name='Id'),
          location?: string(name='Location'),
          name?: string(name='Name'),
          refType?: string(name='RefType'),
          type?: string(name='Type'),
          workspaceId?: string(name='WorkspaceId'),
        }
      ](name='RequestParams'),
      responseBodyModel?: string(name='ResponseBodyModel'),
      sysId?: long(name='SysId'),
      sysName?: string(name='SysName'),
      timeout?: string(name='Timeout'),
      workspaceId?: string(name='WorkspaceId'),
    }(name='Value'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMgsApirestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMgsApirestResponseBody(name='body'),
}

async function queryMgsApirestWithOptions(request: QueryMgsApirestRequest, runtime: Util.RuntimeOptions): QueryMgsApirestResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.format)) {
    body['Format'] = request.format;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryMgsApirest',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMgsApirest(request: QueryMgsApirestRequest): QueryMgsApirestResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMgsApirestWithOptions(request, runtime);
}

model QueryMgsTestreqbodyautogenRequest {
  appId?: string(name='AppId'),
  format?: string(name='Format'),
  mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr?: string(name='MpaasMappcenterMgsTestreqbodyautogenQueryJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMgsTestreqbodyautogenResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMgsTestreqbodyautogenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMgsTestreqbodyautogenResponseBody(name='body'),
}

async function queryMgsTestreqbodyautogenWithOptions(request: QueryMgsTestreqbodyautogenRequest, runtime: Util.RuntimeOptions): QueryMgsTestreqbodyautogenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.format)) {
    body['Format'] = request.format;
  }
  if (!Util.isUnset(request.mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr)) {
    body['MpaasMappcenterMgsTestreqbodyautogenQueryJsonStr'] = request.mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryMgsTestreqbodyautogen',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMgsTestreqbodyautogen(request: QueryMgsTestreqbodyautogenRequest): QueryMgsTestreqbodyautogenResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMgsTestreqbodyautogenWithOptions(request, runtime);
}

model QueryMpsSchedulerListRequest {
  appId?: string(name='AppId'),
  endTime?: long(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime'),
  type?: int32(name='Type'),
  uniqueId?: string(name='UniqueId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMpsSchedulerListResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      list?: [ 
        {
          createType?: int32(name='CreateType'),
          deliveryType?: int32(name='DeliveryType'),
          executedStatus?: string(name='ExecutedStatus'),
          gmtCreate?: long(name='GmtCreate'),
          parentId?: string(name='ParentId'),
          pushContent?: string(name='PushContent'),
          pushTime?: long(name='PushTime'),
          pushTitle?: string(name='PushTitle'),
          strategyType?: int32(name='StrategyType'),
          type?: int32(name='Type'),
          uniqueId?: string(name='UniqueId'),
        }
      ](name='List'),
      totalCount?: int32(name='TotalCount'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMpsSchedulerListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMpsSchedulerListResponseBody(name='body'),
}

async function queryMpsSchedulerListWithOptions(request: QueryMpsSchedulerListRequest, runtime: Util.RuntimeOptions): QueryMpsSchedulerListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.uniqueId)) {
    body['UniqueId'] = request.uniqueId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryMpsSchedulerList',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMpsSchedulerList(request: QueryMpsSchedulerListRequest): QueryMpsSchedulerListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMpsSchedulerListWithOptions(request, runtime);
}

model QueryPushAnalysisCoreIndexRequest {
  appId?: string(name='AppId'),
  channel?: string(name='Channel'),
  endTime?: long(name='EndTime'),
  platform?: string(name='Platform'),
  startTime?: long(name='StartTime'),
  taskId?: string(name='TaskId'),
  type?: string(name='Type'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryPushAnalysisCoreIndexResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      arrivalNum?: float(name='ArrivalNum'),
      arrivalRate?: float(name='ArrivalRate'),
      ignoreNum?: float(name='IgnoreNum'),
      ignoreRate?: float(name='IgnoreRate'),
      openNum?: float(name='OpenNum'),
      openRate?: float(name='OpenRate'),
      pushNum?: float(name='PushNum'),
      pushTotalNum?: float(name='PushTotalNum'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushAnalysisCoreIndexResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryPushAnalysisCoreIndexResponseBody(name='body'),
}

async function queryPushAnalysisCoreIndexWithOptions(request: QueryPushAnalysisCoreIndexRequest, runtime: Util.RuntimeOptions): QueryPushAnalysisCoreIndexResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.channel)) {
    body['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryPushAnalysisCoreIndex',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPushAnalysisCoreIndex(request: QueryPushAnalysisCoreIndexRequest): QueryPushAnalysisCoreIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPushAnalysisCoreIndexWithOptions(request, runtime);
}

model QueryPushAnalysisTaskDetailRequest {
  appId?: string(name='AppId'),
  taskId?: string(name='TaskId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryPushAnalysisTaskDetailResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      duration?: string(name='Duration'),
      endTime?: long(name='EndTime'),
      pushArrivalNum?: float(name='PushArrivalNum'),
      pushNum?: float(name='PushNum'),
      pushSuccessNum?: float(name='PushSuccessNum'),
      startTime?: long(name='StartTime'),
      taskId?: long(name='TaskId'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushAnalysisTaskDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryPushAnalysisTaskDetailResponseBody(name='body'),
}

async function queryPushAnalysisTaskDetailWithOptions(request: QueryPushAnalysisTaskDetailRequest, runtime: Util.RuntimeOptions): QueryPushAnalysisTaskDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryPushAnalysisTaskDetail',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPushAnalysisTaskDetail(request: QueryPushAnalysisTaskDetailRequest): QueryPushAnalysisTaskDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPushAnalysisTaskDetailWithOptions(request, runtime);
}

model QueryPushAnalysisTaskListRequest {
  appId?: string(name='AppId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime'),
  taskId?: string(name='TaskId'),
  taskName?: string(name='TaskName'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryPushAnalysisTaskListResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: [ 
      {
        gmtCreate?: long(name='GmtCreate'),
        list?: [ 
          {
            gmtCreate?: long(name='GmtCreate'),
            taskId?: string(name='TaskId'),
            taskName?: string(name='TaskName'),
            templateId?: string(name='TemplateId'),
            templateName?: string(name='TemplateName'),
            type?: long(name='Type'),
          }
        ](name='List'),
        taskId?: string(name='TaskId'),
        taskName?: string(name='TaskName'),
        templateId?: string(name='TemplateId'),
        templateName?: string(name='TemplateName'),
        type?: long(name='Type'),
      }
    ](name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushAnalysisTaskListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryPushAnalysisTaskListResponseBody(name='body'),
}

async function queryPushAnalysisTaskListWithOptions(request: QueryPushAnalysisTaskListRequest, runtime: Util.RuntimeOptions): QueryPushAnalysisTaskListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryPushAnalysisTaskList',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPushAnalysisTaskList(request: QueryPushAnalysisTaskListRequest): QueryPushAnalysisTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPushAnalysisTaskListWithOptions(request, runtime);
}

model QueryPushSchedulerListRequest {
  appId?: string(name='AppId'),
  endTime?: long(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime'),
  type?: int32(name='Type'),
  uniqueId?: string(name='UniqueId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryPushSchedulerListResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      list?: [ 
        {
          createType?: int32(name='CreateType'),
          deliveryType?: int32(name='DeliveryType'),
          executedStatus?: string(name='ExecutedStatus'),
          gmtCreate?: long(name='GmtCreate'),
          parentId?: string(name='ParentId'),
          pushContent?: string(name='PushContent'),
          pushTime?: long(name='PushTime'),
          pushTitle?: string(name='PushTitle'),
          strategyType?: int32(name='StrategyType'),
          type?: int32(name='Type'),
          uniqueId?: string(name='UniqueId'),
        }
      ](name='List'),
      totalCount?: int32(name='TotalCount'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushSchedulerListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryPushSchedulerListResponseBody(name='body'),
}

async function queryPushSchedulerListWithOptions(request: QueryPushSchedulerListRequest, runtime: Util.RuntimeOptions): QueryPushSchedulerListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  if (!Util.isUnset(request.uniqueId)) {
    body['UniqueId'] = request.uniqueId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryPushSchedulerList',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPushSchedulerList(request: QueryPushSchedulerListRequest): QueryPushSchedulerListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPushSchedulerListWithOptions(request, runtime);
}

model RevokePushMessageRequest {
  appId?: string(name='AppId'),
  messageId?: string(name='MessageId'),
  targetId?: string(name='TargetId'),
  workspaceId?: string(name='WorkspaceId'),
}

model RevokePushMessageResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model RevokePushMessageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokePushMessageResponseBody(name='body'),
}

async function revokePushMessageWithOptions(request: RevokePushMessageRequest, runtime: Util.RuntimeOptions): RevokePushMessageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.messageId)) {
    body['MessageId'] = request.messageId;
  }
  if (!Util.isUnset(request.targetId)) {
    body['TargetId'] = request.targetId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RevokePushMessage',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokePushMessage(request: RevokePushMessageRequest): RevokePushMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokePushMessageWithOptions(request, runtime);
}

model RevokePushTaskRequest {
  appId?: string(name='AppId'),
  taskId?: string(name='TaskId'),
  workspaceId?: string(name='WorkspaceId'),
}

model RevokePushTaskResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model RevokePushTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokePushTaskResponseBody(name='body'),
}

async function revokePushTaskWithOptions(request: RevokePushTaskRequest, runtime: Util.RuntimeOptions): RevokePushTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RevokePushTask',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokePushTask(request: RevokePushTaskRequest): RevokePushTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokePushTaskWithOptions(request, runtime);
}

model RunMsaDiffRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMsaDiffRunJsonStr?: string(name='MpaasMappcenterMsaDiffRunJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model RunMsaDiffResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model RunMsaDiffResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RunMsaDiffResponseBody(name='body'),
}

async function runMsaDiffWithOptions(request: RunMsaDiffRequest, runtime: Util.RuntimeOptions): RunMsaDiffResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMsaDiffRunJsonStr)) {
    body['MpaasMappcenterMsaDiffRunJsonStr'] = request.mpaasMappcenterMsaDiffRunJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RunMsaDiff',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runMsaDiff(request: RunMsaDiffRequest): RunMsaDiffResponse {
  var runtime = new Util.RuntimeOptions{};
  return runMsaDiffWithOptions(request, runtime);
}

model SaveMgsApirestRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMgsApirestSaveJsonStr?: string(name='MpaasMappcenterMgsApirestSaveJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model SaveMgsApirestResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    errorMessage?: string(name='ErrorMessage'),
    success?: boolean(name='Success'),
    value?: boolean(name='Value'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model SaveMgsApirestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveMgsApirestResponseBody(name='body'),
}

async function saveMgsApirestWithOptions(request: SaveMgsApirestRequest, runtime: Util.RuntimeOptions): SaveMgsApirestResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.mpaasMappcenterMgsApirestSaveJsonStr)) {
    body['MpaasMappcenterMgsApirestSaveJsonStr'] = request.mpaasMappcenterMgsApirestSaveJsonStr;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveMgsApirest',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveMgsApirest(request: SaveMgsApirestRequest): SaveMgsApirestResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveMgsApirestWithOptions(request, runtime);
}

model StartUserAppAsyncEnhanceInMsaRequest {
  apkProtector?: boolean(name='ApkProtector'),
  appId?: string(name='AppId'),
  assetsFileList?: string(name='AssetsFileList'),
  classes?: string(name='Classes'),
  dalvikDebugger?: int32(name='DalvikDebugger'),
  emulatorEnvironment?: int32(name='EmulatorEnvironment'),
  id?: long(name='Id'),
  javaHook?: int32(name='JavaHook'),
  memoryDump?: int32(name='MemoryDump'),
  nativeDebugger?: int32(name='NativeDebugger'),
  nativeHook?: int32(name='NativeHook'),
  packageTampered?: int32(name='PackageTampered'),
  root?: int32(name='Root'),
  runMode?: string(name='RunMode'),
  soFileList?: string(name='SoFileList'),
  taskType?: string(name='TaskType'),
  tenantId?: string(name='TenantId'),
  totalSwitch?: boolean(name='TotalSwitch'),
  workspaceId?: string(name='WorkspaceId'),
}

model StartUserAppAsyncEnhanceInMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: {
      afterMd5?: string(name='AfterMd5'),
      afterSize?: long(name='AfterSize'),
      appCode?: string(name='AppCode'),
      appPackage?: string(name='AppPackage'),
      assetsFileList?: [ string ](name='AssetsFileList'),
      beforeMd5?: string(name='BeforeMd5'),
      beforeSize?: long(name='BeforeSize'),
      classForest?: string(name='ClassForest'),
      enhanceMapping?: [ 
        {
          info?: string(name='Info'),
          reason?: string(name='Reason'),
          type?: string(name='Type'),
        }
      ](name='EnhanceMapping'),
      enhanceRules?: [ string ](name='EnhanceRules'),
      enhancedAssetsFiles?: [ string ](name='EnhancedAssetsFiles'),
      enhancedClasses?: [ string ](name='EnhancedClasses'),
      enhancedSoFiles?: [ string ](name='EnhancedSoFiles'),
      id?: long(name='Id'),
      label?: string(name='Label'),
      progress?: long(name='Progress'),
      soFileList?: [ string ](name='SoFileList'),
      status?: long(name='Status'),
      taskType?: string(name='TaskType'),
      versionCode?: string(name='VersionCode'),
      versionName?: string(name='VersionName'),
    }(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model StartUserAppAsyncEnhanceInMsaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartUserAppAsyncEnhanceInMsaResponseBody(name='body'),
}

async function startUserAppAsyncEnhanceInMsaWithOptions(request: StartUserAppAsyncEnhanceInMsaRequest, runtime: Util.RuntimeOptions): StartUserAppAsyncEnhanceInMsaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.apkProtector)) {
    body['ApkProtector'] = request.apkProtector;
  }
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.assetsFileList)) {
    body['AssetsFileList'] = request.assetsFileList;
  }
  if (!Util.isUnset(request.classes)) {
    body['Classes'] = request.classes;
  }
  if (!Util.isUnset(request.dalvikDebugger)) {
    body['DalvikDebugger'] = request.dalvikDebugger;
  }
  if (!Util.isUnset(request.emulatorEnvironment)) {
    body['EmulatorEnvironment'] = request.emulatorEnvironment;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.javaHook)) {
    body['JavaHook'] = request.javaHook;
  }
  if (!Util.isUnset(request.memoryDump)) {
    body['MemoryDump'] = request.memoryDump;
  }
  if (!Util.isUnset(request.nativeDebugger)) {
    body['NativeDebugger'] = request.nativeDebugger;
  }
  if (!Util.isUnset(request.nativeHook)) {
    body['NativeHook'] = request.nativeHook;
  }
  if (!Util.isUnset(request.packageTampered)) {
    body['PackageTampered'] = request.packageTampered;
  }
  if (!Util.isUnset(request.root)) {
    body['Root'] = request.root;
  }
  if (!Util.isUnset(request.runMode)) {
    body['RunMode'] = request.runMode;
  }
  if (!Util.isUnset(request.soFileList)) {
    body['SoFileList'] = request.soFileList;
  }
  if (!Util.isUnset(request.taskType)) {
    body['TaskType'] = request.taskType;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.totalSwitch)) {
    body['TotalSwitch'] = request.totalSwitch;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartUserAppAsyncEnhanceInMsa',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startUserAppAsyncEnhanceInMsa(request: StartUserAppAsyncEnhanceInMsaRequest): StartUserAppAsyncEnhanceInMsaResponse {
  var runtime = new Util.RuntimeOptions{};
  return startUserAppAsyncEnhanceInMsaWithOptions(request, runtime);
}

model UpdateMcubeWhitelistRequest {
  appId?: string(name='AppId'),
  id?: string(name='Id'),
  keyIds?: string(name='KeyIds'),
  onexFlag?: boolean(name='OnexFlag'),
  ossUrl?: string(name='OssUrl'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model UpdateMcubeWhitelistResponseBody = {
  addWhitelistResult?: {
    addWhitelistInfo?: {
      failNum?: long(name='FailNum'),
      failUserIds?: string(name='FailUserIds'),
      successNum?: long(name='SuccessNum'),
    }(name='AddWhitelistInfo'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='AddWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model UpdateMcubeWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMcubeWhitelistResponseBody(name='body'),
}

async function updateMcubeWhitelistWithOptions(request: UpdateMcubeWhitelistRequest, runtime: Util.RuntimeOptions): UpdateMcubeWhitelistResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.keyIds)) {
    body['KeyIds'] = request.keyIds;
  }
  if (!Util.isUnset(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!Util.isUnset(request.ossUrl)) {
    body['OssUrl'] = request.ossUrl;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMcubeWhitelist',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMcubeWhitelist(request: UpdateMcubeWhitelistRequest): UpdateMcubeWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMcubeWhitelistWithOptions(request, runtime);
}

model UpdateMpaasAppInfoRequest {
  appId?: string(name='AppId'),
  appName?: string(name='AppName'),
  iconFileUrl?: string(name='IconFileUrl'),
  identifier?: string(name='Identifier'),
  onexFlag?: boolean(name='OnexFlag'),
  systemType?: string(name='SystemType'),
  tenantId?: string(name='TenantId'),
}

model UpdateMpaasAppInfoResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      appId?: string(name='AppId'),
      code?: string(name='Code'),
      data?: string(name='Data'),
      message?: string(name='Message'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model UpdateMpaasAppInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMpaasAppInfoResponseBody(name='body'),
}

async function updateMpaasAppInfoWithOptions(request: UpdateMpaasAppInfoRequest, runtime: Util.RuntimeOptions): UpdateMpaasAppInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appName)) {
    body['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.iconFileUrl)) {
    body['IconFileUrl'] = request.iconFileUrl;
  }
  if (!Util.isUnset(request.identifier)) {
    body['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!Util.isUnset(request.systemType)) {
    body['SystemType'] = request.systemType;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMpaasAppInfo',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMpaasAppInfo(request: UpdateMpaasAppInfoRequest): UpdateMpaasAppInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMpaasAppInfoWithOptions(request, runtime);
}

model UploadMcubeMiniPackageRequest {
  appId?: string(name='AppId'),
  autoInstall?: long(name='AutoInstall'),
  clientVersionMax?: string(name='ClientVersionMax'),
  clientVersionMin?: string(name='ClientVersionMin'),
  enableKeepAlive?: string(name='EnableKeepAlive'),
  enableOptionMenu?: string(name='EnableOptionMenu'),
  enableTabBar?: long(name='EnableTabBar'),
  extendInfo?: string(name='ExtendInfo'),
  h5Id?: string(name='H5Id'),
  h5Name?: string(name='H5Name'),
  h5Version?: string(name='H5Version'),
  iconFileUrl?: string(name='IconFileUrl'),
  iconUrl?: string(name='IconUrl'),
  installType?: long(name='InstallType'),
  mainUrl?: string(name='MainUrl'),
  onexFlag?: boolean(name='OnexFlag'),
  packageType?: long(name='PackageType'),
  platform?: string(name='Platform'),
  resourceFileUrl?: string(name='ResourceFileUrl'),
  resourceType?: long(name='ResourceType'),
  tenantId?: string(name='TenantId'),
  userId?: string(name='UserId'),
  uuid?: string(name='Uuid'),
  vhost?: string(name='Vhost'),
  workspaceId?: string(name='WorkspaceId'),
}

model UploadMcubeMiniPackageResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  uploadMiniPackageResult?: {
    resultMsg?: string(name='ResultMsg'),
    returnPackageResult?: {
      debugUrl?: string(name='DebugUrl'),
      packageId?: string(name='PackageId'),
      userId?: string(name='UserId'),
    }(name='ReturnPackageResult'),
    success?: boolean(name='Success'),
  }(name='UploadMiniPackageResult'),
}

model UploadMcubeMiniPackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadMcubeMiniPackageResponseBody(name='body'),
}

async function uploadMcubeMiniPackageWithOptions(request: UploadMcubeMiniPackageRequest, runtime: Util.RuntimeOptions): UploadMcubeMiniPackageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.autoInstall)) {
    body['AutoInstall'] = request.autoInstall;
  }
  if (!Util.isUnset(request.clientVersionMax)) {
    body['ClientVersionMax'] = request.clientVersionMax;
  }
  if (!Util.isUnset(request.clientVersionMin)) {
    body['ClientVersionMin'] = request.clientVersionMin;
  }
  if (!Util.isUnset(request.enableKeepAlive)) {
    body['EnableKeepAlive'] = request.enableKeepAlive;
  }
  if (!Util.isUnset(request.enableOptionMenu)) {
    body['EnableOptionMenu'] = request.enableOptionMenu;
  }
  if (!Util.isUnset(request.enableTabBar)) {
    body['EnableTabBar'] = request.enableTabBar;
  }
  if (!Util.isUnset(request.extendInfo)) {
    body['ExtendInfo'] = request.extendInfo;
  }
  if (!Util.isUnset(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!Util.isUnset(request.h5Name)) {
    body['H5Name'] = request.h5Name;
  }
  if (!Util.isUnset(request.h5Version)) {
    body['H5Version'] = request.h5Version;
  }
  if (!Util.isUnset(request.iconFileUrl)) {
    body['IconFileUrl'] = request.iconFileUrl;
  }
  if (!Util.isUnset(request.iconUrl)) {
    body['IconUrl'] = request.iconUrl;
  }
  if (!Util.isUnset(request.installType)) {
    body['InstallType'] = request.installType;
  }
  if (!Util.isUnset(request.mainUrl)) {
    body['MainUrl'] = request.mainUrl;
  }
  if (!Util.isUnset(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!Util.isUnset(request.packageType)) {
    body['PackageType'] = request.packageType;
  }
  if (!Util.isUnset(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.resourceFileUrl)) {
    body['ResourceFileUrl'] = request.resourceFileUrl;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.uuid)) {
    body['Uuid'] = request.uuid;
  }
  if (!Util.isUnset(request.vhost)) {
    body['Vhost'] = request.vhost;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UploadMcubeMiniPackage',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadMcubeMiniPackage(request: UploadMcubeMiniPackageRequest): UploadMcubeMiniPackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadMcubeMiniPackageWithOptions(request, runtime);
}

model UploadMcubeRsaKeyRequest {
  appId?: string(name='AppId'),
  fileUrl?: string(name='FileUrl'),
  onexFlag?: boolean(name='OnexFlag'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model UploadMcubeRsaKeyResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  uploadRsaResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='UploadRsaResult'),
}

model UploadMcubeRsaKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadMcubeRsaKeyResponseBody(name='body'),
}

async function uploadMcubeRsaKeyWithOptions(request: UploadMcubeRsaKeyRequest, runtime: Util.RuntimeOptions): UploadMcubeRsaKeyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.fileUrl)) {
    body['FileUrl'] = request.fileUrl;
  }
  if (!Util.isUnset(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UploadMcubeRsaKey',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadMcubeRsaKey(request: UploadMcubeRsaKeyRequest): UploadMcubeRsaKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadMcubeRsaKeyWithOptions(request, runtime);
}

model UploadUserAppToMsaRequest {
  appId?: string(name='AppId'),
  fileUrl?: string(name='FileUrl'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model UploadUserAppToMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: {
      apkInfo?: {
        afterMd5?: string(name='AfterMd5'),
        afterSize?: long(name='AfterSize'),
        appCode?: string(name='AppCode'),
        appPackage?: string(name='AppPackage'),
        beforeMd5?: string(name='BeforeMd5'),
        beforeSize?: long(name='BeforeSize'),
        classForest?: string(name='ClassForest'),
        enhanceMapping?: {
          info?: string(name='Info'),
          reason?: string(name='Reason'),
          type?: string(name='Type'),
        }(name='EnhanceMapping'),
        enhanceRules?: [ string ](name='EnhanceRules'),
        enhancedClasses?: [ string ](name='EnhancedClasses'),
        id?: long(name='Id'),
        label?: string(name='Label'),
        progress?: long(name='Progress'),
        status?: long(name='Status'),
        taskType?: string(name='TaskType'),
        versionCode?: string(name='VersionCode'),
        versionName?: string(name='VersionName'),
      }(name='ApkInfo'),
      enhanceTaskId?: long(name='EnhanceTaskId'),
      id?: long(name='Id'),
      progress?: long(name='Progress'),
      status?: long(name='Status'),
    }(name='Data'),
    extra?: string(name='Extra'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model UploadUserAppToMsaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadUserAppToMsaResponseBody(name='body'),
}

async function uploadUserAppToMsaWithOptions(request: UploadUserAppToMsaRequest, runtime: Util.RuntimeOptions): UploadUserAppToMsaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.fileUrl)) {
    body['FileUrl'] = request.fileUrl;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UploadUserAppToMsa',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadUserAppToMsa(request: UploadUserAppToMsaRequest): UploadUserAppToMsaResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadUserAppToMsaWithOptions(request, runtime);
}

