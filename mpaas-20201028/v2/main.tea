/**
 *
 */
import OpenApi;
import OpenApi.OpenApiUtil;

extends OpenApi;


init(config: OpenApiUtil.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    'cn-hangzhou' = 'mpaas.aliyuncs.com',
    'ap-northeast-1' = 'mpaas.aliyuncs.com',
    'ap-northeast-2-pop' = 'mpaas.aliyuncs.com',
    'ap-south-1' = 'mpaas.aliyuncs.com',
    'ap-southeast-1' = 'mpaas.aliyuncs.com',
    'ap-southeast-2' = 'mpaas.aliyuncs.com',
    'ap-southeast-3' = 'mpaas.aliyuncs.com',
    'ap-southeast-5' = 'mpaas.aliyuncs.com',
    'cn-beijing' = 'mpaas.aliyuncs.com',
    'cn-beijing-finance-1' = 'mpaas.aliyuncs.com',
    'cn-beijing-finance-pop' = 'mpaas.aliyuncs.com',
    'cn-beijing-gov-1' = 'mpaas.aliyuncs.com',
    'cn-beijing-nu16-b01' = 'mpaas.aliyuncs.com',
    'cn-chengdu' = 'mpaas.aliyuncs.com',
    'cn-edge-1' = 'mpaas.aliyuncs.com',
    'cn-fujian' = 'mpaas.aliyuncs.com',
    'cn-haidian-cm12-c01' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-bj-b01' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-finance' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-prod-1' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-test-1' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-test-2' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-test-3' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-test-306' = 'mpaas.aliyuncs.com',
    'cn-hongkong' = 'mpaas.aliyuncs.com',
    'cn-hongkong-finance-pop' = 'mpaas.aliyuncs.com',
    'cn-huhehaote' = 'mpaas.aliyuncs.com',
    'cn-north-2-gov-1' = 'mpaas.aliyuncs.com',
    'cn-qingdao' = 'mpaas.aliyuncs.com',
    'cn-qingdao-nebula' = 'mpaas.aliyuncs.com',
    'cn-shanghai' = 'mpaas.aliyuncs.com',
    'cn-shanghai-et15-b01' = 'mpaas.aliyuncs.com',
    'cn-shanghai-et2-b01' = 'mpaas.aliyuncs.com',
    'cn-shanghai-finance-1' = 'mpaas.aliyuncs.com',
    'cn-shanghai-inner' = 'mpaas.aliyuncs.com',
    'cn-shanghai-internal-test-1' = 'mpaas.aliyuncs.com',
    'cn-shenzhen' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-finance-1' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-inner' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-st4-d01' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-su18-b01' = 'mpaas.aliyuncs.com',
    'cn-wuhan' = 'mpaas.aliyuncs.com',
    'cn-yushanfang' = 'mpaas.aliyuncs.com',
    'cn-zhangbei-na61-b01' = 'mpaas.aliyuncs.com',
    'cn-zhangjiakou' = 'mpaas.aliyuncs.com',
    'cn-zhangjiakou-na62-a01' = 'mpaas.aliyuncs.com',
    'cn-zhengzhou-nebula-1' = 'mpaas.aliyuncs.com',
    'eu-central-1' = 'mpaas.aliyuncs.com',
    'eu-west-1' = 'mpaas.aliyuncs.com',
    'eu-west-1-oxs' = 'mpaas.aliyuncs.com',
    'me-east-1' = 'mpaas.aliyuncs.com',
    'rus-west-1-pop' = 'mpaas.aliyuncs.com',
    'us-east-1' = 'mpaas.aliyuncs.com',
    'us-west-1' = 'mpaas.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('mpaas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!$isNull(endpoint)) {
    return endpoint;
  }
  
  if (!$isNull(endpointMap) && !$isNull(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddMdsMiniConfigRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  mpaasMappcenterMiniConfigAddJsonStr?: string(name='MpaasMappcenterMiniConfigAddJsonStr', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model AddMdsMiniConfigResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      requestId?: string(name='RequestId'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model AddMdsMiniConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddMdsMiniConfigResponseBody(name='body'),
}

/**
 * @param request AddMdsMiniConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddMdsMiniConfigResponse
 */
@context("addMdsMiniConfigWithContext")
async function addMdsMiniConfigWithOptions(request: AddMdsMiniConfigRequest, runtime: $RuntimeOptions): AddMdsMiniConfigResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.mpaasMappcenterMiniConfigAddJsonStr)) {
    body['MpaasMappcenterMiniConfigAddJsonStr'] = request.mpaasMappcenterMiniConfigAddJsonStr;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'AddMdsMiniConfig',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddMdsMiniConfigRequest
 * @return AddMdsMiniConfigResponse
 */
async function addMdsMiniConfig(request: AddMdsMiniConfigRequest): AddMdsMiniConfigResponse {
  var runtime = new $RuntimeOptions{};
  return addMdsMiniConfigWithOptions(request, runtime);
}

model CancelPushSchedulerRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  type?: int32(name='Type'),
  uniqueIds?: string(name='UniqueIds', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CancelPushSchedulerResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CancelPushSchedulerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelPushSchedulerResponseBody(name='body'),
}

/**
 * @param request CancelPushSchedulerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelPushSchedulerResponse
 */
@context("cancelPushSchedulerWithContext")
async function cancelPushSchedulerWithOptions(request: CancelPushSchedulerRequest, runtime: $RuntimeOptions): CancelPushSchedulerResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }
  if (!$isNull(request.uniqueIds)) {
    body['UniqueIds'] = request.uniqueIds;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CancelPushScheduler',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CancelPushSchedulerRequest
 * @return CancelPushSchedulerResponse
 */
async function cancelPushScheduler(request: CancelPushSchedulerRequest): CancelPushSchedulerResponse {
  var runtime = new $RuntimeOptions{};
  return cancelPushSchedulerWithOptions(request, runtime);
}

model ChangeMcubeMiniTaskStatusRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  bizType?: string(name='BizType', description='This parameter is required.'),
  packageId?: long(name='PackageId', description='This parameter is required.'),
  taskId?: long(name='TaskId', description='This parameter is required.'),
  taskStatus?: long(name='TaskStatus', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model ChangeMcubeMiniTaskStatusResponseBody = {
  changeMiniTaskStatusResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ChangeMiniTaskStatusResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ChangeMcubeMiniTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeMcubeMiniTaskStatusResponseBody(name='body'),
}

/**
 * @param request ChangeMcubeMiniTaskStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeMcubeMiniTaskStatusResponse
 */
@context("changeMcubeMiniTaskStatusWithContext")
async function changeMcubeMiniTaskStatusWithOptions(request: ChangeMcubeMiniTaskStatusRequest, runtime: $RuntimeOptions): ChangeMcubeMiniTaskStatusResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!$isNull(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.taskStatus)) {
    body['TaskStatus'] = request.taskStatus;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ChangeMcubeMiniTaskStatus',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ChangeMcubeMiniTaskStatusRequest
 * @return ChangeMcubeMiniTaskStatusResponse
 */
async function changeMcubeMiniTaskStatus(request: ChangeMcubeMiniTaskStatusRequest): ChangeMcubeMiniTaskStatusResponse {
  var runtime = new $RuntimeOptions{};
  return changeMcubeMiniTaskStatusWithOptions(request, runtime);
}

model ChangeMcubeNebulaTaskStatusRequest {
  appId?: string(name='AppId'),
  bizType?: string(name='BizType'),
  packageId?: string(name='PackageId'),
  taskId?: string(name='TaskId'),
  taskStatus?: int32(name='TaskStatus'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ChangeMcubeNebulaTaskStatusResponseBody = {
  changeMcubeNebulaTaskStatusResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ChangeMcubeNebulaTaskStatusResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ChangeMcubeNebulaTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeMcubeNebulaTaskStatusResponseBody(name='body'),
}

/**
 * @param request ChangeMcubeNebulaTaskStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeMcubeNebulaTaskStatusResponse
 */
@context("changeMcubeNebulaTaskStatusWithContext")
async function changeMcubeNebulaTaskStatusWithOptions(request: ChangeMcubeNebulaTaskStatusRequest, runtime: $RuntimeOptions): ChangeMcubeNebulaTaskStatusResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!$isNull(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.taskStatus)) {
    body['TaskStatus'] = request.taskStatus;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ChangeMcubeNebulaTaskStatus',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ChangeMcubeNebulaTaskStatusRequest
 * @return ChangeMcubeNebulaTaskStatusResponse
 */
async function changeMcubeNebulaTaskStatus(request: ChangeMcubeNebulaTaskStatusRequest): ChangeMcubeNebulaTaskStatusResponse {
  var runtime = new $RuntimeOptions{};
  return changeMcubeNebulaTaskStatusWithOptions(request, runtime);
}

model ChangeMcubePublicTaskStatusRequest {
  appId?: string(name='AppId'),
  taskId?: string(name='TaskId'),
  taskStatus?: string(name='TaskStatus'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ChangeMcubePublicTaskStatusResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: string(name='Data'),
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model ChangeMcubePublicTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeMcubePublicTaskStatusResponseBody(name='body'),
}

/**
 * @param request ChangeMcubePublicTaskStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeMcubePublicTaskStatusResponse
 */
@context("changeMcubePublicTaskStatusWithContext")
async function changeMcubePublicTaskStatusWithOptions(request: ChangeMcubePublicTaskStatusRequest, runtime: $RuntimeOptions): ChangeMcubePublicTaskStatusResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.taskStatus)) {
    body['TaskStatus'] = request.taskStatus;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ChangeMcubePublicTaskStatus',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ChangeMcubePublicTaskStatusRequest
 * @return ChangeMcubePublicTaskStatusResponse
 */
async function changeMcubePublicTaskStatus(request: ChangeMcubePublicTaskStatusRequest): ChangeMcubePublicTaskStatusResponse {
  var runtime = new $RuntimeOptions{};
  return changeMcubePublicTaskStatusWithOptions(request, runtime);
}

model CopyMcdpGroupRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpGroupCopyJsonStr?: string(name='MpaasMappcenterMcdpGroupCopyJsonStr', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CopyMcdpGroupResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CopyMcdpGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CopyMcdpGroupResponseBody(name='body'),
}

/**
 * @param request CopyMcdpGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CopyMcdpGroupResponse
 */
@context("copyMcdpGroupWithContext")
async function copyMcdpGroupWithOptions(request: CopyMcdpGroupRequest, runtime: $RuntimeOptions): CopyMcdpGroupResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.mpaasMappcenterMcdpGroupCopyJsonStr)) {
    body['MpaasMappcenterMcdpGroupCopyJsonStr'] = request.mpaasMappcenterMcdpGroupCopyJsonStr;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CopyMcdpGroup',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CopyMcdpGroupRequest
 * @return CopyMcdpGroupResponse
 */
async function copyMcdpGroup(request: CopyMcdpGroupRequest): CopyMcdpGroupResponse {
  var runtime = new $RuntimeOptions{};
  return copyMcdpGroupWithOptions(request, runtime);
}

model CreateLinkRequest {
  appId?: string(name='AppId', description='This parameter is required.', example='BB5953C300957'),
  cors?: boolean(name='Cors', example='false'),
  domain?: string(name='Domain', example='x519.cn'),
  dynamicfield?: string(name='Dynamicfield', example='txt'),
  targetUrl?: string(name='TargetUrl', description='This parameter is required.', example='https://********'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.', example='default'),
}

model CreateLinkResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='0CC8A9CB-9BA3-13FD-A404-6E2E7461881A'),
  resultCode?: string(name='ResultCode', example='100'),
  resultContent?: {
    data?: string(name='Data', example='https://xxx/xxx'),
    target?: string(name='Target', example='https://xxx/xxx/xxx'),
    version?: string(name='Version', example='0'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage', example='success'),
}

model CreateLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLinkResponseBody(name='body'),
}

/**
 * @summary 创建短链
 *
 * @param request CreateLinkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLinkResponse
 */
@context("createLinkWithContext")
async function createLinkWithOptions(request: CreateLinkRequest, runtime: $RuntimeOptions): CreateLinkResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.cors)) {
    body['Cors'] = request.cors;
  }
  if (!$isNull(request.domain)) {
    body['Domain'] = request.domain;
  }
  if (!$isNull(request.dynamicfield)) {
    body['Dynamicfield'] = request.dynamicfield;
  }
  if (!$isNull(request.targetUrl)) {
    body['TargetUrl'] = request.targetUrl;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateLink',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建短链
 *
 * @param request CreateLinkRequest
 * @return CreateLinkResponse
 */
async function createLink(request: CreateLinkRequest): CreateLinkResponse {
  var runtime = new $RuntimeOptions{};
  return createLinkWithOptions(request, runtime);
}

model CreateMcdpGroupRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpGroupCreateJsonStr?: string(name='MpaasMappcenterMcdpGroupCreateJsonStr', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcdpGroupResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcdpGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcdpGroupResponseBody(name='body'),
}

/**
 * @param request CreateMcdpGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcdpGroupResponse
 */
@context("createMcdpGroupWithContext")
async function createMcdpGroupWithOptions(request: CreateMcdpGroupRequest, runtime: $RuntimeOptions): CreateMcdpGroupResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.mpaasMappcenterMcdpGroupCreateJsonStr)) {
    body['MpaasMappcenterMcdpGroupCreateJsonStr'] = request.mpaasMappcenterMcdpGroupCreateJsonStr;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcdpGroup',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcdpGroupRequest
 * @return CreateMcdpGroupResponse
 */
async function createMcdpGroup(request: CreateMcdpGroupRequest): CreateMcdpGroupResponse {
  var runtime = new $RuntimeOptions{};
  return createMcdpGroupWithOptions(request, runtime);
}

model CreateMcdpMaterialRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpMaterialCreateJsonStr?: string(name='MpaasMappcenterMcdpMaterialCreateJsonStr', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcdpMaterialResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcdpMaterialResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcdpMaterialResponseBody(name='body'),
}

/**
 * @param request CreateMcdpMaterialRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcdpMaterialResponse
 */
@context("createMcdpMaterialWithContext")
async function createMcdpMaterialWithOptions(request: CreateMcdpMaterialRequest, runtime: $RuntimeOptions): CreateMcdpMaterialResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.mpaasMappcenterMcdpMaterialCreateJsonStr)) {
    body['MpaasMappcenterMcdpMaterialCreateJsonStr'] = request.mpaasMappcenterMcdpMaterialCreateJsonStr;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcdpMaterial',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcdpMaterialRequest
 * @return CreateMcdpMaterialResponse
 */
async function createMcdpMaterial(request: CreateMcdpMaterialRequest): CreateMcdpMaterialResponse {
  var runtime = new $RuntimeOptions{};
  return createMcdpMaterialWithOptions(request, runtime);
}

model CreateMcdpZoneRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpZoneCreateJsonStr?: string(name='MpaasMappcenterMcdpZoneCreateJsonStr', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcdpZoneResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcdpZoneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcdpZoneResponseBody(name='body'),
}

/**
 * @param request CreateMcdpZoneRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcdpZoneResponse
 */
@context("createMcdpZoneWithContext")
async function createMcdpZoneWithOptions(request: CreateMcdpZoneRequest, runtime: $RuntimeOptions): CreateMcdpZoneResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.mpaasMappcenterMcdpZoneCreateJsonStr)) {
    body['MpaasMappcenterMcdpZoneCreateJsonStr'] = request.mpaasMappcenterMcdpZoneCreateJsonStr;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcdpZone',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcdpZoneRequest
 * @return CreateMcdpZoneResponse
 */
async function createMcdpZone(request: CreateMcdpZoneRequest): CreateMcdpZoneResponse {
  var runtime = new $RuntimeOptions{};
  return createMcdpZoneWithOptions(request, runtime);
}

model CreateMcubeMiniAppRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  h5Id?: string(name='H5Id', description='This parameter is required.'),
  h5Name?: string(name='H5Name', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CreateMcubeMiniAppResponseBody = {
  createMiniResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMiniResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeMiniAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeMiniAppResponseBody(name='body'),
}

/**
 * @param request CreateMcubeMiniAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeMiniAppResponse
 */
@context("createMcubeMiniAppWithContext")
async function createMcubeMiniAppWithOptions(request: CreateMcubeMiniAppRequest, runtime: $RuntimeOptions): CreateMcubeMiniAppResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.h5Name)) {
    body['H5Name'] = request.h5Name;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeMiniApp',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeMiniAppRequest
 * @return CreateMcubeMiniAppResponse
 */
async function createMcubeMiniApp(request: CreateMcubeMiniAppRequest): CreateMcubeMiniAppResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeMiniAppWithOptions(request, runtime);
}

model CreateMcubeMiniTaskRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  greyConfigInfo?: string(name='GreyConfigInfo'),
  greyEndtimeData?: string(name='GreyEndtimeData'),
  greyNum?: long(name='GreyNum'),
  memo?: string(name='Memo', description='This parameter is required.'),
  packageId?: long(name='PackageId', description='This parameter is required.'),
  publishMode?: long(name='PublishMode', description='This parameter is required.'),
  publishType?: long(name='PublishType', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  whitelistIds?: string(name='WhitelistIds'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CreateMcubeMiniTaskResponseBody = {
  createMiniTaskResult?: {
    miniTaskId?: string(name='MiniTaskId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMiniTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeMiniTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeMiniTaskResponseBody(name='body'),
}

/**
 * @param request CreateMcubeMiniTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeMiniTaskResponse
 */
@context("createMcubeMiniTaskWithContext")
async function createMcubeMiniTaskWithOptions(request: CreateMcubeMiniTaskRequest, runtime: $RuntimeOptions): CreateMcubeMiniTaskResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.greyConfigInfo)) {
    body['GreyConfigInfo'] = request.greyConfigInfo;
  }
  if (!$isNull(request.greyEndtimeData)) {
    body['GreyEndtimeData'] = request.greyEndtimeData;
  }
  if (!$isNull(request.greyNum)) {
    body['GreyNum'] = request.greyNum;
  }
  if (!$isNull(request.memo)) {
    body['Memo'] = request.memo;
  }
  if (!$isNull(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!$isNull(request.publishMode)) {
    body['PublishMode'] = request.publishMode;
  }
  if (!$isNull(request.publishType)) {
    body['PublishType'] = request.publishType;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.whitelistIds)) {
    body['WhitelistIds'] = request.whitelistIds;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeMiniTask',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeMiniTaskRequest
 * @return CreateMcubeMiniTaskResponse
 */
async function createMcubeMiniTask(request: CreateMcubeMiniTaskRequest): CreateMcubeMiniTaskResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeMiniTaskWithOptions(request, runtime);
}

model CreateMcubeNebulaAppRequest {
  appId?: string(name='AppId'),
  h5Id?: string(name='H5Id'),
  h5Name?: string(name='H5Name'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeNebulaAppResponseBody = {
  createNebulaAppResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateNebulaAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeNebulaAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeNebulaAppResponseBody(name='body'),
}

/**
 * @param request CreateMcubeNebulaAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeNebulaAppResponse
 */
@context("createMcubeNebulaAppWithContext")
async function createMcubeNebulaAppWithOptions(request: CreateMcubeNebulaAppRequest, runtime: $RuntimeOptions): CreateMcubeNebulaAppResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.h5Name)) {
    body['H5Name'] = request.h5Name;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeNebulaApp',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeNebulaAppRequest
 * @return CreateMcubeNebulaAppResponse
 */
async function createMcubeNebulaApp(request: CreateMcubeNebulaAppRequest): CreateMcubeNebulaAppResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeNebulaAppWithOptions(request, runtime);
}

model CreateMcubeNebulaResourceRequest {
  appId?: string(name='AppId'),
  autoInstall?: int32(name='AutoInstall'),
  clientVersionMax?: string(name='ClientVersionMax'),
  clientVersionMin?: string(name='ClientVersionMin'),
  customDomainName?: string(name='CustomDomainName'),
  extendInfo?: string(name='ExtendInfo'),
  fileUrl?: string(name='FileUrl'),
  h5Id?: string(name='H5Id'),
  h5Name?: string(name='H5Name'),
  h5Version?: string(name='H5Version'),
  installType?: int32(name='InstallType'),
  mainUrl?: string(name='MainUrl'),
  onexFlag?: boolean(name='OnexFlag'),
  platform?: string(name='Platform'),
  repeatNebula?: int32(name='RepeatNebula'),
  resourceType?: int32(name='ResourceType'),
  subUrl?: string(name='SubUrl'),
  tenantId?: string(name='TenantId'),
  vhost?: string(name='Vhost'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeNebulaResourceResponseBody = {
  createMcubeNebulaResourceReslult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaResourceId?: string(name='NebulaResourceId'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMcubeNebulaResourceReslult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeNebulaResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeNebulaResourceResponseBody(name='body'),
}

/**
 * @param request CreateMcubeNebulaResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeNebulaResourceResponse
 */
@context("createMcubeNebulaResourceWithContext")
async function createMcubeNebulaResourceWithOptions(request: CreateMcubeNebulaResourceRequest, runtime: $RuntimeOptions): CreateMcubeNebulaResourceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.autoInstall)) {
    body['AutoInstall'] = request.autoInstall;
  }
  if (!$isNull(request.clientVersionMax)) {
    body['ClientVersionMax'] = request.clientVersionMax;
  }
  if (!$isNull(request.clientVersionMin)) {
    body['ClientVersionMin'] = request.clientVersionMin;
  }
  if (!$isNull(request.customDomainName)) {
    body['CustomDomainName'] = request.customDomainName;
  }
  if (!$isNull(request.extendInfo)) {
    body['ExtendInfo'] = request.extendInfo;
  }
  if (!$isNull(request.fileUrl)) {
    body['FileUrl'] = request.fileUrl;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.h5Name)) {
    body['H5Name'] = request.h5Name;
  }
  if (!$isNull(request.h5Version)) {
    body['H5Version'] = request.h5Version;
  }
  if (!$isNull(request.installType)) {
    body['InstallType'] = request.installType;
  }
  if (!$isNull(request.mainUrl)) {
    body['MainUrl'] = request.mainUrl;
  }
  if (!$isNull(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!$isNull(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!$isNull(request.repeatNebula)) {
    body['RepeatNebula'] = request.repeatNebula;
  }
  if (!$isNull(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.subUrl)) {
    body['SubUrl'] = request.subUrl;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.vhost)) {
    body['Vhost'] = request.vhost;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeNebulaResource',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeNebulaResourceRequest
 * @return CreateMcubeNebulaResourceResponse
 */
async function createMcubeNebulaResource(request: CreateMcubeNebulaResourceRequest): CreateMcubeNebulaResourceResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeNebulaResourceWithOptions(request, runtime);
}

model CreateMcubeNebulaTaskRequest {
  appCode?: string(name='AppCode'),
  appId?: string(name='AppId'),
  bizType?: string(name='BizType'),
  creator?: string(name='Creator'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  gmtModifiedStr?: string(name='GmtModifiedStr'),
  greyConfigInfo?: string(name='GreyConfigInfo'),
  greyEndtime?: string(name='GreyEndtime'),
  greyEndtimeData?: string(name='GreyEndtimeData'),
  greyEndtimeStr?: string(name='GreyEndtimeStr'),
  greyNum?: int32(name='GreyNum'),
  greyUrl?: string(name='GreyUrl'),
  id?: long(name='Id'),
  memo?: string(name='Memo'),
  modifier?: string(name='Modifier'),
  packageId?: long(name='PackageId'),
  percent?: int32(name='Percent'),
  platform?: string(name='Platform'),
  productId?: string(name='ProductId'),
  productVersion?: string(name='ProductVersion'),
  publishMode?: int32(name='PublishMode'),
  publishType?: int32(name='PublishType'),
  releaseVersion?: string(name='ReleaseVersion'),
  resIds?: string(name='ResIds'),
  serialVersionUID?: long(name='SerialVersionUID'),
  status?: int32(name='Status'),
  syncMode?: string(name='SyncMode'),
  syncResult?: string(name='SyncResult'),
  taskName?: string(name='TaskName'),
  taskStatus?: int32(name='TaskStatus'),
  taskType?: int32(name='TaskType'),
  taskVersion?: long(name='TaskVersion'),
  tenantId?: string(name='TenantId'),
  upgradeNoticeNum?: long(name='UpgradeNoticeNum'),
  upgradeProgress?: string(name='UpgradeProgress'),
  whitelistIds?: string(name='WhitelistIds'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeNebulaTaskResponseBody = {
  createMcubeNebulaTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaTaskId?: string(name='NebulaTaskId'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMcubeNebulaTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeNebulaTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeNebulaTaskResponseBody(name='body'),
}

/**
 * @param request CreateMcubeNebulaTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeNebulaTaskResponse
 */
@context("createMcubeNebulaTaskWithContext")
async function createMcubeNebulaTaskWithOptions(request: CreateMcubeNebulaTaskRequest, runtime: $RuntimeOptions): CreateMcubeNebulaTaskResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appCode)) {
    body['AppCode'] = request.appCode;
  }
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!$isNull(request.creator)) {
    body['Creator'] = request.creator;
  }
  if (!$isNull(request.gmtCreate)) {
    body['GmtCreate'] = request.gmtCreate;
  }
  if (!$isNull(request.gmtModified)) {
    body['GmtModified'] = request.gmtModified;
  }
  if (!$isNull(request.gmtModifiedStr)) {
    body['GmtModifiedStr'] = request.gmtModifiedStr;
  }
  if (!$isNull(request.greyConfigInfo)) {
    body['GreyConfigInfo'] = request.greyConfigInfo;
  }
  if (!$isNull(request.greyEndtime)) {
    body['GreyEndtime'] = request.greyEndtime;
  }
  if (!$isNull(request.greyEndtimeData)) {
    body['GreyEndtimeData'] = request.greyEndtimeData;
  }
  if (!$isNull(request.greyEndtimeStr)) {
    body['GreyEndtimeStr'] = request.greyEndtimeStr;
  }
  if (!$isNull(request.greyNum)) {
    body['GreyNum'] = request.greyNum;
  }
  if (!$isNull(request.greyUrl)) {
    body['GreyUrl'] = request.greyUrl;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.memo)) {
    body['Memo'] = request.memo;
  }
  if (!$isNull(request.modifier)) {
    body['Modifier'] = request.modifier;
  }
  if (!$isNull(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!$isNull(request.percent)) {
    body['Percent'] = request.percent;
  }
  if (!$isNull(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!$isNull(request.productId)) {
    body['ProductId'] = request.productId;
  }
  if (!$isNull(request.productVersion)) {
    body['ProductVersion'] = request.productVersion;
  }
  if (!$isNull(request.publishMode)) {
    body['PublishMode'] = request.publishMode;
  }
  if (!$isNull(request.publishType)) {
    body['PublishType'] = request.publishType;
  }
  if (!$isNull(request.releaseVersion)) {
    body['ReleaseVersion'] = request.releaseVersion;
  }
  if (!$isNull(request.resIds)) {
    body['ResIds'] = request.resIds;
  }
  if (!$isNull(request.serialVersionUID)) {
    body['SerialVersionUID'] = request.serialVersionUID;
  }
  if (!$isNull(request.status)) {
    body['Status'] = request.status;
  }
  if (!$isNull(request.syncMode)) {
    body['SyncMode'] = request.syncMode;
  }
  if (!$isNull(request.syncResult)) {
    body['SyncResult'] = request.syncResult;
  }
  if (!$isNull(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!$isNull(request.taskStatus)) {
    body['TaskStatus'] = request.taskStatus;
  }
  if (!$isNull(request.taskType)) {
    body['TaskType'] = request.taskType;
  }
  if (!$isNull(request.taskVersion)) {
    body['TaskVersion'] = request.taskVersion;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.upgradeNoticeNum)) {
    body['UpgradeNoticeNum'] = request.upgradeNoticeNum;
  }
  if (!$isNull(request.upgradeProgress)) {
    body['UpgradeProgress'] = request.upgradeProgress;
  }
  if (!$isNull(request.whitelistIds)) {
    body['WhitelistIds'] = request.whitelistIds;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeNebulaTask',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeNebulaTaskRequest
 * @return CreateMcubeNebulaTaskResponse
 */
async function createMcubeNebulaTask(request: CreateMcubeNebulaTaskRequest): CreateMcubeNebulaTaskResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeNebulaTaskWithOptions(request, runtime);
}

model CreateMcubeUpgradePackageRequest {
  appId?: string(name='AppId'),
  appVersion?: string(name='AppVersion'),
  appstoreUrl?: string(name='AppstoreUrl'),
  bundleId?: string(name='BundleId'),
  customDomainName?: string(name='CustomDomainName'),
  desc?: string(name='Desc'),
  downloadUrl?: string(name='DownloadUrl'),
  fileUrl?: string(name='FileUrl'),
  iconFileUrl?: string(name='IconFileUrl'),
  installAmount?: int32(name='InstallAmount'),
  iosSymbolfileUrl?: string(name='IosSymbolfileUrl'),
  isEnterprise?: int32(name='IsEnterprise'),
  needCheck?: int32(name='NeedCheck'),
  onexFlag?: boolean(name='OnexFlag'),
  platform?: string(name='Platform'),
  tenantId?: string(name='TenantId'),
  validDays?: int32(name='ValidDays'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeUpgradePackageResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: string(name='Data'),
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeUpgradePackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeUpgradePackageResponseBody(name='body'),
}

/**
 * @param request CreateMcubeUpgradePackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeUpgradePackageResponse
 */
@context("createMcubeUpgradePackageWithContext")
async function createMcubeUpgradePackageWithOptions(request: CreateMcubeUpgradePackageRequest, runtime: $RuntimeOptions): CreateMcubeUpgradePackageResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.appVersion)) {
    body['AppVersion'] = request.appVersion;
  }
  if (!$isNull(request.appstoreUrl)) {
    body['AppstoreUrl'] = request.appstoreUrl;
  }
  if (!$isNull(request.bundleId)) {
    body['BundleId'] = request.bundleId;
  }
  if (!$isNull(request.customDomainName)) {
    body['CustomDomainName'] = request.customDomainName;
  }
  if (!$isNull(request.desc)) {
    body['Desc'] = request.desc;
  }
  if (!$isNull(request.downloadUrl)) {
    body['DownloadUrl'] = request.downloadUrl;
  }
  if (!$isNull(request.fileUrl)) {
    body['FileUrl'] = request.fileUrl;
  }
  if (!$isNull(request.iconFileUrl)) {
    body['IconFileUrl'] = request.iconFileUrl;
  }
  if (!$isNull(request.installAmount)) {
    body['InstallAmount'] = request.installAmount;
  }
  if (!$isNull(request.iosSymbolfileUrl)) {
    body['IosSymbolfileUrl'] = request.iosSymbolfileUrl;
  }
  if (!$isNull(request.isEnterprise)) {
    body['IsEnterprise'] = request.isEnterprise;
  }
  if (!$isNull(request.needCheck)) {
    body['NeedCheck'] = request.needCheck;
  }
  if (!$isNull(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!$isNull(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.validDays)) {
    body['ValidDays'] = request.validDays;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeUpgradePackage',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeUpgradePackageRequest
 * @return CreateMcubeUpgradePackageResponse
 */
async function createMcubeUpgradePackage(request: CreateMcubeUpgradePackageRequest): CreateMcubeUpgradePackageResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeUpgradePackageWithOptions(request, runtime);
}

model CreateMcubeUpgradeTaskRequest {
  appId?: string(name='AppId'),
  greyConfigInfo?: string(name='GreyConfigInfo'),
  greyEndtimeData?: string(name='GreyEndtimeData'),
  greyNum?: int32(name='GreyNum'),
  historyForce?: int32(name='HistoryForce'),
  memo?: string(name='Memo'),
  packageInfoId?: long(name='PackageInfoId'),
  publishMode?: int32(name='PublishMode'),
  publishType?: int32(name='PublishType'),
  tenantId?: string(name='TenantId'),
  upgradeContent?: string(name='UpgradeContent'),
  upgradeType?: int32(name='UpgradeType'),
  whitelistIds?: string(name='WhitelistIds'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMcubeUpgradeTaskResponseBody = {
  createTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    upgradeTaskId?: string(name='upgradeTaskId'),
  }(name='CreateTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeUpgradeTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeUpgradeTaskResponseBody(name='body'),
}

/**
 * @param request CreateMcubeUpgradeTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeUpgradeTaskResponse
 */
@context("createMcubeUpgradeTaskWithContext")
async function createMcubeUpgradeTaskWithOptions(request: CreateMcubeUpgradeTaskRequest, runtime: $RuntimeOptions): CreateMcubeUpgradeTaskResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.greyConfigInfo)) {
    body['GreyConfigInfo'] = request.greyConfigInfo;
  }
  if (!$isNull(request.greyEndtimeData)) {
    body['GreyEndtimeData'] = request.greyEndtimeData;
  }
  if (!$isNull(request.greyNum)) {
    body['GreyNum'] = request.greyNum;
  }
  if (!$isNull(request.historyForce)) {
    body['HistoryForce'] = request.historyForce;
  }
  if (!$isNull(request.memo)) {
    body['Memo'] = request.memo;
  }
  if (!$isNull(request.packageInfoId)) {
    body['PackageInfoId'] = request.packageInfoId;
  }
  if (!$isNull(request.publishMode)) {
    body['PublishMode'] = request.publishMode;
  }
  if (!$isNull(request.publishType)) {
    body['PublishType'] = request.publishType;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.upgradeContent)) {
    body['UpgradeContent'] = request.upgradeContent;
  }
  if (!$isNull(request.upgradeType)) {
    body['UpgradeType'] = request.upgradeType;
  }
  if (!$isNull(request.whitelistIds)) {
    body['WhitelistIds'] = request.whitelistIds;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeUpgradeTask',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeUpgradeTaskRequest
 * @return CreateMcubeUpgradeTaskResponse
 */
async function createMcubeUpgradeTask(request: CreateMcubeUpgradeTaskRequest): CreateMcubeUpgradeTaskResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeUpgradeTaskWithOptions(request, runtime);
}

model CreateMcubeVhostRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  vhost?: string(name='Vhost', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CreateMcubeVhostResponseBody = {
  createVhostResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateVhostResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeVhostResponseBody(name='body'),
}

/**
 * @param request CreateMcubeVhostRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeVhostResponse
 */
@context("createMcubeVhostWithContext")
async function createMcubeVhostWithOptions(request: CreateMcubeVhostRequest, runtime: $RuntimeOptions): CreateMcubeVhostResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.vhost)) {
    body['Vhost'] = request.vhost;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeVhost',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeVhostRequest
 * @return CreateMcubeVhostResponse
 */
async function createMcubeVhost(request: CreateMcubeVhostRequest): CreateMcubeVhostResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeVhostWithOptions(request, runtime);
}

model CreateMcubeWhitelistRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  whiteListName?: string(name='WhiteListName', description='This parameter is required.'),
  whitelistType?: string(name='WhitelistType', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CreateMcubeWhitelistResponseBody = {
  createWhitelistResult?: {
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    whitelistId?: string(name='WhitelistId'),
  }(name='CreateWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeWhitelistResponseBody(name='body'),
}

/**
 * @param request CreateMcubeWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeWhitelistResponse
 */
@context("createMcubeWhitelistWithContext")
async function createMcubeWhitelistWithOptions(request: CreateMcubeWhitelistRequest, runtime: $RuntimeOptions): CreateMcubeWhitelistResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.whiteListName)) {
    body['WhiteListName'] = request.whiteListName;
  }
  if (!$isNull(request.whitelistType)) {
    body['WhitelistType'] = request.whitelistType;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeWhitelist',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeWhitelistRequest
 * @return CreateMcubeWhitelistResponse
 */
async function createMcubeWhitelist(request: CreateMcubeWhitelistRequest): CreateMcubeWhitelistResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeWhitelistWithOptions(request, runtime);
}

model CreateMcubeWhitelistForIdeRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  userId?: string(name='UserId', description='This parameter is required.'),
  whitelistValue?: string(name='WhitelistValue', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CreateMcubeWhitelistForIdeResponseBody = {
  createWhitelistForIdeResult?: {
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    whitelistId?: string(name='WhitelistId'),
  }(name='CreateWhitelistForIdeResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeWhitelistForIdeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeWhitelistForIdeResponseBody(name='body'),
}

/**
 * @param request CreateMcubeWhitelistForIdeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMcubeWhitelistForIdeResponse
 */
@context("createMcubeWhitelistForIdeWithContext")
async function createMcubeWhitelistForIdeWithOptions(request: CreateMcubeWhitelistForIdeRequest, runtime: $RuntimeOptions): CreateMcubeWhitelistForIdeResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!$isNull(request.whitelistValue)) {
    body['WhitelistValue'] = request.whitelistValue;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMcubeWhitelistForIde',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMcubeWhitelistForIdeRequest
 * @return CreateMcubeWhitelistForIdeResponse
 */
async function createMcubeWhitelistForIde(request: CreateMcubeWhitelistForIdeRequest): CreateMcubeWhitelistForIdeResponse {
  var runtime = new $RuntimeOptions{};
  return createMcubeWhitelistForIdeWithOptions(request, runtime);
}

model CreateMdsMiniprogramTaskRequest {
  appId?: string(name='AppId'),
  greyConfigInfo?: string(name='GreyConfigInfo'),
  greyEndtimeData?: string(name='GreyEndtimeData'),
  greyNum?: string(name='GreyNum'),
  id?: long(name='Id', description='This parameter is required.'),
  memo?: string(name='Memo'),
  packageId?: long(name='PackageId', description='This parameter is required.'),
  publishMode?: string(name='PublishMode'),
  publishType?: long(name='PublishType', description='This parameter is required.'),
  syncMode?: string(name='SyncMode'),
  tenantId?: string(name='TenantId'),
  whitelistIds?: string(name='WhitelistIds'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateMdsMiniprogramTaskResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      requestId?: string(name='RequestId'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMdsMiniprogramTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMdsMiniprogramTaskResponseBody(name='body'),
}

/**
 * @param request CreateMdsMiniprogramTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMdsMiniprogramTaskResponse
 */
@context("createMdsMiniprogramTaskWithContext")
async function createMdsMiniprogramTaskWithOptions(request: CreateMdsMiniprogramTaskRequest, runtime: $RuntimeOptions): CreateMdsMiniprogramTaskResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.greyConfigInfo)) {
    body['GreyConfigInfo'] = request.greyConfigInfo;
  }
  if (!$isNull(request.greyEndtimeData)) {
    body['GreyEndtimeData'] = request.greyEndtimeData;
  }
  if (!$isNull(request.greyNum)) {
    body['GreyNum'] = request.greyNum;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.memo)) {
    body['Memo'] = request.memo;
  }
  if (!$isNull(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!$isNull(request.publishMode)) {
    body['PublishMode'] = request.publishMode;
  }
  if (!$isNull(request.publishType)) {
    body['PublishType'] = request.publishType;
  }
  if (!$isNull(request.syncMode)) {
    body['SyncMode'] = request.syncMode;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.whitelistIds)) {
    body['WhitelistIds'] = request.whitelistIds;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMdsMiniprogramTask',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateMdsMiniprogramTaskRequest
 * @return CreateMdsMiniprogramTaskResponse
 */
async function createMdsMiniprogramTask(request: CreateMdsMiniprogramTaskRequest): CreateMdsMiniprogramTaskResponse {
  var runtime = new $RuntimeOptions{};
  return createMdsMiniprogramTaskWithOptions(request, runtime);
}

model CreateOpenGlobalDataRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  appMaxVersion?: string(name='AppMaxVersion'),
  appMinVersion?: string(name='AppMinVersion'),
  bizType?: string(name='BizType', description='This parameter is required.'),
  extAttrStr?: string(name='ExtAttrStr'),
  maxUid?: long(name='MaxUid'),
  minUid?: long(name='MinUid'),
  osType?: string(name='OsType'),
  payload?: string(name='Payload', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdMsgId?: string(name='ThirdMsgId', description='This parameter is required.'),
  uids?: string(name='Uids'),
  validTimeEnd?: long(name='ValidTimeEnd'),
  validTimeStart?: long(name='ValidTimeStart'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CreateOpenGlobalDataResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateOpenGlobalDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOpenGlobalDataResponseBody(name='body'),
}

/**
 * @param request CreateOpenGlobalDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOpenGlobalDataResponse
 */
@context("createOpenGlobalDataWithContext")
async function createOpenGlobalDataWithOptions(request: CreateOpenGlobalDataRequest, runtime: $RuntimeOptions): CreateOpenGlobalDataResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.appMaxVersion)) {
    body['AppMaxVersion'] = request.appMaxVersion;
  }
  if (!$isNull(request.appMinVersion)) {
    body['AppMinVersion'] = request.appMinVersion;
  }
  if (!$isNull(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!$isNull(request.extAttrStr)) {
    body['ExtAttrStr'] = request.extAttrStr;
  }
  if (!$isNull(request.maxUid)) {
    body['MaxUid'] = request.maxUid;
  }
  if (!$isNull(request.minUid)) {
    body['MinUid'] = request.minUid;
  }
  if (!$isNull(request.osType)) {
    body['OsType'] = request.osType;
  }
  if (!$isNull(request.payload)) {
    body['Payload'] = request.payload;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.thirdMsgId)) {
    body['ThirdMsgId'] = request.thirdMsgId;
  }
  if (!$isNull(request.uids)) {
    body['Uids'] = request.uids;
  }
  if (!$isNull(request.validTimeEnd)) {
    body['ValidTimeEnd'] = request.validTimeEnd;
  }
  if (!$isNull(request.validTimeStart)) {
    body['ValidTimeStart'] = request.validTimeStart;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateOpenGlobalData',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateOpenGlobalDataRequest
 * @return CreateOpenGlobalDataResponse
 */
async function createOpenGlobalData(request: CreateOpenGlobalDataRequest): CreateOpenGlobalDataResponse {
  var runtime = new $RuntimeOptions{};
  return createOpenGlobalDataWithOptions(request, runtime);
}

model CreateOpenSingleDataRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  appMaxVersion?: string(name='AppMaxVersion'),
  appMinVersion?: string(name='AppMinVersion'),
  bizType?: string(name='BizType', description='This parameter is required.'),
  checkOnline?: boolean(name='CheckOnline'),
  extAttrStr?: string(name='ExtAttrStr'),
  linkToken?: string(name='LinkToken', description='This parameter is required.'),
  osType?: string(name='OsType'),
  payload?: string(name='Payload', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdMsgId?: string(name='ThirdMsgId', description='This parameter is required.'),
  validTimeEnd?: long(name='ValidTimeEnd'),
  validTimeStart?: long(name='ValidTimeStart'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model CreateOpenSingleDataResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateOpenSingleDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOpenSingleDataResponseBody(name='body'),
}

/**
 * @param request CreateOpenSingleDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOpenSingleDataResponse
 */
@context("createOpenSingleDataWithContext")
async function createOpenSingleDataWithOptions(request: CreateOpenSingleDataRequest, runtime: $RuntimeOptions): CreateOpenSingleDataResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.appMaxVersion)) {
    body['AppMaxVersion'] = request.appMaxVersion;
  }
  if (!$isNull(request.appMinVersion)) {
    body['AppMinVersion'] = request.appMinVersion;
  }
  if (!$isNull(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!$isNull(request.checkOnline)) {
    body['CheckOnline'] = request.checkOnline;
  }
  if (!$isNull(request.extAttrStr)) {
    body['ExtAttrStr'] = request.extAttrStr;
  }
  if (!$isNull(request.linkToken)) {
    body['LinkToken'] = request.linkToken;
  }
  if (!$isNull(request.osType)) {
    body['OsType'] = request.osType;
  }
  if (!$isNull(request.payload)) {
    body['Payload'] = request.payload;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.thirdMsgId)) {
    body['ThirdMsgId'] = request.thirdMsgId;
  }
  if (!$isNull(request.validTimeEnd)) {
    body['ValidTimeEnd'] = request.validTimeEnd;
  }
  if (!$isNull(request.validTimeStart)) {
    body['ValidTimeStart'] = request.validTimeStart;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateOpenSingleData',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request CreateOpenSingleDataRequest
 * @return CreateOpenSingleDataResponse
 */
async function createOpenSingleData(request: CreateOpenSingleDataRequest): CreateOpenSingleDataResponse {
  var runtime = new $RuntimeOptions{};
  return createOpenSingleDataWithOptions(request, runtime);
}

model DeleteCubecardWhitelistContentRequest {
  appId?: string(name='AppId'),
  tenantId?: string(name='TenantId'),
  whitelistId?: string(name='WhitelistId'),
  whitelistValue?: string(name='WhitelistValue'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteCubecardWhitelistContentResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteCubecardWhitelistContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCubecardWhitelistContentResponseBody(name='body'),
}

/**
 * @param request DeleteCubecardWhitelistContentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCubecardWhitelistContentResponse
 */
@context("deleteCubecardWhitelistContentWithContext")
async function deleteCubecardWhitelistContentWithOptions(request: DeleteCubecardWhitelistContentRequest, runtime: $RuntimeOptions): DeleteCubecardWhitelistContentResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.whitelistId)) {
    body['WhitelistId'] = request.whitelistId;
  }
  if (!$isNull(request.whitelistValue)) {
    body['WhitelistValue'] = request.whitelistValue;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteCubecardWhitelistContent',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteCubecardWhitelistContentRequest
 * @return DeleteCubecardWhitelistContentResponse
 */
async function deleteCubecardWhitelistContent(request: DeleteCubecardWhitelistContentRequest): DeleteCubecardWhitelistContentResponse {
  var runtime = new $RuntimeOptions{};
  return deleteCubecardWhitelistContentWithOptions(request, runtime);
}

model DeleteMcdpAimRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpAimDeleteJsonStr?: string(name='MpaasMappcenterMcdpAimDeleteJsonStr', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcdpAimResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcdpAimResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcdpAimResponseBody(name='body'),
}

/**
 * @param request DeleteMcdpAimRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMcdpAimResponse
 */
@context("deleteMcdpAimWithContext")
async function deleteMcdpAimWithOptions(request: DeleteMcdpAimRequest, runtime: $RuntimeOptions): DeleteMcdpAimResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.mpaasMappcenterMcdpAimDeleteJsonStr)) {
    body['MpaasMappcenterMcdpAimDeleteJsonStr'] = request.mpaasMappcenterMcdpAimDeleteJsonStr;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMcdpAim',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteMcdpAimRequest
 * @return DeleteMcdpAimResponse
 */
async function deleteMcdpAim(request: DeleteMcdpAimRequest): DeleteMcdpAimResponse {
  var runtime = new $RuntimeOptions{};
  return deleteMcdpAimWithOptions(request, runtime);
}

model DeleteMcdpCrowdRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpCrowdDeleteJsonStr?: string(name='MpaasMappcenterMcdpCrowdDeleteJsonStr', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcdpCrowdResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcdpCrowdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcdpCrowdResponseBody(name='body'),
}

/**
 * @param request DeleteMcdpCrowdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMcdpCrowdResponse
 */
@context("deleteMcdpCrowdWithContext")
async function deleteMcdpCrowdWithOptions(request: DeleteMcdpCrowdRequest, runtime: $RuntimeOptions): DeleteMcdpCrowdResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.mpaasMappcenterMcdpCrowdDeleteJsonStr)) {
    body['MpaasMappcenterMcdpCrowdDeleteJsonStr'] = request.mpaasMappcenterMcdpCrowdDeleteJsonStr;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMcdpCrowd',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteMcdpCrowdRequest
 * @return DeleteMcdpCrowdResponse
 */
async function deleteMcdpCrowd(request: DeleteMcdpCrowdRequest): DeleteMcdpCrowdResponse {
  var runtime = new $RuntimeOptions{};
  return deleteMcdpCrowdWithOptions(request, runtime);
}

model DeleteMcdpZoneRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMcdpZoneDeleteJsonStr?: string(name='MpaasMappcenterMcdpZoneDeleteJsonStr', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcdpZoneResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcdpZoneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcdpZoneResponseBody(name='body'),
}

/**
 * @param request DeleteMcdpZoneRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMcdpZoneResponse
 */
@context("deleteMcdpZoneWithContext")
async function deleteMcdpZoneWithOptions(request: DeleteMcdpZoneRequest, runtime: $RuntimeOptions): DeleteMcdpZoneResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.mpaasMappcenterMcdpZoneDeleteJsonStr)) {
    body['MpaasMappcenterMcdpZoneDeleteJsonStr'] = request.mpaasMappcenterMcdpZoneDeleteJsonStr;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMcdpZone',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteMcdpZoneRequest
 * @return DeleteMcdpZoneResponse
 */
async function deleteMcdpZone(request: DeleteMcdpZoneRequest): DeleteMcdpZoneResponse {
  var runtime = new $RuntimeOptions{};
  return deleteMcdpZoneWithOptions(request, runtime);
}

model DeleteMcubeMiniAppRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  h5Id?: string(name='H5Id', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model DeleteMcubeMiniAppResponseBody = {
  deleteMiniResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteMiniResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeMiniAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeMiniAppResponseBody(name='body'),
}

/**
 * @param request DeleteMcubeMiniAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMcubeMiniAppResponse
 */
@context("deleteMcubeMiniAppWithContext")
async function deleteMcubeMiniAppWithOptions(request: DeleteMcubeMiniAppRequest, runtime: $RuntimeOptions): DeleteMcubeMiniAppResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMcubeMiniApp',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteMcubeMiniAppRequest
 * @return DeleteMcubeMiniAppResponse
 */
async function deleteMcubeMiniApp(request: DeleteMcubeMiniAppRequest): DeleteMcubeMiniAppResponse {
  var runtime = new $RuntimeOptions{};
  return deleteMcubeMiniAppWithOptions(request, runtime);
}

model DeleteMcubeNebulaAppRequest {
  appId?: string(name='AppId'),
  h5Id?: string(name='H5Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcubeNebulaAppResponseBody = {
  deleteMcubeNebulaAppResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteMcubeNebulaAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeNebulaAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeNebulaAppResponseBody(name='body'),
}

/**
 * @param request DeleteMcubeNebulaAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMcubeNebulaAppResponse
 */
@context("deleteMcubeNebulaAppWithContext")
async function deleteMcubeNebulaAppWithOptions(request: DeleteMcubeNebulaAppRequest, runtime: $RuntimeOptions): DeleteMcubeNebulaAppResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMcubeNebulaApp',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteMcubeNebulaAppRequest
 * @return DeleteMcubeNebulaAppResponse
 */
async function deleteMcubeNebulaApp(request: DeleteMcubeNebulaAppRequest): DeleteMcubeNebulaAppResponse {
  var runtime = new $RuntimeOptions{};
  return deleteMcubeNebulaAppWithOptions(request, runtime);
}

model DeleteMcubeUpgradeResourceRequest {
  appId?: string(name='AppId'),
  id?: string(name='Id'),
  platform?: string(name='Platform'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMcubeUpgradeResourceResponseBody = {
  deleteResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeUpgradeResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeUpgradeResourceResponseBody(name='body'),
}

/**
 * @param request DeleteMcubeUpgradeResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMcubeUpgradeResourceResponse
 */
@context("deleteMcubeUpgradeResourceWithContext")
async function deleteMcubeUpgradeResourceWithOptions(request: DeleteMcubeUpgradeResourceRequest, runtime: $RuntimeOptions): DeleteMcubeUpgradeResourceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMcubeUpgradeResource',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteMcubeUpgradeResourceRequest
 * @return DeleteMcubeUpgradeResourceResponse
 */
async function deleteMcubeUpgradeResource(request: DeleteMcubeUpgradeResourceRequest): DeleteMcubeUpgradeResourceResponse {
  var runtime = new $RuntimeOptions{};
  return deleteMcubeUpgradeResourceWithOptions(request, runtime);
}

model DeleteMcubeWhitelistRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  id?: long(name='Id', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model DeleteMcubeWhitelistResponseBody = {
  deleteWhitelistResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeWhitelistResponseBody(name='body'),
}

/**
 * @param request DeleteMcubeWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMcubeWhitelistResponse
 */
@context("deleteMcubeWhitelistWithContext")
async function deleteMcubeWhitelistWithOptions(request: DeleteMcubeWhitelistRequest, runtime: $RuntimeOptions): DeleteMcubeWhitelistResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMcubeWhitelist',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteMcubeWhitelistRequest
 * @return DeleteMcubeWhitelistResponse
 */
async function deleteMcubeWhitelist(request: DeleteMcubeWhitelistRequest): DeleteMcubeWhitelistResponse {
  var runtime = new $RuntimeOptions{};
  return deleteMcubeWhitelistWithOptions(request, runtime);
}

model DeleteMdsWhitelistContentRequest {
  appId?: string(name='AppId'),
  tenantId?: string(name='TenantId'),
  whitelistId?: string(name='WhitelistId'),
  whitelistValue?: string(name='WhitelistValue'),
  workspaceId?: string(name='WorkspaceId'),
}

model DeleteMdsWhitelistContentResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMdsWhitelistContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMdsWhitelistContentResponseBody(name='body'),
}

/**
 * @param request DeleteMdsWhitelistContentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMdsWhitelistContentResponse
 */
@context("deleteMdsWhitelistContentWithContext")
async function deleteMdsWhitelistContentWithOptions(request: DeleteMdsWhitelistContentRequest, runtime: $RuntimeOptions): DeleteMdsWhitelistContentResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.whitelistId)) {
    body['WhitelistId'] = request.whitelistId;
  }
  if (!$isNull(request.whitelistValue)) {
    body['WhitelistValue'] = request.whitelistValue;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMdsWhitelistContent',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteMdsWhitelistContentRequest
 * @return DeleteMdsWhitelistContentResponse
 */
async function deleteMdsWhitelistContent(request: DeleteMdsWhitelistContentRequest): DeleteMdsWhitelistContentResponse {
  var runtime = new $RuntimeOptions{};
  return deleteMdsWhitelistContentWithOptions(request, runtime);
}

model ExistMcubeRsaKeyRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model ExistMcubeRsaKeyResponseBody = {
  checkRsaKeyResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CheckRsaKeyResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ExistMcubeRsaKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExistMcubeRsaKeyResponseBody(name='body'),
}

/**
 * @param request ExistMcubeRsaKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExistMcubeRsaKeyResponse
 */
@context("existMcubeRsaKeyWithContext")
async function existMcubeRsaKeyWithOptions(request: ExistMcubeRsaKeyRequest, runtime: $RuntimeOptions): ExistMcubeRsaKeyResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ExistMcubeRsaKey',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ExistMcubeRsaKeyRequest
 * @return ExistMcubeRsaKeyResponse
 */
async function existMcubeRsaKey(request: ExistMcubeRsaKeyRequest): ExistMcubeRsaKeyResponse {
  var runtime = new $RuntimeOptions{};
  return existMcubeRsaKeyWithOptions(request, runtime);
}

model ExportMappCenterAppConfigRequest {
  apkFileUrl?: string(name='ApkFileUrl'),
  appId?: string(name='AppId'),
  certRsaBase64?: string(name='CertRsaBase64'),
  identifier?: string(name='Identifier', description='This parameter is required.'),
  onexFlag?: boolean(name='OnexFlag', description='This parameter is required.'),
  systemType?: string(name='SystemType', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId'),
}

model ExportMappCenterAppConfigResponseBody = {
  exportMappCenterAppConfigResult?: {
    configDownloadUrl?: string(name='ConfigDownloadUrl'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ExportMappCenterAppConfigResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ExportMappCenterAppConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExportMappCenterAppConfigResponseBody(name='body'),
}

/**
 * @param request ExportMappCenterAppConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportMappCenterAppConfigResponse
 */
@context("exportMappCenterAppConfigWithContext")
async function exportMappCenterAppConfigWithOptions(request: ExportMappCenterAppConfigRequest, runtime: $RuntimeOptions): ExportMappCenterAppConfigResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.apkFileUrl)) {
    body['ApkFileUrl'] = request.apkFileUrl;
  }
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.certRsaBase64)) {
    body['CertRsaBase64'] = request.certRsaBase64;
  }
  if (!$isNull(request.identifier)) {
    body['Identifier'] = request.identifier;
  }
  if (!$isNull(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!$isNull(request.systemType)) {
    body['SystemType'] = request.systemType;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ExportMappCenterAppConfig',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ExportMappCenterAppConfigRequest
 * @return ExportMappCenterAppConfigResponse
 */
async function exportMappCenterAppConfig(request: ExportMappCenterAppConfigRequest): ExportMappCenterAppConfigResponse {
  var runtime = new $RuntimeOptions{};
  return exportMappCenterAppConfigWithOptions(request, runtime);
}

model GetFileTokenForUploadToMsaRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  onexFlag?: boolean(name='OnexFlag'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model GetFileTokenForUploadToMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    content?: {
      accessid?: string(name='Accessid'),
      dir?: string(name='Dir'),
      expire?: string(name='Expire'),
      host?: string(name='Host'),
      policy?: string(name='Policy'),
      signature?: string(name='Signature'),
    }(name='Content'),
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: string(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetFileTokenForUploadToMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFileTokenForUploadToMsaResponseBody(name='body'),
}

/**
 * @param request GetFileTokenForUploadToMsaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFileTokenForUploadToMsaResponse
 */
@context("getFileTokenForUploadToMsaWithContext")
async function getFileTokenForUploadToMsaWithOptions(request: GetFileTokenForUploadToMsaRequest, runtime: $RuntimeOptions): GetFileTokenForUploadToMsaResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetFileTokenForUploadToMsa',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetFileTokenForUploadToMsaRequest
 * @return GetFileTokenForUploadToMsaResponse
 */
async function getFileTokenForUploadToMsa(request: GetFileTokenForUploadToMsaRequest): GetFileTokenForUploadToMsaResponse {
  var runtime = new $RuntimeOptions{};
  return getFileTokenForUploadToMsaWithOptions(request, runtime);
}

model GetLogUrlInMsaRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  id?: long(name='Id'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model GetLogUrlInMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetLogUrlInMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLogUrlInMsaResponseBody(name='body'),
}

/**
 * @param request GetLogUrlInMsaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLogUrlInMsaResponse
 */
@context("getLogUrlInMsaWithContext")
async function getLogUrlInMsaWithOptions(request: GetLogUrlInMsaRequest, runtime: $RuntimeOptions): GetLogUrlInMsaResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetLogUrlInMsa',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetLogUrlInMsaRequest
 * @return GetLogUrlInMsaResponse
 */
async function getLogUrlInMsa(request: GetLogUrlInMsaRequest): GetLogUrlInMsaResponse {
  var runtime = new $RuntimeOptions{};
  return getLogUrlInMsaWithOptions(request, runtime);
}

model GetMcubeFileTokenRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  onexFlag?: boolean(name='OnexFlag', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model GetMcubeFileTokenResponseBody = {
  getFileTokenResult?: {
    fileToken?: {
      accessid?: string(name='Accessid'),
      dir?: string(name='Dir'),
      expire?: string(name='Expire'),
      host?: string(name='Host'),
      policy?: string(name='Policy'),
      signature?: string(name='Signature'),
    }(name='FileToken'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetFileTokenResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeFileTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeFileTokenResponseBody(name='body'),
}

/**
 * @param request GetMcubeFileTokenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMcubeFileTokenResponse
 */
@context("getMcubeFileTokenWithContext")
async function getMcubeFileTokenWithOptions(request: GetMcubeFileTokenRequest, runtime: $RuntimeOptions): GetMcubeFileTokenResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetMcubeFileToken',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMcubeFileTokenRequest
 * @return GetMcubeFileTokenResponse
 */
async function getMcubeFileToken(request: GetMcubeFileTokenRequest): GetMcubeFileTokenResponse {
  var runtime = new $RuntimeOptions{};
  return getMcubeFileTokenWithOptions(request, runtime);
}

model GetMcubeNebulaResourceRequest {
  appId?: string(name='AppId'),
  id?: string(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetMcubeNebulaResourceResponseBody = {
  getNebulaResourceResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaResourceInfo?: {
      appCode?: string(name='AppCode'),
      autoInstall?: int32(name='AutoInstall'),
      clientVersionMax?: string(name='ClientVersionMax'),
      clientVersionMin?: string(name='ClientVersionMin'),
      creator?: string(name='Creator'),
      downloadUrl?: string(name='DownloadUrl'),
      extendInfo?: string(name='ExtendInfo'),
      extraData?: string(name='ExtraData'),
      fallbackBaseUrl?: string(name='FallbackBaseUrl'),
      fileSize?: string(name='FileSize'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      h5Id?: string(name='H5Id'),
      h5Name?: string(name='H5Name'),
      h5Version?: string(name='H5Version'),
      id?: long(name='Id'),
      installType?: int32(name='InstallType'),
      mainUrl?: string(name='MainUrl'),
      memo?: string(name='Memo'),
      metaId?: long(name='MetaId'),
      modifier?: string(name='Modifier'),
      packageType?: int32(name='PackageType'),
      platform?: string(name='Platform'),
      publishPeriod?: int32(name='PublishPeriod'),
      resourceType?: string(name='ResourceType'),
      status?: int32(name='Status'),
      vhost?: string(name='Vhost'),
    }(name='NebulaResourceInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetNebulaResourceResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeNebulaResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeNebulaResourceResponseBody(name='body'),
}

/**
 * @param request GetMcubeNebulaResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMcubeNebulaResourceResponse
 */
@context("getMcubeNebulaResourceWithContext")
async function getMcubeNebulaResourceWithOptions(request: GetMcubeNebulaResourceRequest, runtime: $RuntimeOptions): GetMcubeNebulaResourceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetMcubeNebulaResource',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMcubeNebulaResourceRequest
 * @return GetMcubeNebulaResourceResponse
 */
async function getMcubeNebulaResource(request: GetMcubeNebulaResourceRequest): GetMcubeNebulaResourceResponse {
  var runtime = new $RuntimeOptions{};
  return getMcubeNebulaResourceWithOptions(request, runtime);
}

model GetMcubeNebulaTaskDetailRequest {
  appId?: string(name='AppId'),
  taskId?: long(name='TaskId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetMcubeNebulaTaskDetailResponseBody = {
  getMcubeNebulaTaskDetailResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaTaskDetail?: {
      appCode?: string(name='AppCode'),
      appId?: string(name='AppId'),
      atomic?: int32(name='Atomic'),
      baseInfoId?: long(name='BaseInfoId'),
      bizType?: string(name='BizType'),
      creator?: string(name='Creator'),
      cronexpress?: int32(name='Cronexpress'),
      downloadUrl?: string(name='DownloadUrl'),
      extraData?: string(name='ExtraData'),
      fileSize?: string(name='FileSize'),
      fullRepair?: int32(name='FullRepair'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      gmtModifiedStr?: string(name='GmtModifiedStr'),
      greyConfigInfo?: string(name='GreyConfigInfo'),
      greyEndtime?: string(name='GreyEndtime'),
      greyEndtimeData?: string(name='GreyEndtimeData'),
      greyEndtimeStr?: string(name='GreyEndtimeStr'),
      greyNum?: int32(name='GreyNum'),
      greyUrl?: string(name='GreyUrl'),
      id?: long(name='Id'),
      issueDesc?: string(name='IssueDesc'),
      memo?: string(name='Memo'),
      modifier?: string(name='Modifier'),
      ossPath?: string(name='OssPath'),
      packageId?: long(name='PackageId'),
      percent?: int32(name='Percent'),
      platform?: string(name='Platform'),
      productId?: string(name='ProductId'),
      productVersion?: string(name='ProductVersion'),
      publishMode?: int32(name='PublishMode'),
      publishPeriod?: int32(name='PublishPeriod'),
      publishType?: int32(name='PublishType'),
      quickRollback?: int32(name='QuickRollback'),
      releaseVersion?: string(name='ReleaseVersion'),
      ruleJsonList?: [ 
        {
          operation?: string(name='Operation'),
          ruleElement?: string(name='RuleElement'),
          ruleType?: string(name='RuleType'),
          value?: string(name='Value'),
        }
      ](name='RuleJsonList'),
      sourceId?: string(name='SourceId'),
      sourceName?: string(name='SourceName'),
      sourceType?: string(name='SourceType'),
      status?: int32(name='Status'),
      syncResult?: string(name='SyncResult'),
      syncType?: int32(name='SyncType'),
      taskName?: string(name='TaskName'),
      taskStatus?: int32(name='TaskStatus'),
      taskType?: int32(name='TaskType'),
      taskVersion?: long(name='TaskVersion'),
      upgradeNoticeNum?: long(name='UpgradeNoticeNum'),
      upgradeProgress?: string(name='UpgradeProgress'),
      whitelistIds?: string(name='WhitelistIds'),
      workspaceId?: string(name='WorkspaceId'),
    }(name='NebulaTaskDetail'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetMcubeNebulaTaskDetailResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeNebulaTaskDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeNebulaTaskDetailResponseBody(name='body'),
}

/**
 * @param request GetMcubeNebulaTaskDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMcubeNebulaTaskDetailResponse
 */
@context("getMcubeNebulaTaskDetailWithContext")
async function getMcubeNebulaTaskDetailWithOptions(request: GetMcubeNebulaTaskDetailRequest, runtime: $RuntimeOptions): GetMcubeNebulaTaskDetailResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetMcubeNebulaTaskDetail',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMcubeNebulaTaskDetailRequest
 * @return GetMcubeNebulaTaskDetailResponse
 */
async function getMcubeNebulaTaskDetail(request: GetMcubeNebulaTaskDetailRequest): GetMcubeNebulaTaskDetailResponse {
  var runtime = new $RuntimeOptions{};
  return getMcubeNebulaTaskDetailWithOptions(request, runtime);
}

model GetMcubeUpgradePackageInfoRequest {
  appId?: string(name='AppId'),
  packageId?: long(name='PackageId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetMcubeUpgradePackageInfoResponseBody = {
  getPackageResult?: {
    errorCode?: string(name='ErrorCode'),
    packageInfo?: {
      mobileTestFlightConfigDO?: {
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        installAmount?: int32(name='InstallAmount'),
        invalidTime?: string(name='InvalidTime'),
        upgradeId?: long(name='UpgradeId'),
      }(name='MobileTestFlightConfigDO'),
      upgradeBaseInfoDO?: {
        allowCreateTask?: boolean(name='AllowCreateTask'),
        appCode?: string(name='AppCode'),
        appstoreUrl?: string(name='AppstoreUrl'),
        backLog?: string(name='BackLog'),
        changeLog?: string(name='ChangeLog'),
        clientFileSize?: int32(name='ClientFileSize'),
        clientName?: string(name='ClientName'),
        cpId?: string(name='CpId'),
        creator?: string(name='Creator'),
        downloadUrl?: string(name='DownloadUrl'),
        globalVariables?: string(name='GlobalVariables'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateStr?: string(name='GmtCreateStr'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedStr?: string(name='GmtModifiedStr'),
        id?: long(name='Id'),
        innerVersion?: string(name='InnerVersion'),
        iosSymbol?: string(name='IosSymbol'),
        isEnterprise?: int32(name='IsEnterprise'),
        isRc?: int32(name='IsRc'),
        isRelease?: int32(name='IsRelease'),
        maxVersion?: string(name='MaxVersion'),
        md5?: string(name='Md5'),
        modifier?: string(name='Modifier'),
        needCheck?: int32(name='NeedCheck'),
        ossPath?: string(name='OssPath'),
        packageType?: string(name='PackageType'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productName?: string(name='ProductName'),
        productVersion?: string(name='ProductVersion'),
        publishPeriod?: int32(name='PublishPeriod'),
        qrcodeUrl?: string(name='QrcodeUrl'),
        releaseType?: string(name='ReleaseType'),
        releaseWindow?: string(name='ReleaseWindow'),
        scmDownloadUrl?: string(name='ScmDownloadUrl'),
        serverVersion?: int32(name='ServerVersion'),
        verificationCode?: string(name='VerificationCode'),
        verifyResult?: int32(name='VerifyResult'),
        versionCode?: string(name='VersionCode'),
      }(name='UpgradeBaseInfoDO'),
    }(name='PackageInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetPackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeUpgradePackageInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeUpgradePackageInfoResponseBody(name='body'),
}

/**
 * @param request GetMcubeUpgradePackageInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMcubeUpgradePackageInfoResponse
 */
@context("getMcubeUpgradePackageInfoWithContext")
async function getMcubeUpgradePackageInfoWithOptions(request: GetMcubeUpgradePackageInfoRequest, runtime: $RuntimeOptions): GetMcubeUpgradePackageInfoResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetMcubeUpgradePackageInfo',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMcubeUpgradePackageInfoRequest
 * @return GetMcubeUpgradePackageInfoResponse
 */
async function getMcubeUpgradePackageInfo(request: GetMcubeUpgradePackageInfoRequest): GetMcubeUpgradePackageInfoResponse {
  var runtime = new $RuntimeOptions{};
  return getMcubeUpgradePackageInfoWithOptions(request, runtime);
}

model GetMcubeUpgradeTaskInfoRequest {
  appId?: string(name='AppId'),
  taskId?: long(name='TaskId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model GetMcubeUpgradeTaskInfoResponseBody = {
  getTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    taskInfo?: {
      appCode?: string(name='AppCode'),
      appId?: string(name='AppId'),
      appstoreUrl?: string(name='AppstoreUrl'),
      creater?: string(name='Creater'),
      creator?: string(name='Creator'),
      downloadUrl?: string(name='DownloadUrl'),
      greyConfigInfo?: string(name='GreyConfigInfo'),
      greyEndtimeData?: string(name='GreyEndtimeData'),
      greyNum?: int32(name='GreyNum'),
      historyForce?: int32(name='HistoryForce'),
      id?: long(name='Id'),
      isEnterprise?: int32(name='IsEnterprise'),
      isOfficial?: int32(name='IsOfficial'),
      isRc?: int32(name='IsRc'),
      isRelease?: int32(name='IsRelease'),
      memo?: string(name='Memo'),
      modifier?: string(name='Modifier'),
      netType?: string(name='NetType'),
      osVersion?: string(name='OsVersion'),
      packageInfoId?: long(name='PackageInfoId'),
      packageType?: string(name='PackageType'),
      platform?: string(name='Platform'),
      productId?: string(name='ProductId'),
      publishMode?: int32(name='PublishMode'),
      publishType?: int32(name='PublishType'),
      pushContent?: string(name='PushContent'),
      qrcodeUrl?: string(name='QrcodeUrl'),
      ruleJsonList?: [ 
        {
          operation?: string(name='Operation'),
          ruleElement?: string(name='RuleElement'),
          ruleType?: string(name='RuleType'),
          value?: string(name='Value'),
        }
      ](name='RuleJsonList'),
      silentType?: int32(name='SilentType'),
      taskStatus?: int32(name='TaskStatus'),
      upgradeContent?: string(name='UpgradeContent'),
      upgradeType?: int32(name='UpgradeType'),
      upgradeValidTime?: int32(name='UpgradeValidTime'),
      whitelist?: [ 
        {
          appCode?: string(name='AppCode'),
          id?: long(name='Id'),
          idType?: string(name='IdType'),
          platform?: string(name='Platform'),
          status?: int32(name='Status'),
          userType?: string(name='UserType'),
          whiteListCount?: long(name='WhiteListCount'),
          whiteListName?: string(name='WhiteListName'),
          whitelistType?: string(name='WhitelistType'),
        }
      ](name='Whitelist'),
      whitelistIds?: string(name='WhitelistIds'),
      workspaceId?: string(name='WorkspaceId'),
    }(name='TaskInfo'),
  }(name='GetTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeUpgradeTaskInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeUpgradeTaskInfoResponseBody(name='body'),
}

/**
 * @param request GetMcubeUpgradeTaskInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMcubeUpgradeTaskInfoResponse
 */
@context("getMcubeUpgradeTaskInfoWithContext")
async function getMcubeUpgradeTaskInfoWithOptions(request: GetMcubeUpgradeTaskInfoRequest, runtime: $RuntimeOptions): GetMcubeUpgradeTaskInfoResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetMcubeUpgradeTaskInfo',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMcubeUpgradeTaskInfoRequest
 * @return GetMcubeUpgradeTaskInfoResponse
 */
async function getMcubeUpgradeTaskInfo(request: GetMcubeUpgradeTaskInfoRequest): GetMcubeUpgradeTaskInfoResponse {
  var runtime = new $RuntimeOptions{};
  return getMcubeUpgradeTaskInfoWithOptions(request, runtime);
}

model GetMdsMiniConfigRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  h5Id?: string(name='H5Id', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model GetMdsMiniConfigResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: {
        apiConfigList?: [ 
          {
            appCode?: string(name='AppCode'),
            configStatus?: long(name='ConfigStatus'),
            configType?: string(name='ConfigType'),
            configValue?: string(name='ConfigValue'),
            description?: string(name='Description'),
            gmtCreate?: string(name='GmtCreate'),
            gmtModified?: string(name='GmtModified'),
            h5Id?: string(name='H5Id'),
            h5Name?: string(name='H5Name'),
            id?: long(name='Id'),
          }
        ](name='ApiConfigList'),
        appCode?: string(name='AppCode'),
        enableServerDomainCount?: string(name='EnableServerDomainCount'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
        privilegeSwitch?: {
          appCode?: string(name='AppCode'),
          configStatus?: long(name='ConfigStatus'),
          configType?: string(name='ConfigType'),
          configValue?: string(name='ConfigValue'),
          description?: string(name='Description'),
          gmtCreate?: string(name='GmtCreate'),
          gmtModified?: string(name='GmtModified'),
          h5Id?: string(name='H5Id'),
          h5Name?: string(name='H5Name'),
          id?: long(name='Id'),
        }(name='PrivilegeSwitch'),
        serverDomainConfigList?: [ 
          {
            appCode?: string(name='AppCode'),
            configStatus?: long(name='ConfigStatus'),
            configType?: string(name='ConfigType'),
            configValue?: string(name='ConfigValue'),
            description?: string(name='Description'),
            gmtCreate?: string(name='GmtCreate'),
            gmtModified?: string(name='GmtModified'),
            h5Id?: string(name='H5Id'),
            h5Name?: string(name='H5Name'),
            id?: long(name='Id'),
          }
        ](name='ServerDomainConfigList'),
        webviewDomainConfigList?: [ 
          {
            appCode?: string(name='AppCode'),
            configStatus?: long(name='ConfigStatus'),
            configType?: string(name='ConfigType'),
            configValue?: string(name='ConfigValue'),
            description?: string(name='Description'),
            gmtCreate?: string(name='GmtCreate'),
            gmtModified?: string(name='GmtModified'),
            h5Id?: string(name='H5Id'),
            h5Name?: string(name='H5Name'),
            id?: long(name='Id'),
          }
        ](name='WebviewDomainConfigList'),
      }(name='Content'),
      requestId?: string(name='RequestId'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMdsMiniConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMdsMiniConfigResponseBody(name='body'),
}

/**
 * @param request GetMdsMiniConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMdsMiniConfigResponse
 */
@context("getMdsMiniConfigWithContext")
async function getMdsMiniConfigWithOptions(request: GetMdsMiniConfigRequest, runtime: $RuntimeOptions): GetMdsMiniConfigResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetMdsMiniConfig',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetMdsMiniConfigRequest
 * @return GetMdsMiniConfigResponse
 */
async function getMdsMiniConfig(request: GetMdsMiniConfigRequest): GetMdsMiniConfigResponse {
  var runtime = new $RuntimeOptions{};
  return getMdsMiniConfigWithOptions(request, runtime);
}

model GetUserAppDonwloadUrlInMsaRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  id?: long(name='Id', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model GetUserAppDonwloadUrlInMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: {
      filename?: string(name='Filename'),
      url?: string(name='Url'),
    }(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetUserAppDonwloadUrlInMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserAppDonwloadUrlInMsaResponseBody(name='body'),
}

/**
 * @param request GetUserAppDonwloadUrlInMsaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetUserAppDonwloadUrlInMsaResponse
 */
@context("getUserAppDonwloadUrlInMsaWithContext")
async function getUserAppDonwloadUrlInMsaWithOptions(request: GetUserAppDonwloadUrlInMsaRequest, runtime: $RuntimeOptions): GetUserAppDonwloadUrlInMsaResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetUserAppDonwloadUrlInMsa',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetUserAppDonwloadUrlInMsaRequest
 * @return GetUserAppDonwloadUrlInMsaResponse
 */
async function getUserAppDonwloadUrlInMsa(request: GetUserAppDonwloadUrlInMsaRequest): GetUserAppDonwloadUrlInMsaResponse {
  var runtime = new $RuntimeOptions{};
  return getUserAppDonwloadUrlInMsaWithOptions(request, runtime);
}

model GetUserAppEnhanceProcessInMsaRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  id?: long(name='Id', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model GetUserAppEnhanceProcessInMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: {
      afterMd5?: string(name='AfterMd5'),
      afterSize?: long(name='AfterSize'),
      appCode?: string(name='AppCode'),
      appPackage?: string(name='AppPackage'),
      assetsFileList?: [ string ](name='AssetsFileList'),
      beforeMd5?: string(name='BeforeMd5'),
      beforeSize?: long(name='BeforeSize'),
      classForest?: [ string ](name='ClassForest'),
      enhanceMapping?: [ 
        {
          info?: string(name='Info'),
          reason?: string(name='Reason'),
          type?: string(name='Type'),
        }
      ](name='EnhanceMapping'),
      enhanceRules?: [ string ](name='EnhanceRules'),
      enhancedAssetsFiles?: [ string ](name='EnhancedAssetsFiles'),
      enhancedClasses?: [ string ](name='EnhancedClasses'),
      enhancedSoFiles?: [ string ](name='EnhancedSoFiles'),
      id?: long(name='Id'),
      label?: string(name='Label'),
      progress?: long(name='Progress'),
      soFileList?: [ string ](name='SoFileList'),
      status?: long(name='Status'),
      taskType?: string(name='TaskType'),
      versionCode?: string(name='VersionCode'),
      versionName?: string(name='VersionName'),
    }(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetUserAppEnhanceProcessInMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserAppEnhanceProcessInMsaResponseBody(name='body'),
}

/**
 * @param request GetUserAppEnhanceProcessInMsaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetUserAppEnhanceProcessInMsaResponse
 */
@context("getUserAppEnhanceProcessInMsaWithContext")
async function getUserAppEnhanceProcessInMsaWithOptions(request: GetUserAppEnhanceProcessInMsaRequest, runtime: $RuntimeOptions): GetUserAppEnhanceProcessInMsaResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetUserAppEnhanceProcessInMsa',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetUserAppEnhanceProcessInMsaRequest
 * @return GetUserAppEnhanceProcessInMsaResponse
 */
async function getUserAppEnhanceProcessInMsa(request: GetUserAppEnhanceProcessInMsaRequest): GetUserAppEnhanceProcessInMsaResponse {
  var runtime = new $RuntimeOptions{};
  return getUserAppEnhanceProcessInMsaWithOptions(request, runtime);
}

model GetUserAppUploadProcessInMsaRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  id?: long(name='Id', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model GetUserAppUploadProcessInMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: {
      apkInfo?: {
        afterMd5?: string(name='AfterMd5'),
        afterSize?: long(name='AfterSize'),
        appCode?: string(name='AppCode'),
        appPackage?: string(name='AppPackage'),
        assetsFileList?: [ string ](name='AssetsFileList'),
        beforeMd5?: string(name='BeforeMd5'),
        beforeSize?: long(name='BeforeSize'),
        classForest?: string(name='ClassForest'),
        enhanceMapping?: [ 
          {
            info?: string(name='Info'),
            reason?: string(name='Reason'),
            type?: string(name='Type'),
          }
        ](name='EnhanceMapping'),
        enhanceRules?: [ string ](name='EnhanceRules'),
        enhancedAssetsFiles?: [ string ](name='EnhancedAssetsFiles'),
        enhancedClasses?: [ string ](name='EnhancedClasses'),
        enhancedSoFiles?: [ string ](name='EnhancedSoFiles'),
        id?: long(name='Id'),
        label?: string(name='Label'),
        progress?: long(name='Progress'),
        soFileList?: [ string ](name='SoFileList'),
        status?: long(name='Status'),
        taskType?: string(name='TaskType'),
        versionCode?: string(name='VersionCode'),
        versionName?: string(name='VersionName'),
      }(name='ApkInfo'),
      enhanceTaskId?: long(name='EnhanceTaskId'),
      id?: long(name='Id'),
      progress?: long(name='Progress'),
      status?: long(name='Status'),
    }(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetUserAppUploadProcessInMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserAppUploadProcessInMsaResponseBody(name='body'),
}

/**
 * @param request GetUserAppUploadProcessInMsaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetUserAppUploadProcessInMsaResponse
 */
@context("getUserAppUploadProcessInMsaWithContext")
async function getUserAppUploadProcessInMsaWithOptions(request: GetUserAppUploadProcessInMsaRequest, runtime: $RuntimeOptions): GetUserAppUploadProcessInMsaResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetUserAppUploadProcessInMsa',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetUserAppUploadProcessInMsaRequest
 * @return GetUserAppUploadProcessInMsaResponse
 */
async function getUserAppUploadProcessInMsa(request: GetUserAppUploadProcessInMsaRequest): GetUserAppUploadProcessInMsaResponse {
  var runtime = new $RuntimeOptions{};
  return getUserAppUploadProcessInMsaWithOptions(request, runtime);
}

model ListMappCenterAppsResponseBody = {
  listMappCenterAppResult?: {
    mappCenterAppList?: [ 
      {
        androidConfig?: {
          certRSA?: string(name='CertRSA'),
          packageName?: string(name='PackageName'),
        }(name='AndroidConfig'),
        appDesc?: string(name='AppDesc'),
        appIcon?: string(name='AppIcon'),
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        appSecret?: string(name='AppSecret'),
        creator?: string(name='Creator'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        iosConfig?: {
          bundleId?: string(name='BundleId'),
        }(name='IosConfig'),
        modifier?: string(name='Modifier'),
        monitorJson?: string(name='MonitorJson'),
        status?: long(name='Status'),
        tenantId?: string(name='TenantId'),
        type?: long(name='Type'),
      }
    ](name='MappCenterAppList'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMappCenterAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMappCenterAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMappCenterAppsResponseBody(name='body'),
}

/**
 * @param request ListMappCenterAppsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMappCenterAppsResponse
 */
async function listMappCenterAppsWithOptions(runtime: $RuntimeOptions): ListMappCenterAppsResponse {
  var req = new OpenApiUtil.OpenApiRequest{};
  var params = new OpenApiUtil.Params{
    action = 'ListMappCenterApps',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return ListMappCenterAppsResponse
 */
async function listMappCenterApps(): ListMappCenterAppsResponse {
  var runtime = new $RuntimeOptions{};
  return listMappCenterAppsWithOptions(runtime);
}

model ListMappCenterWorkspacesResponseBody = {
  listMappCenterWorkspaceResult?: {
    mappCenterWorkspaceList?: [ 
      {
        compatibleId?: string(name='CompatibleId'),
        createTime?: string(name='CreateTime'),
        displayName?: string(name='DisplayName'),
        id?: string(name='Id'),
        region?: string(name='Region'),
        status?: string(name='Status'),
        tenantId?: string(name='TenantId'),
        type?: string(name='Type'),
        uid?: long(name='Uid'),
        updateTime?: string(name='UpdateTime'),
        workspaceId?: string(name='WorkspaceId'),
        zones?: string(name='Zones'),
      }
    ](name='MappCenterWorkspaceList'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    userId?: string(name='UserId'),
  }(name='ListMappCenterWorkspaceResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMappCenterWorkspacesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMappCenterWorkspacesResponseBody(name='body'),
}

/**
 * @param request ListMappCenterWorkspacesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMappCenterWorkspacesResponse
 */
async function listMappCenterWorkspacesWithOptions(runtime: $RuntimeOptions): ListMappCenterWorkspacesResponse {
  var req = new OpenApiUtil.OpenApiRequest{};
  var params = new OpenApiUtil.Params{
    action = 'ListMappCenterWorkspaces',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @return ListMappCenterWorkspacesResponse
 */
async function listMappCenterWorkspaces(): ListMappCenterWorkspacesResponse {
  var runtime = new $RuntimeOptions{};
  return listMappCenterWorkspacesWithOptions(runtime);
}

model ListMcdpAimRequest {
  appId?: string(name='AppId'),
  emptyTag?: string(name='EmptyTag'),
  keyword?: string(name='Keyword'),
  name?: string(name='Name'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
  sort?: string(name='Sort'),
  sortField?: string(name='SortField'),
  tenantId?: string(name='TenantId'),
  type?: string(name='Type'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcdpAimResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcdpAimResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcdpAimResponseBody(name='body'),
}

/**
 * @param request ListMcdpAimRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcdpAimResponse
 */
@context("listMcdpAimWithContext")
async function listMcdpAimWithOptions(request: ListMcdpAimRequest, runtime: $RuntimeOptions): ListMcdpAimResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.emptyTag)) {
    body['EmptyTag'] = request.emptyTag;
  }
  if (!$isNull(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }
  if (!$isNull(request.pageNo)) {
    body['PageNo'] = request.pageNo;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.sort)) {
    body['Sort'] = request.sort;
  }
  if (!$isNull(request.sortField)) {
    body['SortField'] = request.sortField;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcdpAim',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcdpAimRequest
 * @return ListMcdpAimResponse
 */
async function listMcdpAim(request: ListMcdpAimRequest): ListMcdpAimResponse {
  var runtime = new $RuntimeOptions{};
  return listMcdpAimWithOptions(request, runtime);
}

model ListMcubeMiniAppsRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  keyword?: string(name='Keyword'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model ListMcubeMiniAppsResponseBody = {
  listMiniResult?: {
    currentPage?: int32(name='CurrentPage'),
    hasMore?: boolean(name='HasMore'),
    miniProgramList?: [ 
      {
        appCode?: string(name='AppCode'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
      }
    ](name='MiniProgramList'),
    pageSize?: int32(name='PageSize'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMiniResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeMiniAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeMiniAppsResponseBody(name='body'),
}

/**
 * @param request ListMcubeMiniAppsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeMiniAppsResponse
 */
@context("listMcubeMiniAppsWithContext")
async function listMcubeMiniAppsWithOptions(request: ListMcubeMiniAppsRequest, runtime: $RuntimeOptions): ListMcubeMiniAppsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!$isNull(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeMiniApps',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeMiniAppsRequest
 * @return ListMcubeMiniAppsResponse
 */
async function listMcubeMiniApps(request: ListMcubeMiniAppsRequest): ListMcubeMiniAppsResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeMiniAppsWithOptions(request, runtime);
}

model ListMcubeMiniPackagesRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  h5Id?: string(name='H5Id', description='This parameter is required.'),
  packageTypes?: string(name='PackageTypes', description='This parameter is required.'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model ListMcubeMiniPackagesResponseBody = {
  listMiniPackageResult?: {
    currentPage?: int32(name='CurrentPage'),
    hasMore?: boolean(name='HasMore'),
    miniPackageList?: [ 
      {
        appCode?: string(name='AppCode'),
        autoInstall?: long(name='AutoInstall'),
        clientVersionMax?: string(name='ClientVersionMax'),
        clientVersionMin?: string(name='ClientVersionMin'),
        downloadUrl?: string(name='DownloadUrl'),
        extendInfo?: string(name='ExtendInfo'),
        extraData?: string(name='ExtraData'),
        fallbackBaseUrl?: string(name='FallbackBaseUrl'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
        h5Version?: string(name='H5Version'),
        id?: long(name='Id'),
        installType?: long(name='InstallType'),
        mainUrl?: string(name='MainUrl'),
        memo?: string(name='Memo'),
        packageType?: long(name='PackageType'),
        platform?: string(name='Platform'),
        publishPeriod?: long(name='PublishPeriod'),
        resourceType?: long(name='ResourceType'),
        status?: long(name='Status'),
      }
    ](name='MiniPackageList'),
    pageSize?: int32(name='PageSize'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMiniPackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeMiniPackagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeMiniPackagesResponseBody(name='body'),
}

/**
 * @param request ListMcubeMiniPackagesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeMiniPackagesResponse
 */
@context("listMcubeMiniPackagesWithContext")
async function listMcubeMiniPackagesWithOptions(request: ListMcubeMiniPackagesRequest, runtime: $RuntimeOptions): ListMcubeMiniPackagesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.packageTypes)) {
    body['PackageTypes'] = request.packageTypes;
  }
  if (!$isNull(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeMiniPackages',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeMiniPackagesRequest
 * @return ListMcubeMiniPackagesResponse
 */
async function listMcubeMiniPackages(request: ListMcubeMiniPackagesRequest): ListMcubeMiniPackagesResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeMiniPackagesWithOptions(request, runtime);
}

model ListMcubeMiniTasksRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  id?: string(name='Id', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model ListMcubeMiniTasksResponseBody = {
  listMiniTaskResult?: {
    miniTaskList?: [ 
      {
        appCode?: string(name='AppCode'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtime?: string(name='GreyEndtime'),
        greyEndtimeData?: string(name='GreyEndtimeData'),
        greyNum?: long(name='GreyNum'),
        id?: long(name='Id'),
        memo?: string(name='Memo'),
        packageId?: long(name='PackageId'),
        platform?: string(name='Platform'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: long(name='PublishMode'),
        publishType?: long(name='PublishType'),
        status?: string(name='Status'),
        taskStatus?: long(name='TaskStatus'),
        whitelistIds?: string(name='WhitelistIds'),
      }
    ](name='MiniTaskList'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMiniTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeMiniTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeMiniTasksResponseBody(name='body'),
}

/**
 * @param request ListMcubeMiniTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeMiniTasksResponse
 */
@context("listMcubeMiniTasksWithContext")
async function listMcubeMiniTasksWithOptions(request: ListMcubeMiniTasksRequest, runtime: $RuntimeOptions): ListMcubeMiniTasksResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeMiniTasks',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeMiniTasksRequest
 * @return ListMcubeMiniTasksResponse
 */
async function listMcubeMiniTasks(request: ListMcubeMiniTasksRequest): ListMcubeMiniTasksResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeMiniTasksWithOptions(request, runtime);
}

model ListMcubeNebulaAppsRequest {
  appId?: string(name='AppId'),
  keyword?: string(name='Keyword'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeNebulaAppsResponseBody = {
  listMcubeNebulaAppsResult?: {
    currentPage?: int32(name='CurrentPage'),
    errorCode?: string(name='ErrorCode'),
    hasMore?: boolean(name='HasMore'),
    nebulaAppInfos?: [ 
      {
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
      }
    ](name='NebulaAppInfos'),
    pageSize?: int32(name='PageSize'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMcubeNebulaAppsResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeNebulaAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeNebulaAppsResponseBody(name='body'),
}

/**
 * @param request ListMcubeNebulaAppsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeNebulaAppsResponse
 */
@context("listMcubeNebulaAppsWithContext")
async function listMcubeNebulaAppsWithOptions(request: ListMcubeNebulaAppsRequest, runtime: $RuntimeOptions): ListMcubeNebulaAppsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!$isNull(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeNebulaApps',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeNebulaAppsRequest
 * @return ListMcubeNebulaAppsResponse
 */
async function listMcubeNebulaApps(request: ListMcubeNebulaAppsRequest): ListMcubeNebulaAppsResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeNebulaAppsWithOptions(request, runtime);
}

model ListMcubeNebulaResourcesRequest {
  appId?: string(name='AppId'),
  h5Id?: string(name='H5Id'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeNebulaResourcesResponseBody = {
  listMcubeNebulaResourceResult?: {
    currentPage?: int32(name='CurrentPage'),
    errorCode?: string(name='ErrorCode'),
    hasMore?: boolean(name='HasMore'),
    nebulaResourceInfo?: [ 
      {
        appCode?: string(name='AppCode'),
        autoInstall?: int32(name='AutoInstall'),
        clientVersionMax?: string(name='ClientVersionMax'),
        clientVersionMin?: string(name='ClientVersionMin'),
        creator?: string(name='Creator'),
        debugUrl?: string(name='DebugUrl'),
        downloadUrl?: string(name='DownloadUrl'),
        extendInfo?: string(name='ExtendInfo'),
        extraData?: string(name='ExtraData'),
        fallbackBaseUrl?: string(name='FallbackBaseUrl'),
        fileSize?: string(name='FileSize'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
        h5Version?: string(name='H5Version'),
        id?: long(name='Id'),
        installType?: int32(name='InstallType'),
        lazyLoad?: int32(name='LazyLoad'),
        mainUrl?: string(name='MainUrl'),
        md5?: string(name='Md5'),
        memo?: string(name='Memo'),
        metaId?: long(name='MetaId'),
        modifier?: string(name='Modifier'),
        packageType?: int32(name='PackageType'),
        platform?: string(name='Platform'),
        publishPeriod?: int32(name='PublishPeriod'),
        releaseVersion?: string(name='ReleaseVersion'),
        resourceType?: string(name='ResourceType'),
        status?: int32(name='Status'),
        vhost?: string(name='Vhost'),
      }
    ](name='NebulaResourceInfo'),
    pageSize?: int32(name='PageSize'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMcubeNebulaResourceResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeNebulaResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeNebulaResourcesResponseBody(name='body'),
}

/**
 * @param request ListMcubeNebulaResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeNebulaResourcesResponse
 */
@context("listMcubeNebulaResourcesWithContext")
async function listMcubeNebulaResourcesWithOptions(request: ListMcubeNebulaResourcesRequest, runtime: $RuntimeOptions): ListMcubeNebulaResourcesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeNebulaResources',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeNebulaResourcesRequest
 * @return ListMcubeNebulaResourcesResponse
 */
async function listMcubeNebulaResources(request: ListMcubeNebulaResourcesRequest): ListMcubeNebulaResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeNebulaResourcesWithOptions(request, runtime);
}

model ListMcubeNebulaTasksRequest {
  appId?: string(name='AppId'),
  id?: long(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeNebulaTasksResponseBody = {
  listMcubeNebulaTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaTaskInfo?: [ 
      {
        appCode?: string(name='AppCode'),
        bizType?: string(name='BizType'),
        creator?: string(name='Creator'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedStr?: string(name='GmtModifiedStr'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtime?: string(name='GreyEndtime'),
        greyEndtimeData?: string(name='GreyEndtimeData'),
        greyEndtimeStr?: string(name='GreyEndtimeStr'),
        greyNum?: int32(name='GreyNum'),
        greyUrl?: string(name='GreyUrl'),
        id?: long(name='Id'),
        memo?: string(name='Memo'),
        modifier?: string(name='Modifier'),
        packageId?: long(name='PackageId'),
        percent?: int32(name='Percent'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: int32(name='PublishMode'),
        publishType?: int32(name='PublishType'),
        releaseVersion?: string(name='ReleaseVersion'),
        status?: int32(name='Status'),
        syncResult?: string(name='SyncResult'),
        taskName?: string(name='TaskName'),
        taskStatus?: int32(name='TaskStatus'),
        taskType?: int32(name='TaskType'),
        taskVersion?: long(name='TaskVersion'),
        upgradeNoticeNum?: long(name='UpgradeNoticeNum'),
        upgradeProgress?: string(name='UpgradeProgress'),
        whitelistIds?: string(name='WhitelistIds'),
      }
    ](name='NebulaTaskInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMcubeNebulaTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeNebulaTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeNebulaTasksResponseBody(name='body'),
}

/**
 * @param request ListMcubeNebulaTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeNebulaTasksResponse
 */
@context("listMcubeNebulaTasksWithContext")
async function listMcubeNebulaTasksWithOptions(request: ListMcubeNebulaTasksRequest, runtime: $RuntimeOptions): ListMcubeNebulaTasksResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeNebulaTasks',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeNebulaTasksRequest
 * @return ListMcubeNebulaTasksResponse
 */
async function listMcubeNebulaTasks(request: ListMcubeNebulaTasksRequest): ListMcubeNebulaTasksResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeNebulaTasksWithOptions(request, runtime);
}

model ListMcubeUpgradePackagesRequest {
  appId?: string(name='AppId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeUpgradePackagesResponseBody = {
  listPackagesResult?: {
    currentPage?: int32(name='CurrentPage'),
    errorCode?: string(name='ErrorCode'),
    hasMore?: boolean(name='HasMore'),
    packages?: [ 
      {
        allowCreateTask?: boolean(name='AllowCreateTask'),
        appCode?: string(name='AppCode'),
        appstoreUrl?: string(name='AppstoreUrl'),
        backLog?: string(name='BackLog'),
        changeLog?: string(name='ChangeLog'),
        clientFileSize?: int32(name='ClientFileSize'),
        clientName?: string(name='ClientName'),
        cpId?: string(name='CpId'),
        creator?: string(name='Creator'),
        downloadUrl?: string(name='DownloadUrl'),
        globalVariables?: string(name='GlobalVariables'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateStr?: string(name='GmtCreateStr'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedStr?: string(name='GmtModifiedStr'),
        id?: long(name='Id'),
        innerVersion?: string(name='InnerVersion'),
        iosSymbol?: string(name='IosSymbol'),
        isEnterprise?: int32(name='IsEnterprise'),
        isRc?: int32(name='IsRc'),
        isRelease?: int32(name='IsRelease'),
        maxVersion?: string(name='MaxVersion'),
        md5?: string(name='Md5'),
        modifier?: string(name='Modifier'),
        needCheck?: int32(name='NeedCheck'),
        ossPath?: string(name='OssPath'),
        packageType?: string(name='PackageType'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productName?: string(name='ProductName'),
        productVersion?: string(name='ProductVersion'),
        publishPeriod?: int32(name='PublishPeriod'),
        qrcodeUrl?: string(name='QrcodeUrl'),
        releaseType?: string(name='ReleaseType'),
        releaseWindow?: string(name='ReleaseWindow'),
        scmDownloadUrl?: string(name='ScmDownloadUrl'),
        serverVersion?: int32(name='ServerVersion'),
        verificationCode?: string(name='VerificationCode'),
        verifyResult?: int32(name='VerifyResult'),
        versionCode?: string(name='VersionCode'),
      }
    ](name='Packages'),
    pageSize?: int32(name='PageSize'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListPackagesResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeUpgradePackagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeUpgradePackagesResponseBody(name='body'),
}

/**
 * @param request ListMcubeUpgradePackagesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeUpgradePackagesResponse
 */
@context("listMcubeUpgradePackagesWithContext")
async function listMcubeUpgradePackagesWithOptions(request: ListMcubeUpgradePackagesRequest, runtime: $RuntimeOptions): ListMcubeUpgradePackagesResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeUpgradePackages',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeUpgradePackagesRequest
 * @return ListMcubeUpgradePackagesResponse
 */
async function listMcubeUpgradePackages(request: ListMcubeUpgradePackagesRequest): ListMcubeUpgradePackagesResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeUpgradePackagesWithOptions(request, runtime);
}

model ListMcubeUpgradeTasksRequest {
  appId?: string(name='AppId'),
  packageId?: string(name='PackageId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMcubeUpgradeTasksResponseBody = {
  listTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    taskInfo?: [ 
      {
        appCode?: string(name='AppCode'),
        creator?: string(name='Creator'),
        devicePercent?: int32(name='DevicePercent'),
        executionOrder?: int32(name='ExecutionOrder'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateStr?: string(name='GmtCreateStr'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedStr?: string(name='GmtModifiedStr'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtime?: string(name='GreyEndtime'),
        greyNotice?: int32(name='GreyNotice'),
        greyNum?: int32(name='GreyNum'),
        greyPausePoint?: int32(name='GreyPausePoint'),
        greyPauseType?: int32(name='GreyPauseType'),
        greyUv?: int32(name='GreyUv'),
        historyForce?: int32(name='HistoryForce'),
        huobanNoticeId?: string(name='HuobanNoticeId'),
        huobanUrl?: string(name='HuobanUrl'),
        id?: long(name='Id'),
        innerVersion?: string(name='InnerVersion'),
        isEnterprise?: int32(name='IsEnterprise'),
        isOfficial?: int32(name='IsOfficial'),
        isPush?: int32(name='IsPush'),
        isRelease?: int32(name='IsRelease'),
        maxVersion?: string(name='MaxVersion'),
        memo?: string(name='Memo'),
        modifier?: string(name='Modifier'),
        packageInfoId?: long(name='PackageInfoId'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: int32(name='PublishMode'),
        publishType?: int32(name='PublishType'),
        pushContent?: string(name='PushContent'),
        realGreyEndtime?: string(name='RealGreyEndtime'),
        realGreyEndtimeStr?: string(name='RealGreyEndtimeStr'),
        realGreyEndtype?: int32(name='RealGreyEndtype'),
        realGreyNum?: int32(name='RealGreyNum'),
        realGreyUv?: int32(name='RealGreyUv'),
        silentType?: int32(name='SilentType'),
        syncResult?: string(name='SyncResult'),
        taskStatus?: int32(name='TaskStatus'),
        upgradeContent?: string(name='UpgradeContent'),
        upgradeType?: int32(name='UpgradeType'),
        upgradeValidTime?: int32(name='UpgradeValidTime'),
        whitelistIds?: string(name='WhitelistIds'),
      }
    ](name='TaskInfo'),
  }(name='ListTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeUpgradeTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeUpgradeTasksResponseBody(name='body'),
}

/**
 * @param request ListMcubeUpgradeTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeUpgradeTasksResponse
 */
@context("listMcubeUpgradeTasksWithContext")
async function listMcubeUpgradeTasksWithOptions(request: ListMcubeUpgradeTasksRequest, runtime: $RuntimeOptions): ListMcubeUpgradeTasksResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.packageId)) {
    body['PackageId'] = request.packageId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeUpgradeTasks',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeUpgradeTasksRequest
 * @return ListMcubeUpgradeTasksResponse
 */
async function listMcubeUpgradeTasks(request: ListMcubeUpgradeTasksRequest): ListMcubeUpgradeTasksResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeUpgradeTasksWithOptions(request, runtime);
}

model ListMcubeWhitelistsRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  whitelistName?: string(name='WhitelistName'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model ListMcubeWhitelistsResponseBody = {
  listWhitelistResult?: {
    currentPage?: int32(name='CurrentPage'),
    hasMore?: boolean(name='HasMore'),
    pageSize?: int32(name='PageSize'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
    whitelists?: [ 
      {
        appCode?: string(name='AppCode'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        whiteListCount?: long(name='WhiteListCount'),
        whiteListName?: string(name='WhiteListName'),
        whitelistType?: string(name='WhitelistType'),
      }
    ](name='Whitelists'),
  }(name='ListWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeWhitelistsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeWhitelistsResponseBody(name='body'),
}

/**
 * @param request ListMcubeWhitelistsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMcubeWhitelistsResponse
 */
@context("listMcubeWhitelistsWithContext")
async function listMcubeWhitelistsWithOptions(request: ListMcubeWhitelistsRequest, runtime: $RuntimeOptions): ListMcubeWhitelistsResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.whitelistName)) {
    body['WhitelistName'] = request.whitelistName;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMcubeWhitelists',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMcubeWhitelistsRequest
 * @return ListMcubeWhitelistsResponse
 */
async function listMcubeWhitelists(request: ListMcubeWhitelistsRequest): ListMcubeWhitelistsResponse {
  var runtime = new $RuntimeOptions{};
  return listMcubeWhitelistsWithOptions(request, runtime);
}

model ListMgsApiRequest {
  apiStatus?: string(name='ApiStatus'),
  apiType?: string(name='ApiType'),
  appId?: string(name='AppId'),
  format?: string(name='Format'),
  host?: string(name='Host'),
  needEncrypt?: string(name='NeedEncrypt'),
  needEtag?: string(name='NeedEtag'),
  needSign?: string(name='NeedSign'),
  operationType?: string(name='OperationType'),
  optFuzzy?: string(name='OptFuzzy'),
  pageIndex?: long(name='PageIndex'),
  pageSize?: long(name='PageSize'),
  sysId?: long(name='SysId'),
  sysName?: string(name='SysName'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMgsApiResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    errorMessage?: string(name='ErrorMessage'),
    success?: boolean(name='Success'),
    value?: [ 
      {
        apiInvoker?: {
          httpInvoker?: {
            charset?: string(name='Charset'),
            contentType?: string(name='ContentType'),
            host?: string(name='Host'),
            method?: string(name='Method'),
            path?: string(name='Path'),
          }(name='HttpInvoker'),
          rpcInvoker?: string(name='RpcInvoker'),
        }(name='ApiInvoker'),
        apiName?: string(name='ApiName'),
        apiStatus?: string(name='ApiStatus'),
        apiType?: string(name='ApiType'),
        appId?: string(name='AppId'),
        authRuleName?: string(name='AuthRuleName'),
        cacheRule?: {
          cacheKey?: string(name='CacheKey'),
          needCache?: boolean(name='NeedCache'),
          ttl?: long(name='Ttl'),
        }(name='CacheRule'),
        charset?: string(name='Charset'),
        circuitBreakerRule?: {
          appId?: string(name='AppId'),
          defaultResponse?: string(name='DefaultResponse'),
          errorThreshold?: long(name='ErrorThreshold'),
          id?: long(name='Id'),
          model?: string(name='Model'),
          openTimeoutSeconds?: long(name='OpenTimeoutSeconds'),
          slowRatioThreshold?: double(name='SlowRatioThreshold'),
          switchStatus?: string(name='SwitchStatus'),
          windowsInSeconds?: long(name='WindowsInSeconds'),
          workspaceId?: string(name='WorkspaceId'),
        }(name='CircuitBreakerRule'),
        contentType?: string(name='ContentType'),
        description?: string(name='Description'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        headerRule?: [ 
          {
            headerKey?: string(name='HeaderKey'),
            location?: string(name='Location'),
            type?: string(name='Type'),
            value?: string(name='Value'),
          }
        ](name='HeaderRule'),
        headerRules?: [ 
          {
            headerKey?: string(name='HeaderKey'),
            location?: string(name='Location'),
            type?: string(name='Type'),
            value?: string(name='Value'),
          }
        ](name='HeaderRules'),
        host?: string(name='Host'),
        id?: long(name='Id'),
        interfaceType?: string(name='InterfaceType'),
        limitRule?: {
          defaultResponse?: string(name='DefaultResponse'),
          i18nResponse?: string(name='I18nResponse'),
          interval?: long(name='Interval'),
          limit?: long(name='Limit'),
          mode?: string(name='Mode'),
        }(name='LimitRule'),
        method?: string(name='Method'),
        methodName?: string(name='MethodName'),
        migrateRule?: {
          flowPercent?: long(name='FlowPercent'),
          needMigrate?: boolean(name='NeedMigrate'),
          needSwitchCompletely?: boolean(name='NeedSwitchCompletely'),
          sysId?: long(name='SysId'),
          sysName?: string(name='SysName'),
          upstreamType?: string(name='UpstreamType'),
        }(name='MigrateRule'),
        mockRule?: {
          mockData?: string(name='MockData'),
          needMock?: boolean(name='NeedMock'),
          percentage?: long(name='Percentage'),
          type?: string(name='Type'),
        }(name='MockRule'),
        needETag?: string(name='NeedETag'),
        needEncrypt?: string(name='NeedEncrypt'),
        needJsonp?: string(name='NeedJsonp'),
        needSign?: string(name='NeedSign'),
        operationType?: string(name='OperationType'),
        paramGetMethod?: string(name='ParamGetMethod'),
        path?: string(name='Path'),
        requestBodyModel?: string(name='RequestBodyModel'),
        requestParams?: [ 
          {
            apiId?: string(name='ApiId'),
            appId?: string(name='AppId'),
            defaultValue?: string(name='DefaultValue'),
            description?: string(name='Description'),
            id?: long(name='Id'),
            location?: string(name='Location'),
            name?: string(name='Name'),
            refType?: string(name='RefType'),
            type?: string(name='Type'),
            workspaceId?: string(name='WorkspaceId'),
          }
        ](name='RequestParams'),
        responseBodyModel?: string(name='ResponseBodyModel'),
        sysId?: long(name='SysId'),
        sysName?: string(name='SysName'),
        timeout?: string(name='Timeout'),
        workspaceId?: string(name='WorkspaceId'),
      }
    ](name='Value'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMgsApiResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMgsApiResponseBody(name='body'),
}

/**
 * @param request ListMgsApiRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMgsApiResponse
 */
@context("listMgsApiWithContext")
async function listMgsApiWithOptions(request: ListMgsApiRequest, runtime: $RuntimeOptions): ListMgsApiResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.apiStatus)) {
    body['ApiStatus'] = request.apiStatus;
  }
  if (!$isNull(request.apiType)) {
    body['ApiType'] = request.apiType;
  }
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.format)) {
    body['Format'] = request.format;
  }
  if (!$isNull(request.host)) {
    body['Host'] = request.host;
  }
  if (!$isNull(request.needEncrypt)) {
    body['NeedEncrypt'] = request.needEncrypt;
  }
  if (!$isNull(request.needEtag)) {
    body['NeedEtag'] = request.needEtag;
  }
  if (!$isNull(request.needSign)) {
    body['NeedSign'] = request.needSign;
  }
  if (!$isNull(request.operationType)) {
    body['OperationType'] = request.operationType;
  }
  if (!$isNull(request.optFuzzy)) {
    body['OptFuzzy'] = request.optFuzzy;
  }
  if (!$isNull(request.pageIndex)) {
    body['PageIndex'] = request.pageIndex;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.sysId)) {
    body['SysId'] = request.sysId;
  }
  if (!$isNull(request.sysName)) {
    body['SysName'] = request.sysName;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListMgsApi',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ListMgsApiRequest
 * @return ListMgsApiResponse
 */
async function listMgsApi(request: ListMgsApiRequest): ListMgsApiResponse {
  var runtime = new $RuntimeOptions{};
  return listMgsApiWithOptions(request, runtime);
}

model MTRSOCRServiceRequest {
  appId?: string(name='AppId', example='ONEX8C7E7FA161089'),
  imageRaw?: string(name='ImageRaw', description='This parameter is required.', example='xydasf==ac'),
  mask?: boolean(name='Mask'),
  tenantId?: string(name='TenantId', example='tabcaa'),
  type?: string(name='Type', description='This parameter is required.', example='ID_CARD_OCR'),
  workspaceId?: string(name='WorkspaceId', example='default'),
}

model MTRSOCRServiceResponseBody = {
  code?: string(name='Code'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId', example='D9B3C4E7-BEC7-1E2C-86A3-EA985B4FFD73'),
  result?: string(name='Result', example='{"aa":"ss"}'),
  status?: boolean(name='Status', example='true/false'),
  traceId?: string(name='TraceId', example='777799aa'),
}

model MTRSOCRServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MTRSOCRServiceResponseBody(name='body'),
}

/**
 * @summary OCR通用接口
 *
 * @param request MTRSOCRServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MTRSOCRServiceResponse
 */
@context("mTRSOCRServiceWithContext")
async function mTRSOCRServiceWithOptions(request: MTRSOCRServiceRequest, runtime: $RuntimeOptions): MTRSOCRServiceResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.imageRaw)) {
    body['ImageRaw'] = request.imageRaw;
  }
  if (!$isNull(request.mask)) {
    body['Mask'] = request.mask;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'MTRSOCRService',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary OCR通用接口
 *
 * @param request MTRSOCRServiceRequest
 * @return MTRSOCRServiceResponse
 */
async function mTRSOCRService(request: MTRSOCRServiceRequest): MTRSOCRServiceResponse {
  var runtime = new $RuntimeOptions{};
  return mTRSOCRServiceWithOptions(request, runtime);
}

model PushBindRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  deliveryToken?: string(name='DeliveryToken', description='This parameter is required.'),
  osType?: int32(name='OsType', description='This parameter is required.'),
  phoneNumber?: string(name='PhoneNumber'),
  tenantId?: string(name='TenantId'),
  userId?: string(name='UserId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushBindResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushBindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushBindResponseBody(name='body'),
}

/**
 * @param request PushBindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushBindResponse
 */
@context("pushBindWithContext")
async function pushBindWithOptions(request: PushBindRequest, runtime: $RuntimeOptions): PushBindResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.deliveryToken)) {
    body['DeliveryToken'] = request.deliveryToken;
  }
  if (!$isNull(request.osType)) {
    body['OsType'] = request.osType;
  }
  if (!$isNull(request.phoneNumber)) {
    body['PhoneNumber'] = request.phoneNumber;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'PushBind',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PushBindRequest
 * @return PushBindResponse
 */
async function pushBind(request: PushBindRequest): PushBindResponse {
  var runtime = new $RuntimeOptions{};
  return pushBindWithOptions(request, runtime);
}

model PushBroadcastRequest {
  androidChannel?: int32(name='AndroidChannel'),
  appId?: string(name='AppId', description='This parameter is required.'),
  bindPeriod?: int32(name='BindPeriod'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  miChannelId?: string(name='MiChannelId'),
  msgkey?: string(name='Msgkey', description='This parameter is required.'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  pushStatus?: long(name='PushStatus'),
  silent?: long(name='Silent'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  taskName?: string(name='TaskName'),
  templateKeyValue?: string(name='TemplateKeyValue'),
  templateName?: string(name='TemplateName', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  unBindPeriod?: long(name='UnBindPeriod'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushBroadcastShrinkRequest {
  androidChannel?: int32(name='AndroidChannel'),
  appId?: string(name='AppId', description='This parameter is required.'),
  bindPeriod?: int32(name='BindPeriod'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  miChannelId?: string(name='MiChannelId'),
  msgkey?: string(name='Msgkey', description='This parameter is required.'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  pushStatus?: long(name='PushStatus'),
  silent?: long(name='Silent'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  taskName?: string(name='TaskName'),
  templateKeyValue?: string(name='TemplateKeyValue'),
  templateName?: string(name='TemplateName', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategoryShrink?: string(name='ThirdChannelCategory'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  unBindPeriod?: long(name='UnBindPeriod'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushBroadcastResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushBroadcastResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushBroadcastResponseBody(name='body'),
}

/**
 * @param tmpReq PushBroadcastRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushBroadcastResponse
 */
@context("pushBroadcastWithContext")
async function pushBroadcastWithOptions(tmpReq: PushBroadcastRequest, runtime: $RuntimeOptions): PushBroadcastResponse {
  tmpReq.validate();
  var request = new PushBroadcastShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.thirdChannelCategory)) {
    request.thirdChannelCategoryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.thirdChannelCategory, 'ThirdChannelCategory', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.androidChannel)) {
    body['AndroidChannel'] = request.androidChannel;
  }
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.bindPeriod)) {
    body['BindPeriod'] = request.bindPeriod;
  }
  if (!$isNull(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!$isNull(request.classification)) {
    body['Classification'] = request.classification;
  }
  if (!$isNull(request.deliveryType)) {
    body['DeliveryType'] = request.deliveryType;
  }
  if (!$isNull(request.expiredSeconds)) {
    body['ExpiredSeconds'] = request.expiredSeconds;
  }
  if (!$isNull(request.extendedParams)) {
    body['ExtendedParams'] = request.extendedParams;
  }
  if (!$isNull(request.miChannelId)) {
    body['MiChannelId'] = request.miChannelId;
  }
  if (!$isNull(request.msgkey)) {
    body['Msgkey'] = request.msgkey;
  }
  if (!$isNull(request.notifyType)) {
    body['NotifyType'] = request.notifyType;
  }
  if (!$isNull(request.pushAction)) {
    body['PushAction'] = request.pushAction;
  }
  if (!$isNull(request.pushStatus)) {
    body['PushStatus'] = request.pushStatus;
  }
  if (!$isNull(request.silent)) {
    body['Silent'] = request.silent;
  }
  if (!$isNull(request.strategyContent)) {
    body['StrategyContent'] = request.strategyContent;
  }
  if (!$isNull(request.strategyType)) {
    body['StrategyType'] = request.strategyType;
  }
  if (!$isNull(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!$isNull(request.templateKeyValue)) {
    body['TemplateKeyValue'] = request.templateKeyValue;
  }
  if (!$isNull(request.templateName)) {
    body['TemplateName'] = request.templateName;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.thirdChannelCategoryShrink)) {
    body['ThirdChannelCategory'] = request.thirdChannelCategoryShrink;
  }
  if (!$isNull(request.transparentMessagePayload)) {
    body['TransparentMessagePayload'] = request.transparentMessagePayload;
  }
  if (!$isNull(request.transparentMessageUrgency)) {
    body['TransparentMessageUrgency'] = request.transparentMessageUrgency;
  }
  if (!$isNull(request.unBindPeriod)) {
    body['UnBindPeriod'] = request.unBindPeriod;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'PushBroadcast',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PushBroadcastRequest
 * @return PushBroadcastResponse
 */
async function pushBroadcast(request: PushBroadcastRequest): PushBroadcastResponse {
  var runtime = new $RuntimeOptions{};
  return pushBroadcastWithOptions(request, runtime);
}

model PushMultipleRequest {
  activityContentState?: any(name='ActivityContentState'),
  activityEvent?: string(name='ActivityEvent'),
  appId?: string(name='AppId', description='This parameter is required.'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  dismissalDate?: long(name='DismissalDate'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  miChannelId?: string(name='MiChannelId'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  silent?: long(name='Silent'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  targetMsg?: [ 
    {
      extendedParams?: string(name='ExtendedParams'),
      msgKey?: string(name='MsgKey', description='This parameter is required.'),
      target?: string(name='Target', description='This parameter is required.'),
      templateKeyValue?: string(name='TemplateKeyValue'),
    }
  ](name='TargetMsg', description='This parameter is required.'),
  taskName?: string(name='TaskName'),
  templateName?: string(name='TemplateName', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushMultipleShrinkRequest {
  activityContentState?: any(name='ActivityContentState'),
  activityEvent?: string(name='ActivityEvent'),
  appId?: string(name='AppId', description='This parameter is required.'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  dismissalDate?: long(name='DismissalDate'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  miChannelId?: string(name='MiChannelId'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  silent?: long(name='Silent'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  targetMsg?: [ 
    {
      extendedParams?: string(name='ExtendedParams'),
      msgKey?: string(name='MsgKey', description='This parameter is required.'),
      target?: string(name='Target', description='This parameter is required.'),
      templateKeyValue?: string(name='TemplateKeyValue'),
    }
  ](name='TargetMsg', description='This parameter is required.'),
  taskName?: string(name='TaskName'),
  templateName?: string(name='TemplateName', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategoryShrink?: string(name='ThirdChannelCategory'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushMultipleResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushMultipleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushMultipleResponseBody(name='body'),
}

/**
 * @param tmpReq PushMultipleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushMultipleResponse
 */
@context("pushMultipleWithContext")
async function pushMultipleWithOptions(tmpReq: PushMultipleRequest, runtime: $RuntimeOptions): PushMultipleResponse {
  tmpReq.validate();
  var request = new PushMultipleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.thirdChannelCategory)) {
    request.thirdChannelCategoryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.thirdChannelCategory, 'ThirdChannelCategory', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.activityContentState)) {
    body['ActivityContentState'] = request.activityContentState;
  }
  if (!$isNull(request.activityEvent)) {
    body['ActivityEvent'] = request.activityEvent;
  }
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!$isNull(request.classification)) {
    body['Classification'] = request.classification;
  }
  if (!$isNull(request.deliveryType)) {
    body['DeliveryType'] = request.deliveryType;
  }
  if (!$isNull(request.dismissalDate)) {
    body['DismissalDate'] = request.dismissalDate;
  }
  if (!$isNull(request.expiredSeconds)) {
    body['ExpiredSeconds'] = request.expiredSeconds;
  }
  if (!$isNull(request.extendedParams)) {
    body['ExtendedParams'] = request.extendedParams;
  }
  if (!$isNull(request.miChannelId)) {
    body['MiChannelId'] = request.miChannelId;
  }
  if (!$isNull(request.notifyType)) {
    body['NotifyType'] = request.notifyType;
  }
  if (!$isNull(request.pushAction)) {
    body['PushAction'] = request.pushAction;
  }
  if (!$isNull(request.silent)) {
    body['Silent'] = request.silent;
  }
  if (!$isNull(request.strategyContent)) {
    body['StrategyContent'] = request.strategyContent;
  }
  if (!$isNull(request.strategyType)) {
    body['StrategyType'] = request.strategyType;
  }
  if (!$isNull(request.targetMsg)) {
    body['TargetMsg'] = request.targetMsg;
  }
  if (!$isNull(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!$isNull(request.templateName)) {
    body['TemplateName'] = request.templateName;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.thirdChannelCategoryShrink)) {
    body['ThirdChannelCategory'] = request.thirdChannelCategoryShrink;
  }
  if (!$isNull(request.transparentMessagePayload)) {
    body['TransparentMessagePayload'] = request.transparentMessagePayload;
  }
  if (!$isNull(request.transparentMessageUrgency)) {
    body['TransparentMessageUrgency'] = request.transparentMessageUrgency;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'PushMultiple',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PushMultipleRequest
 * @return PushMultipleResponse
 */
async function pushMultiple(request: PushMultipleRequest): PushMultipleResponse {
  var runtime = new $RuntimeOptions{};
  return pushMultipleWithOptions(request, runtime);
}

model PushReportRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  appVersion?: string(name='AppVersion'),
  channel?: string(name='Channel'),
  connectType?: string(name='ConnectType'),
  deliveryToken?: string(name='DeliveryToken', description='This parameter is required.'),
  imei?: string(name='Imei'),
  imsi?: string(name='Imsi'),
  model?: string(name='Model'),
  osType?: int32(name='OsType', description='This parameter is required.'),
  pushVersion?: string(name='PushVersion'),
  tenantId?: string(name='TenantId'),
  thirdChannel?: int32(name='ThirdChannel'),
  thirdChannelDeviceToken?: string(name='ThirdChannelDeviceToken'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushReportResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushReportResponseBody(name='body'),
}

/**
 * @param request PushReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushReportResponse
 */
@context("pushReportWithContext")
async function pushReportWithOptions(request: PushReportRequest, runtime: $RuntimeOptions): PushReportResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.appVersion)) {
    body['AppVersion'] = request.appVersion;
  }
  if (!$isNull(request.channel)) {
    body['Channel'] = request.channel;
  }
  if (!$isNull(request.connectType)) {
    body['ConnectType'] = request.connectType;
  }
  if (!$isNull(request.deliveryToken)) {
    body['DeliveryToken'] = request.deliveryToken;
  }
  if (!$isNull(request.imei)) {
    body['Imei'] = request.imei;
  }
  if (!$isNull(request.imsi)) {
    body['Imsi'] = request.imsi;
  }
  if (!$isNull(request.model)) {
    body['Model'] = request.model;
  }
  if (!$isNull(request.osType)) {
    body['OsType'] = request.osType;
  }
  if (!$isNull(request.pushVersion)) {
    body['PushVersion'] = request.pushVersion;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.thirdChannel)) {
    body['ThirdChannel'] = request.thirdChannel;
  }
  if (!$isNull(request.thirdChannelDeviceToken)) {
    body['ThirdChannelDeviceToken'] = request.thirdChannelDeviceToken;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'PushReport',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PushReportRequest
 * @return PushReportResponse
 */
async function pushReport(request: PushReportRequest): PushReportResponse {
  var runtime = new $RuntimeOptions{};
  return pushReportWithOptions(request, runtime);
}

model PushSimpleRequest {
  activityContentState?: any(name='ActivityContentState'),
  activityEvent?: string(name='ActivityEvent'),
  appId?: string(name='AppId', description='This parameter is required.'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  content?: string(name='Content', description='This parameter is required.'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  dismissalDate?: long(name='DismissalDate'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  iconUrls?: string(name='IconUrls'),
  imageUrls?: string(name='ImageUrls'),
  miChannelId?: string(name='MiChannelId'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  pushStyle?: int32(name='PushStyle'),
  silent?: long(name='Silent'),
  smsSignName?: string(name='SmsSignName'),
  smsStrategy?: int32(name='SmsStrategy'),
  smsTemplateCode?: string(name='SmsTemplateCode'),
  smsTemplateParam?: string(name='SmsTemplateParam'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  targetMsgkey?: string(name='TargetMsgkey', description='This parameter is required.'),
  taskName?: string(name='TaskName'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory'),
  title?: string(name='Title', description='This parameter is required.'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  uri?: string(name='Uri'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushSimpleShrinkRequest {
  activityContentState?: any(name='ActivityContentState'),
  activityEvent?: string(name='ActivityEvent'),
  appId?: string(name='AppId', description='This parameter is required.'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  content?: string(name='Content', description='This parameter is required.'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  dismissalDate?: long(name='DismissalDate'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  iconUrls?: string(name='IconUrls'),
  imageUrls?: string(name='ImageUrls'),
  miChannelId?: string(name='MiChannelId'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  pushStyle?: int32(name='PushStyle'),
  silent?: long(name='Silent'),
  smsSignName?: string(name='SmsSignName'),
  smsStrategy?: int32(name='SmsStrategy'),
  smsTemplateCode?: string(name='SmsTemplateCode'),
  smsTemplateParam?: string(name='SmsTemplateParam'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  targetMsgkey?: string(name='TargetMsgkey', description='This parameter is required.'),
  taskName?: string(name='TaskName'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategoryShrink?: string(name='ThirdChannelCategory'),
  title?: string(name='Title', description='This parameter is required.'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  uri?: string(name='Uri'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushSimpleResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushSimpleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushSimpleResponseBody(name='body'),
}

/**
 * @summary 极简推送
 *
 * @param tmpReq PushSimpleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushSimpleResponse
 */
@context("pushSimpleWithContext")
async function pushSimpleWithOptions(tmpReq: PushSimpleRequest, runtime: $RuntimeOptions): PushSimpleResponse {
  tmpReq.validate();
  var request = new PushSimpleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.thirdChannelCategory)) {
    request.thirdChannelCategoryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.thirdChannelCategory, 'ThirdChannelCategory', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.activityContentState)) {
    body['ActivityContentState'] = request.activityContentState;
  }
  if (!$isNull(request.activityEvent)) {
    body['ActivityEvent'] = request.activityEvent;
  }
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!$isNull(request.classification)) {
    body['Classification'] = request.classification;
  }
  if (!$isNull(request.content)) {
    body['Content'] = request.content;
  }
  if (!$isNull(request.deliveryType)) {
    body['DeliveryType'] = request.deliveryType;
  }
  if (!$isNull(request.dismissalDate)) {
    body['DismissalDate'] = request.dismissalDate;
  }
  if (!$isNull(request.expiredSeconds)) {
    body['ExpiredSeconds'] = request.expiredSeconds;
  }
  if (!$isNull(request.extendedParams)) {
    body['ExtendedParams'] = request.extendedParams;
  }
  if (!$isNull(request.iconUrls)) {
    body['IconUrls'] = request.iconUrls;
  }
  if (!$isNull(request.imageUrls)) {
    body['ImageUrls'] = request.imageUrls;
  }
  if (!$isNull(request.miChannelId)) {
    body['MiChannelId'] = request.miChannelId;
  }
  if (!$isNull(request.notifyType)) {
    body['NotifyType'] = request.notifyType;
  }
  if (!$isNull(request.pushAction)) {
    body['PushAction'] = request.pushAction;
  }
  if (!$isNull(request.pushStyle)) {
    body['PushStyle'] = request.pushStyle;
  }
  if (!$isNull(request.silent)) {
    body['Silent'] = request.silent;
  }
  if (!$isNull(request.smsSignName)) {
    body['SmsSignName'] = request.smsSignName;
  }
  if (!$isNull(request.smsStrategy)) {
    body['SmsStrategy'] = request.smsStrategy;
  }
  if (!$isNull(request.smsTemplateCode)) {
    body['SmsTemplateCode'] = request.smsTemplateCode;
  }
  if (!$isNull(request.smsTemplateParam)) {
    body['SmsTemplateParam'] = request.smsTemplateParam;
  }
  if (!$isNull(request.strategyContent)) {
    body['StrategyContent'] = request.strategyContent;
  }
  if (!$isNull(request.strategyType)) {
    body['StrategyType'] = request.strategyType;
  }
  if (!$isNull(request.targetMsgkey)) {
    body['TargetMsgkey'] = request.targetMsgkey;
  }
  if (!$isNull(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.thirdChannelCategoryShrink)) {
    body['ThirdChannelCategory'] = request.thirdChannelCategoryShrink;
  }
  if (!$isNull(request.title)) {
    body['Title'] = request.title;
  }
  if (!$isNull(request.transparentMessagePayload)) {
    body['TransparentMessagePayload'] = request.transparentMessagePayload;
  }
  if (!$isNull(request.transparentMessageUrgency)) {
    body['TransparentMessageUrgency'] = request.transparentMessageUrgency;
  }
  if (!$isNull(request.uri)) {
    body['Uri'] = request.uri;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'PushSimple',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 极简推送
 *
 * @param request PushSimpleRequest
 * @return PushSimpleResponse
 */
async function pushSimple(request: PushSimpleRequest): PushSimpleResponse {
  var runtime = new $RuntimeOptions{};
  return pushSimpleWithOptions(request, runtime);
}

model PushTemplateRequest {
  activityContentState?: any(name='ActivityContentState'),
  activityEvent?: string(name='ActivityEvent'),
  appId?: string(name='AppId', description='This parameter is required.'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  dismissalDate?: long(name='DismissalDate'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  miChannelId?: string(name='MiChannelId'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  silent?: long(name='Silent'),
  smsSignName?: string(name='SmsSignName'),
  smsStrategy?: int32(name='SmsStrategy'),
  smsTemplateCode?: string(name='SmsTemplateCode'),
  smsTemplateParam?: string(name='SmsTemplateParam'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  targetMsgkey?: string(name='TargetMsgkey', description='This parameter is required.'),
  taskName?: string(name='TaskName'),
  templateKeyValue?: string(name='TemplateKeyValue'),
  templateName?: string(name='TemplateName', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushTemplateShrinkRequest {
  activityContentState?: any(name='ActivityContentState'),
  activityEvent?: string(name='ActivityEvent'),
  appId?: string(name='AppId', description='This parameter is required.'),
  channelId?: string(name='ChannelId'),
  classification?: string(name='Classification'),
  deliveryType?: long(name='DeliveryType', description='This parameter is required.'),
  dismissalDate?: long(name='DismissalDate'),
  expiredSeconds?: long(name='ExpiredSeconds', description='This parameter is required.'),
  extendedParams?: string(name='ExtendedParams'),
  miChannelId?: string(name='MiChannelId'),
  notifyType?: string(name='NotifyType'),
  pushAction?: long(name='PushAction'),
  silent?: long(name='Silent'),
  smsSignName?: string(name='SmsSignName'),
  smsStrategy?: int32(name='SmsStrategy'),
  smsTemplateCode?: string(name='SmsTemplateCode'),
  smsTemplateParam?: string(name='SmsTemplateParam'),
  strategyContent?: string(name='StrategyContent'),
  strategyType?: int32(name='StrategyType'),
  targetMsgkey?: string(name='TargetMsgkey', description='This parameter is required.'),
  taskName?: string(name='TaskName'),
  templateKeyValue?: string(name='TemplateKeyValue'),
  templateName?: string(name='TemplateName', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  thirdChannelCategoryShrink?: string(name='ThirdChannelCategory'),
  transparentMessagePayload?: any(name='TransparentMessagePayload'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushTemplateResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushTemplateResponseBody(name='body'),
}

/**
 * @param tmpReq PushTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushTemplateResponse
 */
@context("pushTemplateWithContext")
async function pushTemplateWithOptions(tmpReq: PushTemplateRequest, runtime: $RuntimeOptions): PushTemplateResponse {
  tmpReq.validate();
  var request = new PushTemplateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.thirdChannelCategory)) {
    request.thirdChannelCategoryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.thirdChannelCategory, 'ThirdChannelCategory', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.activityContentState)) {
    body['ActivityContentState'] = request.activityContentState;
  }
  if (!$isNull(request.activityEvent)) {
    body['ActivityEvent'] = request.activityEvent;
  }
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.channelId)) {
    body['ChannelId'] = request.channelId;
  }
  if (!$isNull(request.classification)) {
    body['Classification'] = request.classification;
  }
  if (!$isNull(request.deliveryType)) {
    body['DeliveryType'] = request.deliveryType;
  }
  if (!$isNull(request.dismissalDate)) {
    body['DismissalDate'] = request.dismissalDate;
  }
  if (!$isNull(request.expiredSeconds)) {
    body['ExpiredSeconds'] = request.expiredSeconds;
  }
  if (!$isNull(request.extendedParams)) {
    body['ExtendedParams'] = request.extendedParams;
  }
  if (!$isNull(request.miChannelId)) {
    body['MiChannelId'] = request.miChannelId;
  }
  if (!$isNull(request.notifyType)) {
    body['NotifyType'] = request.notifyType;
  }
  if (!$isNull(request.pushAction)) {
    body['PushAction'] = request.pushAction;
  }
  if (!$isNull(request.silent)) {
    body['Silent'] = request.silent;
  }
  if (!$isNull(request.smsSignName)) {
    body['SmsSignName'] = request.smsSignName;
  }
  if (!$isNull(request.smsStrategy)) {
    body['SmsStrategy'] = request.smsStrategy;
  }
  if (!$isNull(request.smsTemplateCode)) {
    body['SmsTemplateCode'] = request.smsTemplateCode;
  }
  if (!$isNull(request.smsTemplateParam)) {
    body['SmsTemplateParam'] = request.smsTemplateParam;
  }
  if (!$isNull(request.strategyContent)) {
    body['StrategyContent'] = request.strategyContent;
  }
  if (!$isNull(request.strategyType)) {
    body['StrategyType'] = request.strategyType;
  }
  if (!$isNull(request.targetMsgkey)) {
    body['TargetMsgkey'] = request.targetMsgkey;
  }
  if (!$isNull(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!$isNull(request.templateKeyValue)) {
    body['TemplateKeyValue'] = request.templateKeyValue;
  }
  if (!$isNull(request.templateName)) {
    body['TemplateName'] = request.templateName;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.thirdChannelCategoryShrink)) {
    body['ThirdChannelCategory'] = request.thirdChannelCategoryShrink;
  }
  if (!$isNull(request.transparentMessagePayload)) {
    body['TransparentMessagePayload'] = request.transparentMessagePayload;
  }
  if (!$isNull(request.transparentMessageUrgency)) {
    body['TransparentMessageUrgency'] = request.transparentMessageUrgency;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'PushTemplate',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PushTemplateRequest
 * @return PushTemplateResponse
 */
async function pushTemplate(request: PushTemplateRequest): PushTemplateResponse {
  var runtime = new $RuntimeOptions{};
  return pushTemplateWithOptions(request, runtime);
}

model PushUnBindRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  deliveryToken?: string(name='DeliveryToken', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  userId?: string(name='UserId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model PushUnBindResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushUnBindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushUnBindResponseBody(name='body'),
}

/**
 * @param request PushUnBindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PushUnBindResponse
 */
@context("pushUnBindWithContext")
async function pushUnBindWithOptions(request: PushUnBindRequest, runtime: $RuntimeOptions): PushUnBindResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.deliveryToken)) {
    body['DeliveryToken'] = request.deliveryToken;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'PushUnBind',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request PushUnBindRequest
 * @return PushUnBindResponse
 */
async function pushUnBind(request: PushUnBindRequest): PushUnBindResponse {
  var runtime = new $RuntimeOptions{};
  return pushUnBindWithOptions(request, runtime);
}

model QueryInfoFromMdpRequest {
  appId?: string(name='AppId', description='This parameter is required.', example='ALIPUBE5C3F6D091419'),
  mobile?: string(name='Mobile', example='13178195662'),
  mobileMd5?: string(name='MobileMd5', example='2fe6e5fa754be73d1721b9bd2c6cf821'),
  mobileSha256?: string(name='MobileSha256', example='db0797452ccafce84d7c151eb81596099bda3f097693d1e18b588804e6742ced'),
  mobileSm3?: string(name='MobileSm3'),
  riskScene?: string(name='RiskScene', description='This parameter is required.', example='1000'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.', example='default'),
}

model QueryInfoFromMdpResponseBody = {
  data?: string(name='Data', example='{\\\\"db0797452ccafce84d7c151eb81596099bda3f097693d1e18b588804e6742ced\\\\":{\\\\"riskScore\\\\":\\\\"3\\\\"}}'),
  requestId?: string(name='RequestId', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  resultCode?: int32(name='ResultCode', example='OK'),
  resultMessage?: string(name='ResultMessage', example='SYSTEM_ERROR'),
  success?: boolean(name='Success', example='True'),
}

model QueryInfoFromMdpResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryInfoFromMdpResponseBody(name='body'),
}

/**
 * @summary 查询Device+服务的
 *
 * @param request QueryInfoFromMdpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryInfoFromMdpResponse
 */
@context("queryInfoFromMdpWithContext")
async function queryInfoFromMdpWithOptions(request: QueryInfoFromMdpRequest, runtime: $RuntimeOptions): QueryInfoFromMdpResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.mobile)) {
    body['Mobile'] = request.mobile;
  }
  if (!$isNull(request.mobileMd5)) {
    body['MobileMd5'] = request.mobileMd5;
  }
  if (!$isNull(request.mobileSha256)) {
    body['MobileSha256'] = request.mobileSha256;
  }
  if (!$isNull(request.mobileSm3)) {
    body['MobileSm3'] = request.mobileSm3;
  }
  if (!$isNull(request.riskScene)) {
    body['RiskScene'] = request.riskScene;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryInfoFromMdp',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询Device+服务的
 *
 * @param request QueryInfoFromMdpRequest
 * @return QueryInfoFromMdpResponse
 */
async function queryInfoFromMdp(request: QueryInfoFromMdpRequest): QueryInfoFromMdpResponse {
  var runtime = new $RuntimeOptions{};
  return queryInfoFromMdpWithOptions(request, runtime);
}

model QueryLinkRequest {
  appId?: string(name='AppId', description='This parameter is required.', example='BB5953C300957'),
  url?: string(name='Url', description='This parameter is required.', example='8hGb9SyJARqp7V4PGP92X'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.', example='default'),
}

model QueryLinkResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='D9B3C4E7-BEC7-1E2C-86A3-EA985B4FFD73'),
  resultCode?: string(name='ResultCode', example='100'),
  resultContent?: {
    data?: any(name='Data', example='{
            "Modified": "2024-04-29 16:35:55",
            "NeedRenderEvent": false,
            "WorkspaceId": "default",
            "Cors": false,
            "Url": "https://xxx/xxx",
            "Created": "2024-04-29 16:35:55",
            "LastModified": "2024-04-29 16:35:55",
            "Target": "http://xxx/test.html",
            "Dynamictarget": "",
            "AppId": "BB5953C300957",
            "Version": 0,
            "Traceid": "f6c95f06891a19ff2d896ea309581883",
            "Domain": "u.aliyuncs.com"
        }'),
    target?: string(name='Target', example='https://xxx/xxx/xxx'),
    version?: string(name='Version', example='0'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage', example='success'),
}

model QueryLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryLinkResponseBody(name='body'),
}

/**
 * @summary 查询短链
 *
 * @param request QueryLinkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryLinkResponse
 */
@context("queryLinkWithContext")
async function queryLinkWithOptions(request: QueryLinkRequest, runtime: $RuntimeOptions): QueryLinkResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.url)) {
    body['Url'] = request.url;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryLink',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询短链
 *
 * @param request QueryLinkRequest
 * @return QueryLinkResponse
 */
async function queryLink(request: QueryLinkRequest): QueryLinkResponse {
  var runtime = new $RuntimeOptions{};
  return queryLinkWithOptions(request, runtime);
}

model QueryMappCenterAppRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryMappCenterAppResponseBody = {
  queryMappCenterAppResult?: {
    mappCenterApp?: {
      androidConfig?: {
        certRSA?: string(name='CertRSA'),
        packageName?: string(name='PackageName'),
      }(name='AndroidConfig'),
      appDesc?: string(name='AppDesc'),
      appIcon?: string(name='AppIcon'),
      appId?: string(name='AppId'),
      appName?: string(name='AppName'),
      appSecret?: string(name='AppSecret'),
      creator?: string(name='Creator'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
      iosConfig?: {
        bundleId?: string(name='BundleId'),
      }(name='IosConfig'),
      modifier?: string(name='Modifier'),
      monitorJson?: string(name='MonitorJson'),
      status?: long(name='Status'),
      tenantId?: string(name='TenantId'),
      type?: long(name='Type'),
    }(name='MappCenterApp'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryMappCenterAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMappCenterAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMappCenterAppResponseBody(name='body'),
}

/**
 * @param request QueryMappCenterAppRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMappCenterAppResponse
 */
@context("queryMappCenterAppWithContext")
async function queryMappCenterAppWithOptions(request: QueryMappCenterAppRequest, runtime: $RuntimeOptions): QueryMappCenterAppResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMappCenterApp',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMappCenterAppRequest
 * @return QueryMappCenterAppResponse
 */
async function queryMappCenterApp(request: QueryMappCenterAppRequest): QueryMappCenterAppResponse {
  var runtime = new $RuntimeOptions{};
  return queryMappCenterAppWithOptions(request, runtime);
}

model QueryMcdpAimRequest {
  appId?: string(name='AppId'),
  id?: long(name='Id', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMcdpAimResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcdpAimResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcdpAimResponseBody(name='body'),
}

/**
 * @param request QueryMcdpAimRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMcdpAimResponse
 */
@context("queryMcdpAimWithContext")
async function queryMcdpAimWithOptions(request: QueryMcdpAimRequest, runtime: $RuntimeOptions): QueryMcdpAimResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMcdpAim',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMcdpAimRequest
 * @return QueryMcdpAimResponse
 */
async function queryMcdpAim(request: QueryMcdpAimRequest): QueryMcdpAimResponse {
  var runtime = new $RuntimeOptions{};
  return queryMcdpAimWithOptions(request, runtime);
}

model QueryMcdpZoneRequest {
  appId?: string(name='AppId'),
  id?: long(name='Id'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMcdpZoneResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcdpZoneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcdpZoneResponseBody(name='body'),
}

/**
 * @param request QueryMcdpZoneRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMcdpZoneResponse
 */
@context("queryMcdpZoneWithContext")
async function queryMcdpZoneWithOptions(request: QueryMcdpZoneRequest, runtime: $RuntimeOptions): QueryMcdpZoneResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMcdpZone',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMcdpZoneRequest
 * @return QueryMcdpZoneResponse
 */
async function queryMcdpZone(request: QueryMcdpZoneRequest): QueryMcdpZoneResponse {
  var runtime = new $RuntimeOptions{};
  return queryMcdpZoneWithOptions(request, runtime);
}

model QueryMcubeMiniPackageRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  h5Id?: string(name='H5Id', description='This parameter is required.'),
  id?: string(name='Id', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryMcubeMiniPackageResponseBody = {
  queryMiniPackageResult?: {
    miniPackageInfo?: {
      appCode?: string(name='AppCode'),
      autoInstall?: long(name='AutoInstall'),
      clientVersionMax?: string(name='ClientVersionMax'),
      clientVersionMin?: string(name='ClientVersionMin'),
      downloadUrl?: string(name='DownloadUrl'),
      extendInfo?: string(name='ExtendInfo'),
      extraData?: string(name='ExtraData'),
      fallbackBaseUrl?: string(name='FallbackBaseUrl'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      h5Id?: string(name='H5Id'),
      h5Name?: string(name='H5Name'),
      h5Version?: string(name='H5Version'),
      id?: long(name='Id'),
      installType?: long(name='InstallType'),
      mainUrl?: string(name='MainUrl'),
      memo?: string(name='Memo'),
      packageType?: long(name='PackageType'),
      platform?: string(name='Platform'),
      publishPeriod?: long(name='PublishPeriod'),
      resourceType?: long(name='ResourceType'),
      status?: long(name='Status'),
    }(name='MiniPackageInfo'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryMiniPackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcubeMiniPackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcubeMiniPackageResponseBody(name='body'),
}

/**
 * @param request QueryMcubeMiniPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMcubeMiniPackageResponse
 */
@context("queryMcubeMiniPackageWithContext")
async function queryMcubeMiniPackageWithOptions(request: QueryMcubeMiniPackageRequest, runtime: $RuntimeOptions): QueryMcubeMiniPackageResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMcubeMiniPackage',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMcubeMiniPackageRequest
 * @return QueryMcubeMiniPackageResponse
 */
async function queryMcubeMiniPackage(request: QueryMcubeMiniPackageRequest): QueryMcubeMiniPackageResponse {
  var runtime = new $RuntimeOptions{};
  return queryMcubeMiniPackageWithOptions(request, runtime);
}

model QueryMcubeMiniTaskRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  taskId?: long(name='TaskId', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryMcubeMiniTaskResponseBody = {
  queryMiniTaskResult?: {
    miniTaskInfo?: {
      appCode?: string(name='AppCode'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      greyConfigInfo?: string(name='GreyConfigInfo'),
      greyEndtime?: string(name='GreyEndtime'),
      greyEndtimeData?: string(name='GreyEndtimeData'),
      greyNum?: long(name='GreyNum'),
      id?: long(name='Id'),
      memo?: string(name='Memo'),
      packageId?: long(name='PackageId'),
      platform?: string(name='Platform'),
      productVersion?: string(name='ProductVersion'),
      publishMode?: long(name='PublishMode'),
      publishType?: long(name='PublishType'),
      status?: string(name='Status'),
      taskStatus?: long(name='TaskStatus'),
      whitelistIds?: string(name='WhitelistIds'),
    }(name='MiniTaskInfo'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryMiniTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcubeMiniTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcubeMiniTaskResponseBody(name='body'),
}

/**
 * @param request QueryMcubeMiniTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMcubeMiniTaskResponse
 */
@context("queryMcubeMiniTaskWithContext")
async function queryMcubeMiniTaskWithOptions(request: QueryMcubeMiniTaskRequest, runtime: $RuntimeOptions): QueryMcubeMiniTaskResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMcubeMiniTask',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMcubeMiniTaskRequest
 * @return QueryMcubeMiniTaskResponse
 */
async function queryMcubeMiniTask(request: QueryMcubeMiniTaskRequest): QueryMcubeMiniTaskResponse {
  var runtime = new $RuntimeOptions{};
  return queryMcubeMiniTaskWithOptions(request, runtime);
}

model QueryMcubeVhostRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryMcubeVhostResponseBody = {
  queryVhostResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryVhostResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcubeVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcubeVhostResponseBody(name='body'),
}

/**
 * @param request QueryMcubeVhostRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMcubeVhostResponse
 */
@context("queryMcubeVhostWithContext")
async function queryMcubeVhostWithOptions(request: QueryMcubeVhostRequest, runtime: $RuntimeOptions): QueryMcubeVhostResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMcubeVhost',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMcubeVhostRequest
 * @return QueryMcubeVhostResponse
 */
async function queryMcubeVhost(request: QueryMcubeVhostRequest): QueryMcubeVhostResponse {
  var runtime = new $RuntimeOptions{};
  return queryMcubeVhostWithOptions(request, runtime);
}

model QueryMdsUpgradeTaskDetailRequest {
  appId?: string(name='AppId'),
  taskId?: long(name='TaskId', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMdsUpgradeTaskDetailResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: {
        appCode?: string(name='AppCode'),
        appId?: string(name='AppId'),
        appstoreurl?: string(name='Appstoreurl'),
        channelContains?: string(name='ChannelContains'),
        channelExcludes?: string(name='ChannelExcludes'),
        cityContains?: string(name='CityContains'),
        cityExcludes?: string(name='CityExcludes'),
        creator?: string(name='Creator'),
        deviceGreyNum?: long(name='DeviceGreyNum'),
        devicePercent?: long(name='DevicePercent'),
        downloadUrl?: string(name='DownloadUrl'),
        executionOrder?: long(name='ExecutionOrder'),
        gmtCreateStr?: string(name='GmtCreateStr'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtimeData?: string(name='GreyEndtimeData'),
        greyNotice?: long(name='GreyNotice'),
        greyNum?: long(name='GreyNum'),
        greyUv?: long(name='GreyUv'),
        id?: long(name='Id'),
        innerVersion?: string(name='InnerVersion'),
        isEnterprise?: long(name='IsEnterprise'),
        isOfficial?: long(name='IsOfficial'),
        isPush?: long(name='IsPush'),
        isRc?: long(name='IsRc'),
        isRelease?: long(name='IsRelease'),
        memo?: string(name='Memo'),
        mobileModelContains?: string(name='MobileModelContains'),
        mobileModelExcludes?: string(name='MobileModelExcludes'),
        modifier?: string(name='Modifier'),
        netType?: string(name='NetType'),
        osVersion?: string(name='OsVersion'),
        packageInfoId?: long(name='PackageInfoId'),
        packageType?: string(name='PackageType'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: long(name='PublishMode'),
        publishType?: long(name='PublishType'),
        pushContent?: string(name='PushContent'),
        qrcodeUrl?: string(name='QrcodeUrl'),
        releaseType?: string(name='ReleaseType'),
        ruleJsonList?: [ 
          {
            operation?: string(name='Operation'),
            ruleElement?: string(name='RuleElement'),
            ruleType?: string(name='RuleType'),
            value?: string(name='Value'),
          }
        ](name='RuleJsonList'),
        silentType?: long(name='SilentType'),
        syncMode?: string(name='SyncMode'),
        syncResult?: string(name='SyncResult'),
        taskStatus?: long(name='TaskStatus'),
        upgradeContent?: string(name='UpgradeContent'),
        upgradeType?: long(name='UpgradeType'),
        upgradeValidTime?: long(name='UpgradeValidTime'),
        whitelist?: [ 
          {
            appCode?: string(name='AppCode'),
            business?: string(name='Business'),
            gmtModified?: string(name='GmtModified'),
            id?: long(name='Id'),
            idType?: string(name='IdType'),
            platform?: string(name='Platform'),
            status?: long(name='Status'),
            whiteListCount?: long(name='WhiteListCount'),
            whiteListName?: string(name='WhiteListName'),
          }
        ](name='Whitelist'),
        whitelistIds?: string(name='WhitelistIds'),
      }(name='Content'),
      errorCode?: string(name='ErrorCode'),
      requestId?: string(name='RequestId'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMdsUpgradeTaskDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMdsUpgradeTaskDetailResponseBody(name='body'),
}

/**
 * @param request QueryMdsUpgradeTaskDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMdsUpgradeTaskDetailResponse
 */
@context("queryMdsUpgradeTaskDetailWithContext")
async function queryMdsUpgradeTaskDetailWithOptions(request: QueryMdsUpgradeTaskDetailRequest, runtime: $RuntimeOptions): QueryMdsUpgradeTaskDetailResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMdsUpgradeTaskDetail',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMdsUpgradeTaskDetailRequest
 * @return QueryMdsUpgradeTaskDetailResponse
 */
async function queryMdsUpgradeTaskDetail(request: QueryMdsUpgradeTaskDetailRequest): QueryMdsUpgradeTaskDetailResponse {
  var runtime = new $RuntimeOptions{};
  return queryMdsUpgradeTaskDetailWithOptions(request, runtime);
}

model QueryMgsApipageRequest {
  apiStatus?: string(name='ApiStatus'),
  apiType?: string(name='ApiType'),
  appId?: string(name='AppId'),
  format?: string(name='Format'),
  host?: string(name='Host'),
  needEncrypt?: string(name='NeedEncrypt'),
  needEtag?: string(name='NeedEtag'),
  needSign?: string(name='NeedSign'),
  operationType?: string(name='OperationType'),
  optFuzzy?: string(name='OptFuzzy'),
  pageIndex?: long(name='PageIndex'),
  pageSize?: long(name='PageSize'),
  sysId?: long(name='SysId'),
  sysName?: string(name='SysName'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMgsApipageResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    current?: long(name='Current'),
    list?: [ 
      {
        apiInvoker?: {
          httpInvoker?: {
            charset?: string(name='Charset'),
            contentType?: string(name='ContentType'),
            host?: string(name='Host'),
            method?: string(name='Method'),
            path?: string(name='Path'),
          }(name='HttpInvoker'),
          rpcInvoker?: string(name='RpcInvoker'),
        }(name='ApiInvoker'),
        apiName?: string(name='ApiName'),
        apiStatus?: string(name='ApiStatus'),
        apiType?: string(name='ApiType'),
        appId?: string(name='AppId'),
        authRuleName?: string(name='AuthRuleName'),
        cacheRule?: {
          cacheKey?: string(name='CacheKey'),
          needCache?: boolean(name='NeedCache'),
          ttl?: long(name='Ttl'),
        }(name='CacheRule'),
        charset?: string(name='Charset'),
        circuitBreakerRule?: {
          appId?: string(name='AppId'),
          defaultResponse?: string(name='DefaultResponse'),
          errorThreshold?: long(name='ErrorThreshold'),
          id?: long(name='Id'),
          model?: string(name='Model'),
          openTimeoutSeconds?: long(name='OpenTimeoutSeconds'),
          slowRatioThreshold?: double(name='SlowRatioThreshold'),
          switchStatus?: string(name='SwitchStatus'),
          windowsInSeconds?: long(name='WindowsInSeconds'),
          workspaceId?: string(name='WorkspaceId'),
        }(name='CircuitBreakerRule'),
        contentType?: string(name='ContentType'),
        description?: string(name='Description'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        headerRule?: [ 
          {
            headerKey?: string(name='HeaderKey'),
            location?: string(name='Location'),
            type?: string(name='Type'),
            value?: string(name='Value'),
          }
        ](name='HeaderRule'),
        headerRules?: [ 
          {
            headerKey?: string(name='HeaderKey'),
            location?: string(name='Location'),
            type?: string(name='Type'),
            value?: string(name='Value'),
          }
        ](name='HeaderRules'),
        host?: string(name='Host'),
        id?: long(name='Id'),
        interfaceType?: string(name='InterfaceType'),
        limitRule?: {
          defaultResponse?: string(name='DefaultResponse'),
          i18nResponse?: string(name='I18nResponse'),
          interval?: long(name='Interval'),
          limit?: long(name='Limit'),
          mode?: string(name='Mode'),
        }(name='LimitRule'),
        method?: string(name='Method'),
        methodName?: string(name='MethodName'),
        migrateRule?: {
          flowPercent?: long(name='FlowPercent'),
          needMigrate?: boolean(name='NeedMigrate'),
          needSwitchCompletely?: boolean(name='NeedSwitchCompletely'),
          sysId?: long(name='SysId'),
          sysName?: string(name='SysName'),
          upstreamType?: string(name='UpstreamType'),
        }(name='MigrateRule'),
        mockRule?: {
          mockData?: string(name='MockData'),
          needMock?: boolean(name='NeedMock'),
          percentage?: long(name='Percentage'),
          type?: string(name='Type'),
        }(name='MockRule'),
        needETag?: string(name='NeedETag'),
        needEncrypt?: string(name='NeedEncrypt'),
        needJsonp?: string(name='NeedJsonp'),
        needSign?: string(name='NeedSign'),
        operationType?: string(name='OperationType'),
        paramGetMethod?: string(name='ParamGetMethod'),
        path?: string(name='Path'),
        requestBodyModel?: string(name='RequestBodyModel'),
        requestParams?: [ 
          {
            apiId?: string(name='ApiId'),
            appId?: string(name='AppId'),
            defaultValue?: string(name='DefaultValue'),
            description?: string(name='Description'),
            id?: long(name='Id'),
            location?: string(name='Location'),
            name?: string(name='Name'),
            refType?: string(name='RefType'),
            type?: string(name='Type'),
            workspaceId?: string(name='WorkspaceId'),
          }
        ](name='RequestParams'),
        responseBodyModel?: string(name='ResponseBodyModel'),
        sysId?: long(name='SysId'),
        sysName?: string(name='SysName'),
        timeout?: string(name='Timeout'),
        workspaceId?: string(name='WorkspaceId'),
      }
    ](name='List'),
    pageSize?: long(name='PageSize'),
    total?: long(name='Total'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMgsApipageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMgsApipageResponseBody(name='body'),
}

/**
 * @param request QueryMgsApipageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMgsApipageResponse
 */
@context("queryMgsApipageWithContext")
async function queryMgsApipageWithOptions(request: QueryMgsApipageRequest, runtime: $RuntimeOptions): QueryMgsApipageResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.apiStatus)) {
    body['ApiStatus'] = request.apiStatus;
  }
  if (!$isNull(request.apiType)) {
    body['ApiType'] = request.apiType;
  }
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.format)) {
    body['Format'] = request.format;
  }
  if (!$isNull(request.host)) {
    body['Host'] = request.host;
  }
  if (!$isNull(request.needEncrypt)) {
    body['NeedEncrypt'] = request.needEncrypt;
  }
  if (!$isNull(request.needEtag)) {
    body['NeedEtag'] = request.needEtag;
  }
  if (!$isNull(request.needSign)) {
    body['NeedSign'] = request.needSign;
  }
  if (!$isNull(request.operationType)) {
    body['OperationType'] = request.operationType;
  }
  if (!$isNull(request.optFuzzy)) {
    body['OptFuzzy'] = request.optFuzzy;
  }
  if (!$isNull(request.pageIndex)) {
    body['PageIndex'] = request.pageIndex;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.sysId)) {
    body['SysId'] = request.sysId;
  }
  if (!$isNull(request.sysName)) {
    body['SysName'] = request.sysName;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMgsApipage',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMgsApipageRequest
 * @return QueryMgsApipageResponse
 */
async function queryMgsApipage(request: QueryMgsApipageRequest): QueryMgsApipageResponse {
  var runtime = new $RuntimeOptions{};
  return queryMgsApipageWithOptions(request, runtime);
}

model QueryMgsApirestRequest {
  appId?: string(name='AppId'),
  format?: string(name='Format'),
  id?: long(name='Id'),
  tenantId?: string(name='TenantId'),
  type?: string(name='Type'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMgsApirestResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    errorMessage?: string(name='ErrorMessage'),
    success?: boolean(name='Success'),
    value?: {
      apiInvoker?: {
        httpInvoker?: {
          charset?: string(name='Charset'),
          contentType?: string(name='ContentType'),
          host?: string(name='Host'),
          method?: string(name='Method'),
          path?: string(name='Path'),
        }(name='HttpInvoker'),
        rpcInvoker?: string(name='RpcInvoker'),
      }(name='ApiInvoker'),
      apiName?: string(name='ApiName'),
      apiStatus?: string(name='ApiStatus'),
      apiType?: string(name='ApiType'),
      appId?: string(name='AppId'),
      authRuleName?: string(name='AuthRuleName'),
      cacheRule?: {
        cacheKey?: string(name='CacheKey'),
        needCache?: boolean(name='NeedCache'),
        ttl?: long(name='Ttl'),
      }(name='CacheRule'),
      charset?: string(name='Charset'),
      circuitBreakerRule?: {
        appId?: string(name='AppId'),
        defaultResponse?: string(name='DefaultResponse'),
        errorThreshold?: long(name='ErrorThreshold'),
        id?: long(name='Id'),
        model?: string(name='Model'),
        openTimeoutSeconds?: long(name='OpenTimeoutSeconds'),
        slowRatioThreshold?: double(name='SlowRatioThreshold'),
        switchStatus?: string(name='SwitchStatus'),
        windowsInSeconds?: long(name='WindowsInSeconds'),
        workspaceId?: string(name='WorkspaceId'),
      }(name='CircuitBreakerRule'),
      contentType?: string(name='ContentType'),
      defaultLimitRule?: {
        configId?: int32(name='ConfigId'),
        defaultLimit?: boolean(name='DefaultLimit'),
      }(name='DefaultLimitRule'),
      description?: string(name='Description'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      headerRule?: [ 
        {
          headerKey?: string(name='HeaderKey'),
          location?: string(name='Location'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='HeaderRule'),
      headerRules?: [ 
        {
          headerKey?: string(name='HeaderKey'),
          location?: string(name='Location'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='HeaderRules'),
      host?: string(name='Host'),
      id?: long(name='Id'),
      interfaceType?: string(name='InterfaceType'),
      limitRule?: {
        defaultResponse?: string(name='DefaultResponse'),
        i18nResponse?: string(name='I18nResponse'),
        interval?: long(name='Interval'),
        limit?: long(name='Limit'),
        mode?: string(name='Mode'),
      }(name='LimitRule'),
      method?: string(name='Method'),
      methodName?: string(name='MethodName'),
      migrateRule?: {
        flowPercent?: long(name='FlowPercent'),
        needMigrate?: boolean(name='NeedMigrate'),
        needSwitchCompletely?: boolean(name='NeedSwitchCompletely'),
        sysId?: long(name='SysId'),
        sysName?: string(name='SysName'),
        upstreamType?: string(name='UpstreamType'),
      }(name='MigrateRule'),
      mockRule?: {
        mockData?: string(name='MockData'),
        needMock?: boolean(name='NeedMock'),
        percentage?: long(name='Percentage'),
        type?: string(name='Type'),
      }(name='MockRule'),
      needETag?: string(name='NeedETag'),
      needEncrypt?: string(name='NeedEncrypt'),
      needJsonp?: string(name='NeedJsonp'),
      needSign?: string(name='NeedSign'),
      operationType?: string(name='OperationType'),
      paramGetMethod?: string(name='ParamGetMethod'),
      path?: string(name='Path'),
      requestBodyModel?: string(name='RequestBodyModel'),
      requestParams?: [ 
        {
          apiId?: string(name='ApiId'),
          appId?: string(name='AppId'),
          defaultValue?: string(name='DefaultValue'),
          description?: string(name='Description'),
          id?: long(name='Id'),
          location?: string(name='Location'),
          name?: string(name='Name'),
          refType?: string(name='RefType'),
          type?: string(name='Type'),
          workspaceId?: string(name='WorkspaceId'),
        }
      ](name='RequestParams'),
      responseBodyModel?: string(name='ResponseBodyModel'),
      sysId?: long(name='SysId'),
      sysName?: string(name='SysName'),
      timeout?: string(name='Timeout'),
      workspaceId?: string(name='WorkspaceId'),
    }(name='Value'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMgsApirestResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMgsApirestResponseBody(name='body'),
}

/**
 * @param request QueryMgsApirestRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMgsApirestResponse
 */
@context("queryMgsApirestWithContext")
async function queryMgsApirestWithOptions(request: QueryMgsApirestRequest, runtime: $RuntimeOptions): QueryMgsApirestResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.format)) {
    body['Format'] = request.format;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMgsApirest',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMgsApirestRequest
 * @return QueryMgsApirestResponse
 */
async function queryMgsApirest(request: QueryMgsApirestRequest): QueryMgsApirestResponse {
  var runtime = new $RuntimeOptions{};
  return queryMgsApirestWithOptions(request, runtime);
}

model QueryMgsTestreqbodyautogenRequest {
  appId?: string(name='AppId'),
  format?: string(name='Format'),
  mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr?: string(name='MpaasMappcenterMgsTestreqbodyautogenQueryJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model QueryMgsTestreqbodyautogenResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMgsTestreqbodyautogenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMgsTestreqbodyautogenResponseBody(name='body'),
}

/**
 * @param request QueryMgsTestreqbodyautogenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMgsTestreqbodyautogenResponse
 */
@context("queryMgsTestreqbodyautogenWithContext")
async function queryMgsTestreqbodyautogenWithOptions(request: QueryMgsTestreqbodyautogenRequest, runtime: $RuntimeOptions): QueryMgsTestreqbodyautogenResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.format)) {
    body['Format'] = request.format;
  }
  if (!$isNull(request.mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr)) {
    body['MpaasMappcenterMgsTestreqbodyautogenQueryJsonStr'] = request.mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMgsTestreqbodyautogen',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMgsTestreqbodyautogenRequest
 * @return QueryMgsTestreqbodyautogenResponse
 */
async function queryMgsTestreqbodyautogen(request: QueryMgsTestreqbodyautogenRequest): QueryMgsTestreqbodyautogenResponse {
  var runtime = new $RuntimeOptions{};
  return queryMgsTestreqbodyautogenWithOptions(request, runtime);
}

model QueryMpsSchedulerListRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  endTime?: long(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime'),
  type?: int32(name='Type'),
  uniqueId?: string(name='UniqueId'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryMpsSchedulerListResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      list?: [ 
        {
          createType?: int32(name='CreateType'),
          deliveryType?: int32(name='DeliveryType'),
          executedStatus?: string(name='ExecutedStatus'),
          gmtCreate?: long(name='GmtCreate'),
          parentId?: string(name='ParentId'),
          pushContent?: string(name='PushContent'),
          pushTime?: long(name='PushTime'),
          pushTitle?: string(name='PushTitle'),
          strategyType?: int32(name='StrategyType'),
          type?: int32(name='Type'),
          uniqueId?: string(name='UniqueId'),
        }
      ](name='List'),
      totalCount?: int32(name='TotalCount'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMpsSchedulerListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMpsSchedulerListResponseBody(name='body'),
}

/**
 * @param request QueryMpsSchedulerListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMpsSchedulerListResponse
 */
@context("queryMpsSchedulerListWithContext")
async function queryMpsSchedulerListWithOptions(request: QueryMpsSchedulerListRequest, runtime: $RuntimeOptions): QueryMpsSchedulerListResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!$isNull(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }
  if (!$isNull(request.uniqueId)) {
    body['UniqueId'] = request.uniqueId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryMpsSchedulerList',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryMpsSchedulerListRequest
 * @return QueryMpsSchedulerListResponse
 */
async function queryMpsSchedulerList(request: QueryMpsSchedulerListRequest): QueryMpsSchedulerListResponse {
  var runtime = new $RuntimeOptions{};
  return queryMpsSchedulerListWithOptions(request, runtime);
}

model QueryPushAnalysisCoreIndexRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  channel?: string(name='Channel'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  platform?: string(name='Platform'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
  taskId?: string(name='TaskId'),
  tenantId?: string(name='TenantId'),
  type?: string(name='Type'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryPushAnalysisCoreIndexResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      arrivalNum?: float(name='ArrivalNum'),
      arrivalRate?: float(name='ArrivalRate'),
      ignoreNum?: float(name='IgnoreNum'),
      ignoreRate?: float(name='IgnoreRate'),
      openNum?: float(name='OpenNum'),
      openRate?: float(name='OpenRate'),
      pushNum?: float(name='PushNum'),
      pushTotalNum?: float(name='PushTotalNum'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushAnalysisCoreIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushAnalysisCoreIndexResponseBody(name='body'),
}

/**
 * @param request QueryPushAnalysisCoreIndexRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryPushAnalysisCoreIndexResponse
 */
@context("queryPushAnalysisCoreIndexWithContext")
async function queryPushAnalysisCoreIndexWithOptions(request: QueryPushAnalysisCoreIndexRequest, runtime: $RuntimeOptions): QueryPushAnalysisCoreIndexResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.channel)) {
    body['Channel'] = request.channel;
  }
  if (!$isNull(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!$isNull(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!$isNull(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryPushAnalysisCoreIndex',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryPushAnalysisCoreIndexRequest
 * @return QueryPushAnalysisCoreIndexResponse
 */
async function queryPushAnalysisCoreIndex(request: QueryPushAnalysisCoreIndexRequest): QueryPushAnalysisCoreIndexResponse {
  var runtime = new $RuntimeOptions{};
  return queryPushAnalysisCoreIndexWithOptions(request, runtime);
}

model QueryPushAnalysisTaskDetailRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  taskId?: string(name='TaskId', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryPushAnalysisTaskDetailResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      duration?: string(name='Duration'),
      endTime?: long(name='EndTime'),
      pushArrivalNum?: float(name='PushArrivalNum'),
      pushNum?: float(name='PushNum'),
      pushSuccessNum?: float(name='PushSuccessNum'),
      startTime?: long(name='StartTime'),
      taskId?: long(name='TaskId'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushAnalysisTaskDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushAnalysisTaskDetailResponseBody(name='body'),
}

/**
 * @param request QueryPushAnalysisTaskDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryPushAnalysisTaskDetailResponse
 */
@context("queryPushAnalysisTaskDetailWithContext")
async function queryPushAnalysisTaskDetailWithOptions(request: QueryPushAnalysisTaskDetailRequest, runtime: $RuntimeOptions): QueryPushAnalysisTaskDetailResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryPushAnalysisTaskDetail',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryPushAnalysisTaskDetailRequest
 * @return QueryPushAnalysisTaskDetailResponse
 */
async function queryPushAnalysisTaskDetail(request: QueryPushAnalysisTaskDetailRequest): QueryPushAnalysisTaskDetailResponse {
  var runtime = new $RuntimeOptions{};
  return queryPushAnalysisTaskDetailWithOptions(request, runtime);
}

model QueryPushAnalysisTaskListRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
  taskId?: string(name='TaskId'),
  taskName?: string(name='TaskName'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryPushAnalysisTaskListResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: [ 
      {
        gmtCreate?: long(name='GmtCreate'),
        list?: [ 
          {
            gmtCreate?: long(name='GmtCreate'),
            taskId?: string(name='TaskId'),
            taskName?: string(name='TaskName'),
            templateId?: string(name='TemplateId'),
            templateName?: string(name='TemplateName'),
            type?: long(name='Type'),
          }
        ](name='List'),
        taskId?: string(name='TaskId'),
        taskName?: string(name='TaskName'),
        templateId?: string(name='TemplateId'),
        templateName?: string(name='TemplateName'),
        type?: long(name='Type'),
      }
    ](name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushAnalysisTaskListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushAnalysisTaskListResponseBody(name='body'),
}

/**
 * @param request QueryPushAnalysisTaskListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryPushAnalysisTaskListResponse
 */
@context("queryPushAnalysisTaskListWithContext")
async function queryPushAnalysisTaskListWithOptions(request: QueryPushAnalysisTaskListRequest, runtime: $RuntimeOptions): QueryPushAnalysisTaskListResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryPushAnalysisTaskList',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryPushAnalysisTaskListRequest
 * @return QueryPushAnalysisTaskListResponse
 */
async function queryPushAnalysisTaskList(request: QueryPushAnalysisTaskListRequest): QueryPushAnalysisTaskListResponse {
  var runtime = new $RuntimeOptions{};
  return queryPushAnalysisTaskListWithOptions(request, runtime);
}

model QueryPushSchedulerListRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  type?: int32(name='Type'),
  uniqueId?: string(name='UniqueId'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model QueryPushSchedulerListResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      list?: [ 
        {
          createType?: int32(name='CreateType'),
          deliveryType?: int32(name='DeliveryType'),
          executedStatus?: string(name='ExecutedStatus'),
          gmtCreate?: long(name='GmtCreate'),
          parentId?: string(name='ParentId'),
          pushContent?: string(name='PushContent'),
          pushTime?: long(name='PushTime'),
          pushTitle?: string(name='PushTitle'),
          strategyType?: int32(name='StrategyType'),
          type?: int32(name='Type'),
          uniqueId?: string(name='UniqueId'),
        }
      ](name='List'),
      totalCount?: int32(name='TotalCount'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushSchedulerListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushSchedulerListResponseBody(name='body'),
}

/**
 * @param request QueryPushSchedulerListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryPushSchedulerListResponse
 */
@context("queryPushSchedulerListWithContext")
async function queryPushSchedulerListWithOptions(request: QueryPushSchedulerListRequest, runtime: $RuntimeOptions): QueryPushSchedulerListResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!$isNull(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }
  if (!$isNull(request.uniqueId)) {
    body['UniqueId'] = request.uniqueId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'QueryPushSchedulerList',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request QueryPushSchedulerListRequest
 * @return QueryPushSchedulerListResponse
 */
async function queryPushSchedulerList(request: QueryPushSchedulerListRequest): QueryPushSchedulerListResponse {
  var runtime = new $RuntimeOptions{};
  return queryPushSchedulerListWithOptions(request, runtime);
}

model RevokePushMessageRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  messageId?: string(name='MessageId', description='This parameter is required.'),
  targetId?: string(name='TargetId', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model RevokePushMessageResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model RevokePushMessageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokePushMessageResponseBody(name='body'),
}

/**
 * @param request RevokePushMessageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokePushMessageResponse
 */
@context("revokePushMessageWithContext")
async function revokePushMessageWithOptions(request: RevokePushMessageRequest, runtime: $RuntimeOptions): RevokePushMessageResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.messageId)) {
    body['MessageId'] = request.messageId;
  }
  if (!$isNull(request.targetId)) {
    body['TargetId'] = request.targetId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RevokePushMessage',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RevokePushMessageRequest
 * @return RevokePushMessageResponse
 */
async function revokePushMessage(request: RevokePushMessageRequest): RevokePushMessageResponse {
  var runtime = new $RuntimeOptions{};
  return revokePushMessageWithOptions(request, runtime);
}

model RevokePushTaskRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  taskId?: string(name='TaskId', description='This parameter is required.'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model RevokePushTaskResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model RevokePushTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokePushTaskResponseBody(name='body'),
}

/**
 * @param request RevokePushTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokePushTaskResponse
 */
@context("revokePushTaskWithContext")
async function revokePushTaskWithOptions(request: RevokePushTaskRequest, runtime: $RuntimeOptions): RevokePushTaskResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RevokePushTask',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RevokePushTaskRequest
 * @return RevokePushTaskResponse
 */
async function revokePushTask(request: RevokePushTaskRequest): RevokePushTaskResponse {
  var runtime = new $RuntimeOptions{};
  return revokePushTaskWithOptions(request, runtime);
}

model RunMsaDiffRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  mpaasMappcenterMsaDiffRunJsonStr?: string(name='MpaasMappcenterMsaDiffRunJsonStr', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model RunMsaDiffResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model RunMsaDiffResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RunMsaDiffResponseBody(name='body'),
}

/**
 * @param request RunMsaDiffRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RunMsaDiffResponse
 */
@context("runMsaDiffWithContext")
async function runMsaDiffWithOptions(request: RunMsaDiffRequest, runtime: $RuntimeOptions): RunMsaDiffResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.mpaasMappcenterMsaDiffRunJsonStr)) {
    body['MpaasMappcenterMsaDiffRunJsonStr'] = request.mpaasMappcenterMsaDiffRunJsonStr;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RunMsaDiff',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request RunMsaDiffRequest
 * @return RunMsaDiffResponse
 */
async function runMsaDiff(request: RunMsaDiffRequest): RunMsaDiffResponse {
  var runtime = new $RuntimeOptions{};
  return runMsaDiffWithOptions(request, runtime);
}

model SaveMgsApirestRequest {
  appId?: string(name='AppId'),
  mpaasMappcenterMgsApirestSaveJsonStr?: string(name='MpaasMappcenterMgsApirestSaveJsonStr'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model SaveMgsApirestResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    errorMessage?: string(name='ErrorMessage'),
    success?: boolean(name='Success'),
    value?: boolean(name='Value'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model SaveMgsApirestResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SaveMgsApirestResponseBody(name='body'),
}

/**
 * @param request SaveMgsApirestRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveMgsApirestResponse
 */
@context("saveMgsApirestWithContext")
async function saveMgsApirestWithOptions(request: SaveMgsApirestRequest, runtime: $RuntimeOptions): SaveMgsApirestResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.mpaasMappcenterMgsApirestSaveJsonStr)) {
    body['MpaasMappcenterMgsApirestSaveJsonStr'] = request.mpaasMappcenterMgsApirestSaveJsonStr;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'SaveMgsApirest',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request SaveMgsApirestRequest
 * @return SaveMgsApirestResponse
 */
async function saveMgsApirest(request: SaveMgsApirestRequest): SaveMgsApirestResponse {
  var runtime = new $RuntimeOptions{};
  return saveMgsApirestWithOptions(request, runtime);
}

model StartUserAppAsyncEnhanceInMsaRequest {
  apkProtector?: boolean(name='ApkProtector'),
  appId?: string(name='AppId', description='This parameter is required.'),
  assetsFileList?: string(name='AssetsFileList'),
  classes?: string(name='Classes'),
  dalvikDebugger?: int32(name='DalvikDebugger'),
  emulatorEnvironment?: int32(name='EmulatorEnvironment'),
  id?: long(name='Id', description='This parameter is required.'),
  javaHook?: int32(name='JavaHook'),
  memoryDump?: int32(name='MemoryDump'),
  nativeDebugger?: int32(name='NativeDebugger'),
  nativeHook?: int32(name='NativeHook'),
  packageTampered?: int32(name='PackageTampered'),
  root?: int32(name='Root'),
  runMode?: string(name='RunMode'),
  soFileList?: string(name='SoFileList'),
  taskType?: string(name='TaskType'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  totalSwitch?: boolean(name='TotalSwitch'),
  useAShield?: boolean(name='UseAShield'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model StartUserAppAsyncEnhanceInMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: {
      afterMd5?: string(name='AfterMd5'),
      afterSize?: long(name='AfterSize'),
      appCode?: string(name='AppCode'),
      appPackage?: string(name='AppPackage'),
      assetsFileList?: [ string ](name='AssetsFileList'),
      beforeMd5?: string(name='BeforeMd5'),
      beforeSize?: long(name='BeforeSize'),
      classForest?: string(name='ClassForest'),
      enhanceMapping?: [ 
        {
          info?: string(name='Info'),
          reason?: string(name='Reason'),
          type?: string(name='Type'),
        }
      ](name='EnhanceMapping'),
      enhanceRules?: [ string ](name='EnhanceRules'),
      enhancedAssetsFiles?: [ string ](name='EnhancedAssetsFiles'),
      enhancedClasses?: [ string ](name='EnhancedClasses'),
      enhancedSoFiles?: [ string ](name='EnhancedSoFiles'),
      id?: long(name='Id'),
      label?: string(name='Label'),
      progress?: long(name='Progress'),
      soFileList?: [ string ](name='SoFileList'),
      status?: long(name='Status'),
      taskType?: string(name='TaskType'),
      versionCode?: string(name='VersionCode'),
      versionName?: string(name='VersionName'),
    }(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model StartUserAppAsyncEnhanceInMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartUserAppAsyncEnhanceInMsaResponseBody(name='body'),
}

/**
 * @param request StartUserAppAsyncEnhanceInMsaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartUserAppAsyncEnhanceInMsaResponse
 */
@context("startUserAppAsyncEnhanceInMsaWithContext")
async function startUserAppAsyncEnhanceInMsaWithOptions(request: StartUserAppAsyncEnhanceInMsaRequest, runtime: $RuntimeOptions): StartUserAppAsyncEnhanceInMsaResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.apkProtector)) {
    body['ApkProtector'] = request.apkProtector;
  }
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.assetsFileList)) {
    body['AssetsFileList'] = request.assetsFileList;
  }
  if (!$isNull(request.classes)) {
    body['Classes'] = request.classes;
  }
  if (!$isNull(request.dalvikDebugger)) {
    body['DalvikDebugger'] = request.dalvikDebugger;
  }
  if (!$isNull(request.emulatorEnvironment)) {
    body['EmulatorEnvironment'] = request.emulatorEnvironment;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.javaHook)) {
    body['JavaHook'] = request.javaHook;
  }
  if (!$isNull(request.memoryDump)) {
    body['MemoryDump'] = request.memoryDump;
  }
  if (!$isNull(request.nativeDebugger)) {
    body['NativeDebugger'] = request.nativeDebugger;
  }
  if (!$isNull(request.nativeHook)) {
    body['NativeHook'] = request.nativeHook;
  }
  if (!$isNull(request.packageTampered)) {
    body['PackageTampered'] = request.packageTampered;
  }
  if (!$isNull(request.root)) {
    body['Root'] = request.root;
  }
  if (!$isNull(request.runMode)) {
    body['RunMode'] = request.runMode;
  }
  if (!$isNull(request.soFileList)) {
    body['SoFileList'] = request.soFileList;
  }
  if (!$isNull(request.taskType)) {
    body['TaskType'] = request.taskType;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.totalSwitch)) {
    body['TotalSwitch'] = request.totalSwitch;
  }
  if (!$isNull(request.useAShield)) {
    body['UseAShield'] = request.useAShield;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'StartUserAppAsyncEnhanceInMsa',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request StartUserAppAsyncEnhanceInMsaRequest
 * @return StartUserAppAsyncEnhanceInMsaResponse
 */
async function startUserAppAsyncEnhanceInMsa(request: StartUserAppAsyncEnhanceInMsaRequest): StartUserAppAsyncEnhanceInMsaResponse {
  var runtime = new $RuntimeOptions{};
  return startUserAppAsyncEnhanceInMsaWithOptions(request, runtime);
}

model UpdateLinkRequest {
  appId?: string(name='AppId', description='This parameter is required.', example='BB5953C300957'),
  cors?: boolean(name='Cors', example='true'),
  domain?: string(name='Domain', example='x519.cn'),
  dynamicfield?: string(name='Dynamicfield', example='txt'),
  targetUrl?: string(name='TargetUrl', description='This parameter is required.', example='https://********'),
  url?: string(name='Url', description='This parameter is required.', example='https://xxx/8hGb9SyJARqp7V4PGP92X'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.', example='default'),
}

model UpdateLinkResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  resultCode?: string(name='ResultCode', example='100'),
  resultContent?: {
    data?: string(name='Data', example='https://xxx/xxx'),
    target?: string(name='Target', example='https://xxx/xxx/xxx'),
    version?: string(name='Version', example='1'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage', example='success'),
}

model UpdateLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLinkResponseBody(name='body'),
}

/**
 * @summary 更新短链
 *
 * @param request UpdateLinkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateLinkResponse
 */
@context("updateLinkWithContext")
async function updateLinkWithOptions(request: UpdateLinkRequest, runtime: $RuntimeOptions): UpdateLinkResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.cors)) {
    body['Cors'] = request.cors;
  }
  if (!$isNull(request.domain)) {
    body['Domain'] = request.domain;
  }
  if (!$isNull(request.dynamicfield)) {
    body['Dynamicfield'] = request.dynamicfield;
  }
  if (!$isNull(request.targetUrl)) {
    body['TargetUrl'] = request.targetUrl;
  }
  if (!$isNull(request.url)) {
    body['Url'] = request.url;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateLink',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新短链
 *
 * @param request UpdateLinkRequest
 * @return UpdateLinkResponse
 */
async function updateLink(request: UpdateLinkRequest): UpdateLinkResponse {
  var runtime = new $RuntimeOptions{};
  return updateLinkWithOptions(request, runtime);
}

model UpdateMcubeWhitelistRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  id?: string(name='Id', description='This parameter is required.'),
  keyIds?: string(name='KeyIds'),
  onexFlag?: boolean(name='OnexFlag', description='This parameter is required.'),
  ossUrl?: string(name='OssUrl'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model UpdateMcubeWhitelistResponseBody = {
  addWhitelistResult?: {
    addWhitelistInfo?: {
      failNum?: long(name='FailNum'),
      failUserIds?: string(name='FailUserIds'),
      successNum?: long(name='SuccessNum'),
    }(name='AddWhitelistInfo'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='AddWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model UpdateMcubeWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMcubeWhitelistResponseBody(name='body'),
}

/**
 * @param request UpdateMcubeWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMcubeWhitelistResponse
 */
@context("updateMcubeWhitelistWithContext")
async function updateMcubeWhitelistWithOptions(request: UpdateMcubeWhitelistRequest, runtime: $RuntimeOptions): UpdateMcubeWhitelistResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.id)) {
    body['Id'] = request.id;
  }
  if (!$isNull(request.keyIds)) {
    body['KeyIds'] = request.keyIds;
  }
  if (!$isNull(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!$isNull(request.ossUrl)) {
    body['OssUrl'] = request.ossUrl;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateMcubeWhitelist',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateMcubeWhitelistRequest
 * @return UpdateMcubeWhitelistResponse
 */
async function updateMcubeWhitelist(request: UpdateMcubeWhitelistRequest): UpdateMcubeWhitelistResponse {
  var runtime = new $RuntimeOptions{};
  return updateMcubeWhitelistWithOptions(request, runtime);
}

model UpdateMpaasAppInfoRequest {
  appId?: string(name='AppId'),
  appName?: string(name='AppName'),
  iconFileUrl?: string(name='IconFileUrl'),
  identifier?: string(name='Identifier'),
  onexFlag?: boolean(name='OnexFlag'),
  systemType?: string(name='SystemType'),
  tenantId?: string(name='TenantId'),
}

model UpdateMpaasAppInfoResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      appId?: string(name='AppId'),
      code?: string(name='Code'),
      data?: string(name='Data'),
      message?: string(name='Message'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model UpdateMpaasAppInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMpaasAppInfoResponseBody(name='body'),
}

/**
 * @param request UpdateMpaasAppInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMpaasAppInfoResponse
 */
@context("updateMpaasAppInfoWithContext")
async function updateMpaasAppInfoWithOptions(request: UpdateMpaasAppInfoRequest, runtime: $RuntimeOptions): UpdateMpaasAppInfoResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.appName)) {
    body['AppName'] = request.appName;
  }
  if (!$isNull(request.iconFileUrl)) {
    body['IconFileUrl'] = request.iconFileUrl;
  }
  if (!$isNull(request.identifier)) {
    body['Identifier'] = request.identifier;
  }
  if (!$isNull(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!$isNull(request.systemType)) {
    body['SystemType'] = request.systemType;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateMpaasAppInfo',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UpdateMpaasAppInfoRequest
 * @return UpdateMpaasAppInfoResponse
 */
async function updateMpaasAppInfo(request: UpdateMpaasAppInfoRequest): UpdateMpaasAppInfoResponse {
  var runtime = new $RuntimeOptions{};
  return updateMpaasAppInfoWithOptions(request, runtime);
}

model UploadBitcodeToMsaRequest {
  appId?: string(name='AppId', description='This parameter is required.', example='ALIPUBE5C3F6D091419'),
  bitcode?: string(name='Bitcode', example='3sAXCwAAAAAUAAAACHoAAP'),
  codeVersion?: string(name='CodeVersion', example='xcode14'),
  license?: string(name='License', example='{}'),
  tenantId?: string(name='TenantId', description='This parameter is required.', example='ZXCXMAHQ-zh_CN'),
  type?: string(name='Type'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.', example='dev'),
}

model UploadBitcodeToMsaResponseBody = {
  requestId?: string(name='RequestId', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  resultCode?: string(name='ResultCode', example='OK'),
  resultContent?: {
    code?: string(name='Code', example='200'),
    data?: string(name='Data', example='1234'),
    message?: string(name='Message', example='Normal'),
    success?: boolean(name='Success', example='True'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage', example='SYSTEM_ERROR'),
}

model UploadBitcodeToMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadBitcodeToMsaResponseBody(name='body'),
}

/**
 * @summary 上传字节码到msa进行加固
 *
 * @param request UploadBitcodeToMsaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadBitcodeToMsaResponse
 */
@context("uploadBitcodeToMsaWithContext")
async function uploadBitcodeToMsaWithOptions(request: UploadBitcodeToMsaRequest, runtime: $RuntimeOptions): UploadBitcodeToMsaResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.bitcode)) {
    body['Bitcode'] = request.bitcode;
  }
  if (!$isNull(request.codeVersion)) {
    body['CodeVersion'] = request.codeVersion;
  }
  if (!$isNull(request.license)) {
    body['License'] = request.license;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.type)) {
    body['Type'] = request.type;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UploadBitcodeToMsa',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 上传字节码到msa进行加固
 *
 * @param request UploadBitcodeToMsaRequest
 * @return UploadBitcodeToMsaResponse
 */
async function uploadBitcodeToMsa(request: UploadBitcodeToMsaRequest): UploadBitcodeToMsaResponse {
  var runtime = new $RuntimeOptions{};
  return uploadBitcodeToMsaWithOptions(request, runtime);
}

model UploadMcubeMiniPackageRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  autoInstall?: long(name='AutoInstall', description='This parameter is required.'),
  clientVersionMax?: string(name='ClientVersionMax'),
  clientVersionMin?: string(name='ClientVersionMin', description='This parameter is required.'),
  enableKeepAlive?: string(name='EnableKeepAlive', description='This parameter is required.'),
  enableOptionMenu?: string(name='EnableOptionMenu', description='This parameter is required.'),
  enableTabBar?: long(name='EnableTabBar', description='This parameter is required.'),
  extendInfo?: string(name='ExtendInfo'),
  h5Id?: string(name='H5Id', description='This parameter is required.'),
  h5Name?: string(name='H5Name', description='This parameter is required.'),
  h5Version?: string(name='H5Version', description='This parameter is required.'),
  iconFileUrl?: string(name='IconFileUrl'),
  iconUrl?: string(name='IconUrl'),
  installType?: long(name='InstallType', description='This parameter is required.'),
  mainUrl?: string(name='MainUrl', description='This parameter is required.'),
  onexFlag?: boolean(name='OnexFlag', description='This parameter is required.'),
  packageType?: long(name='PackageType', description='This parameter is required.'),
  platform?: string(name='Platform', description='This parameter is required.'),
  resourceFileUrl?: string(name='ResourceFileUrl', description='This parameter is required.'),
  resourceType?: long(name='ResourceType', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  userId?: string(name='UserId', description='This parameter is required.'),
  uuid?: string(name='Uuid'),
  vhost?: string(name='Vhost', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model UploadMcubeMiniPackageResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  uploadMiniPackageResult?: {
    resultMsg?: string(name='ResultMsg'),
    returnPackageResult?: {
      debugUrl?: string(name='DebugUrl'),
      packageId?: string(name='PackageId'),
      userId?: string(name='UserId'),
    }(name='ReturnPackageResult'),
    success?: boolean(name='Success'),
  }(name='UploadMiniPackageResult'),
}

model UploadMcubeMiniPackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadMcubeMiniPackageResponseBody(name='body'),
}

/**
 * @param request UploadMcubeMiniPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadMcubeMiniPackageResponse
 */
@context("uploadMcubeMiniPackageWithContext")
async function uploadMcubeMiniPackageWithOptions(request: UploadMcubeMiniPackageRequest, runtime: $RuntimeOptions): UploadMcubeMiniPackageResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.autoInstall)) {
    body['AutoInstall'] = request.autoInstall;
  }
  if (!$isNull(request.clientVersionMax)) {
    body['ClientVersionMax'] = request.clientVersionMax;
  }
  if (!$isNull(request.clientVersionMin)) {
    body['ClientVersionMin'] = request.clientVersionMin;
  }
  if (!$isNull(request.enableKeepAlive)) {
    body['EnableKeepAlive'] = request.enableKeepAlive;
  }
  if (!$isNull(request.enableOptionMenu)) {
    body['EnableOptionMenu'] = request.enableOptionMenu;
  }
  if (!$isNull(request.enableTabBar)) {
    body['EnableTabBar'] = request.enableTabBar;
  }
  if (!$isNull(request.extendInfo)) {
    body['ExtendInfo'] = request.extendInfo;
  }
  if (!$isNull(request.h5Id)) {
    body['H5Id'] = request.h5Id;
  }
  if (!$isNull(request.h5Name)) {
    body['H5Name'] = request.h5Name;
  }
  if (!$isNull(request.h5Version)) {
    body['H5Version'] = request.h5Version;
  }
  if (!$isNull(request.iconFileUrl)) {
    body['IconFileUrl'] = request.iconFileUrl;
  }
  if (!$isNull(request.iconUrl)) {
    body['IconUrl'] = request.iconUrl;
  }
  if (!$isNull(request.installType)) {
    body['InstallType'] = request.installType;
  }
  if (!$isNull(request.mainUrl)) {
    body['MainUrl'] = request.mainUrl;
  }
  if (!$isNull(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!$isNull(request.packageType)) {
    body['PackageType'] = request.packageType;
  }
  if (!$isNull(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!$isNull(request.resourceFileUrl)) {
    body['ResourceFileUrl'] = request.resourceFileUrl;
  }
  if (!$isNull(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!$isNull(request.uuid)) {
    body['Uuid'] = request.uuid;
  }
  if (!$isNull(request.vhost)) {
    body['Vhost'] = request.vhost;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UploadMcubeMiniPackage',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UploadMcubeMiniPackageRequest
 * @return UploadMcubeMiniPackageResponse
 */
async function uploadMcubeMiniPackage(request: UploadMcubeMiniPackageRequest): UploadMcubeMiniPackageResponse {
  var runtime = new $RuntimeOptions{};
  return uploadMcubeMiniPackageWithOptions(request, runtime);
}

model UploadMcubeRsaKeyRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  fileUrl?: string(name='FileUrl', description='This parameter is required.'),
  onexFlag?: boolean(name='OnexFlag', description='This parameter is required.'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model UploadMcubeRsaKeyResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  uploadRsaResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='UploadRsaResult'),
}

model UploadMcubeRsaKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadMcubeRsaKeyResponseBody(name='body'),
}

/**
 * @param request UploadMcubeRsaKeyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadMcubeRsaKeyResponse
 */
@context("uploadMcubeRsaKeyWithContext")
async function uploadMcubeRsaKeyWithOptions(request: UploadMcubeRsaKeyRequest, runtime: $RuntimeOptions): UploadMcubeRsaKeyResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.fileUrl)) {
    body['FileUrl'] = request.fileUrl;
  }
  if (!$isNull(request.onexFlag)) {
    body['OnexFlag'] = request.onexFlag;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UploadMcubeRsaKey',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UploadMcubeRsaKeyRequest
 * @return UploadMcubeRsaKeyResponse
 */
async function uploadMcubeRsaKey(request: UploadMcubeRsaKeyRequest): UploadMcubeRsaKeyResponse {
  var runtime = new $RuntimeOptions{};
  return uploadMcubeRsaKeyWithOptions(request, runtime);
}

model UploadUserAppToMsaRequest {
  appId?: string(name='AppId', description='This parameter is required.'),
  fileUrl?: string(name='FileUrl'),
  tenantId?: string(name='TenantId', description='This parameter is required.'),
  workspaceId?: string(name='WorkspaceId', description='This parameter is required.'),
}

model UploadUserAppToMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: {
      apkInfo?: {
        afterMd5?: string(name='AfterMd5'),
        afterSize?: long(name='AfterSize'),
        appCode?: string(name='AppCode'),
        appPackage?: string(name='AppPackage'),
        beforeMd5?: string(name='BeforeMd5'),
        beforeSize?: long(name='BeforeSize'),
        classForest?: string(name='ClassForest'),
        enhanceMapping?: {
          info?: string(name='Info'),
          reason?: string(name='Reason'),
          type?: string(name='Type'),
        }(name='EnhanceMapping'),
        enhanceRules?: [ string ](name='EnhanceRules'),
        enhancedClasses?: [ string ](name='EnhancedClasses'),
        id?: long(name='Id'),
        label?: string(name='Label'),
        progress?: long(name='Progress'),
        status?: long(name='Status'),
        taskType?: string(name='TaskType'),
        versionCode?: string(name='VersionCode'),
        versionName?: string(name='VersionName'),
      }(name='ApkInfo'),
      enhanceTaskId?: long(name='EnhanceTaskId'),
      id?: long(name='Id'),
      progress?: long(name='Progress'),
      status?: long(name='Status'),
    }(name='Data'),
    extra?: string(name='Extra'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model UploadUserAppToMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadUserAppToMsaResponseBody(name='body'),
}

/**
 * @param request UploadUserAppToMsaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadUserAppToMsaResponse
 */
@context("uploadUserAppToMsaWithContext")
async function uploadUserAppToMsaWithOptions(request: UploadUserAppToMsaRequest, runtime: $RuntimeOptions): UploadUserAppToMsaResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!$isNull(request.fileUrl)) {
    body['FileUrl'] = request.fileUrl;
  }
  if (!$isNull(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!$isNull(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UploadUserAppToMsa',
    version = '2020-10-28',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request UploadUserAppToMsaRequest
 * @return UploadUserAppToMsaResponse
 */
async function uploadUserAppToMsa(request: UploadUserAppToMsaRequest): UploadUserAppToMsaResponse {
  var runtime = new $RuntimeOptions{};
  return uploadUserAppToMsaWithOptions(request, runtime);
}

