/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'mPaaS';
  @version = '2020-10-28';
  @endpointRule = 'regional';
  @endpointMap = {
    'cn-hangzhou' = 'mpaas.aliyuncs.com',
    'ap-northeast-1' = 'mpaas.aliyuncs.com',
    'ap-northeast-2-pop' = 'mpaas.aliyuncs.com',
    'ap-south-1' = 'mpaas.aliyuncs.com',
    'ap-southeast-1' = 'mpaas.aliyuncs.com',
    'ap-southeast-2' = 'mpaas.aliyuncs.com',
    'ap-southeast-3' = 'mpaas.aliyuncs.com',
    'ap-southeast-5' = 'mpaas.aliyuncs.com',
    'cn-beijing' = 'mpaas.aliyuncs.com',
    'cn-beijing-finance-1' = 'mpaas.aliyuncs.com',
    'cn-beijing-finance-pop' = 'mpaas.aliyuncs.com',
    'cn-beijing-gov-1' = 'mpaas.aliyuncs.com',
    'cn-beijing-nu16-b01' = 'mpaas.aliyuncs.com',
    'cn-chengdu' = 'mpaas.aliyuncs.com',
    'cn-edge-1' = 'mpaas.aliyuncs.com',
    'cn-fujian' = 'mpaas.aliyuncs.com',
    'cn-haidian-cm12-c01' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-bj-b01' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-finance' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-prod-1' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-test-1' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-test-2' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-internal-test-3' = 'mpaas.aliyuncs.com',
    'cn-hangzhou-test-306' = 'mpaas.aliyuncs.com',
    'cn-hongkong' = 'mpaas.aliyuncs.com',
    'cn-hongkong-finance-pop' = 'mpaas.aliyuncs.com',
    'cn-huhehaote' = 'mpaas.aliyuncs.com',
    'cn-north-2-gov-1' = 'mpaas.aliyuncs.com',
    'cn-qingdao' = 'mpaas.aliyuncs.com',
    'cn-qingdao-nebula' = 'mpaas.aliyuncs.com',
    'cn-shanghai' = 'mpaas.aliyuncs.com',
    'cn-shanghai-et15-b01' = 'mpaas.aliyuncs.com',
    'cn-shanghai-et2-b01' = 'mpaas.aliyuncs.com',
    'cn-shanghai-finance-1' = 'mpaas.aliyuncs.com',
    'cn-shanghai-inner' = 'mpaas.aliyuncs.com',
    'cn-shanghai-internal-test-1' = 'mpaas.aliyuncs.com',
    'cn-shenzhen' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-finance-1' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-inner' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-st4-d01' = 'mpaas.aliyuncs.com',
    'cn-shenzhen-su18-b01' = 'mpaas.aliyuncs.com',
    'cn-wuhan' = 'mpaas.aliyuncs.com',
    'cn-yushanfang' = 'mpaas.aliyuncs.com',
    'cn-zhangbei-na61-b01' = 'mpaas.aliyuncs.com',
    'cn-zhangjiakou' = 'mpaas.aliyuncs.com',
    'cn-zhangjiakou-na62-a01' = 'mpaas.aliyuncs.com',
    'cn-zhengzhou-nebula-1' = 'mpaas.aliyuncs.com',
    'eu-central-1' = 'mpaas.aliyuncs.com',
    'eu-west-1' = 'mpaas.aliyuncs.com',
    'eu-west-1-oxs' = 'mpaas.aliyuncs.com',
    'me-east-1' = 'mpaas.aliyuncs.com',
    'rus-west-1-pop' = 'mpaas.aliyuncs.com',
    'us-east-1' = 'mpaas.aliyuncs.com',
    'us-west-1' = 'mpaas.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AddMdsMiniConfigRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  mpaasMappcenterMiniConfigAddJsonStr: string(name='MpaasMappcenterMiniConfigAddJsonStr', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model AddMdsMiniConfigResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      requestId?: string(name='RequestId'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model AddMdsMiniConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddMdsMiniConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of AddMdsMiniConfig  AddMdsMiniConfigRequest
  * @return AddMdsMiniConfigResponse
 */
async function addMdsMiniConfig(request: AddMdsMiniConfigRequest): AddMdsMiniConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddMdsMiniConfig', 'POST', '/', 'json', true, 'form', request);
}

model CancelPushSchedulerRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  type?: int32(name='Type', position='Body'),
  uniqueIds: string(name='UniqueIds', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CancelPushSchedulerResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CancelPushSchedulerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelPushSchedulerResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CancelPushScheduler  CancelPushSchedulerRequest
  * @return CancelPushSchedulerResponse
 */
async function cancelPushScheduler(request: CancelPushSchedulerRequest): CancelPushSchedulerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelPushScheduler', 'POST', '/', 'json', true, 'form', request);
}

model ChangeMcubeMiniTaskStatusRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  bizType: string(name='BizType', description='This parameter is required.', position='Body'),
  packageId: long(name='PackageId', description='This parameter is required.', position='Body'),
  taskId: long(name='TaskId', description='This parameter is required.', position='Body'),
  taskStatus: long(name='TaskStatus', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model ChangeMcubeMiniTaskStatusResponseBody = {
  changeMiniTaskStatusResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ChangeMiniTaskStatusResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ChangeMcubeMiniTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeMcubeMiniTaskStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ChangeMcubeMiniTaskStatus  ChangeMcubeMiniTaskStatusRequest
  * @return ChangeMcubeMiniTaskStatusResponse
 */
async function changeMcubeMiniTaskStatus(request: ChangeMcubeMiniTaskStatusRequest): ChangeMcubeMiniTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeMcubeMiniTaskStatus', 'POST', '/', 'json', true, 'form', request);
}

model ChangeMcubeNebulaTaskStatusRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  bizType?: string(name='BizType', position='Body'),
  packageId?: string(name='PackageId', position='Body'),
  taskId?: string(name='TaskId', position='Body'),
  taskStatus?: int32(name='TaskStatus', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ChangeMcubeNebulaTaskStatusResponseBody = {
  changeMcubeNebulaTaskStatusResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ChangeMcubeNebulaTaskStatusResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ChangeMcubeNebulaTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeMcubeNebulaTaskStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ChangeMcubeNebulaTaskStatus  ChangeMcubeNebulaTaskStatusRequest
  * @return ChangeMcubeNebulaTaskStatusResponse
 */
async function changeMcubeNebulaTaskStatus(request: ChangeMcubeNebulaTaskStatusRequest): ChangeMcubeNebulaTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeMcubeNebulaTaskStatus', 'POST', '/', 'json', true, 'form', request);
}

model ChangeMcubePublicTaskStatusRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  taskId?: string(name='TaskId', position='Body'),
  taskStatus?: string(name='TaskStatus', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ChangeMcubePublicTaskStatusResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: string(name='Data'),
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model ChangeMcubePublicTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeMcubePublicTaskStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ChangeMcubePublicTaskStatus  ChangeMcubePublicTaskStatusRequest
  * @return ChangeMcubePublicTaskStatusResponse
 */
async function changeMcubePublicTaskStatus(request: ChangeMcubePublicTaskStatusRequest): ChangeMcubePublicTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeMcubePublicTaskStatus', 'POST', '/', 'json', true, 'form', request);
}

model CopyMcdpGroupRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  mpaasMappcenterMcdpGroupCopyJsonStr: string(name='MpaasMappcenterMcdpGroupCopyJsonStr', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CopyMcdpGroupResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CopyMcdpGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CopyMcdpGroupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CopyMcdpGroup  CopyMcdpGroupRequest
  * @return CopyMcdpGroupResponse
 */
async function copyMcdpGroup(request: CopyMcdpGroupRequest): CopyMcdpGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CopyMcdpGroup', 'POST', '/', 'json', true, 'form', request);
}

model CreateLinkRequest {
  appId: string(name='AppId', description='This parameter is required.', example='BB5953C300957', position='Body'),
  cors?: boolean(name='Cors', example='false', position='Body'),
  domain?: string(name='Domain', example='x519.cn', position='Body'),
  dynamicfield?: string(name='Dynamicfield', example='txt', position='Body'),
  targetUrl: string(name='TargetUrl', description='This parameter is required.', example='https://********', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', example='default', position='Body'),
}

model CreateLinkResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='0CC8A9CB-9BA3-13FD-A404-6E2E7461881A'),
  resultCode?: string(name='ResultCode', example='100'),
  resultContent?: {
    data?: string(name='Data', example='https://xxx/xxx'),
    target?: string(name='Target', example='https://xxx/xxx/xxx'),
    version?: string(name='Version', example='0'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage', example='success'),
}

model CreateLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLinkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateLink  CreateLinkRequest
  * @return CreateLinkResponse
 */
async function createLink(request: CreateLinkRequest): CreateLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLink', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcdpGroupRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  mpaasMappcenterMcdpGroupCreateJsonStr: string(name='MpaasMappcenterMcdpGroupCreateJsonStr', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CreateMcdpGroupResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcdpGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcdpGroupResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcdpGroup  CreateMcdpGroupRequest
  * @return CreateMcdpGroupResponse
 */
async function createMcdpGroup(request: CreateMcdpGroupRequest): CreateMcdpGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcdpGroup', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcdpMaterialRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  mpaasMappcenterMcdpMaterialCreateJsonStr: string(name='MpaasMappcenterMcdpMaterialCreateJsonStr', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CreateMcdpMaterialResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcdpMaterialResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcdpMaterialResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcdpMaterial  CreateMcdpMaterialRequest
  * @return CreateMcdpMaterialResponse
 */
async function createMcdpMaterial(request: CreateMcdpMaterialRequest): CreateMcdpMaterialResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcdpMaterial', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcdpZoneRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  mpaasMappcenterMcdpZoneCreateJsonStr: string(name='MpaasMappcenterMcdpZoneCreateJsonStr', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CreateMcdpZoneResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcdpZoneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcdpZoneResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcdpZone  CreateMcdpZoneRequest
  * @return CreateMcdpZoneResponse
 */
async function createMcdpZone(request: CreateMcdpZoneRequest): CreateMcdpZoneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcdpZone', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeMiniAppRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  h5Id: string(name='H5Id', description='This parameter is required.', position='Body'),
  h5Name: string(name='H5Name', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CreateMcubeMiniAppResponseBody = {
  createMiniResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMiniResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeMiniAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeMiniAppResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeMiniApp  CreateMcubeMiniAppRequest
  * @return CreateMcubeMiniAppResponse
 */
async function createMcubeMiniApp(request: CreateMcubeMiniAppRequest): CreateMcubeMiniAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeMiniApp', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeMiniTaskRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  greyConfigInfo?: string(name='GreyConfigInfo', position='Body'),
  greyEndtimeData?: string(name='GreyEndtimeData', position='Body'),
  greyNum?: long(name='GreyNum', position='Body'),
  memo: string(name='Memo', description='This parameter is required.', position='Body'),
  packageId: long(name='PackageId', description='This parameter is required.', position='Body'),
  publishMode: long(name='PublishMode', description='This parameter is required.', position='Body'),
  publishType: long(name='PublishType', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  whitelistIds?: string(name='WhitelistIds', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CreateMcubeMiniTaskResponseBody = {
  createMiniTaskResult?: {
    miniTaskId?: string(name='MiniTaskId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMiniTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeMiniTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeMiniTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeMiniTask  CreateMcubeMiniTaskRequest
  * @return CreateMcubeMiniTaskResponse
 */
async function createMcubeMiniTask(request: CreateMcubeMiniTaskRequest): CreateMcubeMiniTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeMiniTask', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeNebulaAppRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  h5Id?: string(name='H5Id', position='Body'),
  h5Name?: string(name='H5Name', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CreateMcubeNebulaAppResponseBody = {
  createNebulaAppResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateNebulaAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeNebulaAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeNebulaAppResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeNebulaApp  CreateMcubeNebulaAppRequest
  * @return CreateMcubeNebulaAppResponse
 */
async function createMcubeNebulaApp(request: CreateMcubeNebulaAppRequest): CreateMcubeNebulaAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeNebulaApp', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeNebulaResourceRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  autoInstall?: int32(name='AutoInstall', position='Body'),
  clientVersionMax?: string(name='ClientVersionMax', position='Body'),
  clientVersionMin?: string(name='ClientVersionMin', position='Body'),
  customDomainName?: string(name='CustomDomainName', position='Body'),
  extendInfo?: string(name='ExtendInfo', position='Body'),
  fileUrl?: string(name='FileUrl', position='Body'),
  h5Id?: string(name='H5Id', position='Body'),
  h5Name?: string(name='H5Name', position='Body'),
  h5Version?: string(name='H5Version', position='Body'),
  installType?: int32(name='InstallType', position='Body'),
  mainUrl?: string(name='MainUrl', position='Body'),
  onexFlag?: boolean(name='OnexFlag', position='Body'),
  platform?: string(name='Platform', position='Body'),
  repeatNebula?: int32(name='RepeatNebula', position='Body'),
  resourceType?: int32(name='ResourceType', position='Body'),
  subUrl?: string(name='SubUrl', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  vhost?: string(name='Vhost', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CreateMcubeNebulaResourceResponseBody = {
  createMcubeNebulaResourceReslult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaResourceId?: string(name='NebulaResourceId'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMcubeNebulaResourceReslult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeNebulaResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeNebulaResourceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeNebulaResource  CreateMcubeNebulaResourceRequest
  * @return CreateMcubeNebulaResourceResponse
 */
async function createMcubeNebulaResource(request: CreateMcubeNebulaResourceRequest): CreateMcubeNebulaResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeNebulaResource', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeNebulaTaskRequest {
  regionId?: string(name='RegionId', position='Host'),
  appCode?: string(name='AppCode', position='Body'),
  appId?: string(name='AppId', position='Body'),
  bizType?: string(name='BizType', position='Body'),
  creator?: string(name='Creator', position='Body'),
  gmtCreate?: string(name='GmtCreate', position='Body'),
  gmtModified?: string(name='GmtModified', position='Body'),
  gmtModifiedStr?: string(name='GmtModifiedStr', position='Body'),
  greyConfigInfo?: string(name='GreyConfigInfo', position='Body'),
  greyEndtime?: string(name='GreyEndtime', position='Body'),
  greyEndtimeData?: string(name='GreyEndtimeData', position='Body'),
  greyEndtimeStr?: string(name='GreyEndtimeStr', position='Body'),
  greyNum?: int32(name='GreyNum', position='Body'),
  greyUrl?: string(name='GreyUrl', position='Body'),
  id?: long(name='Id', position='Body'),
  memo?: string(name='Memo', position='Body'),
  modifier?: string(name='Modifier', position='Body'),
  packageId?: long(name='PackageId', position='Body'),
  percent?: int32(name='Percent', position='Body'),
  platform?: string(name='Platform', position='Body'),
  productId?: string(name='ProductId', position='Body'),
  productVersion?: string(name='ProductVersion', position='Body'),
  publishMode?: int32(name='PublishMode', position='Body'),
  publishType?: int32(name='PublishType', position='Body'),
  releaseVersion?: string(name='ReleaseVersion', position='Body'),
  resIds?: string(name='ResIds', position='Body'),
  serialVersionUID?: long(name='SerialVersionUID', position='Body'),
  status?: int32(name='Status', position='Body'),
  syncMode?: string(name='SyncMode', position='Body'),
  syncResult?: string(name='SyncResult', position='Body'),
  taskName?: string(name='TaskName', position='Body'),
  taskStatus?: int32(name='TaskStatus', position='Body'),
  taskType?: int32(name='TaskType', position='Body'),
  taskVersion?: long(name='TaskVersion', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  upgradeNoticeNum?: long(name='UpgradeNoticeNum', position='Body'),
  upgradeProgress?: string(name='UpgradeProgress', position='Body'),
  whitelistIds?: string(name='WhitelistIds', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CreateMcubeNebulaTaskResponseBody = {
  createMcubeNebulaTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaTaskId?: string(name='NebulaTaskId'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateMcubeNebulaTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeNebulaTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeNebulaTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeNebulaTask  CreateMcubeNebulaTaskRequest
  * @return CreateMcubeNebulaTaskResponse
 */
async function createMcubeNebulaTask(request: CreateMcubeNebulaTaskRequest): CreateMcubeNebulaTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeNebulaTask', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeUpgradePackageRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  appVersion?: string(name='AppVersion', position='Body'),
  appstoreUrl?: string(name='AppstoreUrl', position='Body'),
  bundleId?: string(name='BundleId', position='Body'),
  customDomainName?: string(name='CustomDomainName', position='Body'),
  desc?: string(name='Desc', position='Body'),
  downloadUrl?: string(name='DownloadUrl', position='Body'),
  fileUrl?: string(name='FileUrl', position='Body'),
  iconFileUrl?: string(name='IconFileUrl', position='Body'),
  installAmount?: int32(name='InstallAmount', position='Body'),
  iosSymbolfileUrl?: string(name='IosSymbolfileUrl', position='Body'),
  isEnterprise?: int32(name='IsEnterprise', position='Body'),
  needCheck?: int32(name='NeedCheck', position='Body'),
  onexFlag?: boolean(name='OnexFlag', position='Body'),
  platform?: string(name='Platform', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  validDays?: int32(name='ValidDays', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CreateMcubeUpgradePackageResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: string(name='Data'),
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeUpgradePackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeUpgradePackageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeUpgradePackage  CreateMcubeUpgradePackageRequest
  * @return CreateMcubeUpgradePackageResponse
 */
async function createMcubeUpgradePackage(request: CreateMcubeUpgradePackageRequest): CreateMcubeUpgradePackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeUpgradePackage', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeUpgradeTaskRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  greyConfigInfo?: string(name='GreyConfigInfo', position='Body'),
  greyEndtimeData?: string(name='GreyEndtimeData', position='Body'),
  greyNum?: int32(name='GreyNum', position='Body'),
  historyForce?: int32(name='HistoryForce', position='Body'),
  memo?: string(name='Memo', position='Body'),
  packageInfoId?: long(name='PackageInfoId', position='Body'),
  publishMode?: int32(name='PublishMode', position='Body'),
  publishType?: int32(name='PublishType', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  upgradeContent?: string(name='UpgradeContent', position='Body'),
  upgradeType?: int32(name='UpgradeType', position='Body'),
  whitelistIds?: string(name='WhitelistIds', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CreateMcubeUpgradeTaskResponseBody = {
  createTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    upgradeTaskId?: string(name='upgradeTaskId'),
  }(name='CreateTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeUpgradeTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeUpgradeTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeUpgradeTask  CreateMcubeUpgradeTaskRequest
  * @return CreateMcubeUpgradeTaskResponse
 */
async function createMcubeUpgradeTask(request: CreateMcubeUpgradeTaskRequest): CreateMcubeUpgradeTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeUpgradeTask', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeVhostRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  vhost: string(name='Vhost', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CreateMcubeVhostResponseBody = {
  createVhostResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CreateVhostResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeVhostResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeVhost  CreateMcubeVhostRequest
  * @return CreateMcubeVhostResponse
 */
async function createMcubeVhost(request: CreateMcubeVhostRequest): CreateMcubeVhostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeVhost', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeWhitelistRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  whiteListName: string(name='WhiteListName', description='This parameter is required.', position='Body'),
  whitelistType: string(name='WhitelistType', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CreateMcubeWhitelistResponseBody = {
  createWhitelistResult?: {
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    whitelistId?: string(name='WhitelistId'),
  }(name='CreateWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeWhitelistResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeWhitelist  CreateMcubeWhitelistRequest
  * @return CreateMcubeWhitelistResponse
 */
async function createMcubeWhitelist(request: CreateMcubeWhitelistRequest): CreateMcubeWhitelistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeWhitelist', 'POST', '/', 'json', true, 'form', request);
}

model CreateMcubeWhitelistForIdeRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  userId: string(name='UserId', description='This parameter is required.', position='Body'),
  whitelistValue: string(name='WhitelistValue', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CreateMcubeWhitelistForIdeResponseBody = {
  createWhitelistForIdeResult?: {
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    whitelistId?: string(name='WhitelistId'),
  }(name='CreateWhitelistForIdeResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMcubeWhitelistForIdeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMcubeWhitelistForIdeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMcubeWhitelistForIde  CreateMcubeWhitelistForIdeRequest
  * @return CreateMcubeWhitelistForIdeResponse
 */
async function createMcubeWhitelistForIde(request: CreateMcubeWhitelistForIdeRequest): CreateMcubeWhitelistForIdeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMcubeWhitelistForIde', 'POST', '/', 'json', true, 'form', request);
}

model CreateMdsMiniprogramTaskRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  greyConfigInfo?: string(name='GreyConfigInfo', position='Body'),
  greyEndtimeData?: string(name='GreyEndtimeData', position='Body'),
  greyNum?: string(name='GreyNum', position='Body'),
  id: long(name='Id', description='This parameter is required.', position='Body'),
  memo?: string(name='Memo', position='Body'),
  packageId: long(name='PackageId', description='This parameter is required.', position='Body'),
  publishMode?: string(name='PublishMode', position='Body'),
  publishType: long(name='PublishType', description='This parameter is required.', position='Body'),
  syncMode?: string(name='SyncMode', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  whitelistIds?: string(name='WhitelistIds', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model CreateMdsMiniprogramTaskResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      requestId?: string(name='RequestId'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateMdsMiniprogramTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMdsMiniprogramTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateMdsMiniprogramTask  CreateMdsMiniprogramTaskRequest
  * @return CreateMdsMiniprogramTaskResponse
 */
async function createMdsMiniprogramTask(request: CreateMdsMiniprogramTaskRequest): CreateMdsMiniprogramTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMdsMiniprogramTask', 'POST', '/', 'json', true, 'form', request);
}

model CreateOpenGlobalDataRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  appMaxVersion?: string(name='AppMaxVersion', position='Body'),
  appMinVersion?: string(name='AppMinVersion', position='Body'),
  bizType: string(name='BizType', description='This parameter is required.', position='Body'),
  extAttrStr?: string(name='ExtAttrStr', position='Body'),
  maxUid?: long(name='MaxUid', minimum=0, maximum=99, position='Body'),
  minUid?: long(name='MinUid', minimum=0, maximum=99, position='Body'),
  osType?: string(name='OsType', position='Body'),
  payload: string(name='Payload', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  thirdMsgId: string(name='ThirdMsgId', description='This parameter is required.', position='Body'),
  uids?: string(name='Uids', position='Body'),
  validTimeEnd?: long(name='ValidTimeEnd', minimum=0, maximum=99999999999999, position='Body'),
  validTimeStart?: long(name='ValidTimeStart', minimum=0, maximum=99999999999999, position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CreateOpenGlobalDataResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateOpenGlobalDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOpenGlobalDataResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateOpenGlobalData  CreateOpenGlobalDataRequest
  * @return CreateOpenGlobalDataResponse
 */
async function createOpenGlobalData(request: CreateOpenGlobalDataRequest): CreateOpenGlobalDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOpenGlobalData', 'POST', '/', 'json', true, 'form', request);
}

model CreateOpenSingleDataRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  appMaxVersion?: string(name='AppMaxVersion', position='Body'),
  appMinVersion?: string(name='AppMinVersion', position='Body'),
  bizType: string(name='BizType', description='This parameter is required.', position='Body'),
  checkOnline?: boolean(name='CheckOnline', position='Body'),
  extAttrStr?: string(name='ExtAttrStr', position='Body'),
  linkToken: string(name='LinkToken', description='This parameter is required.', position='Body'),
  osType?: string(name='OsType', position='Body'),
  payload: string(name='Payload', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  thirdMsgId: string(name='ThirdMsgId', description='This parameter is required.', position='Body'),
  validTimeEnd?: long(name='ValidTimeEnd', minimum=0, maximum=99999999999999, position='Body'),
  validTimeStart?: long(name='ValidTimeStart', minimum=0, maximum=99999999999999, position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model CreateOpenSingleDataResponseBody = {
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model CreateOpenSingleDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOpenSingleDataResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateOpenSingleData  CreateOpenSingleDataRequest
  * @return CreateOpenSingleDataResponse
 */
async function createOpenSingleData(request: CreateOpenSingleDataRequest): CreateOpenSingleDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOpenSingleData', 'POST', '/', 'json', true, 'form', request);
}

model DeleteCubecardWhitelistContentRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  whitelistId?: string(name='WhitelistId', position='Body'),
  whitelistValue?: string(name='WhitelistValue', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model DeleteCubecardWhitelistContentResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteCubecardWhitelistContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCubecardWhitelistContentResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteCubecardWhitelistContent  DeleteCubecardWhitelistContentRequest
  * @return DeleteCubecardWhitelistContentResponse
 */
async function deleteCubecardWhitelistContent(request: DeleteCubecardWhitelistContentRequest): DeleteCubecardWhitelistContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCubecardWhitelistContent', 'POST', '/', 'json', true, 'form', request);
}

model DeleteMcdpAimRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  mpaasMappcenterMcdpAimDeleteJsonStr: string(name='MpaasMappcenterMcdpAimDeleteJsonStr', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model DeleteMcdpAimResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcdpAimResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcdpAimResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMcdpAim  DeleteMcdpAimRequest
  * @return DeleteMcdpAimResponse
 */
async function deleteMcdpAim(request: DeleteMcdpAimRequest): DeleteMcdpAimResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMcdpAim', 'POST', '/', 'json', true, 'form', request);
}

model DeleteMcdpCrowdRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  mpaasMappcenterMcdpCrowdDeleteJsonStr: string(name='MpaasMappcenterMcdpCrowdDeleteJsonStr', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model DeleteMcdpCrowdResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcdpCrowdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcdpCrowdResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMcdpCrowd  DeleteMcdpCrowdRequest
  * @return DeleteMcdpCrowdResponse
 */
async function deleteMcdpCrowd(request: DeleteMcdpCrowdRequest): DeleteMcdpCrowdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMcdpCrowd', 'POST', '/', 'json', true, 'form', request);
}

model DeleteMcdpZoneRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  mpaasMappcenterMcdpZoneDeleteJsonStr: string(name='MpaasMappcenterMcdpZoneDeleteJsonStr', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model DeleteMcdpZoneResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcdpZoneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcdpZoneResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMcdpZone  DeleteMcdpZoneRequest
  * @return DeleteMcdpZoneResponse
 */
async function deleteMcdpZone(request: DeleteMcdpZoneRequest): DeleteMcdpZoneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMcdpZone', 'POST', '/', 'json', true, 'form', request);
}

model DeleteMcubeMiniAppRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  h5Id: string(name='H5Id', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model DeleteMcubeMiniAppResponseBody = {
  deleteMiniResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteMiniResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeMiniAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeMiniAppResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMcubeMiniApp  DeleteMcubeMiniAppRequest
  * @return DeleteMcubeMiniAppResponse
 */
async function deleteMcubeMiniApp(request: DeleteMcubeMiniAppRequest): DeleteMcubeMiniAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMcubeMiniApp', 'POST', '/', 'json', true, 'form', request);
}

model DeleteMcubeNebulaAppRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  h5Id?: string(name='H5Id', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model DeleteMcubeNebulaAppResponseBody = {
  deleteMcubeNebulaAppResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteMcubeNebulaAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeNebulaAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeNebulaAppResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMcubeNebulaApp  DeleteMcubeNebulaAppRequest
  * @return DeleteMcubeNebulaAppResponse
 */
async function deleteMcubeNebulaApp(request: DeleteMcubeNebulaAppRequest): DeleteMcubeNebulaAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMcubeNebulaApp', 'POST', '/', 'json', true, 'form', request);
}

model DeleteMcubeUpgradeResourceRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  id?: string(name='Id', position='Body'),
  platform?: string(name='Platform', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model DeleteMcubeUpgradeResourceResponseBody = {
  deleteResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeUpgradeResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeUpgradeResourceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMcubeUpgradeResource  DeleteMcubeUpgradeResourceRequest
  * @return DeleteMcubeUpgradeResourceResponse
 */
async function deleteMcubeUpgradeResource(request: DeleteMcubeUpgradeResourceRequest): DeleteMcubeUpgradeResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMcubeUpgradeResource', 'POST', '/', 'json', true, 'form', request);
}

model DeleteMcubeWhitelistRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  id: long(name='Id', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model DeleteMcubeWhitelistResponseBody = {
  deleteWhitelistResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='DeleteWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMcubeWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMcubeWhitelistResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMcubeWhitelist  DeleteMcubeWhitelistRequest
  * @return DeleteMcubeWhitelistResponse
 */
async function deleteMcubeWhitelist(request: DeleteMcubeWhitelistRequest): DeleteMcubeWhitelistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMcubeWhitelist', 'POST', '/', 'json', true, 'form', request);
}

model DeleteMdsWhitelistContentRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  whitelistId?: string(name='WhitelistId', position='Body'),
  whitelistValue?: string(name='WhitelistValue', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model DeleteMdsWhitelistContentResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: string(name='Content'),
      errorCode?: string(name='ErrorCode'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model DeleteMdsWhitelistContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMdsWhitelistContentResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteMdsWhitelistContent  DeleteMdsWhitelistContentRequest
  * @return DeleteMdsWhitelistContentResponse
 */
async function deleteMdsWhitelistContent(request: DeleteMdsWhitelistContentRequest): DeleteMdsWhitelistContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMdsWhitelistContent', 'POST', '/', 'json', true, 'form', request);
}

model ExistMcubeRsaKeyRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model ExistMcubeRsaKeyResponseBody = {
  checkRsaKeyResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='CheckRsaKeyResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ExistMcubeRsaKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExistMcubeRsaKeyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ExistMcubeRsaKey  ExistMcubeRsaKeyRequest
  * @return ExistMcubeRsaKeyResponse
 */
async function existMcubeRsaKey(request: ExistMcubeRsaKeyRequest): ExistMcubeRsaKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExistMcubeRsaKey', 'POST', '/', 'json', true, 'form', request);
}

model ExportMappCenterAppConfigRequest {
  regionId?: string(name='RegionId', position='Host'),
  apkFileUrl?: string(name='ApkFileUrl', position='Body'),
  appId?: string(name='AppId', position='Body'),
  certRsaBase64?: string(name='CertRsaBase64', position='Body'),
  identifier: string(name='Identifier', description='This parameter is required.', position='Body'),
  onexFlag: boolean(name='OnexFlag', description='This parameter is required.', position='Body'),
  systemType: string(name='SystemType', description='This parameter is required.', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ExportMappCenterAppConfigResponseBody = {
  exportMappCenterAppConfigResult?: {
    configDownloadUrl?: string(name='ConfigDownloadUrl'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ExportMappCenterAppConfigResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ExportMappCenterAppConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExportMappCenterAppConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ExportMappCenterAppConfig  ExportMappCenterAppConfigRequest
  * @return ExportMappCenterAppConfigResponse
 */
async function exportMappCenterAppConfig(request: ExportMappCenterAppConfigRequest): ExportMappCenterAppConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExportMappCenterAppConfig', 'POST', '/', 'json', true, 'form', request);
}

model GetFileTokenForUploadToMsaRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  onexFlag?: boolean(name='OnexFlag', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model GetFileTokenForUploadToMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    content?: {
      accessid?: string(name='Accessid'),
      dir?: string(name='Dir'),
      expire?: string(name='Expire'),
      host?: string(name='Host'),
      policy?: string(name='Policy'),
      signature?: string(name='Signature'),
    }(name='Content'),
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: string(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetFileTokenForUploadToMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFileTokenForUploadToMsaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetFileTokenForUploadToMsa  GetFileTokenForUploadToMsaRequest
  * @return GetFileTokenForUploadToMsaResponse
 */
async function getFileTokenForUploadToMsa(request: GetFileTokenForUploadToMsaRequest): GetFileTokenForUploadToMsaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetFileTokenForUploadToMsa', 'POST', '/', 'json', true, 'form', request);
}

model GetLogUrlInMsaRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  id?: long(name='Id', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model GetLogUrlInMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetLogUrlInMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLogUrlInMsaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetLogUrlInMsa  GetLogUrlInMsaRequest
  * @return GetLogUrlInMsaResponse
 */
async function getLogUrlInMsa(request: GetLogUrlInMsaRequest): GetLogUrlInMsaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetLogUrlInMsa', 'POST', '/', 'json', true, 'form', request);
}

model GetMcubeFileTokenRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  onexFlag: boolean(name='OnexFlag', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model GetMcubeFileTokenResponseBody = {
  getFileTokenResult?: {
    fileToken?: {
      accessid?: string(name='Accessid'),
      dir?: string(name='Dir'),
      expire?: string(name='Expire'),
      host?: string(name='Host'),
      policy?: string(name='Policy'),
      signature?: string(name='Signature'),
    }(name='FileToken'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetFileTokenResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeFileTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeFileTokenResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetMcubeFileToken  GetMcubeFileTokenRequest
  * @return GetMcubeFileTokenResponse
 */
async function getMcubeFileToken(request: GetMcubeFileTokenRequest): GetMcubeFileTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMcubeFileToken', 'POST', '/', 'json', true, 'form', request);
}

model GetMcubeNebulaResourceRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  id?: string(name='Id', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model GetMcubeNebulaResourceResponseBody = {
  getNebulaResourceResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaResourceInfo?: {
      appCode?: string(name='AppCode'),
      autoInstall?: int32(name='AutoInstall'),
      clientVersionMax?: string(name='ClientVersionMax'),
      clientVersionMin?: string(name='ClientVersionMin'),
      creator?: string(name='Creator'),
      downloadUrl?: string(name='DownloadUrl'),
      extendInfo?: string(name='ExtendInfo'),
      extraData?: string(name='ExtraData'),
      fallbackBaseUrl?: string(name='FallbackBaseUrl'),
      fileSize?: string(name='FileSize'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      h5Id?: string(name='H5Id'),
      h5Name?: string(name='H5Name'),
      h5Version?: string(name='H5Version'),
      id?: long(name='Id'),
      installType?: int32(name='InstallType'),
      mainUrl?: string(name='MainUrl'),
      memo?: string(name='Memo'),
      metaId?: long(name='MetaId'),
      modifier?: string(name='Modifier'),
      packageType?: int32(name='PackageType'),
      platform?: string(name='Platform'),
      publishPeriod?: int32(name='PublishPeriod'),
      resourceType?: string(name='ResourceType'),
      status?: int32(name='Status'),
      vhost?: string(name='Vhost'),
    }(name='NebulaResourceInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetNebulaResourceResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeNebulaResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeNebulaResourceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetMcubeNebulaResource  GetMcubeNebulaResourceRequest
  * @return GetMcubeNebulaResourceResponse
 */
async function getMcubeNebulaResource(request: GetMcubeNebulaResourceRequest): GetMcubeNebulaResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMcubeNebulaResource', 'POST', '/', 'json', true, 'form', request);
}

model GetMcubeNebulaTaskDetailRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  taskId?: long(name='TaskId', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model GetMcubeNebulaTaskDetailResponseBody = {
  getMcubeNebulaTaskDetailResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaTaskDetail?: {
      appCode?: string(name='AppCode'),
      appId?: string(name='AppId'),
      atomic?: int32(name='Atomic'),
      baseInfoId?: long(name='BaseInfoId'),
      bizType?: string(name='BizType'),
      creator?: string(name='Creator'),
      cronexpress?: int32(name='Cronexpress'),
      downloadUrl?: string(name='DownloadUrl'),
      extraData?: string(name='ExtraData'),
      fileSize?: string(name='FileSize'),
      fullRepair?: int32(name='FullRepair'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      gmtModifiedStr?: string(name='GmtModifiedStr'),
      greyConfigInfo?: string(name='GreyConfigInfo'),
      greyEndtime?: string(name='GreyEndtime'),
      greyEndtimeData?: string(name='GreyEndtimeData'),
      greyEndtimeStr?: string(name='GreyEndtimeStr'),
      greyNum?: int32(name='GreyNum'),
      greyUrl?: string(name='GreyUrl'),
      id?: long(name='Id'),
      issueDesc?: string(name='IssueDesc'),
      memo?: string(name='Memo'),
      modifier?: string(name='Modifier'),
      ossPath?: string(name='OssPath'),
      packageId?: long(name='PackageId'),
      percent?: int32(name='Percent'),
      platform?: string(name='Platform'),
      productId?: string(name='ProductId'),
      productVersion?: string(name='ProductVersion'),
      publishMode?: int32(name='PublishMode'),
      publishPeriod?: int32(name='PublishPeriod'),
      publishType?: int32(name='PublishType'),
      quickRollback?: int32(name='QuickRollback'),
      releaseVersion?: string(name='ReleaseVersion'),
      ruleJsonList?: [ 
        {
          operation?: string(name='Operation'),
          ruleElement?: string(name='RuleElement'),
          ruleType?: string(name='RuleType'),
          value?: string(name='Value'),
        }
      ](name='RuleJsonList'),
      sourceId?: string(name='SourceId'),
      sourceName?: string(name='SourceName'),
      sourceType?: string(name='SourceType'),
      status?: int32(name='Status'),
      syncResult?: string(name='SyncResult'),
      syncType?: int32(name='SyncType'),
      taskName?: string(name='TaskName'),
      taskStatus?: int32(name='TaskStatus'),
      taskType?: int32(name='TaskType'),
      taskVersion?: long(name='TaskVersion'),
      upgradeNoticeNum?: long(name='UpgradeNoticeNum'),
      upgradeProgress?: string(name='UpgradeProgress'),
      whitelistIds?: string(name='WhitelistIds'),
      workspaceId?: string(name='WorkspaceId'),
    }(name='NebulaTaskDetail'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetMcubeNebulaTaskDetailResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeNebulaTaskDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeNebulaTaskDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetMcubeNebulaTaskDetail  GetMcubeNebulaTaskDetailRequest
  * @return GetMcubeNebulaTaskDetailResponse
 */
async function getMcubeNebulaTaskDetail(request: GetMcubeNebulaTaskDetailRequest): GetMcubeNebulaTaskDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMcubeNebulaTaskDetail', 'POST', '/', 'json', true, 'form', request);
}

model GetMcubeUpgradePackageInfoRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  packageId?: long(name='PackageId', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model GetMcubeUpgradePackageInfoResponseBody = {
  getPackageResult?: {
    errorCode?: string(name='ErrorCode'),
    packageInfo?: {
      mobileTestFlightConfigDO?: {
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        installAmount?: int32(name='InstallAmount'),
        invalidTime?: string(name='InvalidTime'),
        upgradeId?: long(name='UpgradeId'),
      }(name='MobileTestFlightConfigDO'),
      upgradeBaseInfoDO?: {
        allowCreateTask?: boolean(name='AllowCreateTask'),
        appCode?: string(name='AppCode'),
        appstoreUrl?: string(name='AppstoreUrl'),
        backLog?: string(name='BackLog'),
        changeLog?: string(name='ChangeLog'),
        clientFileSize?: int32(name='ClientFileSize'),
        clientName?: string(name='ClientName'),
        cpId?: string(name='CpId'),
        creator?: string(name='Creator'),
        downloadUrl?: string(name='DownloadUrl'),
        globalVariables?: string(name='GlobalVariables'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateStr?: string(name='GmtCreateStr'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedStr?: string(name='GmtModifiedStr'),
        id?: long(name='Id'),
        innerVersion?: string(name='InnerVersion'),
        iosSymbol?: string(name='IosSymbol'),
        isEnterprise?: int32(name='IsEnterprise'),
        isRc?: int32(name='IsRc'),
        isRelease?: int32(name='IsRelease'),
        maxVersion?: string(name='MaxVersion'),
        md5?: string(name='Md5'),
        modifier?: string(name='Modifier'),
        needCheck?: int32(name='NeedCheck'),
        ossPath?: string(name='OssPath'),
        packageType?: string(name='PackageType'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productName?: string(name='ProductName'),
        productVersion?: string(name='ProductVersion'),
        publishPeriod?: int32(name='PublishPeriod'),
        qrcodeUrl?: string(name='QrcodeUrl'),
        releaseType?: string(name='ReleaseType'),
        releaseWindow?: string(name='ReleaseWindow'),
        scmDownloadUrl?: string(name='ScmDownloadUrl'),
        serverVersion?: int32(name='ServerVersion'),
        verificationCode?: string(name='VerificationCode'),
        verifyResult?: int32(name='VerifyResult'),
        versionCode?: string(name='VersionCode'),
      }(name='UpgradeBaseInfoDO'),
    }(name='PackageInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='GetPackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeUpgradePackageInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeUpgradePackageInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetMcubeUpgradePackageInfo  GetMcubeUpgradePackageInfoRequest
  * @return GetMcubeUpgradePackageInfoResponse
 */
async function getMcubeUpgradePackageInfo(request: GetMcubeUpgradePackageInfoRequest): GetMcubeUpgradePackageInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMcubeUpgradePackageInfo', 'POST', '/', 'json', true, 'form', request);
}

model GetMcubeUpgradeTaskInfoRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  taskId?: long(name='TaskId', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model GetMcubeUpgradeTaskInfoResponseBody = {
  getTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    taskInfo?: {
      appCode?: string(name='AppCode'),
      appId?: string(name='AppId'),
      appstoreUrl?: string(name='AppstoreUrl'),
      creater?: string(name='Creater'),
      creator?: string(name='Creator'),
      downloadUrl?: string(name='DownloadUrl'),
      greyConfigInfo?: string(name='GreyConfigInfo'),
      greyEndtimeData?: string(name='GreyEndtimeData'),
      greyNum?: int32(name='GreyNum'),
      historyForce?: int32(name='HistoryForce'),
      id?: long(name='Id'),
      isEnterprise?: int32(name='IsEnterprise'),
      isOfficial?: int32(name='IsOfficial'),
      isRc?: int32(name='IsRc'),
      isRelease?: int32(name='IsRelease'),
      memo?: string(name='Memo'),
      modifier?: string(name='Modifier'),
      netType?: string(name='NetType'),
      osVersion?: string(name='OsVersion'),
      packageInfoId?: long(name='PackageInfoId'),
      packageType?: string(name='PackageType'),
      platform?: string(name='Platform'),
      productId?: string(name='ProductId'),
      publishMode?: int32(name='PublishMode'),
      publishType?: int32(name='PublishType'),
      pushContent?: string(name='PushContent'),
      qrcodeUrl?: string(name='QrcodeUrl'),
      ruleJsonList?: [ 
        {
          operation?: string(name='Operation'),
          ruleElement?: string(name='RuleElement'),
          ruleType?: string(name='RuleType'),
          value?: string(name='Value'),
        }
      ](name='RuleJsonList'),
      silentType?: int32(name='SilentType'),
      taskStatus?: int32(name='TaskStatus'),
      upgradeContent?: string(name='UpgradeContent'),
      upgradeType?: int32(name='UpgradeType'),
      upgradeValidTime?: int32(name='UpgradeValidTime'),
      whitelist?: [ 
        {
          appCode?: string(name='AppCode'),
          id?: long(name='Id'),
          idType?: string(name='IdType'),
          platform?: string(name='Platform'),
          status?: int32(name='Status'),
          userType?: string(name='UserType'),
          whiteListCount?: long(name='WhiteListCount'),
          whiteListName?: string(name='WhiteListName'),
          whitelistType?: string(name='WhitelistType'),
        }
      ](name='Whitelist'),
      whitelistIds?: string(name='WhitelistIds'),
      workspaceId?: string(name='WorkspaceId'),
    }(name='TaskInfo'),
  }(name='GetTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMcubeUpgradeTaskInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMcubeUpgradeTaskInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetMcubeUpgradeTaskInfo  GetMcubeUpgradeTaskInfoRequest
  * @return GetMcubeUpgradeTaskInfoResponse
 */
async function getMcubeUpgradeTaskInfo(request: GetMcubeUpgradeTaskInfoRequest): GetMcubeUpgradeTaskInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMcubeUpgradeTaskInfo', 'POST', '/', 'json', true, 'form', request);
}

model GetMdsMiniConfigRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  h5Id: string(name='H5Id', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model GetMdsMiniConfigResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: {
        apiConfigList?: [ 
          {
            appCode?: string(name='AppCode'),
            configStatus?: long(name='ConfigStatus'),
            configType?: string(name='ConfigType'),
            configValue?: string(name='ConfigValue'),
            description?: string(name='Description'),
            gmtCreate?: string(name='GmtCreate'),
            gmtModified?: string(name='GmtModified'),
            h5Id?: string(name='H5Id'),
            h5Name?: string(name='H5Name'),
            id?: long(name='Id'),
          }
        ](name='ApiConfigList'),
        appCode?: string(name='AppCode'),
        enableServerDomainCount?: string(name='EnableServerDomainCount'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
        privilegeSwitch?: {
          appCode?: string(name='AppCode'),
          configStatus?: long(name='ConfigStatus'),
          configType?: string(name='ConfigType'),
          configValue?: string(name='ConfigValue'),
          description?: string(name='Description'),
          gmtCreate?: string(name='GmtCreate'),
          gmtModified?: string(name='GmtModified'),
          h5Id?: string(name='H5Id'),
          h5Name?: string(name='H5Name'),
          id?: long(name='Id'),
        }(name='PrivilegeSwitch'),
        serverDomainConfigList?: [ 
          {
            appCode?: string(name='AppCode'),
            configStatus?: long(name='ConfigStatus'),
            configType?: string(name='ConfigType'),
            configValue?: string(name='ConfigValue'),
            description?: string(name='Description'),
            gmtCreate?: string(name='GmtCreate'),
            gmtModified?: string(name='GmtModified'),
            h5Id?: string(name='H5Id'),
            h5Name?: string(name='H5Name'),
            id?: long(name='Id'),
          }
        ](name='ServerDomainConfigList'),
        webviewDomainConfigList?: [ 
          {
            appCode?: string(name='AppCode'),
            configStatus?: long(name='ConfigStatus'),
            configType?: string(name='ConfigType'),
            configValue?: string(name='ConfigValue'),
            description?: string(name='Description'),
            gmtCreate?: string(name='GmtCreate'),
            gmtModified?: string(name='GmtModified'),
            h5Id?: string(name='H5Id'),
            h5Name?: string(name='H5Name'),
            id?: long(name='Id'),
          }
        ](name='WebviewDomainConfigList'),
      }(name='Content'),
      requestId?: string(name='RequestId'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetMdsMiniConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMdsMiniConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetMdsMiniConfig  GetMdsMiniConfigRequest
  * @return GetMdsMiniConfigResponse
 */
async function getMdsMiniConfig(request: GetMdsMiniConfigRequest): GetMdsMiniConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMdsMiniConfig', 'POST', '/', 'json', true, 'form', request);
}

model GetUserAppDonwloadUrlInMsaRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  id: long(name='Id', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model GetUserAppDonwloadUrlInMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: {
      filename?: string(name='Filename'),
      url?: string(name='Url'),
    }(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetUserAppDonwloadUrlInMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserAppDonwloadUrlInMsaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetUserAppDonwloadUrlInMsa  GetUserAppDonwloadUrlInMsaRequest
  * @return GetUserAppDonwloadUrlInMsaResponse
 */
async function getUserAppDonwloadUrlInMsa(request: GetUserAppDonwloadUrlInMsaRequest): GetUserAppDonwloadUrlInMsaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserAppDonwloadUrlInMsa', 'POST', '/', 'json', true, 'form', request);
}

model GetUserAppEnhanceProcessInMsaRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  id: long(name='Id', description='This parameter is required.', minimum=-9999, maximum=99999999999999, position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model GetUserAppEnhanceProcessInMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: {
      afterMd5?: string(name='AfterMd5'),
      afterSize?: long(name='AfterSize'),
      appCode?: string(name='AppCode'),
      appPackage?: string(name='AppPackage'),
      assetsFileList?: [ string ](name='AssetsFileList'),
      beforeMd5?: string(name='BeforeMd5'),
      beforeSize?: long(name='BeforeSize'),
      classForest?: [ string ](name='ClassForest'),
      enhanceMapping?: [ 
        {
          info?: string(name='Info'),
          reason?: string(name='Reason'),
          type?: string(name='Type'),
        }
      ](name='EnhanceMapping'),
      enhanceRules?: [ string ](name='EnhanceRules'),
      enhancedAssetsFiles?: [ string ](name='EnhancedAssetsFiles'),
      enhancedClasses?: [ string ](name='EnhancedClasses'),
      enhancedSoFiles?: [ string ](name='EnhancedSoFiles'),
      id?: long(name='Id'),
      label?: string(name='Label'),
      progress?: long(name='Progress'),
      soFileList?: [ string ](name='SoFileList'),
      status?: long(name='Status'),
      taskType?: string(name='TaskType'),
      versionCode?: string(name='VersionCode'),
      versionName?: string(name='VersionName'),
    }(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetUserAppEnhanceProcessInMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserAppEnhanceProcessInMsaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetUserAppEnhanceProcessInMsa  GetUserAppEnhanceProcessInMsaRequest
  * @return GetUserAppEnhanceProcessInMsaResponse
 */
async function getUserAppEnhanceProcessInMsa(request: GetUserAppEnhanceProcessInMsaRequest): GetUserAppEnhanceProcessInMsaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserAppEnhanceProcessInMsa', 'POST', '/', 'json', true, 'form', request);
}

model GetUserAppUploadProcessInMsaRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  id: long(name='Id', description='This parameter is required.', minimum=-999, maximum=99999999999, position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model GetUserAppUploadProcessInMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: {
      apkInfo?: {
        afterMd5?: string(name='AfterMd5'),
        afterSize?: long(name='AfterSize'),
        appCode?: string(name='AppCode'),
        appPackage?: string(name='AppPackage'),
        assetsFileList?: [ string ](name='AssetsFileList'),
        beforeMd5?: string(name='BeforeMd5'),
        beforeSize?: long(name='BeforeSize'),
        classForest?: string(name='ClassForest'),
        enhanceMapping?: [ 
          {
            info?: string(name='Info'),
            reason?: string(name='Reason'),
            type?: string(name='Type'),
          }
        ](name='EnhanceMapping'),
        enhanceRules?: [ string ](name='EnhanceRules'),
        enhancedAssetsFiles?: [ string ](name='EnhancedAssetsFiles'),
        enhancedClasses?: [ string ](name='EnhancedClasses'),
        enhancedSoFiles?: [ string ](name='EnhancedSoFiles'),
        id?: long(name='Id'),
        label?: string(name='Label'),
        progress?: long(name='Progress'),
        soFileList?: [ string ](name='SoFileList'),
        status?: long(name='Status'),
        taskType?: string(name='TaskType'),
        versionCode?: string(name='VersionCode'),
        versionName?: string(name='VersionName'),
      }(name='ApkInfo'),
      enhanceTaskId?: long(name='EnhanceTaskId'),
      id?: long(name='Id'),
      progress?: long(name='Progress'),
      status?: long(name='Status'),
    }(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model GetUserAppUploadProcessInMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserAppUploadProcessInMsaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetUserAppUploadProcessInMsa  GetUserAppUploadProcessInMsaRequest
  * @return GetUserAppUploadProcessInMsaResponse
 */
async function getUserAppUploadProcessInMsa(request: GetUserAppUploadProcessInMsaRequest): GetUserAppUploadProcessInMsaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserAppUploadProcessInMsa', 'POST', '/', 'json', true, 'form', request);
}

model ListMappCenterAppsRequest {
  regionId?: string(name='RegionId', position='Host'),
}

model ListMappCenterAppsResponseBody = {
  listMappCenterAppResult?: {
    mappCenterAppList?: [ 
      {
        androidConfig?: {
          certRSA?: string(name='CertRSA'),
          packageName?: string(name='PackageName'),
        }(name='AndroidConfig'),
        appDesc?: string(name='AppDesc'),
        appIcon?: string(name='AppIcon'),
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        appSecret?: string(name='AppSecret'),
        creator?: string(name='Creator'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        iosConfig?: {
          bundleId?: string(name='BundleId'),
        }(name='IosConfig'),
        modifier?: string(name='Modifier'),
        monitorJson?: string(name='MonitorJson'),
        status?: long(name='Status'),
        tenantId?: string(name='TenantId'),
        type?: long(name='Type'),
      }
    ](name='MappCenterAppList'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMappCenterAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMappCenterAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMappCenterAppsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMappCenterApps  ListMappCenterAppsRequest
  * @return ListMappCenterAppsResponse
 */
async function listMappCenterApps(request: ListMappCenterAppsRequest): ListMappCenterAppsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMappCenterApps', 'POST', '/', 'json', false, 'json', request);
}

model ListMappCenterWorkspacesRequest {
  regionId?: string(name='RegionId', position='Host'),
}

model ListMappCenterWorkspacesResponseBody = {
  listMappCenterWorkspaceResult?: {
    mappCenterWorkspaceList?: [ 
      {
        compatibleId?: string(name='CompatibleId'),
        createTime?: string(name='CreateTime'),
        displayName?: string(name='DisplayName'),
        id?: string(name='Id'),
        region?: string(name='Region'),
        status?: string(name='Status'),
        tenantId?: string(name='TenantId'),
        type?: string(name='Type'),
        uid?: long(name='Uid'),
        updateTime?: string(name='UpdateTime'),
        workspaceId?: string(name='WorkspaceId'),
        zones?: string(name='Zones'),
      }
    ](name='MappCenterWorkspaceList'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    userId?: string(name='UserId'),
  }(name='ListMappCenterWorkspaceResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMappCenterWorkspacesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMappCenterWorkspacesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMappCenterWorkspaces  ListMappCenterWorkspacesRequest
  * @return ListMappCenterWorkspacesResponse
 */
async function listMappCenterWorkspaces(request: ListMappCenterWorkspacesRequest): ListMappCenterWorkspacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMappCenterWorkspaces', 'POST', '/', 'json', false, 'json', request);
}

model ListMcdpAimRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  emptyTag?: string(name='EmptyTag', position='Body'),
  keyword?: string(name='Keyword', position='Body'),
  name?: string(name='Name', position='Body'),
  pageNo?: long(name='PageNo', position='Body'),
  pageSize?: long(name='PageSize', position='Body'),
  sort?: string(name='Sort', position='Body'),
  sortField?: string(name='SortField', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  type?: string(name='Type', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ListMcdpAimResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcdpAimResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcdpAimResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcdpAim  ListMcdpAimRequest
  * @return ListMcdpAimResponse
 */
async function listMcdpAim(request: ListMcdpAimRequest): ListMcdpAimResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcdpAim', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeMiniAppsRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  keyword?: string(name='Keyword', position='Body'),
  pageNum?: int32(name='PageNum', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model ListMcubeMiniAppsResponseBody = {
  listMiniResult?: {
    currentPage?: int32(name='CurrentPage'),
    hasMore?: boolean(name='HasMore'),
    miniProgramList?: [ 
      {
        appCode?: string(name='AppCode'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
      }
    ](name='MiniProgramList'),
    pageSize?: int32(name='PageSize'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMiniResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeMiniAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeMiniAppsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeMiniApps  ListMcubeMiniAppsRequest
  * @return ListMcubeMiniAppsResponse
 */
async function listMcubeMiniApps(request: ListMcubeMiniAppsRequest): ListMcubeMiniAppsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeMiniApps', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeMiniPackagesRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  h5Id: string(name='H5Id', description='This parameter is required.', position='Body'),
  packageTypes: string(name='PackageTypes', description='This parameter is required.', position='Body'),
  pageNum?: int32(name='PageNum', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model ListMcubeMiniPackagesResponseBody = {
  listMiniPackageResult?: {
    currentPage?: int32(name='CurrentPage'),
    hasMore?: boolean(name='HasMore'),
    miniPackageList?: [ 
      {
        appCode?: string(name='AppCode'),
        autoInstall?: long(name='AutoInstall'),
        clientVersionMax?: string(name='ClientVersionMax'),
        clientVersionMin?: string(name='ClientVersionMin'),
        downloadUrl?: string(name='DownloadUrl'),
        extendInfo?: string(name='ExtendInfo'),
        extraData?: string(name='ExtraData'),
        fallbackBaseUrl?: string(name='FallbackBaseUrl'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
        h5Version?: string(name='H5Version'),
        id?: long(name='Id'),
        installType?: long(name='InstallType'),
        mainUrl?: string(name='MainUrl'),
        memo?: string(name='Memo'),
        packageType?: long(name='PackageType'),
        platform?: string(name='Platform'),
        publishPeriod?: long(name='PublishPeriod'),
        resourceType?: long(name='ResourceType'),
        status?: long(name='Status'),
      }
    ](name='MiniPackageList'),
    pageSize?: int32(name='PageSize'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMiniPackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeMiniPackagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeMiniPackagesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeMiniPackages  ListMcubeMiniPackagesRequest
  * @return ListMcubeMiniPackagesResponse
 */
async function listMcubeMiniPackages(request: ListMcubeMiniPackagesRequest): ListMcubeMiniPackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeMiniPackages', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeMiniTasksRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  id: string(name='Id', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model ListMcubeMiniTasksResponseBody = {
  listMiniTaskResult?: {
    miniTaskList?: [ 
      {
        appCode?: string(name='AppCode'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtime?: string(name='GreyEndtime'),
        greyEndtimeData?: string(name='GreyEndtimeData'),
        greyNum?: long(name='GreyNum'),
        id?: long(name='Id'),
        memo?: string(name='Memo'),
        packageId?: long(name='PackageId'),
        platform?: string(name='Platform'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: long(name='PublishMode'),
        publishType?: long(name='PublishType'),
        status?: string(name='Status'),
        taskStatus?: long(name='TaskStatus'),
        whitelistIds?: string(name='WhitelistIds'),
      }
    ](name='MiniTaskList'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMiniTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeMiniTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeMiniTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeMiniTasks  ListMcubeMiniTasksRequest
  * @return ListMcubeMiniTasksResponse
 */
async function listMcubeMiniTasks(request: ListMcubeMiniTasksRequest): ListMcubeMiniTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeMiniTasks', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeNebulaAppsRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  keyword?: string(name='Keyword', position='Body'),
  pageNum?: int32(name='PageNum', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ListMcubeNebulaAppsResponseBody = {
  listMcubeNebulaAppsResult?: {
    currentPage?: int32(name='CurrentPage'),
    errorCode?: string(name='ErrorCode'),
    hasMore?: boolean(name='HasMore'),
    nebulaAppInfos?: [ 
      {
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
      }
    ](name='NebulaAppInfos'),
    pageSize?: int32(name='PageSize'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMcubeNebulaAppsResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeNebulaAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeNebulaAppsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeNebulaApps  ListMcubeNebulaAppsRequest
  * @return ListMcubeNebulaAppsResponse
 */
async function listMcubeNebulaApps(request: ListMcubeNebulaAppsRequest): ListMcubeNebulaAppsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeNebulaApps', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeNebulaResourcesRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  h5Id?: string(name='H5Id', position='Body'),
  pageNum?: int32(name='PageNum', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ListMcubeNebulaResourcesResponseBody = {
  listMcubeNebulaResourceResult?: {
    currentPage?: int32(name='CurrentPage'),
    errorCode?: string(name='ErrorCode'),
    hasMore?: boolean(name='HasMore'),
    nebulaResourceInfo?: [ 
      {
        appCode?: string(name='AppCode'),
        autoInstall?: int32(name='AutoInstall'),
        clientVersionMax?: string(name='ClientVersionMax'),
        clientVersionMin?: string(name='ClientVersionMin'),
        creator?: string(name='Creator'),
        debugUrl?: string(name='DebugUrl'),
        downloadUrl?: string(name='DownloadUrl'),
        extendInfo?: string(name='ExtendInfo'),
        extraData?: string(name='ExtraData'),
        fallbackBaseUrl?: string(name='FallbackBaseUrl'),
        fileSize?: string(name='FileSize'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        h5Id?: string(name='H5Id'),
        h5Name?: string(name='H5Name'),
        h5Version?: string(name='H5Version'),
        id?: long(name='Id'),
        installType?: int32(name='InstallType'),
        lazyLoad?: int32(name='LazyLoad'),
        mainUrl?: string(name='MainUrl'),
        md5?: string(name='Md5'),
        memo?: string(name='Memo'),
        metaId?: long(name='MetaId'),
        modifier?: string(name='Modifier'),
        packageType?: int32(name='PackageType'),
        platform?: string(name='Platform'),
        publishPeriod?: int32(name='PublishPeriod'),
        releaseVersion?: string(name='ReleaseVersion'),
        resourceType?: string(name='ResourceType'),
        status?: int32(name='Status'),
        vhost?: string(name='Vhost'),
      }
    ](name='NebulaResourceInfo'),
    pageSize?: int32(name='PageSize'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListMcubeNebulaResourceResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeNebulaResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeNebulaResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeNebulaResources  ListMcubeNebulaResourcesRequest
  * @return ListMcubeNebulaResourcesResponse
 */
async function listMcubeNebulaResources(request: ListMcubeNebulaResourcesRequest): ListMcubeNebulaResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeNebulaResources', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeNebulaTasksRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  id?: long(name='Id', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ListMcubeNebulaTasksResponseBody = {
  listMcubeNebulaTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    nebulaTaskInfo?: [ 
      {
        appCode?: string(name='AppCode'),
        bizType?: string(name='BizType'),
        creator?: string(name='Creator'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedStr?: string(name='GmtModifiedStr'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtime?: string(name='GreyEndtime'),
        greyEndtimeData?: string(name='GreyEndtimeData'),
        greyEndtimeStr?: string(name='GreyEndtimeStr'),
        greyNum?: int32(name='GreyNum'),
        greyUrl?: string(name='GreyUrl'),
        id?: long(name='Id'),
        memo?: string(name='Memo'),
        modifier?: string(name='Modifier'),
        packageId?: long(name='PackageId'),
        percent?: int32(name='Percent'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: int32(name='PublishMode'),
        publishType?: int32(name='PublishType'),
        releaseVersion?: string(name='ReleaseVersion'),
        status?: int32(name='Status'),
        syncResult?: string(name='SyncResult'),
        taskName?: string(name='TaskName'),
        taskStatus?: int32(name='TaskStatus'),
        taskType?: int32(name='TaskType'),
        taskVersion?: long(name='TaskVersion'),
        upgradeNoticeNum?: long(name='UpgradeNoticeNum'),
        upgradeProgress?: string(name='UpgradeProgress'),
        whitelistIds?: string(name='WhitelistIds'),
      }
    ](name='NebulaTaskInfo'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='ListMcubeNebulaTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeNebulaTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeNebulaTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeNebulaTasks  ListMcubeNebulaTasksRequest
  * @return ListMcubeNebulaTasksResponse
 */
async function listMcubeNebulaTasks(request: ListMcubeNebulaTasksRequest): ListMcubeNebulaTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeNebulaTasks', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeUpgradePackagesRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  pageNum?: int32(name='PageNum', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ListMcubeUpgradePackagesResponseBody = {
  listPackagesResult?: {
    currentPage?: int32(name='CurrentPage'),
    errorCode?: string(name='ErrorCode'),
    hasMore?: boolean(name='HasMore'),
    packages?: [ 
      {
        allowCreateTask?: boolean(name='AllowCreateTask'),
        appCode?: string(name='AppCode'),
        appstoreUrl?: string(name='AppstoreUrl'),
        backLog?: string(name='BackLog'),
        changeLog?: string(name='ChangeLog'),
        clientFileSize?: int32(name='ClientFileSize'),
        clientName?: string(name='ClientName'),
        cpId?: string(name='CpId'),
        creator?: string(name='Creator'),
        downloadUrl?: string(name='DownloadUrl'),
        globalVariables?: string(name='GlobalVariables'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateStr?: string(name='GmtCreateStr'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedStr?: string(name='GmtModifiedStr'),
        id?: long(name='Id'),
        innerVersion?: string(name='InnerVersion'),
        iosSymbol?: string(name='IosSymbol'),
        isEnterprise?: int32(name='IsEnterprise'),
        isRc?: int32(name='IsRc'),
        isRelease?: int32(name='IsRelease'),
        maxVersion?: string(name='MaxVersion'),
        md5?: string(name='Md5'),
        modifier?: string(name='Modifier'),
        needCheck?: int32(name='NeedCheck'),
        ossPath?: string(name='OssPath'),
        packageType?: string(name='PackageType'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productName?: string(name='ProductName'),
        productVersion?: string(name='ProductVersion'),
        publishPeriod?: int32(name='PublishPeriod'),
        qrcodeUrl?: string(name='QrcodeUrl'),
        releaseType?: string(name='ReleaseType'),
        releaseWindow?: string(name='ReleaseWindow'),
        scmDownloadUrl?: string(name='ScmDownloadUrl'),
        serverVersion?: int32(name='ServerVersion'),
        verificationCode?: string(name='VerificationCode'),
        verifyResult?: int32(name='VerifyResult'),
        versionCode?: string(name='VersionCode'),
      }
    ](name='Packages'),
    pageSize?: int32(name='PageSize'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
  }(name='ListPackagesResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeUpgradePackagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeUpgradePackagesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeUpgradePackages  ListMcubeUpgradePackagesRequest
  * @return ListMcubeUpgradePackagesResponse
 */
async function listMcubeUpgradePackages(request: ListMcubeUpgradePackagesRequest): ListMcubeUpgradePackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeUpgradePackages', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeUpgradeTasksRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  packageId?: string(name='PackageId', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ListMcubeUpgradeTasksResponseBody = {
  listTaskResult?: {
    errorCode?: string(name='ErrorCode'),
    requestId?: string(name='RequestId'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    taskInfo?: [ 
      {
        appCode?: string(name='AppCode'),
        creator?: string(name='Creator'),
        devicePercent?: int32(name='DevicePercent'),
        executionOrder?: int32(name='ExecutionOrder'),
        gmtCreate?: string(name='GmtCreate'),
        gmtCreateStr?: string(name='GmtCreateStr'),
        gmtModified?: string(name='GmtModified'),
        gmtModifiedStr?: string(name='GmtModifiedStr'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtime?: string(name='GreyEndtime'),
        greyNotice?: int32(name='GreyNotice'),
        greyNum?: int32(name='GreyNum'),
        greyPausePoint?: int32(name='GreyPausePoint'),
        greyPauseType?: int32(name='GreyPauseType'),
        greyUv?: int32(name='GreyUv'),
        historyForce?: int32(name='HistoryForce'),
        huobanNoticeId?: string(name='HuobanNoticeId'),
        huobanUrl?: string(name='HuobanUrl'),
        id?: long(name='Id'),
        innerVersion?: string(name='InnerVersion'),
        isEnterprise?: int32(name='IsEnterprise'),
        isOfficial?: int32(name='IsOfficial'),
        isPush?: int32(name='IsPush'),
        isRelease?: int32(name='IsRelease'),
        maxVersion?: string(name='MaxVersion'),
        memo?: string(name='Memo'),
        modifier?: string(name='Modifier'),
        packageInfoId?: long(name='PackageInfoId'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: int32(name='PublishMode'),
        publishType?: int32(name='PublishType'),
        pushContent?: string(name='PushContent'),
        realGreyEndtime?: string(name='RealGreyEndtime'),
        realGreyEndtimeStr?: string(name='RealGreyEndtimeStr'),
        realGreyEndtype?: int32(name='RealGreyEndtype'),
        realGreyNum?: int32(name='RealGreyNum'),
        realGreyUv?: int32(name='RealGreyUv'),
        silentType?: int32(name='SilentType'),
        syncResult?: string(name='SyncResult'),
        taskStatus?: int32(name='TaskStatus'),
        upgradeContent?: string(name='UpgradeContent'),
        upgradeType?: int32(name='UpgradeType'),
        upgradeValidTime?: int32(name='UpgradeValidTime'),
        whitelistIds?: string(name='WhitelistIds'),
      }
    ](name='TaskInfo'),
  }(name='ListTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeUpgradeTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeUpgradeTasksResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeUpgradeTasks  ListMcubeUpgradeTasksRequest
  * @return ListMcubeUpgradeTasksResponse
 */
async function listMcubeUpgradeTasks(request: ListMcubeUpgradeTasksRequest): ListMcubeUpgradeTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeUpgradeTasks', 'POST', '/', 'json', true, 'form', request);
}

model ListMcubeWhitelistsRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  pageNum?: int32(name='PageNum', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  whitelistName?: string(name='WhitelistName', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model ListMcubeWhitelistsResponseBody = {
  listWhitelistResult?: {
    currentPage?: int32(name='CurrentPage'),
    hasMore?: boolean(name='HasMore'),
    pageSize?: int32(name='PageSize'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
    totalCount?: long(name='TotalCount'),
    whitelists?: [ 
      {
        appCode?: string(name='AppCode'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        whiteListCount?: long(name='WhiteListCount'),
        whiteListName?: string(name='WhiteListName'),
        whitelistType?: string(name='WhitelistType'),
      }
    ](name='Whitelists'),
  }(name='ListWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMcubeWhitelistsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMcubeWhitelistsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMcubeWhitelists  ListMcubeWhitelistsRequest
  * @return ListMcubeWhitelistsResponse
 */
async function listMcubeWhitelists(request: ListMcubeWhitelistsRequest): ListMcubeWhitelistsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMcubeWhitelists', 'POST', '/', 'json', true, 'form', request);
}

model ListMgsApiRequest {
  regionId?: string(name='RegionId', position='Host'),
  apiStatus?: string(name='ApiStatus', position='Body'),
  apiType?: string(name='ApiType', position='Body'),
  appId?: string(name='AppId', position='Body'),
  format?: string(name='Format', position='Body'),
  host?: string(name='Host', position='Body'),
  needEncrypt?: string(name='NeedEncrypt', position='Body'),
  needEtag?: string(name='NeedEtag', position='Body'),
  needSign?: string(name='NeedSign', position='Body'),
  operationType?: string(name='OperationType', position='Body'),
  optFuzzy?: string(name='OptFuzzy', position='Body'),
  pageIndex?: long(name='PageIndex', position='Body'),
  pageSize?: long(name='PageSize', position='Body'),
  sysId?: long(name='SysId', position='Body'),
  sysName?: string(name='SysName', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model ListMgsApiResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    errorMessage?: string(name='ErrorMessage'),
    success?: boolean(name='Success'),
    value?: [ 
      {
        apiInvoker?: {
          httpInvoker?: {
            charset?: string(name='Charset'),
            contentType?: string(name='ContentType'),
            host?: string(name='Host'),
            method?: string(name='Method'),
            path?: string(name='Path'),
          }(name='HttpInvoker'),
          rpcInvoker?: string(name='RpcInvoker'),
        }(name='ApiInvoker'),
        apiName?: string(name='ApiName'),
        apiStatus?: string(name='ApiStatus'),
        apiType?: string(name='ApiType'),
        appId?: string(name='AppId'),
        authRuleName?: string(name='AuthRuleName'),
        cacheRule?: {
          cacheKey?: string(name='CacheKey'),
          needCache?: boolean(name='NeedCache'),
          ttl?: long(name='Ttl'),
        }(name='CacheRule'),
        charset?: string(name='Charset'),
        circuitBreakerRule?: {
          appId?: string(name='AppId'),
          defaultResponse?: string(name='DefaultResponse'),
          errorThreshold?: long(name='ErrorThreshold'),
          id?: long(name='Id'),
          model?: string(name='Model'),
          openTimeoutSeconds?: long(name='OpenTimeoutSeconds'),
          slowRatioThreshold?: double(name='SlowRatioThreshold'),
          switchStatus?: string(name='SwitchStatus'),
          windowsInSeconds?: long(name='WindowsInSeconds'),
          workspaceId?: string(name='WorkspaceId'),
        }(name='CircuitBreakerRule'),
        contentType?: string(name='ContentType'),
        description?: string(name='Description'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        headerRule?: [ 
          {
            headerKey?: string(name='HeaderKey'),
            location?: string(name='Location'),
            type?: string(name='Type'),
            value?: string(name='Value'),
          }
        ](name='HeaderRule'),
        headerRules?: [ 
          {
            headerKey?: string(name='HeaderKey'),
            location?: string(name='Location'),
            type?: string(name='Type'),
            value?: string(name='Value'),
          }
        ](name='HeaderRules'),
        host?: string(name='Host'),
        id?: long(name='Id'),
        interfaceType?: string(name='InterfaceType'),
        limitRule?: {
          defaultResponse?: string(name='DefaultResponse'),
          i18nResponse?: string(name='I18nResponse'),
          interval?: long(name='Interval'),
          limit?: long(name='Limit'),
          mode?: string(name='Mode'),
        }(name='LimitRule'),
        method?: string(name='Method'),
        methodName?: string(name='MethodName'),
        migrateRule?: {
          flowPercent?: long(name='FlowPercent'),
          needMigrate?: boolean(name='NeedMigrate'),
          needSwitchCompletely?: boolean(name='NeedSwitchCompletely'),
          sysId?: long(name='SysId'),
          sysName?: string(name='SysName'),
          upstreamType?: string(name='UpstreamType'),
        }(name='MigrateRule'),
        mockRule?: {
          mockData?: string(name='MockData'),
          needMock?: boolean(name='NeedMock'),
          percentage?: long(name='Percentage'),
          type?: string(name='Type'),
        }(name='MockRule'),
        needETag?: string(name='NeedETag'),
        needEncrypt?: string(name='NeedEncrypt'),
        needJsonp?: string(name='NeedJsonp'),
        needSign?: string(name='NeedSign'),
        operationType?: string(name='OperationType'),
        paramGetMethod?: string(name='ParamGetMethod'),
        path?: string(name='Path'),
        requestBodyModel?: string(name='RequestBodyModel'),
        requestParams?: [ 
          {
            apiId?: string(name='ApiId'),
            appId?: string(name='AppId'),
            defaultValue?: string(name='DefaultValue'),
            description?: string(name='Description'),
            id?: long(name='Id'),
            location?: string(name='Location'),
            name?: string(name='Name'),
            refType?: string(name='RefType'),
            type?: string(name='Type'),
            workspaceId?: string(name='WorkspaceId'),
          }
        ](name='RequestParams'),
        responseBodyModel?: string(name='ResponseBodyModel'),
        sysId?: long(name='SysId'),
        sysName?: string(name='SysName'),
        timeout?: string(name='Timeout'),
        workspaceId?: string(name='WorkspaceId'),
      }
    ](name='Value'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model ListMgsApiResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMgsApiResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListMgsApi  ListMgsApiRequest
  * @return ListMgsApiResponse
 */
async function listMgsApi(request: ListMgsApiRequest): ListMgsApiResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMgsApi', 'POST', '/', 'json', true, 'form', request);
}

model MTRSOCRServiceRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', example='ONEX8C7E7FA161089', position='Body'),
  imageRaw: string(name='ImageRaw', description='This parameter is required.', example='xydasf==ac', position='Body'),
  mask?: boolean(name='Mask', position='Body'),
  tenantId?: string(name='TenantId', example='tabcaa', position='Body'),
  type: string(name='Type', description='This parameter is required.', example='ID_CARD_OCR', position='Body'),
  workspaceId?: string(name='WorkspaceId', example='default', position='Body'),
}

model MTRSOCRServiceResponseBody = {
  code?: string(name='Code'),
  msg?: string(name='Msg'),
  requestId?: string(name='RequestId', example='D9B3C4E7-BEC7-1E2C-86A3-EA985B4FFD73'),
  result?: string(name='Result', example='{"aa":"ss"}'),
  status?: boolean(name='Status', example='true/false'),
  traceId?: string(name='TraceId', example='777799aa'),
}

model MTRSOCRServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MTRSOCRServiceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of MTRSOCRService  MTRSOCRServiceRequest
  * @return MTRSOCRServiceResponse
 */
async function mTRSOCRService(request: MTRSOCRServiceRequest): MTRSOCRServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MTRSOCRService', 'POST', '/', 'json', true, 'form', request);
}

model PushBindRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  deliveryToken: string(name='DeliveryToken', description='This parameter is required.', position='Body'),
  osType: int32(name='OsType', description='This parameter is required.', minimum=0, maximum=100, position='Body'),
  phoneNumber?: string(name='PhoneNumber', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  userId: string(name='UserId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model PushBindResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushBindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushBindResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PushBind  PushBindRequest
  * @return PushBindResponse
 */
async function pushBind(request: PushBindRequest): PushBindResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PushBind', 'POST', '/', 'json', true, 'form', request);
}

model PushBroadcastRequest {
  regionId?: string(name='RegionId', position='Host'),
  androidChannel?: int32(name='AndroidChannel', minimum=0, maximum=10, position='Body'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  bindPeriod?: int32(name='BindPeriod', position='Body'),
  channelId?: string(name='ChannelId', position='Body'),
  classification?: string(name='Classification', position='Body'),
  deliveryType: long(name='DeliveryType', description='This parameter is required.', minimum=0, maximum=10, position='Body'),
  expiredSeconds: long(name='ExpiredSeconds', description='This parameter is required.', minimum=0, maximum=259200, position='Body'),
  extendedParams?: string(name='ExtendedParams', position='Body'),
  miChannelId?: string(name='MiChannelId', position='Body'),
  msgkey: string(name='Msgkey', description='This parameter is required.', position='Body'),
  notifyType?: string(name='NotifyType', position='Body'),
  pushAction?: long(name='PushAction', minimum=0, maximum=10, position='Body'),
  pushStatus?: long(name='PushStatus', minimum=0, maximum=10, position='Body'),
  silent?: long(name='Silent', minimum=-1, maximum=10, position='Body'),
  strategyContent?: string(name='StrategyContent', position='Body'),
  strategyType?: int32(name='StrategyType', position='Body'),
  taskName?: string(name='TaskName', position='Body'),
  templateKeyValue?: string(name='TemplateKeyValue', position='Body'),
  templateName: string(name='TemplateName', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory', shrink='json', position='Body'),
  transparentMessagePayload?: any(name='TransparentMessagePayload', position='Body'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency', position='Body'),
  unBindPeriod?: long(name='UnBindPeriod', minimum=0, maximum=10, position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model PushBroadcastResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushBroadcastResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushBroadcastResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PushBroadcast  PushBroadcastRequest
  * @return PushBroadcastResponse
 */
async function pushBroadcast(request: PushBroadcastRequest): PushBroadcastResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PushBroadcast', 'POST', '/', 'json', true, 'form', request);
}

model PushMultipleRequest {
  regionId?: string(name='RegionId', position='Host'),
  activityContentState?: any(name='ActivityContentState', position='Body'),
  activityEvent?: string(name='ActivityEvent', position='Body'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  channelId?: string(name='ChannelId', position='Body'),
  classification?: string(name='Classification', position='Body'),
  deliveryType: long(name='DeliveryType', description='This parameter is required.', minimum=0, maximum=10, position='Body'),
  dismissalDate?: long(name='DismissalDate', position='Body'),
  expiredSeconds: long(name='ExpiredSeconds', description='This parameter is required.', minimum=0, maximum=259200, position='Body'),
  extendedParams?: string(name='ExtendedParams', position='Body'),
  miChannelId?: string(name='MiChannelId', position='Body'),
  notifyType?: string(name='NotifyType', position='Body'),
  pushAction?: long(name='PushAction', minimum=0, maximum=10, position='Body'),
  silent?: long(name='Silent', minimum=-1, maximum=10, position='Body'),
  strategyContent?: string(name='StrategyContent', position='Body'),
  strategyType?: int32(name='StrategyType', position='Body'),
  targetMsg: [ 
    {
      extendedParams?: string(name='ExtendedParams'),
      msgKey: string(name='MsgKey', description='This parameter is required.'),
      target: string(name='Target', description='This parameter is required.'),
      templateKeyValue?: string(name='TemplateKeyValue'),
    }
  ](name='TargetMsg', description='This parameter is required.', position='Body'),
  taskName?: string(name='TaskName', position='Body'),
  templateName: string(name='TemplateName', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory', shrink='json', position='Body'),
  transparentMessagePayload?: any(name='TransparentMessagePayload', position='Body'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model PushMultipleResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushMultipleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushMultipleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PushMultiple  PushMultipleRequest
  * @return PushMultipleResponse
 */
async function pushMultiple(request: PushMultipleRequest): PushMultipleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PushMultiple', 'POST', '/', 'json', true, 'form', request);
}

model PushReportRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  appVersion?: string(name='AppVersion', position='Body'),
  channel?: string(name='Channel', position='Body'),
  connectType?: string(name='ConnectType', position='Body'),
  deliveryToken: string(name='DeliveryToken', description='This parameter is required.', position='Body'),
  imei?: string(name='Imei', position='Body'),
  imsi?: string(name='Imsi', position='Body'),
  model?: string(name='Model', position='Body'),
  osType: int32(name='OsType', description='This parameter is required.', minimum=0, maximum=100, position='Body'),
  pushVersion?: string(name='PushVersion', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  thirdChannel?: int32(name='ThirdChannel', minimum=0, maximum=100, position='Body'),
  thirdChannelDeviceToken?: string(name='ThirdChannelDeviceToken', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model PushReportResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushReportResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PushReport  PushReportRequest
  * @return PushReportResponse
 */
async function pushReport(request: PushReportRequest): PushReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PushReport', 'POST', '/', 'json', true, 'form', request);
}

model PushSimpleRequest {
  regionId?: string(name='RegionId', position='Host'),
  activityContentState?: any(name='ActivityContentState', position='Body'),
  activityEvent?: string(name='ActivityEvent', position='Body'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  channelId?: string(name='ChannelId', position='Body'),
  classification?: string(name='Classification', position='Body'),
  content: string(name='Content', description='This parameter is required.', position='Body'),
  deliveryType: long(name='DeliveryType', description='This parameter is required.', minimum=0, maximum=10, position='Body'),
  dismissalDate?: long(name='DismissalDate', position='Body'),
  expiredSeconds: long(name='ExpiredSeconds', description='This parameter is required.', minimum=0, maximum=259200, position='Body'),
  extendedParams?: string(name='ExtendedParams', position='Body'),
  iconUrls?: string(name='IconUrls', position='Body'),
  imageUrls?: string(name='ImageUrls', position='Body'),
  miChannelId?: string(name='MiChannelId', position='Body'),
  notifyType?: string(name='NotifyType', position='Body'),
  pushAction?: long(name='PushAction', minimum=0, maximum=10, position='Body'),
  pushStyle?: int32(name='PushStyle', position='Body'),
  silent?: long(name='Silent', minimum=-1, maximum=10, position='Body'),
  smsSignName?: string(name='SmsSignName', position='Body'),
  smsStrategy?: int32(name='SmsStrategy', position='Body'),
  smsTemplateCode?: string(name='SmsTemplateCode', position='Body'),
  smsTemplateParam?: string(name='SmsTemplateParam', position='Body'),
  strategyContent?: string(name='StrategyContent', position='Body'),
  strategyType?: int32(name='StrategyType', position='Body'),
  targetMsgkey: string(name='TargetMsgkey', description='This parameter is required.', position='Body'),
  taskName?: string(name='TaskName', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory', shrink='json', position='Body'),
  title: string(name='Title', description='This parameter is required.', position='Body'),
  transparentMessagePayload?: any(name='TransparentMessagePayload', position='Body'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency', position='Body'),
  uri?: string(name='Uri', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model PushSimpleResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushSimpleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushSimpleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PushSimple  PushSimpleRequest
  * @return PushSimpleResponse
 */
async function pushSimple(request: PushSimpleRequest): PushSimpleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PushSimple', 'POST', '/', 'json', true, 'form', request);
}

model PushTemplateRequest {
  regionId?: string(name='RegionId', position='Host'),
  activityContentState?: any(name='ActivityContentState', position='Body'),
  activityEvent?: string(name='ActivityEvent', position='Body'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  channelId?: string(name='ChannelId', position='Body'),
  classification?: string(name='Classification', position='Body'),
  deliveryType: long(name='DeliveryType', description='This parameter is required.', minimum=0, maximum=10, position='Body'),
  dismissalDate?: long(name='DismissalDate', position='Body'),
  expiredSeconds: long(name='ExpiredSeconds', description='This parameter is required.', minimum=0, maximum=259200, position='Body'),
  extendedParams?: string(name='ExtendedParams', position='Body'),
  miChannelId?: string(name='MiChannelId', position='Body'),
  notifyType?: string(name='NotifyType', position='Body'),
  pushAction?: long(name='PushAction', minimum=0, maximum=10, position='Body'),
  silent?: long(name='Silent', minimum=0, maximum=10, position='Body'),
  smsSignName?: string(name='SmsSignName', position='Body'),
  smsStrategy?: int32(name='SmsStrategy', position='Body'),
  smsTemplateCode?: string(name='SmsTemplateCode', position='Body'),
  smsTemplateParam?: string(name='SmsTemplateParam', position='Body'),
  strategyContent?: string(name='StrategyContent', position='Body'),
  strategyType?: int32(name='StrategyType', position='Body'),
  targetMsgkey: string(name='TargetMsgkey', description='This parameter is required.', position='Body'),
  taskName?: string(name='TaskName', position='Body'),
  templateKeyValue?: string(name='TemplateKeyValue', position='Body'),
  templateName: string(name='TemplateName', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  thirdChannelCategory?: map[string]any(name='ThirdChannelCategory', shrink='json', position='Body'),
  transparentMessagePayload?: any(name='TransparentMessagePayload', position='Body'),
  transparentMessageUrgency?: string(name='TransparentMessageUrgency', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model PushTemplateResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PushTemplate  PushTemplateRequest
  * @return PushTemplateResponse
 */
async function pushTemplate(request: PushTemplateRequest): PushTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PushTemplate', 'POST', '/', 'json', true, 'form', request);
}

model PushUnBindRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  deliveryToken: string(name='DeliveryToken', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  userId: string(name='UserId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model PushUnBindResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model PushUnBindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PushUnBindResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PushUnBind  PushUnBindRequest
  * @return PushUnBindResponse
 */
async function pushUnBind(request: PushUnBindRequest): PushUnBindResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PushUnBind', 'POST', '/', 'json', true, 'form', request);
}

model QueryInfoFromMdpRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', example='ALIPUBE5C3F6D091419', position='Body'),
  mobile?: string(name='Mobile', example='13178195662', position='Body'),
  mobileMd5?: string(name='MobileMd5', example='2fe6e5fa754be73d1721b9bd2c6cf821', position='Body'),
  mobileSha256?: string(name='MobileSha256', example='db0797452ccafce84d7c151eb81596099bda3f097693d1e18b588804e6742ced', position='Body'),
  mobileSm3?: string(name='MobileSm3', position='Body'),
  riskScene: string(name='RiskScene', description='This parameter is required.', example='1000', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', example='default', position='Body'),
}

model QueryInfoFromMdpResponseBody = {
  data?: string(name='Data', example='{\\"db0797452ccafce84d7c151eb81596099bda3f097693d1e18b588804e6742ced\\":{\\"riskScore\\":\\"3\\"}}'),
  requestId?: string(name='RequestId', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  resultCode?: int32(name='ResultCode', example='OK'),
  resultMessage?: string(name='ResultMessage', example='SYSTEM_ERROR'),
  success?: boolean(name='Success', example='True'),
}

model QueryInfoFromMdpResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryInfoFromMdpResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryInfoFromMdp  QueryInfoFromMdpRequest
  * @return QueryInfoFromMdpResponse
 */
async function queryInfoFromMdp(request: QueryInfoFromMdpRequest): QueryInfoFromMdpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryInfoFromMdp', 'POST', '/', 'json', true, 'form', request);
}

model QueryLinkRequest {
  appId: string(name='AppId', description='This parameter is required.', example='BB5953C300957', position='Body'),
  url: string(name='Url', description='This parameter is required.', example='8hGb9SyJARqp7V4PGP92X', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', example='default', position='Body'),
}

model QueryLinkResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='D9B3C4E7-BEC7-1E2C-86A3-EA985B4FFD73'),
  resultCode?: string(name='ResultCode', example='100'),
  resultContent?: {
    data?: any(name='Data', example='{
            "Modified": "2024-04-29 16:35:55",
            "NeedRenderEvent": false,
            "WorkspaceId": "default",
            "Cors": false,
            "Url": "https://xxx/xxx",
            "Created": "2024-04-29 16:35:55",
            "LastModified": "2024-04-29 16:35:55",
            "Target": "http://xxx/test.html",
            "Dynamictarget": "",
            "AppId": "BB5953C300957",
            "Version": 0,
            "Traceid": "f6c95f06891a19ff2d896ea309581883",
            "Domain": "u.aliyuncs.com"
        }'),
    target?: string(name='Target', example='https://xxx/xxx/xxx'),
    version?: string(name='Version', example='0'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage', example='success'),
}

model QueryLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryLinkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryLink  QueryLinkRequest
  * @return QueryLinkResponse
 */
async function queryLink(request: QueryLinkRequest): QueryLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryLink', 'POST', '/', 'json', true, 'form', request);
}

model QueryMappCenterAppRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryMappCenterAppResponseBody = {
  queryMappCenterAppResult?: {
    mappCenterApp?: {
      androidConfig?: {
        certRSA?: string(name='CertRSA'),
        packageName?: string(name='PackageName'),
      }(name='AndroidConfig'),
      appDesc?: string(name='AppDesc'),
      appIcon?: string(name='AppIcon'),
      appId?: string(name='AppId'),
      appName?: string(name='AppName'),
      appSecret?: string(name='AppSecret'),
      creator?: string(name='Creator'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: long(name='Id'),
      iosConfig?: {
        bundleId?: string(name='BundleId'),
      }(name='IosConfig'),
      modifier?: string(name='Modifier'),
      monitorJson?: string(name='MonitorJson'),
      status?: long(name='Status'),
      tenantId?: string(name='TenantId'),
      type?: long(name='Type'),
    }(name='MappCenterApp'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryMappCenterAppResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMappCenterAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMappCenterAppResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMappCenterApp  QueryMappCenterAppRequest
  * @return QueryMappCenterAppResponse
 */
async function queryMappCenterApp(request: QueryMappCenterAppRequest): QueryMappCenterAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMappCenterApp', 'POST', '/', 'json', true, 'form', request);
}

model QueryMcdpAimRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  id: long(name='Id', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model QueryMcdpAimResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcdpAimResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcdpAimResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMcdpAim  QueryMcdpAimRequest
  * @return QueryMcdpAimResponse
 */
async function queryMcdpAim(request: QueryMcdpAimRequest): QueryMcdpAimResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMcdpAim', 'POST', '/', 'json', true, 'form', request);
}

model QueryMcdpZoneRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  id?: long(name='Id', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model QueryMcdpZoneResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcdpZoneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcdpZoneResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMcdpZone  QueryMcdpZoneRequest
  * @return QueryMcdpZoneResponse
 */
async function queryMcdpZone(request: QueryMcdpZoneRequest): QueryMcdpZoneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMcdpZone', 'POST', '/', 'json', true, 'form', request);
}

model QueryMcubeMiniPackageRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  h5Id: string(name='H5Id', description='This parameter is required.', position='Body'),
  id: string(name='Id', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryMcubeMiniPackageResponseBody = {
  queryMiniPackageResult?: {
    miniPackageInfo?: {
      appCode?: string(name='AppCode'),
      autoInstall?: long(name='AutoInstall'),
      clientVersionMax?: string(name='ClientVersionMax'),
      clientVersionMin?: string(name='ClientVersionMin'),
      downloadUrl?: string(name='DownloadUrl'),
      extendInfo?: string(name='ExtendInfo'),
      extraData?: string(name='ExtraData'),
      fallbackBaseUrl?: string(name='FallbackBaseUrl'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      h5Id?: string(name='H5Id'),
      h5Name?: string(name='H5Name'),
      h5Version?: string(name='H5Version'),
      id?: long(name='Id'),
      installType?: long(name='InstallType'),
      mainUrl?: string(name='MainUrl'),
      memo?: string(name='Memo'),
      packageType?: long(name='PackageType'),
      platform?: string(name='Platform'),
      publishPeriod?: long(name='PublishPeriod'),
      resourceType?: long(name='ResourceType'),
      status?: long(name='Status'),
    }(name='MiniPackageInfo'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryMiniPackageResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcubeMiniPackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcubeMiniPackageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMcubeMiniPackage  QueryMcubeMiniPackageRequest
  * @return QueryMcubeMiniPackageResponse
 */
async function queryMcubeMiniPackage(request: QueryMcubeMiniPackageRequest): QueryMcubeMiniPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMcubeMiniPackage', 'POST', '/', 'json', true, 'form', request);
}

model QueryMcubeMiniTaskRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  taskId: long(name='TaskId', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryMcubeMiniTaskResponseBody = {
  queryMiniTaskResult?: {
    miniTaskInfo?: {
      appCode?: string(name='AppCode'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      greyConfigInfo?: string(name='GreyConfigInfo'),
      greyEndtime?: string(name='GreyEndtime'),
      greyEndtimeData?: string(name='GreyEndtimeData'),
      greyNum?: long(name='GreyNum'),
      id?: long(name='Id'),
      memo?: string(name='Memo'),
      packageId?: long(name='PackageId'),
      platform?: string(name='Platform'),
      productVersion?: string(name='ProductVersion'),
      publishMode?: long(name='PublishMode'),
      publishType?: long(name='PublishType'),
      status?: string(name='Status'),
      taskStatus?: long(name='TaskStatus'),
      whitelistIds?: string(name='WhitelistIds'),
    }(name='MiniTaskInfo'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryMiniTaskResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcubeMiniTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcubeMiniTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMcubeMiniTask  QueryMcubeMiniTaskRequest
  * @return QueryMcubeMiniTaskResponse
 */
async function queryMcubeMiniTask(request: QueryMcubeMiniTaskRequest): QueryMcubeMiniTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMcubeMiniTask', 'POST', '/', 'json', true, 'form', request);
}

model QueryMcubeVhostRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryMcubeVhostResponseBody = {
  queryVhostResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='QueryVhostResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMcubeVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMcubeVhostResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMcubeVhost  QueryMcubeVhostRequest
  * @return QueryMcubeVhostResponse
 */
async function queryMcubeVhost(request: QueryMcubeVhostRequest): QueryMcubeVhostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMcubeVhost', 'POST', '/', 'json', true, 'form', request);
}

model QueryMdsUpgradeTaskDetailRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  taskId: long(name='TaskId', description='This parameter is required.', minimum=0, maximum=9223372036854775807, position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model QueryMdsUpgradeTaskDetailResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      content?: {
        appCode?: string(name='AppCode'),
        appId?: string(name='AppId'),
        appstoreurl?: string(name='Appstoreurl'),
        channelContains?: string(name='ChannelContains'),
        channelExcludes?: string(name='ChannelExcludes'),
        cityContains?: string(name='CityContains'),
        cityExcludes?: string(name='CityExcludes'),
        creator?: string(name='Creator'),
        deviceGreyNum?: long(name='DeviceGreyNum'),
        devicePercent?: long(name='DevicePercent'),
        downloadUrl?: string(name='DownloadUrl'),
        executionOrder?: long(name='ExecutionOrder'),
        gmtCreateStr?: string(name='GmtCreateStr'),
        greyConfigInfo?: string(name='GreyConfigInfo'),
        greyEndtimeData?: string(name='GreyEndtimeData'),
        greyNotice?: long(name='GreyNotice'),
        greyNum?: long(name='GreyNum'),
        greyUv?: long(name='GreyUv'),
        id?: long(name='Id'),
        innerVersion?: string(name='InnerVersion'),
        isEnterprise?: long(name='IsEnterprise'),
        isOfficial?: long(name='IsOfficial'),
        isPush?: long(name='IsPush'),
        isRc?: long(name='IsRc'),
        isRelease?: long(name='IsRelease'),
        memo?: string(name='Memo'),
        mobileModelContains?: string(name='MobileModelContains'),
        mobileModelExcludes?: string(name='MobileModelExcludes'),
        modifier?: string(name='Modifier'),
        netType?: string(name='NetType'),
        osVersion?: string(name='OsVersion'),
        packageInfoId?: long(name='PackageInfoId'),
        packageType?: string(name='PackageType'),
        platform?: string(name='Platform'),
        productId?: string(name='ProductId'),
        productVersion?: string(name='ProductVersion'),
        publishMode?: long(name='PublishMode'),
        publishType?: long(name='PublishType'),
        pushContent?: string(name='PushContent'),
        qrcodeUrl?: string(name='QrcodeUrl'),
        releaseType?: string(name='ReleaseType'),
        ruleJsonList?: [ 
          {
            operation?: string(name='Operation'),
            ruleElement?: string(name='RuleElement'),
            ruleType?: string(name='RuleType'),
            value?: string(name='Value'),
          }
        ](name='RuleJsonList'),
        silentType?: long(name='SilentType'),
        syncMode?: string(name='SyncMode'),
        syncResult?: string(name='SyncResult'),
        taskStatus?: long(name='TaskStatus'),
        upgradeContent?: string(name='UpgradeContent'),
        upgradeType?: long(name='UpgradeType'),
        upgradeValidTime?: long(name='UpgradeValidTime'),
        whitelist?: [ 
          {
            appCode?: string(name='AppCode'),
            business?: string(name='Business'),
            gmtModified?: string(name='GmtModified'),
            id?: long(name='Id'),
            idType?: string(name='IdType'),
            platform?: string(name='Platform'),
            status?: long(name='Status'),
            whiteListCount?: long(name='WhiteListCount'),
            whiteListName?: string(name='WhiteListName'),
          }
        ](name='Whitelist'),
        whitelistIds?: string(name='WhitelistIds'),
      }(name='Content'),
      errorCode?: string(name='ErrorCode'),
      requestId?: string(name='RequestId'),
      resultMsg?: string(name='ResultMsg'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMdsUpgradeTaskDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMdsUpgradeTaskDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMdsUpgradeTaskDetail  QueryMdsUpgradeTaskDetailRequest
  * @return QueryMdsUpgradeTaskDetailResponse
 */
async function queryMdsUpgradeTaskDetail(request: QueryMdsUpgradeTaskDetailRequest): QueryMdsUpgradeTaskDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMdsUpgradeTaskDetail', 'POST', '/', 'json', true, 'form', request);
}

model QueryMgsApipageRequest {
  regionId?: string(name='RegionId', position='Host'),
  apiStatus?: string(name='ApiStatus', position='Body'),
  apiType?: string(name='ApiType', position='Body'),
  appId?: string(name='AppId', position='Body'),
  format?: string(name='Format', position='Body'),
  host?: string(name='Host', position='Body'),
  needEncrypt?: string(name='NeedEncrypt', position='Body'),
  needEtag?: string(name='NeedEtag', position='Body'),
  needSign?: string(name='NeedSign', position='Body'),
  operationType?: string(name='OperationType', position='Body'),
  optFuzzy?: string(name='OptFuzzy', position='Body'),
  pageIndex?: long(name='PageIndex', position='Body'),
  pageSize?: long(name='PageSize', position='Body'),
  sysId?: long(name='SysId', position='Body'),
  sysName?: string(name='SysName', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model QueryMgsApipageResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    current?: long(name='Current'),
    list?: [ 
      {
        apiInvoker?: {
          httpInvoker?: {
            charset?: string(name='Charset'),
            contentType?: string(name='ContentType'),
            host?: string(name='Host'),
            method?: string(name='Method'),
            path?: string(name='Path'),
          }(name='HttpInvoker'),
          rpcInvoker?: string(name='RpcInvoker'),
        }(name='ApiInvoker'),
        apiName?: string(name='ApiName'),
        apiStatus?: string(name='ApiStatus'),
        apiType?: string(name='ApiType'),
        appId?: string(name='AppId'),
        authRuleName?: string(name='AuthRuleName'),
        cacheRule?: {
          cacheKey?: string(name='CacheKey'),
          needCache?: boolean(name='NeedCache'),
          ttl?: long(name='Ttl'),
        }(name='CacheRule'),
        charset?: string(name='Charset'),
        circuitBreakerRule?: {
          appId?: string(name='AppId'),
          defaultResponse?: string(name='DefaultResponse'),
          errorThreshold?: long(name='ErrorThreshold'),
          id?: long(name='Id'),
          model?: string(name='Model'),
          openTimeoutSeconds?: long(name='OpenTimeoutSeconds'),
          slowRatioThreshold?: double(name='SlowRatioThreshold'),
          switchStatus?: string(name='SwitchStatus'),
          windowsInSeconds?: long(name='WindowsInSeconds'),
          workspaceId?: string(name='WorkspaceId'),
        }(name='CircuitBreakerRule'),
        contentType?: string(name='ContentType'),
        description?: string(name='Description'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        headerRule?: [ 
          {
            headerKey?: string(name='HeaderKey'),
            location?: string(name='Location'),
            type?: string(name='Type'),
            value?: string(name='Value'),
          }
        ](name='HeaderRule'),
        headerRules?: [ 
          {
            headerKey?: string(name='HeaderKey'),
            location?: string(name='Location'),
            type?: string(name='Type'),
            value?: string(name='Value'),
          }
        ](name='HeaderRules'),
        host?: string(name='Host'),
        id?: long(name='Id'),
        interfaceType?: string(name='InterfaceType'),
        limitRule?: {
          defaultResponse?: string(name='DefaultResponse'),
          i18nResponse?: string(name='I18nResponse'),
          interval?: long(name='Interval'),
          limit?: long(name='Limit'),
          mode?: string(name='Mode'),
        }(name='LimitRule'),
        method?: string(name='Method'),
        methodName?: string(name='MethodName'),
        migrateRule?: {
          flowPercent?: long(name='FlowPercent'),
          needMigrate?: boolean(name='NeedMigrate'),
          needSwitchCompletely?: boolean(name='NeedSwitchCompletely'),
          sysId?: long(name='SysId'),
          sysName?: string(name='SysName'),
          upstreamType?: string(name='UpstreamType'),
        }(name='MigrateRule'),
        mockRule?: {
          mockData?: string(name='MockData'),
          needMock?: boolean(name='NeedMock'),
          percentage?: long(name='Percentage'),
          type?: string(name='Type'),
        }(name='MockRule'),
        needETag?: string(name='NeedETag'),
        needEncrypt?: string(name='NeedEncrypt'),
        needJsonp?: string(name='NeedJsonp'),
        needSign?: string(name='NeedSign'),
        operationType?: string(name='OperationType'),
        paramGetMethod?: string(name='ParamGetMethod'),
        path?: string(name='Path'),
        requestBodyModel?: string(name='RequestBodyModel'),
        requestParams?: [ 
          {
            apiId?: string(name='ApiId'),
            appId?: string(name='AppId'),
            defaultValue?: string(name='DefaultValue'),
            description?: string(name='Description'),
            id?: long(name='Id'),
            location?: string(name='Location'),
            name?: string(name='Name'),
            refType?: string(name='RefType'),
            type?: string(name='Type'),
            workspaceId?: string(name='WorkspaceId'),
          }
        ](name='RequestParams'),
        responseBodyModel?: string(name='ResponseBodyModel'),
        sysId?: long(name='SysId'),
        sysName?: string(name='SysName'),
        timeout?: string(name='Timeout'),
        workspaceId?: string(name='WorkspaceId'),
      }
    ](name='List'),
    pageSize?: long(name='PageSize'),
    total?: long(name='Total'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMgsApipageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMgsApipageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMgsApipage  QueryMgsApipageRequest
  * @return QueryMgsApipageResponse
 */
async function queryMgsApipage(request: QueryMgsApipageRequest): QueryMgsApipageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMgsApipage', 'POST', '/', 'json', true, 'form', request);
}

model QueryMgsApirestRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  format?: string(name='Format', position='Body'),
  id?: long(name='Id', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  type?: string(name='Type', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model QueryMgsApirestResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    errorMessage?: string(name='ErrorMessage'),
    success?: boolean(name='Success'),
    value?: {
      apiInvoker?: {
        httpInvoker?: {
          charset?: string(name='Charset'),
          contentType?: string(name='ContentType'),
          host?: string(name='Host'),
          method?: string(name='Method'),
          path?: string(name='Path'),
        }(name='HttpInvoker'),
        rpcInvoker?: string(name='RpcInvoker'),
      }(name='ApiInvoker'),
      apiName?: string(name='ApiName'),
      apiStatus?: string(name='ApiStatus'),
      apiType?: string(name='ApiType'),
      appId?: string(name='AppId'),
      authRuleName?: string(name='AuthRuleName'),
      cacheRule?: {
        cacheKey?: string(name='CacheKey'),
        needCache?: boolean(name='NeedCache'),
        ttl?: long(name='Ttl'),
      }(name='CacheRule'),
      charset?: string(name='Charset'),
      circuitBreakerRule?: {
        appId?: string(name='AppId'),
        defaultResponse?: string(name='DefaultResponse'),
        errorThreshold?: long(name='ErrorThreshold'),
        id?: long(name='Id'),
        model?: string(name='Model'),
        openTimeoutSeconds?: long(name='OpenTimeoutSeconds'),
        slowRatioThreshold?: double(name='SlowRatioThreshold'),
        switchStatus?: string(name='SwitchStatus'),
        windowsInSeconds?: long(name='WindowsInSeconds'),
        workspaceId?: string(name='WorkspaceId'),
      }(name='CircuitBreakerRule'),
      contentType?: string(name='ContentType'),
      defaultLimitRule?: {
        configId?: int32(name='ConfigId'),
        defaultLimit?: boolean(name='DefaultLimit'),
      }(name='DefaultLimitRule'),
      description?: string(name='Description'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      headerRule?: [ 
        {
          headerKey?: string(name='HeaderKey'),
          location?: string(name='Location'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='HeaderRule'),
      headerRules?: [ 
        {
          headerKey?: string(name='HeaderKey'),
          location?: string(name='Location'),
          type?: string(name='Type'),
          value?: string(name='Value'),
        }
      ](name='HeaderRules'),
      host?: string(name='Host'),
      id?: long(name='Id'),
      interfaceType?: string(name='InterfaceType'),
      limitRule?: {
        defaultResponse?: string(name='DefaultResponse'),
        i18nResponse?: string(name='I18nResponse'),
        interval?: long(name='Interval'),
        limit?: long(name='Limit'),
        mode?: string(name='Mode'),
      }(name='LimitRule'),
      method?: string(name='Method'),
      methodName?: string(name='MethodName'),
      migrateRule?: {
        flowPercent?: long(name='FlowPercent'),
        needMigrate?: boolean(name='NeedMigrate'),
        needSwitchCompletely?: boolean(name='NeedSwitchCompletely'),
        sysId?: long(name='SysId'),
        sysName?: string(name='SysName'),
        upstreamType?: string(name='UpstreamType'),
      }(name='MigrateRule'),
      mockRule?: {
        mockData?: string(name='MockData'),
        needMock?: boolean(name='NeedMock'),
        percentage?: long(name='Percentage'),
        type?: string(name='Type'),
      }(name='MockRule'),
      needETag?: string(name='NeedETag'),
      needEncrypt?: string(name='NeedEncrypt'),
      needJsonp?: string(name='NeedJsonp'),
      needSign?: string(name='NeedSign'),
      operationType?: string(name='OperationType'),
      paramGetMethod?: string(name='ParamGetMethod'),
      path?: string(name='Path'),
      requestBodyModel?: string(name='RequestBodyModel'),
      requestParams?: [ 
        {
          apiId?: string(name='ApiId'),
          appId?: string(name='AppId'),
          defaultValue?: string(name='DefaultValue'),
          description?: string(name='Description'),
          id?: long(name='Id'),
          location?: string(name='Location'),
          name?: string(name='Name'),
          refType?: string(name='RefType'),
          type?: string(name='Type'),
          workspaceId?: string(name='WorkspaceId'),
        }
      ](name='RequestParams'),
      responseBodyModel?: string(name='ResponseBodyModel'),
      sysId?: long(name='SysId'),
      sysName?: string(name='SysName'),
      timeout?: string(name='Timeout'),
      workspaceId?: string(name='WorkspaceId'),
    }(name='Value'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMgsApirestResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMgsApirestResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMgsApirest  QueryMgsApirestRequest
  * @return QueryMgsApirestResponse
 */
async function queryMgsApirest(request: QueryMgsApirestRequest): QueryMgsApirestResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMgsApirest', 'POST', '/', 'json', true, 'form', request);
}

model QueryMgsTestreqbodyautogenRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  format?: string(name='Format', position='Body'),
  mpaasMappcenterMgsTestreqbodyautogenQueryJsonStr?: string(name='MpaasMappcenterMgsTestreqbodyautogenQueryJsonStr', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model QueryMgsTestreqbodyautogenResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: string(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMgsTestreqbodyautogenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMgsTestreqbodyautogenResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMgsTestreqbodyautogen  QueryMgsTestreqbodyautogenRequest
  * @return QueryMgsTestreqbodyautogenResponse
 */
async function queryMgsTestreqbodyautogen(request: QueryMgsTestreqbodyautogenRequest): QueryMgsTestreqbodyautogenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMgsTestreqbodyautogen', 'POST', '/', 'json', true, 'form', request);
}

model QueryMpsSchedulerListRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  endTime?: long(name='EndTime', minimum=0, maximum=99999999999999999, position='Body'),
  pageNumber?: int32(name='PageNumber', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  startTime?: long(name='StartTime', minimum=0, maximum=99999999999999999, position='Body'),
  type?: int32(name='Type', position='Body'),
  uniqueId?: string(name='UniqueId', maxLength=100000000000000000, position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryMpsSchedulerListResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      list?: [ 
        {
          createType?: int32(name='CreateType'),
          deliveryType?: int32(name='DeliveryType'),
          executedStatus?: string(name='ExecutedStatus'),
          gmtCreate?: long(name='GmtCreate'),
          parentId?: string(name='ParentId'),
          pushContent?: string(name='PushContent'),
          pushTime?: long(name='PushTime'),
          pushTitle?: string(name='PushTitle'),
          strategyType?: int32(name='StrategyType'),
          type?: int32(name='Type'),
          uniqueId?: string(name='UniqueId'),
        }
      ](name='List'),
      totalCount?: int32(name='TotalCount'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryMpsSchedulerListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMpsSchedulerListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMpsSchedulerList  QueryMpsSchedulerListRequest
  * @return QueryMpsSchedulerListResponse
 */
async function queryMpsSchedulerList(request: QueryMpsSchedulerListRequest): QueryMpsSchedulerListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMpsSchedulerList', 'POST', '/', 'json', true, 'form', request);
}

model QueryPushAnalysisCoreIndexRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  channel?: string(name='Channel', position='Body'),
  endTime: long(name='EndTime', description='This parameter is required.', minimum=0, maximum=99999999999999999, position='Body'),
  platform?: string(name='Platform', position='Body'),
  startTime: long(name='StartTime', description='This parameter is required.', minimum=0, maximum=99999999999999999, position='Body'),
  taskId?: string(name='TaskId', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  type?: string(name='Type', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryPushAnalysisCoreIndexResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      arrivalNum?: float(name='ArrivalNum'),
      arrivalRate?: float(name='ArrivalRate'),
      ignoreNum?: float(name='IgnoreNum'),
      ignoreRate?: float(name='IgnoreRate'),
      openNum?: float(name='OpenNum'),
      openRate?: float(name='OpenRate'),
      pushNum?: float(name='PushNum'),
      pushTotalNum?: float(name='PushTotalNum'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushAnalysisCoreIndexResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushAnalysisCoreIndexResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryPushAnalysisCoreIndex  QueryPushAnalysisCoreIndexRequest
  * @return QueryPushAnalysisCoreIndexResponse
 */
async function queryPushAnalysisCoreIndex(request: QueryPushAnalysisCoreIndexRequest): QueryPushAnalysisCoreIndexResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryPushAnalysisCoreIndex', 'POST', '/', 'json', true, 'form', request);
}

model QueryPushAnalysisTaskDetailRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  taskId: string(name='TaskId', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryPushAnalysisTaskDetailResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      duration?: string(name='Duration'),
      endTime?: long(name='EndTime'),
      pushArrivalNum?: float(name='PushArrivalNum'),
      pushNum?: float(name='PushNum'),
      pushSuccessNum?: float(name='PushSuccessNum'),
      startTime?: long(name='StartTime'),
      taskId?: long(name='TaskId'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushAnalysisTaskDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushAnalysisTaskDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryPushAnalysisTaskDetail  QueryPushAnalysisTaskDetailRequest
  * @return QueryPushAnalysisTaskDetailResponse
 */
async function queryPushAnalysisTaskDetail(request: QueryPushAnalysisTaskDetailRequest): QueryPushAnalysisTaskDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryPushAnalysisTaskDetail', 'POST', '/', 'json', true, 'form', request);
}

model QueryPushAnalysisTaskListRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  pageNumber?: int32(name='PageNumber', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  startTime: long(name='StartTime', description='This parameter is required.', minimum=0, maximum=99999999999999999, position='Body'),
  taskId?: string(name='TaskId', position='Body'),
  taskName?: string(name='TaskName', maxLength=100000000000000000, position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryPushAnalysisTaskListResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: [ 
      {
        gmtCreate?: long(name='GmtCreate'),
        list?: [ 
          {
            gmtCreate?: long(name='GmtCreate'),
            taskId?: string(name='TaskId'),
            taskName?: string(name='TaskName'),
            templateId?: string(name='TemplateId'),
            templateName?: string(name='TemplateName'),
            type?: long(name='Type'),
          }
        ](name='List'),
        taskId?: string(name='TaskId'),
        taskName?: string(name='TaskName'),
        templateId?: string(name='TemplateId'),
        templateName?: string(name='TemplateName'),
        type?: long(name='Type'),
      }
    ](name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushAnalysisTaskListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushAnalysisTaskListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryPushAnalysisTaskList  QueryPushAnalysisTaskListRequest
  * @return QueryPushAnalysisTaskListResponse
 */
async function queryPushAnalysisTaskList(request: QueryPushAnalysisTaskListRequest): QueryPushAnalysisTaskListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryPushAnalysisTaskList', 'POST', '/', 'json', true, 'form', request);
}

model QueryPushSchedulerListRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  endTime: long(name='EndTime', description='This parameter is required.', minimum=0, maximum=99999999999999999, position='Body'),
  pageNumber?: int32(name='PageNumber', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  startTime: long(name='StartTime', description='This parameter is required.', minimum=0, maximum=99999999999999999, position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  type?: int32(name='Type', position='Body'),
  uniqueId?: string(name='UniqueId', maxLength=100000000000000000, position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model QueryPushSchedulerListResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      list?: [ 
        {
          createType?: int32(name='CreateType'),
          deliveryType?: int32(name='DeliveryType'),
          executedStatus?: string(name='ExecutedStatus'),
          gmtCreate?: long(name='GmtCreate'),
          parentId?: string(name='ParentId'),
          pushContent?: string(name='PushContent'),
          pushTime?: long(name='PushTime'),
          pushTitle?: string(name='PushTitle'),
          strategyType?: int32(name='StrategyType'),
          type?: int32(name='Type'),
          uniqueId?: string(name='UniqueId'),
        }
      ](name='List'),
      totalCount?: int32(name='TotalCount'),
    }(name='Data'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model QueryPushSchedulerListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryPushSchedulerListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryPushSchedulerList  QueryPushSchedulerListRequest
  * @return QueryPushSchedulerListResponse
 */
async function queryPushSchedulerList(request: QueryPushSchedulerListRequest): QueryPushSchedulerListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryPushSchedulerList', 'POST', '/', 'json', true, 'form', request);
}

model RevokePushMessageRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  messageId: string(name='MessageId', description='This parameter is required.', position='Body'),
  targetId: string(name='TargetId', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model RevokePushMessageResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model RevokePushMessageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokePushMessageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RevokePushMessage  RevokePushMessageRequest
  * @return RevokePushMessageResponse
 */
async function revokePushMessage(request: RevokePushMessageRequest): RevokePushMessageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokePushMessage', 'POST', '/', 'json', true, 'form', request);
}

model RevokePushTaskRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  taskId: string(name='TaskId', description='This parameter is required.', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model RevokePushTaskResponseBody = {
  pushResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='PushResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model RevokePushTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokePushTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RevokePushTask  RevokePushTaskRequest
  * @return RevokePushTaskResponse
 */
async function revokePushTask(request: RevokePushTaskRequest): RevokePushTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokePushTask', 'POST', '/', 'json', true, 'form', request);
}

model RunMsaDiffRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  mpaasMappcenterMsaDiffRunJsonStr: string(name='MpaasMappcenterMsaDiffRunJsonStr', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model RunMsaDiffResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: string(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model RunMsaDiffResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RunMsaDiffResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RunMsaDiff  RunMsaDiffRequest
  * @return RunMsaDiffResponse
 */
async function runMsaDiff(request: RunMsaDiffRequest): RunMsaDiffResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunMsaDiff', 'POST', '/', 'json', true, 'form', request);
}

model SaveMgsApirestRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  mpaasMappcenterMgsApirestSaveJsonStr?: string(name='MpaasMappcenterMgsApirestSaveJsonStr', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
  workspaceId?: string(name='WorkspaceId', position='Body'),
}

model SaveMgsApirestResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    errorMessage?: string(name='ErrorMessage'),
    success?: boolean(name='Success'),
    value?: boolean(name='Value'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model SaveMgsApirestResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SaveMgsApirestResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SaveMgsApirest  SaveMgsApirestRequest
  * @return SaveMgsApirestResponse
 */
async function saveMgsApirest(request: SaveMgsApirestRequest): SaveMgsApirestResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveMgsApirest', 'POST', '/', 'json', true, 'form', request);
}

model StartUserAppAsyncEnhanceInMsaRequest {
  regionId?: string(name='RegionId', position='Host'),
  apkProtector?: boolean(name='ApkProtector', position='Body'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  assetsFileList?: string(name='AssetsFileList', position='Body'),
  classes?: string(name='Classes', position='Body'),
  dalvikDebugger?: int32(name='DalvikDebugger', position='Body'),
  emulatorEnvironment?: int32(name='EmulatorEnvironment', position='Body'),
  id: long(name='Id', description='This parameter is required.', position='Body'),
  javaHook?: int32(name='JavaHook', position='Body'),
  memoryDump?: int32(name='MemoryDump', position='Body'),
  nativeDebugger?: int32(name='NativeDebugger', position='Body'),
  nativeHook?: int32(name='NativeHook', position='Body'),
  packageTampered?: int32(name='PackageTampered', position='Body'),
  root?: int32(name='Root', position='Body'),
  runMode?: string(name='RunMode', position='Body'),
  soFileList?: string(name='SoFileList', position='Body'),
  taskType?: string(name='TaskType', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  totalSwitch?: boolean(name='TotalSwitch', position='Body'),
  useAShield?: boolean(name='UseAShield', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model StartUserAppAsyncEnhanceInMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: {
      afterMd5?: string(name='AfterMd5'),
      afterSize?: long(name='AfterSize'),
      appCode?: string(name='AppCode'),
      appPackage?: string(name='AppPackage'),
      assetsFileList?: [ string ](name='AssetsFileList'),
      beforeMd5?: string(name='BeforeMd5'),
      beforeSize?: long(name='BeforeSize'),
      classForest?: string(name='ClassForest'),
      enhanceMapping?: [ 
        {
          info?: string(name='Info'),
          reason?: string(name='Reason'),
          type?: string(name='Type'),
        }
      ](name='EnhanceMapping'),
      enhanceRules?: [ string ](name='EnhanceRules'),
      enhancedAssetsFiles?: [ string ](name='EnhancedAssetsFiles'),
      enhancedClasses?: [ string ](name='EnhancedClasses'),
      enhancedSoFiles?: [ string ](name='EnhancedSoFiles'),
      id?: long(name='Id'),
      label?: string(name='Label'),
      progress?: long(name='Progress'),
      soFileList?: [ string ](name='SoFileList'),
      status?: long(name='Status'),
      taskType?: string(name='TaskType'),
      versionCode?: string(name='VersionCode'),
      versionName?: string(name='VersionName'),
    }(name='Data'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model StartUserAppAsyncEnhanceInMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartUserAppAsyncEnhanceInMsaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StartUserAppAsyncEnhanceInMsa  StartUserAppAsyncEnhanceInMsaRequest
  * @return StartUserAppAsyncEnhanceInMsaResponse
 */
async function startUserAppAsyncEnhanceInMsa(request: StartUserAppAsyncEnhanceInMsaRequest): StartUserAppAsyncEnhanceInMsaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartUserAppAsyncEnhanceInMsa', 'POST', '/', 'json', true, 'form', request);
}

model UpdateLinkRequest {
  appId: string(name='AppId', description='This parameter is required.', example='BB5953C300957', position='Body'),
  cors?: boolean(name='Cors', example='true', position='Body'),
  domain?: string(name='Domain', example='x519.cn', position='Body'),
  dynamicfield?: string(name='Dynamicfield', example='txt', position='Body'),
  targetUrl: string(name='TargetUrl', description='This parameter is required.', example='https://********', position='Body'),
  url: string(name='Url', description='This parameter is required.', example='https://xxx/8hGb9SyJARqp7V4PGP92X', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', example='default', position='Body'),
}

model UpdateLinkResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  resultCode?: string(name='ResultCode', example='100'),
  resultContent?: {
    data?: string(name='Data', example='https://xxx/xxx'),
    target?: string(name='Target', example='https://xxx/xxx/xxx'),
    version?: string(name='Version', example='1'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage', example='success'),
}

model UpdateLinkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLinkResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateLink  UpdateLinkRequest
  * @return UpdateLinkResponse
 */
async function updateLink(request: UpdateLinkRequest): UpdateLinkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLink', 'POST', '/', 'json', true, 'form', request);
}

model UpdateMcubeWhitelistRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  id: string(name='Id', description='This parameter is required.', position='Body'),
  keyIds?: string(name='KeyIds', position='Body'),
  onexFlag: boolean(name='OnexFlag', description='This parameter is required.', position='Body'),
  ossUrl?: string(name='OssUrl', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model UpdateMcubeWhitelistResponseBody = {
  addWhitelistResult?: {
    addWhitelistInfo?: {
      failNum?: long(name='FailNum'),
      failUserIds?: string(name='FailUserIds'),
      successNum?: long(name='SuccessNum'),
    }(name='AddWhitelistInfo'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='AddWhitelistResult'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
}

model UpdateMcubeWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMcubeWhitelistResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateMcubeWhitelist  UpdateMcubeWhitelistRequest
  * @return UpdateMcubeWhitelistResponse
 */
async function updateMcubeWhitelist(request: UpdateMcubeWhitelistRequest): UpdateMcubeWhitelistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMcubeWhitelist', 'POST', '/', 'json', true, 'form', request);
}

model UpdateMpaasAppInfoRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId?: string(name='AppId', position='Body'),
  appName?: string(name='AppName', position='Body'),
  iconFileUrl?: string(name='IconFileUrl', position='Body'),
  identifier?: string(name='Identifier', position='Body'),
  onexFlag?: boolean(name='OnexFlag', position='Body'),
  systemType?: string(name='SystemType', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
}

model UpdateMpaasAppInfoResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    data?: {
      appId?: string(name='AppId'),
      code?: string(name='Code'),
      data?: string(name='Data'),
      message?: string(name='Message'),
      success?: boolean(name='Success'),
    }(name='Data'),
    requestId?: string(name='RequestId'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model UpdateMpaasAppInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMpaasAppInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateMpaasAppInfo  UpdateMpaasAppInfoRequest
  * @return UpdateMpaasAppInfoResponse
 */
async function updateMpaasAppInfo(request: UpdateMpaasAppInfoRequest): UpdateMpaasAppInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMpaasAppInfo', 'POST', '/', 'json', true, 'form', request);
}

model UploadBitcodeToMsaRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', example='ALIPUBE5C3F6D091419', position='Body'),
  bitcode?: string(name='Bitcode', example='3sAXCwAAAAAUAAAACHoAAP', position='Body'),
  codeVersion?: string(name='CodeVersion', example='xcode14', position='Body'),
  license?: string(name='License', example='{}', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', example='ZXCXMAHQ-zh_CN', position='Body'),
  type?: string(name='Type', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', example='dev', position='Body'),
}

model UploadBitcodeToMsaResponseBody = {
  requestId?: string(name='RequestId', example='11E66B29-9E5E-5C10-B64E-B5A0E0F26355'),
  resultCode?: string(name='ResultCode', example='OK'),
  resultContent?: {
    code?: string(name='Code', example='200'),
    data?: string(name='Data', example='1234'),
    message?: string(name='Message', example='Normal'),
    success?: boolean(name='Success', example='True'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage', example='SYSTEM_ERROR'),
}

model UploadBitcodeToMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadBitcodeToMsaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UploadBitcodeToMsa  UploadBitcodeToMsaRequest
  * @return UploadBitcodeToMsaResponse
 */
async function uploadBitcodeToMsa(request: UploadBitcodeToMsaRequest): UploadBitcodeToMsaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UploadBitcodeToMsa', 'POST', '/', 'json', true, 'form', request);
}

model UploadMcubeMiniPackageRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  autoInstall: long(name='AutoInstall', description='This parameter is required.', position='Body'),
  clientVersionMax?: string(name='ClientVersionMax', position='Body'),
  clientVersionMin: string(name='ClientVersionMin', description='This parameter is required.', position='Body'),
  enableKeepAlive: string(name='EnableKeepAlive', description='This parameter is required.', position='Body'),
  enableOptionMenu: string(name='EnableOptionMenu', description='This parameter is required.', position='Body'),
  enableTabBar: long(name='EnableTabBar', description='This parameter is required.', position='Body'),
  extendInfo?: string(name='ExtendInfo', position='Body'),
  h5Id: string(name='H5Id', description='This parameter is required.', position='Body'),
  h5Name: string(name='H5Name', description='This parameter is required.', position='Body'),
  h5Version: string(name='H5Version', description='This parameter is required.', position='Body'),
  iconFileUrl?: string(name='IconFileUrl', position='Body'),
  iconUrl?: string(name='IconUrl', position='Body'),
  installType: long(name='InstallType', description='This parameter is required.', position='Body'),
  mainUrl: string(name='MainUrl', description='This parameter is required.', position='Body'),
  onexFlag: boolean(name='OnexFlag', description='This parameter is required.', position='Body'),
  packageType: long(name='PackageType', description='This parameter is required.', position='Body'),
  platform: string(name='Platform', description='This parameter is required.', position='Body'),
  resourceFileUrl: string(name='ResourceFileUrl', description='This parameter is required.', position='Body'),
  resourceType: long(name='ResourceType', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  userId: string(name='UserId', description='This parameter is required.', position='Body'),
  uuid?: string(name='Uuid', position='Body'),
  vhost: string(name='Vhost', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model UploadMcubeMiniPackageResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  uploadMiniPackageResult?: {
    resultMsg?: string(name='ResultMsg'),
    returnPackageResult?: {
      debugUrl?: string(name='DebugUrl'),
      packageId?: string(name='PackageId'),
      userId?: string(name='UserId'),
    }(name='ReturnPackageResult'),
    success?: boolean(name='Success'),
  }(name='UploadMiniPackageResult'),
}

model UploadMcubeMiniPackageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadMcubeMiniPackageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UploadMcubeMiniPackage  UploadMcubeMiniPackageRequest
  * @return UploadMcubeMiniPackageResponse
 */
async function uploadMcubeMiniPackage(request: UploadMcubeMiniPackageRequest): UploadMcubeMiniPackageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UploadMcubeMiniPackage', 'POST', '/', 'json', true, 'form', request);
}

model UploadMcubeRsaKeyRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  fileUrl: string(name='FileUrl', description='This parameter is required.', position='Body'),
  onexFlag: boolean(name='OnexFlag', description='This parameter is required.', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model UploadMcubeRsaKeyResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMessage?: string(name='ResultMessage'),
  uploadRsaResult?: {
    data?: string(name='Data'),
    resultMsg?: string(name='ResultMsg'),
    success?: boolean(name='Success'),
  }(name='UploadRsaResult'),
}

model UploadMcubeRsaKeyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadMcubeRsaKeyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UploadMcubeRsaKey  UploadMcubeRsaKeyRequest
  * @return UploadMcubeRsaKeyResponse
 */
async function uploadMcubeRsaKey(request: UploadMcubeRsaKeyRequest): UploadMcubeRsaKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UploadMcubeRsaKey', 'POST', '/', 'json', true, 'form', request);
}

model UploadUserAppToMsaRequest {
  regionId?: string(name='RegionId', position='Host'),
  appId: string(name='AppId', description='This parameter is required.', position='Body'),
  fileUrl?: string(name='FileUrl', position='Body'),
  tenantId: string(name='TenantId', description='This parameter is required.', position='Body'),
  workspaceId: string(name='WorkspaceId', description='This parameter is required.', position='Body'),
}

model UploadUserAppToMsaResponseBody = {
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultContent?: {
    code?: string(name='Code'),
    data?: {
      apkInfo?: {
        afterMd5?: string(name='AfterMd5'),
        afterSize?: long(name='AfterSize'),
        appCode?: string(name='AppCode'),
        appPackage?: string(name='AppPackage'),
        beforeMd5?: string(name='BeforeMd5'),
        beforeSize?: long(name='BeforeSize'),
        classForest?: string(name='ClassForest'),
        enhanceMapping?: {
          info?: string(name='Info'),
          reason?: string(name='Reason'),
          type?: string(name='Type'),
        }(name='EnhanceMapping'),
        enhanceRules?: [ string ](name='EnhanceRules'),
        enhancedClasses?: [ string ](name='EnhancedClasses'),
        id?: long(name='Id'),
        label?: string(name='Label'),
        progress?: long(name='Progress'),
        status?: long(name='Status'),
        taskType?: string(name='TaskType'),
        versionCode?: string(name='VersionCode'),
        versionName?: string(name='VersionName'),
      }(name='ApkInfo'),
      enhanceTaskId?: long(name='EnhanceTaskId'),
      id?: long(name='Id'),
      progress?: long(name='Progress'),
      status?: long(name='Status'),
    }(name='Data'),
    extra?: string(name='Extra'),
    message?: string(name='Message'),
    success?: boolean(name='Success'),
  }(name='ResultContent'),
  resultMessage?: string(name='ResultMessage'),
}

model UploadUserAppToMsaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadUserAppToMsaResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UploadUserAppToMsa  UploadUserAppToMsaRequest
  * @return UploadUserAppToMsaResponse
 */
async function uploadUserAppToMsa(request: UploadUserAppToMsaRequest): UploadUserAppToMsaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UploadUserAppToMsa', 'POST', '/', 'json', true, 'form', request);
}

