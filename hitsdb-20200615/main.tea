/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('hitsdb', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ChangeResourceGroupRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group into which you want to change.

This parameter is required.', example='rg-aek2i6wee****'),
  resourceId?: string(name='ResourceId', description='The resource ID.

This parameter is required.', example='ld-bp17j28j2y7pm****'),
  resourceRegionId?: string(name='ResourceRegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model ChangeResourceGroupResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', description='The detailed reason why the access was denied.', example='{"AuthAction":"xxx","AuthPrincipalDisplayName":"222","AuthPrincipalOwnerId":"111","AuthPrincipalType":"SubUser",,"NoPermissionType":"ImplicitDeny","PolicyType":"AccountLevelIdentityBasedPolicy","EncodedDiagnosticMessage":"xxxxxx"}'),
  requestId?: string(name='RequestId', description='Id of the request', example='FAED4C02-AF99-5015-A075-692DE9C99630'),
}

model ChangeResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeResourceGroupResponseBody(name='body'),
}

/**
 * @summary Changes a resource group to another.
 *
 * @param request ChangeResourceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeResourceGroupResponse
 */
async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: Util.RuntimeOptions): ChangeResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceRegionId)) {
    query['ResourceRegionId'] = request.resourceRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeResourceGroup',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Changes a resource group to another.
 *
 * @param request ChangeResourceGroupRequest
 * @return ChangeResourceGroupResponse
 */
async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeResourceGroupWithOptions(request, runtime);
}

model CheckLdpsColumnarIndexStatusRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model CheckLdpsColumnarIndexStatusResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  opened?: boolean(name='Opened'),
  requestId?: string(name='RequestId'),
}

model CheckLdpsColumnarIndexStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckLdpsColumnarIndexStatusResponseBody(name='body'),
}

/**
 * @param request CheckLdpsColumnarIndexStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckLdpsColumnarIndexStatusResponse
 */
async function checkLdpsColumnarIndexStatusWithOptions(request: CheckLdpsColumnarIndexStatusRequest, runtime: Util.RuntimeOptions): CheckLdpsColumnarIndexStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckLdpsColumnarIndexStatus',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request CheckLdpsColumnarIndexStatusRequest
 * @return CheckLdpsColumnarIndexStatusResponse
 */
async function checkLdpsColumnarIndexStatus(request: CheckLdpsColumnarIndexStatusRequest): CheckLdpsColumnarIndexStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkLdpsColumnarIndexStatusWithOptions(request, runtime);
}

model CreateAutoScalingConfigRequest {
  configName?: string(name='ConfigName', description='This parameter is required.'),
  effectiveTimeEnd?: string(name='EffectiveTimeEnd'),
  effectiveTimeStart?: string(name='EffectiveTimeStart'),
  enabled?: boolean(name='Enabled'),
  engine?: string(name='Engine', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  nodesMax?: int32(name='NodesMax'),
  nodesMin?: int32(name='NodesMin'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scaleRuleList?: [ 
    {
      configId?: string(name='ConfigId'),
      enabled?: boolean(name='Enabled'),
      endTime?: string(name='EndTime'),
      instanceId?: string(name='InstanceId'),
      observationWindow?: int32(name='ObservationWindow'),
      operationType?: string(name='OperationType'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      ruleType?: string(name='RuleType'),
      scaleInStep?: int32(name='ScaleInStep'),
      scaleOutStep?: int32(name='ScaleOutStep'),
      silenceTime?: int32(name='SilenceTime'),
      startTime?: string(name='StartTime'),
      targetMetric?: string(name='TargetMetric'),
      targetNodes?: int32(name='TargetNodes'),
      thresholdLower?: int32(name='ThresholdLower'),
      thresholdUpper?: int32(name='ThresholdUpper'),
      triggerCronExpr?: string(name='TriggerCronExpr'),
    }
  ](name='ScaleRuleList'),
  scaleType?: string(name='ScaleType', description='This parameter is required.'),
  securityToken?: string(name='SecurityToken'),
  specId?: string(name='SpecId', description='This parameter is required.'),
}

model CreateAutoScalingConfigShrinkRequest {
  configName?: string(name='ConfigName', description='This parameter is required.'),
  effectiveTimeEnd?: string(name='EffectiveTimeEnd'),
  effectiveTimeStart?: string(name='EffectiveTimeStart'),
  enabled?: boolean(name='Enabled'),
  engine?: string(name='Engine', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  nodesMax?: int32(name='NodesMax'),
  nodesMin?: int32(name='NodesMin'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scaleRuleListShrink?: string(name='ScaleRuleList'),
  scaleType?: string(name='ScaleType', description='This parameter is required.'),
  securityToken?: string(name='SecurityToken'),
  specId?: string(name='SpecId', description='This parameter is required.'),
}

model CreateAutoScalingConfigResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateAutoScalingConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAutoScalingConfigResponseBody(name='body'),
}

/**
 * @param tmpReq CreateAutoScalingConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAutoScalingConfigResponse
 */
async function createAutoScalingConfigWithOptions(tmpReq: CreateAutoScalingConfigRequest, runtime: Util.RuntimeOptions): CreateAutoScalingConfigResponse {
  Util.validateModel(tmpReq);
  var request = new CreateAutoScalingConfigShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.scaleRuleList)) {
    request.scaleRuleListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scaleRuleList, 'ScaleRuleList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.configName)) {
    query['ConfigName'] = request.configName;
  }
  if (!Util.isUnset(request.effectiveTimeEnd)) {
    query['EffectiveTimeEnd'] = request.effectiveTimeEnd;
  }
  if (!Util.isUnset(request.effectiveTimeStart)) {
    query['EffectiveTimeStart'] = request.effectiveTimeStart;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nodesMax)) {
    query['NodesMax'] = request.nodesMax;
  }
  if (!Util.isUnset(request.nodesMin)) {
    query['NodesMin'] = request.nodesMin;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scaleRuleListShrink)) {
    query['ScaleRuleList'] = request.scaleRuleListShrink;
  }
  if (!Util.isUnset(request.scaleType)) {
    query['ScaleType'] = request.scaleType;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.specId)) {
    query['SpecId'] = request.specId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAutoScalingConfig',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request CreateAutoScalingConfigRequest
 * @return CreateAutoScalingConfigResponse
 */
async function createAutoScalingConfig(request: CreateAutoScalingConfigRequest): CreateAutoScalingConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAutoScalingConfigWithOptions(request, runtime);
}

model CreateAutoScalingRuleRequest {
  configId?: string(name='ConfigId', description='This parameter is required.'),
  enabled?: boolean(name='Enabled'),
  endTime?: string(name='EndTime'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  observationWindow?: int32(name='ObservationWindow'),
  operationType?: string(name='OperationType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleName?: string(name='RuleName', description='This parameter is required.'),
  ruleType?: string(name='RuleType', description='This parameter is required.'),
  scaleInStep?: int32(name='ScaleInStep'),
  scaleOutStep?: int32(name='ScaleOutStep'),
  securityToken?: string(name='SecurityToken'),
  silenceTime?: int32(name='SilenceTime'),
  startTime?: string(name='StartTime'),
  targetMetric?: string(name='TargetMetric'),
  targetNodes?: int32(name='TargetNodes'),
  thresholdLower?: int32(name='ThresholdLower'),
  thresholdUpper?: int32(name='ThresholdUpper'),
  triggerCronExpr?: string(name='TriggerCronExpr'),
}

model CreateAutoScalingRuleResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateAutoScalingRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAutoScalingRuleResponseBody(name='body'),
}

/**
 * @param request CreateAutoScalingRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAutoScalingRuleResponse
 */
async function createAutoScalingRuleWithOptions(request: CreateAutoScalingRuleRequest, runtime: Util.RuntimeOptions): CreateAutoScalingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.observationWindow)) {
    query['ObservationWindow'] = request.observationWindow;
  }
  if (!Util.isUnset(request.operationType)) {
    query['OperationType'] = request.operationType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.scaleInStep)) {
    query['ScaleInStep'] = request.scaleInStep;
  }
  if (!Util.isUnset(request.scaleOutStep)) {
    query['ScaleOutStep'] = request.scaleOutStep;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.silenceTime)) {
    query['SilenceTime'] = request.silenceTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.targetMetric)) {
    query['TargetMetric'] = request.targetMetric;
  }
  if (!Util.isUnset(request.targetNodes)) {
    query['TargetNodes'] = request.targetNodes;
  }
  if (!Util.isUnset(request.thresholdLower)) {
    query['ThresholdLower'] = request.thresholdLower;
  }
  if (!Util.isUnset(request.thresholdUpper)) {
    query['ThresholdUpper'] = request.thresholdUpper;
  }
  if (!Util.isUnset(request.triggerCronExpr)) {
    query['TriggerCronExpr'] = request.triggerCronExpr;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAutoScalingRule',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request CreateAutoScalingRuleRequest
 * @return CreateAutoScalingRuleResponse
 */
async function createAutoScalingRule(request: CreateAutoScalingRuleRequest): CreateAutoScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAutoScalingRuleWithOptions(request, runtime);
}

model CreateLdpsComputeGroupRequest {
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  properties?: string(name='Properties'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model CreateLdpsComputeGroupResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  requestId?: string(name='RequestId'),
}

model CreateLdpsComputeGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLdpsComputeGroupResponseBody(name='body'),
}

/**
 * @param request CreateLdpsComputeGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLdpsComputeGroupResponse
 */
async function createLdpsComputeGroupWithOptions(request: CreateLdpsComputeGroupRequest, runtime: Util.RuntimeOptions): CreateLdpsComputeGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.properties)) {
    query['Properties'] = request.properties;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLdpsComputeGroup',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request CreateLdpsComputeGroupRequest
 * @return CreateLdpsComputeGroupResponse
 */
async function createLdpsComputeGroup(request: CreateLdpsComputeGroupRequest): CreateLdpsComputeGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLdpsComputeGroupWithOptions(request, runtime);
}

model CreateLindormInstanceRequest {
  arbiterVSwitchId?: string(name='ArbiterVSwitchId', description='The ID of the vSwitch that is specified for the zone for the coordinate node of the instance. The vSwitch must be deployed in the zone specified by the ArbiterZoneId parameter. **This parameter is required if you want to create a multi-zone instance**.', example='vsw-uf6664pqjawb87k36****'),
  arbiterZoneId?: string(name='ArbiterZoneId', description='The ID of the zone for the coordinate node of the instance. **This parameter is required if you want to create a multi-zone instance**.', example='cn-shanghai-g'),
  archVersion?: string(name='ArchVersion', description='The architecture of the instance. Valid values:

*   **1.0**: The instance that you want to create is a single-zone instance.
*   **2.0**: The instance that you want to create is a multi-zone instance.

By default, the value of this parameter is 1.0. To create a multi-zone instance, set this parameter to 2.0. **This parameter is required if you want to create a multi-zone instance**.', example='2.0'),
  autoRenewDuration?: string(name='AutoRenewDuration', description='The auto-renewal duration. Unit: month.

Valid values: **1** to **12**.

>  This parameter is available only when the **AutoRenewal** parameter is set to **true**.', example='1'),
  autoRenewal?: boolean(name='AutoRenewal', description='Specifies whether to enable auto-renewal for the instance. Valid values:

*   **true**: enables auto-renewal.
*   **false**: disables auto-renewal.

Default value: false.

>  This parameter is available only when the **PayType** parameter is set to **PREPAY**.', example='false'),
  coldStorage?: int32(name='ColdStorage', description='The cold storage capacity of the instance. By default, if you leave this parameter unspecified, cold storage is not enabled for the instance. Unit: GB. Valid values: **800** to **1000000**.', example='800'),
  coreSingleStorage?: int32(name='CoreSingleStorage', description='The storage capacity of the disk of a single core node. Valid values: 400 to 64000. Unit: GB. **This parameter is required if you want to create a multi-zone instance**.', example='400'),
  coreSpec?: string(name='CoreSpec', description='The specification of the nodes in the instance if you set DiskCategory to local_ssd_pro or local_hdd_pro.

When DiskCategory is set to local_ssd_pro, you can set this parameter to the following values:

*   **lindorm.i2.xlarge**: Each node has 4 dedicated CPU cores and 32 GB of dedicated memory.
*   **lindorm.i2.2xlarge**: Each node has 8 dedicated CPU cores and 64 GB of dedicated memory.
*   **lindorm.i2.4xlarge**: Each node has 16 dedicated CPU cores and 128 GB of dedicated memory.
*   **lindorm.i2.8xlarge**: Each node has 32 dedicated CPU cores and 256 GB of dedicated memory.

When DiskCategory is set to local_hdd_pro, you can set this parameter to the following values:

*   **lindorm.d1.2xlarge**: Each node has 8 dedicated CPU cores and 32 GB of dedicated memory.
*   **lindorm.d1.4xlarge**: Each node has 16 dedicated CPU cores and 64 GB of dedicated memory.
*   **lindorm.d1.6xlarge**: Each node has 24 dedicated CPU cores and 96 GB of dedicated memory.', example='lindorm.i2.xlarge'),
  diskCategory?: string(name='DiskCategory', description='The storage type of the instance. Valid values:

*   **cloud_efficiency**: This instance uses the Standard type of storage.
*   **cloud_ssd**: This instance uses the Performance type of storage.
*   **capacity_cloud_storage**: This instance uses the Capacity type of storage.
*   **local_ssd_pro**: This instance uses local SSDs.
*   **local_hdd_pro**: This instance uses local HDDs.

This parameter is required.', example='cloud_efficiency'),
  duration?: string(name='Duration', description='The subscription period of the instance. The valid values of this parameter depend on the value of the PricingCycle parameter.

*   If PricingCycle is set to **Month**, set this parameter to an integer that ranges from **1** to **9**.
*   If PricingCycle is set to **Year**, set this parameter to an integer that ranges from **1** to **3**.

> This parameter is available and required when the PayType parameter is set to **PREPAY**.', example='1'),
  filestoreNum?: int32(name='FilestoreNum', description='The number of LindormDFS nodes in the instance. The valid values of this parameter depend on the value of the PayType parameter.

*   If the PayType parameter is set to **PREPAY**, set this parameter to an integer that ranges from **0** to **60**.
*   If the PayType parameter is set to **POSTPAY**, set this parameter to an integer that ranges from **0** to **8**.', example='2'),
  filestoreSpec?: string(name='FilestoreSpec', description='The specification of LindormDFS nodes in the instance. Set the value of this parameter to **lindorm.c.xlarge**, which indicates that each node has 4 dedicated CPU cores and 8 GB of dedicated memory.', example='lindorm.c.xlarge'),
  instanceAlias?: string(name='InstanceAlias', description='The name of the instance that you want to create.', example='lindorm_test'),
  instanceStorage?: string(name='InstanceStorage', description='The storage capacity of the instance you want to create. Unit: GB.', example='480'),
  lindormNum?: int32(name='LindormNum', description='The number of LindormTable nodes in the instance. The valid values of this parameter depend on the value of the PayType parameter.

*   If the PayType parameter is set to **PREPAY**, set this parameter to an integer that ranges from **0** to **90**.
*   If the PayType parameter is set to **POSTPAY**, set this parameter to an integer that ranges from **0** to **400**.

**This parameter is required if you want to create a multi-zone instance**.  The valid values of this parameter range from 4 to 400 if you want to create a multi-zone instance.', example='2'),
  lindormSpec?: string(name='LindormSpec', description='The specification of LindormTable nodes in the instance. Valid values:

*   **lindorm.c.xlarge**: Each node has 4 dedicated CPU cores and 8 GB of dedicated memory.
*   **lindorm.c.2xlarge**: Each node has 8 dedicated CPU cores and 16 GB of dedicated memory.
*   **lindorm.c.4xlarge**: Each node has 16 dedicated CPU cores and 32 GB of dedicated memory.
*   **lindorm.c.8xlarge**: Each node has 32 dedicated CPU cores and 64 GB of dedicated memory.', example='lindorm.c.xlarge'),
  logDiskCategory?: string(name='LogDiskCategory', description='The disk type of the log nodes. Valid values:

*   **cloud_efficiency**: This instance uses the Standard type of storage.
*   **cloud_ssd**: This instance uses the Performance type of storage.

**This parameter is required if you want to create a multi-zone instance**.', example='cloud_ssd'),
  logNum?: int32(name='LogNum', description='The number of the log nodes. Valid values: 4 to 400. **This parameter is required if you want to create a multi-zone instance**.', example='4'),
  logSingleStorage?: int32(name='LogSingleStorage', description='The storage capacity of the disk of a single log node. Valid values: 400 to 64000. Unit: GB. **This parameter is required if you want to create a multi-zone instance**.', example='400'),
  logSpec?: string(name='LogSpec', description='The type of the log nodes. Valid values:

*   **lindorm.sn1.xlarge**: Each node has 4 dedicated CPU cores and 8 GB of dedicated memory.
*   **lindorm.sn1.2xlarge**: Each node has 8 dedicated CPU cores and 16 GB of dedicated memory.

**This parameter is required if you want to create a multi-zone instance**.', example='lindorm.sn1.large'),
  ltsNum?: string(name='LtsNum', description='The number of LTS nodes in the instance. Valid values: **0** to **60**.', example='2'),
  ltsSpec?: string(name='LtsSpec', description='The specification of LTS nodes in the instance. Valid values:

*   **lindorm.c.xlarge**: Each node has 4 dedicated CPU cores and 8 GB of dedicated memory.
*   **lindorm.g.xlarge**: Each node has 4 dedicated CPU cores and 16 GB of dedicated memory.
*   **lindorm.c.2xlarge**: Each node has 8 dedicated CPU cores and 16 GB of dedicated memory.
*   **lindorm.g.2xlarge**: Each node has 8 dedicated CPU cores and 32 GB of dedicated memory.
*   **lindorm.c.4xlarge**: Each node has 16 dedicated CPU cores and 32 GB of dedicated memory.
*   **lindorm.g.4xlarge**: Each node has 16 dedicated CPU cores and 64 GB of dedicated memory.
*   **lindorm.c.8xlarge**: Each node has 32 dedicated CPU cores and 64 GB of dedicated memory.
*   **lindorm.g.8xlarge**: Each node has 32 dedicated CPU cores and 128 GB of dedicated memory.', example='lindorm.g.xlarge'),
  multiZoneCombination?: string(name='MultiZoneCombination', description='The combinations of zones that are available for the multi-zone instance. You can go to the purchase page of Lindorm to view the supported zone combinations.

*   **ap-southeast-5abc-aliyun**: Zone A+B+C in the Indonesia (Jakarta) region.
*   **cn-hangzhou-ehi-aliyun**: Zone E+H+I in the China (Hangzhou) region.
*   **cn-beijing-acd-aliyun**: Zone A+C+D in the China (Beijing) region.
*   **ap-southeast-1-abc-aliyun**: Zone A+B+C in the Singapore region.
*   **cn-zhangjiakou-abc-aliyun**: Zone A+B+C in the China (Zhangjiakou) region.
*   **cn-shanghai-efg-aliyun**: Zone E+F+G in the China (Shanghai) region.
*   **cn-shanghai-abd-aliyun**: Zone A+B+D in the China (Shanghai) region.
*   **cn-hangzhou-bef-aliyun**: Zone B+E+F in the China (Hangzhou) region.
*   **cn-hangzhou-bce-aliyun**: Zone B+C+E in the China (Hangzhou) region.
*   **cn-beijing-fgh-aliyun**: Zone F+G+H in the China (Beijing) region.
*   **cn-shenzhen-abc-aliyun**: Zone A+B+C in the China (Shenzhen) region.

**This parameter is required if you want to create a multi-zone instance**.', example='cn-shanghai-efg-aliyun'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType', description='The billing method of the instance you want to create. Valid values:

*   **PREPAY**: subscription.
*   **POSTPAY**: pay-as-you-go.

This parameter is required.', example='POSTPAY'),
  pricingCycle?: string(name='PricingCycle', description='The period based on which you are charged for the instance. Valid values:

*   **Month**: You are charged for the instance on a monthly basis.
*   **Year**: You are charged for the instance on a yearly basis.

> This parameter is available and required when the PayType parameter is set to **PREPAY**.', example='Month'),
  primaryVSwitchId?: string(name='PrimaryVSwitchId', description='The ID of the vSwitch that is specified for the secondary zone of the instance. The vSwitch must be deployed in the zone specified by the StandbyZoneId parameter. **This parameter is required if you want to create a multi-zone instance**.', example='vsw-uf6fdqa7c0pipnqzq****'),
  primaryZoneId?: string(name='PrimaryZoneId', description='Multi-zone instance, availability zone ID of the primary zone. **This parameter is required if you need to create a multi-zone instance.**', example='cn-shanghai-e'),
  regionId?: string(name='RegionId', description='The ID of the region in which you want to create the instance. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/426062.html) operation to query the region in which you can create the instance.

This parameter is required.', example='cn-shanghai'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the Lindorm instance belongs.', example='rg-aek2i6weeb4nfii'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  solrNum?: int32(name='SolrNum', description='The number of LindormSearch nodes in the instance. Valid values: integers from **0** to **60**.', example='2'),
  solrSpec?: string(name='SolrSpec', description='The specification of the LindormSearch nodes in the instance. Valid values:

*   **lindorm.g.xlarge**: Each node has 4 dedicated CPU cores and 16 GB of dedicated memory.
*   **lindorm.g.2xlarge**: Each node has 8 dedicated CPU cores and 32 GB of dedicated memory.
*   **lindorm.g.4xlarge**: Each node has 16 dedicated CPU cores and 64 GB of dedicated memory.
*   **lindorm.g.8xlarge**: Each node has 32 dedicated CPU cores and 128 GB of dedicated memory.', example='lindorm.g.xlarge'),
  standbyVSwitchId?: string(name='StandbyVSwitchId', description='The ID of the vSwitch that is specified for the secondary zone of the instance. The vSwitch must be deployed in the zone specified by the StandbyZoneId parameter. **This parameter is required if you want to create a multi-zone instance**.', example='vsw-2zec0kcn08cgdtr6****'),
  standbyZoneId?: string(name='StandbyZoneId', description='The ID of the secondary zone of the instance. **This parameter is required if you want to create a multi-zone instance**.', example='cn-shanghai-f'),
  streamNum?: int32(name='StreamNum', description='The number of LindormStream nodes in the instance. Valid values: integers from **0** to **60**.', example='2'),
  streamSpec?: string(name='StreamSpec', description='The specification of the LindormStream nodes in the instance. Valid values:

*   **lindorm.g.xlarge**: Each node has 4 dedicated CPU cores and 16 GB of dedicated memory.
*   **lindorm.g.2xlarge**: Each node has 8 dedicated CPU cores and 32 GB of dedicated memory.
*   **lindorm.g.4xlarge**: Each node has 16 dedicated CPU cores and 64 GB of dedicated memory.
*   **lindorm.g.8xlarge**: Each node has 32 dedicated CPU cores and 128 GB of dedicated memory.', example='lindorm.g.xlarge'),
  tsdbNum?: int32(name='TsdbNum', description='The number of the LindormTSDB nodes in the instance. The valid values of this parameter depend on the value of the PayType parameter.

*   If the PayType parameter is set to **PREPAY**, set this parameter to an integer that ranges from **0** to **24**.
*   If the PayType parameter is set to **POSTPAY**, set this parameter to an integer that ranges from **0** to **32**.', example='2'),
  tsdbSpec?: string(name='TsdbSpec', description='The specification of the LindormTSDB nodes in the instance. Valid values:

*   **lindorm.g.xlarge**: Each node has 4 dedicated CPU cores and 16 GB of dedicated memory.
*   **lindorm.g.2xlarge**: Each node has 8 dedicated CPU cores and 32 GB of dedicated memory.
*   **lindorm.g.4xlarge**: Each node has 16 dedicated CPU cores and 64 GB of dedicated memory.
*   **lindorm.g.8xlarge**: Each node has 32 dedicated CPU cores and 128 GB of dedicated memory.', example='lindorm.g.xlarge'),
  VPCId?: string(name='VPCId', description='The ID of the VPC in which you want to create the instance.

This parameter is required.', example='vpc-bp1nme44gek34slfc****'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch to which you want the instance to connect.

This parameter is required.', example='vsw-bp1e7clcw529l773d****'),
  zoneId?: string(name='ZoneId', description='The ID of the zone in which you want to create the instance.

This parameter is required.', example='cn-shanghai-f'),
}

model CreateLindormInstanceResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', description='The details about the access denial.', example='{"AuthAction":"xxx","AuthPrincipalDisplayName":"222","AuthPrincipalOwnerId":"111","AuthPrincipalType":"SubUser",,"NoPermissionType":"ImplicitDeny","PolicyType":"AccountLevelIdentityBasedPolicy","EncodedDiagnosticMessage":"xxxxxx"}'),
  instanceId?: string(name='InstanceId', description='The ID of the Lindorm instance that is created.', example='ld-bp1o3y0yme2i2****'),
  orderId?: long(name='OrderId', description='The ID of the order.', example='111111111111111'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='93BE8227-3406-4D7A-883D-9A421D42****'),
}

model CreateLindormInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLindormInstanceResponseBody(name='body'),
}

/**
 * @summary Creates a Lindorm instance.
 *
 * @description You must select at least one engine when you create a Lindorm instance. For more information about how to select the storage type and engine type when you create a Lindorm instance, see [Select engine types](https://help.aliyun.com/document_detail/181971.html) and [Select storage types](https://help.aliyun.com/document_detail/174643.html).
 *
 * @param request CreateLindormInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLindormInstanceResponse
 */
async function createLindormInstanceWithOptions(request: CreateLindormInstanceRequest, runtime: Util.RuntimeOptions): CreateLindormInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.arbiterVSwitchId)) {
    query['ArbiterVSwitchId'] = request.arbiterVSwitchId;
  }
  if (!Util.isUnset(request.arbiterZoneId)) {
    query['ArbiterZoneId'] = request.arbiterZoneId;
  }
  if (!Util.isUnset(request.archVersion)) {
    query['ArchVersion'] = request.archVersion;
  }
  if (!Util.isUnset(request.autoRenewDuration)) {
    query['AutoRenewDuration'] = request.autoRenewDuration;
  }
  if (!Util.isUnset(request.autoRenewal)) {
    query['AutoRenewal'] = request.autoRenewal;
  }
  if (!Util.isUnset(request.coldStorage)) {
    query['ColdStorage'] = request.coldStorage;
  }
  if (!Util.isUnset(request.coreSingleStorage)) {
    query['CoreSingleStorage'] = request.coreSingleStorage;
  }
  if (!Util.isUnset(request.coreSpec)) {
    query['CoreSpec'] = request.coreSpec;
  }
  if (!Util.isUnset(request.diskCategory)) {
    query['DiskCategory'] = request.diskCategory;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.filestoreNum)) {
    query['FilestoreNum'] = request.filestoreNum;
  }
  if (!Util.isUnset(request.filestoreSpec)) {
    query['FilestoreSpec'] = request.filestoreSpec;
  }
  if (!Util.isUnset(request.instanceAlias)) {
    query['InstanceAlias'] = request.instanceAlias;
  }
  if (!Util.isUnset(request.instanceStorage)) {
    query['InstanceStorage'] = request.instanceStorage;
  }
  if (!Util.isUnset(request.lindormNum)) {
    query['LindormNum'] = request.lindormNum;
  }
  if (!Util.isUnset(request.lindormSpec)) {
    query['LindormSpec'] = request.lindormSpec;
  }
  if (!Util.isUnset(request.logDiskCategory)) {
    query['LogDiskCategory'] = request.logDiskCategory;
  }
  if (!Util.isUnset(request.logNum)) {
    query['LogNum'] = request.logNum;
  }
  if (!Util.isUnset(request.logSingleStorage)) {
    query['LogSingleStorage'] = request.logSingleStorage;
  }
  if (!Util.isUnset(request.logSpec)) {
    query['LogSpec'] = request.logSpec;
  }
  if (!Util.isUnset(request.ltsNum)) {
    query['LtsNum'] = request.ltsNum;
  }
  if (!Util.isUnset(request.ltsSpec)) {
    query['LtsSpec'] = request.ltsSpec;
  }
  if (!Util.isUnset(request.multiZoneCombination)) {
    query['MultiZoneCombination'] = request.multiZoneCombination;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.primaryVSwitchId)) {
    query['PrimaryVSwitchId'] = request.primaryVSwitchId;
  }
  if (!Util.isUnset(request.primaryZoneId)) {
    query['PrimaryZoneId'] = request.primaryZoneId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.solrNum)) {
    query['SolrNum'] = request.solrNum;
  }
  if (!Util.isUnset(request.solrSpec)) {
    query['SolrSpec'] = request.solrSpec;
  }
  if (!Util.isUnset(request.standbyVSwitchId)) {
    query['StandbyVSwitchId'] = request.standbyVSwitchId;
  }
  if (!Util.isUnset(request.standbyZoneId)) {
    query['StandbyZoneId'] = request.standbyZoneId;
  }
  if (!Util.isUnset(request.streamNum)) {
    query['StreamNum'] = request.streamNum;
  }
  if (!Util.isUnset(request.streamSpec)) {
    query['StreamSpec'] = request.streamSpec;
  }
  if (!Util.isUnset(request.tsdbNum)) {
    query['TsdbNum'] = request.tsdbNum;
  }
  if (!Util.isUnset(request.tsdbSpec)) {
    query['TsdbSpec'] = request.tsdbSpec;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLindormInstance',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a Lindorm instance.
 *
 * @description You must select at least one engine when you create a Lindorm instance. For more information about how to select the storage type and engine type when you create a Lindorm instance, see [Select engine types](https://help.aliyun.com/document_detail/181971.html) and [Select storage types](https://help.aliyun.com/document_detail/174643.html).
 *
 * @param request CreateLindormInstanceRequest
 * @return CreateLindormInstanceResponse
 */
async function createLindormInstance(request: CreateLindormInstanceRequest): CreateLindormInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLindormInstanceWithOptions(request, runtime);
}

model CreateLindormV2InstanceRequest {
  arbiterVSwitchId?: string(name='ArbiterVSwitchId'),
  arbiterZoneId?: string(name='ArbiterZoneId'),
  archVersion?: string(name='ArchVersion'),
  autoRenewDuration?: string(name='AutoRenewDuration'),
  autoRenewal?: boolean(name='AutoRenewal'),
  capacityStorageSize?: int32(name='CapacityStorageSize'),
  cloudStorageSize?: int32(name='CloudStorageSize'),
  cloudStorageType?: string(name='CloudStorageType'),
  clusterMode?: string(name='ClusterMode'),
  clusterPattern?: string(name='ClusterPattern'),
  duration?: int32(name='Duration'),
  enableCapacityStorage?: boolean(name='EnableCapacityStorage'),
  engineList?: [ 
    {
      engineType?: string(name='EngineType', description='This parameter is required.'),
      nodeGroupList?: [ 
        {
          nodeCount?: int32(name='NodeCount', description='This parameter is required.'),
          nodeDiskSize?: int32(name='NodeDiskSize'),
          nodeDiskType?: string(name='NodeDiskType'),
          nodeSpec?: string(name='NodeSpec', description='This parameter is required.'),
          resourceGroupName?: string(name='ResourceGroupName'),
        }
      ](name='NodeGroupList'),
    }
  ](name='EngineList', description='This parameter is required.'),
  instanceAlias?: string(name='InstanceAlias'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType', description='This parameter is required.'),
  pricingCycle?: string(name='PricingCycle'),
  primaryVSwitchId?: string(name='PrimaryVSwitchId'),
  primaryZoneId?: string(name='PrimaryZoneId'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  standbyVSwitchId?: string(name='StandbyVSwitchId'),
  standbyZoneId?: string(name='StandbyZoneId'),
  VPCId?: string(name='VPCId', description='This parameter is required.'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId', description='This parameter is required.'),
}

model CreateLindormV2InstanceResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  instanceId?: string(name='InstanceId'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateLindormV2InstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLindormV2InstanceResponseBody(name='body'),
}

/**
 * @param request CreateLindormV2InstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLindormV2InstanceResponse
 */
async function createLindormV2InstanceWithOptions(request: CreateLindormV2InstanceRequest, runtime: Util.RuntimeOptions): CreateLindormV2InstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.arbiterVSwitchId)) {
    query['ArbiterVSwitchId'] = request.arbiterVSwitchId;
  }
  if (!Util.isUnset(request.arbiterZoneId)) {
    query['ArbiterZoneId'] = request.arbiterZoneId;
  }
  if (!Util.isUnset(request.archVersion)) {
    query['ArchVersion'] = request.archVersion;
  }
  if (!Util.isUnset(request.autoRenewDuration)) {
    query['AutoRenewDuration'] = request.autoRenewDuration;
  }
  if (!Util.isUnset(request.autoRenewal)) {
    query['AutoRenewal'] = request.autoRenewal;
  }
  if (!Util.isUnset(request.capacityStorageSize)) {
    query['CapacityStorageSize'] = request.capacityStorageSize;
  }
  if (!Util.isUnset(request.cloudStorageSize)) {
    query['CloudStorageSize'] = request.cloudStorageSize;
  }
  if (!Util.isUnset(request.cloudStorageType)) {
    query['CloudStorageType'] = request.cloudStorageType;
  }
  if (!Util.isUnset(request.clusterMode)) {
    query['ClusterMode'] = request.clusterMode;
  }
  if (!Util.isUnset(request.clusterPattern)) {
    query['ClusterPattern'] = request.clusterPattern;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.enableCapacityStorage)) {
    query['EnableCapacityStorage'] = request.enableCapacityStorage;
  }
  if (!Util.isUnset(request.engineList)) {
    query['EngineList'] = request.engineList;
  }
  if (!Util.isUnset(request.instanceAlias)) {
    query['InstanceAlias'] = request.instanceAlias;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.primaryVSwitchId)) {
    query['PrimaryVSwitchId'] = request.primaryVSwitchId;
  }
  if (!Util.isUnset(request.primaryZoneId)) {
    query['PrimaryZoneId'] = request.primaryZoneId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.standbyVSwitchId)) {
    query['StandbyVSwitchId'] = request.standbyVSwitchId;
  }
  if (!Util.isUnset(request.standbyZoneId)) {
    query['StandbyZoneId'] = request.standbyZoneId;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLindormV2Instance',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request CreateLindormV2InstanceRequest
 * @return CreateLindormV2InstanceResponse
 */
async function createLindormV2Instance(request: CreateLindormV2InstanceRequest): CreateLindormV2InstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLindormV2InstanceWithOptions(request, runtime);
}

model DeleteAutoScalingConfigRequest {
  configId?: string(name='ConfigId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteAutoScalingConfigResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteAutoScalingConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAutoScalingConfigResponseBody(name='body'),
}

/**
 * @param request DeleteAutoScalingConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAutoScalingConfigResponse
 */
async function deleteAutoScalingConfigWithOptions(request: DeleteAutoScalingConfigRequest, runtime: Util.RuntimeOptions): DeleteAutoScalingConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAutoScalingConfig',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request DeleteAutoScalingConfigRequest
 * @return DeleteAutoScalingConfigResponse
 */
async function deleteAutoScalingConfig(request: DeleteAutoScalingConfigRequest): DeleteAutoScalingConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAutoScalingConfigWithOptions(request, runtime);
}

model DeleteAutoScalingRuleRequest {
  configId?: string(name='ConfigId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleId?: string(name='RuleId', description='This parameter is required.'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteAutoScalingRuleResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteAutoScalingRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAutoScalingRuleResponseBody(name='body'),
}

/**
 * @param request DeleteAutoScalingRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAutoScalingRuleResponse
 */
async function deleteAutoScalingRuleWithOptions(request: DeleteAutoScalingRuleRequest, runtime: Util.RuntimeOptions): DeleteAutoScalingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAutoScalingRule',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request DeleteAutoScalingRuleRequest
 * @return DeleteAutoScalingRuleResponse
 */
async function deleteAutoScalingRule(request: DeleteAutoScalingRuleRequest): DeleteAutoScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAutoScalingRuleWithOptions(request, runtime);
}

model DeleteCustomResourceRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  name?: string(name='Name', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteCustomResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCustomResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCustomResourceResponseBody(name='body'),
}

/**
 * @param request DeleteCustomResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCustomResourceResponse
 */
async function deleteCustomResourceWithOptions(request: DeleteCustomResourceRequest, runtime: Util.RuntimeOptions): DeleteCustomResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomResource',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request DeleteCustomResourceRequest
 * @return DeleteCustomResourceResponse
 */
async function deleteCustomResource(request: DeleteCustomResourceRequest): DeleteCustomResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomResourceWithOptions(request, runtime);
}

model DeleteLdpsComputeGroupRequest {
  groupName?: string(name='GroupName', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeleteLdpsComputeGroupResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  requestId?: string(name='RequestId'),
}

model DeleteLdpsComputeGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLdpsComputeGroupResponseBody(name='body'),
}

/**
 * @param request DeleteLdpsComputeGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLdpsComputeGroupResponse
 */
async function deleteLdpsComputeGroupWithOptions(request: DeleteLdpsComputeGroupRequest, runtime: Util.RuntimeOptions): DeleteLdpsComputeGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLdpsComputeGroup',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request DeleteLdpsComputeGroupRequest
 * @return DeleteLdpsComputeGroupResponse
 */
async function deleteLdpsComputeGroup(request: DeleteLdpsComputeGroupRequest): DeleteLdpsComputeGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLdpsComputeGroupWithOptions(request, runtime);
}

model DeployLdpsSemiManagedComponentRequest {
  componentName?: string(name='ComponentName'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DeployLdpsSemiManagedComponentResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeployLdpsSemiManagedComponentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeployLdpsSemiManagedComponentResponseBody(name='body'),
}

/**
 * @param request DeployLdpsSemiManagedComponentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeployLdpsSemiManagedComponentResponse
 */
async function deployLdpsSemiManagedComponentWithOptions(request: DeployLdpsSemiManagedComponentRequest, runtime: Util.RuntimeOptions): DeployLdpsSemiManagedComponentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.componentName)) {
    query['ComponentName'] = request.componentName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeployLdpsSemiManagedComponent',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request DeployLdpsSemiManagedComponentRequest
 * @return DeployLdpsSemiManagedComponentResponse
 */
async function deployLdpsSemiManagedComponent(request: DeployLdpsSemiManagedComponentRequest): DeployLdpsSemiManagedComponentResponse {
  var runtime = new Util.RuntimeOptions{};
  return deployLdpsSemiManagedComponentWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', description='The display language of the regions in the returned results. Valid values:

*   **zh-CN** (default): Chinese.
*   **en-US**: English.', example='zh-CN'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName', description='The name of the region.'),
      regionEndpoint?: string(name='RegionEndpoint', description='The endpoint for the region.', example='hitsdb.aliyuncs.com'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='Regions', description='The regions supported by Lindorm.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='73F6E6DA-9AE5-5548-9E07-761A554DAF2E'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @summary Obtains the regions supported by Lindorm.
 *
 * @param request DescribeRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains the regions supported by Lindorm.
 *
 * @param request DescribeRegionsRequest
 * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model GetAutoScalingConfigRequest {
  configId?: string(name='ConfigId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model GetAutoScalingConfigResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: {
    configId?: string(name='ConfigId'),
    configName?: string(name='ConfigName'),
    effectiveTimeEnd?: string(name='EffectiveTimeEnd'),
    effectiveTimeStart?: string(name='EffectiveTimeStart'),
    enabled?: boolean(name='Enabled'),
    engine?: string(name='Engine'),
    instanceId?: string(name='InstanceId'),
    nodesMax?: int32(name='NodesMax'),
    nodesMin?: int32(name='NodesMin'),
    scaleRuleList?: [ 
      {
        configId?: string(name='ConfigId'),
        enabled?: boolean(name='Enabled'),
        endTime?: string(name='EndTime'),
        instanceId?: string(name='InstanceId'),
        observationWindow?: int32(name='ObservationWindow'),
        operationType?: string(name='OperationType'),
        ruleId?: string(name='RuleId'),
        ruleName?: string(name='RuleName'),
        ruleType?: string(name='RuleType'),
        scaleInStep?: int32(name='ScaleInStep'),
        scaleOutStep?: int32(name='ScaleOutStep'),
        silenceTime?: int32(name='SilenceTime'),
        startTime?: string(name='StartTime'),
        targetMetric?: string(name='TargetMetric'),
        targetNodes?: int32(name='TargetNodes'),
        thresholdLower?: int32(name='ThresholdLower'),
        thresholdUpper?: int32(name='ThresholdUpper'),
        triggerCronExpr?: string(name='TriggerCronExpr'),
      }
    ](name='ScaleRuleList'),
    scaleType?: string(name='ScaleType'),
    specId?: string(name='SpecId'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAutoScalingConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAutoScalingConfigResponseBody(name='body'),
}

/**
 * @param request GetAutoScalingConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAutoScalingConfigResponse
 */
async function getAutoScalingConfigWithOptions(request: GetAutoScalingConfigRequest, runtime: Util.RuntimeOptions): GetAutoScalingConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAutoScalingConfig',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetAutoScalingConfigRequest
 * @return GetAutoScalingConfigResponse
 */
async function getAutoScalingConfig(request: GetAutoScalingConfigRequest): GetAutoScalingConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAutoScalingConfigWithOptions(request, runtime);
}

model GetAutoScalingRuleRequest {
  configId?: string(name='ConfigId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleId?: string(name='RuleId', description='This parameter is required.'),
  securityToken?: string(name='SecurityToken'),
}

model GetAutoScalingRuleResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: {
    configId?: string(name='ConfigId'),
    enabled?: boolean(name='Enabled'),
    endTime?: string(name='EndTime'),
    instanceId?: string(name='InstanceId'),
    observationWindow?: int32(name='ObservationWindow'),
    operationType?: string(name='OperationType'),
    ruleId?: string(name='RuleId'),
    ruleName?: string(name='RuleName'),
    ruleType?: string(name='RuleType'),
    scaleInStep?: int32(name='ScaleInStep'),
    scaleOutStep?: int32(name='ScaleOutStep'),
    silenceTime?: int32(name='SilenceTime'),
    startTime?: string(name='StartTime'),
    targetMetric?: string(name='TargetMetric'),
    targetNodes?: int32(name='TargetNodes'),
    thresholdLower?: int32(name='ThresholdLower'),
    thresholdUpper?: int32(name='ThresholdUpper'),
    triggerCronExpr?: string(name='TriggerCronExpr'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAutoScalingRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAutoScalingRuleResponseBody(name='body'),
}

/**
 * @param request GetAutoScalingRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAutoScalingRuleResponse
 */
async function getAutoScalingRuleWithOptions(request: GetAutoScalingRuleRequest, runtime: Util.RuntimeOptions): GetAutoScalingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAutoScalingRule',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetAutoScalingRuleRequest
 * @return GetAutoScalingRuleResponse
 */
async function getAutoScalingRule(request: GetAutoScalingRuleRequest): GetAutoScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAutoScalingRuleWithOptions(request, runtime);
}

model GetClientSourceIpRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model GetClientSourceIpResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  clientIp?: string(name='ClientIp'),
  requestId?: string(name='RequestId'),
}

model GetClientSourceIpResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClientSourceIpResponseBody(name='body'),
}

/**
 * @param request GetClientSourceIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClientSourceIpResponse
 */
async function getClientSourceIpWithOptions(request: GetClientSourceIpRequest, runtime: Util.RuntimeOptions): GetClientSourceIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetClientSourceIp',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetClientSourceIpRequest
 * @return GetClientSourceIpResponse
 */
async function getClientSourceIp(request: GetClientSourceIpRequest): GetClientSourceIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClientSourceIpWithOptions(request, runtime);
}

model GetEngineDefaultAuthRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model GetEngineDefaultAuthResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  authInfos?: [ 
    {
      engine?: string(name='Engine'),
      password?: string(name='Password'),
      username?: string(name='Username'),
    }
  ](name='AuthInfos'),
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
}

model GetEngineDefaultAuthResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEngineDefaultAuthResponseBody(name='body'),
}

/**
 * @param request GetEngineDefaultAuthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEngineDefaultAuthResponse
 */
async function getEngineDefaultAuthWithOptions(request: GetEngineDefaultAuthRequest, runtime: Util.RuntimeOptions): GetEngineDefaultAuthResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEngineDefaultAuth',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetEngineDefaultAuthRequest
 * @return GetEngineDefaultAuthResponse
 */
async function getEngineDefaultAuth(request: GetEngineDefaultAuthRequest): GetEngineDefaultAuthResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEngineDefaultAuthWithOptions(request, runtime);
}

model GetInstanceIpWhiteListRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance whose whitelists you want to query. You can call the [GetLindormInstanceList](https://help.aliyun.com/document_detail/426068.html) operation to obtain the instance ID.

This parameter is required.', example='ld-bp1z3506imz2f****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model GetInstanceIpWhiteListResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', description='The details about the access denial.', example='{"AuthAction":"xxx","AuthPrincipalDisplayName":"222","AuthPrincipalOwnerId":"111","AuthPrincipalType":"SubUser",,"NoPermissionType":"ImplicitDeny","PolicyType":"AccountLevelIdentityBasedPolicy","EncodedDiagnosticMessage":"xxxxxx"}'),
  groupList?: [ 
    {
      groupName?: string(name='GroupName', description='The name of the IP address whitelist.', example='test'),
      securityIpList?: string(name='SecurityIpList', description='The IP addresses in the whitelist.', example='192.168.1.0/24'),
    }
  ](name='GroupList', description='The details about the IP address whitelists.'),
  instanceId?: string(name='InstanceId', description='The ID of the Lindorm instance.', example='ld-bp1z3506imz2f****'),
  ipList?: [ string ](name='IpList', description='The list of IP addresses in the whitelist of the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1D1F6F4D-9203-53E7-84E9-5376B4657E63'),
}

model GetInstanceIpWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInstanceIpWhiteListResponseBody(name='body'),
}

/**
 * @summary Queries the whitelists configured for a Lindorm instance.
 *
 * @param request GetInstanceIpWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceIpWhiteListResponse
 */
async function getInstanceIpWhiteListWithOptions(request: GetInstanceIpWhiteListRequest, runtime: Util.RuntimeOptions): GetInstanceIpWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceIpWhiteList',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the whitelists configured for a Lindorm instance.
 *
 * @param request GetInstanceIpWhiteListRequest
 * @return GetInstanceIpWhiteListResponse
 */
async function getInstanceIpWhiteList(request: GetInstanceIpWhiteListRequest): GetInstanceIpWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceIpWhiteListWithOptions(request, runtime);
}

model GetInstanceSecurityGroupsRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model GetInstanceSecurityGroupsResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
  securityGroups?: [ string ](name='SecurityGroups'),
}

model GetInstanceSecurityGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetInstanceSecurityGroupsResponseBody(name='body'),
}

/**
 * @param request GetInstanceSecurityGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceSecurityGroupsResponse
 */
async function getInstanceSecurityGroupsWithOptions(request: GetInstanceSecurityGroupsRequest, runtime: Util.RuntimeOptions): GetInstanceSecurityGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceSecurityGroups',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetInstanceSecurityGroupsRequest
 * @return GetInstanceSecurityGroupsResponse
 */
async function getInstanceSecurityGroups(request: GetInstanceSecurityGroupsRequest): GetInstanceSecurityGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceSecurityGroupsWithOptions(request, runtime);
}

model GetLdpsComputeGroupRequest {
  groupName?: string(name='GroupName'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model GetLdpsComputeGroupResponseBody = {
  groupName?: string(name='GroupName'),
  properties?: map[string]any(name='Properties'),
  requestId?: string(name='RequestId'),
}

model GetLdpsComputeGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLdpsComputeGroupResponseBody(name='body'),
}

/**
 * @param request GetLdpsComputeGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLdpsComputeGroupResponse
 */
async function getLdpsComputeGroupWithOptions(request: GetLdpsComputeGroupRequest, runtime: Util.RuntimeOptions): GetLdpsComputeGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLdpsComputeGroup',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetLdpsComputeGroupRequest
 * @return GetLdpsComputeGroupResponse
 */
async function getLdpsComputeGroup(request: GetLdpsComputeGroupRequest): GetLdpsComputeGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLdpsComputeGroupWithOptions(request, runtime);
}

model GetLdpsNamespacedQuotaRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  namespace?: string(name='Namespace'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model GetLdpsNamespacedQuotaResponseBody = {
  namespacedQuotas?: [ 
    {
      cpuAmount?: string(name='CpuAmount'),
      memoryAmount?: string(name='MemoryAmount'),
      name?: string(name='Name'),
      usedCpu?: string(name='UsedCpu'),
      usedMemory?: string(name='UsedMemory'),
    }
  ](name='NamespacedQuotas'),
  requestId?: string(name='RequestId'),
}

model GetLdpsNamespacedQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLdpsNamespacedQuotaResponseBody(name='body'),
}

/**
 * @param request GetLdpsNamespacedQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLdpsNamespacedQuotaResponse
 */
async function getLdpsNamespacedQuotaWithOptions(request: GetLdpsNamespacedQuotaRequest, runtime: Util.RuntimeOptions): GetLdpsNamespacedQuotaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLdpsNamespacedQuota',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetLdpsNamespacedQuotaRequest
 * @return GetLdpsNamespacedQuotaResponse
 */
async function getLdpsNamespacedQuota(request: GetLdpsNamespacedQuotaRequest): GetLdpsNamespacedQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLdpsNamespacedQuotaWithOptions(request, runtime);
}

model GetLdpsResourceCostRequest {
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  jobId?: string(name='JobId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  startTime?: long(name='StartTime'),
}

model GetLdpsResourceCostResponseBody = {
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
  startTime?: long(name='StartTime'),
  totalResource?: long(name='TotalResource'),
}

model GetLdpsResourceCostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLdpsResourceCostResponseBody(name='body'),
}

/**
 * @param request GetLdpsResourceCostRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLdpsResourceCostResponse
 */
async function getLdpsResourceCostWithOptions(request: GetLdpsResourceCostRequest, runtime: Util.RuntimeOptions): GetLdpsResourceCostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLdpsResourceCost',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetLdpsResourceCostRequest
 * @return GetLdpsResourceCostResponse
 */
async function getLdpsResourceCost(request: GetLdpsResourceCostRequest): GetLdpsResourceCostResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLdpsResourceCostWithOptions(request, runtime);
}

model GetLindormFsUsedDetailRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='ld-xxxx'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model GetLindormFsUsedDetailResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', example='{}'),
  fsCapacity?: string(name='FsCapacity', example='85899345920'),
  fsCapacityCold?: string(name='FsCapacityCold', example='85899345920'),
  fsCapacityHot?: string(name='FsCapacityHot', example='85899345920'),
  fsUsedCold?: string(name='FsUsedCold', example='33269'),
  fsUsedColdOnLindormSearch?: string(name='FsUsedColdOnLindormSearch', example='33269'),
  fsUsedColdOnLindormTSDB?: string(name='FsUsedColdOnLindormTSDB', example='33269'),
  fsUsedColdOnLindormTable?: string(name='FsUsedColdOnLindormTable', example='33269'),
  fsUsedHot?: string(name='FsUsedHot', example='33269'),
  fsUsedHotOnLindormSearch?: string(name='FsUsedHotOnLindormSearch', example='33269'),
  fsUsedHotOnLindormTSDB?: string(name='FsUsedHotOnLindormTSDB', example='33269'),
  fsUsedHotOnLindormTable?: string(name='FsUsedHotOnLindormTable', example='33269'),
  fsUsedOnLindormSearch?: string(name='FsUsedOnLindormSearch', example='33269'),
  fsUsedOnLindormTSDB?: string(name='FsUsedOnLindormTSDB', example='33269'),
  fsUsedOnLindormTable?: string(name='FsUsedOnLindormTable', example='33269'),
  fsUsedOnLindormTableData?: string(name='FsUsedOnLindormTableData', example='33269'),
  fsUsedOnLindormTableWAL?: string(name='FsUsedOnLindormTableWAL', example='33269'),
  LStorageUsageList?: [ 
    {
      capacity?: string(name='Capacity', example='85899345920'),
      diskType?: string(name='DiskType', example='StandardCloudStorage'),
      used?: string(name='Used', example='33269'),
      usedLindormSearch?: string(name='UsedLindormSearch', example='33269'),
      usedLindormSpark?: string(name='UsedLindormSpark', example='33269'),
      usedLindormTable?: string(name='UsedLindormTable', example='33269'),
      usedLindormTsdb?: string(name='UsedLindormTsdb', example='33269'),
      usedOther?: string(name='UsedOther', example='33269'),
    }
  ](name='LStorageUsageList'),
  requestId?: string(name='RequestId', example='4F23D50C-400C-592C-9486-9D1E10179065'),
  valid?: string(name='Valid', example='true'),
}

model GetLindormFsUsedDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLindormFsUsedDetailResponseBody(name='body'),
}

/**
 * @param request GetLindormFsUsedDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLindormFsUsedDetailResponse
 */
async function getLindormFsUsedDetailWithOptions(request: GetLindormFsUsedDetailRequest, runtime: Util.RuntimeOptions): GetLindormFsUsedDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLindormFsUsedDetail',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetLindormFsUsedDetailRequest
 * @return GetLindormFsUsedDetailResponse
 */
async function getLindormFsUsedDetail(request: GetLindormFsUsedDetailRequest): GetLindormFsUsedDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLindormFsUsedDetailWithOptions(request, runtime);
}

model GetLindormInstanceRequest {
  instanceId?: string(name='InstanceId', description='The disk type of the log nodes. This parameter is returned only for multi-zone instances. Valid values:

*   **cloud_efficiency**: The nodes use the Standard type of storage.
*   **cloud_ssd**: The nodes use the Performance type of storage.

This parameter is required.', example='ld-bp1o3y0yme2i2****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model GetLindormInstanceResponseBody = {
  aliUid?: long(name='AliUid', description='16-digit AliUid of the Alibaba Cloud primary account (main account).', example='164901546557****'),
  arbiterVSwitchId?: string(name='ArbiterVSwitchId', description='Multi-AZ instance, coordinating Availability Zone virtual switch ID, which must be located in the Availability Zone corresponding to ArbiterZoneId.', example='vsw-uf6664pqjawb87k36****'),
  arbiterZoneId?: string(name='ArbiterZoneId', description='Multi-zone instance, coordinating Availability Zone ID.', example='cn-shanghai-g'),
  archVersion?: string(name='ArchVersion', description='The architecture of the instance. Valid values:

*   **1.0**: The instance is deployed in a single zone.
*   **2.0**: The instance is deployed across multiple zones.', example='1.0'),
  archiveStorage?: int32(name='ArchiveStorage', description='The Archive storage size of the instance.', example='0GB'),
  autoRenew?: boolean(name='AutoRenew', description='Indicates whether auto-renewal is enabled, with the following returns:
- **true**: Enabled. - **false**: Disabled.
> This parameter is returned when the instance\\\\"s payment type is prepaid.', example='false'),
  coldStorage?: int32(name='ColdStorage', description='The Capacity storage size of the instance.', example='0GB'),
  coreDiskCategory?: string(name='CoreDiskCategory', description='The disk type of the core nodes. This parameter is returned only for multi-zone instances. Valid values:

*   **cloud_efficiency**: This instance uses the Standard type of storage.
*   **cloud_ssd**: This instance uses the Performance type of storage.
*   **cloud_essd**: This instance uses ESSDs for storage.
*   **cloud_essd_pl0**: This instance uses PL0 ESSDs for storage.', example='cloud_efficiency'),
  coreNum?: int32(name='CoreNum', description='Multi-zone instance, number of core nodes.', example='4'),
  coreSingleStorage?: int32(name='CoreSingleStorage', description='Multi-zone instance, core single-node disk capacity.', example='400'),
  coreSpec?: string(name='CoreSpec', description='Multi-zone instance, core node specification.', example='lindorm.g.xlarge'),
  createMilliseconds?: long(name='CreateMilliseconds', description='The timestamp in milliseconds between the instance creation time and 1970-01-01 00:00:00.', example='1627290664000'),
  createTime?: string(name='CreateTime', description='The storage capacity of the disk of a single log node. This parameter is returned only for multi-zone instances.', example='2021-07-26 17:10:26'),
  deletionProtection?: string(name='DeletionProtection', description='Indicates whether deletion protection is enabled, returning:
- **true**: Enabled. - **false**: Disabled.', example='false'),
  diskCategory?: string(name='DiskCategory', description='The storage type of the instance. Valid values:

*   **cloud_efficiency**: This instance uses the Standard type of storage.
*   **cloud_ssd**: This instance uses the Performance type of storage.
*   **cloud_essd**: This instance uses ESSDs for storage.
*   **cloud_essd_pl0**: This instance uses PL0 ESSDs for storage.
*   **capacity_cloud_storage**: This instance uses the Capacity type of storage.
*   **local_ssd_pro**: This instance uses local SSDs for storage.
*   **local_hdd_pro**: This instance uses local HDDs for storage.', example='cloud_efficiency'),
  diskThreshold?: string(name='DiskThreshold', description='The threshold for disk space.', example='80%'),
  diskUsage?: string(name='DiskUsage', description='Disk space usage rate.', example='0.0%'),
  enableBlob?: boolean(name='EnableBlob', description='Indicates whether LBlob is enabled for the instance. Valid values:

true: LBlob is enabled for the instance. false: LBlob is not enabled for the instance.', example='true'),
  enableCdc?: boolean(name='EnableCdc', description='Indicates whether the data subscription feature for the instance is enabled. Returns:
- **true**: Enabled. - **false**: Not enabled.', example='false'),
  enableCompute?: boolean(name='EnableCompute', description='Indicates whether the instance\\\\"s compute engine is enabled, returning:
- **true**: Enabled. - **false**: Not enabled.', example='true'),
  enableKms?: boolean(name='EnableKms', description='Indicates whether the Key Management Service (KMS) is enabled, returning:
- **true**: Enabled. - **false**: Disabled.', example='false'),
  enableLProxy?: boolean(name='EnableLProxy', description='Indicates whether the wide-table engine supports Thrift and CQL protocols. If not supported, the SwitchLProxyService interface can be used to enable or disable.
True indicates support
False indicates no support', example='False'),
  enableLTS?: boolean(name='EnableLTS', description='Indicates whether the LTS engine is activated for the instance. Valid values:

*   **true**: The LTS engine is activated for the instance.
*   **false**: The LTS engine is not activated for the instance.', example='true'),
  enableLsqlVersionV3?: boolean(name='EnableLsqlVersionV3', description='Indicates whether LindormTable of the instance supports LindormSQL V3 that is compatible with MySQL. By default, LindormTable of instances that are purchased after October 24, 2023 supports LindormSQL V3. If your instance is purchased before this date and want to enable LindormSQL V3, contact the technical support.

*   True: LindormTable supports LindormSQL V3.
*   False: LindormTable does not support LindormSQL V3.', example='True'),
  enableMLCtrl?: boolean(name='EnableMLCtrl', description='Indicates whether AI control nodes are enabled for the instance.

*   True: AI control nodes are enabled for the instance.
*   False: AI control nodes are not enabled for the instance.', example='False'),
  enableSSL?: boolean(name='EnableSSL', description='Indicates whether SSL link encryption is enabled, returning:
- **true**: Enabled. - **false**: Disabled.', example='false'),
  enableShs?: boolean(name='EnableShs', description='Whether to enable the Compute Engine History Server.', example='true'),
  enableStoreTDE?: boolean(name='EnableStoreTDE', description='Indicates whether the Transparent Data Encryption (TDE) is enabled, returning:
- **true**: Enabled. - **false**: Disabled.', example='false'),
  enableStream?: boolean(name='EnableStream', description='Indicates whether the instance has the stream engine enabled. Return values:
- **true**: Stream engine is enabled. - **false**: Stream engine is not enabled.', example='true'),
  engineList?: [ 
    {
      coreCount?: string(name='CoreCount', description='The number of engine nodes.', example='2'),
      cpuCount?: string(name='CpuCount', description='The number of CPU cores on the engine node.', example='4'),
      engine?: string(name='Engine', description='The engine type. Valid values:

*   **lindorm**: LindormTable.
*   **tsdb**: LindormTSDB.
*   **solr**: LindormSearch.
*   **store**: LindormDFS.
*   **bds**: Lindorm Tunnel Service (LTS).
*   **compute**: Lindorm Distributed Processing System (LDPS).', example='lindorm'),
      isLastVersion?: boolean(name='IsLastVersion', description='Indicates whether the version of the engine is the latest. Valid values:

*   **true**: The version of the engine is the latest.
*   **false**: The version of the engine is not the latest.', example='false'),
      latestVersion?: string(name='LatestVersion', description='The latest version number of the engine.', example='2.2.19.2'),
      memorySize?: string(name='MemorySize', description='The memory size of the engine nodes.', example='8GB'),
      specification?: string(name='Specification'),
      version?: string(name='Version', description='The version of the engine.', example='2.2.3'),
    }
  ](name='EngineList', description='The latest version number of the engine.'),
  engineType?: int32(name='EngineType', description='Supported engine types, the return value is obtained by performing addition operations on the values of the following engine types.
- 1: Search Engine - 2: Time Series Engine - 4: Wide Table Engine - 8: File Engine
> For example: If EngineType is 15, where 15 = 8 + 4 + 2 + 1, it indicates that the instance supports Search Engine, Time Series Engine, Wide Table Engine, and File Engine. If EngineType is 6, where 6 = 4 + 2, it signifies that the instance supports Time Series Engine and Wide Table Engine.', example='15'),
  expireTime?: string(name='ExpireTime', description='Expiration time of the instance, format: **yyyy-MM-dd HH:mm:ss**.
> This parameter is only returned when the payment type is pre-paid.', example='2021-08-27 00:00:00'),
  expiredMilliseconds?: long(name='ExpiredMilliseconds', description='The millisecond value between the instance expiration time and 1970-01-01 00:00:00.', example='1629993600000'),
  instanceAlias?: string(name='InstanceAlias', description='Instance name.', example='test0726'),
  instanceId?: string(name='InstanceId', description='Instance ID.', example='ld-bp1o3y0yme2i2****'),
  instanceStatus?: string(name='InstanceStatus', description='The status of the instance. Valid values:

*   **CREATING**: The instance is being created.
*   **ACTIVATION**: The instance is running.
*   **COLD_EXPANDING**: The Capacity storage of the instance is being scaled up.
*   **MINOR_VERSION_TRANSING**: The minor version of the instance is being updated.
*   **RESIZING**: The nodes in the instance are being scaled up.
*   **SHRINKING**: The nodes in the instance are being scaled down.
*   **CLASS_CHANGING**: The specification of the instance is being changed.
*   **SSL_SWITCHING: SSL**: The SSL configurations of the instance are being changed.
*   **CDC_OPENING**: Data subscription is being enabled for the instance.
*   **TRANSFER**: The data of the instance is being transferred.
*   **DATABASE_TRANSFER**: The data of the instance is being transferred to databases.
*   **GUARD_CREATING**: A disaster recovery instance is being created.
*   **BACKUP_RECOVERING**: The data of the instance is being restored from a backup.
*   **DATABASE_IMPORTING**: Data is being imported to the instance.
*   **NET_MODIFYING**: The network configurations of the instance are being changed.
*   **NET_SWITCHING**: The network of the instance is being switched between a virtual private cloud (VPC) and the Internet.
*   **NET_CREATING**: The connection to the instance is being created.
*   **NET_DELETING**: The connection to the instance is being deleted.
*   **DELETING**: The instance is being deleted.
*   **RESTARTING**: The instance is restarting.
*   **LOCKED**: The instance is locked because it expires.', example='ACTIVATION'),
  instanceStorage?: string(name='InstanceStorage', description='Instance\\\\"s storage capacity.', example='480'),
  logDiskCategory?: string(name='LogDiskCategory', description='Multi-zone instance, log node disk type, returns:
- **cloud_efficiency**Standard cloud storage. - **cloud_ssd**Performance cloud storage.', example='cloud_ssd'),
  logNum?: int32(name='LogNum', description='Multi-zone instance, number of log nodes.', example='4'),
  logSingleStorage?: int32(name='LogSingleStorage', description='The storage capacity of the disk of a single log node. This parameter is returned only for multi-zone instances.', example='400GB'),
  logSpec?: string(name='LogSpec', description='Multi-zone instance, log node specification.', example='lindorm.sn1.large'),
  maintainEndTime?: string(name='MaintainEndTime', description='Maintainable end time.', example='20:00Z'),
  maintainStartTime?: string(name='MaintainStartTime', description='Maintainable start time.', example='00:00Z'),
  multiZoneCombination?: string(name='MultiZoneCombination', description='Multi-zone combinations. For support details on zone combinations, please refer to the product page.
- **ap-southeast-5abc-aliyun**: Indonesia (Jakarta) A+B+C. - **cn-hangzhou-ehi-aliyun**: East China 1 (Hangzhou) E+H+I. - **cn-beijing-acd-aliyun**: North China 2 (Beijing) A+C+D. - **ap-southeast-1-abc-aliyun**: Singapore A+B+C. - **cn-zhangjiakou-abc-aliyun**: North China 3 (Zhangjiakou) A+B+C. - **cn-shanghai-efg-aliyun**: East China 2 (Shanghai) E+F+G. - **cn-shanghai-abd-aliyun**: East China 2 (Shanghai) A+B+D. - **cn-hangzhou-bef-aliyun**: East China 1 (Hangzhou) B+E+F. - **cn-hangzhou-bce-aliyun**: East China 1 (Hangzhou) B+C+E. - **cn-beijing-fgh-aliyun**: North China 2 (Beijing) F+G+H. - **cn-shenzhen-abc-aliyun**: South China 1 (Shenzhen) A+B+C.', example='cn-shanghai-efg-aliyun'),
  networkType?: string(name='NetworkType', description='Instance\\\\"s network type.', example='vpc'),
  payType?: string(name='PayType', description='400', example='POSTPAY'),
  primaryVSwitchId?: string(name='PrimaryVSwitchId', description='Multi-zone instance, the virtual switch ID of the primary availability zone, which must be in the availability zone corresponding to PrimaryZoneId.', example='vsw-uf6fdqa7c0pipnqzq****'),
  primaryZoneId?: string(name='PrimaryZoneId', description='Multi-zone instance, availability zone ID of the primary zone.', example='cn-shanghai-e'),
  regionId?: string(name='RegionId', description='Region ID.', example='cn-hangzhou'),
  requestId?: string(name='RequestId', description='Request ID.', example='633F1BE4-C8DA-5744-8FDF-A3075C3FE37F'),
  resourceGroupId?: string(name='ResourceGroupId', description='Resource group ID.', example='rg-aek2wvd6oia****'),
  serviceType?: string(name='ServiceType', description='Instance type, valid values:
- **lindorm**represents a Lindorm single-zone instance. - **lindorm_multizone**represents a Lindorm multi-zone instance. - **serverless_lindorm**represents a Lindorm Serverless instance. - **lindorm_standalone**represents a Lindorm standalone instance. - **lts**represents the Lindorm Data Channel Service type.', example='lindorm'),
  standbyVSwitchId?: string(name='StandbyVSwitchId', description='Multi-zone instance, the virtual switch ID of the backup availability zone, which must be in the availability zone corresponding to StandbyZoneId.', example='vsw-2zec0kcn08cgdtr6****'),
  standbyZoneId?: string(name='StandbyZoneId', description='Multi-zone instance, backup availability zone\\\\"s availability zone ID.', example='cn-shanghai-f'),
  vpcId?: string(name='VpcId', description='The type of the log nodes. This parameter is returned only for multi-zone instances.', example='vpc-bp1n3i15v90el48nx****'),
  vswitchId?: string(name='VswitchId', description='The number of the log nodes. This parameter is returned only for multi-zone instances.', example='vsw-bp1vbjzmod9q3l9eo****'),
  zoneId?: string(name='ZoneId', description='Availability Zone ID.', example='cn-hangzhou-h'),
}

model GetLindormInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLindormInstanceResponseBody(name='body'),
}

/**
 * @summary Obtains the detailed information about a Lindorm instance, including the instance type, billing method, and VPC.
 *
 * @param request GetLindormInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLindormInstanceResponse
 */
async function getLindormInstanceWithOptions(request: GetLindormInstanceRequest, runtime: Util.RuntimeOptions): GetLindormInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLindormInstance',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains the detailed information about a Lindorm instance, including the instance type, billing method, and VPC.
 *
 * @param request GetLindormInstanceRequest
 * @return GetLindormInstanceResponse
 */
async function getLindormInstance(request: GetLindormInstanceRequest): GetLindormInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLindormInstanceWithOptions(request, runtime);
}

model GetLindormInstanceEngineListRequest {
  instanceId?: string(name='InstanceId', description='Instance ID, which can be obtained by calling the [GetLindormInstanceList](https://help.aliyun.com/document_detail/426069.html) interface.

This parameter is required.', example='ld-bp1nq34mv3smk****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='Region ID.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model GetLindormInstanceEngineListResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', description='The details about the access denial.', example='{"AuthAction":"xxx","AuthPrincipalDisplayName":"222","AuthPrincipalOwnerId":"111","AuthPrincipalType":"SubUser",,"NoPermissionType":"ImplicitDeny","PolicyType":"AccountLevelIdentityBasedPolicy","EncodedDiagnosticMessage":"xxxxxx"}'),
  engineList?: [ 
    {
      engineType?: string(name='EngineType', description='The type of engine that can run on the instance. Valid values:

*   **lindorm**: LindormTable.
*   **tsdb**: LindormTSDB.
*   **solr**: LindormSearch.
*   **store**: LindormDFS.', example='lindorm'),
      netInfoList?: [ 
        {
          accessType?: int32(name='AccessType', description='The method by which the connection information can be used to access LindormTable. Valid values:

*   **0**: The default value. This value can be ignored.
*   **1**: The connection information can be used to access LindormTable by using ApsaraDB for HBase API for Java.
*   **2**: The connection information can be used to access LindormTable by using ApsaraDB for HBase API for a non-Java language.
*   **3**: The connection information can be used to access LindormTable by using the LindormTable endpoint for CQL.
*   **4**: The connection information can be used to access LindormTable by using the LindormTable endpoint for SQL.
*   **5**: The connection information can be used to access Lindorm by using the LindormTable endpoint for Amazon S3.
*   **6**: The connection information can be used to access Lindorm by using the LindormTable endpoint for MySQL.', example='1'),
          connectionString?: string(name='ConnectionString', description='The endpoint that is used to connect to the engine.', example='ld-bp1nq34mv3smk****-proxy-lindorm.lindorm.rds.aliyuncs.com'),
          netType?: string(name='NetType', description='The network type of the endpoint. Valid values:

*   **0**: Internet
*   **2**: virtual private cloud (VPC)', example='2'),
          port?: int32(name='Port', description='The port number used to connect to the engine.', example='30020'),
        }
      ](name='NetInfoList', description='The list of connection information about the engine.'),
    }
  ](name='EngineList', description='The list of engines that can run on the specified instance.'),
  instanceId?: string(name='InstanceId', description='Instance ID.', example='ld-bp1nq34mv3smk****'),
  requestId?: string(name='RequestId', description='Request ID.', example='B496BA0E-520C-59FC-BA04-196D8F3B07EF'),
}

model GetLindormInstanceEngineListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLindormInstanceEngineListResponseBody(name='body'),
}

/**
 * @summary Obtains the engine types supported by the specified Lindorm instance.
 *
 * @param request GetLindormInstanceEngineListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLindormInstanceEngineListResponse
 */
async function getLindormInstanceEngineListWithOptions(request: GetLindormInstanceEngineListRequest, runtime: Util.RuntimeOptions): GetLindormInstanceEngineListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLindormInstanceEngineList',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Obtains the engine types supported by the specified Lindorm instance.
 *
 * @param request GetLindormInstanceEngineListRequest
 * @return GetLindormInstanceEngineListResponse
 */
async function getLindormInstanceEngineList(request: GetLindormInstanceEngineListRequest): GetLindormInstanceEngineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLindormInstanceEngineListWithOptions(request, runtime);
}

model GetLindormInstanceListRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of the pages to return,', example='1'),
  pageSize?: int32(name='PageSize', description='The number of instances to return on each page.', example='20'),
  queryStr?: string(name='QueryStr', description='The keyword contained in the names of Lindorm instances you want to query. Fuzzy queries based on the keyword is supported.', example='test'),
  regionId?: string(name='RegionId', description='The ID of the region in which the instances that you want to query is located. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/426062.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-aek3b63arvg27vi'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  serviceType?: string(name='ServiceType', description='The series of instances that you want to query. Valid values:

*   **lindorm**: The instance is a single-zone Lindorm instance.
*   **lindorm_multizone**: The instance is a multi-zone Lindorm instance.
*   **serverless_lindorm**: The instance is a Lindorm Serverless instance.
*   **lindorm_standalone**: The instance is a single-node Lindorm instance.
*   **lts**: The instance is an LTS instance.', example='lindorm'),
  supportEngine?: int32(name='SupportEngine', description='The engine supported by the instances that you want to query. The engines are indicated by different numbers:

*   **1**: LindormSearch.
*   **2**: LindormTSDB.
*   **4**: LindormTable.
*   **8**: LindormDFS.

> The value of this parameter is the sum of all numbers that indicate the engines supported by the instance. For example, if you set the value of this parameter to 15, which is the sum of 1, 2, 4, and 8, this operation queries instances that support all four engines. If you set the value of this parameter to 6, which is the sum of 2 and 4, this operation queries instances that support LindormTSDB and LindormTable.', example='15'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of tag N of the instances you want to query. You can specify 1 to 20 tag keys.

> You can specify the keys of multiple tags. For example, you can specify the key of the first tag in the first key-value pair contained in the value of this parameter and specify the key of the second tag in the second key-value pair.', example='test'),
      value?: string(name='Value', description='The value of tag N of the instances you want to query. You can specify 1 to 20 tag values.

> You can specify the values of multiple tags. For example, you can specify the value of the first tag in the first key-value pair contained in the value of this parameter and specify the value of the second tag in the second key-value pair.', example='2.2.18'),
    }
  ](name='Tag', description='The list of tags associated with the specified instances.'),
}

model GetLindormInstanceListResponseBody = {
  instanceList?: [ 
    {
      aliUid?: long(name='AliUid', description='The 16-digit AliUid of the Alibaba Cloud account that owns the instance.', example='164901546557****'),
      createMilliseconds?: long(name='CreateMilliseconds', description='The time when the instance is created. This value is a UNIX timestamp that indicates the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1631772842000'),
      createTime?: string(name='CreateTime', description='The time when the instance is created.', example='2021-09-16 14:13:13'),
      enableColumn?: boolean(name='EnableColumn', description='Indicates whether the column storage engine is enabled, returning:
- **true**: Enabled. - **false**: Not enabled.', example='true'),
      enableCompute?: boolean(name='EnableCompute', description='Indicates whether LDPS is activated for the instance. Valid values:

*   **true**: LDPS is activated for the instance.
*   **false**: LDPS is not activated for the instance.', example='true'),
      enableLts?: boolean(name='EnableLts', description='Indicates whether the LTS engine is enabled, returning:
- **true**: Enabled. - **false**: Not enabled.', example='true'),
      enableMessage?: boolean(name='EnableMessage', description='Indicates whether the message engine is enabled, returning:
- **true**: Enabled. - **false**: Not enabled.', example='true'),
      enableRow?: boolean(name='EnableRow'),
      enableStream?: boolean(name='EnableStream', description='Indicates whether the Lindorm streaming engine is activated for the instance. Valid values:

*   **true**: The Lindorm streaming engine is activated for the instance.
*   **false**: The Lindorm streaming engine is not activated for the instance.', example='true'),
      enableVector?: boolean(name='EnableVector', description='Whether the vector engine is enabled, returns:
- **true**: Enabled. - **false**: Not enabled.', example='true'),
      engineType?: string(name='EngineType', description='The engine supported by the instance. The engines are indicated by different numbers:

*   **1**: LindormSearch.
*   **2**: LindormTSDB.
*   **4**: LindormTable.
*   **8**: LindormDFS.

> The value of this parameter is the sum of all numbers that indicate the engines supported by the instance. For example, if the value of this parameter is 15, which is the sum of 1, 2, 4, and 8, the instance supports all four engines. If the value of this parameter is 6, which is the sum of 2 and 4, the instance supports LindormTSDB and LindormTable.', example='15'),
      expireTime?: string(name='ExpireTime', description='The time when the instance expires.

> This parameter is returned only if the billing method of the instance is subscription.', example='2022-04-26 00:00:00'),
      expiredMilliseconds?: long(name='ExpiredMilliseconds', description='The time when the instance expires. This value is a UNIX timestamp that indicates the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.', example='1650902400000'),
      instanceAlias?: string(name='InstanceAlias', description='The name of the VPC.', example='test'),
      instanceId?: string(name='InstanceId', description='The ID of the instance', example='ld-bp17pwu1541ia****'),
      instanceStatus?: string(name='InstanceStatus', description='The status of the instance. Valid values:

*   **CREATING**: The instance is being created.
*   **ACTIVATION**: The instance is running.
*   **COLD_EXPANDING**: The Capacity storage of the instance is being scaled up.
*   **MINOR_VERSION_TRANSING**: The minor version of the instance is being updated.
*   **RESIZING**: The nodes in the instance are being scaled up.
*   **SHRINKING**: The nodes in the instance are being scaled down.
*   **CLASS_CHANGING**: The specification of the instance is being changed.
*   **SSL_SWITCHING: SSL**: The SSL configurations of the instance are being changed.
*   **CDC_OPENING**: Data subscription is being enabled for the instance.
*   **TRANSFER**: The data of the instance is being transferred.
*   **DATABASE_TRANSFER**: The data of the instance is being transferred to databases.
*   **GUARD_CREATING**: A disaster recovery instance is being created.
*   **BACKUP_RECOVERING**: The data of the instance is being restored from a backup.
*   **DATABASE_IMPORTING**: Data is being imported to the instance.
*   **NET_MODIFYING**: The network configurations of the instance are being changed.
*   **NET_SWITCHING**: The network of the instance is being switched between a virtual private cloud (VPC) and the Internet.
*   **NET_CREATING**: The connection to the instance is being created.
*   **NET_DELETING**: The connection to the instance is being deleted.
*   **DELETING**: The instance is being deleted.
*   **RESTARTING**: The instance is restarting.
*   **LOCKED**: The instance is locked because it expires.', example='ACTIVATION'),
      instanceStorage?: string(name='InstanceStorage', description='The storage capacity of the instance.', example='960'),
      networkType?: string(name='NetworkType', description='The network type of the instance.', example='vpc'),
      payType?: string(name='PayType', description='The billing method of the instance. Valid values:

*   **PREPAY**: subscription.
*   **POSTPAY**: pay-as-you-go.', example='PREPAY'),
      regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-aekzledqeat****'),
      serviceType?: string(name='ServiceType', description='The series of the instance. Valid values:

*   **lindorm**: The instance is a Lindorm instance.
*   **serverless_lindorm**: The instance is a Lindorm Serverless instance.
*   **lindorm_standalone**: The instance is a single-node Lindorm instance.
*   **lts**: The instance is an LTS instance.', example='lindorm'),
      tags?: [ 
        {
          key?: string(name='Key', description='The key of the tag.', example='test'),
          value?: string(name='Value', description='The value of the tag.', example='2.2.18'),
        }
      ](name='Tags', description='The list of tags associated with the specified instances.'),
      vpcId?: string(name='VpcId', description='The ID of the VPC in which the instance is deployed.', example='vpc-bp1n3i15v90el48nx****'),
      zoneId?: string(name='ZoneId', description='The ID of the zone in which the instance is created.', example='cn-hangzhou-h'),
    }
  ](name='InstanceList', description='The list of instance.'),
  pageNumber?: int32(name='PageNumber', description='The number of returned pages.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of instances that are returned on each page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1CA1FAFD-E8DC-51C2-AA7E-CA6E2D049BA0'),
  total?: int32(name='Total', description='The total number of returned instances.', example='1'),
}

model GetLindormInstanceListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLindormInstanceListResponseBody(name='body'),
}

/**
 * @summary Queries the instances that meet the specified conditions.
 *
 * @param request GetLindormInstanceListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLindormInstanceListResponse
 */
async function getLindormInstanceListWithOptions(request: GetLindormInstanceListRequest, runtime: Util.RuntimeOptions): GetLindormInstanceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryStr)) {
    query['QueryStr'] = request.queryStr;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.serviceType)) {
    query['ServiceType'] = request.serviceType;
  }
  if (!Util.isUnset(request.supportEngine)) {
    query['SupportEngine'] = request.supportEngine;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLindormInstanceList',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the instances that meet the specified conditions.
 *
 * @param request GetLindormInstanceListRequest
 * @return GetLindormInstanceListResponse
 */
async function getLindormInstanceList(request: GetLindormInstanceListRequest): GetLindormInstanceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLindormInstanceListWithOptions(request, runtime);
}

model GetLindormV2InstanceRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model GetLindormV2InstanceResponseBody = {
  aliUid?: long(name='AliUid'),
  autoRenew?: boolean(name='AutoRenew'),
  coldStorage?: int32(name='ColdStorage'),
  createMilliseconds?: long(name='CreateMilliseconds'),
  deletionProtection?: string(name='DeletionProtection'),
  diskCategory?: string(name='DiskCategory'),
  diskThreshold?: string(name='DiskThreshold'),
  diskUsage?: string(name='DiskUsage'),
  enableCompute?: boolean(name='EnableCompute'),
  engineList?: [ 
    {
      connectAddressList?: [ 
        {
          address?: string(name='Address'),
          port?: string(name='Port'),
          type?: string(name='Type'),
        }
      ](name='ConnectAddressList'),
      engine?: string(name='Engine'),
      isLastVersion?: boolean(name='IsLastVersion'),
      latestVersion?: string(name='LatestVersion'),
      nodeGroup?: [ 
        {
          category?: string(name='Category'),
          cpuCoreCount?: int32(name='CpuCoreCount'),
          enableAttachLocalDisk?: boolean(name='EnableAttachLocalDisk'),
          localDiskCapacity?: long(name='LocalDiskCapacity'),
          localDiskCategory?: string(name='LocalDiskCategory'),
          memorySizeGiB?: int32(name='MemorySizeGiB'),
          nodeSpec?: string(name='NodeSpec'),
          quantity?: int32(name='Quantity'),
          resourceGroupName?: string(name='ResourceGroupName'),
          specId?: string(name='SpecId'),
          status?: string(name='Status'),
        }
      ](name='NodeGroup'),
      version?: string(name='Version'),
    }
  ](name='EngineList'),
  expiredMilliseconds?: long(name='ExpiredMilliseconds'),
  initialRootPassword?: string(name='InitialRootPassword'),
  instanceAlias?: string(name='InstanceAlias'),
  instanceId?: string(name='InstanceId'),
  instanceStatus?: string(name='InstanceStatus'),
  instanceType?: string(name='InstanceType'),
  maintainEndTime?: string(name='MaintainEndTime'),
  maintainStartTime?: string(name='MaintainStartTime'),
  networkType?: string(name='NetworkType'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  serviceType?: string(name='ServiceType'),
  storageUsage?: {
    capacityByDiskCategory?: [  map[string]any ](name='CapacityByDiskCategory'),
    engineUsage?: map[string]any(name='EngineUsage'),
  }(name='StorageUsage'),
  vpcId?: string(name='VpcId'),
  vswitchId?: string(name='VswitchId'),
  whiteIpList?: [ 
    {
      groupName?: string(name='GroupName'),
      ipList?: string(name='IpList'),
    }
  ](name='WhiteIpList'),
  zoneEngineInfoMap?: map[string]any(name='ZoneEngineInfoMap'),
  zoneId?: string(name='ZoneId'),
}

model GetLindormV2InstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLindormV2InstanceResponseBody(name='body'),
}

/**
 * @param request GetLindormV2InstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLindormV2InstanceResponse
 */
async function getLindormV2InstanceWithOptions(request: GetLindormV2InstanceRequest, runtime: Util.RuntimeOptions): GetLindormV2InstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLindormV2Instance',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetLindormV2InstanceRequest
 * @return GetLindormV2InstanceResponse
 */
async function getLindormV2Instance(request: GetLindormV2InstanceRequest): GetLindormV2InstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLindormV2InstanceWithOptions(request, runtime);
}

model GetLindormV2InstanceEngineListRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model GetLindormV2InstanceEngineListResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  engineList?: [ 
    {
      engineType?: string(name='EngineType'),
      netInfoList?: [ 
        {
          accessType?: int32(name='AccessType'),
          connectionString?: string(name='ConnectionString'),
          netType?: string(name='NetType'),
          port?: int32(name='Port'),
        }
      ](name='NetInfoList'),
    }
  ](name='EngineList'),
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
}

model GetLindormV2InstanceEngineListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLindormV2InstanceEngineListResponseBody(name='body'),
}

/**
 * @param request GetLindormV2InstanceEngineListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLindormV2InstanceEngineListResponse
 */
async function getLindormV2InstanceEngineListWithOptions(request: GetLindormV2InstanceEngineListRequest, runtime: Util.RuntimeOptions): GetLindormV2InstanceEngineListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLindormV2InstanceEngineList',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetLindormV2InstanceEngineListRequest
 * @return GetLindormV2InstanceEngineListResponse
 */
async function getLindormV2InstanceEngineList(request: GetLindormV2InstanceEngineListRequest): GetLindormV2InstanceEngineListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLindormV2InstanceEngineListWithOptions(request, runtime);
}

model GetLindormV2StorageUsageRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model GetLindormV2StorageUsageResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  capacityByDiskCategory?: [  map[string]any ](name='CapacityByDiskCategory'),
  instanceStorageZoneMap?: map[string]any(name='InstanceStorageZoneMap'),
  requestId?: string(name='RequestId'),
  usageByDiskCategory?: [  map[string]any ](name='UsageByDiskCategory'),
}

model GetLindormV2StorageUsageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLindormV2StorageUsageResponseBody(name='body'),
}

/**
 * @param request GetLindormV2StorageUsageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLindormV2StorageUsageResponse
 */
async function getLindormV2StorageUsageWithOptions(request: GetLindormV2StorageUsageRequest, runtime: Util.RuntimeOptions): GetLindormV2StorageUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLindormV2StorageUsage',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetLindormV2StorageUsageRequest
 * @return GetLindormV2StorageUsageResponse
 */
async function getLindormV2StorageUsage(request: GetLindormV2StorageUsageRequest): GetLindormV2StorageUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLindormV2StorageUsageWithOptions(request, runtime);
}

model ListAutoScalingConfigsRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ListAutoScalingConfigsResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: {
    scaleConfigs?: [ 
      {
        configId?: string(name='ConfigId'),
        configName?: string(name='ConfigName'),
        effectiveTimeEnd?: string(name='EffectiveTimeEnd'),
        effectiveTimeStart?: string(name='EffectiveTimeStart'),
        enabled?: boolean(name='Enabled'),
        engine?: string(name='Engine'),
        instanceId?: string(name='InstanceId'),
        nodesMax?: int32(name='NodesMax'),
        nodesMin?: int32(name='NodesMin'),
        scaleRuleList?: [ 
          {
            configId?: string(name='ConfigId'),
            enabled?: boolean(name='Enabled'),
            endTime?: string(name='EndTime'),
            instanceId?: string(name='InstanceId'),
            observationWindow?: int32(name='ObservationWindow'),
            operationType?: string(name='OperationType'),
            ruleId?: string(name='RuleId'),
            ruleName?: string(name='RuleName'),
            ruleType?: string(name='RuleType'),
            scaleInStep?: int32(name='ScaleInStep'),
            scaleOutStep?: int32(name='ScaleOutStep'),
            silenceTime?: int32(name='SilenceTime'),
            startTime?: string(name='StartTime'),
            targetMetric?: string(name='TargetMetric'),
            targetNodes?: int32(name='TargetNodes'),
            thresholdLower?: int32(name='ThresholdLower'),
            thresholdUpper?: int32(name='ThresholdUpper'),
            triggerCronExpr?: string(name='TriggerCronExpr'),
          }
        ](name='ScaleRuleList'),
        scaleType?: string(name='ScaleType'),
        specId?: string(name='SpecId'),
      }
    ](name='ScaleConfigs'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAutoScalingConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAutoScalingConfigsResponseBody(name='body'),
}

/**
 * @param request ListAutoScalingConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAutoScalingConfigsResponse
 */
async function listAutoScalingConfigsWithOptions(request: ListAutoScalingConfigsRequest, runtime: Util.RuntimeOptions): ListAutoScalingConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAutoScalingConfigs',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ListAutoScalingConfigsRequest
 * @return ListAutoScalingConfigsResponse
 */
async function listAutoScalingConfigs(request: ListAutoScalingConfigsRequest): ListAutoScalingConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAutoScalingConfigsWithOptions(request, runtime);
}

model ListAutoScalingRecordsRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNum?: int32(name='PageNum', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ListAutoScalingRecordsResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: {
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    scaleRecords?: [ 
      {
        detail?: string(name='Detail'),
        endTime?: string(name='EndTime'),
        id?: string(name='Id'),
        instanceId?: string(name='InstanceId'),
        oldValue?: string(name='OldValue'),
        resourceType?: string(name='ResourceType'),
        specGroupId?: string(name='SpecGroupId'),
        startTime?: string(name='StartTime'),
        status?: string(name='Status'),
        strategy?: string(name='Strategy'),
        targetValue?: string(name='TargetValue'),
      }
    ](name='ScaleRecords'),
    totalNum?: int32(name='TotalNum'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAutoScalingRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAutoScalingRecordsResponseBody(name='body'),
}

/**
 * @param request ListAutoScalingRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAutoScalingRecordsResponse
 */
async function listAutoScalingRecordsWithOptions(request: ListAutoScalingRecordsRequest, runtime: Util.RuntimeOptions): ListAutoScalingRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAutoScalingRecords',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ListAutoScalingRecordsRequest
 * @return ListAutoScalingRecordsResponse
 */
async function listAutoScalingRecords(request: ListAutoScalingRecordsRequest): ListAutoScalingRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAutoScalingRecordsWithOptions(request, runtime);
}

model ListAutoScalingRulesRequest {
  configId?: string(name='ConfigId', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ListAutoScalingRulesResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: {
    scaleRules?: [ 
      {
        configId?: string(name='ConfigId'),
        enabled?: boolean(name='Enabled'),
        endTime?: string(name='EndTime'),
        instanceId?: string(name='InstanceId'),
        observationWindow?: int32(name='ObservationWindow'),
        operationType?: string(name='OperationType'),
        ruleId?: string(name='RuleId'),
        ruleName?: string(name='RuleName'),
        ruleType?: string(name='RuleType'),
        scaleInStep?: int32(name='ScaleInStep'),
        scaleOutStep?: int32(name='ScaleOutStep'),
        silenceTime?: int32(name='SilenceTime'),
        startTime?: string(name='StartTime'),
        targetMetric?: string(name='TargetMetric'),
        targetNodes?: int32(name='TargetNodes'),
        thresholdLower?: int32(name='ThresholdLower'),
        thresholdUpper?: int32(name='ThresholdUpper'),
        triggerCronExpr?: string(name='TriggerCronExpr'),
      }
    ](name='ScaleRules'),
  }(name='Data'),
  dynamicCode?: string(name='DynamicCode'),
  dynamicMessage?: string(name='DynamicMessage'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAutoScalingRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAutoScalingRulesResponseBody(name='body'),
}

/**
 * @param request ListAutoScalingRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAutoScalingRulesResponse
 */
async function listAutoScalingRulesWithOptions(request: ListAutoScalingRulesRequest, runtime: Util.RuntimeOptions): ListAutoScalingRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAutoScalingRules',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ListAutoScalingRulesRequest
 * @return ListAutoScalingRulesResponse
 */
async function listAutoScalingRules(request: ListAutoScalingRulesRequest): ListAutoScalingRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAutoScalingRulesWithOptions(request, runtime);
}

model ListLdpsComputeGroupsRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ListLdpsComputeGroupsResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  groupList?: [ 
    {
      exceptionInfo?: string(name='ExceptionInfo'),
      groupName?: string(name='GroupName'),
      isDefault?: boolean(name='IsDefault'),
      properties?: map[string]any(name='Properties'),
      state?: string(name='State'),
      webUI?: string(name='WebUI'),
    }
  ](name='GroupList'),
  requestId?: string(name='RequestId'),
}

model ListLdpsComputeGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLdpsComputeGroupsResponseBody(name='body'),
}

/**
 * @param request ListLdpsComputeGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLdpsComputeGroupsResponse
 */
async function listLdpsComputeGroupsWithOptions(request: ListLdpsComputeGroupsRequest, runtime: Util.RuntimeOptions): ListLdpsComputeGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLdpsComputeGroups',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ListLdpsComputeGroupsRequest
 * @return ListLdpsComputeGroupsResponse
 */
async function listLdpsComputeGroups(request: ListLdpsComputeGroupsRequest): ListLdpsComputeGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLdpsComputeGroupsWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The token used to start the next query to retrieve more results.

> This parameter is not required in the first query. If not all results are returned in one query, you can pass in the **NextToken** value returned for the query to perform the next query.', example='212db86****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region in which the instances whose tags you want to query are located. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/426062.html) operation to query the region ID.

This parameter is required.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The list of resource IDs.'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType', description='The resource type. Set the value to **INSTANCE**.

This parameter is required.', example='INSTANCE'),
  securityToken?: string(name='SecurityToken'),
  tag?: [ 
    {
      key?: string(name='Key', description='The keys of the tags associated with the instances you want to query.

> You can specify the keys of multiple tags. For example, you can specify the key of the first tag in the first key-value pair contained in the value of this parameter and specify the key of the second tag in the second key-value pair.', example='test'),
      value?: string(name='Value', description='The values of the tags associated with the instances you want to query.

> You can specify the values of multiple tags. For example, you can specify the value of the first tag in the first key-value pair contained in the value of this parameter and specify the value of the second tag in the second key-value pair.', example='2.2.8'),
    }
  ](name='Tag', description='The list of tags associated with the instances you want to query.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The token used to start the next query.

> If not all results are returned in the first query, this parameter is returned. You can pass in the returned value of this parameter for the next query.', example='212db86****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='05CB115C-91CB-529F-9098-50C1F6CB3BD3'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId', description='The ID of the resource, which is the ID of the instance.', example='ld-bp17j28j2y7pm****'),
      resourceType?: string(name='ResourceType', description='The type of the resources. The returned value is fixed to **ALIYUN::HITSDB::INSTANCE**.', example='ALIYUN::HITSDB::INSTANCE'),
      tagKey?: string(name='TagKey', description='The key of the tag associated with the instance.', example='test'),
      tagValue?: string(name='TagValue', description='The value of the tag associated with the instance.', example='2.2.8'),
    }
  ](name='TagResources', description='The list of resources.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
 * @summary Queries the tags associated with the specified Lindorm instance.
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the tags associated with the specified Lindorm instance.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyAutoScalingConfigRequest {
  configId?: string(name='ConfigId', description='This parameter is required.'),
  configName?: string(name='ConfigName'),
  effectiveTimeEnd?: string(name='EffectiveTimeEnd'),
  effectiveTimeStart?: string(name='EffectiveTimeStart'),
  enabled?: boolean(name='Enabled'),
  engine?: string(name='Engine'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  nodesMax?: int32(name='NodesMax'),
  nodesMin?: int32(name='NodesMin'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scaleType?: string(name='ScaleType'),
  securityToken?: string(name='SecurityToken'),
  specId?: string(name='SpecId'),
}

model ModifyAutoScalingConfigResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyAutoScalingConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAutoScalingConfigResponseBody(name='body'),
}

/**
 * @param request ModifyAutoScalingConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAutoScalingConfigResponse
 */
async function modifyAutoScalingConfigWithOptions(request: ModifyAutoScalingConfigRequest, runtime: Util.RuntimeOptions): ModifyAutoScalingConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.configName)) {
    query['ConfigName'] = request.configName;
  }
  if (!Util.isUnset(request.effectiveTimeEnd)) {
    query['EffectiveTimeEnd'] = request.effectiveTimeEnd;
  }
  if (!Util.isUnset(request.effectiveTimeStart)) {
    query['EffectiveTimeStart'] = request.effectiveTimeStart;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nodesMax)) {
    query['NodesMax'] = request.nodesMax;
  }
  if (!Util.isUnset(request.nodesMin)) {
    query['NodesMin'] = request.nodesMin;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scaleType)) {
    query['ScaleType'] = request.scaleType;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.specId)) {
    query['SpecId'] = request.specId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAutoScalingConfig',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ModifyAutoScalingConfigRequest
 * @return ModifyAutoScalingConfigResponse
 */
async function modifyAutoScalingConfig(request: ModifyAutoScalingConfigRequest): ModifyAutoScalingConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAutoScalingConfigWithOptions(request, runtime);
}

model ModifyAutoScalingRuleRequest {
  configId?: string(name='ConfigId', description='This parameter is required.'),
  enabled?: boolean(name='Enabled'),
  endTime?: string(name='EndTime'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  observationWindow?: int32(name='ObservationWindow'),
  operationType?: string(name='OperationType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ruleId?: string(name='RuleId', description='This parameter is required.'),
  ruleName?: string(name='RuleName'),
  ruleType?: string(name='RuleType'),
  scaleInStep?: int32(name='ScaleInStep'),
  scaleOutStep?: int32(name='ScaleOutStep'),
  securityToken?: string(name='SecurityToken'),
  silenceTime?: int32(name='SilenceTime'),
  startTime?: string(name='StartTime'),
  targetMetric?: string(name='TargetMetric'),
  targetNodes?: int32(name='TargetNodes'),
  thresholdLower?: int32(name='ThresholdLower'),
  thresholdUpper?: int32(name='ThresholdUpper'),
  triggerCronExpr?: string(name='TriggerCronExpr'),
}

model ModifyAutoScalingRuleResponseBody = {
  code?: string(name='Code'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyAutoScalingRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAutoScalingRuleResponseBody(name='body'),
}

/**
 * @param request ModifyAutoScalingRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAutoScalingRuleResponse
 */
async function modifyAutoScalingRuleWithOptions(request: ModifyAutoScalingRuleRequest, runtime: Util.RuntimeOptions): ModifyAutoScalingRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configId)) {
    query['ConfigId'] = request.configId;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.observationWindow)) {
    query['ObservationWindow'] = request.observationWindow;
  }
  if (!Util.isUnset(request.operationType)) {
    query['OperationType'] = request.operationType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.scaleInStep)) {
    query['ScaleInStep'] = request.scaleInStep;
  }
  if (!Util.isUnset(request.scaleOutStep)) {
    query['ScaleOutStep'] = request.scaleOutStep;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.silenceTime)) {
    query['SilenceTime'] = request.silenceTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.targetMetric)) {
    query['TargetMetric'] = request.targetMetric;
  }
  if (!Util.isUnset(request.targetNodes)) {
    query['TargetNodes'] = request.targetNodes;
  }
  if (!Util.isUnset(request.thresholdLower)) {
    query['ThresholdLower'] = request.thresholdLower;
  }
  if (!Util.isUnset(request.thresholdUpper)) {
    query['ThresholdUpper'] = request.thresholdUpper;
  }
  if (!Util.isUnset(request.triggerCronExpr)) {
    query['TriggerCronExpr'] = request.triggerCronExpr;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAutoScalingRule',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ModifyAutoScalingRuleRequest
 * @return ModifyAutoScalingRuleResponse
 */
async function modifyAutoScalingRule(request: ModifyAutoScalingRuleRequest): ModifyAutoScalingRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAutoScalingRuleWithOptions(request, runtime);
}

model ModifyInstancePayTypeRequest {
  duration?: int32(name='Duration', description='The subscription duration of the instance. The parameter is required if the instance is an subscription instance.

*   If PricingCycle is set to Month, set this parameter to an integer that ranges from 1 to 9.
*   If PricingCycle is set to Year, set this parameter to an integer that ranges from 1 to 3.', example='1'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

This parameter is required.', example='ld-bp1z3506imz2f****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType', description='The billing method of the instance. Valid values:

*   **PREPAY**: subscription.
*   **POSTPAY**: pay-as-you-go.

This parameter is required.', example='POSTPAY'),
  pricingCycle?: string(name='PricingCycle', description='The unit of the subscription duration for the instance. Valid values:

*   Month
*   Year', example='Month'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifyInstancePayTypeResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', description='The detailed reason why the access was denied.', example='{"AuthAction":"xxx","AuthPrincipalDisplayName":"222","AuthPrincipalOwnerId":"111","AuthPrincipalType":"SubUser",,"NoPermissionType":"ImplicitDeny","PolicyType":"AccountLevelIdentityBasedPolicy","EncodedDiagnosticMessage":"xxxxxx"}'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ld-bp1z3506imz2f****'),
  orderId?: long(name='OrderId', description='The ID of the order.', example='211662251220224'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='587BCA54-50DA-4885-ADE9-80A848339151'),
}

model ModifyInstancePayTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyInstancePayTypeResponseBody(name='body'),
}

/**
 * @summary Changes the billing method of the specified Lindorm instance.
 *
 * @description You can call this operation to change the billing method of an instance to subscription or pay-as-you-go.
 * Before you call this operation, make sure that you fully understand the billing methods and [pricing](https://www.alibabacloud.com/en/pricing-calculator?spm=a2c63.p38356.0.0.2b024c2adcHeXL&_p_lc=1#/commodity/hitsdb_lindormpre_public_intl) of Lindorm. Published on only international site (alibabacloud.com).
 *
 * @param request ModifyInstancePayTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyInstancePayTypeResponse
 */
async function modifyInstancePayTypeWithOptions(request: ModifyInstancePayTypeRequest, runtime: Util.RuntimeOptions): ModifyInstancePayTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstancePayType',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Changes the billing method of the specified Lindorm instance.
 *
 * @description You can call this operation to change the billing method of an instance to subscription or pay-as-you-go.
 * Before you call this operation, make sure that you fully understand the billing methods and [pricing](https://www.alibabacloud.com/en/pricing-calculator?spm=a2c63.p38356.0.0.2b024c2adcHeXL&_p_lc=1#/commodity/hitsdb_lindormpre_public_intl) of Lindorm. Published on only international site (alibabacloud.com).
 *
 * @param request ModifyInstancePayTypeRequest
 * @return ModifyInstancePayTypeResponse
 */
async function modifyInstancePayType(request: ModifyInstancePayTypeRequest): ModifyInstancePayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstancePayTypeWithOptions(request, runtime);
}

model ModifyLindormV2InstanceRequest {
  cloudStorageSize?: long(name='CloudStorageSize'),
  cloudStorageType?: string(name='CloudStorageType'),
  engineType?: string(name='EngineType'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  nodeGroupList?: [ 
    {
      groupId?: string(name='GroupId'),
      nodeCount?: string(name='NodeCount'),
      nodeDiskSize?: long(name='NodeDiskSize'),
      nodeDiskType?: string(name='NodeDiskType'),
      nodeSpec?: string(name='NodeSpec'),
      resourceGroupName?: string(name='ResourceGroupName'),
    }
  ](name='NodeGroupList'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  upgradeType?: string(name='UpgradeType', description='This parameter is required.'),
}

model ModifyLindormV2InstanceResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  instanceId?: string(name='InstanceId'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyLindormV2InstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLindormV2InstanceResponseBody(name='body'),
}

/**
 * @param request ModifyLindormV2InstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyLindormV2InstanceResponse
 */
async function modifyLindormV2InstanceWithOptions(request: ModifyLindormV2InstanceRequest, runtime: Util.RuntimeOptions): ModifyLindormV2InstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cloudStorageSize)) {
    query['CloudStorageSize'] = request.cloudStorageSize;
  }
  if (!Util.isUnset(request.cloudStorageType)) {
    query['CloudStorageType'] = request.cloudStorageType;
  }
  if (!Util.isUnset(request.engineType)) {
    query['EngineType'] = request.engineType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nodeGroupList)) {
    query['NodeGroupList'] = request.nodeGroupList;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.upgradeType)) {
    query['UpgradeType'] = request.upgradeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLindormV2Instance',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ModifyLindormV2InstanceRequest
 * @return ModifyLindormV2InstanceResponse
 */
async function modifyLindormV2Instance(request: ModifyLindormV2InstanceRequest): ModifyLindormV2InstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLindormV2InstanceWithOptions(request, runtime);
}

model ModifyLindormV2WhiteIpListRequest {
  deleteGroup?: boolean(name='DeleteGroup'),
  groupName?: string(name='GroupName', description='This parameter is required.'),
  instanceId?: string(name='InstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  whiteIpList?: string(name='WhiteIpList', description='This parameter is required.'),
}

model ModifyLindormV2WhiteIpListResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  requestId?: string(name='RequestId'),
}

model ModifyLindormV2WhiteIpListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLindormV2WhiteIpListResponseBody(name='body'),
}

/**
 * @param request ModifyLindormV2WhiteIpListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyLindormV2WhiteIpListResponse
 */
async function modifyLindormV2WhiteIpListWithOptions(request: ModifyLindormV2WhiteIpListRequest, runtime: Util.RuntimeOptions): ModifyLindormV2WhiteIpListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deleteGroup)) {
    query['DeleteGroup'] = request.deleteGroup;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.whiteIpList)) {
    query['WhiteIpList'] = request.whiteIpList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyLindormV2WhiteIpList',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ModifyLindormV2WhiteIpListRequest
 * @return ModifyLindormV2WhiteIpListResponse
 */
async function modifyLindormV2WhiteIpList(request: ModifyLindormV2WhiteIpListRequest): ModifyLindormV2WhiteIpListResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyLindormV2WhiteIpListWithOptions(request, runtime);
}

model OpenComputeEngineRequest {
  cpuLimit?: string(name='CpuLimit'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  memoryLimit?: string(name='MemoryLimit'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model OpenComputeEngineResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  requestId?: string(name='RequestId'),
}

model OpenComputeEngineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenComputeEngineResponseBody(name='body'),
}

/**
 * @param request OpenComputeEngineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenComputeEngineResponse
 */
async function openComputeEngineWithOptions(request: OpenComputeEngineRequest, runtime: Util.RuntimeOptions): OpenComputeEngineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cpuLimit)) {
    query['CpuLimit'] = request.cpuLimit;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.memoryLimit)) {
    query['MemoryLimit'] = request.memoryLimit;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenComputeEngine',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request OpenComputeEngineRequest
 * @return OpenComputeEngineResponse
 */
async function openComputeEngine(request: OpenComputeEngineRequest): OpenComputeEngineResponse {
  var runtime = new Util.RuntimeOptions{};
  return openComputeEngineWithOptions(request, runtime);
}

model OpenComputePreCheckRequest {
  cpuLimit?: string(name='CpuLimit'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  memoryLimit?: string(name='MemoryLimit'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model OpenComputePreCheckResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  requestId?: string(name='RequestId'),
}

model OpenComputePreCheckResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenComputePreCheckResponseBody(name='body'),
}

/**
 * @param request OpenComputePreCheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenComputePreCheckResponse
 */
async function openComputePreCheckWithOptions(request: OpenComputePreCheckRequest, runtime: Util.RuntimeOptions): OpenComputePreCheckResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cpuLimit)) {
    query['CpuLimit'] = request.cpuLimit;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.memoryLimit)) {
    query['MemoryLimit'] = request.memoryLimit;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OpenComputePreCheck',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request OpenComputePreCheckRequest
 * @return OpenComputePreCheckResponse
 */
async function openComputePreCheck(request: OpenComputePreCheckRequest): OpenComputePreCheckResponse {
  var runtime = new Util.RuntimeOptions{};
  return openComputePreCheckWithOptions(request, runtime);
}

model ReleaseLindormInstanceRequest {
  immediately?: boolean(name='Immediately', description='Specifies whether to release the instance immediately. If you set this parameter to false, data in the released instance is retained for seven days before it is completely deleted. If you set this parameter to true, data in the released instance is immediately deleted. The default value is false.', example='false'),
  instanceId?: string(name='InstanceId', description='Instance ID, which can be obtained by calling the [GetLindormInstanceList](https://help.aliyun.com/document_detail/426069.html) interface.

This parameter is required.', example='ld-bp1z3506imz2f****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ReleaseLindormInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Request ID.', example='F67BFFF3-F5C2-45B5-9C28-6E4A1E51****'),
}

model ReleaseLindormInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseLindormInstanceResponseBody(name='body'),
}

/**
 * @summary Releases a Lindorm instance.
 *
 * @param request ReleaseLindormInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseLindormInstanceResponse
 */
async function releaseLindormInstanceWithOptions(request: ReleaseLindormInstanceRequest, runtime: Util.RuntimeOptions): ReleaseLindormInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.immediately)) {
    query['Immediately'] = request.immediately;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseLindormInstance',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Releases a Lindorm instance.
 *
 * @param request ReleaseLindormInstanceRequest
 * @return ReleaseLindormInstanceResponse
 */
async function releaseLindormInstance(request: ReleaseLindormInstanceRequest): ReleaseLindormInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseLindormInstanceWithOptions(request, runtime);
}

model ReleaseLindormV2InstanceRequest {
  immediately?: boolean(name='Immediately'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ReleaseLindormV2InstanceResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  requestId?: string(name='RequestId'),
}

model ReleaseLindormV2InstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseLindormV2InstanceResponseBody(name='body'),
}

/**
 * @param request ReleaseLindormV2InstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseLindormV2InstanceResponse
 */
async function releaseLindormV2InstanceWithOptions(request: ReleaseLindormV2InstanceRequest, runtime: Util.RuntimeOptions): ReleaseLindormV2InstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.immediately)) {
    query['Immediately'] = request.immediately;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseLindormV2Instance',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ReleaseLindormV2InstanceRequest
 * @return ReleaseLindormV2InstanceResponse
 */
async function releaseLindormV2Instance(request: ReleaseLindormV2InstanceRequest): ReleaseLindormV2InstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseLindormV2InstanceWithOptions(request, runtime);
}

model RenewLindormInstanceRequest {
  duration?: int32(name='Duration', description='The subscription duration of the instance. The valid values of this parameter depend on the value of the PricingCycle parameter.

*   If PricingCycle is set to **Month**, set this parameter to an integer that ranges from **1** to **9**.
*   If PricingCycle is set to **Year**, set this parameter to an integer that ranges from **1** to **3**.

This parameter is required.', example='1'),
  instanceId?: string(name='InstanceId', description='The ID of the instance that you want to renew. You can call the [GetLindormInstanceList](https://help.aliyun.com/document_detail/426069.html) operation to obtain the instance ID.

This parameter is required.', example='ld-bp1z3506imz2f****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pricingCycle?: string(name='PricingCycle', description='The period based on which you are charged for the instance. Valid values:

*   **Month**: You are charged for the instance based on months.
*   **Year**: You are charged for the instance based on years.

This parameter is required.', example='Month'),
  regionId?: string(name='RegionId', description='The ID of the region in which the instance that you want to renew is located. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/426062.html) operation to query the region ID.

This parameter is required.', example='cn-shanghai'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model RenewLindormInstanceResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', description='The details about the access denial.', example='{"AuthAction":"xxx","AuthPrincipalDisplayName":"222","AuthPrincipalOwnerId":"111","AuthPrincipalType":"SubUser",,"NoPermissionType":"ImplicitDeny","PolicyType":"AccountLevelIdentityBasedPolicy","EncodedDiagnosticMessage":"xxxxxx"}'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ld-bp1z3506imz2f****'),
  orderId?: long(name='OrderId', description='The ID of the order. You can obtain the order ID on the Orders page of the Expenses and Costs console.', example='213465921640411'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1556DCB0-043A-4444-8BD9-CF4A68E7EE64'),
}

model RenewLindormInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RenewLindormInstanceResponseBody(name='body'),
}

/**
 * @summary Renews a subscription Lindorm instance.
 *
 * @description You can call this operation to renew a subscription Lindorm instance for 1 to 9 months or 1 to 3 years.
 * Before you call this operation, make sure that you fully understand the billing methods and pricing of Lindorm.
 *
 * @param request RenewLindormInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RenewLindormInstanceResponse
 */
async function renewLindormInstanceWithOptions(request: RenewLindormInstanceRequest, runtime: Util.RuntimeOptions): RenewLindormInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewLindormInstance',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Renews a subscription Lindorm instance.
 *
 * @description You can call this operation to renew a subscription Lindorm instance for 1 to 9 months or 1 to 3 years.
 * Before you call this operation, make sure that you fully understand the billing methods and pricing of Lindorm.
 *
 * @param request RenewLindormInstanceRequest
 * @return RenewLindormInstanceResponse
 */
async function renewLindormInstance(request: RenewLindormInstanceRequest): RenewLindormInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewLindormInstanceWithOptions(request, runtime);
}

model RestartLdpsComputeGroupRequest {
  groupName?: string(name='GroupName', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model RestartLdpsComputeGroupResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  requestId?: string(name='RequestId'),
}

model RestartLdpsComputeGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartLdpsComputeGroupResponseBody(name='body'),
}

/**
 * @param request RestartLdpsComputeGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestartLdpsComputeGroupResponse
 */
async function restartLdpsComputeGroupWithOptions(request: RestartLdpsComputeGroupRequest, runtime: Util.RuntimeOptions): RestartLdpsComputeGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartLdpsComputeGroup',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request RestartLdpsComputeGroupRequest
 * @return RestartLdpsComputeGroupResponse
 */
async function restartLdpsComputeGroup(request: RestartLdpsComputeGroupRequest): RestartLdpsComputeGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartLdpsComputeGroupWithOptions(request, runtime);
}

model SetDefaultOlapComputeGroupRequest {
  groupName?: string(name='GroupName', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  isDefault?: boolean(name='IsDefault'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model SetDefaultOlapComputeGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetDefaultOlapComputeGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDefaultOlapComputeGroupResponseBody(name='body'),
}

/**
 * @param request SetDefaultOlapComputeGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDefaultOlapComputeGroupResponse
 */
async function setDefaultOlapComputeGroupWithOptions(request: SetDefaultOlapComputeGroupRequest, runtime: Util.RuntimeOptions): SetDefaultOlapComputeGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.isDefault)) {
    query['IsDefault'] = request.isDefault;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDefaultOlapComputeGroup',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request SetDefaultOlapComputeGroupRequest
 * @return SetDefaultOlapComputeGroupResponse
 */
async function setDefaultOlapComputeGroup(request: SetDefaultOlapComputeGroupRequest): SetDefaultOlapComputeGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultOlapComputeGroupWithOptions(request, runtime);
}

model SwitchLSQLV3MySQLServiceRequest {
  actionType?: int32(name='ActionType', description='The type of the operation. Valid value:

*   1: enables the MySQL compatibility feature.
*   0: disables the MySQL compatibility feature.

This parameter is required.', example='1'),
  instanceId?: string(name='InstanceId', description='The cluster ID.

This parameter is required.', example='ld-bp1o3y0yme2i2****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model SwitchLSQLV3MySQLServiceResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', description='The details about the access denial.', example='{"AuthAction":"xxx","AuthPrincipalDisplayName":"222","AuthPrincipalOwnerId":"111","AuthPrincipalType":"SubUser",,"NoPermissionType":"ImplicitDeny","PolicyType":"AccountLevelIdentityBasedPolicy","EncodedDiagnosticMessage":"xxxxxx"}'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1556DCB0-043A-4444-8BD9-CF4A68E7EE64'),
}

model SwitchLSQLV3MySQLServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SwitchLSQLV3MySQLServiceResponseBody(name='body'),
}

/**
 * @summary Enables or disables the MySQL compatibility feature for a Lindorm instance.
 *
 * @description Prerequisites
 * *   The LindormTable version of your instance is 2.6.0 or later.
 * *   The LindormTable of your instance supports LindormSQL V3. The value of the EnableLsqlVersionV3 parameter in the response of the GetLindormInstance operation is true for Lindorm instances purchased after Oct 24, 2023, which indicates that LindormSQL is supported by these instances by default. If you want to enable LindormSQL for instances purchased before Oct 24, 2023, contact the on-duty technical support.
 * You can enable the MySQL compatibility feature for a Lindorm instance only when the instance meets the preceding requirements.
 *
 * @param request SwitchLSQLV3MySQLServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SwitchLSQLV3MySQLServiceResponse
 */
async function switchLSQLV3MySQLServiceWithOptions(request: SwitchLSQLV3MySQLServiceRequest, runtime: Util.RuntimeOptions): SwitchLSQLV3MySQLServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchLSQLV3MySQLService',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables the MySQL compatibility feature for a Lindorm instance.
 *
 * @description Prerequisites
 * *   The LindormTable version of your instance is 2.6.0 or later.
 * *   The LindormTable of your instance supports LindormSQL V3. The value of the EnableLsqlVersionV3 parameter in the response of the GetLindormInstance operation is true for Lindorm instances purchased after Oct 24, 2023, which indicates that LindormSQL is supported by these instances by default. If you want to enable LindormSQL for instances purchased before Oct 24, 2023, contact the on-duty technical support.
 * You can enable the MySQL compatibility feature for a Lindorm instance only when the instance meets the preceding requirements.
 *
 * @param request SwitchLSQLV3MySQLServiceRequest
 * @return SwitchLSQLV3MySQLServiceResponse
 */
async function switchLSQLV3MySQLService(request: SwitchLSQLV3MySQLServiceRequest): SwitchLSQLV3MySQLServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchLSQLV3MySQLServiceWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region in which the instances you want to associate tags with are located. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/426062.html) operation to query the region ID.

This parameter is required.', example='cn-hangzhou'),
  resourceId?: [ string ](name='ResourceId', description='The list of resource IDs.

This parameter is required.'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType', description='The resource type. Set the value to **INSTANCE**.

This parameter is required.', example='INSTANCE'),
  securityToken?: string(name='SecurityToken'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag that you want to associate with the resource.

> You can specify the keys of multiple tags. For example, you can specify the key of the first tag in the first key-value pair contained in the value of this parameter and specify the key of the second tag in the second key-value pair.

This parameter is required.', example='test'),
      value?: string(name='Value', description='The value of the tag that you want to associate with the resource.

> You can specify the values of multiple tags. For example, you can specify the value of the first tag in the first key-value pair contained in the value of this parameter and specify the value of the second tag in the second key-value pair.', example='2.2.8'),
    }
  ](name='Tag', description='The tags that you want to associate with the resource.

This parameter is required.'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F23D50C-400C-592C-9486-9D1E10179065'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
 * @summary Associates tags with a single or multiple Lindorm instances.
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Associates tags with a single or multiple Lindorm instances.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags from the instances. Valid values:

*   **true**: Remove all tags from the instances.
*   **false**: Do not remove all tags from the instances.

>  The default value of this parameter is false.



*   If you specify this parameter together with the TagKey parameter, this parameter does not take effect.', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceId?: [ string ](name='ResourceId', description='The IDs of instances.

This parameter is required.'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType', description='The resource type. Set the value to **INSTANCE**.

This parameter is required.', example='INSTANCE'),
  securityToken?: string(name='SecurityToken'),
  tagKey?: [ string ](name='TagKey', description='The list of keys of the tags that you want to remove.'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='8CACBBCE-7519-545C-8695-86D4F09CED7E'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
 * @summary Removes tags from a Lindorm instance.
 *
 * @description If a tag is not added to any Lindorm instance, it is deleted.
 *
 * @param request UntagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Removes tags from a Lindorm instance.
 *
 * @description If a tag is not added to any Lindorm instance, it is deleted.
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateInstanceIpWhiteListRequest {
  delete?: boolean(name='Delete', description='Specifies whether to clear all IP addresses and CIDR blocks in the whitelist.', example='false'),
  groupName?: string(name='GroupName', description='The name of the IP whitelist. Default value: user.', example='test_group'),
  instanceId?: string(name='InstanceId', description='The ID of the instance for which you want to configure a whitelist. You can call the [GetLindormInstanceList](https://help.aliyun.com/document_detail/426069.html) operation to obtain the ID.

This parameter is required.', example='ld-bp1z3506imz2f****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityIpList?: string(name='SecurityIpList', description='The IP addresses or CIDR blocks that you want to add to the whitelist.

>  If you add 127.0.0.1 to the whitelist, all IP addresses cannot be used to access the Lindorm instance. If you add the CIDR block 192.168.0.0/24 to the whitelist, you can use all IP addresses in the CIDR block to access the Lindorm instance. Separate multiple IP addresses or CIDR blocks with commas (,).

This parameter is required.', example='106.11.XX.XX/24'),
  securityToken?: string(name='SecurityToken'),
}

model UpdateInstanceIpWhiteListResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', description='The details about the access denial.', example='{"AuthAction":"xxx","AuthPrincipalDisplayName":"222","AuthPrincipalOwnerId":"111","AuthPrincipalType":"SubUser",,"NoPermissionType":"ImplicitDeny","PolicyType":"AccountLevelIdentityBasedPolicy","EncodedDiagnosticMessage":"xxxxxx"}'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4944539D-D27C-458D-95F1-2DCEB5E0EED5'),
}

model UpdateInstanceIpWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateInstanceIpWhiteListResponseBody(name='body'),
}

/**
 * @summary Configures an IP address whitelist for a Lindorm instance.
 *
 * @param request UpdateInstanceIpWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateInstanceIpWhiteListResponse
 */
async function updateInstanceIpWhiteListWithOptions(request: UpdateInstanceIpWhiteListRequest, runtime: Util.RuntimeOptions): UpdateInstanceIpWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.delete)) {
    query['Delete'] = request.delete;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityIpList)) {
    query['SecurityIpList'] = request.securityIpList;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstanceIpWhiteList',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures an IP address whitelist for a Lindorm instance.
 *
 * @param request UpdateInstanceIpWhiteListRequest
 * @return UpdateInstanceIpWhiteListResponse
 */
async function updateInstanceIpWhiteList(request: UpdateInstanceIpWhiteListRequest): UpdateInstanceIpWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInstanceIpWhiteListWithOptions(request, runtime);
}

model UpdateInstanceSecurityGroupsRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityGroups?: string(name='SecurityGroups', description='This parameter is required.'),
  securityToken?: string(name='SecurityToken'),
}

model UpdateInstanceSecurityGroupsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateInstanceSecurityGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateInstanceSecurityGroupsResponseBody(name='body'),
}

/**
 * @param request UpdateInstanceSecurityGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateInstanceSecurityGroupsResponse
 */
async function updateInstanceSecurityGroupsWithOptions(request: UpdateInstanceSecurityGroupsRequest, runtime: Util.RuntimeOptions): UpdateInstanceSecurityGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityGroups)) {
    query['SecurityGroups'] = request.securityGroups;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstanceSecurityGroups',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request UpdateInstanceSecurityGroupsRequest
 * @return UpdateInstanceSecurityGroupsResponse
 */
async function updateInstanceSecurityGroups(request: UpdateInstanceSecurityGroupsRequest): UpdateInstanceSecurityGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInstanceSecurityGroupsWithOptions(request, runtime);
}

model UpdateLdpsComputeGroupRequest {
  groupName?: string(name='GroupName', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  properties?: string(name='Properties'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model UpdateLdpsComputeGroupResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  requestId?: string(name='RequestId'),
}

model UpdateLdpsComputeGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLdpsComputeGroupResponseBody(name='body'),
}

/**
 * @param request UpdateLdpsComputeGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateLdpsComputeGroupResponse
 */
async function updateLdpsComputeGroupWithOptions(request: UpdateLdpsComputeGroupRequest, runtime: Util.RuntimeOptions): UpdateLdpsComputeGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.properties)) {
    query['Properties'] = request.properties;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLdpsComputeGroup',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request UpdateLdpsComputeGroupRequest
 * @return UpdateLdpsComputeGroupResponse
 */
async function updateLdpsComputeGroup(request: UpdateLdpsComputeGroupRequest): UpdateLdpsComputeGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLdpsComputeGroupWithOptions(request, runtime);
}

model UpdateLindormV2InstanceParameterRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterKey?: string(name='ParameterKey', description='This parameter is required.'),
  parameterValue?: string(name='ParameterValue', description='This parameter is required.'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  updateType?: string(name='UpdateType'),
}

model UpdateLindormV2InstanceParameterResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  requestId?: string(name='RequestId'),
}

model UpdateLindormV2InstanceParameterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLindormV2InstanceParameterResponseBody(name='body'),
}

/**
 * @param request UpdateLindormV2InstanceParameterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateLindormV2InstanceParameterResponse
 */
async function updateLindormV2InstanceParameterWithOptions(request: UpdateLindormV2InstanceParameterRequest, runtime: Util.RuntimeOptions): UpdateLindormV2InstanceParameterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterKey)) {
    query['ParameterKey'] = request.parameterKey;
  }
  if (!Util.isUnset(request.parameterValue)) {
    query['ParameterValue'] = request.parameterValue;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.updateType)) {
    query['UpdateType'] = request.updateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLindormV2InstanceParameter',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request UpdateLindormV2InstanceParameterRequest
 * @return UpdateLindormV2InstanceParameterResponse
 */
async function updateLindormV2InstanceParameter(request: UpdateLindormV2InstanceParameterRequest): UpdateLindormV2InstanceParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLindormV2InstanceParameterWithOptions(request, runtime);
}

model UpgradeLindormInstanceRequest {
  clusterStorage?: int32(name='ClusterStorage', description='The storage capacity of the instance after it is upgraded. Unit: GB. Valid values: **480** to **1017600**.', example='480'),
  coldStorage?: int32(name='ColdStorage', description='The cold storage capacity of the instance after it is upgraded. Unit: GB. Valid values: **800** to **1000000**.', example='800'),
  coreSingleStorage?: int32(name='CoreSingleStorage', description='The storage capacity of a single core node in the instance after the instance upgraded. This parameter is available only if the instance you want to upgrade is a multi-zone instance. Unit: GB. Valid values: 400 to 64000. **This parameter is optional**.', example='400'),
  filestoreNum?: int32(name='FilestoreNum', description='The number of LindormDFS nodes in the instance after the instance is upgraded. Valid values: integers from **0** to **60**.', example='2'),
  filestoreSpec?: string(name='FilestoreSpec', description='The specification of LindormDFS nodes in the instance after the instance is upgraded. Valid values:

*   **lindorm.g.xlarge**: Each node has 4 dedicated CPU cores and 16 GB of dedicated memory.
*   **lindorm.g.2xlarge**: Each node has 8 dedicated CPU cores and 32 GB of dedicated memory.
*   **lindorm.g.4xlarge**: Each node has 16 dedicated CPU cores and 64 GB of dedicated memory.
*   **lindorm.g.8xlarge**: Each node has 32 dedicated CPU cores and 128 GB of dedicated memory.', example='lindorm.g.xlarge'),
  instanceId?: string(name='InstanceId', description='The ID of the instance that you want to upgrade, scale up, or enable cold storage. You can call the [GetLindormInstanceList](https://help.aliyun.com/document_detail/426069.html) operation to query the instance ID.

This parameter is required.', example='ld-bp1o3y0yme2i2****'),
  lindormNum?: int32(name='LindormNum', description='The number of LindormTable nodes in the instance after the instance is upgraded. Valid values: integers from **0** to **90**.

> This parameter must be specified together with the LindormSpec parameter.', example='2'),
  lindormSpec?: string(name='LindormSpec', description='The specification of LindormTable nodes in the instance after the instance is upgraded. Valid values:

*   **lindorm.c.xlarge**: Each node has 4 dedicated CPU cores and 8 GB of dedicated memory.
*   **lindorm.c.2xlarge**: Each node has 8 dedicated CPU cores and 16 GB of dedicated memory.
*   **lindorm.c.4xlarge**: Each node has 16 dedicated CPU cores and 32 GB of dedicated memory.
*   **lindorm.c.8xlarge**: Each node has 32 dedicated CPU cores and 64 GB of dedicated memory.', example='lindorm.c.xlarge'),
  logNum?: int32(name='LogNum', description='The number of log nodes in the instance after the instance is upgraded. This parameter is available only if the instance you want to upgrade is a multi-zone instance. **This parameter is optional**.', example='4'),
  logSingleStorage?: int32(name='LogSingleStorage', description='The storage capacity of a single log node in the instance after the instance upgraded. This parameter is available only if the instance you want to upgrade is a multi-zone instance. **This parameter is optional**.', example='400'),
  logSpec?: string(name='LogSpec', description='The specification of log nodes in the instance after the instance is upgraded. This parameter is available only if the instance you want to upgrade is a multi-zone instance. Valid values:

*   **lindorm.sn1.large**: Each node has 4 dedicated CPU cores and 8 GB of dedicated memory.
*   **lindorm.sn1.2xlarge**: Each node has 8 dedicated CPU cores and 16 GB of dedicated memory.

**This parameter is optional**.', example='lindorm.sn1.large'),
  ltsCoreNum?: int32(name='LtsCoreNum', description='The number of LTS nodes in the instance after the instance is upgraded. Valid values: integers from **0** to **50**.', example='2'),
  ltsCoreSpec?: string(name='LtsCoreSpec', description='The specification of Lindorm Tunnel Service (LTS) nodes in the instance after the instance is upgraded. Valid values:

*   **lindorm.g.xlarge**: Each node has 4 dedicated CPU cores and 16 GB of dedicated memory.
*   **lindorm.g.2xlarge**: Each node has 8 dedicated CPU cores and 32 GB of dedicated memory.', example='lindorm.g.xlarge'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The ID of the region in which the instance that you want to upgrade, scale up, or enable cold storage is located. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/426062.html) operation to query the region ID.

This parameter is required.', example='cn-shanghai'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  solrNum?: int32(name='SolrNum', description='The number of LindormSearch nodes in the instance after the instance is upgraded. Valid values: integers from **0** to **60**.', example='2'),
  solrSpec?: string(name='SolrSpec', description='The specification of LindormSearch nodes in the instance after the instance is upgraded. Valid values:

*   **lindorm.g.xlarge**: Each node has 4 dedicated CPU cores and 16 GB of dedicated memory.
*   **lindorm.g.2xlarge**: Each node has 8 dedicated CPU cores and 32 GB of dedicated memory.
*   **lindorm.g.4xlarge**: Each node has 16 dedicated CPU cores and 64 GB of dedicated memory.
*   **lindorm.g.8xlarge**: Each node has 32 dedicated CPU cores and 128 GB of dedicated memory.', example='lindorm.g.xlarge'),
  streamNum?: int32(name='StreamNum', description='The number of LindormStream nodes in the instance after the instance is upgraded. Valid values: integers from **0** to **60**.', example='2'),
  streamSpec?: string(name='StreamSpec', description='The specification of LindormStream nodes in the instance after the instance is upgraded. Valid values:

*   **lindorm.g.xlarge**: Each node has 4 dedicated CPU cores and 16 GB of dedicated memory.
*   **lindorm.g.2xlarge**: Each node has 8 dedicated CPU cores and 32 GB of dedicated memory.
*   **lindorm.g.4xlarge**: Each node has 16 dedicated CPU cores and 64 GB of dedicated memory.
*   **lindorm.g.8xlarge**: Each node has 32 dedicated CPU cores and 128 GB of dedicated memory.', example='lindorm.g.xlarge'),
  tsdbNum?: int32(name='TsdbNum', description='The number of LindormTSDB nodes in the instance after the instance is upgraded. Valid values: integers from **0** to **24**.', example='2'),
  tsdbSpec?: string(name='TsdbSpec', description='The specification of LindormTSDB nodes in the instance after the instance is upgraded. Valid values:

*   **lindorm.g.xlarge**: Each node has 4 dedicated CPU cores and 16 GB of dedicated memory.
*   **lindorm.g.2xlarge**: Each node has 8 dedicated CPU cores and 32 GB of dedicated memory.
*   **lindorm.g.4xlarge**: Each node has 16 dedicated CPU cores and 64 GB of dedicated memory.
*   **lindorm.g.8xlarge**: Each node has 32 dedicated CPU cores and 128 GB of dedicated memory.', example='lindorm.g.xlarge'),
  upgradeType?: string(name='UpgradeType', description='The upgrade type of the operation. For more information about upgrade types, see the UpgradeType parameters section.

This parameter is required.', example='upgrade-cold-storage'),
  zoneId?: string(name='ZoneId', description='The ID of the zone in which the instance that you want to upgrade, scale up, or enable cold storage is located. You can call the [GetLindormInstance](https://help.aliyun.com/document_detail/426067.html) operation to query the zone ID.

This parameter is required.', example='cn-shanghai-f'),
}

model UpgradeLindormInstanceResponseBody = {
  orderId?: long(name='OrderId', description='The ID of the order.', example='111111111111111'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='2A7D4F9D-AA26-4E15-A2B1-3E4792C6****'),
}

model UpgradeLindormInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeLindormInstanceResponseBody(name='body'),
}

/**
 * @summary Upgrades, scales up, or enable cold storage for a Lindorm instance.
 *
 * @description For more information about how to select the storage type and engine type when you create a Lindorm instance, see [Select engine typpes](https://help.aliyun.com/document_detail/181971.html) and [Select storage types](https://help.aliyun.com/document_detail/174643.html).
 *
 * @param request UpgradeLindormInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeLindormInstanceResponse
 */
async function upgradeLindormInstanceWithOptions(request: UpgradeLindormInstanceRequest, runtime: Util.RuntimeOptions): UpgradeLindormInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterStorage)) {
    query['ClusterStorage'] = request.clusterStorage;
  }
  if (!Util.isUnset(request.coldStorage)) {
    query['ColdStorage'] = request.coldStorage;
  }
  if (!Util.isUnset(request.coreSingleStorage)) {
    query['CoreSingleStorage'] = request.coreSingleStorage;
  }
  if (!Util.isUnset(request.filestoreNum)) {
    query['FilestoreNum'] = request.filestoreNum;
  }
  if (!Util.isUnset(request.filestoreSpec)) {
    query['FilestoreSpec'] = request.filestoreSpec;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lindormNum)) {
    query['LindormNum'] = request.lindormNum;
  }
  if (!Util.isUnset(request.lindormSpec)) {
    query['LindormSpec'] = request.lindormSpec;
  }
  if (!Util.isUnset(request.logNum)) {
    query['LogNum'] = request.logNum;
  }
  if (!Util.isUnset(request.logSingleStorage)) {
    query['LogSingleStorage'] = request.logSingleStorage;
  }
  if (!Util.isUnset(request.logSpec)) {
    query['LogSpec'] = request.logSpec;
  }
  if (!Util.isUnset(request.ltsCoreNum)) {
    query['LtsCoreNum'] = request.ltsCoreNum;
  }
  if (!Util.isUnset(request.ltsCoreSpec)) {
    query['LtsCoreSpec'] = request.ltsCoreSpec;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.solrNum)) {
    query['SolrNum'] = request.solrNum;
  }
  if (!Util.isUnset(request.solrSpec)) {
    query['SolrSpec'] = request.solrSpec;
  }
  if (!Util.isUnset(request.streamNum)) {
    query['StreamNum'] = request.streamNum;
  }
  if (!Util.isUnset(request.streamSpec)) {
    query['StreamSpec'] = request.streamSpec;
  }
  if (!Util.isUnset(request.tsdbNum)) {
    query['TsdbNum'] = request.tsdbNum;
  }
  if (!Util.isUnset(request.tsdbSpec)) {
    query['TsdbSpec'] = request.tsdbSpec;
  }
  if (!Util.isUnset(request.upgradeType)) {
    query['UpgradeType'] = request.upgradeType;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeLindormInstance',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Upgrades, scales up, or enable cold storage for a Lindorm instance.
 *
 * @description For more information about how to select the storage type and engine type when you create a Lindorm instance, see [Select engine typpes](https://help.aliyun.com/document_detail/181971.html) and [Select storage types](https://help.aliyun.com/document_detail/174643.html).
 *
 * @param request UpgradeLindormInstanceRequest
 * @return UpgradeLindormInstanceResponse
 */
async function upgradeLindormInstance(request: UpgradeLindormInstanceRequest): UpgradeLindormInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeLindormInstanceWithOptions(request, runtime);
}

model UpgradeLindormV2StreamEngineRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  quantity?: int32(name='Quantity', description='This parameter is required.'),
  resourceGroupName?: string(name='ResourceGroupName'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  spec?: string(name='Spec', description='This parameter is required.'),
  specId?: string(name='SpecId', description='This parameter is required.'),
  upgradeType?: string(name='UpgradeType', description='This parameter is required.'),
}

model UpgradeLindormV2StreamEngineResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail'),
  requestId?: string(name='RequestId'),
}

model UpgradeLindormV2StreamEngineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeLindormV2StreamEngineResponseBody(name='body'),
}

/**
 * @param request UpgradeLindormV2StreamEngineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeLindormV2StreamEngineResponse
 */
async function upgradeLindormV2StreamEngineWithOptions(request: UpgradeLindormV2StreamEngineRequest, runtime: Util.RuntimeOptions): UpgradeLindormV2StreamEngineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.quantity)) {
    query['Quantity'] = request.quantity;
  }
  if (!Util.isUnset(request.resourceGroupName)) {
    query['ResourceGroupName'] = request.resourceGroupName;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  if (!Util.isUnset(request.specId)) {
    query['SpecId'] = request.specId;
  }
  if (!Util.isUnset(request.upgradeType)) {
    query['UpgradeType'] = request.upgradeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeLindormV2StreamEngine',
    version = '2020-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request UpgradeLindormV2StreamEngineRequest
 * @return UpgradeLindormV2StreamEngineResponse
 */
async function upgradeLindormV2StreamEngine(request: UpgradeLindormV2StreamEngineRequest): UpgradeLindormV2StreamEngineResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeLindormV2StreamEngineWithOptions(request, runtime);
}

