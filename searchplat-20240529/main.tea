/**
 *
 */
import Util;
import GatewayClient;
import OpenApi;
import OpenApiUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  var gatewayClient = new GatewayClient();
  @spi = gatewayClient;
  @endpointRule = '';
  }

model CreateDocumentAnalyzeTaskRequest {
  document?: {
    content?: string(name='content'),
    fileName?: string(name='file_name'),
    fileType?: string(name='file_type'),
    url?: string(name='url'),
  }(name='document'),
  output?: {
    imageStorage?: string(name='image_storage'),
  }(name='output'),
}

model CreateDocumentAnalyzeTaskResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    taskId?: string(name='task_id'),
  }(name='result'),
}

model CreateDocumentAnalyzeTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDocumentAnalyzeTaskResponseBody(name='body'),
}

/**
 * @summary 创建文档解析异步提取任务
 *
 * @param request CreateDocumentAnalyzeTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDocumentAnalyzeTaskResponse
 */
async function createDocumentAnalyzeTaskWithOptions(workspaceName: string, serviceId: string, request: CreateDocumentAnalyzeTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDocumentAnalyzeTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.document)) {
    body['document'] = request.document;
  }
  if (!Util.isUnset(request.output)) {
    body['output'] = request.output;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDocumentAnalyzeTask',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/document-analyze/${serviceId}/async`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 创建文档解析异步提取任务
 *
 * @param request CreateDocumentAnalyzeTaskRequest
 * @return CreateDocumentAnalyzeTaskResponse
 */
async function createDocumentAnalyzeTask(workspaceName: string, serviceId: string, request: CreateDocumentAnalyzeTaskRequest): CreateDocumentAnalyzeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDocumentAnalyzeTaskWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model CreateImageAnalyzeTaskRequest {
  document?: {
    content?: string(name='content'),
    fileName?: string(name='file_name'),
    fileType?: string(name='file_type'),
    url?: string(name='url'),
  }(name='document'),
}

model CreateImageAnalyzeTaskResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    taskId?: string(name='task_id'),
  }(name='result'),
}

model CreateImageAnalyzeTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateImageAnalyzeTaskResponseBody(name='body'),
}

/**
 * @summary 创建图片解析异步提取任务
 *
 * @param request CreateImageAnalyzeTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateImageAnalyzeTaskResponse
 */
async function createImageAnalyzeTaskWithOptions(workspaceName: string, serviceId: string, request: CreateImageAnalyzeTaskRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateImageAnalyzeTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.document)) {
    body['document'] = request.document;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateImageAnalyzeTask',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/image-analyze/${serviceId}/async`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 创建图片解析异步提取任务
 *
 * @param request CreateImageAnalyzeTaskRequest
 * @return CreateImageAnalyzeTaskResponse
 */
async function createImageAnalyzeTask(workspaceName: string, serviceId: string, request: CreateImageAnalyzeTaskRequest): CreateImageAnalyzeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createImageAnalyzeTaskWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetDocumentAnalyzeTaskStatusRequest {
  taskId?: string(name='task_id', description='This parameter is required.'),
}

model GetDocumentAnalyzeTaskStatusResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    data?: {
      content?: string(name='content'),
      contentType?: string(name='content_type'),
      pageNum?: int32(name='page_num'),
    }(name='data'),
    error?: string(name='error'),
    status?: string(name='status'),
    taskId?: string(name='task_id'),
  }(name='result'),
  usage?: {
    imageCount?: long(name='image_count'),
    tableCount?: long(name='table_count'),
    tokenCount?: long(name='token_count'),
  }(name='usage'),
}

model GetDocumentAnalyzeTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDocumentAnalyzeTaskStatusResponseBody(name='body'),
}

/**
 * @summary 获取文档解析异步提取任务状态
 *
 * @param request GetDocumentAnalyzeTaskStatusRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDocumentAnalyzeTaskStatusResponse
 */
async function getDocumentAnalyzeTaskStatusWithOptions(workspaceName: string, serviceId: string, request: GetDocumentAnalyzeTaskStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDocumentAnalyzeTaskStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.taskId)) {
    query['task_id'] = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDocumentAnalyzeTaskStatus',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/document-analyze/${serviceId}/async/task-status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 获取文档解析异步提取任务状态
 *
 * @param request GetDocumentAnalyzeTaskStatusRequest
 * @return GetDocumentAnalyzeTaskStatusResponse
 */
async function getDocumentAnalyzeTaskStatus(workspaceName: string, serviceId: string, request: GetDocumentAnalyzeTaskStatusRequest): GetDocumentAnalyzeTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDocumentAnalyzeTaskStatusWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetDocumentRankRequest {
  docs?: [ string ](name='docs', description='This parameter is required.'),
  query?: string(name='query', description='This parameter is required.'),
}

model GetDocumentRankResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    scores?: [ 
      {
        index?: int32(name='index'),
        score?: double(name='score'),
      }
    ](name='scores'),
  }(name='result'),
  usage?: {
    docCount?: long(name='doc_count'),
  }(name='usage'),
}

model GetDocumentRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDocumentRankResponseBody(name='body'),
}

/**
 * @summary 文档相关性打分
 *
 * @param request GetDocumentRankRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDocumentRankResponse
 */
async function getDocumentRankWithOptions(workspaceName: string, serviceId: string, request: GetDocumentRankRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDocumentRankResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.docs)) {
    body['docs'] = request.docs;
  }
  if (!Util.isUnset(request.query)) {
    body['query'] = request.query;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDocumentRank',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/ranker/${serviceId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 文档相关性打分
 *
 * @param request GetDocumentRankRequest
 * @return GetDocumentRankResponse
 */
async function getDocumentRank(workspaceName: string, serviceId: string, request: GetDocumentRankRequest): GetDocumentRankResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDocumentRankWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetDocumentSplitRequest {
  document?: {
    content?: string(name='content'),
    contentEncoding?: string(name='content_encoding'),
    contentType?: string(name='content_type'),
  }(name='document', description='This parameter is required.'),
  strategy?: {
    computeType?: string(name='compute_type'),
    maxChunkSize?: long(name='max_chunk_size'),
    needSentence?: boolean(name='need_sentence'),
  }(name='strategy'),
}

model GetDocumentSplitResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    chunks?: [ 
      {
        content?: string(name='content'),
        meta?: map[string]string(name='meta'),
      }
    ](name='chunks'),
    nodes?: [ map[string]string ](name='nodes'),
    richTexts?: [ 
      {
        content?: string(name='content'),
        meta?: map[string]string(name='meta'),
      }
    ](name='rich_texts'),
    sentences?: [ 
      {
        content?: string(name='content'),
        meta?: map[string]string(name='meta'),
      }
    ](name='sentences'),
  }(name='result'),
  usage?: {
    tokenCount?: long(name='token_count'),
  }(name='usage'),
}

model GetDocumentSplitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDocumentSplitResponseBody(name='body'),
}

/**
 * @summary 文档切片
 *
 * @param request GetDocumentSplitRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDocumentSplitResponse
 */
async function getDocumentSplitWithOptions(workspaceName: string, serviceId: string, request: GetDocumentSplitRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetDocumentSplitResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.document)) {
    body['document'] = request.document;
  }
  if (!Util.isUnset(request.strategy)) {
    body['strategy'] = request.strategy;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDocumentSplit',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/document-split/${serviceId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 文档切片
 *
 * @param request GetDocumentSplitRequest
 * @return GetDocumentSplitResponse
 */
async function getDocumentSplit(workspaceName: string, serviceId: string, request: GetDocumentSplitRequest): GetDocumentSplitResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDocumentSplitWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetImageAnalyzeTaskStatusRequest {
  taskId?: string(name='task_id', description='This parameter is required.'),
}

model GetImageAnalyzeTaskStatusResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    data?: {
      content?: string(name='content'),
      contentType?: string(name='content_type'),
      pageNum?: int32(name='page_num'),
    }(name='data'),
    error?: string(name='error'),
    status?: string(name='status'),
    taskId?: string(name='task_id'),
  }(name='result'),
  usage?: {
    pvCount?: long(name='pv_count'),
    tokenCount?: long(name='token_count'),
  }(name='usage'),
}

model GetImageAnalyzeTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetImageAnalyzeTaskStatusResponseBody(name='body'),
}

/**
 * @summary 获取图片解析异步提取任务状态
 *
 * @param request GetImageAnalyzeTaskStatusRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetImageAnalyzeTaskStatusResponse
 */
async function getImageAnalyzeTaskStatusWithOptions(workspaceName: string, serviceId: string, request: GetImageAnalyzeTaskStatusRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetImageAnalyzeTaskStatusResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.taskId)) {
    query['task_id'] = request.taskId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetImageAnalyzeTaskStatus',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/image-analyze/${serviceId}/async/task-status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 获取图片解析异步提取任务状态
 *
 * @param request GetImageAnalyzeTaskStatusRequest
 * @return GetImageAnalyzeTaskStatusResponse
 */
async function getImageAnalyzeTaskStatus(workspaceName: string, serviceId: string, request: GetImageAnalyzeTaskStatusRequest): GetImageAnalyzeTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getImageAnalyzeTaskStatusWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetQueryAnalysisRequest {
  functions?: [ 
    {
      name?: string(name='name'),
      parameters?: map[string]any(name='parameters'),
    }
  ](name='functions'),
  history?: [ 
    {
      content?: string(name='content'),
      role?: string(name='role'),
    }
  ](name='history'),
  query?: string(name='query', description='This parameter is required.'),
}

model GetQueryAnalysisResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    intent?: string(name='intent'),
    queries?: [ string ](name='queries'),
    query?: string(name='query'),
    sql?: map[string]any(name='sql'),
  }(name='result'),
  usage?: {
    inputTokens?: long(name='input_tokens'),
    outputTokens?: long(name='output_tokens'),
    totalTokens?: long(name='total_tokens'),
  }(name='usage'),
}

model GetQueryAnalysisResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQueryAnalysisResponseBody(name='body'),
}

/**
 * @summary 获取query分析结果
 *
 * @param request GetQueryAnalysisRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetQueryAnalysisResponse
 */
async function getQueryAnalysisWithOptions(workspaceName: string, serviceId: string, request: GetQueryAnalysisRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetQueryAnalysisResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.functions)) {
    body['functions'] = request.functions;
  }
  if (!Util.isUnset(request.history)) {
    body['history'] = request.history;
  }
  if (!Util.isUnset(request.query)) {
    body['query'] = request.query;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetQueryAnalysis',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/query-analyze/${serviceId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 获取query分析结果
 *
 * @param request GetQueryAnalysisRequest
 * @return GetQueryAnalysisResponse
 */
async function getQueryAnalysis(workspaceName: string, serviceId: string, request: GetQueryAnalysisRequest): GetQueryAnalysisResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getQueryAnalysisWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetTextEmbeddingRequest {
  input?: [ string ](name='input', description='This parameter is required.'),
  inputType?: string(name='input_type', example='document'),
}

model GetTextEmbeddingResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    embeddings?: [ 
      {
        embedding?: [ double ](name='embedding'),
        index?: int32(name='index'),
      }
    ](name='embeddings'),
  }(name='result'),
  usage?: {
    tokenCount?: long(name='token_count'),
  }(name='usage'),
}

model GetTextEmbeddingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTextEmbeddingResponseBody(name='body'),
}

/**
 * @summary 文本向量化
 *
 * @param request GetTextEmbeddingRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTextEmbeddingResponse
 */
async function getTextEmbeddingWithOptions(workspaceName: string, serviceId: string, request: GetTextEmbeddingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTextEmbeddingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.input)) {
    body['input'] = request.input;
  }
  if (!Util.isUnset(request.inputType)) {
    body['input_type'] = request.inputType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTextEmbedding',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/text-embedding/${serviceId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 文本向量化
 *
 * @param request GetTextEmbeddingRequest
 * @return GetTextEmbeddingResponse
 */
async function getTextEmbedding(workspaceName: string, serviceId: string, request: GetTextEmbeddingRequest): GetTextEmbeddingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTextEmbeddingWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetTextGenerationRequest {
  csiLevel?: string(name='csi_level'),
  messages?: [ 
    {
      content?: string(name='content'),
      role?: string(name='role'),
    }
  ](name='messages', description='This parameter is required.'),
  parameters?: map[string]string(name='parameters'),
  stream?: boolean(name='stream'),
}

model GetTextGenerationResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    text?: string(name='text'),
  }(name='result'),
  usage?: {
    inputTokens?: long(name='input_tokens'),
    outputTokens?: long(name='output_tokens'),
    totalTokens?: long(name='total_tokens'),
  }(name='usage'),
}

model GetTextGenerationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTextGenerationResponseBody(name='body'),
}

/**
 * @summary 大模型问答
 *
 * @param request GetTextGenerationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTextGenerationResponse
 */
async function getTextGenerationWithOptions(workspaceName: string, serviceId: string, request: GetTextGenerationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTextGenerationResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.csiLevel)) {
    body['csi_level'] = request.csiLevel;
  }
  if (!Util.isUnset(request.messages)) {
    body['messages'] = request.messages;
  }
  if (!Util.isUnset(request.parameters)) {
    body['parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.stream)) {
    body['stream'] = request.stream;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTextGeneration',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/text-generation/${serviceId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 大模型问答
 *
 * @param request GetTextGenerationRequest
 * @return GetTextGenerationResponse
 */
async function getTextGeneration(workspaceName: string, serviceId: string, request: GetTextGenerationRequest): GetTextGenerationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTextGenerationWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetTextSparseEmbeddingRequest {
  input?: [ string ](name='input', description='This parameter is required.'),
  inputType?: string(name='input_type', example='document'),
  returnToken?: boolean(name='return_token'),
}

model GetTextSparseEmbeddingResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    sparseEmbeddings?: [ 
      {
        embedding?: [ 
          {
            token?: string(name='token'),
            tokenId?: int32(name='token_id'),
            weight?: float(name='weight'),
          }
        ](name='embedding'),
        index?: int32(name='index'),
      }
    ](name='sparse_embeddings'),
  }(name='result'),
  usage?: {
    tokenCount?: long(name='token_count'),
  }(name='usage'),
}

model GetTextSparseEmbeddingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTextSparseEmbeddingResponseBody(name='body'),
}

/**
 * @summary 文本稀疏向量化
 *
 * @param request GetTextSparseEmbeddingRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTextSparseEmbeddingResponse
 */
async function getTextSparseEmbeddingWithOptions(workspaceName: string, serviceId: string, request: GetTextSparseEmbeddingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTextSparseEmbeddingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.input)) {
    body['input'] = request.input;
  }
  if (!Util.isUnset(request.inputType)) {
    body['input_type'] = request.inputType;
  }
  if (!Util.isUnset(request.returnToken)) {
    body['return_token'] = request.returnToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTextSparseEmbedding',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/text-sparse-embedding/${serviceId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 文本稀疏向量化
 *
 * @param request GetTextSparseEmbeddingRequest
 * @return GetTextSparseEmbeddingResponse
 */
async function getTextSparseEmbedding(workspaceName: string, serviceId: string, request: GetTextSparseEmbeddingRequest): GetTextSparseEmbeddingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTextSparseEmbeddingWithOptions(workspaceName, serviceId, request, headers, runtime);
}

