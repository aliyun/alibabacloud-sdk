/**
 *
 */
import GatewayClient;
import OpenApi;
import OpenApi.OpenApiUtil;

extends OpenApi;


init(config: OpenApiUtil.Config){
  super(config);
  @productId = 'Searchplat';
  var gatewayClient = new GatewayClient();
  @spi = gatewayClient;
  @endpointRule = '';
  }

model CreateDocumentAnalyzeTaskRequest {
  document?: {
    content?: string(name='content'),
    fileName?: string(name='file_name'),
    fileType?: string(name='file_type'),
    url?: string(name='url'),
  }(name='document'),
  output?: {
    imageStorage?: string(name='image_storage'),
  }(name='output'),
}

model CreateDocumentAnalyzeTaskResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    taskId?: string(name='task_id'),
  }(name='result'),
}

model CreateDocumentAnalyzeTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDocumentAnalyzeTaskResponseBody(name='body'),
}

/**
 * @summary 创建文档解析异步提取任务
 *
 * @param request CreateDocumentAnalyzeTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDocumentAnalyzeTaskResponse
 */
async function createDocumentAnalyzeTaskWithOptions(workspaceName: string, serviceId: string, request: CreateDocumentAnalyzeTaskRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateDocumentAnalyzeTaskResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.document)) {
    body['document'] = request.document;
  }
  if (!$isNull(request.output)) {
    body['output'] = request.output;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDocumentAnalyzeTask',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/document-analyze/${serviceId}/async`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 创建文档解析异步提取任务
 *
 * @param request CreateDocumentAnalyzeTaskRequest
 * @return CreateDocumentAnalyzeTaskResponse
 */
async function createDocumentAnalyzeTask(workspaceName: string, serviceId: string, request: CreateDocumentAnalyzeTaskRequest): CreateDocumentAnalyzeTaskResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createDocumentAnalyzeTaskWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model CreateImageAnalyzeTaskRequest {
  document?: {
    content?: string(name='content'),
    fileName?: string(name='file_name'),
    fileType?: string(name='file_type'),
    url?: string(name='url'),
  }(name='document'),
}

model CreateImageAnalyzeTaskResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    taskId?: string(name='task_id'),
  }(name='result'),
}

model CreateImageAnalyzeTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateImageAnalyzeTaskResponseBody(name='body'),
}

/**
 * @summary 创建图片解析异步提取任务
 *
 * @param request CreateImageAnalyzeTaskRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateImageAnalyzeTaskResponse
 */
async function createImageAnalyzeTaskWithOptions(workspaceName: string, serviceId: string, request: CreateImageAnalyzeTaskRequest, headers: map[string]string, runtime: $RuntimeOptions): CreateImageAnalyzeTaskResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.document)) {
    body['document'] = request.document;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateImageAnalyzeTask',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/image-analyze/${serviceId}/async`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 创建图片解析异步提取任务
 *
 * @param request CreateImageAnalyzeTaskRequest
 * @return CreateImageAnalyzeTaskResponse
 */
async function createImageAnalyzeTask(workspaceName: string, serviceId: string, request: CreateImageAnalyzeTaskRequest): CreateImageAnalyzeTaskResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return createImageAnalyzeTaskWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetDocumentAnalyzeTaskStatusRequest {
  taskId?: string(name='task_id', description='This parameter is required.'),
}

model GetDocumentAnalyzeTaskStatusResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    data?: {
      content?: string(name='content'),
      contentType?: string(name='content_type'),
      pageNum?: int32(name='page_num'),
    }(name='data'),
    error?: string(name='error'),
    status?: string(name='status'),
    taskId?: string(name='task_id'),
  }(name='result'),
  usage?: {
    imageCount?: long(name='image_count'),
    tableCount?: long(name='table_count'),
    tokenCount?: long(name='token_count'),
  }(name='usage'),
}

model GetDocumentAnalyzeTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDocumentAnalyzeTaskStatusResponseBody(name='body'),
}

/**
 * @summary 获取文档解析异步提取任务状态
 *
 * @param request GetDocumentAnalyzeTaskStatusRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDocumentAnalyzeTaskStatusResponse
 */
async function getDocumentAnalyzeTaskStatusWithOptions(workspaceName: string, serviceId: string, request: GetDocumentAnalyzeTaskStatusRequest, headers: map[string]string, runtime: $RuntimeOptions): GetDocumentAnalyzeTaskStatusResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.taskId)) {
    query['task_id'] = request.taskId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDocumentAnalyzeTaskStatus',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/document-analyze/${serviceId}/async/task-status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 获取文档解析异步提取任务状态
 *
 * @param request GetDocumentAnalyzeTaskStatusRequest
 * @return GetDocumentAnalyzeTaskStatusResponse
 */
async function getDocumentAnalyzeTaskStatus(workspaceName: string, serviceId: string, request: GetDocumentAnalyzeTaskStatusRequest): GetDocumentAnalyzeTaskStatusResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getDocumentAnalyzeTaskStatusWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetDocumentRankRequest {
  docs?: [ string ](name='docs', description='This parameter is required.'),
  query?: string(name='query', description='This parameter is required.'),
}

model GetDocumentRankResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    scores?: [ 
      {
        index?: int32(name='index'),
        score?: double(name='score'),
      }
    ](name='scores'),
  }(name='result'),
  usage?: {
    docCount?: long(name='doc_count'),
  }(name='usage'),
}

model GetDocumentRankResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDocumentRankResponseBody(name='body'),
}

/**
 * @summary 文档相关性打分
 *
 * @param request GetDocumentRankRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDocumentRankResponse
 */
async function getDocumentRankWithOptions(workspaceName: string, serviceId: string, request: GetDocumentRankRequest, headers: map[string]string, runtime: $RuntimeOptions): GetDocumentRankResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.docs)) {
    body['docs'] = request.docs;
  }
  if (!$isNull(request.query)) {
    body['query'] = request.query;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDocumentRank',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/ranker/${serviceId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 文档相关性打分
 *
 * @param request GetDocumentRankRequest
 * @return GetDocumentRankResponse
 */
async function getDocumentRank(workspaceName: string, serviceId: string, request: GetDocumentRankRequest): GetDocumentRankResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getDocumentRankWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetDocumentSplitRequest {
  document?: {
    content?: string(name='content'),
    contentEncoding?: string(name='content_encoding'),
    contentType?: string(name='content_type'),
  }(name='document', description='This parameter is required.'),
  strategy?: {
    computeType?: string(name='compute_type'),
    maxChunkSize?: long(name='max_chunk_size'),
    needSentence?: boolean(name='need_sentence'),
  }(name='strategy'),
}

model GetDocumentSplitResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    chunks?: [ 
      {
        content?: string(name='content'),
        meta?: map[string]string(name='meta'),
      }
    ](name='chunks'),
    nodes?: [ map[string]string ](name='nodes'),
    richTexts?: [ 
      {
        content?: string(name='content'),
        meta?: map[string]string(name='meta'),
      }
    ](name='rich_texts'),
    sentences?: [ 
      {
        content?: string(name='content'),
        meta?: map[string]string(name='meta'),
      }
    ](name='sentences'),
  }(name='result'),
  usage?: {
    tokenCount?: long(name='token_count'),
  }(name='usage'),
}

model GetDocumentSplitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDocumentSplitResponseBody(name='body'),
}

/**
 * @summary 文档切片
 *
 * @param request GetDocumentSplitRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDocumentSplitResponse
 */
async function getDocumentSplitWithOptions(workspaceName: string, serviceId: string, request: GetDocumentSplitRequest, headers: map[string]string, runtime: $RuntimeOptions): GetDocumentSplitResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.document)) {
    body['document'] = request.document;
  }
  if (!$isNull(request.strategy)) {
    body['strategy'] = request.strategy;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDocumentSplit',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/document-split/${serviceId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 文档切片
 *
 * @param request GetDocumentSplitRequest
 * @return GetDocumentSplitResponse
 */
async function getDocumentSplit(workspaceName: string, serviceId: string, request: GetDocumentSplitRequest): GetDocumentSplitResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getDocumentSplitWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetEmbeddingTuningRequest {
  input?: [[ float ]  ](name='input'),
  parameters?: map[string]any(name='parameters'),
}

model GetEmbeddingTuningResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    output?: [[ float ]    ](name='output'),
  }(name='result'),
  usage?: {
    docCount?: int32(name='doc_count'),
  }(name='usage'),
}

model GetEmbeddingTuningResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEmbeddingTuningResponseBody(name='body'),
}

/**
 * @summary 向量微调
 *
 * @param request GetEmbeddingTuningRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEmbeddingTuningResponse
 */
async function getEmbeddingTuningWithOptions(workspaceName: string, serviceId: string, request: GetEmbeddingTuningRequest, headers: map[string]string, runtime: $RuntimeOptions): GetEmbeddingTuningResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.input)) {
    body['input'] = request.input;
  }
  if (!$isNull(request.parameters)) {
    body['parameters'] = request.parameters;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetEmbeddingTuning',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/embedding-tuning/${serviceId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 向量微调
 *
 * @param request GetEmbeddingTuningRequest
 * @return GetEmbeddingTuningResponse
 */
async function getEmbeddingTuning(workspaceName: string, serviceId: string, request: GetEmbeddingTuningRequest): GetEmbeddingTuningResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getEmbeddingTuningWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetImageAnalyzeTaskStatusRequest {
  taskId?: string(name='task_id', description='This parameter is required.'),
}

model GetImageAnalyzeTaskStatusResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    data?: {
      content?: string(name='content'),
      contentType?: string(name='content_type'),
      pageNum?: int32(name='page_num'),
    }(name='data'),
    error?: string(name='error'),
    status?: string(name='status'),
    taskId?: string(name='task_id'),
  }(name='result'),
  usage?: {
    pvCount?: long(name='pv_count'),
    tokenCount?: long(name='token_count'),
  }(name='usage'),
}

model GetImageAnalyzeTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetImageAnalyzeTaskStatusResponseBody(name='body'),
}

/**
 * @summary 获取图片解析异步提取任务状态
 *
 * @param request GetImageAnalyzeTaskStatusRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetImageAnalyzeTaskStatusResponse
 */
async function getImageAnalyzeTaskStatusWithOptions(workspaceName: string, serviceId: string, request: GetImageAnalyzeTaskStatusRequest, headers: map[string]string, runtime: $RuntimeOptions): GetImageAnalyzeTaskStatusResponse {
  request.validate();
  var query : map[string]any = {};
  if (!$isNull(request.taskId)) {
    query['task_id'] = request.taskId;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetImageAnalyzeTaskStatus',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/image-analyze/${serviceId}/async/task-status`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 获取图片解析异步提取任务状态
 *
 * @param request GetImageAnalyzeTaskStatusRequest
 * @return GetImageAnalyzeTaskStatusResponse
 */
async function getImageAnalyzeTaskStatus(workspaceName: string, serviceId: string, request: GetImageAnalyzeTaskStatusRequest): GetImageAnalyzeTaskStatusResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getImageAnalyzeTaskStatusWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetPredictionHeaders {
  commonHeaders?: map[string]string,
  token?: string(name='Token'),
}

model GetPredictionRequest {
  body?: string(name='body'),
}

model GetPredictionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: string(name='body'),
}

/**
 * @summary 获取推理结果
 *
 * @param request GetPredictionRequest
 * @param headers GetPredictionHeaders
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPredictionResponse
 */
async function getPredictionWithOptions(deploymentId: string, request: GetPredictionRequest, headers: GetPredictionHeaders, runtime: $RuntimeOptions): GetPredictionResponse {
  request.validate();
  var realHeaders : map[string]string = {};
  if (!$isNull(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!$isNull(headers.token)) {
    realHeaders['Token'] = $string(headers.token);
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = realHeaders,
    body = request.body,
  };
  var params = new OpenApiUtil.Params{
    action = 'GetPrediction',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/deployments/${deploymentId}/predict`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'string',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 获取推理结果
 *
 * @param request GetPredictionRequest
 * @return GetPredictionResponse
 */
async function getPrediction(deploymentId: string, request: GetPredictionRequest): GetPredictionResponse {
  var runtime = new $RuntimeOptions{};
  var headers = new GetPredictionHeaders{};
  return getPredictionWithOptions(deploymentId, request, headers, runtime);
}

model GetQueryAnalysisRequest {
  functions?: [ 
    {
      name?: string(name='name'),
      parameters?: map[string]any(name='parameters'),
    }
  ](name='functions'),
  history?: [ 
    {
      content?: string(name='content'),
      role?: string(name='role'),
    }
  ](name='history'),
  query?: string(name='query', description='This parameter is required.'),
}

model GetQueryAnalysisResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    intent?: string(name='intent'),
    queries?: [ string ](name='queries'),
    query?: string(name='query'),
    sql?: map[string]any(name='sql'),
  }(name='result'),
  usage?: {
    inputTokens?: long(name='input_tokens'),
    outputTokens?: long(name='output_tokens'),
    totalTokens?: long(name='total_tokens'),
  }(name='usage'),
}

model GetQueryAnalysisResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQueryAnalysisResponseBody(name='body'),
}

/**
 * @summary 获取query分析结果
 *
 * @param request GetQueryAnalysisRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetQueryAnalysisResponse
 */
async function getQueryAnalysisWithOptions(workspaceName: string, serviceId: string, request: GetQueryAnalysisRequest, headers: map[string]string, runtime: $RuntimeOptions): GetQueryAnalysisResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.functions)) {
    body['functions'] = request.functions;
  }
  if (!$isNull(request.history)) {
    body['history'] = request.history;
  }
  if (!$isNull(request.query)) {
    body['query'] = request.query;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetQueryAnalysis',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/query-analyze/${serviceId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 获取query分析结果
 *
 * @param request GetQueryAnalysisRequest
 * @return GetQueryAnalysisResponse
 */
async function getQueryAnalysis(workspaceName: string, serviceId: string, request: GetQueryAnalysisRequest): GetQueryAnalysisResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getQueryAnalysisWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetTextEmbeddingRequest {
  input?: [ string ](name='input', description='This parameter is required.'),
  inputType?: string(name='input_type', example='document'),
}

model GetTextEmbeddingResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    embeddings?: [ 
      {
        embedding?: [ double ](name='embedding'),
        index?: int32(name='index'),
      }
    ](name='embeddings'),
  }(name='result'),
  usage?: {
    tokenCount?: long(name='token_count'),
  }(name='usage'),
}

model GetTextEmbeddingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTextEmbeddingResponseBody(name='body'),
}

/**
 * @summary 文本向量化
 *
 * @param request GetTextEmbeddingRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTextEmbeddingResponse
 */
async function getTextEmbeddingWithOptions(workspaceName: string, serviceId: string, request: GetTextEmbeddingRequest, headers: map[string]string, runtime: $RuntimeOptions): GetTextEmbeddingResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.input)) {
    body['input'] = request.input;
  }
  if (!$isNull(request.inputType)) {
    body['input_type'] = request.inputType;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetTextEmbedding',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/text-embedding/${serviceId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 文本向量化
 *
 * @param request GetTextEmbeddingRequest
 * @return GetTextEmbeddingResponse
 */
async function getTextEmbedding(workspaceName: string, serviceId: string, request: GetTextEmbeddingRequest): GetTextEmbeddingResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getTextEmbeddingWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetTextGenerationRequest {
  csiLevel?: string(name='csi_level'),
  enableSearch?: boolean(name='enable_search'),
  messages?: [ 
    {
      content?: string(name='content'),
      role?: string(name='role'),
    }
  ](name='messages', description='This parameter is required.'),
  parameters?: map[string]any(name='parameters'),
  stream?: boolean(name='stream'),
}

model GetTextGenerationResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    searchResults?: [ 
      {
        title?: string(name='title'),
        url?: string(name='url'),
      }
    ](name='search_results'),
    text?: string(name='text'),
  }(name='result'),
  usage?: {
    inputTokens?: long(name='input_tokens'),
    outputTokens?: long(name='output_tokens'),
    totalTokens?: long(name='total_tokens'),
  }(name='usage'),
}

model GetTextGenerationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTextGenerationResponseBody(name='body'),
}

/**
 * @summary 大模型问答
 *
 * @param request GetTextGenerationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTextGenerationResponse
 */
async function getTextGenerationWithOptions(workspaceName: string, serviceId: string, request: GetTextGenerationRequest, headers: map[string]string, runtime: $RuntimeOptions): GetTextGenerationResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.csiLevel)) {
    body['csi_level'] = request.csiLevel;
  }
  if (!$isNull(request.enableSearch)) {
    body['enable_search'] = request.enableSearch;
  }
  if (!$isNull(request.messages)) {
    body['messages'] = request.messages;
  }
  if (!$isNull(request.parameters)) {
    body['parameters'] = request.parameters;
  }
  if (!$isNull(request.stream)) {
    body['stream'] = request.stream;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetTextGeneration',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/text-generation/${serviceId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 大模型问答
 *
 * @param request GetTextGenerationRequest
 * @return GetTextGenerationResponse
 */
async function getTextGeneration(workspaceName: string, serviceId: string, request: GetTextGenerationRequest): GetTextGenerationResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getTextGenerationWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetTextSparseEmbeddingRequest {
  input?: [ string ](name='input', description='This parameter is required.'),
  inputType?: string(name='input_type', example='document'),
  returnToken?: boolean(name='return_token'),
}

model GetTextSparseEmbeddingResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    sparseEmbeddings?: [ 
      {
        embedding?: [ 
          {
            token?: string(name='token'),
            tokenId?: int32(name='token_id'),
            weight?: float(name='weight'),
          }
        ](name='embedding'),
        index?: int32(name='index'),
      }
    ](name='sparse_embeddings'),
  }(name='result'),
  usage?: {
    tokenCount?: long(name='token_count'),
  }(name='usage'),
}

model GetTextSparseEmbeddingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTextSparseEmbeddingResponseBody(name='body'),
}

/**
 * @summary 文本稀疏向量化
 *
 * @param request GetTextSparseEmbeddingRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTextSparseEmbeddingResponse
 */
async function getTextSparseEmbeddingWithOptions(workspaceName: string, serviceId: string, request: GetTextSparseEmbeddingRequest, headers: map[string]string, runtime: $RuntimeOptions): GetTextSparseEmbeddingResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.input)) {
    body['input'] = request.input;
  }
  if (!$isNull(request.inputType)) {
    body['input_type'] = request.inputType;
  }
  if (!$isNull(request.returnToken)) {
    body['return_token'] = request.returnToken;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetTextSparseEmbedding',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/text-sparse-embedding/${serviceId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 文本稀疏向量化
 *
 * @param request GetTextSparseEmbeddingRequest
 * @return GetTextSparseEmbeddingResponse
 */
async function getTextSparseEmbedding(workspaceName: string, serviceId: string, request: GetTextSparseEmbeddingRequest): GetTextSparseEmbeddingResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getTextSparseEmbeddingWithOptions(workspaceName, serviceId, request, headers, runtime);
}

model GetWebSearchRequest {
  query?: string(name='query', description='This parameter is required.'),
  topK?: long(name='top_k'),
  way?: string(name='way'),
}

model GetWebSearchResponseBody = {
  latency?: int32(name='latency'),
  requestId?: string(name='request_id'),
  result?: {
    searchResult?: [ 
      {
        content?: string(name='content'),
        link?: string(name='link'),
        position?: long(name='position'),
        snippet?: string(name='snippet'),
        tilte?: string(name='tilte'),
      }
    ](name='search_result'),
  }(name='result'),
  usage?: {
    filterModel?: {
      inputTokens?: long(name='input_tokens'),
      outputTokens?: long(name='output_tokens'),
      totalTokens?: long(name='total_tokens'),
    }(name='filter_model'),
    rewriteModel?: {
      inputTokens?: long(name='input_tokens'),
      outputTokens?: long(name='output_tokens'),
      totalTokens?: long(name='total_tokens'),
    }(name='rewrite_model'),
    searchCount?: long(name='search_count'),
  }(name='usage'),
}

model GetWebSearchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetWebSearchResponseBody(name='body'),
}

/**
 * @summary 联网搜索
 *
 * @param request GetWebSearchRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetWebSearchResponse
 */
async function getWebSearchWithOptions(workspaceName: string, serviceId: string, request: GetWebSearchRequest, headers: map[string]string, runtime: $RuntimeOptions): GetWebSearchResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.query)) {
    body['query'] = request.query;
  }
  if (!$isNull(request.topK)) {
    body['top_k'] = request.topK;
  }
  if (!$isNull(request.way)) {
    body['way'] = request.way;
  }

  var req = new OpenApiUtil.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetWebSearch',
    version = '2024-05-29',
    protocol = 'HTTPS',
    pathname = `/v3/openapi/workspaces/${workspaceName}/web-search/${serviceId}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return execute(params, req, runtime);
}

/**
 * @summary 联网搜索
 *
 * @param request GetWebSearchRequest
 * @return GetWebSearchResponse
 */
async function getWebSearch(workspaceName: string, serviceId: string, request: GetWebSearchRequest): GetWebSearchResponse {
  var runtime = new $RuntimeOptions{};
  var headers : map[string]string = {};
  return getWebSearchWithOptions(workspaceName, serviceId, request, headers, runtime);
}

