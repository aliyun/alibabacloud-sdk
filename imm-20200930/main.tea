/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing-gov-1 = 'imm-vpc.cn-beijing-gov-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('imm', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model Address {
  addressLine?: string(name='AddressLine', description='AddressLine'),
  city?: string(name='City', description='City'),
  country?: string(name='Country', description='Country'),
  district?: string(name='District', description='District'),
  language?: string(name='Language', description='Language'),
  province?: string(name='Province', description='Province'),
  township?: string(name='Township', description='Township'),
}

model AssumeRoleChain {
  chain?: [
    AssumeRoleChainNode
  ](name='Chain', description='链式授权节点'),
  policy?: string(name='Policy', description='当前用户 policy'),
}

model AssumeRoleChainNode {
  ownerId?: string(name='OwnerId', description='账号id'),
  role?: string(name='Role', description='授权角色名'),
  type?: string(name='Type', description='账号类型，普通账号填 user，服务账号填 service'),
}

model AudioStream {
  bitrate?: long(name='Bitrate', description='Bitrate'),
  channelLayout?: string(name='ChannelLayout', description='ChannelLayout'),
  channels?: long(name='Channels', description='Channels'),
  codecLongName?: string(name='CodecLongName', description='CodecLongName'),
  codecName?: string(name='CodecName', description='CodecName'),
  codecTag?: string(name='CodecTag', description='CodecTag'),
  codecTagString?: string(name='CodecTagString', description='CodecTagString'),
  codecTimeBase?: string(name='CodecTimeBase', description='CodecTimeBase'),
  duration?: double(name='Duration', description='Duration'),
  frameCount?: long(name='FrameCount', description='FrameCount'),
  index?: long(name='Index', description='Index'),
  language?: string(name='Language', description='Language'),
  lyric?: string(name='Lyric', description='Lyric'),
  sampleFormat?: string(name='SampleFormat', description='SampleFormat'),
  sampleRate?: long(name='SampleRate', description='SampleRate'),
  startTime?: double(name='StartTime', description='StartTime'),
  timeBase?: string(name='TimeBase', description='TimeBase'),
}

model Binding {
  createTime?: string(name='CreateTime', description='CreateTime'),
  datasetName?: string(name='DatasetName', description='DatasetName'),
  detail?: string(name='Detail', description='Detail'),
  phase?: string(name='Phase', description='Phase'),
  projectName?: string(name='ProjectName', description='ProjectName'),
  state?: string(name='State', description='State'),
  URI?: string(name='URI', description='URI'),
  updateTime?: string(name='UpdateTime', description='UpdateTime'),
}

model Boundary {
  height?: long(name='Height', description='Height'),
  left?: long(name='Left', description='Left'),
  top?: long(name='Top', description='Top'),
  width?: long(name='Width', description='Width'),
}

model ClusterForReq {
  cover?: {
    figures?: [ 
      {
        figureId?: string(name='FigureId', description='FigureId'),
      }
    ](name='Figures', description='Figures'),
  }(name='Cover', description='Cover'),
  customId?: string(name='CustomId', description='CustomId'),
  customLabels?: map[string]any(name='CustomLabels', description='CustomLabels'),
  name?: string(name='Name', description='Name'),
  objectId?: string(name='ObjectId', description='ObjectId'),
}

model Codes {
  boundary?: Boundary(name='Boundary', description='Boundary'),
  confidence?: float(name='Confidence', description='Confidence'),
  content?: string(name='Content', description='Content'),
  type?: string(name='Type', description='Type'),
}

model CredentialConfig {
  chain?: [ 
    {
      assumeRoleFor?: string(name='AssumeRoleFor', description='授权对象'),
      role?: string(name='Role', description='授权角色'),
      roleType?: string(name='RoleType', description='授权方类型'),
    }
  ](name='Chain', description='授权链'),
  policy?: string(name='Policy', description='权限策略'),
  serviceRole?: string(name='ServiceRole', description='服务角色'),
}

model CroppingSuggestion {
  aspectRatio?: string(name='AspectRatio', description='AspectRatio'),
  boundary?: Boundary(name='Boundary', description='Boundary'),
  confidence?: float(name='Confidence', description='Confidence'),
}

model Dataset {
  bindCount?: long(name='BindCount', description='媒体集当前绑定数'),
  createTime?: string(name='CreateTime', description='创建时间'),
  datasetMaxBindCount?: long(name='DatasetMaxBindCount', description='媒体集最大绑定数'),
  datasetMaxEntityCount?: long(name='DatasetMaxEntityCount', description='媒体集最多实体数量'),
  datasetMaxFileCount?: long(name='DatasetMaxFileCount', description='媒体集最多文件数量'),
  datasetMaxRelationCount?: long(name='DatasetMaxRelationCount', description='媒体集最多关系数量'),
  datasetMaxTotalFileSize?: long(name='DatasetMaxTotalFileSize', description='媒体集最大文件总大小'),
  datasetName?: string(name='DatasetName', description='媒体集名称'),
  description?: string(name='Description', description='描述'),
  fileCount?: long(name='FileCount', description='媒体集当前文件数'),
  projectName?: string(name='ProjectName', description='项目名称'),
  totalFileSize?: long(name='TotalFileSize', description='媒体集当前文件总大小'),
  updateTime?: string(name='UpdateTime', description='更新时间'),
}

model Figure {
  age?: long(name='Age', description='Age'),
  ageSD?: float(name='AgeSD', description='AgeSD'),
  attractive?: float(name='Attractive', description='Attractive'),
  beard?: string(name='Beard', description='Beard'),
  beardConfidence?: float(name='BeardConfidence', description='BeardConfidence'),
  boundary?: Boundary(name='Boundary', description='Boundary'),
  emotion?: string(name='Emotion', description='Emotion'),
  emotionConfidence?: float(name='EmotionConfidence', description='EmotionConfidence'),
  faceQuality?: float(name='FaceQuality', description='FaceQuality'),
  figureClusterConfidence?: float(name='FigureClusterConfidence', description='FigureClusterConfidence'),
  figureClusterId?: string(name='FigureClusterId', description='FigureClusterId'),
  figureConfidence?: float(name='FigureConfidence', description='FigureConfidence'),
  figureId?: string(name='FigureId', description='FigureId'),
  figureType?: string(name='FigureType', description='FigureType'),
  gender?: string(name='Gender', description='Gender'),
  genderConfidence?: float(name='GenderConfidence', description='GenderConfidence'),
  glasses?: string(name='Glasses', description='Glasses'),
  glassesConfidence?: float(name='GlassesConfidence', description='GlassesConfidence'),
  hat?: string(name='Hat', description='Hat'),
  hatConfidence?: float(name='HatConfidence', description='HatConfidence'),
  headPose?: HeadPose(name='HeadPose'),
  mask?: string(name='Mask', description='Mask'),
  maskConfidence?: float(name='MaskConfidence', description='MaskConfidence'),
  mouth?: string(name='Mouth', description='Mouth'),
  mouthConfidence?: float(name='MouthConfidence', description='MouthConfidence'),
  sharpness?: float(name='Sharpness', description='Sharpness'),
}

model FigureCluster {
  averageAge?: float(name='AverageAge', description='AverageAge'),
  cover?: File(name='Cover', description='Cover'),
  createTime?: string(name='CreateTime', description='CreateTime'),
  customId?: string(name='CustomId', description='CustomId'),
  customLabels?: map[string]any(name='CustomLabels', description='CustomLabels'),
  datasetName?: string(name='DatasetName', description='DatasetName'),
  faceCount?: long(name='FaceCount', description='FaceCount'),
  gender?: string(name='Gender', description='Gender'),
  imageCount?: long(name='ImageCount', description='ImageCount'),
  maxAge?: float(name='MaxAge', description='MaxAge'),
  minAge?: float(name='MinAge', description='MinAge'),
  name?: string(name='Name', description='Name'),
  objectId?: string(name='ObjectId', description='ObjectId'),
  objectType?: string(name='ObjectType', description='ObjectType'),
  ownerId?: string(name='OwnerId', description='OwnerId'),
  projectName?: string(name='ProjectName', description='ProjectName'),
  updateTime?: string(name='UpdateTime', description='UpdateTime'),
  videoCount?: long(name='VideoCount', description='VideoCount'),
}

model FigureClusterForReq {
  cover?: {
    figures?: [ 
      {
        figureId?: string(name='FigureId', description='FigureId'),
      }
    ](name='Figures', description='Figures'),
  }(name='Cover', description='Cover'),
  customId?: string(name='CustomId', description='CustomId'),
  customLabels?: map[string]any(name='CustomLabels', description='CustomLabels'),
  name?: string(name='Name', description='Name'),
  objectId?: string(name='ObjectId', description='ObjectId'),
}

model File {
  accessControlAllowOrigin?: string(name='AccessControlAllowOrigin', description='AccessControlAllowOrigin'),
  accessControlRequestMethod?: string(name='AccessControlRequestMethod', description='AccessControlRequestMethod'),
  addresses?: [
    Address
  ](name='Addresses', description='Addresses'),
  album?: string(name='Album', description='Album'),
  albumArtist?: string(name='AlbumArtist', description='AlbumArtist'),
  artist?: string(name='Artist', description='Artist'),
  audioCovers?: [
    Image
  ](name='AudioCovers', description='AudioCovers'),
  audioStreams?: [
    AudioStream
  ](name='AudioStreams', description='AudioStreams'),
  bitrate?: long(name='Bitrate', description='Bitrate'),
  cacheControl?: string(name='CacheControl', description='CacheControl'),
  composer?: string(name='Composer', description='Composer'),
  contentDisposition?: string(name='ContentDisposition', description='ContentDisposition'),
  contentEncoding?: string(name='ContentEncoding', description='ContentEncoding'),
  contentLanguage?: string(name='ContentLanguage', description='ContentLanguage'),
  contentMd5?: string(name='ContentMd5', description='ContentMd5'),
  contentType?: string(name='ContentType', description='ContentType'),
  createTime?: string(name='CreateTime', description='CreateTime'),
  croppingSuggestions?: [
    CroppingSuggestion
  ](name='CroppingSuggestions', description='CroppingSuggestions'),
  customId?: string(name='CustomId', description='CustomId'),
  customLabels?: map[string]any(name='CustomLabels', description='CustomLabels'),
  datasetName?: string(name='DatasetName', description='DatasetName'),
  documentContent?: string(name='DocumentContent', description='DocumentContent'),
  documentLanguage?: string(name='DocumentLanguage', description='DocumentLanguage'),
  duration?: double(name='Duration', description='Duration'),
  ETag?: string(name='ETag', description='ETag'),
  EXIF?: string(name='EXIF', description='EXIF'),
  figureCount?: long(name='FigureCount', description='FigureCount'),
  figures?: [
    Figure
  ](name='Figures', description='Figures'),
  fileAccessTime?: string(name='FileAccessTime', description='FileAccessTime'),
  fileCreateTime?: string(name='FileCreateTime', description='FileCreateTime'),
  fileHash?: string(name='FileHash', description='FileHash'),
  fileModifiedTime?: string(name='FileModifiedTime', description='FileModifiedTime'),
  filename?: string(name='Filename', description='Filename'),
  formatLongName?: string(name='FormatLongName', description='FormatLongName'),
  formatName?: string(name='FormatName', description='FormatName'),
  imageHeight?: long(name='ImageHeight', description='ImageHeight'),
  imageScore?: ImageScore(name='ImageScore'),
  imageWidth?: long(name='ImageWidth', description='ImageWidth'),
  labels?: [
    Label
  ](name='Labels', description='Labels'),
  language?: string(name='Language', description='Language'),
  latLong?: string(name='LatLong', description='LatLong'),
  mediaType?: string(name='MediaType', description='MediaType'),
  OCRContents?: [
    OCRContents
  ](name='OCRContents', description='OCRContents'),
  OSSCRC64?: string(name='OSSCRC64', description='OSSCRC64'),
  OSSDeleteMarker?: string(name='OSSDeleteMarker', description='OSSDeleteMarker'),
  OSSExpiration?: string(name='OSSExpiration', description='OSSExpiration'),
  OSSObjectType?: string(name='OSSObjectType', description='OSSObjectType'),
  OSSStorageClass?: string(name='OSSStorageClass', description='OSSStorageClass'),
  OSSTagging?: map[string]any(name='OSSTagging', description='OSSTagging'),
  OSSTaggingCount?: long(name='OSSTaggingCount', description='OSSTaggingCount'),
  OSSURI?: string(name='OSSURI', description='OSSURI'),
  OSSUserMeta?: map[string]any(name='OSSUserMeta', description='OSSUserMeta'),
  OSSVersionId?: string(name='OSSVersionId', description='OSSVersionId'),
  objectACL?: string(name='ObjectACL', description='ObjectACL'),
  objectId?: string(name='ObjectId', description='ObjectId'),
  objectType?: string(name='ObjectType', description='ObjectType'),
  orientation?: long(name='Orientation', description='Orientation'),
  ownerId?: string(name='OwnerId', description='OwnerId'),
  pageCount?: long(name='PageCount', description='PageCount'),
  performer?: string(name='Performer', description='Performer'),
  produceTime?: string(name='ProduceTime', description='ProduceTime'),
  programCount?: long(name='ProgramCount', description='ProgramCount'),
  projectName?: string(name='ProjectName', description='ProjectName'),
  serverSideDataEncryption?: string(name='ServerSideDataEncryption', description='ServerSideDataEncryption'),
  serverSideEncryption?: string(name='ServerSideEncryption', description='ServerSideEncryption'),
  serverSideEncryptionCustomerAlgorithm?: string(name='ServerSideEncryptionCustomerAlgorithm', description='ServerSideEncryptionCustomerAlgorithm'),
  serverSideEncryptionKeyId?: string(name='ServerSideEncryptionKeyId', description='ServerSideEncryptionKeyId'),
  size?: long(name='Size', description='Size'),
  startTime?: double(name='StartTime', description='StartTime'),
  streamCount?: long(name='StreamCount', description='StreamCount'),
  subtitles?: [
    SubtitleStream
  ](name='Subtitles', description='Subtitles'),
  timezone?: string(name='Timezone', description='Timezone'),
  title?: string(name='Title', description='Title'),
  travelClusterId?: string(name='TravelClusterId', description='TravelClusterId'),
  URI?: string(name='URI', description='URI'),
  updateTime?: string(name='UpdateTime', description='UpdateTime'),
  videoHeight?: long(name='VideoHeight', description='VideoHeight'),
  videoStreams?: [
    VideoStream
  ](name='VideoStreams', description='VideoStreams'),
  videoWidth?: long(name='VideoWidth', description='VideoWidth'),
}

model FileForReq {
  contentType?: string(name='ContentType', description='ContentType'),
  customId?: string(name='CustomId', description='CustomId'),
  customLabels?: map[string]any(name='CustomLabels', description='CustomLabels'),
  figures?: [ 
    {
      figureClusterId?: string(name='FigureClusterId', description='FigureClusterId'),
      figureId?: string(name='FigureId', description='FigureId'),
      figureType?: string(name='FigureType', description='FigureType'),
    }
  ](name='Figures', description='Figures'),
  fileHash?: string(name='FileHash', description='FileHash'),
  mediaType?: string(name='MediaType', description='MediaType'),
  OSSURI?: string(name='OSSURI', description='OSSURI'),
  URI?: string(name='URI', description='URI'),
}

model HeadPose {
  pitch?: float(name='Pitch', description='Pitch'),
  roll?: float(name='Roll', description='Roll'),
  yaw?: float(name='Yaw', description='Yaw'),
}

model Image {
  croppingSuggestions?: [
    CroppingSuggestion
  ](name='CroppingSuggestions', description='CroppingSuggestions'),
  EXIF?: string(name='EXIF', description='EXIF'),
  imageHeight?: long(name='ImageHeight', description='ImageHeight'),
  imageScore?: ImageScore(name='ImageScore'),
  imageWidth?: long(name='ImageWidth', description='ImageWidth'),
  OCRContents?: [
    OCRContents
  ](name='OCRContents', description='OCRContents'),
}

model ImageScore {
  overallQualityScore?: float(name='OverallQualityScore', description='OverallQualityScore'),
}

model KeyValuePair {
  key?: string(name='Key', description='键'),
  value?: string(name='Value', description='值'),
}

model Label {
  centricScore?: float(name='CentricScore', description='CentricScore'),
  labelConfidence?: float(name='LabelConfidence', description='LabelConfidence'),
  labelLevel?: long(name='LabelLevel', description='LabelLevel'),
  labelName?: string(name='LabelName', description='LabelName'),
  language?: string(name='Language', description='Language'),
  parentLabelName?: string(name='ParentLabelName', description='ParentLabelName'),
}

model OCRContents {
  boundary?: Boundary(name='Boundary', description='Boundary'),
  confidence?: float(name='Confidence', description='Confidence'),
  contents?: string(name='Contents', description='Contents'),
  language?: string(name='Language', description='Language'),
}

model PresetReference {
  name?: string(name='Name', description='名称'),
  type?: string(name='Type', description='类型'),
}

model Project {
  createTime?: string(name='CreateTime', description='创建时间'),
  datasetCount?: long(name='DatasetCount', description='项目当前媒体集数'),
  datasetMaxBindCount?: long(name='DatasetMaxBindCount', description='项目最多绑定数'),
  datasetMaxEntityCount?: long(name='DatasetMaxEntityCount', description='项目最多实体数'),
  datasetMaxFileCount?: long(name='DatasetMaxFileCount', description='项目最多文件数'),
  datasetMaxRelationCount?: long(name='DatasetMaxRelationCount', description='项目最多关系数'),
  datasetMaxTotalFileSize?: long(name='DatasetMaxTotalFileSize', description='项目最大文件总大小'),
  description?: string(name='Description', description='描述'),
  engineConcurrency?: long(name='EngineConcurrency', description='项目最大并发数'),
  fileCount?: long(name='FileCount', description='项目当前文件数'),
  projectMaxDatasetCount?: long(name='ProjectMaxDatasetCount', description='项目最多媒体集数量'),
  projectName?: string(name='ProjectName', description='项目名称'),
  projectQueriesPerSecond?: long(name='ProjectQueriesPerSecond', description='项目QPS'),
  serviceRole?: string(name='ServiceRole', description='服务角色'),
  totalFileSize?: long(name='TotalFileSize', description='项目当前文件总大小'),
  updateTime?: string(name='UpdateTime', description='更新时间'),
}

model RegionType {
  localName?: string(name='LocalName', description='LocalName'),
  regionId?: string(name='RegionId', description='RegionId'),
}

model Row {
  customLabels?: [
    KeyValuePair
  ](name='CustomLabels', description='CustomLabels'),
  URI?: string(name='URI', description='URI'),
}

model SimpleQuery {
  field?: string(name='Field', description='需要查询的字段名'),
  operation?: string(name='Operation', description='运算符'),
  subQueries?: [
    SimpleQuery
  ](name='SubQueries', description='由 SimpleQuery 结构体组成的子查询数组'),
  value?: string(name='Value', description='需要查询的字段值'),
}

model Story {
  cover?: File(name='Cover'),
  createTime?: string(name='CreateTime', description='CreateTime'),
  customId?: string(name='CustomId', description='CustomId'),
  customLabels?: map[string]any(name='CustomLabels', description='CustomLabels'),
  datasetName?: string(name='DatasetName', description='DatasetName'),
  figureClusterIds?: [ string ](name='FigureClusterIds', description='FigureClusterIds'),
  files?: [
    File
  ](name='Files', description='Files'),
  objectId?: string(name='ObjectId', description='ObjectId'),
  objectType?: string(name='ObjectType', description='ObjectType'),
  ownerId?: string(name='OwnerId', description='OwnerId'),
  projectName?: string(name='ProjectName', description='ProjectName'),
  storyEndTime?: string(name='StoryEndTime', description='StoryEndTime'),
  storyName?: string(name='StoryName', description='StoryName'),
  storyStartTime?: string(name='StoryStartTime', description='StoryStartTime'),
  storySubType?: string(name='StorySubType', description='StorySubType'),
  storyType?: string(name='StoryType', description='StoryType'),
  updateTime?: string(name='UpdateTime', description='UpdateTime'),
}

model SubtitleStream {
  bitrate?: long(name='Bitrate', description='Bitrate'),
  codecLongName?: string(name='CodecLongName', description='CodecLongName'),
  codecName?: string(name='CodecName', description='CodecName'),
  codecTag?: string(name='CodecTag', description='CodecTag'),
  codecTagString?: string(name='CodecTagString', description='CodecTagString'),
  content?: string(name='Content', description='Content'),
  duration?: double(name='Duration', description='Duration'),
  height?: long(name='Height', description='Height'),
  index?: long(name='Index', description='Index'),
  language?: string(name='Language', description='Language'),
  startTime?: double(name='StartTime', description='StartTime'),
  width?: long(name='Width', description='Width'),
}

model TaskInfo {
  code?: string(name='Code', description='错误码'),
  endTime?: string(name='EndTime', description='任务结束时间'),
  message?: string(name='Message', description='错误消息'),
  startTime?: string(name='StartTime', description='任务开始时间'),
  status?: string(name='Status', description='任务状态'),
  tags?: map[string]any(name='Tags', description='标签'),
  taskId?: string(name='TaskId', description='任务唯一ID'),
  taskType?: string(name='TaskType', description='任务类型'),
  userData?: string(name='UserData', description='用户自定义信息'),
}

model TimeRange {
  end?: string(name='End', description='end time'),
  start?: string(name='Start', description='start time'),
}

model TrimPolicy {
  disableDeleteEmptyCell?: boolean(name='DisableDeleteEmptyCell', description='禁止删除所有空单元格'),
  disableDeleteRepeatedStyle?: boolean(name='DisableDeleteRepeatedStyle', description='禁止删除所有重复样式'),
  disableDeleteUnusedPicture?: boolean(name='DisableDeleteUnusedPicture', description='禁止删除未使用的单元格图片'),
  disableDeleteUnusedShape?: boolean(name='DisableDeleteUnusedShape', description='禁止删除没有使用的Shape'),
}

model VideoStream {
  averageFrameRate?: string(name='AverageFrameRate', description='AverageFrameRate'),
  bitDepth?: long(name='BitDepth', description='BitDepth'),
  bitrate?: long(name='Bitrate', description='Bitrate'),
  codecLongName?: string(name='CodecLongName', description='CodecLongName'),
  codecName?: string(name='CodecName', description='CodecName'),
  codecTag?: string(name='CodecTag', description='CodecTag'),
  codecTagString?: string(name='CodecTagString', description='CodecTagString'),
  codecTimeBase?: string(name='CodecTimeBase', description='CodecTimeBase'),
  colorPrimaries?: string(name='ColorPrimaries', description='ColorPrimaries'),
  colorRange?: string(name='ColorRange', description='ColorRange'),
  colorSpace?: string(name='ColorSpace', description='ColorSpace'),
  colorTransfer?: string(name='ColorTransfer', description='ColorTransfer'),
  displayAspectRatio?: string(name='DisplayAspectRatio', description='DisplayAspectRatio'),
  duration?: double(name='Duration', description='Duration'),
  frameCount?: long(name='FrameCount', description='FrameCount'),
  frameRate?: string(name='FrameRate', description='FrameRate'),
  hasBFrames?: long(name='HasBFrames', description='HasBFrames'),
  height?: long(name='Height', description='Height'),
  index?: long(name='Index', description='Index'),
  language?: string(name='Language', description='Language'),
  level?: long(name='Level', description='Level'),
  pixelFormat?: string(name='PixelFormat', description='PixelFormat'),
  profile?: string(name='Profile', description='Profile'),
  rotate?: string(name='Rotate', description='Rotate'),
  sampleAspectRatio?: string(name='SampleAspectRatio', description='SampleAspectRatio'),
  startTime?: double(name='StartTime', description='StartTime'),
  timeBase?: string(name='TimeBase', description='TimeBase'),
  width?: long(name='Width', description='Width'),
}

model WebofficePermission {
  copy?: boolean(name='Copy', description='拷贝'),
  export?: boolean(name='Export', description='导出'),
  history?: boolean(name='History', description='查看历史版本'),
  print?: boolean(name='Print', description='打印'),
  readonly?: boolean(name='Readonly', description='只读模式'),
  rename?: boolean(name='Rename', description='重命名'),
}

model WebofficeUser {
  avatar?: string(name='Avatar', description='头像'),
  id?: string(name='Id', description='Id'),
  name?: string(name='Name', description='名字'),
}

model WebofficeWatermark {
  fillStyle?: string(name='FillStyle', description='字体颜色'),
  font?: string(name='Font', description='字体样式'),
  horizontal?: long(name='Horizontal', description='水平间距'),
  rotate?: float(name='Rotate', description='旋转角度'),
  type?: long(name='Type', description='水印类型，目前仅支持文字水印，0: 无水印；1: 文字水印'),
  value?: string(name='Value', description='水印文字'),
  vertical?: long(name='Vertical', description='垂直间距'),
}

model AddStoryFilesRequest {
  datasetName?: string(name='DatasetName'),
  files?: [ 
    {
      URI?: string(name='URI'),
    }
  ](name='Files'),
  objectId?: string(name='ObjectId'),
  projectName?: string(name='ProjectName', description='A short description of struct'),
}

model AddStoryFilesShrinkRequest {
  datasetName?: string(name='DatasetName'),
  filesShrink?: string(name='Files'),
  objectId?: string(name='ObjectId'),
  projectName?: string(name='ProjectName', description='A short description of struct'),
}

model AddStoryFilesResponseBody = {
  files?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      URI?: string(name='URI'),
    }
  ](name='Files'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddStoryFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddStoryFilesResponseBody(name='body'),
}

async function addStoryFilesWithOptions(tmpReq: AddStoryFilesRequest, runtime: Util.RuntimeOptions): AddStoryFilesResponse {
  Util.validateModel(tmpReq);
  var request = new AddStoryFilesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.files)) {
    request.filesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.files, 'Files', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.datasetName)) {
    body['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.filesShrink)) {
    body['Files'] = request.filesShrink;
  }
  if (!Util.isUnset(request.objectId)) {
    body['ObjectId'] = request.objectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddStoryFiles',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addStoryFiles(request: AddStoryFilesRequest): AddStoryFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addStoryFilesWithOptions(request, runtime);
}

model AttachOSSBucketRequest {
  OSSBucket?: string(name='OSSBucket'),
  projectName?: string(name='ProjectName', description='项目名称'),
}

model AttachOSSBucketResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
}

model AttachOSSBucketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachOSSBucketResponseBody(name='body'),
}

async function attachOSSBucketWithOptions(request: AttachOSSBucketRequest, runtime: Util.RuntimeOptions): AttachOSSBucketResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.OSSBucket)) {
    query['OSSBucket'] = request.OSSBucket;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachOSSBucket',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachOSSBucket(request: AttachOSSBucketRequest): AttachOSSBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachOSSBucketWithOptions(request, runtime);
}

model BatchDeleteFileMetaRequest {
  datasetName?: string(name='DatasetName'),
  projectName?: string(name='ProjectName'),
  URIs?: [ string ](name='URIs'),
}

model BatchDeleteFileMetaShrinkRequest {
  datasetName?: string(name='DatasetName'),
  projectName?: string(name='ProjectName'),
  URIsShrink?: string(name='URIs'),
}

model BatchDeleteFileMetaResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model BatchDeleteFileMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchDeleteFileMetaResponseBody(name='body'),
}

async function batchDeleteFileMetaWithOptions(tmpReq: BatchDeleteFileMetaRequest, runtime: Util.RuntimeOptions): BatchDeleteFileMetaResponse {
  Util.validateModel(tmpReq);
  var request = new BatchDeleteFileMetaShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.URIs)) {
    request.URIsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.URIs, 'URIs', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.URIsShrink)) {
    query['URIs'] = request.URIsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteFileMeta',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchDeleteFileMeta(request: BatchDeleteFileMetaRequest): BatchDeleteFileMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDeleteFileMetaWithOptions(request, runtime);
}

model BatchGetFileMetaRequest {
  datasetName?: string(name='DatasetName'),
  projectName?: string(name='ProjectName'),
  URIs?: [ string ](name='URIs'),
}

model BatchGetFileMetaShrinkRequest {
  datasetName?: string(name='DatasetName'),
  projectName?: string(name='ProjectName'),
  URIsShrink?: string(name='URIs'),
}

model BatchGetFileMetaResponseBody = {
  files?: [
    File
  ](name='Files'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model BatchGetFileMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchGetFileMetaResponseBody(name='body'),
}

async function batchGetFileMetaWithOptions(tmpReq: BatchGetFileMetaRequest, runtime: Util.RuntimeOptions): BatchGetFileMetaResponse {
  Util.validateModel(tmpReq);
  var request = new BatchGetFileMetaShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.URIs)) {
    request.URIsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.URIs, 'URIs', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.URIsShrink)) {
    query['URIs'] = request.URIsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchGetFileMeta',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchGetFileMeta(request: BatchGetFileMetaRequest): BatchGetFileMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchGetFileMetaWithOptions(request, runtime);
}

model BatchIndexFileMetaRequest {
  datasetName?: string(name='DatasetName'),
  files?: [
    FileForReq
  ](name='Files'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  projectName?: string(name='ProjectName'),
}

model BatchIndexFileMetaShrinkRequest {
  datasetName?: string(name='DatasetName'),
  filesShrink?: string(name='Files'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  projectName?: string(name='ProjectName'),
}

model BatchIndexFileMetaResponseBody = {
  eventId?: string(name='EventId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model BatchIndexFileMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchIndexFileMetaResponseBody(name='body'),
}

async function batchIndexFileMetaWithOptions(tmpReq: BatchIndexFileMetaRequest, runtime: Util.RuntimeOptions): BatchIndexFileMetaResponse {
  Util.validateModel(tmpReq);
  var request = new BatchIndexFileMetaShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.files)) {
    request.filesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.files, 'Files', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.filesShrink)) {
    query['Files'] = request.filesShrink;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchIndexFileMeta',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchIndexFileMeta(request: BatchIndexFileMetaRequest): BatchIndexFileMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchIndexFileMetaWithOptions(request, runtime);
}

model BatchUpdateFileMetaRequest {
  datasetName?: string(name='DatasetName'),
  files?: [
    FileForReq
  ](name='Files'),
  projectName?: string(name='ProjectName'),
}

model BatchUpdateFileMetaShrinkRequest {
  datasetName?: string(name='DatasetName'),
  filesShrink?: string(name='Files'),
  projectName?: string(name='ProjectName'),
}

model BatchUpdateFileMetaResponseBody = {
  files?: [ 
    {
      message?: string(name='Message'),
      success?: boolean(name='Success'),
      URI?: string(name='URI'),
    }
  ](name='Files'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model BatchUpdateFileMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchUpdateFileMetaResponseBody(name='body'),
}

async function batchUpdateFileMetaWithOptions(tmpReq: BatchUpdateFileMetaRequest, runtime: Util.RuntimeOptions): BatchUpdateFileMetaResponse {
  Util.validateModel(tmpReq);
  var request = new BatchUpdateFileMetaShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.files)) {
    request.filesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.files, 'Files', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.filesShrink)) {
    query['Files'] = request.filesShrink;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchUpdateFileMeta',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchUpdateFileMeta(request: BatchUpdateFileMetaRequest): BatchUpdateFileMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchUpdateFileMetaWithOptions(request, runtime);
}

model CreateBindingRequest {
  datasetName?: string(name='DatasetName', description='DatasetName'),
  projectName?: string(name='ProjectName', description='ProjectName'),
  URI?: string(name='URI', description='URI'),
}

model CreateBindingResponseBody = {
  binding?: Binding(name='Binding'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBindingResponseBody(name='body'),
}

async function createBindingWithOptions(request: CreateBindingRequest, runtime: Util.RuntimeOptions): CreateBindingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.URI)) {
    query['URI'] = request.URI;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBinding',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBinding(request: CreateBindingRequest): CreateBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBindingWithOptions(request, runtime);
}

model CreateDatasetRequest {
  datasetMaxBindCount?: long(name='DatasetMaxBindCount', description='媒体集最多帮定数'),
  datasetMaxEntityCount?: long(name='DatasetMaxEntityCount', description='媒体集最多实体数'),
  datasetMaxFileCount?: long(name='DatasetMaxFileCount', description='媒体集最多文件数'),
  datasetMaxRelationCount?: long(name='DatasetMaxRelationCount', description='媒体集最多关系数'),
  datasetMaxTotalFileSize?: long(name='DatasetMaxTotalFileSize', description='媒体集最大文件总大小'),
  datasetName?: string(name='DatasetName', description='数据集名称'),
  description?: string(name='Description', description='对数据集的描述'),
  projectName?: string(name='ProjectName', description='项目名称'),
  templateId?: string(name='TemplateId', description='模板Id'),
}

model CreateDatasetResponseBody = {
  dataset?: Dataset(name='Dataset'),
  requestId?: string(name='RequestId', description='请求 ID'),
}

model CreateDatasetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDatasetResponseBody(name='body'),
}

async function createDatasetWithOptions(request: CreateDatasetRequest, runtime: Util.RuntimeOptions): CreateDatasetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetMaxBindCount)) {
    query['DatasetMaxBindCount'] = request.datasetMaxBindCount;
  }
  if (!Util.isUnset(request.datasetMaxEntityCount)) {
    query['DatasetMaxEntityCount'] = request.datasetMaxEntityCount;
  }
  if (!Util.isUnset(request.datasetMaxFileCount)) {
    query['DatasetMaxFileCount'] = request.datasetMaxFileCount;
  }
  if (!Util.isUnset(request.datasetMaxRelationCount)) {
    query['DatasetMaxRelationCount'] = request.datasetMaxRelationCount;
  }
  if (!Util.isUnset(request.datasetMaxTotalFileSize)) {
    query['DatasetMaxTotalFileSize'] = request.datasetMaxTotalFileSize;
  }
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataset',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDataset(request: CreateDatasetRequest): CreateDatasetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDatasetWithOptions(request, runtime);
}

model CreateDetectVideoLabelsTaskRequest {
  credentialConfig?: CredentialConfig(name='CredentialConfig'),
  notifyEndpoint?: string(name='NotifyEndpoint', description='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName', description='NotifyTopicName'),
  projectName?: string(name='ProjectName', description='项目名称'),
  sourceURI?: string(name='SourceURI', description='SourceURI'),
  tags?: map[string]any(name='Tags'),
  userData?: string(name='UserData', description='UserData'),
}

model CreateDetectVideoLabelsTaskShrinkRequest {
  credentialConfigShrink?: string(name='CredentialConfig'),
  notifyEndpoint?: string(name='NotifyEndpoint', description='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName', description='NotifyTopicName'),
  projectName?: string(name='ProjectName', description='项目名称'),
  sourceURI?: string(name='SourceURI', description='SourceURI'),
  tagsShrink?: string(name='Tags'),
  userData?: string(name='UserData', description='UserData'),
}

model CreateDetectVideoLabelsTaskResponseBody = {
  eventId?: string(name='EventId', description='事件Id'),
  requestId?: string(name='RequestId', description='请求唯一Id'),
  taskId?: string(name='TaskId', description='任务唯一ID'),
}

model CreateDetectVideoLabelsTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDetectVideoLabelsTaskResponseBody(name='body'),
}

async function createDetectVideoLabelsTaskWithOptions(tmpReq: CreateDetectVideoLabelsTaskRequest, runtime: Util.RuntimeOptions): CreateDetectVideoLabelsTaskResponse {
  Util.validateModel(tmpReq);
  var request = new CreateDetectVideoLabelsTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.credentialConfig)) {
    request.credentialConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.credentialConfig, 'CredentialConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.credentialConfigShrink)) {
    query['CredentialConfig'] = request.credentialConfigShrink;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.sourceURI)) {
    query['SourceURI'] = request.sourceURI;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDetectVideoLabelsTask',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDetectVideoLabelsTask(request: CreateDetectVideoLabelsTaskRequest): CreateDetectVideoLabelsTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDetectVideoLabelsTaskWithOptions(request, runtime);
}

model CreateFigureClusteringTaskRequest {
  datasetName?: string(name='DatasetName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  projectName?: string(name='ProjectName'),
  tags?: map[string]any(name='Tags'),
  userData?: string(name='UserData'),
}

model CreateFigureClusteringTaskShrinkRequest {
  datasetName?: string(name='DatasetName'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  projectName?: string(name='ProjectName'),
  tagsShrink?: string(name='Tags'),
  userData?: string(name='UserData'),
}

model CreateFigureClusteringTaskResponseBody = {
  eventId?: string(name='EventId'),
  requestId?: string(name='RequestId', description='Id of the request'),
  taskId?: string(name='TaskId'),
}

model CreateFigureClusteringTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFigureClusteringTaskResponseBody(name='body'),
}

async function createFigureClusteringTaskWithOptions(tmpReq: CreateFigureClusteringTaskRequest, runtime: Util.RuntimeOptions): CreateFigureClusteringTaskResponse {
  Util.validateModel(tmpReq);
  var request = new CreateFigureClusteringTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFigureClusteringTask',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFigureClusteringTask(request: CreateFigureClusteringTaskRequest): CreateFigureClusteringTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFigureClusteringTaskWithOptions(request, runtime);
}

model CreateFigureClustersMergingTaskRequest {
  datasetName?: string(name='DatasetName'),
  from?: string(name='From', description='源cluster'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  projectName?: string(name='ProjectName'),
  tags?: map[string]any(name='Tags'),
  to?: string(name='To', description='目的cluster'),
  userData?: string(name='UserData'),
}

model CreateFigureClustersMergingTaskShrinkRequest {
  datasetName?: string(name='DatasetName'),
  from?: string(name='From', description='源cluster'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  projectName?: string(name='ProjectName'),
  tagsShrink?: string(name='Tags'),
  to?: string(name='To', description='目的cluster'),
  userData?: string(name='UserData'),
}

model CreateFigureClustersMergingTaskResponseBody = {
  eventId?: string(name='EventId'),
  requestId?: string(name='RequestId', description='Id of the request'),
  taskId?: string(name='TaskId'),
}

model CreateFigureClustersMergingTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFigureClustersMergingTaskResponseBody(name='body'),
}

async function createFigureClustersMergingTaskWithOptions(tmpReq: CreateFigureClustersMergingTaskRequest, runtime: Util.RuntimeOptions): CreateFigureClustersMergingTaskResponse {
  Util.validateModel(tmpReq);
  var request = new CreateFigureClustersMergingTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.to)) {
    query['To'] = request.to;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFigureClustersMergingTask',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFigureClustersMergingTask(request: CreateFigureClustersMergingTaskRequest): CreateFigureClustersMergingTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFigureClustersMergingTaskWithOptions(request, runtime);
}

model CreateImageModerationTaskRequest {
  credentialConfig?: CredentialConfig(name='CredentialConfig'),
  interval?: long(name='Interval'),
  maxFrames?: long(name='MaxFrames'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  projectName?: string(name='ProjectName', description='项目名称'),
  reviewer?: string(name='Reviewer'),
  scenes?: [ string ](name='Scenes'),
  sourceURI?: string(name='SourceURI'),
  tags?: map[string]any(name='Tags'),
  userData?: string(name='UserData'),
}

model CreateImageModerationTaskShrinkRequest {
  credentialConfigShrink?: string(name='CredentialConfig'),
  interval?: long(name='Interval'),
  maxFrames?: long(name='MaxFrames'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  projectName?: string(name='ProjectName', description='项目名称'),
  reviewer?: string(name='Reviewer'),
  scenesShrink?: string(name='Scenes'),
  sourceURI?: string(name='SourceURI'),
  tagsShrink?: string(name='Tags'),
  userData?: string(name='UserData'),
}

model CreateImageModerationTaskResponseBody = {
  eventId?: string(name='EventId'),
  requestId?: string(name='RequestId', description='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateImageModerationTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateImageModerationTaskResponseBody(name='body'),
}

async function createImageModerationTaskWithOptions(tmpReq: CreateImageModerationTaskRequest, runtime: Util.RuntimeOptions): CreateImageModerationTaskResponse {
  Util.validateModel(tmpReq);
  var request = new CreateImageModerationTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.credentialConfig)) {
    request.credentialConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.credentialConfig, 'CredentialConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.scenes)) {
    request.scenesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scenes, 'Scenes', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.credentialConfigShrink)) {
    query['CredentialConfig'] = request.credentialConfigShrink;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.maxFrames)) {
    query['MaxFrames'] = request.maxFrames;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.reviewer)) {
    query['Reviewer'] = request.reviewer;
  }
  if (!Util.isUnset(request.scenesShrink)) {
    query['Scenes'] = request.scenesShrink;
  }
  if (!Util.isUnset(request.sourceURI)) {
    query['SourceURI'] = request.sourceURI;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateImageModerationTask',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createImageModerationTask(request: CreateImageModerationTaskRequest): CreateImageModerationTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createImageModerationTaskWithOptions(request, runtime);
}

model CreateMediaConvertTaskRequest {
  credentialConfig?: CredentialConfig(name='CredentialConfig'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  projectName?: string(name='ProjectName'),
  sources?: [ 
    {
      duration?: double(name='Duration'),
      startTime?: double(name='StartTime'),
      subtitles?: [ 
        {
          language?: string(name='Language'),
          timeOffset?: double(name='TimeOffset'),
          URI?: string(name='URI'),
        }
      ](name='Subtitles'),
      URI?: string(name='URI'),
    }
  ](name='Sources'),
  tags?: map[string]any(name='Tags'),
  targets?: [ 
    {
      audio?: {
        disableAudio?: boolean(name='DisableAudio'),
        filterAudio?: {
          mixing?: boolean(name='Mixing'),
        }(name='FilterAudio'),
        transcodeAudio?: {
          bitrate?: int32(name='Bitrate'),
          bitrateOption?: string(name='BitrateOption'),
          channel?: int32(name='Channel'),
          codec?: string(name='Codec'),
          quality?: int32(name='Quality'),
          sampleRate?: int32(name='SampleRate'),
          sampleRateOption?: string(name='SampleRateOption'),
        }(name='TranscodeAudio'),
      }(name='Audio'),
      container?: string(name='Container'),
      image?: {
        snapshots?: [ 
          {
            format?: string(name='Format'),
            height?: int32(name='Height'),
            interval?: double(name='Interval'),
            number?: int32(name='Number'),
            scaleType?: string(name='ScaleType'),
            startTime?: double(name='StartTime'),
            URI?: string(name='URI'),
            width?: int32(name='Width'),
          }
        ](name='Snapshots'),
        sprites?: [ 
          {
            format?: string(name='Format'),
            interval?: double(name='Interval'),
            margin?: int32(name='Margin'),
            number?: int32(name='Number'),
            pad?: int32(name='Pad'),
            scaleHeight?: float(name='ScaleHeight'),
            scaleType?: string(name='ScaleType'),
            scaleWidth?: float(name='ScaleWidth'),
            startTime?: double(name='StartTime'),
            tileHeight?: int32(name='TileHeight'),
            tileWidth?: int32(name='TileWidth'),
            URI?: string(name='URI'),
          }
        ](name='Sprites'),
      }(name='Image'),
      preset?: PresetReference(name='Preset'),
      segment?: {
        duration?: double(name='Duration'),
        format?: string(name='Format'),
        startNumber?: int32(name='StartNumber'),
      }(name='Segment'),
      speed?: float(name='Speed'),
      subtitle?: {
        disableSubtitle?: boolean(name='DisableSubtitle'),
        extractSubtitle?: {
          format?: string(name='Format'),
          URI?: string(name='URI'),
        }(name='ExtractSubtitle'),
      }(name='Subtitle'),
      URI?: string(name='URI'),
      video?: {
        disableVideo?: boolean(name='DisableVideo'),
        filterVideo?: {
          delogos?: [ 
            {
              duration?: double(name='Duration'),
              dx?: float(name='Dx'),
              dy?: float(name='Dy'),
              height?: float(name='Height'),
              referPos?: string(name='ReferPos'),
              startTime?: double(name='StartTime'),
              width?: float(name='Width'),
            }
          ](name='Delogos'),
          watermarks?: [ 
            {
              borderColor?: string(name='BorderColor'),
              borderWidth?: int32(name='BorderWidth'),
              content?: string(name='Content'),
              duration?: double(name='Duration'),
              dx?: float(name='Dx'),
              dy?: float(name='Dy'),
              fontApha?: float(name='FontApha'),
              fontColor?: string(name='FontColor'),
              fontName?: string(name='FontName'),
              fontSize?: int32(name='FontSize'),
              height?: float(name='Height'),
              referPos?: string(name='ReferPos'),
              startTime?: double(name='StartTime'),
              type?: string(name='Type'),
              URI?: string(name='URI'),
              width?: float(name='Width'),
            }
          ](name='Watermarks'),
        }(name='FilterVideo'),
        transcodeVideo?: {
          adaptiveResolutionDirection?: boolean(name='AdaptiveResolutionDirection'),
          BFrames?: int32(name='BFrames'),
          bitrate?: int32(name='Bitrate'),
          bitrateOption?: string(name='BitrateOption'),
          bufferSize?: int32(name='BufferSize'),
          CRF?: float(name='CRF'),
          codec?: string(name='Codec'),
          frameRate?: float(name='FrameRate'),
          frameRateOption?: string(name='FrameRateOption'),
          GOPSize?: int32(name='GOPSize'),
          maxBitrate?: int32(name='MaxBitrate'),
          pixelFormat?: string(name='PixelFormat'),
          refs?: int32(name='Refs'),
          resolution?: string(name='Resolution'),
          resolutionOption?: string(name='ResolutionOption'),
          rotation?: int32(name='Rotation'),
          scaleType?: string(name='ScaleType'),
        }(name='TranscodeVideo'),
      }(name='Video'),
    }
  ](name='Targets'),
  userData?: string(name='UserData'),
}

model CreateMediaConvertTaskShrinkRequest {
  credentialConfigShrink?: string(name='CredentialConfig'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  projectName?: string(name='ProjectName'),
  sourcesShrink?: string(name='Sources'),
  tagsShrink?: string(name='Tags'),
  targetsShrink?: string(name='Targets'),
  userData?: string(name='UserData'),
}

model CreateMediaConvertTaskResponseBody = {
  eventId?: string(name='EventId'),
  requestId?: string(name='RequestId', description='请求 ID'),
  taskId?: string(name='TaskId'),
}

model CreateMediaConvertTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMediaConvertTaskResponseBody(name='body'),
}

async function createMediaConvertTaskWithOptions(tmpReq: CreateMediaConvertTaskRequest, runtime: Util.RuntimeOptions): CreateMediaConvertTaskResponse {
  Util.validateModel(tmpReq);
  var request = new CreateMediaConvertTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.credentialConfig)) {
    request.credentialConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.credentialConfig, 'CredentialConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.sources)) {
    request.sourcesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sources, 'Sources', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  if (!Util.isUnset(tmpReq.targets)) {
    request.targetsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.targets, 'Targets', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.credentialConfigShrink)) {
    query['CredentialConfig'] = request.credentialConfigShrink;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.sourcesShrink)) {
    query['Sources'] = request.sourcesShrink;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.targetsShrink)) {
    query['Targets'] = request.targetsShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMediaConvertTask',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMediaConvertTask(request: CreateMediaConvertTaskRequest): CreateMediaConvertTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMediaConvertTaskWithOptions(request, runtime);
}

model CreateOfficeConversionTaskRequest {
  credentialConfig?: CredentialConfig(name='CredentialConfig'),
  endPage?: long(name='EndPage', description='转换终止页，包含终止页，默认转换到最后一页，表格转图片时需要指定 SheetIndex 才有效'),
  firstPage?: boolean(name='FirstPage', description='表格转图片参数，是否只返回表格的第一张图片，默认为否'),
  fitToHeight?: boolean(name='FitToHeight', description='表格转图片参数，是否将所有行输出到一张图片，默认为否'),
  fitToWidth?: boolean(name='FitToWidth', description='表格转图片参数，是否将所有列输出到一张图片，默认为否'),
  holdLineFeed?: boolean(name='HoldLineFeed', description='转文本时是否保留文档中的换行符，默认不保留'),
  imageDPI?: long(name='ImageDPI', description='输出图片 DPI，允许范围 96-600，默认 96'),
  longPicture?: boolean(name='LongPicture', description='转图片时是否转换成一张长图，最多支持将 20 页合成一张长图，超过可能报错，默认为不转成长图'),
  longText?: boolean(name='LongText', description='转文本时是否转换成长文本，默认每页是个独立的文本'),
  maxSheetColumn?: long(name='MaxSheetColumn', description='表格转图片的最大列数，在 LongPicture 为 true 时生效，默认转所有列'),
  maxSheetRow?: long(name='MaxSheetRow', description='表格转图片的最大行数，在 LongPicture 为 true 时生效，默认转所有行'),
  notifyEndpoint?: string(name='NotifyEndpoint', description='mns 消息通知地址'),
  notifyTopicName?: string(name='NotifyTopicName', description='mns 消息通知 topic'),
  pages?: string(name='Pages', description='指定转换页码，优先级高于 StartPage/EndPage，格式：多个页码用 “," 拼接，连续页码用 "-" 连接，样例参考: 1,2-4,7'),
  paperHorizontal?: boolean(name='PaperHorizontal', description='表格转图片纸张是否水平放置，默认为否'),
  paperSize?: string(name='PaperSize', description='表格转图片纸张大小，支持 A4/A2/A0，默认A4，配合 FitToHeight 或 FitToWidth 一起使用才有效'),
  password?: string(name='Password', description='文档密码'),
  projectName?: string(name='ProjectName', description='项目名称'),
  quality?: long(name='Quality', description='质量参数，范围是0-100，越大质量越好，默认系统自动选择适合的分辨率'),
  scalePercentage?: long(name='ScalePercentage', description='缩放参数，允许范围 20~200，100代表不缩放，小于100表示缩小，大于100表示放大，默认不缩放'),
  sheetCount?: long(name='SheetCount', description='表格转图片参数，指定转换表格中的 sheet 数量，默认转换所有 sheet'),
  sheetIndex?: long(name='SheetIndex', description='表格转图片参数，指定转换哪一个 sheet，从 1 开始，默认从起始页开始转'),
  showComments?: boolean(name='ShowComments', description='文字转图片，是否显示批注，目前只支持文字转图片时携带批注，默认不显示批注'),
  sourceType?: string(name='SourceType', description='输入文件格式，默认使用文件名后缀小写格式'),
  sourceURI?: string(name='SourceURI', description='文档转换输入文件地址'),
  startPage?: long(name='StartPage', description='转换起始页，从 1 开始，包含起始页，默认从第一页开始转换，表格转图片时需要指定 SheetIndex 才有效'),
  tags?: map[string]any(name='Tags', description='用户自定义标签'),
  targetType?: string(name='TargetType', description='输出文件格式'),
  targetURI?: string(name='TargetURI', description='文档转换输出地址模式'),
  targetURIPrefix?: string(name='TargetURIPrefix', description='文档转换输出文件地址前缀'),
  trimPolicy?: TrimPolicy(name='TrimPolicy', description='表格瘦身'),
  userData?: string(name='UserData', description='用户自定义数据，在消息通知中返回'),
}

model CreateOfficeConversionTaskShrinkRequest {
  credentialConfigShrink?: string(name='CredentialConfig'),
  endPage?: long(name='EndPage', description='转换终止页，包含终止页，默认转换到最后一页，表格转图片时需要指定 SheetIndex 才有效'),
  firstPage?: boolean(name='FirstPage', description='表格转图片参数，是否只返回表格的第一张图片，默认为否'),
  fitToHeight?: boolean(name='FitToHeight', description='表格转图片参数，是否将所有行输出到一张图片，默认为否'),
  fitToWidth?: boolean(name='FitToWidth', description='表格转图片参数，是否将所有列输出到一张图片，默认为否'),
  holdLineFeed?: boolean(name='HoldLineFeed', description='转文本时是否保留文档中的换行符，默认不保留'),
  imageDPI?: long(name='ImageDPI', description='输出图片 DPI，允许范围 96-600，默认 96'),
  longPicture?: boolean(name='LongPicture', description='转图片时是否转换成一张长图，最多支持将 20 页合成一张长图，超过可能报错，默认为不转成长图'),
  longText?: boolean(name='LongText', description='转文本时是否转换成长文本，默认每页是个独立的文本'),
  maxSheetColumn?: long(name='MaxSheetColumn', description='表格转图片的最大列数，在 LongPicture 为 true 时生效，默认转所有列'),
  maxSheetRow?: long(name='MaxSheetRow', description='表格转图片的最大行数，在 LongPicture 为 true 时生效，默认转所有行'),
  notifyEndpoint?: string(name='NotifyEndpoint', description='mns 消息通知地址'),
  notifyTopicName?: string(name='NotifyTopicName', description='mns 消息通知 topic'),
  pages?: string(name='Pages', description='指定转换页码，优先级高于 StartPage/EndPage，格式：多个页码用 “," 拼接，连续页码用 "-" 连接，样例参考: 1,2-4,7'),
  paperHorizontal?: boolean(name='PaperHorizontal', description='表格转图片纸张是否水平放置，默认为否'),
  paperSize?: string(name='PaperSize', description='表格转图片纸张大小，支持 A4/A2/A0，默认A4，配合 FitToHeight 或 FitToWidth 一起使用才有效'),
  password?: string(name='Password', description='文档密码'),
  projectName?: string(name='ProjectName', description='项目名称'),
  quality?: long(name='Quality', description='质量参数，范围是0-100，越大质量越好，默认系统自动选择适合的分辨率'),
  scalePercentage?: long(name='ScalePercentage', description='缩放参数，允许范围 20~200，100代表不缩放，小于100表示缩小，大于100表示放大，默认不缩放'),
  sheetCount?: long(name='SheetCount', description='表格转图片参数，指定转换表格中的 sheet 数量，默认转换所有 sheet'),
  sheetIndex?: long(name='SheetIndex', description='表格转图片参数，指定转换哪一个 sheet，从 1 开始，默认从起始页开始转'),
  showComments?: boolean(name='ShowComments', description='文字转图片，是否显示批注，目前只支持文字转图片时携带批注，默认不显示批注'),
  sourceType?: string(name='SourceType', description='输入文件格式，默认使用文件名后缀小写格式'),
  sourceURI?: string(name='SourceURI', description='文档转换输入文件地址'),
  startPage?: long(name='StartPage', description='转换起始页，从 1 开始，包含起始页，默认从第一页开始转换，表格转图片时需要指定 SheetIndex 才有效'),
  tagsShrink?: string(name='Tags', description='用户自定义标签'),
  targetType?: string(name='TargetType', description='输出文件格式'),
  targetURI?: string(name='TargetURI', description='文档转换输出地址模式'),
  targetURIPrefix?: string(name='TargetURIPrefix', description='文档转换输出文件地址前缀'),
  trimPolicyShrink?: string(name='TrimPolicy', description='表格瘦身'),
  userData?: string(name='UserData', description='用户自定义数据，在消息通知中返回'),
}

model CreateOfficeConversionTaskResponseBody = {
  eventId?: string(name='EventId'),
  requestId?: string(name='RequestId', description='请求 id'),
  taskId?: string(name='TaskId', description='任务 id'),
}

model CreateOfficeConversionTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOfficeConversionTaskResponseBody(name='body'),
}

async function createOfficeConversionTaskWithOptions(tmpReq: CreateOfficeConversionTaskRequest, runtime: Util.RuntimeOptions): CreateOfficeConversionTaskResponse {
  Util.validateModel(tmpReq);
  var request = new CreateOfficeConversionTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.credentialConfig)) {
    request.credentialConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.credentialConfig, 'CredentialConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  if (!Util.isUnset(tmpReq.trimPolicy)) {
    request.trimPolicyShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.trimPolicy, 'TrimPolicy', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.credentialConfigShrink)) {
    query['CredentialConfig'] = request.credentialConfigShrink;
  }
  if (!Util.isUnset(request.endPage)) {
    query['EndPage'] = request.endPage;
  }
  if (!Util.isUnset(request.firstPage)) {
    query['FirstPage'] = request.firstPage;
  }
  if (!Util.isUnset(request.fitToHeight)) {
    query['FitToHeight'] = request.fitToHeight;
  }
  if (!Util.isUnset(request.fitToWidth)) {
    query['FitToWidth'] = request.fitToWidth;
  }
  if (!Util.isUnset(request.holdLineFeed)) {
    query['HoldLineFeed'] = request.holdLineFeed;
  }
  if (!Util.isUnset(request.imageDPI)) {
    query['ImageDPI'] = request.imageDPI;
  }
  if (!Util.isUnset(request.longPicture)) {
    query['LongPicture'] = request.longPicture;
  }
  if (!Util.isUnset(request.longText)) {
    query['LongText'] = request.longText;
  }
  if (!Util.isUnset(request.maxSheetColumn)) {
    query['MaxSheetColumn'] = request.maxSheetColumn;
  }
  if (!Util.isUnset(request.maxSheetRow)) {
    query['MaxSheetRow'] = request.maxSheetRow;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.pages)) {
    query['Pages'] = request.pages;
  }
  if (!Util.isUnset(request.paperHorizontal)) {
    query['PaperHorizontal'] = request.paperHorizontal;
  }
  if (!Util.isUnset(request.paperSize)) {
    query['PaperSize'] = request.paperSize;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.quality)) {
    query['Quality'] = request.quality;
  }
  if (!Util.isUnset(request.scalePercentage)) {
    query['ScalePercentage'] = request.scalePercentage;
  }
  if (!Util.isUnset(request.sheetCount)) {
    query['SheetCount'] = request.sheetCount;
  }
  if (!Util.isUnset(request.sheetIndex)) {
    query['SheetIndex'] = request.sheetIndex;
  }
  if (!Util.isUnset(request.showComments)) {
    query['ShowComments'] = request.showComments;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.sourceURI)) {
    query['SourceURI'] = request.sourceURI;
  }
  if (!Util.isUnset(request.startPage)) {
    query['StartPage'] = request.startPage;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.targetType)) {
    query['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.targetURI)) {
    query['TargetURI'] = request.targetURI;
  }
  if (!Util.isUnset(request.targetURIPrefix)) {
    query['TargetURIPrefix'] = request.targetURIPrefix;
  }
  if (!Util.isUnset(request.trimPolicyShrink)) {
    query['TrimPolicy'] = request.trimPolicyShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOfficeConversionTask',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOfficeConversionTask(request: CreateOfficeConversionTaskRequest): CreateOfficeConversionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOfficeConversionTaskWithOptions(request, runtime);
}

model CreateProjectRequest {
  datasetMaxBindCount?: long(name='DatasetMaxBindCount'),
  datasetMaxEntityCount?: long(name='DatasetMaxEntityCount'),
  datasetMaxFileCount?: long(name='DatasetMaxFileCount'),
  datasetMaxRelationCount?: long(name='DatasetMaxRelationCount'),
  datasetMaxTotalFileSize?: long(name='DatasetMaxTotalFileSize'),
  description?: string(name='Description'),
  engineConcurrency?: long(name='EngineConcurrency'),
  projectMaxDatasetCount?: long(name='ProjectMaxDatasetCount'),
  projectName?: string(name='ProjectName', description='项目名称'),
  projectQueriesPerSecond?: long(name='ProjectQueriesPerSecond'),
  serviceRole?: string(name='ServiceRole'),
  templateId?: string(name='TemplateId'),
}

model CreateProjectResponseBody = {
  project?: Project(name='Project'),
  requestId?: string(name='RequestId', description='本次请求的唯一 ID'),
}

model CreateProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProjectResponseBody(name='body'),
}

async function createProjectWithOptions(request: CreateProjectRequest, runtime: Util.RuntimeOptions): CreateProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetMaxBindCount)) {
    query['DatasetMaxBindCount'] = request.datasetMaxBindCount;
  }
  if (!Util.isUnset(request.datasetMaxEntityCount)) {
    query['DatasetMaxEntityCount'] = request.datasetMaxEntityCount;
  }
  if (!Util.isUnset(request.datasetMaxFileCount)) {
    query['DatasetMaxFileCount'] = request.datasetMaxFileCount;
  }
  if (!Util.isUnset(request.datasetMaxRelationCount)) {
    query['DatasetMaxRelationCount'] = request.datasetMaxRelationCount;
  }
  if (!Util.isUnset(request.datasetMaxTotalFileSize)) {
    query['DatasetMaxTotalFileSize'] = request.datasetMaxTotalFileSize;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.engineConcurrency)) {
    query['EngineConcurrency'] = request.engineConcurrency;
  }
  if (!Util.isUnset(request.projectMaxDatasetCount)) {
    query['ProjectMaxDatasetCount'] = request.projectMaxDatasetCount;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.projectQueriesPerSecond)) {
    query['ProjectQueriesPerSecond'] = request.projectQueriesPerSecond;
  }
  if (!Util.isUnset(request.serviceRole)) {
    query['ServiceRole'] = request.serviceRole;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProject',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createProject(request: CreateProjectRequest): CreateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProjectWithOptions(request, runtime);
}

model CreateStoryRequest {
  customId?: string(name='CustomId'),
  customLabels?: map[string]any(name='CustomLabels'),
  datasetName?: string(name='DatasetName'),
  maxFileCount?: long(name='MaxFileCount'),
  minFileCount?: long(name='MinFileCount'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  objectId?: string(name='ObjectId'),
  projectName?: string(name='ProjectName'),
  storyEndTime?: string(name='StoryEndTime'),
  storyName?: string(name='StoryName'),
  storyStartTime?: string(name='StoryStartTime'),
  storySubType?: string(name='StorySubType'),
  storyType?: string(name='StoryType'),
  tags?: map[string]any(name='Tags'),
  userData?: string(name='UserData'),
}

model CreateStoryShrinkRequest {
  customId?: string(name='CustomId'),
  customLabelsShrink?: string(name='CustomLabels'),
  datasetName?: string(name='DatasetName'),
  maxFileCount?: long(name='MaxFileCount'),
  minFileCount?: long(name='MinFileCount'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  objectId?: string(name='ObjectId'),
  projectName?: string(name='ProjectName'),
  storyEndTime?: string(name='StoryEndTime'),
  storyName?: string(name='StoryName'),
  storyStartTime?: string(name='StoryStartTime'),
  storySubType?: string(name='StorySubType'),
  storyType?: string(name='StoryType'),
  tagsShrink?: string(name='Tags'),
  userData?: string(name='UserData'),
}

model CreateStoryResponseBody = {
  eventId?: string(name='EventId'),
  requestId?: string(name='RequestId', description='Id of the request'),
  taskId?: string(name='TaskId'),
}

model CreateStoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateStoryResponseBody(name='body'),
}

async function createStoryWithOptions(tmpReq: CreateStoryRequest, runtime: Util.RuntimeOptions): CreateStoryResponse {
  Util.validateModel(tmpReq);
  var request = new CreateStoryShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.customLabels)) {
    request.customLabelsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.customLabels, 'CustomLabels', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.customId)) {
    body['CustomId'] = request.customId;
  }
  if (!Util.isUnset(request.customLabelsShrink)) {
    body['CustomLabels'] = request.customLabelsShrink;
  }
  if (!Util.isUnset(request.datasetName)) {
    body['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.maxFileCount)) {
    body['MaxFileCount'] = request.maxFileCount;
  }
  if (!Util.isUnset(request.minFileCount)) {
    body['MinFileCount'] = request.minFileCount;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    body['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    body['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.objectId)) {
    body['ObjectId'] = request.objectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.storyEndTime)) {
    body['StoryEndTime'] = request.storyEndTime;
  }
  if (!Util.isUnset(request.storyName)) {
    body['StoryName'] = request.storyName;
  }
  if (!Util.isUnset(request.storyStartTime)) {
    body['StoryStartTime'] = request.storyStartTime;
  }
  if (!Util.isUnset(request.storySubType)) {
    body['StorySubType'] = request.storySubType;
  }
  if (!Util.isUnset(request.storyType)) {
    body['StoryType'] = request.storyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateStory',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createStory(request: CreateStoryRequest): CreateStoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createStoryWithOptions(request, runtime);
}

model CreateVideoModerationTaskRequest {
  credentialConfig?: CredentialConfig(name='CredentialConfig'),
  interval?: long(name='Interval'),
  maxFrames?: long(name='MaxFrames'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  projectName?: string(name='ProjectName', description='项目名称'),
  reviewer?: string(name='Reviewer'),
  scenes?: [ string ](name='Scenes'),
  sourceURI?: string(name='SourceURI'),
  tags?: map[string]any(name='Tags'),
  userData?: string(name='UserData'),
}

model CreateVideoModerationTaskShrinkRequest {
  credentialConfigShrink?: string(name='CredentialConfig'),
  interval?: long(name='Interval'),
  maxFrames?: long(name='MaxFrames'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  projectName?: string(name='ProjectName', description='项目名称'),
  reviewer?: string(name='Reviewer'),
  scenesShrink?: string(name='Scenes'),
  sourceURI?: string(name='SourceURI'),
  tagsShrink?: string(name='Tags'),
  userData?: string(name='UserData'),
}

model CreateVideoModerationTaskResponseBody = {
  eventId?: string(name='EventId'),
  requestId?: string(name='RequestId', description='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateVideoModerationTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVideoModerationTaskResponseBody(name='body'),
}

async function createVideoModerationTaskWithOptions(tmpReq: CreateVideoModerationTaskRequest, runtime: Util.RuntimeOptions): CreateVideoModerationTaskResponse {
  Util.validateModel(tmpReq);
  var request = new CreateVideoModerationTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.credentialConfig)) {
    request.credentialConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.credentialConfig, 'CredentialConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.scenes)) {
    request.scenesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scenes, 'Scenes', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.credentialConfigShrink)) {
    query['CredentialConfig'] = request.credentialConfigShrink;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.maxFrames)) {
    query['MaxFrames'] = request.maxFrames;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.reviewer)) {
    query['Reviewer'] = request.reviewer;
  }
  if (!Util.isUnset(request.scenesShrink)) {
    query['Scenes'] = request.scenesShrink;
  }
  if (!Util.isUnset(request.sourceURI)) {
    query['SourceURI'] = request.sourceURI;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVideoModerationTask',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVideoModerationTask(request: CreateVideoModerationTaskRequest): CreateVideoModerationTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVideoModerationTaskWithOptions(request, runtime);
}

model DeleteBindingRequest {
  cleanup?: boolean(name='Cleanup'),
  datasetName?: string(name='DatasetName'),
  projectName?: string(name='ProjectName', description='A short description of struct'),
  URI?: string(name='URI'),
}

model DeleteBindingResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBindingResponseBody(name='body'),
}

async function deleteBindingWithOptions(request: DeleteBindingRequest, runtime: Util.RuntimeOptions): DeleteBindingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cleanup)) {
    query['Cleanup'] = request.cleanup;
  }
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.URI)) {
    query['URI'] = request.URI;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBinding',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBinding(request: DeleteBindingRequest): DeleteBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBindingWithOptions(request, runtime);
}

model DeleteDatasetRequest {
  datasetName?: string(name='DatasetName'),
  projectName?: string(name='ProjectName'),
}

model DeleteDatasetResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteDatasetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDatasetResponseBody(name='body'),
}

async function deleteDatasetWithOptions(request: DeleteDatasetRequest, runtime: Util.RuntimeOptions): DeleteDatasetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataset',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDataset(request: DeleteDatasetRequest): DeleteDatasetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDatasetWithOptions(request, runtime);
}

model DeleteFileMetaRequest {
  datasetName?: string(name='DatasetName'),
  projectName?: string(name='ProjectName'),
  URI?: string(name='URI'),
}

model DeleteFileMetaResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteFileMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFileMetaResponseBody(name='body'),
}

async function deleteFileMetaWithOptions(request: DeleteFileMetaRequest, runtime: Util.RuntimeOptions): DeleteFileMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.URI)) {
    query['URI'] = request.URI;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFileMeta',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFileMeta(request: DeleteFileMetaRequest): DeleteFileMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFileMetaWithOptions(request, runtime);
}

model DeleteProjectRequest {
  projectName?: string(name='ProjectName', description='项目名称'),
}

model DeleteProjectResponseBody = {
  requestId?: string(name='RequestId', description='本次请求的唯一 ID'),
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProjectResponseBody(name='body'),
}

async function deleteProjectWithOptions(request: DeleteProjectRequest, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProject(request: DeleteProjectRequest): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectWithOptions(request, runtime);
}

model DeleteStoryRequest {
  datasetName?: string(name='DatasetName'),
  objectId?: string(name='ObjectId'),
  projectName?: string(name='ProjectName'),
}

model DeleteStoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteStoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteStoryResponseBody(name='body'),
}

async function deleteStoryWithOptions(request: DeleteStoryRequest, runtime: Util.RuntimeOptions): DeleteStoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.objectId)) {
    query['ObjectId'] = request.objectId;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteStory',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteStory(request: DeleteStoryRequest): DeleteStoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteStoryWithOptions(request, runtime);
}

model DetachOSSBucketRequest {
  OSSBucket?: string(name='OSSBucket'),
}

model DetachOSSBucketResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
}

model DetachOSSBucketResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachOSSBucketResponseBody(name='body'),
}

async function detachOSSBucketWithOptions(request: DetachOSSBucketRequest, runtime: Util.RuntimeOptions): DetachOSSBucketResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.OSSBucket)) {
    query['OSSBucket'] = request.OSSBucket;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachOSSBucket',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachOSSBucket(request: DetachOSSBucketRequest): DetachOSSBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachOSSBucketWithOptions(request, runtime);
}

model DetectImageCodesRequest {
  credentialConfig?: CredentialConfig(name='CredentialConfig'),
  projectName?: string(name='ProjectName', description='项目名称'),
  sourceURI?: string(name='SourceURI', description='SourceURI'),
}

model DetectImageCodesShrinkRequest {
  credentialConfigShrink?: string(name='CredentialConfig'),
  projectName?: string(name='ProjectName', description='项目名称'),
  sourceURI?: string(name='SourceURI', description='SourceURI'),
}

model DetectImageCodesResponseBody = {
  codes?: [
    Codes
  ](name='Codes', description='二维码检测结果'),
  requestId?: string(name='RequestId', description='请求唯一ID'),
}

model DetectImageCodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectImageCodesResponseBody(name='body'),
}

async function detectImageCodesWithOptions(tmpReq: DetectImageCodesRequest, runtime: Util.RuntimeOptions): DetectImageCodesResponse {
  Util.validateModel(tmpReq);
  var request = new DetectImageCodesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.credentialConfig)) {
    request.credentialConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.credentialConfig, 'CredentialConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.credentialConfigShrink)) {
    query['CredentialConfig'] = request.credentialConfigShrink;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.sourceURI)) {
    query['SourceURI'] = request.sourceURI;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetectImageCodes',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectImageCodes(request: DetectImageCodesRequest): DetectImageCodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageCodesWithOptions(request, runtime);
}

model DetectImageCroppingRequest {
  aspectRatios?: string(name='AspectRatios'),
  credentialConfig?: CredentialConfig(name='CredentialConfig'),
  projectName?: string(name='ProjectName', description='项目名称'),
  sourceURI?: string(name='SourceURI', description='SourceURI'),
}

model DetectImageCroppingShrinkRequest {
  aspectRatios?: string(name='AspectRatios'),
  credentialConfigShrink?: string(name='CredentialConfig'),
  projectName?: string(name='ProjectName', description='项目名称'),
  sourceURI?: string(name='SourceURI', description='SourceURI'),
}

model DetectImageCroppingResponseBody = {
  croppings?: [
    CroppingSuggestion
  ](name='Croppings', description='图片裁剪结果'),
  requestId?: string(name='RequestId', description='请求唯一ID'),
}

model DetectImageCroppingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectImageCroppingResponseBody(name='body'),
}

async function detectImageCroppingWithOptions(tmpReq: DetectImageCroppingRequest, runtime: Util.RuntimeOptions): DetectImageCroppingResponse {
  Util.validateModel(tmpReq);
  var request = new DetectImageCroppingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.credentialConfig)) {
    request.credentialConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.credentialConfig, 'CredentialConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.aspectRatios)) {
    query['AspectRatios'] = request.aspectRatios;
  }
  if (!Util.isUnset(request.credentialConfigShrink)) {
    query['CredentialConfig'] = request.credentialConfigShrink;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.sourceURI)) {
    query['SourceURI'] = request.sourceURI;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetectImageCropping',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectImageCropping(request: DetectImageCroppingRequest): DetectImageCroppingResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageCroppingWithOptions(request, runtime);
}

model DetectImageFacesRequest {
  credentialConfig?: CredentialConfig(name='CredentialConfig'),
  projectName?: string(name='ProjectName', description='项目名称'),
  sourceURI?: string(name='SourceURI'),
}

model DetectImageFacesShrinkRequest {
  credentialConfigShrink?: string(name='CredentialConfig'),
  projectName?: string(name='ProjectName', description='项目名称'),
  sourceURI?: string(name='SourceURI'),
}

model DetectImageFacesResponseBody = {
  faces?: [
    Figure
  ](name='Faces'),
  requestId?: string(name='RequestId', description='RequestId'),
}

model DetectImageFacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectImageFacesResponseBody(name='body'),
}

async function detectImageFacesWithOptions(tmpReq: DetectImageFacesRequest, runtime: Util.RuntimeOptions): DetectImageFacesResponse {
  Util.validateModel(tmpReq);
  var request = new DetectImageFacesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.credentialConfig)) {
    request.credentialConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.credentialConfig, 'CredentialConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.credentialConfigShrink)) {
    query['CredentialConfig'] = request.credentialConfigShrink;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.sourceURI)) {
    query['SourceURI'] = request.sourceURI;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetectImageFaces',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectImageFaces(request: DetectImageFacesRequest): DetectImageFacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageFacesWithOptions(request, runtime);
}

model DetectImageLabelsRequest {
  credentialConfig?: CredentialConfig(name='CredentialConfig'),
  projectName?: string(name='ProjectName', description='项目名称'),
  sourceURI?: string(name='SourceURI', description='SourceURI'),
  threshold?: float(name='Threshold', description='Threshold'),
}

model DetectImageLabelsShrinkRequest {
  credentialConfigShrink?: string(name='CredentialConfig'),
  projectName?: string(name='ProjectName', description='项目名称'),
  sourceURI?: string(name='SourceURI', description='SourceURI'),
  threshold?: float(name='Threshold', description='Threshold'),
}

model DetectImageLabelsResponseBody = {
  labels?: [
    Label
  ](name='Labels', description='内容标签列表'),
  requestId?: string(name='RequestId', description='请求唯一ID'),
}

model DetectImageLabelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectImageLabelsResponseBody(name='body'),
}

async function detectImageLabelsWithOptions(tmpReq: DetectImageLabelsRequest, runtime: Util.RuntimeOptions): DetectImageLabelsResponse {
  Util.validateModel(tmpReq);
  var request = new DetectImageLabelsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.credentialConfig)) {
    request.credentialConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.credentialConfig, 'CredentialConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.credentialConfigShrink)) {
    query['CredentialConfig'] = request.credentialConfigShrink;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.sourceURI)) {
    query['SourceURI'] = request.sourceURI;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetectImageLabels',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectImageLabels(request: DetectImageLabelsRequest): DetectImageLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageLabelsWithOptions(request, runtime);
}

model DetectImageScoreRequest {
  credentialConfig?: CredentialConfig(name='CredentialConfig'),
  projectName?: string(name='ProjectName', description='项目名称'),
  sourceURI?: string(name='SourceURI'),
}

model DetectImageScoreShrinkRequest {
  credentialConfigShrink?: string(name='CredentialConfig'),
  projectName?: string(name='ProjectName', description='项目名称'),
  sourceURI?: string(name='SourceURI'),
}

model DetectImageScoreResponseBody = {
  imageScore?: {
    overallQualityScore?: float(name='OverallQualityScore'),
  }(name='ImageScore'),
  requestId?: string(name='RequestId', description='RequestId'),
}

model DetectImageScoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectImageScoreResponseBody(name='body'),
}

async function detectImageScoreWithOptions(tmpReq: DetectImageScoreRequest, runtime: Util.RuntimeOptions): DetectImageScoreResponse {
  Util.validateModel(tmpReq);
  var request = new DetectImageScoreShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.credentialConfig)) {
    request.credentialConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.credentialConfig, 'CredentialConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.credentialConfigShrink)) {
    query['CredentialConfig'] = request.credentialConfigShrink;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.sourceURI)) {
    query['SourceURI'] = request.sourceURI;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetectImageScore',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectImageScore(request: DetectImageScoreRequest): DetectImageScoreResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectImageScoreWithOptions(request, runtime);
}

model DetectTextAnomalyRequest {
  content?: string(name='Content'),
  projectName?: string(name='ProjectName', description='项目名称'),
}

model DetectTextAnomalyResponseBody = {
  requestId?: string(name='RequestId', description='RequestId'),
  suggestion?: string(name='Suggestion'),
}

model DetectTextAnomalyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetectTextAnomalyResponseBody(name='body'),
}

async function detectTextAnomalyWithOptions(request: DetectTextAnomalyRequest, runtime: Util.RuntimeOptions): DetectTextAnomalyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetectTextAnomaly',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detectTextAnomaly(request: DetectTextAnomalyRequest): DetectTextAnomalyResponse {
  var runtime = new Util.RuntimeOptions{};
  return detectTextAnomalyWithOptions(request, runtime);
}

model FuzzyQueryRequest {
  datasetName?: string(name='DatasetName', description='Dataset 名称'),
  maxResults?: long(name='MaxResults', description='本次读取的最大数据记录数量'),
  nextToken?: string(name='NextToken', description='标记当前开始读取的位置，置空表示从头开始'),
  projectName?: string(name='ProjectName', description='项目名称'),
  query?: string(name='Query', description='用于搜索的字符串'),
}

model FuzzyQueryResponseBody = {
  files?: [
    File
  ](name='Files'),
  nextToken?: string(name='NextToken', description='表示当前调用返回读取到的位置，空代表数据已经读取完毕'),
  requestId?: string(name='RequestId', description='本次请求的唯一 Id'),
}

model FuzzyQueryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FuzzyQueryResponseBody(name='body'),
}

async function fuzzyQueryWithOptions(request: FuzzyQueryRequest, runtime: Util.RuntimeOptions): FuzzyQueryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.query)) {
    query['Query'] = request.query;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FuzzyQuery',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function fuzzyQuery(request: FuzzyQueryRequest): FuzzyQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  return fuzzyQueryWithOptions(request, runtime);
}

model GetBindingRequest {
  datasetName?: string(name='DatasetName'),
  projectName?: string(name='ProjectName'),
  URI?: string(name='URI'),
}

model GetBindingResponseBody = {
  binding?: Binding(name='Binding'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBindingResponseBody(name='body'),
}

async function getBindingWithOptions(request: GetBindingRequest, runtime: Util.RuntimeOptions): GetBindingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.URI)) {
    query['URI'] = request.URI;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBinding',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBinding(request: GetBindingRequest): GetBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBindingWithOptions(request, runtime);
}

model GetDatasetRequest {
  datasetName?: string(name='DatasetName'),
  projectName?: string(name='ProjectName'),
  withStatistics?: boolean(name='WithStatistics'),
}

model GetDatasetResponseBody = {
  dataset?: Dataset(name='Dataset'),
  requestId?: string(name='RequestId'),
}

model GetDatasetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDatasetResponseBody(name='body'),
}

async function getDatasetWithOptions(request: GetDatasetRequest, runtime: Util.RuntimeOptions): GetDatasetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.withStatistics)) {
    query['WithStatistics'] = request.withStatistics;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDataset',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDataset(request: GetDatasetRequest): GetDatasetResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDatasetWithOptions(request, runtime);
}

model GetDetectVideoLabelsResultRequest {
  projectName?: string(name='ProjectName', description='项目名称'),
  taskId?: string(name='TaskId', description='TaskId'),
  taskType?: string(name='TaskType', description='TaskType'),
}

model GetDetectVideoLabelsResultResponseBody = {
  code?: string(name='Code', description='任务错误码'),
  endTime?: string(name='EndTime', description='任务结束时间'),
  eventId?: string(name='EventId', description='事件Id'),
  labels?: [
    Label
  ](name='Labels', description='标签列表'),
  message?: string(name='Message', description='任务错误消息'),
  projectName?: string(name='ProjectName', description='项目名称'),
  requestId?: string(name='RequestId', description='请求唯一Id'),
  startTime?: string(name='StartTime', description='任务开始时间'),
  status?: string(name='Status', description='任务运行状态'),
  taskId?: string(name='TaskId', description='任务唯一ID'),
  taskType?: string(name='TaskType', description='任务类型'),
  userData?: string(name='UserData', description='用户自定义信息'),
}

model GetDetectVideoLabelsResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDetectVideoLabelsResultResponseBody(name='body'),
}

async function getDetectVideoLabelsResultWithOptions(request: GetDetectVideoLabelsResultRequest, runtime: Util.RuntimeOptions): GetDetectVideoLabelsResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDetectVideoLabelsResult',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDetectVideoLabelsResult(request: GetDetectVideoLabelsResultRequest): GetDetectVideoLabelsResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDetectVideoLabelsResultWithOptions(request, runtime);
}

model GetFigureClusterRequest {
  datasetName?: string(name='DatasetName'),
  objectId?: string(name='ObjectId'),
  projectName?: string(name='ProjectName'),
}

model GetFigureClusterResponseBody = {
  figureCluster?: FigureCluster(name='FigureCluster'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetFigureClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFigureClusterResponseBody(name='body'),
}

async function getFigureClusterWithOptions(request: GetFigureClusterRequest, runtime: Util.RuntimeOptions): GetFigureClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.objectId)) {
    query['ObjectId'] = request.objectId;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFigureCluster',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFigureCluster(request: GetFigureClusterRequest): GetFigureClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFigureClusterWithOptions(request, runtime);
}

model GetFileMetaRequest {
  datasetName?: string(name='DatasetName'),
  projectName?: string(name='ProjectName'),
  URI?: string(name='URI'),
}

model GetFileMetaResponseBody = {
  files?: [
    File
  ](name='Files', description='File list.'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetFileMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFileMetaResponseBody(name='body'),
}

async function getFileMetaWithOptions(request: GetFileMetaRequest, runtime: Util.RuntimeOptions): GetFileMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.URI)) {
    query['URI'] = request.URI;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFileMeta',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFileMeta(request: GetFileMetaRequest): GetFileMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFileMetaWithOptions(request, runtime);
}

model GetMediaMetaRequest {
  credentialConfig?: CredentialConfig(name='CredentialConfig'),
  projectName?: string(name='ProjectName'),
  sourceURI?: string(name='SourceURI'),
}

model GetMediaMetaShrinkRequest {
  credentialConfigShrink?: string(name='CredentialConfig'),
  projectName?: string(name='ProjectName'),
  sourceURI?: string(name='SourceURI'),
}

model GetMediaMetaResponseBody = {
  addresses?: [
    Address
  ](name='Addresses'),
  album?: string(name='Album'),
  albumArtist?: string(name='AlbumArtist'),
  artist?: string(name='Artist'),
  audioStreams?: [
    AudioStream
  ](name='AudioStreams'),
  bitrate?: long(name='Bitrate'),
  composer?: string(name='Composer'),
  duration?: double(name='Duration'),
  formatLongName?: string(name='FormatLongName'),
  formatName?: string(name='FormatName'),
  language?: string(name='Language'),
  latLong?: string(name='LatLong'),
  performer?: string(name='Performer'),
  produceTime?: string(name='ProduceTime'),
  programCount?: long(name='ProgramCount'),
  requestId?: string(name='RequestId'),
  size?: long(name='Size'),
  startTime?: double(name='StartTime'),
  streamCount?: long(name='StreamCount'),
  subtitles?: [
    SubtitleStream
  ](name='Subtitles'),
  title?: string(name='Title'),
  videoHeight?: long(name='VideoHeight'),
  videoStreams?: [
    VideoStream
  ](name='VideoStreams'),
  videoWidth?: long(name='VideoWidth'),
}

model GetMediaMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMediaMetaResponseBody(name='body'),
}

async function getMediaMetaWithOptions(tmpReq: GetMediaMetaRequest, runtime: Util.RuntimeOptions): GetMediaMetaResponse {
  Util.validateModel(tmpReq);
  var request = new GetMediaMetaShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.credentialConfig)) {
    request.credentialConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.credentialConfig, 'CredentialConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.credentialConfigShrink)) {
    query['CredentialConfig'] = request.credentialConfigShrink;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.sourceURI)) {
    query['SourceURI'] = request.sourceURI;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMediaMeta',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMediaMeta(request: GetMediaMetaRequest): GetMediaMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaMetaWithOptions(request, runtime);
}

model GetOSSBucketAttachmentRequest {
  OSSBucket?: string(name='OSSBucket'),
}

model GetOSSBucketAttachmentResponseBody = {
  projectName?: string(name='ProjectName'),
  requestId?: string(name='RequestId', description='RequestId'),
}

model GetOSSBucketAttachmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOSSBucketAttachmentResponseBody(name='body'),
}

async function getOSSBucketAttachmentWithOptions(request: GetOSSBucketAttachmentRequest, runtime: Util.RuntimeOptions): GetOSSBucketAttachmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.OSSBucket)) {
    query['OSSBucket'] = request.OSSBucket;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOSSBucketAttachment',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOSSBucketAttachment(request: GetOSSBucketAttachmentRequest): GetOSSBucketAttachmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOSSBucketAttachmentWithOptions(request, runtime);
}

model GetProjectRequest {
  projectName?: string(name='ProjectName', description='项目名称'),
  withStatistics?: boolean(name='WithStatistics', description='是否获取详细信息'),
}

model GetProjectResponseBody = {
  project?: Project(name='Project'),
  requestId?: string(name='RequestId', description='RequestId'),
}

model GetProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProjectResponseBody(name='body'),
}

async function getProjectWithOptions(request: GetProjectRequest, runtime: Util.RuntimeOptions): GetProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.withStatistics)) {
    query['WithStatistics'] = request.withStatistics;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProject',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProject(request: GetProjectRequest): GetProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProjectWithOptions(request, runtime);
}

model GetStoryRequest {
  datasetName?: string(name='DatasetName'),
  objectId?: string(name='ObjectId'),
  projectName?: string(name='ProjectName'),
}

model GetStoryResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  story?: Story(name='Story'),
}

model GetStoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStoryResponseBody(name='body'),
}

async function getStoryWithOptions(request: GetStoryRequest, runtime: Util.RuntimeOptions): GetStoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.objectId)) {
    query['ObjectId'] = request.objectId;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetStory',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStory(request: GetStoryRequest): GetStoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStoryWithOptions(request, runtime);
}

model GetTaskRequest {
  projectName?: string(name='ProjectName', description='项目名称'),
  taskId?: string(name='TaskId', description='TaskId'),
  taskType?: string(name='TaskType', description='TaskType'),
}

model GetTaskResponseBody = {
  code?: string(name='Code', description='任务错误码'),
  endTime?: string(name='EndTime', description='任务结束时间'),
  eventId?: string(name='EventId', description='事件Id'),
  message?: string(name='Message', description='任务错误消息'),
  projectName?: string(name='ProjectName', description='项目名称'),
  requestId?: string(name='RequestId', description='请求唯一Id'),
  startTime?: string(name='StartTime', description='任务开始时间'),
  status?: string(name='Status', description='任务运行状态'),
  tags?: map[string]any(name='Tags'),
  taskId?: string(name='TaskId', description='任务唯一ID'),
  taskType?: string(name='TaskType', description='任务类型'),
  userData?: string(name='UserData', description='用户自定义信息'),
}

model GetTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskResponseBody(name='body'),
}

async function getTaskWithOptions(request: GetTaskRequest, runtime: Util.RuntimeOptions): GetTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTask',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTask(request: GetTaskRequest): GetTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskWithOptions(request, runtime);
}

model GetWebofficeURLRequest {
  cachePreview?: boolean(name='CachePreview', description='缓存预览标识'),
  credentialConfig?: CredentialConfig(name='CredentialConfig'),
  externalUploaded?: boolean(name='ExternalUploaded', description='是否支持外部上传'),
  filename?: string(name='Filename', description='文件名，必须带文件名后缀，默认是 SourceUri 的最后一级'),
  hidecmb?: boolean(name='Hidecmb', description='隐藏工具栏，预览模式下使用'),
  notifyEndpoint?: string(name='NotifyEndpoint', description='mns 消息通知地址'),
  notifyTopicName?: string(name='NotifyTopicName', description='mns 消息通知 topic'),
  password?: string(name='Password', description='文件密码'),
  permission?: WebofficePermission(name='Permission', description='权限'),
  previewPages?: long(name='PreviewPages', description='预览前几页'),
  projectName?: string(name='ProjectName', description='项目名称'),
  referer?: string(name='Referer', description='oss 防盗链 referer'),
  sourceURI?: string(name='SourceURI', description='预览编辑地址'),
  user?: WebofficeUser(name='User', description='用户'),
  userData?: string(name='UserData', description='用户自定义数据，在消息通知中返回'),
  watermark?: WebofficeWatermark(name='Watermark', description='水印'),
}

model GetWebofficeURLShrinkRequest {
  cachePreview?: boolean(name='CachePreview', description='缓存预览标识'),
  credentialConfigShrink?: string(name='CredentialConfig'),
  externalUploaded?: boolean(name='ExternalUploaded', description='是否支持外部上传'),
  filename?: string(name='Filename', description='文件名，必须带文件名后缀，默认是 SourceUri 的最后一级'),
  hidecmb?: boolean(name='Hidecmb', description='隐藏工具栏，预览模式下使用'),
  notifyEndpoint?: string(name='NotifyEndpoint', description='mns 消息通知地址'),
  notifyTopicName?: string(name='NotifyTopicName', description='mns 消息通知 topic'),
  password?: string(name='Password', description='文件密码'),
  permissionShrink?: string(name='Permission', description='权限'),
  previewPages?: long(name='PreviewPages', description='预览前几页'),
  projectName?: string(name='ProjectName', description='项目名称'),
  referer?: string(name='Referer', description='oss 防盗链 referer'),
  sourceURI?: string(name='SourceURI', description='预览编辑地址'),
  userShrink?: string(name='User', description='用户'),
  userData?: string(name='UserData', description='用户自定义数据，在消息通知中返回'),
  watermarkShrink?: string(name='Watermark', description='水印'),
}

model GetWebofficeURLResponseBody = {
  accessToken?: string(name='AccessToken', description='access token'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime', description='access token 过期时间'),
  refreshToken?: string(name='RefreshToken', description='refresh token'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime', description='refresh token 过期时间'),
  requestId?: string(name='RequestId', description='请求 id'),
  webofficeURL?: string(name='WebofficeURL', description='预览编辑地址'),
}

model GetWebofficeURLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWebofficeURLResponseBody(name='body'),
}

async function getWebofficeURLWithOptions(tmpReq: GetWebofficeURLRequest, runtime: Util.RuntimeOptions): GetWebofficeURLResponse {
  Util.validateModel(tmpReq);
  var request = new GetWebofficeURLShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.credentialConfig)) {
    request.credentialConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.credentialConfig, 'CredentialConfig', 'json');
  }
  if (!Util.isUnset(tmpReq.permission)) {
    request.permissionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.permission, 'Permission', 'json');
  }
  if (!Util.isUnset(tmpReq.user)) {
    request.userShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.user, 'User', 'json');
  }
  if (!Util.isUnset(tmpReq.watermark)) {
    request.watermarkShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.watermark, 'Watermark', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.cachePreview)) {
    query['CachePreview'] = request.cachePreview;
  }
  if (!Util.isUnset(request.credentialConfigShrink)) {
    query['CredentialConfig'] = request.credentialConfigShrink;
  }
  if (!Util.isUnset(request.externalUploaded)) {
    query['ExternalUploaded'] = request.externalUploaded;
  }
  if (!Util.isUnset(request.filename)) {
    query['Filename'] = request.filename;
  }
  if (!Util.isUnset(request.hidecmb)) {
    query['Hidecmb'] = request.hidecmb;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.permissionShrink)) {
    query['Permission'] = request.permissionShrink;
  }
  if (!Util.isUnset(request.previewPages)) {
    query['PreviewPages'] = request.previewPages;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.referer)) {
    query['Referer'] = request.referer;
  }
  if (!Util.isUnset(request.sourceURI)) {
    query['SourceURI'] = request.sourceURI;
  }
  if (!Util.isUnset(request.userShrink)) {
    query['User'] = request.userShrink;
  }
  if (!Util.isUnset(request.userData)) {
    query['UserData'] = request.userData;
  }
  if (!Util.isUnset(request.watermarkShrink)) {
    query['Watermark'] = request.watermarkShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWebofficeURL',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWebofficeURL(request: GetWebofficeURLRequest): GetWebofficeURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWebofficeURLWithOptions(request, runtime);
}

model IndexFileMetaRequest {
  datasetName?: string(name='DatasetName'),
  file?: FileForReq(name='File'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  projectName?: string(name='ProjectName'),
}

model IndexFileMetaShrinkRequest {
  datasetName?: string(name='DatasetName'),
  fileShrink?: string(name='File'),
  notifyEndpoint?: string(name='NotifyEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  projectName?: string(name='ProjectName'),
}

model IndexFileMetaResponseBody = {
  eventId?: string(name='EventId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model IndexFileMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: IndexFileMetaResponseBody(name='body'),
}

async function indexFileMetaWithOptions(tmpReq: IndexFileMetaRequest, runtime: Util.RuntimeOptions): IndexFileMetaResponse {
  Util.validateModel(tmpReq);
  var request = new IndexFileMetaShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.file)) {
    request.fileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.file, 'File', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.fileShrink)) {
    query['File'] = request.fileShrink;
  }
  if (!Util.isUnset(request.notifyEndpoint)) {
    query['NotifyEndpoint'] = request.notifyEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'IndexFileMeta',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function indexFileMeta(request: IndexFileMetaRequest): IndexFileMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return indexFileMetaWithOptions(request, runtime);
}

model ListBindingsRequest {
  datasetName?: string(name='DatasetName'),
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  projectName?: string(name='ProjectName', description='A short description of struct'),
}

model ListBindingsResponseBody = {
  bindings?: [
    Binding
  ](name='Bindings'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListBindingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBindingsResponseBody(name='body'),
}

async function listBindingsWithOptions(request: ListBindingsRequest, runtime: Util.RuntimeOptions): ListBindingsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBindings',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBindings(request: ListBindingsRequest): ListBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBindingsWithOptions(request, runtime);
}

model ListDatasetsRequest {
  maxResults?: long(name='MaxResults', description='返回最大个数'),
  nextToken?: string(name='NextToken', description='当总结果个数大于MaxResults时，用于翻页的token'),
  prefix?: string(name='Prefix'),
  projectName?: string(name='ProjectName', description='项目名称'),
}

model ListDatasetsResponseBody = {
  datasets?: [
    Dataset
  ](name='Datasets', description='Datasets'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListDatasetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDatasetsResponseBody(name='body'),
}

async function listDatasetsWithOptions(request: ListDatasetsRequest, runtime: Util.RuntimeOptions): ListDatasetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['Prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDatasets',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDatasets(request: ListDatasetsRequest): ListDatasetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDatasetsWithOptions(request, runtime);
}

model ListProjectsRequest {
  maxResults?: long(name='MaxResults', description='返回结果的最大个数'),
  nextToken?: string(name='NextToken', description='当总结果个数大于MaxResults时，用于翻页的token'),
  prefix?: string(name='Prefix', description='列出包含某前缀的project'),
}

model ListProjectsResponseBody = {
  nextToken?: string(name='NextToken', description='当总结果个数大于MaxResults时，用于翻页的token'),
  projects?: [
    Project
  ](name='Projects', description='由ProjectItem组成的数组'),
  requestId?: string(name='RequestId', description='本次请求的唯一 ID'),
}

model ListProjectsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProjectsResponseBody(name='body'),
}

async function listProjectsWithOptions(request: ListProjectsRequest, runtime: Util.RuntimeOptions): ListProjectsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['Prefix'] = request.prefix;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProjects',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProjects(request: ListProjectsRequest): ListProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectsWithOptions(request, runtime);
}

model ListRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model ListRegionsResponseBody = {
  regions?: [
    RegionType
  ](name='Regions'),
  requestId?: string(name='RequestId', description='RequestId'),
}

model ListRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRegionsResponseBody(name='body'),
}

async function listRegionsWithOptions(request: ListRegionsRequest, runtime: Util.RuntimeOptions): ListRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRegions',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRegions(request: ListRegionsRequest): ListRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRegionsWithOptions(request, runtime);
}

model ListTasksRequest {
  endTimeRange?: TimeRange(name='EndTimeRange'),
  maxResults?: long(name='MaxResults', description='MaxResults'),
  nextToken?: string(name='NextToken', description='NextToken'),
  order?: string(name='Order'),
  projectName?: string(name='ProjectName', description='项目名称'),
  sort?: string(name='Sort'),
  startTimeRange?: TimeRange(name='StartTimeRange'),
  status?: string(name='Status'),
  tagSelector?: string(name='TagSelector'),
  taskTypes?: [ string ](name='TaskTypes'),
}

model ListTasksShrinkRequest {
  endTimeRangeShrink?: string(name='EndTimeRange'),
  maxResults?: long(name='MaxResults', description='MaxResults'),
  nextToken?: string(name='NextToken', description='NextToken'),
  order?: string(name='Order'),
  projectName?: string(name='ProjectName', description='项目名称'),
  sort?: string(name='Sort'),
  startTimeRangeShrink?: string(name='StartTimeRange'),
  status?: string(name='Status'),
  tagSelector?: string(name='TagSelector'),
  taskTypesShrink?: string(name='TaskTypes'),
}

model ListTasksResponseBody = {
  maxResults?: string(name='MaxResults', description='最大结果数量'),
  nextToken?: string(name='NextToken', description='翻页标记'),
  projectName?: string(name='ProjectName', description='项目名称'),
  requestId?: string(name='RequestId', description='请求唯一Id'),
  tasks?: [
    TaskInfo
  ](name='Tasks', description='任务信息'),
}

model ListTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTasksResponseBody(name='body'),
}

async function listTasksWithOptions(tmpReq: ListTasksRequest, runtime: Util.RuntimeOptions): ListTasksResponse {
  Util.validateModel(tmpReq);
  var request = new ListTasksShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.endTimeRange)) {
    request.endTimeRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.endTimeRange, 'EndTimeRange', 'json');
  }
  if (!Util.isUnset(tmpReq.startTimeRange)) {
    request.startTimeRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.startTimeRange, 'StartTimeRange', 'json');
  }
  if (!Util.isUnset(tmpReq.taskTypes)) {
    request.taskTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.taskTypes, 'TaskTypes', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.endTimeRangeShrink)) {
    query['EndTimeRange'] = request.endTimeRangeShrink;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }
  if (!Util.isUnset(request.startTimeRangeShrink)) {
    query['StartTimeRange'] = request.startTimeRangeShrink;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tagSelector)) {
    query['TagSelector'] = request.tagSelector;
  }
  if (!Util.isUnset(request.taskTypesShrink)) {
    query['TaskTypes'] = request.taskTypesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTasks',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTasks(request: ListTasksRequest): ListTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTasksWithOptions(request, runtime);
}

model MergeFigureClustersRequest {
  clusterIdFrom?: string(name='ClusterIdFrom'),
  clusterIdTo?: string(name='ClusterIdTo'),
  customMessage?: string(name='CustomMessage'),
  datasetName?: string(name='DatasetName'),
  figureType?: string(name='FigureType'),
  notifyTopicEndpoint?: string(name='NotifyTopicEndpoint'),
  notifyTopicName?: string(name='NotifyTopicName'),
  projectName?: string(name='ProjectName'),
}

model MergeFigureClustersResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  taskId?: string(name='TaskId'),
}

model MergeFigureClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MergeFigureClustersResponseBody(name='body'),
}

async function mergeFigureClustersWithOptions(request: MergeFigureClustersRequest, runtime: Util.RuntimeOptions): MergeFigureClustersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterIdFrom)) {
    query['ClusterIdFrom'] = request.clusterIdFrom;
  }
  if (!Util.isUnset(request.clusterIdTo)) {
    query['ClusterIdTo'] = request.clusterIdTo;
  }
  if (!Util.isUnset(request.customMessage)) {
    query['CustomMessage'] = request.customMessage;
  }
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.figureType)) {
    query['FigureType'] = request.figureType;
  }
  if (!Util.isUnset(request.notifyTopicEndpoint)) {
    query['NotifyTopicEndpoint'] = request.notifyTopicEndpoint;
  }
  if (!Util.isUnset(request.notifyTopicName)) {
    query['NotifyTopicName'] = request.notifyTopicName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MergeFigureClusters',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function mergeFigureClusters(request: MergeFigureClustersRequest): MergeFigureClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return mergeFigureClustersWithOptions(request, runtime);
}

model QueryFigureClustersRequest {
  customLabels?: string(name='CustomLabels'),
  datasetName?: string(name='DatasetName'),
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  order?: string(name='Order', description='升降序'),
  projectName?: string(name='ProjectName'),
  sort?: string(name='Sort', description='排序字段'),
}

model QueryFigureClustersResponseBody = {
  figureClusters?: [
    FigureCluster
  ](name='FigureClusters'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model QueryFigureClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryFigureClustersResponseBody(name='body'),
}

async function queryFigureClustersWithOptions(request: QueryFigureClustersRequest, runtime: Util.RuntimeOptions): QueryFigureClustersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customLabels)) {
    query['CustomLabels'] = request.customLabels;
  }
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryFigureClusters',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryFigureClusters(request: QueryFigureClustersRequest): QueryFigureClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFigureClustersWithOptions(request, runtime);
}

model QueryStoriesRequest {
  createTimeRange?: TimeRange(name='CreateTimeRange'),
  customLabels?: string(name='CustomLabels'),
  datasetName?: string(name='DatasetName'),
  figureClusterIds?: [ string ](name='FigureClusterIds'),
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  objectId?: string(name='ObjectId'),
  order?: string(name='Order'),
  projectName?: string(name='ProjectName'),
  sort?: string(name='Sort'),
  storyEndTimeRange?: TimeRange(name='StoryEndTimeRange'),
  storyName?: string(name='StoryName'),
  storyStartTimeRange?: TimeRange(name='StoryStartTimeRange'),
  storySubType?: string(name='StorySubType'),
  storyType?: string(name='StoryType'),
  withEmptyStories?: boolean(name='WithEmptyStories'),
}

model QueryStoriesShrinkRequest {
  createTimeRangeShrink?: string(name='CreateTimeRange'),
  customLabels?: string(name='CustomLabels'),
  datasetName?: string(name='DatasetName'),
  figureClusterIdsShrink?: string(name='FigureClusterIds'),
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  objectId?: string(name='ObjectId'),
  order?: string(name='Order'),
  projectName?: string(name='ProjectName'),
  sort?: string(name='Sort'),
  storyEndTimeRangeShrink?: string(name='StoryEndTimeRange'),
  storyName?: string(name='StoryName'),
  storyStartTimeRangeShrink?: string(name='StoryStartTimeRange'),
  storySubType?: string(name='StorySubType'),
  storyType?: string(name='StoryType'),
  withEmptyStories?: boolean(name='WithEmptyStories'),
}

model QueryStoriesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId', description='Id of the request'),
  stories?: [
    Story
  ](name='Stories'),
}

model QueryStoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryStoriesResponseBody(name='body'),
}

async function queryStoriesWithOptions(tmpReq: QueryStoriesRequest, runtime: Util.RuntimeOptions): QueryStoriesResponse {
  Util.validateModel(tmpReq);
  var request = new QueryStoriesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.createTimeRange)) {
    request.createTimeRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.createTimeRange, 'CreateTimeRange', 'json');
  }
  if (!Util.isUnset(tmpReq.figureClusterIds)) {
    request.figureClusterIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.figureClusterIds, 'FigureClusterIds', 'json');
  }
  if (!Util.isUnset(tmpReq.storyEndTimeRange)) {
    request.storyEndTimeRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.storyEndTimeRange, 'StoryEndTimeRange', 'json');
  }
  if (!Util.isUnset(tmpReq.storyStartTimeRange)) {
    request.storyStartTimeRangeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.storyStartTimeRange, 'StoryStartTimeRange', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.createTimeRangeShrink)) {
    query['CreateTimeRange'] = request.createTimeRangeShrink;
  }
  if (!Util.isUnset(request.customLabels)) {
    query['CustomLabels'] = request.customLabels;
  }
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.figureClusterIdsShrink)) {
    query['FigureClusterIds'] = request.figureClusterIdsShrink;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.objectId)) {
    query['ObjectId'] = request.objectId;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }
  if (!Util.isUnset(request.storyEndTimeRangeShrink)) {
    query['StoryEndTimeRange'] = request.storyEndTimeRangeShrink;
  }
  if (!Util.isUnset(request.storyName)) {
    query['StoryName'] = request.storyName;
  }
  if (!Util.isUnset(request.storyStartTimeRangeShrink)) {
    query['StoryStartTimeRange'] = request.storyStartTimeRangeShrink;
  }
  if (!Util.isUnset(request.storySubType)) {
    query['StorySubType'] = request.storySubType;
  }
  if (!Util.isUnset(request.storyType)) {
    query['StoryType'] = request.storyType;
  }
  if (!Util.isUnset(request.withEmptyStories)) {
    query['WithEmptyStories'] = request.withEmptyStories;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryStories',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryStories(request: QueryStoriesRequest): QueryStoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryStoriesWithOptions(request, runtime);
}

model RefreshWebofficeTokenRequest {
  accessToken?: string(name='AccessToken', description='access token'),
  credentialConfig?: CredentialConfig(name='CredentialConfig'),
  projectName?: string(name='ProjectName', description='项目名称'),
  refreshToken?: string(name='RefreshToken', description='refresh token'),
}

model RefreshWebofficeTokenShrinkRequest {
  accessToken?: string(name='AccessToken', description='access token'),
  credentialConfigShrink?: string(name='CredentialConfig'),
  projectName?: string(name='ProjectName', description='项目名称'),
  refreshToken?: string(name='RefreshToken', description='refresh token'),
}

model RefreshWebofficeTokenResponseBody = {
  accessToken?: string(name='AccessToken', description='access token'),
  accessTokenExpiredTime?: string(name='AccessTokenExpiredTime', description='access token 过期时间'),
  refreshToken?: string(name='RefreshToken', description='refresh token'),
  refreshTokenExpiredTime?: string(name='RefreshTokenExpiredTime', description='refresh token 过期时间'),
  requestId?: string(name='RequestId', description='请求 Id'),
}

model RefreshWebofficeTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefreshWebofficeTokenResponseBody(name='body'),
}

async function refreshWebofficeTokenWithOptions(tmpReq: RefreshWebofficeTokenRequest, runtime: Util.RuntimeOptions): RefreshWebofficeTokenResponse {
  Util.validateModel(tmpReq);
  var request = new RefreshWebofficeTokenShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.credentialConfig)) {
    request.credentialConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.credentialConfig, 'CredentialConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.accessToken)) {
    query['AccessToken'] = request.accessToken;
  }
  if (!Util.isUnset(request.credentialConfigShrink)) {
    query['CredentialConfig'] = request.credentialConfigShrink;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.refreshToken)) {
    query['RefreshToken'] = request.refreshToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshWebofficeToken',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshWebofficeToken(request: RefreshWebofficeTokenRequest): RefreshWebofficeTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshWebofficeTokenWithOptions(request, runtime);
}

model RemoveStoryFilesRequest {
  datasetName?: string(name='DatasetName'),
  files?: [ 
    {
      URI?: string(name='URI'),
    }
  ](name='Files'),
  objectId?: string(name='ObjectId'),
  projectName?: string(name='ProjectName', description='A short description of struct'),
}

model RemoveStoryFilesShrinkRequest {
  datasetName?: string(name='DatasetName'),
  filesShrink?: string(name='Files'),
  objectId?: string(name='ObjectId'),
  projectName?: string(name='ProjectName', description='A short description of struct'),
}

model RemoveStoryFilesResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RemoveStoryFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveStoryFilesResponseBody(name='body'),
}

async function removeStoryFilesWithOptions(tmpReq: RemoveStoryFilesRequest, runtime: Util.RuntimeOptions): RemoveStoryFilesResponse {
  Util.validateModel(tmpReq);
  var request = new RemoveStoryFilesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.files)) {
    request.filesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.files, 'Files', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.datasetName)) {
    body['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.filesShrink)) {
    body['Files'] = request.filesShrink;
  }
  if (!Util.isUnset(request.objectId)) {
    body['ObjectId'] = request.objectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveStoryFiles',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeStoryFiles(request: RemoveStoryFilesRequest): RemoveStoryFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeStoryFilesWithOptions(request, runtime);
}

model ResumeBindingRequest {
  datasetName?: string(name='DatasetName'),
  projectName?: string(name='ProjectName'),
  URI?: string(name='URI'),
}

model ResumeBindingResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ResumeBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResumeBindingResponseBody(name='body'),
}

async function resumeBindingWithOptions(request: ResumeBindingRequest, runtime: Util.RuntimeOptions): ResumeBindingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.URI)) {
    query['URI'] = request.URI;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResumeBinding',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resumeBinding(request: ResumeBindingRequest): ResumeBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeBindingWithOptions(request, runtime);
}

model SemanticQueryRequest {
  datasetName?: string(name='DatasetName', description='Dataset 名称'),
  maxResults?: int32(name='MaxResults', description='本次读取的最大数据记录数量'),
  nextToken?: string(name='NextToken', description='标记当前开始读取的位置，置空表示从头开始'),
  projectName?: string(name='ProjectName', description='项目名称'),
  query?: string(name='Query', description='需要搜索的内容，使用自然语言描述'),
}

model SemanticQueryResponseBody = {
  aggregations?: [ 
    {
      field?: string(name='Field', description='聚合字段名'),
      groups?: [ 
        {
          count?: long(name='Count', description='分组聚合的计数'),
          value?: string(name='Value', description='分组聚合的值'),
        }
      ](name='Groups', description='分组聚合的结果'),
      operation?: string(name='Operation', description='聚合字段的聚合操作符'),
      value?: float(name='Value', description='聚合的统计结果'),
    }
  ](name='Aggregations', description='聚合字段的字段名'),
  files?: [
    File
  ](name='Files', description='文件列表'),
  nextToken?: string(name='NextToken', description='表示当前调用返回读取到的位置，空代表数据已经读取完毕'),
  requestId?: string(name='RequestId', description='本次请求的唯一 Id'),
}

model SemanticQueryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SemanticQueryResponseBody(name='body'),
}

async function semanticQueryWithOptions(request: SemanticQueryRequest, runtime: Util.RuntimeOptions): SemanticQueryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.query)) {
    query['Query'] = request.query;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SemanticQuery',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function semanticQuery(request: SemanticQueryRequest): SemanticQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  return semanticQueryWithOptions(request, runtime);
}

model SimpleQueryRequest {
  aggregations?: [ 
    {
      field?: string(name='Field', description='聚合字段的字段名'),
      operation?: string(name='Operation', description='聚合字段的聚合操作符'),
    }
  ](name='Aggregations', description='聚合字段'),
  datasetName?: string(name='DatasetName', description='Dataset 名称'),
  maxResults?: int32(name='MaxResults', description='本次读取的最大数据记录数量'),
  nextToken?: string(name='NextToken', description='标记当前开始读取的位置，置空表示从头开始'),
  order?: string(name='Order', description='排序字段'),
  projectName?: string(name='ProjectName', description='项目名称'),
  query?: SimpleQuery(name='Query'),
  sort?: string(name='Sort', description='排序方式，默认 DESC'),
  withFields?: [ string ](name='WithFields', description='仅返回哪些字段'),
}

model SimpleQueryShrinkRequest {
  aggregationsShrink?: string(name='Aggregations', description='聚合字段'),
  datasetName?: string(name='DatasetName', description='Dataset 名称'),
  maxResults?: int32(name='MaxResults', description='本次读取的最大数据记录数量'),
  nextToken?: string(name='NextToken', description='标记当前开始读取的位置，置空表示从头开始'),
  order?: string(name='Order', description='排序字段'),
  projectName?: string(name='ProjectName', description='项目名称'),
  queryShrink?: string(name='Query'),
  sort?: string(name='Sort', description='排序方式，默认 DESC'),
  withFieldsShrink?: string(name='WithFields', description='仅返回哪些字段'),
}

model SimpleQueryResponseBody = {
  aggregations?: [ 
    {
      field?: string(name='Field', description='聚合字段名'),
      groups?: [ 
        {
          count?: long(name='Count', description='分组聚合的计数'),
          value?: string(name='Value', description='分组聚合的值'),
        }
      ](name='Groups', description='分组聚合的结果'),
      operation?: string(name='Operation', description='聚合字段的聚合操作符'),
      value?: double(name='Value'),
    }
  ](name='Aggregations', description='聚合字段的字段名'),
  files?: [
    File
  ](name='Files', description='文件列表'),
  nextToken?: string(name='NextToken', description='表示当前调用返回读取到的位置，空代表数据已经读取完毕'),
  requestId?: string(name='RequestId', description='本次请求的唯一 Id'),
}

model SimpleQueryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SimpleQueryResponseBody(name='body'),
}

async function simpleQueryWithOptions(tmpReq: SimpleQueryRequest, runtime: Util.RuntimeOptions): SimpleQueryResponse {
  Util.validateModel(tmpReq);
  var request = new SimpleQueryShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.aggregations)) {
    request.aggregationsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.aggregations, 'Aggregations', 'json');
  }
  if (!Util.isUnset(tmpReq.query)) {
    request.queryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.query, 'Query', 'json');
  }
  if (!Util.isUnset(tmpReq.withFields)) {
    request.withFieldsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.withFields, 'WithFields', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.aggregationsShrink)) {
    query['Aggregations'] = request.aggregationsShrink;
  }
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.queryShrink)) {
    query['Query'] = request.queryShrink;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }
  if (!Util.isUnset(request.withFieldsShrink)) {
    query['WithFields'] = request.withFieldsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SimpleQuery',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function simpleQuery(request: SimpleQueryRequest): SimpleQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  return simpleQueryWithOptions(request, runtime);
}

model StopBindingRequest {
  datasetName?: string(name='DatasetName'),
  projectName?: string(name='ProjectName'),
  reason?: string(name='Reason'),
  URI?: string(name='URI'),
}

model StopBindingResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model StopBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopBindingResponseBody(name='body'),
}

async function stopBindingWithOptions(request: StopBindingRequest, runtime: Util.RuntimeOptions): StopBindingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.URI)) {
    query['URI'] = request.URI;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopBinding',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopBinding(request: StopBindingRequest): StopBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopBindingWithOptions(request, runtime);
}

model UpdateDatasetRequest {
  datasetMaxBindCount?: long(name='DatasetMaxBindCount', description='媒体集最多绑定数'),
  datasetMaxEntityCount?: long(name='DatasetMaxEntityCount', description='媒体集最多实体数'),
  datasetMaxFileCount?: long(name='DatasetMaxFileCount', description='媒体集最多文件数'),
  datasetMaxRelationCount?: long(name='DatasetMaxRelationCount', description='媒体集最多关系数'),
  datasetMaxTotalFileSize?: long(name='DatasetMaxTotalFileSize', description='媒体集最大文件总大小'),
  datasetName?: string(name='DatasetName', description='媒体集名称'),
  description?: string(name='Description', description='描述'),
  projectName?: string(name='ProjectName', description='项目名称'),
  templateId?: string(name='TemplateId', description='模板Id'),
}

model UpdateDatasetResponseBody = {
  dataset?: Dataset(name='Dataset'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateDatasetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDatasetResponseBody(name='body'),
}

async function updateDatasetWithOptions(request: UpdateDatasetRequest, runtime: Util.RuntimeOptions): UpdateDatasetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetMaxBindCount)) {
    query['DatasetMaxBindCount'] = request.datasetMaxBindCount;
  }
  if (!Util.isUnset(request.datasetMaxEntityCount)) {
    query['DatasetMaxEntityCount'] = request.datasetMaxEntityCount;
  }
  if (!Util.isUnset(request.datasetMaxFileCount)) {
    query['DatasetMaxFileCount'] = request.datasetMaxFileCount;
  }
  if (!Util.isUnset(request.datasetMaxRelationCount)) {
    query['DatasetMaxRelationCount'] = request.datasetMaxRelationCount;
  }
  if (!Util.isUnset(request.datasetMaxTotalFileSize)) {
    query['DatasetMaxTotalFileSize'] = request.datasetMaxTotalFileSize;
  }
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDataset',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDataset(request: UpdateDatasetRequest): UpdateDatasetResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDatasetWithOptions(request, runtime);
}

model UpdateFigureClusterRequest {
  datasetName?: string(name='DatasetName'),
  figureCluster?: FigureClusterForReq(name='FigureCluster'),
  projectName?: string(name='ProjectName'),
}

model UpdateFigureClusterShrinkRequest {
  datasetName?: string(name='DatasetName'),
  figureClusterShrink?: string(name='FigureCluster'),
  projectName?: string(name='ProjectName'),
}

model UpdateFigureClusterResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateFigureClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFigureClusterResponseBody(name='body'),
}

async function updateFigureClusterWithOptions(tmpReq: UpdateFigureClusterRequest, runtime: Util.RuntimeOptions): UpdateFigureClusterResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateFigureClusterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.figureCluster)) {
    request.figureClusterShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.figureCluster, 'FigureCluster', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.figureClusterShrink)) {
    query['FigureCluster'] = request.figureClusterShrink;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFigureCluster',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateFigureCluster(request: UpdateFigureClusterRequest): UpdateFigureClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFigureClusterWithOptions(request, runtime);
}

model UpdateFileMetaRequest {
  datasetName?: string(name='DatasetName'),
  file?: FileForReq(name='File'),
  projectName?: string(name='ProjectName'),
}

model UpdateFileMetaShrinkRequest {
  datasetName?: string(name='DatasetName'),
  fileShrink?: string(name='File'),
  projectName?: string(name='ProjectName'),
}

model UpdateFileMetaResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateFileMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFileMetaResponseBody(name='body'),
}

async function updateFileMetaWithOptions(tmpReq: UpdateFileMetaRequest, runtime: Util.RuntimeOptions): UpdateFileMetaResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateFileMetaShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.file)) {
    request.fileShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.file, 'File', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.datasetName)) {
    query['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.fileShrink)) {
    query['File'] = request.fileShrink;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFileMeta',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateFileMeta(request: UpdateFileMetaRequest): UpdateFileMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFileMetaWithOptions(request, runtime);
}

model UpdateProjectRequest {
  datasetMaxBindCount?: long(name='DatasetMaxBindCount', description='媒体集最多绑定数'),
  datasetMaxEntityCount?: long(name='DatasetMaxEntityCount', description='媒体集最多实体数'),
  datasetMaxFileCount?: long(name='DatasetMaxFileCount', description='媒体集最多文件数'),
  datasetMaxRelationCount?: long(name='DatasetMaxRelationCount', description='媒体集最多关系数'),
  datasetMaxTotalFileSize?: long(name='DatasetMaxTotalFileSize', description='媒体集最大文件总大小'),
  description?: string(name='Description', description='项目描述'),
  engineConcurrency?: long(name='EngineConcurrency', description='项目并发数'),
  projectMaxDatasetCount?: long(name='ProjectMaxDatasetCount', description='项目最多媒体集数'),
  projectName?: string(name='ProjectName', description='项目名称'),
  projectQueriesPerSecond?: long(name='ProjectQueriesPerSecond', description='项目QPS'),
  serviceRole?: string(name='ServiceRole', description='服务角色'),
  templateId?: string(name='TemplateId', description='模板Id'),
}

model UpdateProjectResponseBody = {
  project?: Project(name='Project'),
  requestId?: string(name='RequestId', description='请求ID'),
}

model UpdateProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProjectResponseBody(name='body'),
}

async function updateProjectWithOptions(request: UpdateProjectRequest, runtime: Util.RuntimeOptions): UpdateProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.datasetMaxBindCount)) {
    query['DatasetMaxBindCount'] = request.datasetMaxBindCount;
  }
  if (!Util.isUnset(request.datasetMaxEntityCount)) {
    query['DatasetMaxEntityCount'] = request.datasetMaxEntityCount;
  }
  if (!Util.isUnset(request.datasetMaxFileCount)) {
    query['DatasetMaxFileCount'] = request.datasetMaxFileCount;
  }
  if (!Util.isUnset(request.datasetMaxRelationCount)) {
    query['DatasetMaxRelationCount'] = request.datasetMaxRelationCount;
  }
  if (!Util.isUnset(request.datasetMaxTotalFileSize)) {
    query['DatasetMaxTotalFileSize'] = request.datasetMaxTotalFileSize;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.engineConcurrency)) {
    query['EngineConcurrency'] = request.engineConcurrency;
  }
  if (!Util.isUnset(request.projectMaxDatasetCount)) {
    query['ProjectMaxDatasetCount'] = request.projectMaxDatasetCount;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.projectQueriesPerSecond)) {
    query['ProjectQueriesPerSecond'] = request.projectQueriesPerSecond;
  }
  if (!Util.isUnset(request.serviceRole)) {
    query['ServiceRole'] = request.serviceRole;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProject',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProject(request: UpdateProjectRequest): UpdateProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProjectWithOptions(request, runtime);
}

model UpdateStoryRequest {
  cover?: {
    URI?: string(name='URI'),
  }(name='Cover'),
  customId?: string(name='CustomId'),
  customLabels?: map[string]any(name='CustomLabels'),
  datasetName?: string(name='DatasetName'),
  objectId?: string(name='ObjectId'),
  projectName?: string(name='ProjectName'),
  storyName?: string(name='StoryName'),
}

model UpdateStoryShrinkRequest {
  coverShrink?: string(name='Cover'),
  customId?: string(name='CustomId'),
  customLabelsShrink?: string(name='CustomLabels'),
  datasetName?: string(name='DatasetName'),
  objectId?: string(name='ObjectId'),
  projectName?: string(name='ProjectName'),
  storyName?: string(name='StoryName'),
}

model UpdateStoryResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateStoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateStoryResponseBody(name='body'),
}

async function updateStoryWithOptions(tmpReq: UpdateStoryRequest, runtime: Util.RuntimeOptions): UpdateStoryResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateStoryShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.cover)) {
    request.coverShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cover, 'Cover', 'json');
  }
  if (!Util.isUnset(tmpReq.customLabels)) {
    request.customLabelsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.customLabels, 'CustomLabels', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.coverShrink)) {
    body['Cover'] = request.coverShrink;
  }
  if (!Util.isUnset(request.customId)) {
    body['CustomId'] = request.customId;
  }
  if (!Util.isUnset(request.customLabelsShrink)) {
    body['CustomLabels'] = request.customLabelsShrink;
  }
  if (!Util.isUnset(request.datasetName)) {
    body['DatasetName'] = request.datasetName;
  }
  if (!Util.isUnset(request.objectId)) {
    body['ObjectId'] = request.objectId;
  }
  if (!Util.isUnset(request.projectName)) {
    body['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.storyName)) {
    body['StoryName'] = request.storyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateStory',
    version = '2020-09-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateStory(request: UpdateStoryRequest): UpdateStoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateStoryWithOptions(request, runtime);
}

