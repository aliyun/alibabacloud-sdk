/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'rtc';
  @version = '2018-01-11';
  @endpointRule = 'central';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddRecordTemplateRequest {
  appId: string(name='AppId', position='Query'),
  backgroundColor?: int32(name='BackgroundColor', position='Query'),
  backgrounds?: [ 
    {
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Backgrounds', position='Query'),
  clockWidgets?: [ 
    {
      fontColor?: int32(name='FontColor'),
      fontSize?: int32(name='FontSize'),
      fontType?: int32(name='FontType'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='ClockWidgets', position='Query'),
  delayStopTime?: int32(name='DelayStopTime', minimum=5, maximum=86400, position='Query'),
  enableM3u8DateTime?: boolean(name='EnableM3u8DateTime', position='Query'),
  fileSplitInterval: int32(name='FileSplitInterval', position='Query'),
  formats: [ string ](name='Formats', position='Query'),
  httpCallbackUrl?: string(name='HttpCallbackUrl', position='Query'),
  layoutIds: [ long ](name='LayoutIds', position='Query'),
  mediaEncode: int32(name='MediaEncode', position='Query'),
  mnsQueue?: string(name='MnsQueue', position='Query'),
  name: string(name='Name', position='Query'),
  ossBucket: string(name='OssBucket', position='Query'),
  ossFilePrefix: string(name='OssFilePrefix', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  taskProfile: string(name='TaskProfile', position='Query'),
  watermarks?: [ 
    {
      alpha?: float(name='Alpha'),
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Watermarks', position='Query'),
}

model AddRecordTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model AddRecordTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddRecordTemplateResponseBody(name='body'),
}

async function addRecordTemplate(request: AddRecordTemplateRequest): AddRecordTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddRecordTemplate', 'POST', '/', 'json', false, 'json', request);
}

model CreateAutoLiveStreamRuleRequest {
  appId: string(name='AppId', position='Query'),
  callBack?: string(name='CallBack', position='Query'),
  channelIdPrefixes?: [ string ](name='ChannelIdPrefixes', position='Query'),
  channelIds?: [ string ](name='ChannelIds', position='Query'),
  mediaEncode?: int32(name='MediaEncode', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  playDomain: string(name='PlayDomain', position='Query'),
  ruleName?: string(name='RuleName', position='Query'),
}

model CreateAutoLiveStreamRuleResponseBody = {
  requestId?: string(name='RequestId'),
  ruleId?: long(name='RuleId'),
}

model CreateAutoLiveStreamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAutoLiveStreamRuleResponseBody(name='body'),
}

async function createAutoLiveStreamRule(request: CreateAutoLiveStreamRuleRequest): CreateAutoLiveStreamRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAutoLiveStreamRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateEventSubscribeRequest {
  appId: string(name='AppId', position='Query'),
  callbackUrl: string(name='CallbackUrl', position='Query'),
  channelId?: string(name='ChannelId', position='Query'),
  clientToken: string(name='ClientToken', position='Query'),
  events: [ string ](name='Events', position='Query'),
  needCallbackAuth?: boolean(name='NeedCallbackAuth', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  users?: [ string ](name='Users', position='Query'),
}

model CreateEventSubscribeResponseBody = {
  requestId?: string(name='RequestId'),
  subscribeId?: string(name='SubscribeId'),
}

model CreateEventSubscribeResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEventSubscribeResponseBody(name='body'),
}

async function createEventSubscribe(request: CreateEventSubscribeRequest): CreateEventSubscribeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateEventSubscribe', 'POST', '/', 'json', false, 'json', request);
}

model CreateMPULayoutRequest {
  appId: string(name='AppId', position='Query'),
  audioMixCount: int32(name='AudioMixCount', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  panes: [ 
    {
      height?: float(name='Height'),
      majorPane?: int32(name='MajorPane'),
      paneId?: int32(name='PaneId'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Panes', position='Query'),
}

model CreateMPULayoutResponseBody = {
  layoutId?: long(name='LayoutId'),
  requestId?: string(name='RequestId'),
}

model CreateMPULayoutResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMPULayoutResponseBody(name='body'),
}

async function createMPULayout(request: CreateMPULayoutRequest): CreateMPULayoutResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMPULayout', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAutoLiveStreamRuleRequest {
  appId: string(name='AppId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model DeleteAutoLiveStreamRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAutoLiveStreamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAutoLiveStreamRuleResponseBody(name='body'),
}

async function deleteAutoLiveStreamRule(request: DeleteAutoLiveStreamRuleRequest): DeleteAutoLiveStreamRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAutoLiveStreamRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteChannelRequest {
  appId: string(name='AppId', position='Query'),
  channelId: string(name='ChannelId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
}

model DeleteChannelResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteChannelResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteChannelResponseBody(name='body'),
}

async function deleteChannel(request: DeleteChannelRequest): DeleteChannelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteChannel', 'POST', '/', 'json', false, 'json', request);
}

model DeleteEventSubscribeRequest {
  appId: string(name='AppId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  subscribeId: string(name='SubscribeId', position='Query'),
}

model DeleteEventSubscribeResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteEventSubscribeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEventSubscribeResponseBody(name='body'),
}

async function deleteEventSubscribe(request: DeleteEventSubscribeRequest): DeleteEventSubscribeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteEventSubscribe', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMPULayoutRequest {
  appId: string(name='AppId', position='Query'),
  layoutId: long(name='LayoutId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
}

model DeleteMPULayoutResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMPULayoutResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMPULayoutResponseBody(name='body'),
}

async function deleteMPULayout(request: DeleteMPULayoutRequest): DeleteMPULayoutResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMPULayout', 'POST', '/', 'json', false, 'json', request);
}

model DeleteRecordTemplateRequest {
  appId: string(name='AppId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  templateId: string(name='TemplateId', position='Query'),
}

model DeleteRecordTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRecordTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRecordTemplateResponseBody(name='body'),
}

async function deleteRecordTemplate(request: DeleteRecordTemplateRequest): DeleteRecordTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRecordTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAppsRequest {
  appId?: string(name='AppId', position='Query'),
  order?: string(name='Order', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, position='Query'),
  status?: string(name='Status', position='Query'),
}

model DescribeAppsResponseBody = {
  appList?: {
    app?: [ 
    {
      appId?: string(name='AppId'),
      appName?: string(name='AppName'),
      appType?: string(name='AppType'),
      billType?: string(name='BillType'),
      createTime?: string(name='CreateTime'),
      serviceAreas?: {
        serviceArea?: [ string ](name='ServiceArea')
      }(name='ServiceAreas'),
      status?: int32(name='Status'),
    }
  ](name='App')
  }(name='AppList'),
  requestId?: string(name='RequestId'),
  totalNum?: int32(name='TotalNum'),
  totalPage?: int32(name='TotalPage'),
}

model DescribeAppsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAppsResponseBody(name='body'),
}

async function describeApps(request: DescribeAppsRequest): DescribeAppsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeApps', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAutoLiveStreamRuleRequest {
  appId: string(name='AppId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
}

model DescribeAutoLiveStreamRuleResponseBody = {
  requestId?: string(name='RequestId'),
  rules?: [ 
    {
      callBack?: string(name='CallBack'),
      channelIdPrefixes?: [ string ](name='ChannelIdPrefixes'),
      channelIds?: [ string ](name='ChannelIds'),
      createTime?: string(name='CreateTime'),
      mediaEncode?: int32(name='MediaEncode'),
      playDomain?: string(name='PlayDomain'),
      ruleId?: long(name='RuleId'),
      ruleName?: string(name='RuleName'),
      status?: string(name='Status'),
    }
  ](name='Rules'),
}

model DescribeAutoLiveStreamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoLiveStreamRuleResponseBody(name='body'),
}

async function describeAutoLiveStreamRule(request: DescribeAutoLiveStreamRuleRequest): DescribeAutoLiveStreamRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoLiveStreamRule', 'POST', '/', 'json', false, 'json', request);
}

model DescribeChannelParticipantsRequest {
  appId: string(name='AppId', position='Query'),
  channelId: string(name='ChannelId', position='Query'),
  order?: string(name='Order', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, position='Query'),
}

model DescribeChannelParticipantsResponseBody = {
  requestId?: string(name='RequestId'),
  timestamp?: int32(name='Timestamp'),
  totalNum?: int32(name='TotalNum'),
  totalPage?: int32(name='TotalPage'),
  userList?: {
    user?: [ string ](name='User')
  }(name='UserList'),
}

model DescribeChannelParticipantsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeChannelParticipantsResponseBody(name='body'),
}

async function describeChannelParticipants(request: DescribeChannelParticipantsRequest): DescribeChannelParticipantsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeChannelParticipants', 'POST', '/', 'json', false, 'json', request);
}

model DescribeChannelUsersRequest {
  appId: string(name='AppId', position='Query'),
  channelId: string(name='ChannelId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
}

model DescribeChannelUsersResponseBody = {
  channelProfile?: int32(name='ChannelProfile'),
  commTotalNum?: int32(name='CommTotalNum'),
  interactiveUserList?: [ string ](name='InteractiveUserList'),
  interactiveUserNum?: int32(name='InteractiveUserNum'),
  isChannelExist?: boolean(name='IsChannelExist'),
  liveUserList?: [ string ](name='LiveUserList'),
  liveUserNum?: int32(name='LiveUserNum'),
  requestId?: string(name='RequestId'),
  timestamp?: int32(name='Timestamp'),
  userList?: [ string ](name='UserList'),
}

model DescribeChannelUsersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeChannelUsersResponseBody(name='body'),
}

async function describeChannelUsers(request: DescribeChannelUsersRequest): DescribeChannelUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeChannelUsers', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMPULayoutInfoListRequest {
  appId: string(name='AppId', position='Query'),
  layoutId?: long(name='LayoutId', minimum=0, position='Query'),
  name?: string(name='Name', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: long(name='PageNum', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, position='Query'),
}

model DescribeMPULayoutInfoListResponseBody = {
  layouts?: {
    layout?: [ 
    {
      audioMixCount?: int32(name='AudioMixCount'),
      layoutId?: long(name='LayoutId'),
      name?: string(name='Name'),
      panes?: {
        panes?: [ 
        {
          height?: float(name='Height'),
          majorPane?: int32(name='MajorPane'),
          paneId?: int32(name='PaneId'),
          width?: float(name='Width'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Panes')
      }(name='Panes'),
    }
  ](name='Layout')
  }(name='Layouts'),
  requestId?: string(name='RequestId'),
  totalNum?: long(name='TotalNum'),
  totalPage?: long(name='TotalPage'),
}

model DescribeMPULayoutInfoListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMPULayoutInfoListResponseBody(name='body'),
}

async function describeMPULayoutInfoList(request: DescribeMPULayoutInfoListRequest): DescribeMPULayoutInfoListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMPULayoutInfoList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRecordFilesRequest {
  appId: string(name='AppId', position='Query'),
  channelId?: string(name='ChannelId', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  taskIds?: [ string ](name='TaskIds', position='Query'),
}

model DescribeRecordFilesResponseBody = {
  recordFiles?: [ 
    {
      appId?: string(name='AppId'),
      channelId?: string(name='ChannelId'),
      createTime?: string(name='CreateTime'),
      duration?: float(name='Duration'),
      startTime?: string(name='StartTime'),
      stopTime?: string(name='StopTime'),
      taskId?: string(name='TaskId'),
      url?: string(name='Url'),
    }
  ](name='RecordFiles'),
  requestId?: string(name='RequestId'),
  totalNum?: long(name='TotalNum'),
  totalPage?: long(name='TotalPage'),
}

model DescribeRecordFilesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRecordFilesResponseBody(name='body'),
}

async function describeRecordFiles(request: DescribeRecordFilesRequest): DescribeRecordFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRecordFiles', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRecordTemplatesRequest {
  appId: string(name='AppId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  templateIds?: [ string ](name='TemplateIds', position='Query'),
}

model DescribeRecordTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  templates?: [ 
    {
      backgroundColor?: int32(name='BackgroundColor'),
      backgrounds?: [ 
        {
          display?: int32(name='Display'),
          height?: float(name='Height'),
          url?: string(name='Url'),
          width?: float(name='Width'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Backgrounds'),
      clockWidgets?: [ 
        {
          fontColor?: int32(name='FontColor'),
          fontSize?: int32(name='FontSize'),
          fontType?: int32(name='FontType'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='ClockWidgets'),
      createTime?: string(name='CreateTime'),
      delayStopTime?: int32(name='DelayStopTime'),
      enableM3u8DateTime?: boolean(name='EnableM3u8DateTime'),
      fileSplitInterval?: int32(name='FileSplitInterval'),
      formats?: [ string ](name='Formats'),
      httpCallbackUrl?: string(name='HttpCallbackUrl'),
      layoutIds?: [ long ](name='LayoutIds'),
      mediaEncode?: int32(name='MediaEncode'),
      mnsQueue?: string(name='MnsQueue'),
      name?: string(name='Name'),
      ossBucket?: string(name='OssBucket'),
      ossFilePrefix?: string(name='OssFilePrefix'),
      taskProfile?: string(name='TaskProfile'),
      templateId?: string(name='TemplateId'),
      watermarks?: [ 
        {
          alpha?: float(name='Alpha'),
          display?: int32(name='Display'),
          height?: float(name='Height'),
          url?: string(name='Url'),
          width?: float(name='Width'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Watermarks'),
    }
  ](name='Templates'),
  totalNum?: long(name='TotalNum'),
  totalPage?: long(name='TotalPage'),
}

model DescribeRecordTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRecordTemplatesResponseBody(name='body'),
}

async function describeRecordTemplates(request: DescribeRecordTemplatesRequest): DescribeRecordTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRecordTemplates', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUserInfoInChannelRequest {
  appId: string(name='AppId', position='Query'),
  channelId: string(name='ChannelId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  userId: string(name='UserId', position='Query'),
}

model DescribeUserInfoInChannelResponseBody = {
  isChannelExist?: boolean(name='IsChannelExist'),
  isInChannel?: boolean(name='IsInChannel'),
  property?: [ 
    {
      join?: int32(name='Join'),
      role?: int32(name='Role'),
      session?: string(name='Session'),
    }
  ](name='Property'),
  requestId?: string(name='RequestId'),
  timestamp?: int32(name='Timestamp'),
}

model DescribeUserInfoInChannelResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUserInfoInChannelResponseBody(name='body'),
}

async function describeUserInfoInChannel(request: DescribeUserInfoInChannelRequest): DescribeUserInfoInChannelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUserInfoInChannel', 'POST', '/', 'json', false, 'json', request);
}

model DisableAutoLiveStreamRuleRequest {
  appId: string(name='AppId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model DisableAutoLiveStreamRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableAutoLiveStreamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableAutoLiveStreamRuleResponseBody(name='body'),
}

async function disableAutoLiveStreamRule(request: DisableAutoLiveStreamRuleRequest): DisableAutoLiveStreamRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableAutoLiveStreamRule', 'POST', '/', 'json', false, 'json', request);
}

model EnableAutoLiveStreamRuleRequest {
  appId: string(name='AppId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  ruleId: long(name='RuleId', position='Query'),
}

model EnableAutoLiveStreamRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableAutoLiveStreamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableAutoLiveStreamRuleResponseBody(name='body'),
}

async function enableAutoLiveStreamRule(request: EnableAutoLiveStreamRuleRequest): EnableAutoLiveStreamRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableAutoLiveStreamRule', 'POST', '/', 'json', false, 'json', request);
}

model GetMPUTaskStatusRequest {
  appId: string(name='AppId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  taskId: string(name='TaskId', position='Query'),
}

model GetMPUTaskStatusResponseBody = {
  requestId?: string(name='RequestId'),
  status?: int32(name='Status'),
}

model GetMPUTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetMPUTaskStatusResponseBody(name='body'),
}

async function getMPUTaskStatus(request: GetMPUTaskStatusRequest): GetMPUTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMPUTaskStatus', 'POST', '/', 'json', false, 'json', request);
}

model ModifyAppRequest {
  appId: string(name='AppId', position='Query'),
  appName: string(name='AppName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
}

model ModifyAppResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAppResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAppResponseBody(name='body'),
}

async function modifyApp(request: ModifyAppRequest): ModifyAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyApp', 'POST', '/', 'json', false, 'json', request);
}

model ModifyMPULayoutRequest {
  appId: string(name='AppId', position='Query'),
  audioMixCount?: int32(name='AudioMixCount', position='Query'),
  layoutId: long(name='LayoutId', position='Query'),
  name?: string(name='Name', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  panes?: [ 
    {
      height?: float(name='Height'),
      majorPane?: int32(name='MajorPane'),
      paneId?: int32(name='PaneId'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Panes', position='Query'),
}

model ModifyMPULayoutResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyMPULayoutResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyMPULayoutResponseBody(name='body'),
}

async function modifyMPULayout(request: ModifyMPULayoutRequest): ModifyMPULayoutResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyMPULayout', 'POST', '/', 'json', false, 'json', request);
}

model RemoveTerminalsRequest {
  appId: string(name='AppId', position='Query'),
  channelId: string(name='ChannelId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  terminalIds: [ string ](name='TerminalIds', position='Query'),
}

model RemoveTerminalsResponseBody = {
  requestId?: string(name='RequestId'),
  terminals?: {
    terminal?: [ 
    {
      code?: int32(name='Code'),
      id?: string(name='Id'),
      message?: string(name='Message'),
    }
  ](name='Terminal')
  }(name='Terminals'),
}

model RemoveTerminalsResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveTerminalsResponseBody(name='body'),
}

async function removeTerminals(request: RemoveTerminalsRequest): RemoveTerminalsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveTerminals', 'POST', '/', 'json', false, 'json', request);
}

model StartMPUTaskRequest {
  appId: string(name='AppId', position='Query'),
  backgroundColor?: int32(name='BackgroundColor', position='Query'),
  backgrounds?: [ 
    {
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Backgrounds', position='Query'),
  channelId: string(name='ChannelId', position='Query'),
  clockWidgets?: [ 
    {
      fontColor?: int32(name='FontColor'),
      fontSize?: int32(name='FontSize'),
      fontType?: int32(name='FontType'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='ClockWidgets', position='Query'),
  cropMode?: int32(name='CropMode', position='Query'),
  enhancedParam?: {
    enablePortraitSegmentation?: boolean(name='EnablePortraitSegmentation'),
  }(name='EnhancedParam', position='Body'),
  layoutIds?: [ long ](name='LayoutIds', position='Query'),
  mediaEncode?: int32(name='MediaEncode', position='Query'),
  mixMode?: int32(name='MixMode', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payloadType?: int32(name='PayloadType', position='Query'),
  reportVad?: int32(name='ReportVad', position='Query'),
  rtpExtInfo?: int32(name='RtpExtInfo', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
  streamType?: int32(name='StreamType', position='Query'),
  streamURL?: string(name='StreamURL', position='Query'),
  subSpecAudioUsers?: [ string ](name='SubSpecAudioUsers', position='Query'),
  subSpecCameraUsers?: [ string ](name='SubSpecCameraUsers', position='Query'),
  subSpecShareScreenUsers?: [ string ](name='SubSpecShareScreenUsers', position='Query'),
  subSpecUsers?: [ string ](name='SubSpecUsers', position='Query'),
  taskId: string(name='TaskId', position='Query'),
  taskType?: int32(name='TaskType', minimum=0, maximum=1, position='Query'),
  timeStampRef?: long(name='TimeStampRef', position='Query'),
  unsubSpecAudioUsers?: [ string ](name='UnsubSpecAudioUsers', position='Query'),
  unsubSpecCameraUsers?: [ string ](name='UnsubSpecCameraUsers', position='Query'),
  unsubSpecShareScreenUsers?: [ string ](name='UnsubSpecShareScreenUsers', position='Query'),
  userPanes?: [ 
    {
      images?: [ 
        {
          display?: int32(name='Display'),
          height?: float(name='Height'),
          url?: string(name='Url'),
          width?: float(name='Width'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Images'),
      paneId?: int32(name='PaneId'),
      segmentType?: int32(name='SegmentType'),
      sourceType?: string(name='SourceType'),
      texts?: [ 
        {
          fontColor?: int32(name='FontColor'),
          fontSize?: int32(name='FontSize'),
          fontType?: int32(name='FontType'),
          text?: string(name='Text'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Texts'),
      userId?: string(name='UserId'),
    }
  ](name='UserPanes', position='Query'),
  vadInterval?: long(name='VadInterval', position='Query'),
  watermarks?: [ 
    {
      alpha?: float(name='Alpha'),
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Watermarks', position='Query'),
}

model StartMPUTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartMPUTaskResponse = {
  headers: map[string]string(name='headers'),
  body: StartMPUTaskResponseBody(name='body'),
}

async function startMPUTask(request: StartMPUTaskRequest): StartMPUTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartMPUTask', 'POST', '/', 'json', true, 'form', request);
}

model StartRecordTaskRequest {
  appId: string(name='AppId', position='Query'),
  channelId: string(name='ChannelId', position='Query'),
  cropMode?: long(name='CropMode', position='Query'),
  layoutIds?: [ long ](name='LayoutIds', position='Query'),
  mediaEncode?: int32(name='MediaEncode', position='Query'),
  mixMode?: int32(name='MixMode', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
  streamType?: int32(name='StreamType', position='Query'),
  subSpecAudioUsers?: [ string ](name='SubSpecAudioUsers', position='Query'),
  subSpecCameraUsers?: [ string ](name='SubSpecCameraUsers', position='Query'),
  subSpecShareScreenUsers?: [ string ](name='SubSpecShareScreenUsers', position='Query'),
  subSpecUsers?: [ string ](name='SubSpecUsers', position='Query'),
  taskId: string(name='TaskId', position='Query'),
  taskProfile?: string(name='TaskProfile', position='Query'),
  templateId: string(name='TemplateId', position='Query'),
  unsubSpecAudioUsers?: [ string ](name='UnsubSpecAudioUsers', position='Query'),
  unsubSpecCameraUsers?: [ string ](name='UnsubSpecCameraUsers', position='Query'),
  unsubSpecShareScreenUsers?: [ string ](name='UnsubSpecShareScreenUsers', position='Query'),
  userPanes?: [ 
    {
      images?: [ 
        {
          display?: int32(name='Display'),
          height?: float(name='Height'),
          url?: string(name='Url'),
          width?: float(name='Width'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Images'),
      paneId?: int32(name='PaneId'),
      sourceType?: string(name='SourceType'),
      texts?: [ 
        {
          fontColor?: int32(name='FontColor'),
          fontSize?: int32(name='FontSize'),
          fontType?: int32(name='FontType'),
          text?: string(name='Text'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Texts'),
      userId?: string(name='UserId'),
    }
  ](name='UserPanes', position='Query'),
}

model StartRecordTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartRecordTaskResponse = {
  headers: map[string]string(name='headers'),
  body: StartRecordTaskResponseBody(name='body'),
}

async function startRecordTask(request: StartRecordTaskRequest): StartRecordTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartRecordTask', 'POST', '/', 'json', false, 'json', request);
}

model StopMPUTaskRequest {
  appId: string(name='AppId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  taskId: string(name='TaskId', position='Query'),
}

model StopMPUTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopMPUTaskResponse = {
  headers: map[string]string(name='headers'),
  body: StopMPUTaskResponseBody(name='body'),
}

async function stopMPUTask(request: StopMPUTaskRequest): StopMPUTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopMPUTask', 'POST', '/', 'json', false, 'json', request);
}

model StopRecordTaskRequest {
  appId: string(name='AppId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  taskId: string(name='TaskId', position='Query'),
}

model StopRecordTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopRecordTaskResponse = {
  headers: map[string]string(name='headers'),
  body: StopRecordTaskResponseBody(name='body'),
}

async function stopRecordTask(request: StopRecordTaskRequest): StopRecordTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopRecordTask', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAutoLiveStreamRuleRequest {
  appId: string(name='AppId', position='Query'),
  callBack?: string(name='CallBack', position='Query'),
  channelIdPrefixes?: [ string ](name='ChannelIdPrefixes', position='Query'),
  channelIds?: [ string ](name='ChannelIds', position='Query'),
  mediaEncode?: int32(name='MediaEncode', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  playDomain: string(name='PlayDomain', position='Query'),
  ruleId: int32(name='RuleId', position='Query'),
  ruleName?: string(name='RuleName', position='Query'),
}

model UpdateAutoLiveStreamRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAutoLiveStreamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAutoLiveStreamRuleResponseBody(name='body'),
}

async function updateAutoLiveStreamRule(request: UpdateAutoLiveStreamRuleRequest): UpdateAutoLiveStreamRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAutoLiveStreamRule', 'POST', '/', 'json', false, 'json', request);
}

model UpdateMPUTaskRequest {
  appId: string(name='AppId', position='Query'),
  backgroundColor?: int32(name='BackgroundColor', position='Query'),
  backgrounds?: [ 
    {
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Backgrounds', position='Query'),
  clockWidgets?: [ 
    {
      fontColor?: int32(name='FontColor'),
      fontSize?: int32(name='FontSize'),
      fontType?: int32(name='FontType'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='ClockWidgets', position='Query'),
  cropMode?: int32(name='CropMode', position='Query'),
  layoutIds?: [ long ](name='LayoutIds', position='Query'),
  mediaEncode?: int32(name='MediaEncode', position='Query'),
  mixMode?: int32(name='MixMode', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
  streamType?: int32(name='StreamType', position='Query'),
  subSpecAudioUsers?: [ string ](name='SubSpecAudioUsers', position='Query'),
  subSpecCameraUsers?: [ string ](name='SubSpecCameraUsers', position='Query'),
  subSpecShareScreenUsers?: [ string ](name='SubSpecShareScreenUsers', position='Query'),
  subSpecUsers?: [ string ](name='SubSpecUsers', position='Query'),
  taskId: string(name='TaskId', position='Query'),
  unsubSpecAudioUsers?: [ string ](name='UnsubSpecAudioUsers', position='Query'),
  unsubSpecCameraUsers?: [ string ](name='UnsubSpecCameraUsers', position='Query'),
  unsubSpecShareScreenUsers?: [ string ](name='UnsubSpecShareScreenUsers', position='Query'),
  userPanes?: [ 
    {
      images?: [ 
        {
          display?: int32(name='Display'),
          height?: float(name='Height'),
          url?: string(name='Url'),
          width?: float(name='Width'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Images'),
      paneId?: int32(name='PaneId'),
      segmentType?: int32(name='SegmentType'),
      sourceType?: string(name='SourceType'),
      texts?: [ 
        {
          fontColor?: int32(name='FontColor'),
          fontSize?: int32(name='FontSize'),
          fontType?: int32(name='FontType'),
          text?: string(name='Text'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Texts'),
      userId?: string(name='UserId'),
    }
  ](name='UserPanes', position='Query'),
  watermarks?: [ 
    {
      alpha?: float(name='Alpha'),
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Watermarks', position='Query'),
}

model UpdateMPUTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMPUTaskResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMPUTaskResponseBody(name='body'),
}

async function updateMPUTask(request: UpdateMPUTaskRequest): UpdateMPUTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMPUTask', 'POST', '/', 'json', false, 'json', request);
}

model UpdateRecordTaskRequest {
  appId: string(name='AppId', position='Query'),
  channelId: string(name='ChannelId', position='Query'),
  layoutIds?: [ long ](name='LayoutIds', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  subSpecAudioUsers?: [ string ](name='SubSpecAudioUsers', position='Query'),
  subSpecCameraUsers?: [ string ](name='SubSpecCameraUsers', position='Query'),
  subSpecShareScreenUsers?: [ string ](name='SubSpecShareScreenUsers', position='Query'),
  subSpecUsers?: [ string ](name='SubSpecUsers', position='Query'),
  taskId: string(name='TaskId', position='Query'),
  templateId: string(name='TemplateId', position='Query'),
  unsubSpecAudioUsers?: [ string ](name='UnsubSpecAudioUsers', position='Query'),
  unsubSpecCameraUsers?: [ string ](name='UnsubSpecCameraUsers', position='Query'),
  unsubSpecShareScreenUsers?: [ string ](name='UnsubSpecShareScreenUsers', position='Query'),
  userPanes?: [ 
    {
      images?: [ 
        {
          display?: int32(name='Display'),
          height?: float(name='Height'),
          url?: string(name='Url'),
          width?: float(name='Width'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Images'),
      paneId?: int32(name='PaneId'),
      sourceType?: string(name='SourceType'),
      texts?: [ 
        {
          fontColor?: int32(name='FontColor'),
          fontSize?: int32(name='FontSize'),
          fontType?: int32(name='FontType'),
          text?: string(name='Text'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Texts'),
      userId?: string(name='UserId'),
    }
  ](name='UserPanes', position='Query'),
}

model UpdateRecordTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateRecordTaskResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRecordTaskResponseBody(name='body'),
}

async function updateRecordTask(request: UpdateRecordTaskRequest): UpdateRecordTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateRecordTask', 'POST', '/', 'json', false, 'json', request);
}

model UpdateRecordTemplateRequest {
  appId: string(name='AppId', position='Query'),
  backgroundColor?: int32(name='BackgroundColor', position='Query'),
  backgrounds?: [ 
    {
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Backgrounds', position='Query'),
  clockWidgets?: [ 
    {
      fontColor?: int32(name='FontColor'),
      fontSize?: int32(name='FontSize'),
      fontType?: int32(name='FontType'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='ClockWidgets', position='Query'),
  delayStopTime?: int32(name='DelayStopTime', minimum=5, maximum=86400, position='Query'),
  enableM3u8DateTime?: boolean(name='EnableM3u8DateTime', position='Query'),
  fileSplitInterval: int32(name='FileSplitInterval', position='Query'),
  formats: [ string ](name='Formats', position='Query'),
  httpCallbackUrl?: string(name='HttpCallbackUrl', position='Query'),
  layoutIds: [ long ](name='LayoutIds', position='Query'),
  mediaEncode: int32(name='MediaEncode', position='Query'),
  mnsQueue?: string(name='MnsQueue', position='Query'),
  name: string(name='Name', position='Query'),
  ossBucket: string(name='OssBucket', position='Query'),
  ossFilePrefix: string(name='OssFilePrefix', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  taskProfile: string(name='TaskProfile', position='Query'),
  templateId: string(name='TemplateId', position='Query'),
  watermarks?: [ 
    {
      alpha?: float(name='Alpha'),
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Watermarks', position='Query'),
}

model UpdateRecordTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model UpdateRecordTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRecordTemplateResponseBody(name='body'),
}

async function updateRecordTemplate(request: UpdateRecordTemplateRequest): UpdateRecordTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateRecordTemplate', 'POST', '/', 'json', false, 'json', request);
}

