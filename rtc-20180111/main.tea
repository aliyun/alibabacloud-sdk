/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  

  checkConfig(config);
  @endpoint = getEndpoint('rtc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddRecordTemplateRequest {
  appId?: string(name='AppId'),
  backgroundColor?: int32(name='BackgroundColor'),
  backgrounds?: [ 
    {
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Backgrounds'),
  clockWidgets?: [ 
    {
      fontColor?: int32(name='FontColor'),
      fontSize?: int32(name='FontSize'),
      fontType?: int32(name='FontType'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='ClockWidgets'),
  delayStopTime?: int32(name='DelayStopTime'),
  enableM3u8DateTime?: boolean(name='EnableM3u8DateTime'),
  fileSplitInterval?: int32(name='FileSplitInterval'),
  formats?: [ string ](name='Formats'),
  httpCallbackUrl?: string(name='HttpCallbackUrl'),
  layoutIds?: [ long ](name='LayoutIds'),
  mediaEncode?: int32(name='MediaEncode'),
  mnsQueue?: string(name='MnsQueue'),
  name?: string(name='Name'),
  ossBucket?: string(name='OssBucket'),
  ossFilePrefix?: string(name='OssFilePrefix'),
  ownerId?: long(name='OwnerId'),
  taskProfile?: string(name='TaskProfile'),
  watermarks?: [ 
    {
      alpha?: float(name='Alpha'),
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Watermarks'),
}

model AddRecordTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model AddRecordTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: AddRecordTemplateResponseBody(name='body'),
}

async function addRecordTemplateWithOptions(request: AddRecordTemplateRequest, runtime: Util.RuntimeOptions): AddRecordTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["BackgroundColor"] = request.backgroundColor;
  query["Backgrounds"] = request.backgrounds;
  query["ClockWidgets"] = request.clockWidgets;
  query["DelayStopTime"] = request.delayStopTime;
  query["EnableM3u8DateTime"] = request.enableM3u8DateTime;
  query["FileSplitInterval"] = request.fileSplitInterval;
  query["Formats"] = request.formats;
  query["HttpCallbackUrl"] = request.httpCallbackUrl;
  query["LayoutIds"] = request.layoutIds;
  query["MediaEncode"] = request.mediaEncode;
  query["MnsQueue"] = request.mnsQueue;
  query["Name"] = request.name;
  query["OssBucket"] = request.ossBucket;
  query["OssFilePrefix"] = request.ossFilePrefix;
  query["OwnerId"] = request.ownerId;
  query["TaskProfile"] = request.taskProfile;
  query["Watermarks"] = request.watermarks;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddRecordTemplate',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addRecordTemplate(request: AddRecordTemplateRequest): AddRecordTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return addRecordTemplateWithOptions(request, runtime);
}

model CreateAutoLiveStreamRuleRequest {
  appId?: string(name='AppId'),
  callBack?: string(name='CallBack'),
  channelIdPrefixes?: [ string ](name='ChannelIdPrefixes'),
  channelIds?: [ string ](name='ChannelIds'),
  mediaEncode?: int32(name='MediaEncode'),
  ownerId?: long(name='OwnerId'),
  playDomain?: string(name='PlayDomain'),
  ruleName?: string(name='RuleName'),
}

model CreateAutoLiveStreamRuleResponseBody = {
  requestId?: string(name='RequestId'),
  ruleId?: long(name='RuleId'),
}

model CreateAutoLiveStreamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAutoLiveStreamRuleResponseBody(name='body'),
}

async function createAutoLiveStreamRuleWithOptions(request: CreateAutoLiveStreamRuleRequest, runtime: Util.RuntimeOptions): CreateAutoLiveStreamRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["CallBack"] = request.callBack;
  query["ChannelIdPrefixes"] = request.channelIdPrefixes;
  query["ChannelIds"] = request.channelIds;
  query["MediaEncode"] = request.mediaEncode;
  query["OwnerId"] = request.ownerId;
  query["PlayDomain"] = request.playDomain;
  query["RuleName"] = request.ruleName;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateAutoLiveStreamRule',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAutoLiveStreamRule(request: CreateAutoLiveStreamRuleRequest): CreateAutoLiveStreamRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAutoLiveStreamRuleWithOptions(request, runtime);
}

model CreateEventSubscribeRequest {
  appId?: string(name='AppId'),
  callbackUrl?: string(name='CallbackUrl'),
  channelId?: string(name='ChannelId'),
  clientToken?: string(name='ClientToken'),
  events?: [ string ](name='Events'),
  ownerId?: long(name='OwnerId'),
  users?: [ string ](name='Users'),
}

model CreateEventSubscribeResponseBody = {
  requestId?: string(name='RequestId'),
  subscribeId?: string(name='SubscribeId'),
}

model CreateEventSubscribeResponse = {
  headers: map[string]string(name='headers'),
  body: CreateEventSubscribeResponseBody(name='body'),
}

async function createEventSubscribeWithOptions(request: CreateEventSubscribeRequest, runtime: Util.RuntimeOptions): CreateEventSubscribeResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["CallbackUrl"] = request.callbackUrl;
  query["ChannelId"] = request.channelId;
  query["ClientToken"] = request.clientToken;
  query["Events"] = request.events;
  query["OwnerId"] = request.ownerId;
  query["Users"] = request.users;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateEventSubscribe',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEventSubscribe(request: CreateEventSubscribeRequest): CreateEventSubscribeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEventSubscribeWithOptions(request, runtime);
}

model CreateMPULayoutRequest {
  appId?: string(name='AppId'),
  audioMixCount?: int32(name='AudioMixCount'),
  name?: string(name='Name'),
  ownerId?: long(name='OwnerId'),
  panes?: [ 
    {
      height?: float(name='Height'),
      majorPane?: int32(name='MajorPane'),
      paneId?: int32(name='PaneId'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Panes'),
}

model CreateMPULayoutResponseBody = {
  layoutId?: long(name='LayoutId'),
  requestId?: string(name='RequestId'),
}

model CreateMPULayoutResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMPULayoutResponseBody(name='body'),
}

async function createMPULayoutWithOptions(request: CreateMPULayoutRequest, runtime: Util.RuntimeOptions): CreateMPULayoutResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["AudioMixCount"] = request.audioMixCount;
  query["Name"] = request.name;
  query["OwnerId"] = request.ownerId;
  query["Panes"] = request.panes;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateMPULayout',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMPULayout(request: CreateMPULayoutRequest): CreateMPULayoutResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMPULayoutWithOptions(request, runtime);
}

model CreateRecordIndexFileRequest {
  appId?: string(name='AppId'),
  channelId?: string(name='ChannelId'),
  endTime?: string(name='EndTime'),
  ossBucket?: string(name='OssBucket'),
  ossEndpoint?: string(name='OssEndpoint'),
  ossObject?: string(name='OssObject'),
  ownerId?: long(name='OwnerId'),
  startTime?: string(name='StartTime'),
  taskId?: string(name='TaskId'),
}

model CreateRecordIndexFileResponseBody = {
  duration?: float(name='Duration'),
  height?: int32(name='Height'),
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
  width?: int32(name='Width'),
}

model CreateRecordIndexFileResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRecordIndexFileResponseBody(name='body'),
}

async function createRecordIndexFileWithOptions(request: CreateRecordIndexFileRequest, runtime: Util.RuntimeOptions): CreateRecordIndexFileResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["ChannelId"] = request.channelId;
  query["EndTime"] = request.endTime;
  query["OssBucket"] = request.ossBucket;
  query["OssEndpoint"] = request.ossEndpoint;
  query["OssObject"] = request.ossObject;
  query["OwnerId"] = request.ownerId;
  query["StartTime"] = request.startTime;
  query["TaskId"] = request.taskId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateRecordIndexFile',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRecordIndexFile(request: CreateRecordIndexFileRequest): CreateRecordIndexFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRecordIndexFileWithOptions(request, runtime);
}

model DeleteAutoLiveStreamRuleRequest {
  appId?: string(name='AppId'),
  ownerId?: long(name='OwnerId'),
  ruleId?: long(name='RuleId'),
}

model DeleteAutoLiveStreamRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAutoLiveStreamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAutoLiveStreamRuleResponseBody(name='body'),
}

async function deleteAutoLiveStreamRuleWithOptions(request: DeleteAutoLiveStreamRuleRequest, runtime: Util.RuntimeOptions): DeleteAutoLiveStreamRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["OwnerId"] = request.ownerId;
  query["RuleId"] = request.ruleId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAutoLiveStreamRule',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAutoLiveStreamRule(request: DeleteAutoLiveStreamRuleRequest): DeleteAutoLiveStreamRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAutoLiveStreamRuleWithOptions(request, runtime);
}

model DeleteEventSubscribeRequest {
  appId?: string(name='AppId'),
  ownerId?: long(name='OwnerId'),
  subscribeId?: string(name='SubscribeId'),
}

model DeleteEventSubscribeResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteEventSubscribeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEventSubscribeResponseBody(name='body'),
}

async function deleteEventSubscribeWithOptions(request: DeleteEventSubscribeRequest, runtime: Util.RuntimeOptions): DeleteEventSubscribeResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["OwnerId"] = request.ownerId;
  query["SubscribeId"] = request.subscribeId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventSubscribe',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEventSubscribe(request: DeleteEventSubscribeRequest): DeleteEventSubscribeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventSubscribeWithOptions(request, runtime);
}

model DeleteMPULayoutRequest {
  appId?: string(name='AppId'),
  layoutId?: long(name='LayoutId'),
  ownerId?: long(name='OwnerId'),
}

model DeleteMPULayoutResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMPULayoutResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMPULayoutResponseBody(name='body'),
}

async function deleteMPULayoutWithOptions(request: DeleteMPULayoutRequest, runtime: Util.RuntimeOptions): DeleteMPULayoutResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["LayoutId"] = request.layoutId;
  query["OwnerId"] = request.ownerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMPULayout',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMPULayout(request: DeleteMPULayoutRequest): DeleteMPULayoutResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMPULayoutWithOptions(request, runtime);
}

model DeleteRecordTemplateRequest {
  appId?: string(name='AppId'),
  ownerId?: long(name='OwnerId'),
  templateId?: string(name='TemplateId'),
}

model DeleteRecordTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRecordTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRecordTemplateResponseBody(name='body'),
}

async function deleteRecordTemplateWithOptions(request: DeleteRecordTemplateRequest, runtime: Util.RuntimeOptions): DeleteRecordTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["OwnerId"] = request.ownerId;
  query["TemplateId"] = request.templateId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRecordTemplate',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRecordTemplate(request: DeleteRecordTemplateRequest): DeleteRecordTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRecordTemplateWithOptions(request, runtime);
}

model DescribeAutoLiveStreamRuleRequest {
  appId?: string(name='AppId'),
  ownerId?: long(name='OwnerId'),
}

model DescribeAutoLiveStreamRuleResponseBody = {
  requestId?: string(name='RequestId'),
  rules?: [ 
    {
      callBack?: string(name='CallBack'),
      channelIdPrefixes?: [ string ](name='ChannelIdPrefixes'),
      channelIds?: [ string ](name='ChannelIds'),
      createTime?: string(name='CreateTime'),
      mediaEncode?: int32(name='MediaEncode'),
      playDomain?: string(name='PlayDomain'),
      ruleId?: long(name='RuleId'),
      ruleName?: string(name='RuleName'),
      status?: string(name='Status'),
    }
  ](name='Rules'),
}

model DescribeAutoLiveStreamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoLiveStreamRuleResponseBody(name='body'),
}

async function describeAutoLiveStreamRuleWithOptions(request: DescribeAutoLiveStreamRuleRequest, runtime: Util.RuntimeOptions): DescribeAutoLiveStreamRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["OwnerId"] = request.ownerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAutoLiveStreamRule',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAutoLiveStreamRule(request: DescribeAutoLiveStreamRuleRequest): DescribeAutoLiveStreamRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAutoLiveStreamRuleWithOptions(request, runtime);
}

model DescribeChannelParticipantsRequest {
  appId?: string(name='AppId'),
  channelId?: string(name='ChannelId'),
  order?: string(name='Order'),
  ownerId?: long(name='OwnerId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model DescribeChannelParticipantsResponseBody = {
  requestId?: string(name='RequestId'),
  timestamp?: int32(name='Timestamp'),
  totalNum?: int32(name='TotalNum'),
  totalPage?: int32(name='TotalPage'),
  userList?: {
    user?: [ string ](name='User')
  }(name='UserList'),
}

model DescribeChannelParticipantsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeChannelParticipantsResponseBody(name='body'),
}

async function describeChannelParticipantsWithOptions(request: DescribeChannelParticipantsRequest, runtime: Util.RuntimeOptions): DescribeChannelParticipantsResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["ChannelId"] = request.channelId;
  query["Order"] = request.order;
  query["OwnerId"] = request.ownerId;
  query["PageNum"] = request.pageNum;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeChannelParticipants',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeChannelParticipants(request: DescribeChannelParticipantsRequest): DescribeChannelParticipantsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeChannelParticipantsWithOptions(request, runtime);
}

model DescribeChannelUsersRequest {
  appId?: string(name='AppId'),
  channelId?: string(name='ChannelId'),
  ownerId?: long(name='OwnerId'),
}

model DescribeChannelUsersResponseBody = {
  channelProfile?: int32(name='ChannelProfile'),
  commTotalNum?: int32(name='CommTotalNum'),
  interactiveUserList?: [ string ](name='InteractiveUserList'),
  interactiveUserNum?: int32(name='InteractiveUserNum'),
  isChannelExist?: boolean(name='IsChannelExist'),
  liveUserList?: [ string ](name='LiveUserList'),
  liveUserNum?: int32(name='LiveUserNum'),
  requestId?: string(name='RequestId'),
  timestamp?: int32(name='Timestamp'),
  userList?: [ string ](name='UserList'),
}

model DescribeChannelUsersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeChannelUsersResponseBody(name='body'),
}

async function describeChannelUsersWithOptions(request: DescribeChannelUsersRequest, runtime: Util.RuntimeOptions): DescribeChannelUsersResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["ChannelId"] = request.channelId;
  query["OwnerId"] = request.ownerId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeChannelUsers',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeChannelUsers(request: DescribeChannelUsersRequest): DescribeChannelUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeChannelUsersWithOptions(request, runtime);
}

model DescribeMPULayoutInfoListRequest {
  appId?: string(name='AppId'),
  layoutId?: long(name='LayoutId'),
  name?: string(name='Name'),
  ownerId?: long(name='OwnerId'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
}

model DescribeMPULayoutInfoListResponseBody = {
  layouts?: {
    layout?: [ 
    {
      audioMixCount?: int32(name='AudioMixCount'),
      layoutId?: long(name='LayoutId'),
      name?: string(name='Name'),
      panes?: {
        panes?: [ 
        {
          height?: float(name='Height'),
          majorPane?: int32(name='MajorPane'),
          paneId?: int32(name='PaneId'),
          width?: float(name='Width'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Panes')
      }(name='Panes'),
    }
  ](name='Layout')
  }(name='Layouts'),
  requestId?: string(name='RequestId'),
  totalNum?: long(name='TotalNum'),
  totalPage?: long(name='TotalPage'),
}

model DescribeMPULayoutInfoListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMPULayoutInfoListResponseBody(name='body'),
}

async function describeMPULayoutInfoListWithOptions(request: DescribeMPULayoutInfoListRequest, runtime: Util.RuntimeOptions): DescribeMPULayoutInfoListResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["LayoutId"] = request.layoutId;
  query["Name"] = request.name;
  query["OwnerId"] = request.ownerId;
  query["PageNum"] = request.pageNum;
  query["PageSize"] = request.pageSize;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMPULayoutInfoList',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMPULayoutInfoList(request: DescribeMPULayoutInfoListRequest): DescribeMPULayoutInfoListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMPULayoutInfoListWithOptions(request, runtime);
}

model DescribeRecordFilesRequest {
  appId?: string(name='AppId'),
  channelId?: string(name='ChannelId'),
  endTime?: string(name='EndTime'),
  ownerId?: long(name='OwnerId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  startTime?: string(name='StartTime'),
  taskIds?: [ string ](name='TaskIds'),
}

model DescribeRecordFilesResponseBody = {
  recordFiles?: [ 
    {
      appId?: string(name='AppId'),
      channelId?: string(name='ChannelId'),
      createTime?: string(name='CreateTime'),
      duration?: float(name='Duration'),
      startTime?: string(name='StartTime'),
      stopTime?: string(name='StopTime'),
      taskId?: string(name='TaskId'),
      url?: string(name='Url'),
    }
  ](name='RecordFiles'),
  requestId?: string(name='RequestId'),
  totalNum?: long(name='TotalNum'),
  totalPage?: long(name='TotalPage'),
}

model DescribeRecordFilesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRecordFilesResponseBody(name='body'),
}

async function describeRecordFilesWithOptions(request: DescribeRecordFilesRequest, runtime: Util.RuntimeOptions): DescribeRecordFilesResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["ChannelId"] = request.channelId;
  query["EndTime"] = request.endTime;
  query["OwnerId"] = request.ownerId;
  query["PageNum"] = request.pageNum;
  query["PageSize"] = request.pageSize;
  query["StartTime"] = request.startTime;
  query["TaskIds"] = request.taskIds;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecordFiles',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRecordFiles(request: DescribeRecordFilesRequest): DescribeRecordFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecordFilesWithOptions(request, runtime);
}

model DescribeRecordTasksRequest {
  appId?: string(name='AppId'),
  channelId?: string(name='ChannelId'),
  endTime?: string(name='EndTime'),
  ownerId?: long(name='OwnerId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
  taskIds?: [ string ](name='TaskIds'),
}

model DescribeRecordTasksResponseBody = {
  recordTasks?: [ 
    {
      appId?: string(name='AppId'),
      channelId?: string(name='ChannelId'),
      createTime?: string(name='CreateTime'),
      status?: int32(name='Status'),
      subSpecUsers?: [ string ](name='SubSpecUsers'),
      taskId?: string(name='TaskId'),
      templateId?: string(name='TemplateId'),
      userPanes?: [ 
        {
          paneId?: int32(name='PaneId'),
          source?: string(name='Source'),
          userId?: string(name='UserId'),
        }
      ](name='UserPanes'),
    }
  ](name='RecordTasks'),
  requestId?: string(name='RequestId'),
  totalNum?: long(name='TotalNum'),
  totalPage?: long(name='TotalPage'),
}

model DescribeRecordTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRecordTasksResponseBody(name='body'),
}

async function describeRecordTasksWithOptions(request: DescribeRecordTasksRequest, runtime: Util.RuntimeOptions): DescribeRecordTasksResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["ChannelId"] = request.channelId;
  query["EndTime"] = request.endTime;
  query["OwnerId"] = request.ownerId;
  query["PageNum"] = request.pageNum;
  query["PageSize"] = request.pageSize;
  query["StartTime"] = request.startTime;
  query["Status"] = request.status;
  query["TaskIds"] = request.taskIds;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecordTasks',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRecordTasks(request: DescribeRecordTasksRequest): DescribeRecordTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecordTasksWithOptions(request, runtime);
}

model DescribeRecordTemplatesRequest {
  appId?: string(name='AppId'),
  ownerId?: long(name='OwnerId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  templateIds?: [ string ](name='TemplateIds'),
}

model DescribeRecordTemplatesResponseBody = {
  requestId?: string(name='RequestId'),
  templates?: [ 
    {
      backgroundColor?: int32(name='BackgroundColor'),
      backgrounds?: [ 
        {
          display?: int32(name='Display'),
          height?: float(name='Height'),
          url?: string(name='Url'),
          width?: float(name='Width'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Backgrounds'),
      clockWidgets?: [ 
        {
          fontColor?: int32(name='FontColor'),
          fontSize?: int32(name='FontSize'),
          fontType?: int32(name='FontType'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='ClockWidgets'),
      createTime?: string(name='CreateTime'),
      delayStopTime?: int32(name='DelayStopTime'),
      enableM3u8DateTime?: boolean(name='EnableM3u8DateTime'),
      fileSplitInterval?: int32(name='FileSplitInterval'),
      formats?: [ string ](name='Formats'),
      httpCallbackUrl?: string(name='HttpCallbackUrl'),
      layoutIds?: [ int32 ](name='LayoutIds'),
      mediaEncode?: int32(name='MediaEncode'),
      mnsQueue?: string(name='MnsQueue'),
      name?: string(name='Name'),
      ossBucket?: string(name='OssBucket'),
      ossFilePrefix?: string(name='OssFilePrefix'),
      taskProfile?: string(name='TaskProfile'),
      templateId?: string(name='TemplateId'),
      watermarks?: [ 
        {
          alpha?: float(name='Alpha'),
          display?: int32(name='Display'),
          height?: float(name='Height'),
          url?: string(name='Url'),
          width?: float(name='Width'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Watermarks'),
    }
  ](name='Templates'),
  totalNum?: long(name='TotalNum'),
  totalPage?: long(name='TotalPage'),
}

model DescribeRecordTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRecordTemplatesResponseBody(name='body'),
}

async function describeRecordTemplatesWithOptions(request: DescribeRecordTemplatesRequest, runtime: Util.RuntimeOptions): DescribeRecordTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["OwnerId"] = request.ownerId;
  query["PageNum"] = request.pageNum;
  query["PageSize"] = request.pageSize;
  query["TemplateIds"] = request.templateIds;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecordTemplates',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRecordTemplates(request: DescribeRecordTemplatesRequest): DescribeRecordTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecordTemplatesWithOptions(request, runtime);
}

model DescribeUserInfoInChannelRequest {
  appId?: string(name='AppId'),
  channelId?: string(name='ChannelId'),
  ownerId?: long(name='OwnerId'),
  userId?: string(name='UserId'),
}

model DescribeUserInfoInChannelResponseBody = {
  isChannelExist?: boolean(name='IsChannelExist'),
  isInChannel?: boolean(name='IsInChannel'),
  property?: [ 
    {
      join?: int32(name='Join'),
      role?: int32(name='Role'),
      session?: string(name='Session'),
    }
  ](name='Property'),
  requestId?: string(name='RequestId'),
  timestamp?: int32(name='Timestamp'),
}

model DescribeUserInfoInChannelResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUserInfoInChannelResponseBody(name='body'),
}

async function describeUserInfoInChannelWithOptions(request: DescribeUserInfoInChannelRequest, runtime: Util.RuntimeOptions): DescribeUserInfoInChannelResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["ChannelId"] = request.channelId;
  query["OwnerId"] = request.ownerId;
  query["UserId"] = request.userId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserInfoInChannel',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUserInfoInChannel(request: DescribeUserInfoInChannelRequest): DescribeUserInfoInChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUserInfoInChannelWithOptions(request, runtime);
}

model DisableAutoLiveStreamRuleRequest {
  appId?: string(name='AppId'),
  ownerId?: long(name='OwnerId'),
  ruleId?: long(name='RuleId'),
}

model DisableAutoLiveStreamRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableAutoLiveStreamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableAutoLiveStreamRuleResponseBody(name='body'),
}

async function disableAutoLiveStreamRuleWithOptions(request: DisableAutoLiveStreamRuleRequest, runtime: Util.RuntimeOptions): DisableAutoLiveStreamRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["OwnerId"] = request.ownerId;
  query["RuleId"] = request.ruleId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DisableAutoLiveStreamRule',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableAutoLiveStreamRule(request: DisableAutoLiveStreamRuleRequest): DisableAutoLiveStreamRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableAutoLiveStreamRuleWithOptions(request, runtime);
}

model EnableAutoLiveStreamRuleRequest {
  appId?: string(name='AppId'),
  ownerId?: long(name='OwnerId'),
  ruleId?: long(name='RuleId'),
}

model EnableAutoLiveStreamRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableAutoLiveStreamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableAutoLiveStreamRuleResponseBody(name='body'),
}

async function enableAutoLiveStreamRuleWithOptions(request: EnableAutoLiveStreamRuleRequest, runtime: Util.RuntimeOptions): EnableAutoLiveStreamRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["OwnerId"] = request.ownerId;
  query["RuleId"] = request.ruleId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'EnableAutoLiveStreamRule',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableAutoLiveStreamRule(request: EnableAutoLiveStreamRuleRequest): EnableAutoLiveStreamRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableAutoLiveStreamRuleWithOptions(request, runtime);
}

model GetMPUTaskStatusRequest {
  appId?: string(name='AppId'),
  ownerId?: long(name='OwnerId'),
  taskId?: string(name='TaskId'),
}

model GetMPUTaskStatusResponseBody = {
  requestId?: string(name='RequestId'),
  status?: int32(name='Status'),
}

model GetMPUTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetMPUTaskStatusResponseBody(name='body'),
}

async function getMPUTaskStatusWithOptions(request: GetMPUTaskStatusRequest, runtime: Util.RuntimeOptions): GetMPUTaskStatusResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["OwnerId"] = request.ownerId;
  query["TaskId"] = request.taskId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetMPUTaskStatus',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMPUTaskStatus(request: GetMPUTaskStatusRequest): GetMPUTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMPUTaskStatusWithOptions(request, runtime);
}

model ModifyMPULayoutRequest {
  appId?: string(name='AppId'),
  audioMixCount?: int32(name='AudioMixCount'),
  layoutId?: long(name='LayoutId'),
  name?: string(name='Name'),
  ownerId?: long(name='OwnerId'),
  panes?: [ 
    {
      height?: float(name='Height'),
      majorPane?: int32(name='MajorPane'),
      paneId?: int32(name='PaneId'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Panes'),
}

model ModifyMPULayoutResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyMPULayoutResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyMPULayoutResponseBody(name='body'),
}

async function modifyMPULayoutWithOptions(request: ModifyMPULayoutRequest, runtime: Util.RuntimeOptions): ModifyMPULayoutResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["AudioMixCount"] = request.audioMixCount;
  query["LayoutId"] = request.layoutId;
  query["Name"] = request.name;
  query["OwnerId"] = request.ownerId;
  query["Panes"] = request.panes;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ModifyMPULayout',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyMPULayout(request: ModifyMPULayoutRequest): ModifyMPULayoutResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMPULayoutWithOptions(request, runtime);
}

model RemoveTerminalsRequest {
  appId?: string(name='AppId'),
  channelId?: string(name='ChannelId'),
  ownerId?: long(name='OwnerId'),
  terminalIds?: [ string ](name='TerminalIds'),
}

model RemoveTerminalsResponseBody = {
  requestId?: string(name='RequestId'),
  terminals?: {
    terminal?: [ 
    {
      code?: int32(name='Code'),
      id?: string(name='Id'),
      message?: string(name='Message'),
    }
  ](name='Terminal')
  }(name='Terminals'),
}

model RemoveTerminalsResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveTerminalsResponseBody(name='body'),
}

async function removeTerminalsWithOptions(request: RemoveTerminalsRequest, runtime: Util.RuntimeOptions): RemoveTerminalsResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["ChannelId"] = request.channelId;
  query["OwnerId"] = request.ownerId;
  query["TerminalIds"] = request.terminalIds;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RemoveTerminals',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeTerminals(request: RemoveTerminalsRequest): RemoveTerminalsResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeTerminalsWithOptions(request, runtime);
}

model StartMPUTaskRequest {
  appId?: string(name='AppId'),
  backgroundColor?: int32(name='BackgroundColor'),
  backgrounds?: [ 
    {
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Backgrounds'),
  channelId?: string(name='ChannelId'),
  clockWidgets?: [ 
    {
      fontColor?: int32(name='FontColor'),
      fontSize?: int32(name='FontSize'),
      fontType?: int32(name='FontType'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='ClockWidgets'),
  cropMode?: int32(name='CropMode'),
  enhancedParam?: {
    enablePortraitSegmentation?: boolean(name='EnablePortraitSegmentation'),
  }(name='EnhancedParam'),
  layoutIds?: [ long ](name='LayoutIds'),
  mediaEncode?: int32(name='MediaEncode'),
  mixMode?: int32(name='MixMode'),
  ownerId?: long(name='OwnerId'),
  payloadType?: int32(name='PayloadType'),
  reportVad?: int32(name='ReportVad'),
  rtpExtInfo?: int32(name='RtpExtInfo'),
  sourceType?: string(name='SourceType'),
  streamType?: int32(name='StreamType'),
  streamURL?: string(name='StreamURL'),
  subSpecAudioUsers?: [ string ](name='SubSpecAudioUsers'),
  subSpecCameraUsers?: [ string ](name='SubSpecCameraUsers'),
  subSpecShareScreenUsers?: [ string ](name='SubSpecShareScreenUsers'),
  subSpecUsers?: [ string ](name='SubSpecUsers'),
  taskId?: string(name='TaskId'),
  taskType?: int32(name='TaskType'),
  timeStampRef?: long(name='TimeStampRef'),
  unsubSpecAudioUsers?: [ string ](name='UnsubSpecAudioUsers'),
  unsubSpecCameraUsers?: [ string ](name='UnsubSpecCameraUsers'),
  unsubSpecShareScreenUsers?: [ string ](name='UnsubSpecShareScreenUsers'),
  userPanes?: [ 
    {
      images?: [ 
        {
          display?: int32(name='Display'),
          height?: float(name='Height'),
          url?: string(name='Url'),
          width?: float(name='Width'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Images'),
      paneId?: int32(name='PaneId'),
      segmentType?: int32(name='SegmentType'),
      sourceType?: string(name='SourceType'),
      texts?: [ 
        {
          fontColor?: int32(name='FontColor'),
          fontSize?: int32(name='FontSize'),
          fontType?: int32(name='FontType'),
          text?: string(name='Text'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Texts'),
      userId?: string(name='UserId'),
    }
  ](name='UserPanes'),
  vadInterval?: long(name='VadInterval'),
  watermarks?: [ 
    {
      alpha?: float(name='Alpha'),
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Watermarks'),
}

model StartMPUTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartMPUTaskResponse = {
  headers: map[string]string(name='headers'),
  body: StartMPUTaskResponseBody(name='body'),
}

async function startMPUTaskWithOptions(request: StartMPUTaskRequest, runtime: Util.RuntimeOptions): StartMPUTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["BackgroundColor"] = request.backgroundColor;
  query["Backgrounds"] = request.backgrounds;
  query["ChannelId"] = request.channelId;
  query["ClockWidgets"] = request.clockWidgets;
  query["CropMode"] = request.cropMode;
  query["LayoutIds"] = request.layoutIds;
  query["MediaEncode"] = request.mediaEncode;
  query["MixMode"] = request.mixMode;
  query["OwnerId"] = request.ownerId;
  query["PayloadType"] = request.payloadType;
  query["ReportVad"] = request.reportVad;
  query["RtpExtInfo"] = request.rtpExtInfo;
  query["SourceType"] = request.sourceType;
  query["StreamType"] = request.streamType;
  query["StreamURL"] = request.streamURL;
  query["SubSpecAudioUsers"] = request.subSpecAudioUsers;
  query["SubSpecCameraUsers"] = request.subSpecCameraUsers;
  query["SubSpecShareScreenUsers"] = request.subSpecShareScreenUsers;
  query["SubSpecUsers"] = request.subSpecUsers;
  query["TaskId"] = request.taskId;
  query["TaskType"] = request.taskType;
  query["TimeStampRef"] = request.timeStampRef;
  query["UnsubSpecAudioUsers"] = request.unsubSpecAudioUsers;
  query["UnsubSpecCameraUsers"] = request.unsubSpecCameraUsers;
  query["UnsubSpecShareScreenUsers"] = request.unsubSpecShareScreenUsers;
  query["UserPanes"] = request.userPanes;
  query["VadInterval"] = request.vadInterval;
  query["Watermarks"] = request.watermarks;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'StartMPUTask',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startMPUTask(request: StartMPUTaskRequest): StartMPUTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return startMPUTaskWithOptions(request, runtime);
}

model StartRecordTaskRequest {
  appId?: string(name='AppId'),
  channelId?: string(name='ChannelId'),
  cropMode?: long(name='CropMode'),
  layoutIds?: [ long ](name='LayoutIds'),
  mediaEncode?: int32(name='MediaEncode'),
  mixMode?: int32(name='MixMode'),
  ownerId?: long(name='OwnerId'),
  sourceType?: string(name='SourceType'),
  streamType?: int32(name='StreamType'),
  subSpecAudioUsers?: [ string ](name='SubSpecAudioUsers'),
  subSpecCameraUsers?: [ string ](name='SubSpecCameraUsers'),
  subSpecShareScreenUsers?: [ string ](name='SubSpecShareScreenUsers'),
  subSpecUsers?: [ string ](name='SubSpecUsers'),
  taskId?: string(name='TaskId'),
  taskProfile?: string(name='TaskProfile'),
  templateId?: string(name='TemplateId'),
  unsubSpecAudioUsers?: [ string ](name='UnsubSpecAudioUsers'),
  unsubSpecCameraUsers?: [ string ](name='UnsubSpecCameraUsers'),
  unsubSpecShareScreenUsers?: [ string ](name='UnsubSpecShareScreenUsers'),
  userPanes?: [ 
    {
      images?: [ 
        {
          display?: int32(name='Display'),
          height?: float(name='Height'),
          url?: string(name='Url'),
          width?: float(name='Width'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Images'),
      paneId?: int32(name='PaneId'),
      sourceType?: string(name='SourceType'),
      texts?: [ 
        {
          fontColor?: int32(name='FontColor'),
          fontSize?: int32(name='FontSize'),
          fontType?: int32(name='FontType'),
          text?: string(name='Text'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Texts'),
      userId?: string(name='UserId'),
    }
  ](name='UserPanes'),
}

model StartRecordTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartRecordTaskResponse = {
  headers: map[string]string(name='headers'),
  body: StartRecordTaskResponseBody(name='body'),
}

async function startRecordTaskWithOptions(request: StartRecordTaskRequest, runtime: Util.RuntimeOptions): StartRecordTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["ChannelId"] = request.channelId;
  query["CropMode"] = request.cropMode;
  query["LayoutIds"] = request.layoutIds;
  query["MediaEncode"] = request.mediaEncode;
  query["MixMode"] = request.mixMode;
  query["OwnerId"] = request.ownerId;
  query["SourceType"] = request.sourceType;
  query["StreamType"] = request.streamType;
  query["SubSpecAudioUsers"] = request.subSpecAudioUsers;
  query["SubSpecCameraUsers"] = request.subSpecCameraUsers;
  query["SubSpecShareScreenUsers"] = request.subSpecShareScreenUsers;
  query["SubSpecUsers"] = request.subSpecUsers;
  query["TaskId"] = request.taskId;
  query["TaskProfile"] = request.taskProfile;
  query["TemplateId"] = request.templateId;
  query["UnsubSpecAudioUsers"] = request.unsubSpecAudioUsers;
  query["UnsubSpecCameraUsers"] = request.unsubSpecCameraUsers;
  query["UnsubSpecShareScreenUsers"] = request.unsubSpecShareScreenUsers;
  query["UserPanes"] = request.userPanes;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'StartRecordTask',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startRecordTask(request: StartRecordTaskRequest): StartRecordTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return startRecordTaskWithOptions(request, runtime);
}

model StopChannelUserPublishRequest {
  appId?: string(name='AppId'),
  channelId?: string(name='ChannelId'),
  ownerId?: long(name='OwnerId'),
  userId?: string(name='UserId'),
}

model StopChannelUserPublishResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopChannelUserPublishResponse = {
  headers: map[string]string(name='headers'),
  body: StopChannelUserPublishResponseBody(name='body'),
}

async function stopChannelUserPublishWithOptions(request: StopChannelUserPublishRequest, runtime: Util.RuntimeOptions): StopChannelUserPublishResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["ChannelId"] = request.channelId;
  query["OwnerId"] = request.ownerId;
  query["UserId"] = request.userId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'StopChannelUserPublish',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopChannelUserPublish(request: StopChannelUserPublishRequest): StopChannelUserPublishResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopChannelUserPublishWithOptions(request, runtime);
}

model StopMPUTaskRequest {
  appId?: string(name='AppId'),
  ownerId?: long(name='OwnerId'),
  taskId?: string(name='TaskId'),
}

model StopMPUTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopMPUTaskResponse = {
  headers: map[string]string(name='headers'),
  body: StopMPUTaskResponseBody(name='body'),
}

async function stopMPUTaskWithOptions(request: StopMPUTaskRequest, runtime: Util.RuntimeOptions): StopMPUTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["OwnerId"] = request.ownerId;
  query["TaskId"] = request.taskId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'StopMPUTask',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopMPUTask(request: StopMPUTaskRequest): StopMPUTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopMPUTaskWithOptions(request, runtime);
}

model StopRecordTaskRequest {
  appId?: string(name='AppId'),
  ownerId?: long(name='OwnerId'),
  taskId?: string(name='TaskId'),
}

model StopRecordTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopRecordTaskResponse = {
  headers: map[string]string(name='headers'),
  body: StopRecordTaskResponseBody(name='body'),
}

async function stopRecordTaskWithOptions(request: StopRecordTaskRequest, runtime: Util.RuntimeOptions): StopRecordTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["OwnerId"] = request.ownerId;
  query["TaskId"] = request.taskId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'StopRecordTask',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopRecordTask(request: StopRecordTaskRequest): StopRecordTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopRecordTaskWithOptions(request, runtime);
}

model UpdateAutoLiveStreamRuleRequest {
  appId?: string(name='AppId'),
  callBack?: string(name='CallBack'),
  channelIdPrefixes?: [ string ](name='ChannelIdPrefixes'),
  channelIds?: [ string ](name='ChannelIds'),
  mediaEncode?: int32(name='MediaEncode'),
  ownerId?: long(name='OwnerId'),
  playDomain?: string(name='PlayDomain'),
  ruleId?: int32(name='RuleId'),
  ruleName?: string(name='RuleName'),
}

model UpdateAutoLiveStreamRuleResponseBody = {
  requestId?: string(name='RequestId'),
  ruleId?: long(name='RuleId'),
}

model UpdateAutoLiveStreamRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAutoLiveStreamRuleResponseBody(name='body'),
}

async function updateAutoLiveStreamRuleWithOptions(request: UpdateAutoLiveStreamRuleRequest, runtime: Util.RuntimeOptions): UpdateAutoLiveStreamRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["CallBack"] = request.callBack;
  query["ChannelIdPrefixes"] = request.channelIdPrefixes;
  query["ChannelIds"] = request.channelIds;
  query["MediaEncode"] = request.mediaEncode;
  query["OwnerId"] = request.ownerId;
  query["PlayDomain"] = request.playDomain;
  query["RuleId"] = request.ruleId;
  query["RuleName"] = request.ruleName;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAutoLiveStreamRule',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAutoLiveStreamRule(request: UpdateAutoLiveStreamRuleRequest): UpdateAutoLiveStreamRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAutoLiveStreamRuleWithOptions(request, runtime);
}

model UpdateMPUTaskRequest {
  appId?: string(name='AppId'),
  backgroundColor?: int32(name='BackgroundColor'),
  backgrounds?: [ 
    {
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Backgrounds'),
  clockWidgets?: [ 
    {
      fontColor?: int32(name='FontColor'),
      fontSize?: int32(name='FontSize'),
      fontType?: int32(name='FontType'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='ClockWidgets'),
  cropMode?: int32(name='CropMode'),
  layoutIds?: [ long ](name='LayoutIds'),
  mediaEncode?: int32(name='MediaEncode'),
  mixMode?: int32(name='MixMode'),
  ownerId?: long(name='OwnerId'),
  sourceType?: string(name='SourceType'),
  streamType?: int32(name='StreamType'),
  subSpecAudioUsers?: [ string ](name='SubSpecAudioUsers'),
  subSpecCameraUsers?: [ string ](name='SubSpecCameraUsers'),
  subSpecShareScreenUsers?: [ string ](name='SubSpecShareScreenUsers'),
  subSpecUsers?: [ string ](name='SubSpecUsers'),
  taskId?: string(name='TaskId'),
  unsubSpecAudioUsers?: [ string ](name='UnsubSpecAudioUsers'),
  unsubSpecCameraUsers?: [ string ](name='UnsubSpecCameraUsers'),
  unsubSpecShareScreenUsers?: [ string ](name='UnsubSpecShareScreenUsers'),
  userPanes?: [ 
    {
      images?: [ 
        {
          display?: int32(name='Display'),
          height?: float(name='Height'),
          url?: string(name='Url'),
          width?: float(name='Width'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Images'),
      paneId?: int32(name='PaneId'),
      segmentType?: int32(name='SegmentType'),
      sourceType?: string(name='SourceType'),
      texts?: [ 
        {
          fontColor?: int32(name='FontColor'),
          fontSize?: int32(name='FontSize'),
          fontType?: int32(name='FontType'),
          text?: string(name='Text'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Texts'),
      userId?: string(name='UserId'),
    }
  ](name='UserPanes'),
  watermarks?: [ 
    {
      alpha?: float(name='Alpha'),
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Watermarks'),
}

model UpdateMPUTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateMPUTaskResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateMPUTaskResponseBody(name='body'),
}

async function updateMPUTaskWithOptions(request: UpdateMPUTaskRequest, runtime: Util.RuntimeOptions): UpdateMPUTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["BackgroundColor"] = request.backgroundColor;
  query["Backgrounds"] = request.backgrounds;
  query["ClockWidgets"] = request.clockWidgets;
  query["CropMode"] = request.cropMode;
  query["LayoutIds"] = request.layoutIds;
  query["MediaEncode"] = request.mediaEncode;
  query["MixMode"] = request.mixMode;
  query["OwnerId"] = request.ownerId;
  query["SourceType"] = request.sourceType;
  query["StreamType"] = request.streamType;
  query["SubSpecAudioUsers"] = request.subSpecAudioUsers;
  query["SubSpecCameraUsers"] = request.subSpecCameraUsers;
  query["SubSpecShareScreenUsers"] = request.subSpecShareScreenUsers;
  query["SubSpecUsers"] = request.subSpecUsers;
  query["TaskId"] = request.taskId;
  query["UnsubSpecAudioUsers"] = request.unsubSpecAudioUsers;
  query["UnsubSpecCameraUsers"] = request.unsubSpecCameraUsers;
  query["UnsubSpecShareScreenUsers"] = request.unsubSpecShareScreenUsers;
  query["UserPanes"] = request.userPanes;
  query["Watermarks"] = request.watermarks;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMPUTask',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMPUTask(request: UpdateMPUTaskRequest): UpdateMPUTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMPUTaskWithOptions(request, runtime);
}

model UpdateRecordTaskRequest {
  appId?: string(name='AppId'),
  channelId?: string(name='ChannelId'),
  layoutIds?: [ long ](name='LayoutIds'),
  ownerId?: long(name='OwnerId'),
  subSpecAudioUsers?: [ string ](name='SubSpecAudioUsers'),
  subSpecCameraUsers?: [ string ](name='SubSpecCameraUsers'),
  subSpecShareScreenUsers?: [ string ](name='SubSpecShareScreenUsers'),
  subSpecUsers?: [ string ](name='SubSpecUsers'),
  taskId?: string(name='TaskId'),
  templateId?: string(name='TemplateId'),
  unsubSpecAudioUsers?: [ string ](name='UnsubSpecAudioUsers'),
  unsubSpecCameraUsers?: [ string ](name='UnsubSpecCameraUsers'),
  unsubSpecShareScreenUsers?: [ string ](name='UnsubSpecShareScreenUsers'),
  userPanes?: [ 
    {
      images?: [ 
        {
          display?: int32(name='Display'),
          height?: float(name='Height'),
          url?: string(name='Url'),
          width?: float(name='Width'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Images'),
      paneId?: int32(name='PaneId'),
      sourceType?: string(name='SourceType'),
      texts?: [ 
        {
          fontColor?: int32(name='FontColor'),
          fontSize?: int32(name='FontSize'),
          fontType?: int32(name='FontType'),
          text?: string(name='Text'),
          x?: float(name='X'),
          y?: float(name='Y'),
          ZOrder?: int32(name='ZOrder'),
        }
      ](name='Texts'),
      userId?: string(name='UserId'),
    }
  ](name='UserPanes'),
}

model UpdateRecordTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateRecordTaskResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRecordTaskResponseBody(name='body'),
}

async function updateRecordTaskWithOptions(request: UpdateRecordTaskRequest, runtime: Util.RuntimeOptions): UpdateRecordTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["ChannelId"] = request.channelId;
  query["LayoutIds"] = request.layoutIds;
  query["OwnerId"] = request.ownerId;
  query["SubSpecAudioUsers"] = request.subSpecAudioUsers;
  query["SubSpecCameraUsers"] = request.subSpecCameraUsers;
  query["SubSpecShareScreenUsers"] = request.subSpecShareScreenUsers;
  query["SubSpecUsers"] = request.subSpecUsers;
  query["TaskId"] = request.taskId;
  query["TemplateId"] = request.templateId;
  query["UnsubSpecAudioUsers"] = request.unsubSpecAudioUsers;
  query["UnsubSpecCameraUsers"] = request.unsubSpecCameraUsers;
  query["UnsubSpecShareScreenUsers"] = request.unsubSpecShareScreenUsers;
  query["UserPanes"] = request.userPanes;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRecordTask',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRecordTask(request: UpdateRecordTaskRequest): UpdateRecordTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRecordTaskWithOptions(request, runtime);
}

model UpdateRecordTemplateRequest {
  appId?: string(name='AppId'),
  backgroundColor?: int32(name='BackgroundColor'),
  backgrounds?: [ 
    {
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Backgrounds'),
  clockWidgets?: [ 
    {
      fontColor?: int32(name='FontColor'),
      fontSize?: int32(name='FontSize'),
      fontType?: int32(name='FontType'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='ClockWidgets'),
  delayStopTime?: int32(name='DelayStopTime'),
  enableM3u8DateTime?: boolean(name='EnableM3u8DateTime'),
  fileSplitInterval?: int32(name='FileSplitInterval'),
  formats?: [ string ](name='Formats'),
  httpCallbackUrl?: string(name='HttpCallbackUrl'),
  layoutIds?: [ long ](name='LayoutIds'),
  mediaEncode?: int32(name='MediaEncode'),
  mnsQueue?: string(name='MnsQueue'),
  name?: string(name='Name'),
  ossBucket?: string(name='OssBucket'),
  ossFilePrefix?: string(name='OssFilePrefix'),
  ownerId?: long(name='OwnerId'),
  taskProfile?: string(name='TaskProfile'),
  templateId?: string(name='TemplateId'),
  watermarks?: [ 
    {
      alpha?: float(name='Alpha'),
      display?: int32(name='Display'),
      height?: float(name='Height'),
      url?: string(name='Url'),
      width?: float(name='Width'),
      x?: float(name='X'),
      y?: float(name='Y'),
      ZOrder?: int32(name='ZOrder'),
    }
  ](name='Watermarks'),
}

model UpdateRecordTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateId?: string(name='TemplateId'),
}

model UpdateRecordTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRecordTemplateResponseBody(name='body'),
}

async function updateRecordTemplateWithOptions(request: UpdateRecordTemplateRequest, runtime: Util.RuntimeOptions): UpdateRecordTemplateResponse {
  Util.validateModel(request);
  var query = {};
  query["AppId"] = request.appId;
  query["BackgroundColor"] = request.backgroundColor;
  query["Backgrounds"] = request.backgrounds;
  query["ClockWidgets"] = request.clockWidgets;
  query["DelayStopTime"] = request.delayStopTime;
  query["EnableM3u8DateTime"] = request.enableM3u8DateTime;
  query["FileSplitInterval"] = request.fileSplitInterval;
  query["Formats"] = request.formats;
  query["HttpCallbackUrl"] = request.httpCallbackUrl;
  query["LayoutIds"] = request.layoutIds;
  query["MediaEncode"] = request.mediaEncode;
  query["MnsQueue"] = request.mnsQueue;
  query["Name"] = request.name;
  query["OssBucket"] = request.ossBucket;
  query["OssFilePrefix"] = request.ossFilePrefix;
  query["OwnerId"] = request.ownerId;
  query["TaskProfile"] = request.taskProfile;
  query["TemplateId"] = request.templateId;
  query["Watermarks"] = request.watermarks;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRecordTemplate',
    version = '2018-01-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRecordTemplate(request: UpdateRecordTemplateRequest): UpdateRecordTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRecordTemplateWithOptions(request, runtime);
}

