/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('cms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddTagsRequest {
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  groupIds?: [ string ](name='GroupIds'),
}

model AddTagsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model AddTagsResponse = {
  headers: map[string]string(name='headers'),
  body: AddTagsResponseBody(name='body'),
}

async function addTagsWithOptions(request: AddTagsRequest, runtime: Util.RuntimeOptions): AddTagsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddTags', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addTags(request: AddTagsRequest): AddTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTagsWithOptions(request, runtime);
}

model ApplyMetricRuleTemplateRequest {
  silenceTime?: long(name='SilenceTime'),
  groupId?: long(name='GroupId'),
  templateIds?: string(name='TemplateIds'),
  enableStartTime?: long(name='EnableStartTime'),
  enableEndTime?: long(name='EnableEndTime'),
  notifyLevel?: long(name='NotifyLevel'),
  applyMode?: string(name='ApplyMode'),
  webhook?: string(name='Webhook'),
}

model ApplyMetricRuleTemplateResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resource?: {
    alertResults?: [ 
      {
        success?: boolean(name='Success'),
        code?: string(name='Code'),
        message?: string(name='Message'),
        ruleName?: string(name='RuleName'),
        ruleId?: string(name='RuleId'),
      }
    ](name='AlertResults'),
    groupId?: long(name='GroupId'),
  }(name='Resource'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ApplyMetricRuleTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyMetricRuleTemplateResponseBody(name='body'),
}

async function applyMetricRuleTemplateWithOptions(request: ApplyMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): ApplyMetricRuleTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ApplyMetricRuleTemplate', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function applyMetricRuleTemplate(request: ApplyMetricRuleTemplateRequest): ApplyMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyMetricRuleTemplateWithOptions(request, runtime);
}

model CreateCmsCallNumOrderRequest {
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  autoPay?: boolean(name='AutoPay'),
  autoUseCoupon?: boolean(name='AutoUseCoupon'),
  phoneCount?: string(name='PhoneCount'),
}

model CreateCmsCallNumOrderResponseBody = {
  requestId?: string(name='RequestId'),
  orderId?: string(name='OrderId'),
}

model CreateCmsCallNumOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCmsCallNumOrderResponseBody(name='body'),
}

async function createCmsCallNumOrderWithOptions(request: CreateCmsCallNumOrderRequest, runtime: Util.RuntimeOptions): CreateCmsCallNumOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateCmsCallNumOrder', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createCmsCallNumOrder(request: CreateCmsCallNumOrderRequest): CreateCmsCallNumOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCmsCallNumOrderWithOptions(request, runtime);
}

model CreateCmsOrderRequest {
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  autoPay?: boolean(name='AutoPay'),
  autoUseCoupon?: boolean(name='AutoUseCoupon'),
  payType?: string(name='PayType'),
  suggestType?: string(name='SuggestType'),
  apiCount?: string(name='ApiCount'),
  siteOperatorNum?: string(name='SiteOperatorNum'),
  eventStoreTime?: string(name='EventStoreTime'),
  logMonitorStream?: string(name='LogMonitorStream'),
  siteTaskNum?: string(name='SiteTaskNum'),
  eventStoreNum?: string(name='EventStoreNum'),
  siteEcsNum?: string(name='SiteEcsNum'),
  customTimeSeries?: string(name='CustomTimeSeries'),
  smsCount?: string(name='SmsCount'),
  phoneCount?: string(name='PhoneCount'),
}

model CreateCmsOrderResponseBody = {
  requestId?: string(name='RequestId'),
  orderId?: string(name='OrderId'),
}

model CreateCmsOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCmsOrderResponseBody(name='body'),
}

async function createCmsOrderWithOptions(request: CreateCmsOrderRequest, runtime: Util.RuntimeOptions): CreateCmsOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateCmsOrder', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createCmsOrder(request: CreateCmsOrderRequest): CreateCmsOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCmsOrderWithOptions(request, runtime);
}

model CreateCmsSmspackageOrderRequest {
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  autoPay?: boolean(name='AutoPay'),
  autoUseCoupon?: boolean(name='AutoUseCoupon'),
  smsCount?: string(name='SmsCount'),
}

model CreateCmsSmspackageOrderResponseBody = {
  requestId?: string(name='RequestId'),
  orderId?: string(name='OrderId'),
}

model CreateCmsSmspackageOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCmsSmspackageOrderResponseBody(name='body'),
}

async function createCmsSmspackageOrderWithOptions(request: CreateCmsSmspackageOrderRequest, runtime: Util.RuntimeOptions): CreateCmsSmspackageOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateCmsSmspackageOrder', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createCmsSmspackageOrder(request: CreateCmsSmspackageOrderRequest): CreateCmsSmspackageOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCmsSmspackageOrderWithOptions(request, runtime);
}

model CreateDynamicTagGroupRequest {
  tagKey?: string(name='TagKey'),
  enableSubscribeEvent?: boolean(name='EnableSubscribeEvent'),
  enableInstallAgent?: boolean(name='EnableInstallAgent'),
  matchExpressFilterRelation?: string(name='MatchExpressFilterRelation'),
  matchExpress?: [ 
    {
      tagValueMatchFunction?: string(name='TagValueMatchFunction'),
      tagValue?: string(name='TagValue'),
    }
  ](name='MatchExpress'),
  contactGroupList?: [ string ](name='ContactGroupList'),
  templateIdList?: [ string ](name='TemplateIdList'),
}

model CreateDynamicTagGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateDynamicTagGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDynamicTagGroupResponseBody(name='body'),
}

async function createDynamicTagGroupWithOptions(request: CreateDynamicTagGroupRequest, runtime: Util.RuntimeOptions): CreateDynamicTagGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateDynamicTagGroup', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createDynamicTagGroup(request: CreateDynamicTagGroupRequest): CreateDynamicTagGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDynamicTagGroupWithOptions(request, runtime);
}

model CreateGroupMetricRulesRequest {
  groupId?: long(name='GroupId'),
  groupMetricRules?: [ 
    {
      escalations: {
        info: {
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
            statistics?: string(name='Statistics'),
            comparisonOperator?: string(name='ComparisonOperator'),
        }(name='Info'),
        warn: {
            threshold?: string(name='Threshold'),
            comparisonOperator?: string(name='ComparisonOperator'),
            times?: int32(name='Times'),
            statistics?: string(name='Statistics'),
        }(name='Warn'),
        critical: {
            times?: int32(name='Times'),
            threshold?: string(name='Threshold'),
            statistics?: string(name='Statistics'),
            comparisonOperator?: string(name='ComparisonOperator'),
        }(name='Critical'),
      }(name='Escalations'),
      metricName?: string(name='MetricName'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      effectiveInterval?: string(name='EffectiveInterval'),
      ruleId?: string(name='RuleId'),
      dimensions?: string(name='Dimensions'),
      silenceTime?: int32(name='SilenceTime'),
      webhook?: string(name='Webhook'),
      namespace?: string(name='Namespace'),
      emailSubject?: string(name='EmailSubject'),
      period?: string(name='Period'),
      ruleName?: string(name='RuleName'),
      interval?: string(name='Interval'),
      category?: string(name='Category'),
    }
  ](name='GroupMetricRules'),
}

model CreateGroupMetricRulesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resources?: {
    alertResult?: [ 
    {
      success?: boolean(name='Success'),
      code?: int32(name='Code'),
      message?: string(name='Message'),
      ruleName?: string(name='RuleName'),
      ruleId?: string(name='RuleId'),
    }
  ](name='AlertResult')
  }(name='Resources'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model CreateGroupMetricRulesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGroupMetricRulesResponseBody(name='body'),
}

async function createGroupMetricRulesWithOptions(request: CreateGroupMetricRulesRequest, runtime: Util.RuntimeOptions): CreateGroupMetricRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateGroupMetricRules', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createGroupMetricRules(request: CreateGroupMetricRulesRequest): CreateGroupMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupMetricRulesWithOptions(request, runtime);
}

model CreateGroupMonitoringAgentProcessRequest {
  groupId?: string(name='GroupId'),
  processName?: string(name='ProcessName'),
  matchExpressFilterRelation?: string(name='MatchExpressFilterRelation'),
  matchExpress?: [ 
    {
      value?: string(name='Value'),
      function?: string(name='Function'),
      name?: string(name='Name'),
    }
  ](name='MatchExpress'),
  alertConfig?: [ 
    {
      silenceTime?: string(name='SilenceTime'),
      comparisonOperator?: string(name='ComparisonOperator'),
      webhook?: string(name='Webhook'),
      times?: string(name='Times'),
      escalationsLevel?: string(name='EscalationsLevel'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      effectiveInterval?: string(name='EffectiveInterval'),
      threshold?: string(name='Threshold'),
      statistics?: string(name='Statistics'),
    }
  ](name='AlertConfig'),
}

model CreateGroupMonitoringAgentProcessResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateGroupMonitoringAgentProcessResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGroupMonitoringAgentProcessResponseBody(name='body'),
}

async function createGroupMonitoringAgentProcessWithOptions(request: CreateGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): CreateGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateGroupMonitoringAgentProcess', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createGroupMonitoringAgentProcess(request: CreateGroupMonitoringAgentProcessRequest): CreateGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model CreateHostAvailabilityRequest {
  taskOption?: {
    httpURI?: string(name='HttpURI'),
    telnetOrPingHost?: string(name='TelnetOrPingHost'),
    httpResponseCharset?: string(name='HttpResponseCharset'),
    httpPostContent?: string(name='HttpPostContent'),
    httpResponseMatchContent?: string(name='HttpResponseMatchContent'),
    httpMethod?: string(name='HttpMethod'),
    httpNegative?: boolean(name='HttpNegative'),
    httpHeader?: string(name='HttpHeader'),
  }(name='TaskOption'),
  alertConfig?: {
    notifyType?: int32(name='NotifyType'),
    startTime?: int32(name='StartTime'),
    endTime?: int32(name='EndTime'),
    silenceTime?: int32(name='SilenceTime'),
    webHook?: string(name='WebHook'),
  }(name='AlertConfig'),
  groupId?: long(name='GroupId'),
  taskName?: string(name='TaskName'),
  taskScope?: string(name='TaskScope'),
  taskType?: string(name='TaskType'),
  alertConfigEscalationList?: [ 
    {
      value?: string(name='Value'),
      metricName?: string(name='MetricName'),
      times?: int32(name='Times'),
      operator?: string(name='Operator'),
      aggregate?: string(name='Aggregate'),
    }
  ](name='AlertConfigEscalationList'),
  instanceList?: [ string ](name='InstanceList'),
}

model CreateHostAvailabilityResponseBody = {
  taskId?: long(name='TaskId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateHostAvailabilityResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHostAvailabilityResponseBody(name='body'),
}

async function createHostAvailabilityWithOptions(request: CreateHostAvailabilityRequest, runtime: Util.RuntimeOptions): CreateHostAvailabilityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateHostAvailability', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createHostAvailability(request: CreateHostAvailabilityRequest): CreateHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHostAvailabilityWithOptions(request, runtime);
}

model CreateMetricRuleResourcesRequest {
  ruleId?: string(name='RuleId'),
  overwrite?: string(name='Overwrite'),
  resources?: string(name='Resources'),
}

model CreateMetricRuleResourcesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateMetricRuleResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMetricRuleResourcesResponseBody(name='body'),
}

async function createMetricRuleResourcesWithOptions(request: CreateMetricRuleResourcesRequest, runtime: Util.RuntimeOptions): CreateMetricRuleResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateMetricRuleResources', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createMetricRuleResources(request: CreateMetricRuleResourcesRequest): CreateMetricRuleResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMetricRuleResourcesWithOptions(request, runtime);
}

model CreateMetricRuleTemplateRequest {
  name?: string(name='Name'),
  description?: string(name='Description'),
  alertTemplates?: [ 
    {
      escalations: {
        info: {
            threshold?: string(name='Threshold'),
            statistics?: string(name='Statistics'),
            comparisonOperator?: string(name='ComparisonOperator'),
            times?: int32(name='Times'),
        }(name='Info'),
        warn: {
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
            comparisonOperator?: string(name='ComparisonOperator'),
            statistics?: string(name='Statistics'),
        }(name='Warn'),
        critical: {
            times?: int32(name='Times'),
            threshold?: string(name='Threshold'),
            comparisonOperator?: string(name='ComparisonOperator'),
            statistics?: string(name='Statistics'),
        }(name='Critical'),
      }(name='Escalations'),
      metricName?: string(name='MetricName'),
      webhook?: string(name='Webhook'),
      namespace?: string(name='Namespace'),
      ruleName?: string(name='RuleName'),
      period?: int32(name='Period'),
      selector?: string(name='Selector'),
      category?: string(name='Category'),
    }
  ](name='AlertTemplates'),
}

model CreateMetricRuleTemplateResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  id?: long(name='Id'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model CreateMetricRuleTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMetricRuleTemplateResponseBody(name='body'),
}

async function createMetricRuleTemplateWithOptions(request: CreateMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): CreateMetricRuleTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateMetricRuleTemplate', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createMetricRuleTemplate(request: CreateMetricRuleTemplateRequest): CreateMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMetricRuleTemplateWithOptions(request, runtime);
}

model CreateMonitorAgentProcessRequest {
  processName?: string(name='ProcessName'),
  instanceId?: string(name='InstanceId'),
  processUser?: string(name='ProcessUser'),
}

model CreateMonitorAgentProcessResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  id?: long(name='Id'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateMonitorAgentProcessResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMonitorAgentProcessResponseBody(name='body'),
}

async function createMonitorAgentProcessWithOptions(request: CreateMonitorAgentProcessRequest, runtime: Util.RuntimeOptions): CreateMonitorAgentProcessResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateMonitorAgentProcess', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createMonitorAgentProcess(request: CreateMonitorAgentProcessRequest): CreateMonitorAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorAgentProcessWithOptions(request, runtime);
}

model CreateMonitorGroupRequest {
  groupName?: string(name='GroupName'),
  contactGroups?: string(name='ContactGroups'),
}

model CreateMonitorGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
  groupId?: long(name='GroupId'),
}

model CreateMonitorGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMonitorGroupResponseBody(name='body'),
}

async function createMonitorGroupWithOptions(request: CreateMonitorGroupRequest, runtime: Util.RuntimeOptions): CreateMonitorGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateMonitorGroup', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createMonitorGroup(request: CreateMonitorGroupRequest): CreateMonitorGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorGroupWithOptions(request, runtime);
}

model CreateMonitorGroupByResourceGroupIdRequest {
  enableSubscribeEvent?: boolean(name='EnableSubscribeEvent'),
  enableInstallAgent?: boolean(name='EnableInstallAgent'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceGroupName?: string(name='ResourceGroupName'),
  contactGroupList?: [ string ](name='ContactGroupList'),
}

model CreateMonitorGroupByResourceGroupIdResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateMonitorGroupByResourceGroupIdResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMonitorGroupByResourceGroupIdResponseBody(name='body'),
}

async function createMonitorGroupByResourceGroupIdWithOptions(request: CreateMonitorGroupByResourceGroupIdRequest, runtime: Util.RuntimeOptions): CreateMonitorGroupByResourceGroupIdResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateMonitorGroupByResourceGroupId', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createMonitorGroupByResourceGroupId(request: CreateMonitorGroupByResourceGroupIdRequest): CreateMonitorGroupByResourceGroupIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorGroupByResourceGroupIdWithOptions(request, runtime);
}

model CreateMonitorGroupInstancesRequest {
  groupId?: string(name='GroupId'),
  instances?: [ 
    {
      instanceName?: string(name='InstanceName'),
      category?: string(name='Category'),
      instanceId?: string(name='InstanceId'),
      regionId?: string(name='RegionId'),
    }
  ](name='Instances'),
}

model CreateMonitorGroupInstancesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model CreateMonitorGroupInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMonitorGroupInstancesResponseBody(name='body'),
}

async function createMonitorGroupInstancesWithOptions(request: CreateMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): CreateMonitorGroupInstancesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateMonitorGroupInstances', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createMonitorGroupInstances(request: CreateMonitorGroupInstancesRequest): CreateMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorGroupInstancesWithOptions(request, runtime);
}

model CreateMonitorGroupNotifyPolicyRequest {
  policyType?: string(name='PolicyType'),
  groupId?: string(name='GroupId'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
}

model CreateMonitorGroupNotifyPolicyResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: string(name='Success'),
  result?: int32(name='Result'),
}

model CreateMonitorGroupNotifyPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMonitorGroupNotifyPolicyResponseBody(name='body'),
}

async function createMonitorGroupNotifyPolicyWithOptions(request: CreateMonitorGroupNotifyPolicyRequest, runtime: Util.RuntimeOptions): CreateMonitorGroupNotifyPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateMonitorGroupNotifyPolicy', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createMonitorGroupNotifyPolicy(request: CreateMonitorGroupNotifyPolicyRequest): CreateMonitorGroupNotifyPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorGroupNotifyPolicyWithOptions(request, runtime);
}

model CreateMonitoringAgentProcessRequest {
  processName?: string(name='ProcessName'),
  instanceId?: string(name='InstanceId'),
  processUser?: string(name='ProcessUser'),
}

model CreateMonitoringAgentProcessResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  id?: long(name='Id'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateMonitoringAgentProcessResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMonitoringAgentProcessResponseBody(name='body'),
}

async function createMonitoringAgentProcessWithOptions(request: CreateMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): CreateMonitoringAgentProcessResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateMonitoringAgentProcess', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createMonitoringAgentProcess(request: CreateMonitoringAgentProcessRequest): CreateMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitoringAgentProcessWithOptions(request, runtime);
}

model CreateSiteMonitorRequest {
  address?: string(name='Address'),
  taskType?: string(name='TaskType'),
  taskName?: string(name='TaskName'),
  interval?: string(name='Interval'),
  ispCities?: string(name='IspCities'),
  optionsJson?: string(name='OptionsJson'),
  alertIds?: string(name='AlertIds'),
}

model CreateSiteMonitorResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    attachAlertResult?: {
      contact?: [ 
      {
        requestId?: string(name='RequestId'),
        success?: string(name='Success'),
        code?: string(name='Code'),
        message?: string(name='Message'),
        ruleId?: string(name='RuleId'),
      }
    ](name='Contact')
    }(name='AttachAlertResult'),
  }(name='Data'),
  code?: string(name='Code'),
  createResultList?: {
    createResultList?: [ 
    {
      taskName?: string(name='TaskName'),
      taskId?: string(name='TaskId'),
    }
  ](name='CreateResultList')
  }(name='CreateResultList'),
  success?: string(name='Success'),
}

model CreateSiteMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSiteMonitorResponseBody(name='body'),
}

async function createSiteMonitorWithOptions(request: CreateSiteMonitorRequest, runtime: Util.RuntimeOptions): CreateSiteMonitorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSiteMonitor', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSiteMonitor(request: CreateSiteMonitorRequest): CreateSiteMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSiteMonitorWithOptions(request, runtime);
}

model DeleteContactRequest {
  contactName?: string(name='ContactName'),
}

model DeleteContactResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteContactResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteContactResponseBody(name='body'),
}

async function deleteContactWithOptions(request: DeleteContactRequest, runtime: Util.RuntimeOptions): DeleteContactResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteContact', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteContact(request: DeleteContactRequest): DeleteContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContactWithOptions(request, runtime);
}

model DeleteContactGroupRequest {
  contactGroupName?: string(name='ContactGroupName'),
}

model DeleteContactGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteContactGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteContactGroupResponseBody(name='body'),
}

async function deleteContactGroupWithOptions(request: DeleteContactGroupRequest, runtime: Util.RuntimeOptions): DeleteContactGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteContactGroup', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteContactGroup(request: DeleteContactGroupRequest): DeleteContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContactGroupWithOptions(request, runtime);
}

model DeleteCustomMetricRequest {
  groupId?: string(name='GroupId'),
  metricName?: string(name='MetricName'),
  md5?: string(name='Md5'),
  UUID?: string(name='UUID'),
}

model DeleteCustomMetricResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model DeleteCustomMetricResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCustomMetricResponseBody(name='body'),
}

async function deleteCustomMetricWithOptions(request: DeleteCustomMetricRequest, runtime: Util.RuntimeOptions): DeleteCustomMetricResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteCustomMetric', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteCustomMetric(request: DeleteCustomMetricRequest): DeleteCustomMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomMetricWithOptions(request, runtime);
}

model DeleteDynamicTagGroupRequest {
  dynamicTagRuleId?: string(name='DynamicTagRuleId'),
}

model DeleteDynamicTagGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteDynamicTagGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDynamicTagGroupResponseBody(name='body'),
}

async function deleteDynamicTagGroupWithOptions(request: DeleteDynamicTagGroupRequest, runtime: Util.RuntimeOptions): DeleteDynamicTagGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteDynamicTagGroup', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteDynamicTagGroup(request: DeleteDynamicTagGroupRequest): DeleteDynamicTagGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDynamicTagGroupWithOptions(request, runtime);
}

model DeleteEventRulesRequest {
  ruleNames?: [ string ](name='RuleNames'),
}

model DeleteEventRulesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteEventRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEventRulesResponseBody(name='body'),
}

async function deleteEventRulesWithOptions(request: DeleteEventRulesRequest, runtime: Util.RuntimeOptions): DeleteEventRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteEventRules', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteEventRules(request: DeleteEventRulesRequest): DeleteEventRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventRulesWithOptions(request, runtime);
}

model DeleteEventRuleTargetsRequest {
  ruleName?: string(name='RuleName'),
  ids?: [ string ](name='Ids'),
}

model DeleteEventRuleTargetsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteEventRuleTargetsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteEventRuleTargetsResponseBody(name='body'),
}

async function deleteEventRuleTargetsWithOptions(request: DeleteEventRuleTargetsRequest, runtime: Util.RuntimeOptions): DeleteEventRuleTargetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteEventRuleTargets', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteEventRuleTargets(request: DeleteEventRuleTargetsRequest): DeleteEventRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventRuleTargetsWithOptions(request, runtime);
}

model DeleteExporterOutputRequest {
  destName?: string(name='DestName'),
}

model DeleteExporterOutputResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteExporterOutputResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExporterOutputResponseBody(name='body'),
}

async function deleteExporterOutputWithOptions(request: DeleteExporterOutputRequest, runtime: Util.RuntimeOptions): DeleteExporterOutputResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteExporterOutput', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteExporterOutput(request: DeleteExporterOutputRequest): DeleteExporterOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExporterOutputWithOptions(request, runtime);
}

model DeleteExporterRuleRequest {
  ruleName?: string(name='RuleName'),
}

model DeleteExporterRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteExporterRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExporterRuleResponseBody(name='body'),
}

async function deleteExporterRuleWithOptions(request: DeleteExporterRuleRequest, runtime: Util.RuntimeOptions): DeleteExporterRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteExporterRule', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteExporterRule(request: DeleteExporterRuleRequest): DeleteExporterRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExporterRuleWithOptions(request, runtime);
}

model DeleteGroupMonitoringAgentProcessRequest {
  groupId?: string(name='GroupId'),
  id?: string(name='Id'),
}

model DeleteGroupMonitoringAgentProcessResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteGroupMonitoringAgentProcessResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGroupMonitoringAgentProcessResponseBody(name='body'),
}

async function deleteGroupMonitoringAgentProcessWithOptions(request: DeleteGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): DeleteGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteGroupMonitoringAgentProcess', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteGroupMonitoringAgentProcess(request: DeleteGroupMonitoringAgentProcessRequest): DeleteGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model DeleteHostAvailabilityRequest {
  id?: [ integer ](name='Id'),
}

model DeleteHostAvailabilityResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteHostAvailabilityResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHostAvailabilityResponseBody(name='body'),
}

async function deleteHostAvailabilityWithOptions(request: DeleteHostAvailabilityRequest, runtime: Util.RuntimeOptions): DeleteHostAvailabilityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteHostAvailability', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteHostAvailability(request: DeleteHostAvailabilityRequest): DeleteHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHostAvailabilityWithOptions(request, runtime);
}

model DeleteLogMonitorRequest {
  logId?: long(name='LogId'),
}

model DeleteLogMonitorResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteLogMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLogMonitorResponseBody(name='body'),
}

async function deleteLogMonitorWithOptions(request: DeleteLogMonitorRequest, runtime: Util.RuntimeOptions): DeleteLogMonitorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteLogMonitor', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteLogMonitor(request: DeleteLogMonitorRequest): DeleteLogMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLogMonitorWithOptions(request, runtime);
}

model DeleteMetricRuleResourcesRequest {
  ruleId?: string(name='RuleId'),
  resources?: string(name='Resources'),
}

model DeleteMetricRuleResourcesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteMetricRuleResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMetricRuleResourcesResponseBody(name='body'),
}

async function deleteMetricRuleResourcesWithOptions(request: DeleteMetricRuleResourcesRequest, runtime: Util.RuntimeOptions): DeleteMetricRuleResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMetricRuleResources', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMetricRuleResources(request: DeleteMetricRuleResourcesRequest): DeleteMetricRuleResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRuleResourcesWithOptions(request, runtime);
}

model DeleteMetricRulesRequest {
  id?: [ string ](name='Id'),
}

model DeleteMetricRulesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteMetricRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMetricRulesResponseBody(name='body'),
}

async function deleteMetricRulesWithOptions(request: DeleteMetricRulesRequest, runtime: Util.RuntimeOptions): DeleteMetricRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMetricRules', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMetricRules(request: DeleteMetricRulesRequest): DeleteMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRulesWithOptions(request, runtime);
}

model DeleteMetricRuleTargetsRequest {
  ruleId?: string(name='RuleId'),
  targetIds?: [ string ](name='TargetIds'),
}

model DeleteMetricRuleTargetsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
  failIds?: {
    targetIds?: {
      targetId?: [ string ](name='TargetId')
    }(name='TargetIds'),
  }(name='FailIds'),
}

model DeleteMetricRuleTargetsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMetricRuleTargetsResponseBody(name='body'),
}

async function deleteMetricRuleTargetsWithOptions(request: DeleteMetricRuleTargetsRequest, runtime: Util.RuntimeOptions): DeleteMetricRuleTargetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMetricRuleTargets', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMetricRuleTargets(request: DeleteMetricRuleTargetsRequest): DeleteMetricRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRuleTargetsWithOptions(request, runtime);
}

model DeleteMetricRuleTemplateRequest {
  templateId?: string(name='TemplateId'),
}

model DeleteMetricRuleTemplateResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resource?: {
    templateId?: string(name='TemplateId'),
  }(name='Resource'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteMetricRuleTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMetricRuleTemplateResponseBody(name='body'),
}

async function deleteMetricRuleTemplateWithOptions(request: DeleteMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): DeleteMetricRuleTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMetricRuleTemplate', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMetricRuleTemplate(request: DeleteMetricRuleTemplateRequest): DeleteMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRuleTemplateWithOptions(request, runtime);
}

model DeleteMonitorGroupRequest {
  groupId?: long(name='GroupId'),
}

model DeleteMonitorGroupResponseBody = {
  group?: {
    groupName?: string(name='GroupName'),
    contactGroups?: {
      contactGroup?: [ 
      {
        name?: string(name='Name'),
      }
    ](name='ContactGroup')
    }(name='ContactGroups'),
  }(name='Group'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteMonitorGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMonitorGroupResponseBody(name='body'),
}

async function deleteMonitorGroupWithOptions(request: DeleteMonitorGroupRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMonitorGroup', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMonitorGroup(request: DeleteMonitorGroupRequest): DeleteMonitorGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupWithOptions(request, runtime);
}

model DeleteMonitorGroupDynamicRuleRequest {
  groupId?: long(name='GroupId'),
  category?: string(name='Category'),
}

model DeleteMonitorGroupDynamicRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteMonitorGroupDynamicRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMonitorGroupDynamicRuleResponseBody(name='body'),
}

async function deleteMonitorGroupDynamicRuleWithOptions(request: DeleteMonitorGroupDynamicRuleRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupDynamicRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMonitorGroupDynamicRule', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMonitorGroupDynamicRule(request: DeleteMonitorGroupDynamicRuleRequest): DeleteMonitorGroupDynamicRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupDynamicRuleWithOptions(request, runtime);
}

model DeleteMonitorGroupInstancesRequest {
  groupId?: long(name='GroupId'),
  instanceIdList?: string(name='InstanceIdList'),
  category?: string(name='Category'),
}

model DeleteMonitorGroupInstancesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteMonitorGroupInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMonitorGroupInstancesResponseBody(name='body'),
}

async function deleteMonitorGroupInstancesWithOptions(request: DeleteMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupInstancesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMonitorGroupInstances', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMonitorGroupInstances(request: DeleteMonitorGroupInstancesRequest): DeleteMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupInstancesWithOptions(request, runtime);
}

model DeleteMonitorGroupNotifyPolicyRequest {
  policyType?: string(name='PolicyType'),
  groupId?: string(name='GroupId'),
}

model DeleteMonitorGroupNotifyPolicyResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: string(name='Success'),
  result?: int32(name='Result'),
}

model DeleteMonitorGroupNotifyPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMonitorGroupNotifyPolicyResponseBody(name='body'),
}

async function deleteMonitorGroupNotifyPolicyWithOptions(request: DeleteMonitorGroupNotifyPolicyRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupNotifyPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMonitorGroupNotifyPolicy', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMonitorGroupNotifyPolicy(request: DeleteMonitorGroupNotifyPolicyRequest): DeleteMonitorGroupNotifyPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupNotifyPolicyWithOptions(request, runtime);
}

model DeleteMonitoringAgentProcessRequest {
  instanceId?: string(name='InstanceId'),
  processName?: string(name='ProcessName'),
  processId?: string(name='ProcessId'),
}

model DeleteMonitoringAgentProcessResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteMonitoringAgentProcessResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMonitoringAgentProcessResponseBody(name='body'),
}

async function deleteMonitoringAgentProcessWithOptions(request: DeleteMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): DeleteMonitoringAgentProcessResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteMonitoringAgentProcess', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteMonitoringAgentProcess(request: DeleteMonitoringAgentProcessRequest): DeleteMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitoringAgentProcessWithOptions(request, runtime);
}

model DeleteSiteMonitorsRequest {
  taskIds?: string(name='TaskIds'),
  isDeleteAlarms?: boolean(name='IsDeleteAlarms'),
}

model DeleteSiteMonitorsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    count?: int32(name='count'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: string(name='Success'),
}

model DeleteSiteMonitorsResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSiteMonitorsResponseBody(name='body'),
}

async function deleteSiteMonitorsWithOptions(request: DeleteSiteMonitorsRequest, runtime: Util.RuntimeOptions): DeleteSiteMonitorsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSiteMonitors', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSiteMonitors(request: DeleteSiteMonitorsRequest): DeleteSiteMonitorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSiteMonitorsWithOptions(request, runtime);
}

model DescribeActiveMetricRuleListRequest {
  product?: string(name='Product'),
}

model DescribeActiveMetricRuleListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  alertList?: {
    alert?: [ 
    {
      silenceTime?: string(name='SilenceTime'),
      metricName?: string(name='MetricName'),
      webhook?: string(name='Webhook'),
      escalations?: {
        critical?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          times?: string(name='Times'),
          threshold?: string(name='Threshold'),
          statistics?: string(name='Statistics'),
        }(name='Critical'),
        info?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          times?: string(name='Times'),
          threshold?: string(name='Threshold'),
          statistics?: string(name='Statistics'),
        }(name='Info'),
        warn?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          times?: string(name='Times'),
          threshold?: string(name='Threshold'),
          statistics?: string(name='Statistics'),
        }(name='Warn'),
      }(name='Escalations'),
      contactGroups?: string(name='ContactGroups'),
      namespace?: string(name='Namespace'),
      mailSubject?: string(name='MailSubject'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      effectiveInterval?: string(name='EffectiveInterval'),
      ruleName?: string(name='RuleName'),
      alertState?: string(name='AlertState'),
      period?: string(name='Period'),
      ruleId?: string(name='RuleId'),
      dimensions?: string(name='Dimensions'),
      enableState?: boolean(name='EnableState'),
      resources?: string(name='Resources'),
    }
  ](name='Alert')
  }(name='AlertList'),
  datapoints?: {
    alarm?: [ 
    {
      silenceTime?: string(name='SilenceTime'),
      metricName?: string(name='MetricName'),
      evaluationCount?: string(name='EvaluationCount'),
      webhook?: string(name='Webhook'),
      state?: string(name='State'),
      contactGroups?: string(name='ContactGroups'),
      namespace?: string(name='Namespace'),
      period?: string(name='Period'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      endTime?: string(name='EndTime'),
      comparisonOperator?: string(name='ComparisonOperator'),
      startTime?: string(name='StartTime'),
      threshold?: string(name='Threshold'),
      statistics?: string(name='Statistics'),
      enable?: string(name='Enable'),
    }
  ](name='Alarm')
  }(name='Datapoints'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeActiveMetricRuleListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeActiveMetricRuleListResponseBody(name='body'),
}

async function describeActiveMetricRuleListWithOptions(request: DescribeActiveMetricRuleListRequest, runtime: Util.RuntimeOptions): DescribeActiveMetricRuleListResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeActiveMetricRuleList', '2019-01-01', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeActiveMetricRuleList(request: DescribeActiveMetricRuleListRequest): DescribeActiveMetricRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeActiveMetricRuleListWithOptions(request, runtime);
}

model DescribeAlertHistoryListRequest {
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  namespace?: string(name='Namespace'),
  metricName?: string(name='MetricName'),
  groupId?: string(name='GroupId'),
  status?: string(name='Status'),
  state?: string(name='State'),
  ascending?: boolean(name='Ascending'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  pageSize?: int32(name='PageSize'),
  page?: int32(name='Page'),
}

model DescribeAlertHistoryListResponseBody = {
  alarmHistoryList?: {
    alarmHistory?: [ 
    {
      status?: int32(name='Status'),
      metricName?: string(name='MetricName'),
      contacts?: {
        contact?: [ string ](name='Contact')
      }(name='Contacts'),
      evaluationCount?: int32(name='EvaluationCount'),
      state?: string(name='State'),
      contactGroups?: {
        contactGroup?: [ string ](name='ContactGroup')
      }(name='ContactGroups'),
      namespace?: string(name='Namespace'),
      webhooks?: string(name='Webhooks'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      lastTime?: long(name='LastTime'),
      value?: string(name='Value'),
      expression?: string(name='Expression'),
      groupId?: string(name='GroupId'),
      alertTime?: long(name='AlertTime'),
      instanceName?: string(name='InstanceName'),
      contactSmses?: {
        contactSms?: [ string ](name='ContactSms')
      }(name='ContactSmses'),
      dimensions?: string(name='Dimensions'),
      contactALIIMs?: {
        contactALIIM?: [ string ](name='ContactALIIM')
      }(name='ContactALIIMs'),
      level?: string(name='Level'),
      contactMails?: {
        contactMail?: [ string ](name='ContactMail')
      }(name='ContactMails'),
    }
  ](name='AlarmHistory')
  }(name='AlarmHistoryList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  total?: string(name='Total'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeAlertHistoryListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAlertHistoryListResponseBody(name='body'),
}

async function describeAlertHistoryListWithOptions(request: DescribeAlertHistoryListRequest, runtime: Util.RuntimeOptions): DescribeAlertHistoryListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeAlertHistoryList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAlertHistoryList(request: DescribeAlertHistoryListRequest): DescribeAlertHistoryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertHistoryListWithOptions(request, runtime);
}

model DescribeAlertingMetricRuleResourcesRequest {
  ruleId?: string(name='RuleId'),
  groupId?: string(name='GroupId'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  namespace?: string(name='Namespace'),
}

model DescribeAlertingMetricRuleResourcesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
  resources?: {
    resource?: [ 
    {
      metricName?: string(name='MetricName'),
      retryTimes?: string(name='RetryTimes'),
      metricValues?: string(name='MetricValues'),
      namespace?: string(name='Namespace'),
      escalation?: {
        resource?: [ 
        {
          comparisonOperator?: string(name='ComparisonOperator'),
          preCondition?: string(name='PreCondition'),
          expression?: string(name='Expression'),
          times?: int32(name='Times'),
          tag?: string(name='Tag'),
          threshold?: string(name='Threshold'),
          level?: int32(name='Level'),
        }
      ](name='Resource')
      }(name='Escalation'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      productCategory?: string(name='ProductCategory'),
      resource?: string(name='Resource'),
      startTime?: string(name='StartTime'),
      groupId?: string(name='GroupId'),
      lastModifyTime?: string(name='LastModifyTime'),
      dimensions?: string(name='Dimensions'),
      lastAlertTime?: string(name='LastAlertTime'),
      level?: int32(name='Level'),
      threshold?: string(name='Threshold'),
      statistics?: string(name='Statistics'),
      enable?: string(name='Enable'),
    }
  ](name='Resource')
  }(name='Resources'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeAlertingMetricRuleResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAlertingMetricRuleResourcesResponseBody(name='body'),
}

async function describeAlertingMetricRuleResourcesWithOptions(request: DescribeAlertingMetricRuleResourcesRequest, runtime: Util.RuntimeOptions): DescribeAlertingMetricRuleResourcesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeAlertingMetricRuleResources', '2019-01-01', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeAlertingMetricRuleResources(request: DescribeAlertingMetricRuleResourcesRequest): DescribeAlertingMetricRuleResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertingMetricRuleResourcesWithOptions(request, runtime);
}

model DescribeAlertLogCountRequest {
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  searchKey?: string(name='SearchKey'),
  namespace?: string(name='Namespace'),
  groupId?: string(name='GroupId'),
  product?: string(name='Product'),
  level?: string(name='Level'),
  sendStatus?: string(name='SendStatus'),
  contactGroup?: string(name='ContactGroup'),
  ruleName?: string(name='RuleName'),
  metricName?: string(name='MetricName'),
  lastMin?: string(name='LastMin'),
  groupBy?: string(name='GroupBy'),
}

model DescribeAlertLogCountResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  alertLogCount?: [ 
    {
      logs?: [ 
        {
          value?: string(name='Value'),
          name?: string(name='Name'),
        }
      ](name='Logs'),
      count?: int32(name='Count'),
    }
  ](name='AlertLogCount'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeAlertLogCountResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAlertLogCountResponseBody(name='body'),
}

async function describeAlertLogCountWithOptions(request: DescribeAlertLogCountRequest, runtime: Util.RuntimeOptions): DescribeAlertLogCountResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeAlertLogCount', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAlertLogCount(request: DescribeAlertLogCountRequest): DescribeAlertLogCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertLogCountWithOptions(request, runtime);
}

model DescribeAlertLogHistogramRequest {
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  searchKey?: string(name='SearchKey'),
  groupId?: string(name='GroupId'),
  product?: string(name='Product'),
  namespace?: string(name='Namespace'),
  level?: string(name='Level'),
  sendStatus?: string(name='SendStatus'),
  contactGroup?: string(name='ContactGroup'),
  ruleName?: string(name='RuleName'),
  metricName?: string(name='MetricName'),
  lastMin?: string(name='LastMin'),
  groupBy?: string(name='GroupBy'),
}

model DescribeAlertLogHistogramResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  alertLogHistogramList?: [ 
    {
      from?: long(name='From'),
      to?: long(name='To'),
      count?: int32(name='Count'),
    }
  ](name='AlertLogHistogramList'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeAlertLogHistogramResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAlertLogHistogramResponseBody(name='body'),
}

async function describeAlertLogHistogramWithOptions(request: DescribeAlertLogHistogramRequest, runtime: Util.RuntimeOptions): DescribeAlertLogHistogramResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeAlertLogHistogram', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAlertLogHistogram(request: DescribeAlertLogHistogramRequest): DescribeAlertLogHistogramResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertLogHistogramWithOptions(request, runtime);
}

model DescribeAlertLogListRequest {
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  searchKey?: string(name='SearchKey'),
  groupId?: string(name='GroupId'),
  namespace?: string(name='Namespace'),
  product?: string(name='Product'),
  level?: string(name='Level'),
  sendStatus?: string(name='SendStatus'),
  contactGroup?: string(name='ContactGroup'),
  ruleName?: string(name='RuleName'),
  metricName?: string(name='MetricName'),
  lastMin?: string(name='LastMin'),
  groupBy?: string(name='GroupBy'),
}

model DescribeAlertLogListResponseBody = {
  alertLogList?: [ 
    {
      metricName?: string(name='MetricName'),
      eventName?: string(name='EventName'),
      contactALIIWWList?: [ string ](name='ContactALIIWWList'),
      message?: string(name='Message'),
      levelChange?: string(name='LevelChange'),
      ruleId?: string(name='RuleId'),
      extendedInfo?: [ 
        {
          value?: string(name='Value'),
          name?: string(name='Name'),
        }
      ](name='ExtendedInfo'),
      dingdingWebhookList?: [ string ](name='DingdingWebhookList'),
      instanceName?: string(name='InstanceName'),
      contactMailList?: [ string ](name='ContactMailList'),
      dimensions?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Dimensions'),
      contactSMSList?: [ string ](name='ContactSMSList'),
      sendStatus?: string(name='SendStatus'),
      contactOnCallList?: [ string ](name='ContactOnCallList'),
      product?: string(name='Product'),
      contactGroups?: [ string ](name='ContactGroups'),
      namespace?: string(name='Namespace'),
      escalation?: {
        expression?: string(name='Expression'),
        times?: int32(name='Times'),
        level?: string(name='Level'),
      }(name='Escalation'),
      instanceId?: string(name='InstanceId'),
      contactDingList?: [ string ](name='ContactDingList'),
      ruleName?: string(name='RuleName'),
      webhookList?: [ string ](name='WebhookList'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      alertTime?: string(name='AlertTime'),
      level?: string(name='Level'),
    }
  ](name='AlertLogList'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeAlertLogListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAlertLogListResponseBody(name='body'),
}

async function describeAlertLogListWithOptions(request: DescribeAlertLogListRequest, runtime: Util.RuntimeOptions): DescribeAlertLogListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeAlertLogList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeAlertLogList(request: DescribeAlertLogListRequest): DescribeAlertLogListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertLogListWithOptions(request, runtime);
}

model DescribeContactGroupListRequest {
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
}

model DescribeContactGroupListResponseBody = {
  contactGroupList?: {
    contactGroup?: [ 
    {
      describe?: string(name='Describe'),
      updateTime?: long(name='UpdateTime'),
      contacts?: {
        contact?: [ string ](name='Contact')
      }(name='Contacts'),
      createTime?: long(name='CreateTime'),
      enabledWeeklyReport?: boolean(name='EnabledWeeklyReport'),
      name?: string(name='Name'),
      enableSubscribed?: boolean(name='EnableSubscribed'),
    }
  ](name='ContactGroup')
  }(name='ContactGroupList'),
  contactGroups?: {
    contactGroup?: [ string ](name='ContactGroup')
  }(name='ContactGroups'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeContactGroupListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeContactGroupListResponseBody(name='body'),
}

async function describeContactGroupListWithOptions(request: DescribeContactGroupListRequest, runtime: Util.RuntimeOptions): DescribeContactGroupListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeContactGroupList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeContactGroupList(request: DescribeContactGroupListRequest): DescribeContactGroupListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactGroupListWithOptions(request, runtime);
}

model DescribeContactListRequest {
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  contactName?: string(name='ContactName'),
  chanelType?: string(name='ChanelType'),
  chanelValue?: string(name='ChanelValue'),
}

model DescribeContactListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  contacts?: {
    contact?: [ 
    {
      updateTime?: long(name='UpdateTime'),
      channelsState?: {
        dingWebHook?: string(name='DingWebHook'),
        SMS?: string(name='SMS'),
        mail?: string(name='Mail'),
        aliIM?: string(name='AliIM'),
      }(name='ChannelsState'),
      createTime?: long(name='CreateTime'),
      lang?: string(name='Lang'),
      contactGroups?: {
        contactGroup?: [ string ](name='ContactGroup')
      }(name='ContactGroups'),
      channels?: {
        dingWebHook?: string(name='DingWebHook'),
        SMS?: string(name='SMS'),
        mail?: string(name='Mail'),
        aliIM?: string(name='AliIM'),
      }(name='Channels'),
      name?: string(name='Name'),
      desc?: string(name='Desc'),
    }
  ](name='Contact')
  }(name='Contacts'),
  total?: int32(name='Total'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeContactListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeContactListResponseBody(name='body'),
}

async function describeContactListWithOptions(request: DescribeContactListRequest, runtime: Util.RuntimeOptions): DescribeContactListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeContactList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeContactList(request: DescribeContactListRequest): DescribeContactListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactListWithOptions(request, runtime);
}

model DescribeContactListByContactGroupRequest {
  contactGroupName?: string(name='ContactGroupName'),
}

model DescribeContactListByContactGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  contacts?: {
    contact?: [ 
    {
      updateTime?: long(name='UpdateTime'),
      createTime?: long(name='CreateTime'),
      channels?: {
        dingWebHook?: string(name='DingWebHook'),
        SMS?: string(name='SMS'),
        mail?: string(name='Mail'),
        aliIM?: string(name='AliIM'),
      }(name='Channels'),
      name?: string(name='Name'),
      desc?: string(name='Desc'),
    }
  ](name='Contact')
  }(name='Contacts'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeContactListByContactGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeContactListByContactGroupResponseBody(name='body'),
}

async function describeContactListByContactGroupWithOptions(request: DescribeContactListByContactGroupRequest, runtime: Util.RuntimeOptions): DescribeContactListByContactGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeContactListByContactGroup', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeContactListByContactGroup(request: DescribeContactListByContactGroupRequest): DescribeContactListByContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactListByContactGroupWithOptions(request, runtime);
}

model DescribeCustomEventAttributeRequest {
  name?: string(name='Name'),
  eventId?: string(name='EventId'),
  groupId?: string(name='GroupId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeCustomEventAttributeResponseBody = {
  customEvents?: {
    customEvent?: [ 
    {
      time?: string(name='Time'),
      groupId?: string(name='GroupId'),
      name?: string(name='Name'),
      content?: string(name='Content'),
      id?: string(name='Id'),
    }
  ](name='CustomEvent')
  }(name='CustomEvents'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: string(name='Success'),
}

model DescribeCustomEventAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCustomEventAttributeResponseBody(name='body'),
}

async function describeCustomEventAttributeWithOptions(request: DescribeCustomEventAttributeRequest, runtime: Util.RuntimeOptions): DescribeCustomEventAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCustomEventAttribute', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCustomEventAttribute(request: DescribeCustomEventAttributeRequest): DescribeCustomEventAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomEventAttributeWithOptions(request, runtime);
}

model DescribeCustomEventCountRequest {
  name?: string(name='Name'),
  eventId?: string(name='EventId'),
  groupId?: string(name='GroupId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
}

model DescribeCustomEventCountResponseBody = {
  customEventCounts?: {
    customEventCount?: [ 
    {
      time?: long(name='Time'),
      num?: int32(name='Num'),
      name?: string(name='Name'),
    }
  ](name='CustomEventCount')
  }(name='CustomEventCounts'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeCustomEventCountResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCustomEventCountResponseBody(name='body'),
}

async function describeCustomEventCountWithOptions(request: DescribeCustomEventCountRequest, runtime: Util.RuntimeOptions): DescribeCustomEventCountResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCustomEventCount', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCustomEventCount(request: DescribeCustomEventCountRequest): DescribeCustomEventCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomEventCountWithOptions(request, runtime);
}

model DescribeCustomEventHistogramRequest {
  name?: string(name='Name'),
  level?: string(name='Level'),
  eventId?: string(name='EventId'),
  groupId?: string(name='GroupId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
}

model DescribeCustomEventHistogramResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  eventHistograms?: {
    eventHistogram?: [ 
    {
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
      count?: long(name='Count'),
    }
  ](name='EventHistogram')
  }(name='EventHistograms'),
  success?: string(name='Success'),
}

model DescribeCustomEventHistogramResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCustomEventHistogramResponseBody(name='body'),
}

async function describeCustomEventHistogramWithOptions(request: DescribeCustomEventHistogramRequest, runtime: Util.RuntimeOptions): DescribeCustomEventHistogramResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCustomEventHistogram', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCustomEventHistogram(request: DescribeCustomEventHistogramRequest): DescribeCustomEventHistogramResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomEventHistogramWithOptions(request, runtime);
}

model DescribeCustomMetricListRequest {
  groupId?: string(name='GroupId'),
  metricName?: string(name='MetricName'),
  dimension?: string(name='Dimension'),
  md5?: string(name='Md5'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
}

model DescribeCustomMetricListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  result?: string(name='Result'),
}

model DescribeCustomMetricListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCustomMetricListResponseBody(name='body'),
}

async function describeCustomMetricListWithOptions(request: DescribeCustomMetricListRequest, runtime: Util.RuntimeOptions): DescribeCustomMetricListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeCustomMetricList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeCustomMetricList(request: DescribeCustomMetricListRequest): DescribeCustomMetricListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomMetricListWithOptions(request, runtime);
}

model DescribeDynamicTagRuleListRequest {
  tagKey?: string(name='TagKey'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
}

model DescribeDynamicTagRuleListResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: string(name='PageSize'),
  pageNumber?: string(name='PageNumber'),
  total?: int32(name='Total'),
  tagGroupList?: {
    tagGroup?: [ 
    {
      status?: string(name='Status'),
      matchExpress?: {
        matchExpress?: [ 
        {
          tagValueMatchFunction?: string(name='TagValueMatchFunction'),
          tagValue?: string(name='TagValue'),
        }
      ](name='MatchExpress')
      }(name='MatchExpress'),
      templateIdList?: {
        templateIdList?: [ string ](name='TemplateIdList')
      }(name='TemplateIdList'),
      dynamicTagRuleId?: string(name='DynamicTagRuleId'),
      matchExpressFilterRelation?: string(name='MatchExpressFilterRelation'),
      regionId?: string(name='RegionId'),
      tagKey?: string(name='TagKey'),
    }
  ](name='TagGroup')
  }(name='TagGroupList'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeDynamicTagRuleListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDynamicTagRuleListResponseBody(name='body'),
}

async function describeDynamicTagRuleListWithOptions(request: DescribeDynamicTagRuleListRequest, runtime: Util.RuntimeOptions): DescribeDynamicTagRuleListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeDynamicTagRuleList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeDynamicTagRuleList(request: DescribeDynamicTagRuleListRequest): DescribeDynamicTagRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDynamicTagRuleListWithOptions(request, runtime);
}

model DescribeEventRuleAttributeRequest {
  ruleName?: string(name='RuleName'),
}

model DescribeEventRuleAttributeResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
  result?: {
    eventType?: string(name='EventType'),
    groupId?: string(name='GroupId'),
    description?: string(name='Description'),
    state?: string(name='State'),
    name?: string(name='Name'),
    eventPattern?: {
      statusList?: {
        statusList?: [ string ](name='StatusList')
      }(name='StatusList'),
      product?: string(name='Product'),
      levelList?: {
        levelList?: [ string ](name='LevelList')
      }(name='LevelList'),
      nameList?: {
        nameList?: [ string ](name='NameList')
      }(name='NameList'),
    }(name='EventPattern'),
  }(name='Result'),
}

model DescribeEventRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEventRuleAttributeResponseBody(name='body'),
}

async function describeEventRuleAttributeWithOptions(request: DescribeEventRuleAttributeRequest, runtime: Util.RuntimeOptions): DescribeEventRuleAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeEventRuleAttribute', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeEventRuleAttribute(request: DescribeEventRuleAttributeRequest): DescribeEventRuleAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventRuleAttributeWithOptions(request, runtime);
}

model DescribeEventRuleListRequest {
  namePrefix?: string(name='NamePrefix'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  groupId?: string(name='GroupId'),
}

model DescribeEventRuleListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
  eventRules?: {
    eventRule?: [ 
    {
      eventType?: string(name='EventType'),
      description?: string(name='Description'),
      groupId?: string(name='GroupId'),
      state?: string(name='State'),
      name?: string(name='Name'),
      eventPattern?: {
        eventPattern?: [ 
        {
          eventTypeList?: {
            eventTypeList?: [ string ](name='EventTypeList')
          }(name='EventTypeList'),
          product?: string(name='Product'),
          levelList?: {
            levelList?: [ string ](name='LevelList')
          }(name='LevelList'),
          nameList?: {
            nameList?: [ string ](name='NameList')
          }(name='NameList'),
        }
      ](name='EventPattern')
      }(name='EventPattern'),
    }
  ](name='EventRule')
  }(name='EventRules'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeEventRuleListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEventRuleListResponseBody(name='body'),
}

async function describeEventRuleListWithOptions(request: DescribeEventRuleListRequest, runtime: Util.RuntimeOptions): DescribeEventRuleListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeEventRuleList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeEventRuleList(request: DescribeEventRuleListRequest): DescribeEventRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventRuleListWithOptions(request, runtime);
}

model DescribeEventRuleTargetListRequest {
  ruleName?: string(name='RuleName'),
}

model DescribeEventRuleTargetListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  contactParameters?: {
    contactParameter?: [ 
    {
      contactGroupName?: string(name='ContactGroupName'),
      level?: string(name='Level'),
      id?: string(name='Id'),
    }
  ](name='ContactParameter')
  }(name='ContactParameters'),
  slsParameters?: {
    slsParameter?: [ 
    {
      logStore?: string(name='LogStore'),
      region?: string(name='Region'),
      project?: string(name='Project'),
      arn?: string(name='Arn'),
      id?: string(name='Id'),
    }
  ](name='SlsParameter')
  }(name='SlsParameters'),
  webhookParameters?: {
    webhookParameter?: [ 
    {
      protocol?: string(name='Protocol'),
      url?: string(name='Url'),
      method?: string(name='Method'),
      id?: string(name='Id'),
    }
  ](name='WebhookParameter')
  }(name='WebhookParameters'),
  fcParameters?: {
    FCParameter?: [ 
    {
      functionName?: string(name='FunctionName'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
      arn?: string(name='Arn'),
      id?: string(name='Id'),
    }
  ](name='FCParameter')
  }(name='FcParameters'),
  code?: string(name='Code'),
  mnsParameters?: {
    mnsParameter?: [ 
    {
      region?: string(name='Region'),
      queue?: string(name='Queue'),
      arn?: string(name='Arn'),
      id?: string(name='Id'),
    }
  ](name='MnsParameter')
  }(name='MnsParameters'),
}

model DescribeEventRuleTargetListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEventRuleTargetListResponseBody(name='body'),
}

async function describeEventRuleTargetListWithOptions(request: DescribeEventRuleTargetListRequest, runtime: Util.RuntimeOptions): DescribeEventRuleTargetListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeEventRuleTargetList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeEventRuleTargetList(request: DescribeEventRuleTargetListRequest): DescribeEventRuleTargetListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventRuleTargetListWithOptions(request, runtime);
}

model DescribeExporterOutputListRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeExporterOutputListResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  datapoints?: {
    datapoint?: [ 
    {
      createTime?: long(name='CreateTime'),
      configJson?: {
        as?: string(name='as'),
        ak?: string(name='ak'),
        endpoint?: string(name='endpoint'),
        project?: string(name='project'),
        logstore?: string(name='logstore'),
      }(name='ConfigJson'),
      destName?: string(name='DestName'),
      destType?: string(name='DestType'),
    }
  ](name='Datapoint')
  }(name='Datapoints'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeExporterOutputListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExporterOutputListResponseBody(name='body'),
}

async function describeExporterOutputListWithOptions(request: DescribeExporterOutputListRequest, runtime: Util.RuntimeOptions): DescribeExporterOutputListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeExporterOutputList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeExporterOutputList(request: DescribeExporterOutputListRequest): DescribeExporterOutputListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExporterOutputListWithOptions(request, runtime);
}

model DescribeExporterRuleListRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeExporterRuleListResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  datapoints?: {
    datapoint?: [ 
    {
      metricName?: string(name='MetricName'),
      describe?: string(name='Describe'),
      targetWindows?: string(name='TargetWindows'),
      createTime?: long(name='CreateTime'),
      enabled?: boolean(name='Enabled'),
      dstName?: {
        dstName?: [ string ](name='DstName')
      }(name='DstName'),
      dimension?: string(name='Dimension'),
      namespace?: string(name='Namespace'),
      ruleName?: string(name='RuleName'),
    }
  ](name='Datapoint')
  }(name='Datapoints'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeExporterRuleListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExporterRuleListResponseBody(name='body'),
}

async function describeExporterRuleListWithOptions(request: DescribeExporterRuleListRequest, runtime: Util.RuntimeOptions): DescribeExporterRuleListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeExporterRuleList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeExporterRuleList(request: DescribeExporterRuleListRequest): DescribeExporterRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExporterRuleListWithOptions(request, runtime);
}

model DescribeGroupMonitoringAgentProcessRequest {
  groupId?: string(name='GroupId'),
  processName?: string(name='ProcessName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeGroupMonitoringAgentProcessResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: string(name='PageSize'),
  pageNumber?: string(name='PageNumber'),
  total?: string(name='Total'),
  processes?: {
    process?: [ 
    {
      processName?: string(name='ProcessName'),
      matchExpress?: {
        matchExpress?: [ 
        {
          value?: string(name='Value'),
          name?: string(name='Name'),
          function?: string(name='Function'),
        }
      ](name='MatchExpress')
      }(name='MatchExpress'),
      groupId?: string(name='GroupId'),
      alertConfig?: {
        alertConfig?: [ 
        {
          comparisonOperator?: string(name='ComparisonOperator'),
          silenceTime?: string(name='SilenceTime'),
          webhook?: string(name='Webhook'),
          times?: string(name='Times'),
          escalationsLevel?: string(name='EscalationsLevel'),
          noEffectiveInterval?: string(name='NoEffectiveInterval'),
          effectiveInterval?: string(name='EffectiveInterval'),
          threshold?: string(name='Threshold'),
          statistics?: string(name='Statistics'),
        }
      ](name='AlertConfig')
      }(name='AlertConfig'),
      matchExpressFilterRelation?: string(name='MatchExpressFilterRelation'),
      id?: string(name='Id'),
    }
  ](name='Process')
  }(name='Processes'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeGroupMonitoringAgentProcessResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGroupMonitoringAgentProcessResponseBody(name='body'),
}

async function describeGroupMonitoringAgentProcessWithOptions(request: DescribeGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): DescribeGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeGroupMonitoringAgentProcess', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeGroupMonitoringAgentProcess(request: DescribeGroupMonitoringAgentProcessRequest): DescribeGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model DescribeHostAvailabilityListRequest {
  id?: long(name='Id'),
  taskName?: string(name='TaskName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  groupId?: long(name='GroupId'),
}

model DescribeHostAvailabilityListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
  taskList?: {
    nodeTaskConfig?: [ 
    {
      taskType?: string(name='TaskType'),
      groupName?: string(name='GroupName'),
      groupId?: long(name='GroupId'),
      taskOption?: {
        httpMethod?: string(name='HttpMethod'),
        httpURI?: string(name='HttpURI'),
        telnetOrPingHost?: string(name='TelnetOrPingHost'),
        httpResponseCharset?: string(name='HttpResponseCharset'),
        httpPostContent?: string(name='HttpPostContent'),
        httpNegative?: boolean(name='HttpNegative'),
        httpKeyword?: string(name='HttpKeyword'),
      }(name='TaskOption'),
      taskName?: string(name='TaskName'),
      disabled?: boolean(name='Disabled'),
      alertConfig?: {
        silenceTime?: int32(name='SilenceTime'),
        endTime?: int32(name='EndTime'),
        startTime?: int32(name='StartTime'),
        notifyType?: int32(name='NotifyType'),
        escalationList?: {
          escalationList?: [ 
          {
            value?: string(name='Value'),
            metricName?: string(name='MetricName'),
            times?: string(name='Times'),
            operator?: string(name='Operator'),
            aggregate?: string(name='Aggregate'),
          }
        ](name='escalationList')
        }(name='EscalationList'),
        webHook?: string(name='WebHook'),
      }(name='AlertConfig'),
      taskScope?: string(name='TaskScope'),
      instances?: {
        instance?: [ string ](name='Instance')
      }(name='Instances'),
      id?: long(name='Id'),
    }
  ](name='NodeTaskConfig')
  }(name='TaskList'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeHostAvailabilityListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHostAvailabilityListResponseBody(name='body'),
}

async function describeHostAvailabilityListWithOptions(request: DescribeHostAvailabilityListRequest, runtime: Util.RuntimeOptions): DescribeHostAvailabilityListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeHostAvailabilityList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeHostAvailabilityList(request: DescribeHostAvailabilityListRequest): DescribeHostAvailabilityListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHostAvailabilityListWithOptions(request, runtime);
}

model DescribeLogMonitorAttributeRequest {
  metricName?: string(name='MetricName'),
}

model DescribeLogMonitorAttributeResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  logMonitor?: {
    valueFilterRelation?: string(name='ValueFilterRelation'),
    metricName?: string(name='MetricName'),
    valueFilter?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
        operator?: string(name='Operator'),
      }
    ](name='ValueFilter'),
    slsRegionId?: string(name='SlsRegionId'),
    slsLogstore?: string(name='SlsLogstore'),
    aggregates?: [ 
      {
        max?: string(name='Max'),
        fieldName?: string(name='FieldName'),
        min?: string(name='Min'),
        function?: string(name='Function'),
        alias?: string(name='Alias'),
      }
    ](name='Aggregates'),
    tumblingwindows?: [ string ](name='Tumblingwindows'),
    groupId?: long(name='GroupId'),
    groupbys?: [ string ](name='Groupbys'),
    logId?: long(name='LogId'),
    metricExpress?: string(name='MetricExpress'),
    gmtCreate?: long(name='GmtCreate'),
    slsProject?: string(name='SlsProject'),
  }(name='LogMonitor'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeLogMonitorAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLogMonitorAttributeResponseBody(name='body'),
}

async function describeLogMonitorAttributeWithOptions(request: DescribeLogMonitorAttributeRequest, runtime: Util.RuntimeOptions): DescribeLogMonitorAttributeResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeLogMonitorAttribute', '2019-01-01', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeLogMonitorAttribute(request: DescribeLogMonitorAttributeRequest): DescribeLogMonitorAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogMonitorAttributeWithOptions(request, runtime);
}

model DescribeLogMonitorListRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  searchValue?: string(name='SearchValue'),
  groupId?: long(name='GroupId'),
}

model DescribeLogMonitorListResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: long(name='Total'),
  logMonitorList?: [ 
    {
      valueFilterRelation?: string(name='ValueFilterRelation'),
      slsLogstore?: string(name='SlsLogstore'),
      metricName?: string(name='MetricName'),
      valueFilter?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
          operator?: string(name='Operator'),
        }
      ](name='ValueFilter'),
      groupId?: long(name='GroupId'),
      logId?: long(name='LogId'),
      slsRegionId?: string(name='SlsRegionId'),
      gmtCreate?: long(name='GmtCreate'),
      slsProject?: string(name='SlsProject'),
    }
  ](name='LogMonitorList'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeLogMonitorListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLogMonitorListResponseBody(name='body'),
}

async function describeLogMonitorListWithOptions(request: DescribeLogMonitorListRequest, runtime: Util.RuntimeOptions): DescribeLogMonitorListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeLogMonitorList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeLogMonitorList(request: DescribeLogMonitorListRequest): DescribeLogMonitorListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogMonitorListWithOptions(request, runtime);
}

model DescribeMetricDataRequest {
  namespace?: string(name='Namespace'),
  metricName?: string(name='MetricName'),
  period?: string(name='Period'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  dimensions?: string(name='Dimensions'),
  express?: string(name='Express'),
  length?: string(name='Length'),
}

model DescribeMetricDataResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  period?: string(name='Period'),
  datapoints?: string(name='Datapoints'),
  code?: string(name='Code'),
}

model DescribeMetricDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMetricDataResponseBody(name='body'),
}

async function describeMetricDataWithOptions(request: DescribeMetricDataRequest, runtime: Util.RuntimeOptions): DescribeMetricDataResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMetricData', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMetricData(request: DescribeMetricDataRequest): DescribeMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricDataWithOptions(request, runtime);
}

model DescribeMetricLastRequest {
  namespace?: string(name='Namespace'),
  metricName?: string(name='MetricName'),
  period?: string(name='Period'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  dimensions?: string(name='Dimensions'),
  nextToken?: string(name='NextToken'),
  length?: string(name='Length'),
  express?: string(name='Express'),
}

model DescribeMetricLastResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  period?: string(name='Period'),
  datapoints?: string(name='Datapoints'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMetricLastResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMetricLastResponseBody(name='body'),
}

async function describeMetricLastWithOptions(request: DescribeMetricLastRequest, runtime: Util.RuntimeOptions): DescribeMetricLastResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMetricLast', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMetricLast(request: DescribeMetricLastRequest): DescribeMetricLastResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricLastWithOptions(request, runtime);
}

model DescribeMetricListRequest {
  namespace?: string(name='Namespace'),
  metricName?: string(name='MetricName'),
  period?: string(name='Period'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  dimensions?: string(name='Dimensions'),
  nextToken?: string(name='NextToken'),
  length?: string(name='Length'),
  express?: string(name='Express'),
}

model DescribeMetricListResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  period?: string(name='Period'),
  datapoints?: string(name='Datapoints'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMetricListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMetricListResponseBody(name='body'),
}

async function describeMetricListWithOptions(request: DescribeMetricListRequest, runtime: Util.RuntimeOptions): DescribeMetricListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMetricList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMetricList(request: DescribeMetricListRequest): DescribeMetricListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricListWithOptions(request, runtime);
}

model DescribeMetricMetaListRequest {
  namespace?: string(name='Namespace'),
  labels?: string(name='Labels'),
  metricName?: string(name='MetricName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeMetricMetaListResponseBody = {
  totalCount?: string(name='TotalCount'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resources?: {
    resource?: [ 
    {
      metricName?: string(name='MetricName'),
      description?: string(name='Description'),
      labels?: string(name='Labels'),
      unit?: string(name='Unit'),
      dimensions?: string(name='Dimensions'),
      namespace?: string(name='Namespace'),
      periods?: string(name='Periods'),
      statistics?: string(name='Statistics'),
    }
  ](name='Resource')
  }(name='Resources'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMetricMetaListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMetricMetaListResponseBody(name='body'),
}

async function describeMetricMetaListWithOptions(request: DescribeMetricMetaListRequest, runtime: Util.RuntimeOptions): DescribeMetricMetaListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMetricMetaList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMetricMetaList(request: DescribeMetricMetaListRequest): DescribeMetricMetaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricMetaListWithOptions(request, runtime);
}

model DescribeMetricRuleCountRequest {
  namespace?: string(name='Namespace'),
  metricName?: string(name='MetricName'),
}

model DescribeMetricRuleCountResponseBody = {
  metricRuleCount?: {
    ok?: int32(name='Ok'),
    nodata?: int32(name='Nodata'),
    disable?: int32(name='Disable'),
    total?: int32(name='Total'),
    alarm?: int32(name='Alarm'),
  }(name='MetricRuleCount'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMetricRuleCountResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMetricRuleCountResponseBody(name='body'),
}

async function describeMetricRuleCountWithOptions(request: DescribeMetricRuleCountRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleCountResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeMetricRuleCount', '2019-01-01', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeMetricRuleCount(request: DescribeMetricRuleCountRequest): DescribeMetricRuleCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleCountWithOptions(request, runtime);
}

model DescribeMetricRuleListRequest {
  metricName?: string(name='MetricName'),
  enableState?: boolean(name='EnableState'),
  namespace?: string(name='Namespace'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  alertState?: string(name='AlertState'),
  dimensions?: string(name='Dimensions'),
  ruleName?: string(name='RuleName'),
  groupId?: string(name='GroupId'),
  ruleIds?: string(name='RuleIds'),
}

model DescribeMetricRuleListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  total?: string(name='Total'),
  alarms?: {
    alarm?: [ 
    {
      silenceTime?: int32(name='SilenceTime'),
      metricName?: string(name='MetricName'),
      webhook?: string(name='Webhook'),
      escalations?: {
        critical?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          preCondition?: string(name='PreCondition'),
          times?: int32(name='Times'),
          threshold?: string(name='Threshold'),
          statistics?: string(name='Statistics'),
        }(name='Critical'),
        info?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          preCondition?: string(name='PreCondition'),
          times?: int32(name='Times'),
          threshold?: string(name='Threshold'),
          statistics?: string(name='Statistics'),
        }(name='Info'),
        warn?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          preCondition?: string(name='PreCondition'),
          times?: int32(name='Times'),
          threshold?: string(name='Threshold'),
          statistics?: string(name='Statistics'),
        }(name='Warn'),
      }(name='Escalations'),
      contactGroups?: string(name='ContactGroups'),
      sourceType?: string(name='SourceType'),
      namespace?: string(name='Namespace'),
      effectiveInterval?: string(name='EffectiveInterval'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      mailSubject?: string(name='MailSubject'),
      ruleName?: string(name='RuleName'),
      alertState?: string(name='AlertState'),
      ruleId?: string(name='RuleId'),
      period?: string(name='Period'),
      groupName?: string(name='GroupName'),
      groupId?: string(name='GroupId'),
      dimensions?: string(name='Dimensions'),
      enableState?: boolean(name='EnableState'),
      resources?: string(name='Resources'),
    }
  ](name='Alarm')
  }(name='Alarms'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMetricRuleListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMetricRuleListResponseBody(name='body'),
}

async function describeMetricRuleListWithOptions(request: DescribeMetricRuleListRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMetricRuleList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMetricRuleList(request: DescribeMetricRuleListRequest): DescribeMetricRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleListWithOptions(request, runtime);
}

model DescribeMetricRuleTargetsRequest {
  ruleId?: string(name='RuleId'),
}

model DescribeMetricRuleTargetsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  targets?: {
    target?: [ 
    {
      id?: string(name='Id'),
      arn?: string(name='Arn'),
      level?: string(name='Level'),
    }
  ](name='Target')
  }(name='Targets'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMetricRuleTargetsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMetricRuleTargetsResponseBody(name='body'),
}

async function describeMetricRuleTargetsWithOptions(request: DescribeMetricRuleTargetsRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleTargetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMetricRuleTargets', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMetricRuleTargets(request: DescribeMetricRuleTargetsRequest): DescribeMetricRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleTargetsWithOptions(request, runtime);
}

model DescribeMetricRuleTemplateAttributeRequest {
  name?: string(name='Name'),
  templateId?: string(name='TemplateId'),
}

model DescribeMetricRuleTemplateAttributeResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resource?: {
    description?: string(name='Description'),
    alertTemplates?: {
      alertTemplate?: [ 
      {
        metricName?: string(name='MetricName'),
        selector?: string(name='Selector'),
        webhook?: string(name='Webhook'),
        escalations?: {
          critical?: {
            comparisonOperator?: string(name='ComparisonOperator'),
            times?: int32(name='Times'),
            threshold?: string(name='Threshold'),
            statistics?: string(name='Statistics'),
          }(name='Critical'),
          info?: {
            comparisonOperator?: string(name='ComparisonOperator'),
            times?: int32(name='Times'),
            threshold?: string(name='Threshold'),
            statistics?: string(name='Statistics'),
          }(name='Info'),
          warn?: {
            comparisonOperator?: string(name='ComparisonOperator'),
            times?: int32(name='Times'),
            threshold?: string(name='Threshold'),
            statistics?: string(name='Statistics'),
          }(name='Warn'),
        }(name='Escalations'),
        namespace?: string(name='Namespace'),
        category?: string(name='Category'),
        ruleName?: string(name='RuleName'),
      }
    ](name='AlertTemplate')
    }(name='AlertTemplates'),
    name?: string(name='Name'),
    restVersion?: string(name='RestVersion'),
    templateId?: string(name='TemplateId'),
  }(name='Resource'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMetricRuleTemplateAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMetricRuleTemplateAttributeResponseBody(name='body'),
}

async function describeMetricRuleTemplateAttributeWithOptions(request: DescribeMetricRuleTemplateAttributeRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleTemplateAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMetricRuleTemplateAttribute', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMetricRuleTemplateAttribute(request: DescribeMetricRuleTemplateAttributeRequest): DescribeMetricRuleTemplateAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleTemplateAttributeWithOptions(request, runtime);
}

model DescribeMetricRuleTemplateListRequest {
  name?: string(name='Name'),
  keyword?: string(name='Keyword'),
  templateId?: long(name='TemplateId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  history?: boolean(name='History'),
}

model DescribeMetricRuleTemplateListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
  templates?: {
    template?: [ 
    {
      applyHistories?: {
        applyHistory?: [ 
        {
          groupId?: long(name='GroupId'),
          groupName?: string(name='GroupName'),
          applyTime?: long(name='ApplyTime'),
        }
      ](name='ApplyHistory')
      }(name='ApplyHistories'),
      description?: string(name='Description'),
      gmtCreate?: long(name='GmtCreate'),
      name?: string(name='Name'),
      restVersion?: long(name='RestVersion'),
      gmtModified?: long(name='GmtModified'),
      templateId?: long(name='TemplateId'),
    }
  ](name='Template')
  }(name='Templates'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMetricRuleTemplateListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMetricRuleTemplateListResponseBody(name='body'),
}

async function describeMetricRuleTemplateListWithOptions(request: DescribeMetricRuleTemplateListRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleTemplateListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMetricRuleTemplateList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMetricRuleTemplateList(request: DescribeMetricRuleTemplateListRequest): DescribeMetricRuleTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleTemplateListWithOptions(request, runtime);
}

model DescribeMetricTopRequest {
  period?: string(name='Period'),
  namespace?: string(name='Namespace'),
  metricName?: string(name='MetricName'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  dimensions?: string(name='Dimensions'),
  orderby?: string(name='Orderby'),
  orderDesc?: string(name='OrderDesc'),
  length?: string(name='Length'),
  express?: string(name='Express'),
}

model DescribeMetricTopResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  period?: string(name='Period'),
  datapoints?: string(name='Datapoints'),
  code?: string(name='Code'),
}

model DescribeMetricTopResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMetricTopResponseBody(name='body'),
}

async function describeMetricTopWithOptions(request: DescribeMetricTopRequest, runtime: Util.RuntimeOptions): DescribeMetricTopResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMetricTop', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMetricTop(request: DescribeMetricTopRequest): DescribeMetricTopResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricTopWithOptions(request, runtime);
}

model DescribeMonitorGroupCategoriesRequest {
  groupId?: long(name='GroupId'),
}

model DescribeMonitorGroupCategoriesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  monitorGroupCategories?: {
    groupId?: long(name='GroupId'),
    monitorGroupCategory?: {
      categoryItem?: [ 
      {
        category?: string(name='Category'),
        count?: int32(name='Count'),
      }
    ](name='CategoryItem')
    }(name='MonitorGroupCategory'),
  }(name='MonitorGroupCategories'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMonitorGroupCategoriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMonitorGroupCategoriesResponseBody(name='body'),
}

async function describeMonitorGroupCategoriesWithOptions(request: DescribeMonitorGroupCategoriesRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupCategoriesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMonitorGroupCategories', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMonitorGroupCategories(request: DescribeMonitorGroupCategoriesRequest): DescribeMonitorGroupCategoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupCategoriesWithOptions(request, runtime);
}

model DescribeMonitorGroupDynamicRulesRequest {
  groupId?: long(name='GroupId'),
}

model DescribeMonitorGroupDynamicRulesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resource?: {
    resource?: [ 
    {
      filterRelation?: string(name='FilterRelation'),
      filters?: {
        filter?: [ 
        {
          value?: string(name='Value'),
          function?: string(name='Function'),
          name?: string(name='Name'),
        }
      ](name='Filter')
      }(name='Filters'),
      category?: string(name='Category'),
    }
  ](name='Resource')
  }(name='Resource'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMonitorGroupDynamicRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMonitorGroupDynamicRulesResponseBody(name='body'),
}

async function describeMonitorGroupDynamicRulesWithOptions(request: DescribeMonitorGroupDynamicRulesRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupDynamicRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMonitorGroupDynamicRules', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMonitorGroupDynamicRules(request: DescribeMonitorGroupDynamicRulesRequest): DescribeMonitorGroupDynamicRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupDynamicRulesWithOptions(request, runtime);
}

model DescribeMonitorGroupInstanceAttributeRequest {
  groupId?: long(name='GroupId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  total?: boolean(name='Total'),
  category?: string(name='Category'),
  keyword?: string(name='Keyword'),
  instanceIds?: string(name='InstanceIds'),
}

model DescribeMonitorGroupInstanceAttributeResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  resources?: {
    resource?: [ 
    {
      instanceName?: string(name='InstanceName'),
      region?: {
        availabilityZone?: string(name='AvailabilityZone'),
        regionId?: string(name='RegionId'),
      }(name='Region'),
      vpc?: {
        vswitchInstanceId?: string(name='VswitchInstanceId'),
        vpcInstanceId?: string(name='VpcInstanceId'),
      }(name='Vpc'),
      dimension?: string(name='Dimension'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      category?: string(name='Category'),
      instanceId?: string(name='InstanceId'),
      networkType?: string(name='NetworkType'),
      desc?: string(name='Desc'),
    }
  ](name='Resource')
  }(name='Resources'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMonitorGroupInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMonitorGroupInstanceAttributeResponseBody(name='body'),
}

async function describeMonitorGroupInstanceAttributeWithOptions(request: DescribeMonitorGroupInstanceAttributeRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupInstanceAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMonitorGroupInstanceAttribute', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMonitorGroupInstanceAttribute(request: DescribeMonitorGroupInstanceAttributeRequest): DescribeMonitorGroupInstanceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupInstanceAttributeWithOptions(request, runtime);
}

model DescribeMonitorGroupInstancesRequest {
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  groupId?: long(name='GroupId'),
  category?: string(name='Category'),
  keyword?: string(name='Keyword'),
  instanceIds?: string(name='InstanceIds'),
}

model DescribeMonitorGroupInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  resources?: {
    resource?: [ 
    {
      instanceName?: string(name='InstanceName'),
      category?: string(name='Category'),
      instanceId?: string(name='InstanceId'),
      id?: long(name='Id'),
      regionId?: string(name='RegionId'),
    }
  ](name='Resource')
  }(name='Resources'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMonitorGroupInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMonitorGroupInstancesResponseBody(name='body'),
}

async function describeMonitorGroupInstancesWithOptions(request: DescribeMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupInstancesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMonitorGroupInstances', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMonitorGroupInstances(request: DescribeMonitorGroupInstancesRequest): DescribeMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupInstancesWithOptions(request, runtime);
}

model DescribeMonitorGroupNotifyPolicyListRequest {
  policyType?: string(name='PolicyType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  groupId?: string(name='GroupId'),
}

model DescribeMonitorGroupNotifyPolicyListResponseBody = {
  notifyPolicyList?: {
    notifyPolicy?: [ 
    {
      endTime?: long(name='EndTime'),
      type?: string(name='Type'),
      startTime?: long(name='StartTime'),
      groupId?: string(name='GroupId'),
      id?: string(name='Id'),
    }
  ](name='NotifyPolicy')
  }(name='NotifyPolicyList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
  code?: string(name='Code'),
  success?: string(name='Success'),
}

model DescribeMonitorGroupNotifyPolicyListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMonitorGroupNotifyPolicyListResponseBody(name='body'),
}

async function describeMonitorGroupNotifyPolicyListWithOptions(request: DescribeMonitorGroupNotifyPolicyListRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupNotifyPolicyListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMonitorGroupNotifyPolicyList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMonitorGroupNotifyPolicyList(request: DescribeMonitorGroupNotifyPolicyListRequest): DescribeMonitorGroupNotifyPolicyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupNotifyPolicyListWithOptions(request, runtime);
}

model DescribeMonitorGroupsRequest {
  selectContactGroups?: boolean(name='SelectContactGroups'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  keyword?: string(name='Keyword'),
  instanceId?: string(name='InstanceId'),
  groupName?: string(name='GroupName'),
  includeTemplateHistory?: boolean(name='IncludeTemplateHistory'),
  type?: string(name='Type'),
  dynamicTagRuleId?: string(name='DynamicTagRuleId'),
  groupId?: string(name='GroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model DescribeMonitorGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  total?: int32(name='Total'),
  resources?: {
    resource?: [ 
    {
      type?: string(name='Type'),
      bindUrl?: string(name='BindUrl'),
      serviceId?: string(name='ServiceId'),
      contactGroups?: {
        contactGroup?: [ 
        {
          name?: string(name='Name'),
        }
      ](name='ContactGroup')
      }(name='ContactGroups'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      groupFounderTagKey?: string(name='GroupFounderTagKey'),
      templateIds?: {
        templateId?: [ string ](name='TemplateId')
      }(name='TemplateIds'),
      gmtModified?: long(name='GmtModified'),
      groupFounderTagValue?: string(name='GroupFounderTagValue'),
      groupName?: string(name='GroupName'),
      groupId?: long(name='GroupId'),
      dynamicTagRuleId?: string(name='DynamicTagRuleId'),
      gmtCreate?: long(name='GmtCreate'),
    }
  ](name='Resource')
  }(name='Resources'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMonitorGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMonitorGroupsResponseBody(name='body'),
}

async function describeMonitorGroupsWithOptions(request: DescribeMonitorGroupsRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMonitorGroups', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMonitorGroups(request: DescribeMonitorGroupsRequest): DescribeMonitorGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupsWithOptions(request, runtime);
}

model DescribeMonitoringAgentAccessKeyResponseBody = {
  secretKey?: string(name='SecretKey'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  accessKey?: string(name='AccessKey'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMonitoringAgentAccessKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMonitoringAgentAccessKeyResponseBody(name='body'),
}

async function describeMonitoringAgentAccessKeyWithOptions(runtime: Util.RuntimeOptions): DescribeMonitoringAgentAccessKeyResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('DescribeMonitoringAgentAccessKey', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMonitoringAgentAccessKey(): DescribeMonitoringAgentAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentAccessKeyWithOptions(runtime);
}

model DescribeMonitoringAgentConfigResponseBody = {
  enableActiveAlert?: string(name='EnableActiveAlert'),
  autoInstall?: boolean(name='AutoInstall'),
  enableInstallAgentNewECS?: boolean(name='EnableInstallAgentNewECS'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMonitoringAgentConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMonitoringAgentConfigResponseBody(name='body'),
}

async function describeMonitoringAgentConfigWithOptions(runtime: Util.RuntimeOptions): DescribeMonitoringAgentConfigResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('DescribeMonitoringAgentConfig', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMonitoringAgentConfig(): DescribeMonitoringAgentConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentConfigWithOptions(runtime);
}

model DescribeMonitoringAgentHostsRequest {
  keyWord?: string(name='KeyWord'),
  hostName?: string(name='HostName'),
  instanceIds?: string(name='InstanceIds'),
  serialNumbers?: string(name='SerialNumbers'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  instanceRegionId?: string(name='InstanceRegionId'),
  aliyunHost?: boolean(name='AliyunHost'),
  status?: string(name='Status'),
}

model DescribeMonitoringAgentHostsResponseBody = {
  hosts?: {
    host?: [ 
    {
      serialNumber?: string(name='SerialNumber'),
      natIp?: string(name='NatIp'),
      aliUid?: long(name='AliUid'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      networkType?: string(name='NetworkType'),
      isAliyunHost?: boolean(name='isAliyunHost'),
      eipAddress?: string(name='EipAddress'),
      agentVersion?: string(name='AgentVersion'),
      eipId?: string(name='EipId'),
      ipGroup?: string(name='IpGroup'),
      region?: string(name='Region'),
      instanceTypeFamily?: string(name='InstanceTypeFamily'),
      operatingSystem?: string(name='OperatingSystem'),
    }
  ](name='Host')
  }(name='Hosts'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  pageTotal?: int32(name='PageTotal'),
  total?: int32(name='Total'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMonitoringAgentHostsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMonitoringAgentHostsResponseBody(name='body'),
}

async function describeMonitoringAgentHostsWithOptions(request: DescribeMonitoringAgentHostsRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentHostsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMonitoringAgentHosts', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMonitoringAgentHosts(request: DescribeMonitoringAgentHostsRequest): DescribeMonitoringAgentHostsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentHostsWithOptions(request, runtime);
}

model DescribeMonitoringAgentProcessesRequest {
  instanceId?: string(name='InstanceId'),
}

model DescribeMonitoringAgentProcessesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  nodeProcesses?: {
    nodeProcess?: [ 
    {
      processName?: string(name='ProcessName'),
      processId?: long(name='ProcessId'),
      groupId?: string(name='GroupId'),
      command?: string(name='Command'),
      processUser?: string(name='ProcessUser'),
      instanceId?: string(name='InstanceId'),
    }
  ](name='NodeProcess')
  }(name='NodeProcesses'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMonitoringAgentProcessesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMonitoringAgentProcessesResponseBody(name='body'),
}

async function describeMonitoringAgentProcessesWithOptions(request: DescribeMonitoringAgentProcessesRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentProcessesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMonitoringAgentProcesses', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMonitoringAgentProcesses(request: DescribeMonitoringAgentProcessesRequest): DescribeMonitoringAgentProcessesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentProcessesWithOptions(request, runtime);
}

model DescribeMonitoringAgentStatusesRequest {
  instanceIds?: string(name='InstanceIds'),
}

model DescribeMonitoringAgentStatusesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  nodeStatusList?: {
    nodeStatus?: [ 
    {
      status?: string(name='Status'),
      autoInstall?: boolean(name='AutoInstall'),
      instanceId?: string(name='InstanceId'),
    }
  ](name='NodeStatus')
  }(name='NodeStatusList'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMonitoringAgentStatusesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMonitoringAgentStatusesResponseBody(name='body'),
}

async function describeMonitoringAgentStatusesWithOptions(request: DescribeMonitoringAgentStatusesRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentStatusesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMonitoringAgentStatuses', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMonitoringAgentStatuses(request: DescribeMonitoringAgentStatusesRequest): DescribeMonitoringAgentStatusesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentStatusesWithOptions(request, runtime);
}

model DescribeMonitoringConfigResponseBody = {
  autoInstall?: boolean(name='AutoInstall'),
  enableInstallAgentNewECS?: boolean(name='EnableInstallAgentNewECS'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeMonitoringConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMonitoringConfigResponseBody(name='body'),
}

async function describeMonitoringConfigWithOptions(runtime: Util.RuntimeOptions): DescribeMonitoringConfigResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('DescribeMonitoringConfig', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMonitoringConfig(): DescribeMonitoringConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringConfigWithOptions(runtime);
}

model DescribeMonitorResourceQuotaAttributeRequest {
  showUsed?: boolean(name='ShowUsed'),
}

model DescribeMonitorResourceQuotaAttributeResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resourceQuota?: {
    api?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='Api'),
    expireTime?: string(name='ExpireTime'),
    customMonitor?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='CustomMonitor'),
    eventMonitor?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='EventMonitor'),
    instanceId?: string(name='InstanceId'),
    siteMonitorTask?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='SiteMonitorTask'),
    phone?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='Phone'),
    suitInfo?: string(name='SuitInfo'),
    SMS?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='SMS'),
    logMonitor?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='LogMonitor'),
    siteMonitorOperatorProbe?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='SiteMonitorOperatorProbe'),
    siteMonitorEcsProbe?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='SiteMonitorEcsProbe'),
  }(name='ResourceQuota'),
  code?: string(name='Code'),
}

model DescribeMonitorResourceQuotaAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMonitorResourceQuotaAttributeResponseBody(name='body'),
}

async function describeMonitorResourceQuotaAttributeWithOptions(request: DescribeMonitorResourceQuotaAttributeRequest, runtime: Util.RuntimeOptions): DescribeMonitorResourceQuotaAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMonitorResourceQuotaAttribute', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMonitorResourceQuotaAttribute(request: DescribeMonitorResourceQuotaAttributeRequest): DescribeMonitorResourceQuotaAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorResourceQuotaAttributeWithOptions(request, runtime);
}

model DescribeProductResourceTagKeyListRequest {
  nextToken?: string(name='NextToken'),
}

model DescribeProductResourceTagKeyListResponseBody = {
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
  tagKeys?: {
    tagKey?: [ string ](name='TagKey')
  }(name='TagKeys'),
}

model DescribeProductResourceTagKeyListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeProductResourceTagKeyListResponseBody(name='body'),
}

async function describeProductResourceTagKeyListWithOptions(request: DescribeProductResourceTagKeyListRequest, runtime: Util.RuntimeOptions): DescribeProductResourceTagKeyListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeProductResourceTagKeyList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeProductResourceTagKeyList(request: DescribeProductResourceTagKeyListRequest): DescribeProductResourceTagKeyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProductResourceTagKeyListWithOptions(request, runtime);
}

model DescribeProductsOfActiveMetricRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  allProductInitMetricRuleList?: {
    allProductInitMetricRule?: [ 
    {
      product?: string(name='Product'),
      alertInitConfigList?: {
        alertInitConfig?: [ 
        {
          metricName?: string(name='MetricName'),
          evaluationCount?: string(name='EvaluationCount'),
          namespace?: string(name='Namespace'),
          threshold?: string(name='Threshold'),
          statistics?: string(name='Statistics'),
          period?: string(name='Period'),
        }
      ](name='AlertInitConfig')
      }(name='AlertInitConfigList'),
    }
  ](name='AllProductInitMetricRule')
  }(name='AllProductInitMetricRuleList'),
  datapoints?: string(name='Datapoints'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeProductsOfActiveMetricRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeProductsOfActiveMetricRuleResponseBody(name='body'),
}

async function describeProductsOfActiveMetricRuleWithOptions(runtime: Util.RuntimeOptions): DescribeProductsOfActiveMetricRuleResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('DescribeProductsOfActiveMetricRule', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeProductsOfActiveMetricRule(): DescribeProductsOfActiveMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProductsOfActiveMetricRuleWithOptions(runtime);
}

model DescribeProjectMetaRequest {
  labels?: string(name='Labels'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeProjectMetaResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: string(name='PageSize'),
  pageNumber?: string(name='PageNumber'),
  total?: string(name='Total'),
  resources?: {
    resource?: [ 
    {
      description?: string(name='Description'),
      labels?: string(name='Labels'),
      namespace?: string(name='Namespace'),
    }
  ](name='Resource')
  }(name='Resources'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DescribeProjectMetaResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeProjectMetaResponseBody(name='body'),
}

async function describeProjectMetaWithOptions(request: DescribeProjectMetaRequest, runtime: Util.RuntimeOptions): DescribeProjectMetaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeProjectMeta', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeProjectMeta(request: DescribeProjectMetaRequest): DescribeProjectMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProjectMetaWithOptions(request, runtime);
}

model DescribeSiteMonitorAttributeRequest {
  taskId?: string(name='TaskId'),
  includeAlert?: boolean(name='IncludeAlert'),
}

model DescribeSiteMonitorAttributeResponseBody = {
  metricRules?: {
    metricRule?: [ 
    {
      metricName?: string(name='MetricName'),
      evaluationCount?: string(name='EvaluationCount'),
      namespace?: string(name='Namespace'),
      okActions?: string(name='OkActions'),
      alarmActions?: string(name='AlarmActions'),
      period?: string(name='Period'),
      ruleName?: string(name='RuleName'),
      ruleId?: string(name='RuleId'),
      comparisonOperator?: string(name='ComparisonOperator'),
      expression?: string(name='Expression'),
      dimensions?: string(name='Dimensions'),
      stateValue?: string(name='StateValue'),
      actionEnable?: string(name='ActionEnable'),
      level?: string(name='Level'),
      threshold?: string(name='Threshold'),
      statistics?: string(name='Statistics'),
    }
  ](name='MetricRule')
  }(name='MetricRules'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
  siteMonitors?: {
    taskType?: string(name='TaskType'),
    optionJson?: {
      password?: string(name='password'),
      requestFormat?: string(name='request_format'),
      expectValue?: string(name='expect_value'),
      responseContent?: string(name='response_content'),
      timeOut?: long(name='time_out'),
      failureRate?: float(name='failure_rate'),
      header?: string(name='header'),
      cookie?: string(name='cookie'),
      pingNum?: int32(name='ping_num'),
      port?: int32(name='port'),
      authentication?: int32(name='authentication'),
      httpMethod?: string(name='http_method'),
      matchRule?: int32(name='match_rule'),
      requestContent?: string(name='request_content'),
      username?: string(name='username'),
      traceroute?: long(name='traceroute'),
      responseFormat?: string(name='response_format'),
      dnsType?: string(name='dns_type'),
      dnsServer?: string(name='dns_server'),
    }(name='OptionJson'),
    interval?: string(name='Interval'),
    taskState?: string(name='TaskState'),
    taskName?: string(name='TaskName'),
    address?: string(name='Address'),
    ispCities?: {
      ispCity?: [ 
      {
        cityName?: string(name='CityName'),
        city?: string(name='City'),
        ispName?: string(name='IspName'),
        isp?: string(name='Isp'),
      }
    ](name='IspCity')
    }(name='IspCities'),
    taskId?: string(name='TaskId'),
  }(name='SiteMonitors'),
}

model DescribeSiteMonitorAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSiteMonitorAttributeResponseBody(name='body'),
}

async function describeSiteMonitorAttributeWithOptions(request: DescribeSiteMonitorAttributeRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSiteMonitorAttribute', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSiteMonitorAttribute(request: DescribeSiteMonitorAttributeRequest): DescribeSiteMonitorAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorAttributeWithOptions(request, runtime);
}

model DescribeSiteMonitorDataRequest {
  taskId?: string(name='TaskId'),
  type?: string(name='Type'),
  metricName?: string(name='MetricName'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  period?: string(name='Period'),
  nextToken?: string(name='NextToken'),
  length?: int32(name='Length'),
}

model DescribeSiteMonitorDataResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: string(name='Success'),
}

model DescribeSiteMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSiteMonitorDataResponseBody(name='body'),
}

async function describeSiteMonitorDataWithOptions(request: DescribeSiteMonitorDataRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorDataResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSiteMonitorData', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSiteMonitorData(request: DescribeSiteMonitorDataRequest): DescribeSiteMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorDataWithOptions(request, runtime);
}

model DescribeSiteMonitorListRequest {
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
  keyword?: string(name='Keyword'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
}

model DescribeSiteMonitorListResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  code?: string(name='Code'),
  success?: string(name='Success'),
  siteMonitors?: {
    siteMonitor?: [ 
    {
      taskType?: string(name='TaskType'),
      updateTime?: string(name='UpdateTime'),
      interval?: string(name='Interval'),
      taskState?: string(name='TaskState'),
      optionsJson?: {
        password?: string(name='password'),
        requestFormat?: string(name='request_format'),
        expectValue?: string(name='expect_value'),
        responseContent?: string(name='response_content'),
        timeOut?: long(name='time_out'),
        failureRate?: float(name='failure_rate'),
        header?: string(name='header'),
        cookie?: string(name='cookie'),
        pingNum?: int32(name='ping_num'),
        port?: int32(name='port'),
        authentication?: int32(name='authentication'),
        httpMethod?: string(name='http_method'),
        matchRule?: int32(name='match_rule'),
        requestContent?: string(name='request_content'),
        username?: string(name='username'),
        traceroute?: long(name='traceroute'),
        responseFormat?: string(name='response_format'),
        dnsType?: string(name='dns_type'),
        dnsServer?: string(name='dns_server'),
      }(name='OptionsJson'),
      createTime?: string(name='CreateTime'),
      taskName?: string(name='TaskName'),
      address?: string(name='Address'),
      taskId?: string(name='TaskId'),
    }
  ](name='SiteMonitor')
  }(name='SiteMonitors'),
}

model DescribeSiteMonitorListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSiteMonitorListResponseBody(name='body'),
}

async function describeSiteMonitorListWithOptions(request: DescribeSiteMonitorListRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSiteMonitorList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSiteMonitorList(request: DescribeSiteMonitorListRequest): DescribeSiteMonitorListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorListWithOptions(request, runtime);
}

model DescribeSiteMonitorQuotaResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    siteMonitorOperatorQuotaQuota?: int32(name='SiteMonitorOperatorQuotaQuota'),
    secondMonitor?: boolean(name='SecondMonitor'),
    siteMonitorQuotaTaskUsed?: int32(name='SiteMonitorQuotaTaskUsed'),
    siteMonitorTaskQuota?: int32(name='SiteMonitorTaskQuota'),
    siteMonitorVersion?: string(name='SiteMonitorVersion'),
    siteMonitorIdcQuota?: int32(name='SiteMonitorIdcQuota'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: string(name='Success'),
}

model DescribeSiteMonitorQuotaResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSiteMonitorQuotaResponseBody(name='body'),
}

async function describeSiteMonitorQuotaWithOptions(runtime: Util.RuntimeOptions): DescribeSiteMonitorQuotaResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('DescribeSiteMonitorQuota', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSiteMonitorQuota(): DescribeSiteMonitorQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorQuotaWithOptions(runtime);
}

model DescribeSiteMonitorStatisticsRequest {
  taskId?: string(name='TaskId'),
  timeRange?: string(name='TimeRange'),
  startTime?: string(name='StartTime'),
  metricName?: string(name='MetricName'),
}

model DescribeSiteMonitorStatisticsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: string(name='Success'),
}

model DescribeSiteMonitorStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSiteMonitorStatisticsResponseBody(name='body'),
}

async function describeSiteMonitorStatisticsWithOptions(request: DescribeSiteMonitorStatisticsRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorStatisticsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSiteMonitorStatistics', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSiteMonitorStatistics(request: DescribeSiteMonitorStatisticsRequest): DescribeSiteMonitorStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorStatisticsWithOptions(request, runtime);
}

model DescribeSystemEventAttributeRequest {
  product?: string(name='Product'),
  eventType?: string(name='EventType'),
  name?: string(name='Name'),
  level?: string(name='Level'),
  status?: string(name='Status'),
  groupId?: string(name='GroupId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeSystemEventAttributeResponseBody = {
  systemEvents?: {
    systemEvent?: [ 
    {
      status?: string(name='Status'),
      time?: long(name='Time'),
      groupId?: string(name='GroupId'),
      product?: string(name='Product'),
      instanceName?: string(name='InstanceName'),
      resourceId?: string(name='ResourceId'),
      name?: string(name='Name'),
      content?: string(name='Content'),
      level?: string(name='Level'),
      regionId?: string(name='RegionId'),
    }
  ](name='SystemEvent')
  }(name='SystemEvents'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: string(name='Success'),
}

model DescribeSystemEventAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSystemEventAttributeResponseBody(name='body'),
}

async function describeSystemEventAttributeWithOptions(request: DescribeSystemEventAttributeRequest, runtime: Util.RuntimeOptions): DescribeSystemEventAttributeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSystemEventAttribute', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSystemEventAttribute(request: DescribeSystemEventAttributeRequest): DescribeSystemEventAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemEventAttributeWithOptions(request, runtime);
}

model DescribeSystemEventCountRequest {
  product?: string(name='Product'),
  eventType?: string(name='EventType'),
  name?: string(name='Name'),
  level?: string(name='Level'),
  status?: string(name='Status'),
  groupId?: string(name='GroupId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
}

model DescribeSystemEventCountResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  systemEventCounts?: {
    systemEventCount?: [ 
    {
      status?: string(name='Status'),
      time?: long(name='Time'),
      groupId?: string(name='GroupId'),
      product?: string(name='Product'),
      instanceName?: string(name='InstanceName'),
      num?: long(name='Num'),
      resourceId?: string(name='ResourceId'),
      name?: string(name='Name'),
      content?: string(name='Content'),
      level?: string(name='Level'),
      regionId?: string(name='RegionId'),
    }
  ](name='SystemEventCount')
  }(name='SystemEventCounts'),
  code?: string(name='Code'),
  success?: string(name='Success'),
}

model DescribeSystemEventCountResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSystemEventCountResponseBody(name='body'),
}

async function describeSystemEventCountWithOptions(request: DescribeSystemEventCountRequest, runtime: Util.RuntimeOptions): DescribeSystemEventCountResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSystemEventCount', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSystemEventCount(request: DescribeSystemEventCountRequest): DescribeSystemEventCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemEventCountWithOptions(request, runtime);
}

model DescribeSystemEventHistogramRequest {
  product?: string(name='Product'),
  eventType?: string(name='EventType'),
  name?: string(name='Name'),
  level?: string(name='Level'),
  status?: string(name='Status'),
  groupId?: string(name='GroupId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
}

model DescribeSystemEventHistogramResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  systemEventHistograms?: {
    systemEventHistogram?: [ 
    {
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
      count?: long(name='Count'),
    }
  ](name='SystemEventHistogram')
  }(name='SystemEventHistograms'),
  code?: string(name='Code'),
  success?: string(name='Success'),
}

model DescribeSystemEventHistogramResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSystemEventHistogramResponseBody(name='body'),
}

async function describeSystemEventHistogramWithOptions(request: DescribeSystemEventHistogramRequest, runtime: Util.RuntimeOptions): DescribeSystemEventHistogramResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSystemEventHistogram', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSystemEventHistogram(request: DescribeSystemEventHistogramRequest): DescribeSystemEventHistogramResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemEventHistogramWithOptions(request, runtime);
}

model DescribeTagKeyListRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeTagKeyListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
  tagKeys?: {
    tagKey?: [ string ](name='TagKey')
  }(name='TagKeys'),
}

model DescribeTagKeyListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTagKeyListResponseBody(name='body'),
}

async function describeTagKeyListWithOptions(request: DescribeTagKeyListRequest, runtime: Util.RuntimeOptions): DescribeTagKeyListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeTagKeyList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeTagKeyList(request: DescribeTagKeyListRequest): DescribeTagKeyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagKeyListWithOptions(request, runtime);
}

model DescribeTagValueListRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  tagKey?: string(name='TagKey'),
}

model DescribeTagValueListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
  tagValues?: {
    tagValue?: [ string ](name='TagValue')
  }(name='TagValues'),
}

model DescribeTagValueListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTagValueListResponseBody(name='body'),
}

async function describeTagValueListWithOptions(request: DescribeTagValueListRequest, runtime: Util.RuntimeOptions): DescribeTagValueListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeTagValueList', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeTagValueList(request: DescribeTagValueListRequest): DescribeTagValueListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagValueListWithOptions(request, runtime);
}

model DescribeUnhealthyHostAvailabilityRequest {
  id?: [ integer ](name='Id'),
}

model DescribeUnhealthyHostAvailabilityResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
  unhealthyList?: {
    nodeTaskInstance?: [ 
    {
      instanceList?: {
        string?: [ string ](name='String')
      }(name='InstanceList'),
      id?: long(name='Id'),
    }
  ](name='NodeTaskInstance')
  }(name='UnhealthyList'),
}

model DescribeUnhealthyHostAvailabilityResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUnhealthyHostAvailabilityResponseBody(name='body'),
}

async function describeUnhealthyHostAvailabilityWithOptions(request: DescribeUnhealthyHostAvailabilityRequest, runtime: Util.RuntimeOptions): DescribeUnhealthyHostAvailabilityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeUnhealthyHostAvailability', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeUnhealthyHostAvailability(request: DescribeUnhealthyHostAvailabilityRequest): DescribeUnhealthyHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUnhealthyHostAvailabilityWithOptions(request, runtime);
}

model DisableActiveMetricRuleRequest {
  product?: string(name='Product'),
}

model DisableActiveMetricRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DisableActiveMetricRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableActiveMetricRuleResponseBody(name='body'),
}

async function disableActiveMetricRuleWithOptions(request: DisableActiveMetricRuleRequest, runtime: Util.RuntimeOptions): DisableActiveMetricRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableActiveMetricRule', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableActiveMetricRule(request: DisableActiveMetricRuleRequest): DisableActiveMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableActiveMetricRuleWithOptions(request, runtime);
}

model DisableEventRulesRequest {
  ruleNames?: [ string ](name='RuleNames'),
}

model DisableEventRulesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DisableEventRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DisableEventRulesResponseBody(name='body'),
}

async function disableEventRulesWithOptions(request: DisableEventRulesRequest, runtime: Util.RuntimeOptions): DisableEventRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableEventRules', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableEventRules(request: DisableEventRulesRequest): DisableEventRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableEventRulesWithOptions(request, runtime);
}

model DisableHostAvailabilityRequest {
  id?: [ integer ](name='Id'),
}

model DisableHostAvailabilityResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DisableHostAvailabilityResponse = {
  headers: map[string]string(name='headers'),
  body: DisableHostAvailabilityResponseBody(name='body'),
}

async function disableHostAvailabilityWithOptions(request: DisableHostAvailabilityRequest, runtime: Util.RuntimeOptions): DisableHostAvailabilityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableHostAvailability', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableHostAvailability(request: DisableHostAvailabilityRequest): DisableHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableHostAvailabilityWithOptions(request, runtime);
}

model DisableMetricRulesRequest {
  ruleId?: [ string ](name='RuleId'),
}

model DisableMetricRulesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DisableMetricRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DisableMetricRulesResponseBody(name='body'),
}

async function disableMetricRulesWithOptions(request: DisableMetricRulesRequest, runtime: Util.RuntimeOptions): DisableMetricRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableMetricRules', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableMetricRules(request: DisableMetricRulesRequest): DisableMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableMetricRulesWithOptions(request, runtime);
}

model DisableSiteMonitorsRequest {
  taskIds?: string(name='TaskIds'),
}

model DisableSiteMonitorsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    count?: int32(name='count'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: string(name='Success'),
}

model DisableSiteMonitorsResponse = {
  headers: map[string]string(name='headers'),
  body: DisableSiteMonitorsResponseBody(name='body'),
}

async function disableSiteMonitorsWithOptions(request: DisableSiteMonitorsRequest, runtime: Util.RuntimeOptions): DisableSiteMonitorsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableSiteMonitors', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableSiteMonitors(request: DisableSiteMonitorsRequest): DisableSiteMonitorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableSiteMonitorsWithOptions(request, runtime);
}

model EnableActiveMetricRuleRequest {
  product?: string(name='Product'),
}

model EnableActiveMetricRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model EnableActiveMetricRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableActiveMetricRuleResponseBody(name='body'),
}

async function enableActiveMetricRuleWithOptions(request: EnableActiveMetricRuleRequest, runtime: Util.RuntimeOptions): EnableActiveMetricRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableActiveMetricRule', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableActiveMetricRule(request: EnableActiveMetricRuleRequest): EnableActiveMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableActiveMetricRuleWithOptions(request, runtime);
}

model EnableEventRulesRequest {
  ruleNames?: [ string ](name='RuleNames'),
}

model EnableEventRulesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model EnableEventRulesResponse = {
  headers: map[string]string(name='headers'),
  body: EnableEventRulesResponseBody(name='body'),
}

async function enableEventRulesWithOptions(request: EnableEventRulesRequest, runtime: Util.RuntimeOptions): EnableEventRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableEventRules', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableEventRules(request: EnableEventRulesRequest): EnableEventRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableEventRulesWithOptions(request, runtime);
}

model EnableHostAvailabilityRequest {
  id?: [ integer ](name='Id'),
}

model EnableHostAvailabilityResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model EnableHostAvailabilityResponse = {
  headers: map[string]string(name='headers'),
  body: EnableHostAvailabilityResponseBody(name='body'),
}

async function enableHostAvailabilityWithOptions(request: EnableHostAvailabilityRequest, runtime: Util.RuntimeOptions): EnableHostAvailabilityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableHostAvailability', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableHostAvailability(request: EnableHostAvailabilityRequest): EnableHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableHostAvailabilityWithOptions(request, runtime);
}

model EnableMetricRulesRequest {
  ruleId?: [ string ](name='RuleId'),
}

model EnableMetricRulesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model EnableMetricRulesResponse = {
  headers: map[string]string(name='headers'),
  body: EnableMetricRulesResponseBody(name='body'),
}

async function enableMetricRulesWithOptions(request: EnableMetricRulesRequest, runtime: Util.RuntimeOptions): EnableMetricRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableMetricRules', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableMetricRules(request: EnableMetricRulesRequest): EnableMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableMetricRulesWithOptions(request, runtime);
}

model EnableSiteMonitorsRequest {
  taskIds?: string(name='TaskIds'),
}

model EnableSiteMonitorsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    count?: int32(name='count'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: string(name='Success'),
}

model EnableSiteMonitorsResponse = {
  headers: map[string]string(name='headers'),
  body: EnableSiteMonitorsResponseBody(name='body'),
}

async function enableSiteMonitorsWithOptions(request: EnableSiteMonitorsRequest, runtime: Util.RuntimeOptions): EnableSiteMonitorsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('EnableSiteMonitors', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function enableSiteMonitors(request: EnableSiteMonitorsRequest): EnableSiteMonitorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableSiteMonitorsWithOptions(request, runtime);
}

model InstallMonitoringAgentRequest {
  force?: boolean(name='Force'),
  instanceIds?: [ string ](name='InstanceIds'),
}

model InstallMonitoringAgentResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model InstallMonitoringAgentResponse = {
  headers: map[string]string(name='headers'),
  body: InstallMonitoringAgentResponseBody(name='body'),
}

async function installMonitoringAgentWithOptions(request: InstallMonitoringAgentRequest, runtime: Util.RuntimeOptions): InstallMonitoringAgentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('InstallMonitoringAgent', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function installMonitoringAgent(request: InstallMonitoringAgentRequest): InstallMonitoringAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return installMonitoringAgentWithOptions(request, runtime);
}

model ModifyGroupMonitoringAgentProcessRequest {
  id?: string(name='Id'),
  groupId?: string(name='GroupId'),
  matchExpressFilterRelation?: string(name='MatchExpressFilterRelation'),
  alertConfig?: [ 
    {
      silenceTime?: string(name='SilenceTime'),
      comparisonOperator?: string(name='ComparisonOperator'),
      webhook?: string(name='Webhook'),
      times?: string(name='Times'),
      escalationsLevel?: string(name='EscalationsLevel'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      effectiveInterval?: string(name='EffectiveInterval'),
      threshold?: string(name='Threshold'),
      statistics?: string(name='Statistics'),
    }
  ](name='AlertConfig'),
}

model ModifyGroupMonitoringAgentProcessResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ModifyGroupMonitoringAgentProcessResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyGroupMonitoringAgentProcessResponseBody(name='body'),
}

async function modifyGroupMonitoringAgentProcessWithOptions(request: ModifyGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): ModifyGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyGroupMonitoringAgentProcess', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyGroupMonitoringAgentProcess(request: ModifyGroupMonitoringAgentProcessRequest): ModifyGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model ModifyHostAvailabilityRequest {
  taskOption?: {
    httpURI?: string(name='HttpURI'),
    telnetOrPingHost?: string(name='TelnetOrPingHost'),
    httpResponseCharset?: string(name='HttpResponseCharset'),
    httpPostContent?: string(name='HttpPostContent'),
    httpResponseMatchContent?: string(name='HttpResponseMatchContent'),
    httpMethod?: string(name='HttpMethod'),
    httpNegative?: boolean(name='HttpNegative'),
    httpHeader?: string(name='HttpHeader'),
  }(name='TaskOption'),
  alertConfig?: {
    notifyType?: int32(name='NotifyType'),
    startTime?: int32(name='StartTime'),
    endTime?: int32(name='EndTime'),
    silenceTime?: int32(name='SilenceTime'),
    webHook?: string(name='WebHook'),
  }(name='AlertConfig'),
  groupId?: long(name='GroupId'),
  id?: long(name='Id'),
  taskName?: string(name='TaskName'),
  taskScope?: string(name='TaskScope'),
  alertConfigEscalationList?: [ 
    {
      value?: string(name='Value'),
      metricName?: string(name='MetricName'),
      times?: int32(name='Times'),
      operator?: string(name='Operator'),
      aggregate?: string(name='Aggregate'),
    }
  ](name='AlertConfigEscalationList'),
  instanceList?: [ string ](name='InstanceList'),
}

model ModifyHostAvailabilityResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ModifyHostAvailabilityResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHostAvailabilityResponseBody(name='body'),
}

async function modifyHostAvailabilityWithOptions(request: ModifyHostAvailabilityRequest, runtime: Util.RuntimeOptions): ModifyHostAvailabilityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyHostAvailability', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyHostAvailability(request: ModifyHostAvailabilityRequest): ModifyHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHostAvailabilityWithOptions(request, runtime);
}

model ModifyHostInfoRequest {
  instanceId?: string(name='InstanceId'),
  hostName?: string(name='HostName'),
}

model ModifyHostInfoResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ModifyHostInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHostInfoResponseBody(name='body'),
}

async function modifyHostInfoWithOptions(request: ModifyHostInfoRequest, runtime: Util.RuntimeOptions): ModifyHostInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyHostInfo', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyHostInfo(request: ModifyHostInfoRequest): ModifyHostInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHostInfoWithOptions(request, runtime);
}

model ModifyMetricRuleTemplateRequest {
  templateId?: long(name='TemplateId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  restVersion?: long(name='RestVersion'),
  alertTemplates?: [ 
    {
      escalations: {
        info: {
            threshold?: string(name='Threshold'),
            statistics?: string(name='Statistics'),
            comparisonOperator?: string(name='ComparisonOperator'),
            times?: int32(name='Times'),
        }(name='Info'),
        warn: {
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
            comparisonOperator?: string(name='ComparisonOperator'),
            statistics?: string(name='Statistics'),
        }(name='Warn'),
        critical: {
            times?: int32(name='Times'),
            threshold?: string(name='Threshold'),
            comparisonOperator?: string(name='ComparisonOperator'),
            statistics?: string(name='Statistics'),
        }(name='Critical'),
      }(name='Escalations'),
      metricName?: string(name='MetricName'),
      webhook?: string(name='Webhook'),
      namespace?: string(name='Namespace'),
      ruleName?: string(name='RuleName'),
      period?: int32(name='Period'),
      selector?: string(name='Selector'),
      category?: string(name='Category'),
    }
  ](name='AlertTemplates'),
}

model ModifyMetricRuleTemplateResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ModifyMetricRuleTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyMetricRuleTemplateResponseBody(name='body'),
}

async function modifyMetricRuleTemplateWithOptions(request: ModifyMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): ModifyMetricRuleTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyMetricRuleTemplate', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyMetricRuleTemplate(request: ModifyMetricRuleTemplateRequest): ModifyMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMetricRuleTemplateWithOptions(request, runtime);
}

model ModifyMonitorGroupRequest {
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  contactGroups?: string(name='ContactGroups'),
}

model ModifyMonitorGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ModifyMonitorGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyMonitorGroupResponseBody(name='body'),
}

async function modifyMonitorGroupWithOptions(request: ModifyMonitorGroupRequest, runtime: Util.RuntimeOptions): ModifyMonitorGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyMonitorGroup', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyMonitorGroup(request: ModifyMonitorGroupRequest): ModifyMonitorGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMonitorGroupWithOptions(request, runtime);
}

model ModifyMonitorGroupInstancesRequest {
  groupId?: long(name='GroupId'),
  instances?: [ 
    {
      instanceName?: string(name='InstanceName'),
      category?: string(name='Category'),
      instanceId?: string(name='InstanceId'),
      regionId?: string(name='RegionId'),
    }
  ](name='Instances'),
}

model ModifyMonitorGroupInstancesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ModifyMonitorGroupInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyMonitorGroupInstancesResponseBody(name='body'),
}

async function modifyMonitorGroupInstancesWithOptions(request: ModifyMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): ModifyMonitorGroupInstancesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyMonitorGroupInstances', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyMonitorGroupInstances(request: ModifyMonitorGroupInstancesRequest): ModifyMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMonitorGroupInstancesWithOptions(request, runtime);
}

model ModifySiteMonitorRequest {
  address?: string(name='Address'),
  taskId?: string(name='TaskId'),
  taskName?: string(name='TaskName'),
  interval?: string(name='Interval'),
  ispCities?: string(name='IspCities'),
  optionsJson?: string(name='OptionsJson'),
  alertIds?: string(name='AlertIds'),
}

model ModifySiteMonitorResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    count?: int32(name='count'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: string(name='Success'),
}

model ModifySiteMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySiteMonitorResponseBody(name='body'),
}

async function modifySiteMonitorWithOptions(request: ModifySiteMonitorRequest, runtime: Util.RuntimeOptions): ModifySiteMonitorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifySiteMonitor', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifySiteMonitor(request: ModifySiteMonitorRequest): ModifySiteMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySiteMonitorWithOptions(request, runtime);
}

model OpenCmsServiceResponseBody = {
  requestId?: string(name='RequestId'),
  orderId?: string(name='OrderId'),
}

model OpenCmsServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenCmsServiceResponseBody(name='body'),
}

async function openCmsServiceWithOptions(runtime: Util.RuntimeOptions): OpenCmsServiceResponse {
  var req = new OpenApi.OpenApiRequest{};
  return doRPCRequest('OpenCmsService', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function openCmsService(): OpenCmsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openCmsServiceWithOptions(runtime);
}

model PutContactRequest {
  channels?: {
    SMS?: string(name='SMS'),
    mail?: string(name='Mail'),
    aliIM?: string(name='AliIM'),
    dingWebHook?: string(name='DingWebHook'),
  }(name='Channels'),
  contactName?: string(name='ContactName'),
  describe?: string(name='Describe'),
  lang?: string(name='Lang'),
}

model PutContactResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model PutContactResponse = {
  headers: map[string]string(name='headers'),
  body: PutContactResponseBody(name='body'),
}

async function putContactWithOptions(request: PutContactRequest, runtime: Util.RuntimeOptions): PutContactResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutContact', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putContact(request: PutContactRequest): PutContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return putContactWithOptions(request, runtime);
}

model PutContactGroupRequest {
  contactGroupName?: string(name='ContactGroupName'),
  describe?: string(name='Describe'),
  enableSubscribed?: boolean(name='EnableSubscribed'),
  contactNames?: [ string ](name='ContactNames'),
}

model PutContactGroupResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model PutContactGroupResponse = {
  headers: map[string]string(name='headers'),
  body: PutContactGroupResponseBody(name='body'),
}

async function putContactGroupWithOptions(request: PutContactGroupRequest, runtime: Util.RuntimeOptions): PutContactGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutContactGroup', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putContactGroup(request: PutContactGroupRequest): PutContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return putContactGroupWithOptions(request, runtime);
}

model PutCustomEventRequest {
  eventInfo?: [ 
    {
      time?: string(name='Time'),
      eventName?: string(name='EventName'),
      groupId?: string(name='GroupId'),
      content?: string(name='Content'),
    }
  ](name='EventInfo'),
}

model PutCustomEventResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model PutCustomEventResponse = {
  headers: map[string]string(name='headers'),
  body: PutCustomEventResponseBody(name='body'),
}

async function putCustomEventWithOptions(request: PutCustomEventRequest, runtime: Util.RuntimeOptions): PutCustomEventResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutCustomEvent', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putCustomEvent(request: PutCustomEventRequest): PutCustomEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return putCustomEventWithOptions(request, runtime);
}

model PutCustomEventRuleRequest {
  groupId?: string(name='GroupId'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  eventName?: string(name='EventName'),
  contactGroups?: string(name='ContactGroups'),
  webhook?: string(name='Webhook'),
  effectiveInterval?: string(name='EffectiveInterval'),
  period?: string(name='Period'),
  emailSubject?: string(name='EmailSubject'),
  threshold?: string(name='Threshold'),
  level?: string(name='Level'),
}

model PutCustomEventRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model PutCustomEventRuleResponse = {
  headers: map[string]string(name='headers'),
  body: PutCustomEventRuleResponseBody(name='body'),
}

async function putCustomEventRuleWithOptions(request: PutCustomEventRuleRequest, runtime: Util.RuntimeOptions): PutCustomEventRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutCustomEventRule', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putCustomEventRule(request: PutCustomEventRuleRequest): PutCustomEventRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putCustomEventRuleWithOptions(request, runtime);
}

model PutCustomMetricRequest {
  metricList?: [ 
    {
      type?: string(name='Type'),
      metricName?: string(name='MetricName'),
      time?: string(name='Time'),
      groupId?: string(name='GroupId'),
      values?: string(name='Values'),
      dimensions?: string(name='Dimensions'),
      period?: string(name='Period'),
    }
  ](name='MetricList'),
}

model PutCustomMetricResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
}

model PutCustomMetricResponse = {
  headers: map[string]string(name='headers'),
  body: PutCustomMetricResponseBody(name='body'),
}

async function putCustomMetricWithOptions(request: PutCustomMetricRequest, runtime: Util.RuntimeOptions): PutCustomMetricResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutCustomMetric', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putCustomMetric(request: PutCustomMetricRequest): PutCustomMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return putCustomMetricWithOptions(request, runtime);
}

model PutCustomMetricRuleRequest {
  groupId?: string(name='GroupId'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  metricName?: string(name='MetricName'),
  resources?: string(name='Resources'),
  contactGroups?: string(name='ContactGroups'),
  webhook?: string(name='Webhook'),
  effectiveInterval?: string(name='EffectiveInterval'),
  silenceTime?: int32(name='SilenceTime'),
  period?: string(name='Period'),
  emailSubject?: string(name='EmailSubject'),
  threshold?: string(name='Threshold'),
  level?: string(name='Level'),
  evaluationCount?: int32(name='EvaluationCount'),
  statistics?: string(name='Statistics'),
  comparisonOperator?: string(name='ComparisonOperator'),
}

model PutCustomMetricRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model PutCustomMetricRuleResponse = {
  headers: map[string]string(name='headers'),
  body: PutCustomMetricRuleResponseBody(name='body'),
}

async function putCustomMetricRuleWithOptions(request: PutCustomMetricRuleRequest, runtime: Util.RuntimeOptions): PutCustomMetricRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutCustomMetricRule', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putCustomMetricRule(request: PutCustomMetricRuleRequest): PutCustomMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putCustomMetricRuleWithOptions(request, runtime);
}

model PutEventRuleRequest {
  ruleName?: string(name='RuleName'),
  groupId?: string(name='GroupId'),
  eventType?: string(name='EventType'),
  description?: string(name='Description'),
  state?: string(name='State'),
  eventPattern?: [ 
    {
      eventTypeList?: [ string ](name='EventTypeList'),
      statusList?: [ string ](name='StatusList'),
      product?: string(name='Product'),
      levelList?: [ string ](name='LevelList'),
      nameList?: [ string ](name='NameList'),
    }
  ](name='EventPattern'),
}

model PutEventRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model PutEventRuleResponse = {
  headers: map[string]string(name='headers'),
  body: PutEventRuleResponseBody(name='body'),
}

async function putEventRuleWithOptions(request: PutEventRuleRequest, runtime: Util.RuntimeOptions): PutEventRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutEventRule', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putEventRule(request: PutEventRuleRequest): PutEventRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putEventRuleWithOptions(request, runtime);
}

model PutEventRuleTargetsRequest {
  ruleName?: string(name='RuleName'),
  fcParameters?: [ 
    {
      functionName?: string(name='FunctionName'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
      id?: string(name='Id'),
    }
  ](name='FcParameters'),
  contactParameters?: [ 
    {
      contactGroupName?: string(name='ContactGroupName'),
      level?: string(name='Level'),
      id?: string(name='Id'),
    }
  ](name='ContactParameters'),
  mnsParameters?: [ 
    {
      region?: string(name='Region'),
      queue?: string(name='Queue'),
      id?: string(name='Id'),
    }
  ](name='MnsParameters'),
  webhookParameters?: [ 
    {
      protocol?: string(name='Protocol'),
      method?: string(name='Method'),
      url?: string(name='Url'),
      id?: string(name='Id'),
    }
  ](name='WebhookParameters'),
  slsParameters?: [ 
    {
      logStore?: string(name='LogStore'),
      region?: string(name='Region'),
      project?: string(name='Project'),
      id?: string(name='Id'),
    }
  ](name='SlsParameters'),
}

model PutEventRuleTargetsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  failedMnsParameters?: {
    mnsParameter?: [ 
    {
      region?: string(name='Region'),
      queue?: string(name='Queue'),
      id?: int32(name='Id'),
    }
  ](name='MnsParameter')
  }(name='FailedMnsParameters'),
  failedFcParameters?: {
    fcParameter?: [ 
    {
      functionName?: string(name='FunctionName'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
      id?: int32(name='Id'),
    }
  ](name='FcParameter')
  }(name='FailedFcParameters'),
  failedParameterCount?: string(name='FailedParameterCount'),
  failedContactParameters?: {
    contactParameter?: [ 
    {
      contactGroupName?: string(name='ContactGroupName'),
      id?: int32(name='Id'),
      level?: string(name='Level'),
    }
  ](name='ContactParameter')
  }(name='FailedContactParameters'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model PutEventRuleTargetsResponse = {
  headers: map[string]string(name='headers'),
  body: PutEventRuleTargetsResponseBody(name='body'),
}

async function putEventRuleTargetsWithOptions(request: PutEventRuleTargetsRequest, runtime: Util.RuntimeOptions): PutEventRuleTargetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutEventRuleTargets', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putEventRuleTargets(request: PutEventRuleTargetsRequest): PutEventRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putEventRuleTargetsWithOptions(request, runtime);
}

model PutExporterOutputRequest {
  destName?: string(name='DestName'),
  configJson?: string(name='ConfigJson'),
  desc?: string(name='Desc'),
  destType?: string(name='DestType'),
}

model PutExporterOutputResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model PutExporterOutputResponse = {
  headers: map[string]string(name='headers'),
  body: PutExporterOutputResponseBody(name='body'),
}

async function putExporterOutputWithOptions(request: PutExporterOutputRequest, runtime: Util.RuntimeOptions): PutExporterOutputResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutExporterOutput', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putExporterOutput(request: PutExporterOutputRequest): PutExporterOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return putExporterOutputWithOptions(request, runtime);
}

model PutExporterRuleRequest {
  ruleName?: string(name='RuleName'),
  namespace?: string(name='Namespace'),
  metricName?: string(name='MetricName'),
  targetWindows?: string(name='TargetWindows'),
  describe?: string(name='Describe'),
  dstNames?: [ string ](name='DstNames'),
}

model PutExporterRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model PutExporterRuleResponse = {
  headers: map[string]string(name='headers'),
  body: PutExporterRuleResponseBody(name='body'),
}

async function putExporterRuleWithOptions(request: PutExporterRuleRequest, runtime: Util.RuntimeOptions): PutExporterRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutExporterRule', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putExporterRule(request: PutExporterRuleRequest): PutExporterRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putExporterRuleWithOptions(request, runtime);
}

model PutGroupMetricRuleRequest {
  escalations?: {
    critical: {
        statistics?: string(name='Statistics'),
        comparisonOperator?: string(name='ComparisonOperator'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Critical'),
    warn: {
        statistics?: string(name='Statistics'),
        comparisonOperator?: string(name='ComparisonOperator'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Warn'),
    info: {
        statistics?: string(name='Statistics'),
        comparisonOperator?: string(name='ComparisonOperator'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Info'),
  }(name='Escalations'),
  groupId?: string(name='GroupId'),
  ruleId?: string(name='RuleId'),
  category?: string(name='Category'),
  ruleName?: string(name='RuleName'),
  namespace?: string(name='Namespace'),
  metricName?: string(name='MetricName'),
  dimensions?: string(name='Dimensions'),
  extraDimensionJson?: string(name='ExtraDimensionJson'),
  effectiveInterval?: string(name='EffectiveInterval'),
  noEffectiveInterval?: string(name='NoEffectiveInterval'),
  silenceTime?: int32(name='SilenceTime'),
  period?: string(name='Period'),
  interval?: string(name='Interval'),
  webhook?: string(name='Webhook'),
  emailSubject?: string(name='EmailSubject'),
  contactGroups?: string(name='ContactGroups'),
}

model PutGroupMetricRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model PutGroupMetricRuleResponse = {
  headers: map[string]string(name='headers'),
  body: PutGroupMetricRuleResponseBody(name='body'),
}

async function putGroupMetricRuleWithOptions(request: PutGroupMetricRuleRequest, runtime: Util.RuntimeOptions): PutGroupMetricRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutGroupMetricRule', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putGroupMetricRule(request: PutGroupMetricRuleRequest): PutGroupMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putGroupMetricRuleWithOptions(request, runtime);
}

model PutLogMonitorRequest {
  logId?: string(name='LogId'),
  slsRegionId?: string(name='SlsRegionId'),
  slsProject?: string(name='SlsProject'),
  slsLogstore?: string(name='SlsLogstore'),
  metricName?: string(name='MetricName'),
  metricExpress?: string(name='MetricExpress'),
  groupId?: string(name='GroupId'),
  valueFilterRelation?: string(name='ValueFilterRelation'),
  tumblingwindows?: string(name='Tumblingwindows'),
  unit?: string(name='Unit'),
  aggregates?: [ 
    {
      fieldName?: string(name='FieldName'),
      function?: string(name='Function'),
      alias?: string(name='Alias'),
    }
  ](name='Aggregates'),
  groupbys?: [ 
    {
      fieldName?: string(name='FieldName'),
      alias?: string(name='Alias'),
    }
  ](name='Groupbys'),
  valueFilter?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
      operator?: string(name='Operator'),
    }
  ](name='ValueFilter'),
}

model PutLogMonitorResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  logId?: string(name='LogId'),
  success?: boolean(name='Success'),
}

model PutLogMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: PutLogMonitorResponseBody(name='body'),
}

async function putLogMonitorWithOptions(request: PutLogMonitorRequest, runtime: Util.RuntimeOptions): PutLogMonitorResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutLogMonitor', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putLogMonitor(request: PutLogMonitorRequest): PutLogMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return putLogMonitorWithOptions(request, runtime);
}

model PutMetricRuleTargetsRequest {
  ruleId?: string(name='RuleId'),
  targets?: [ 
    {
      arn?: string(name='Arn'),
      level?: string(name='Level'),
      id?: string(name='Id'),
    }
  ](name='Targets'),
}

model PutMetricRuleTargetsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  failData?: {
    targets?: {
      target?: [ 
      {
        id?: string(name='Id'),
        arn?: string(name='Arn'),
        level?: string(name='Level'),
      }
    ](name='Target')
    }(name='Targets'),
  }(name='FailData'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model PutMetricRuleTargetsResponse = {
  headers: map[string]string(name='headers'),
  body: PutMetricRuleTargetsResponseBody(name='body'),
}

async function putMetricRuleTargetsWithOptions(request: PutMetricRuleTargetsRequest, runtime: Util.RuntimeOptions): PutMetricRuleTargetsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutMetricRuleTargets', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putMetricRuleTargets(request: PutMetricRuleTargetsRequest): PutMetricRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putMetricRuleTargetsWithOptions(request, runtime);
}

model PutMonitorGroupDynamicRuleRequest {
  groupId?: long(name='GroupId'),
  groupRules?: [ 
    {
      filterRelation?: string(name='FilterRelation'),
      filters?: [ 
        {
          value?: string(name='Value'),
          function?: string(name='Function'),
          name?: string(name='Name'),
        }
      ](name='Filters'),
      category?: string(name='Category'),
    }
  ](name='GroupRules'),
}

model PutMonitorGroupDynamicRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model PutMonitorGroupDynamicRuleResponse = {
  headers: map[string]string(name='headers'),
  body: PutMonitorGroupDynamicRuleResponseBody(name='body'),
}

async function putMonitorGroupDynamicRuleWithOptions(request: PutMonitorGroupDynamicRuleRequest, runtime: Util.RuntimeOptions): PutMonitorGroupDynamicRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutMonitorGroupDynamicRule', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putMonitorGroupDynamicRule(request: PutMonitorGroupDynamicRuleRequest): PutMonitorGroupDynamicRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putMonitorGroupDynamicRuleWithOptions(request, runtime);
}

model PutMonitoringConfigRequest {
  autoInstall?: boolean(name='AutoInstall'),
  enableInstallAgentNewECS?: boolean(name='EnableInstallAgentNewECS'),
}

model PutMonitoringConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model PutMonitoringConfigResponse = {
  headers: map[string]string(name='headers'),
  body: PutMonitoringConfigResponseBody(name='body'),
}

async function putMonitoringConfigWithOptions(request: PutMonitoringConfigRequest, runtime: Util.RuntimeOptions): PutMonitoringConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutMonitoringConfig', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putMonitoringConfig(request: PutMonitoringConfigRequest): PutMonitoringConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return putMonitoringConfigWithOptions(request, runtime);
}

model PutResourceMetricRuleRequest {
  escalations?: {
    critical: {
        statistics?: string(name='Statistics'),
        comparisonOperator?: string(name='ComparisonOperator'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Critical'),
    warn: {
        statistics?: string(name='Statistics'),
        comparisonOperator?: string(name='ComparisonOperator'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Warn'),
    info: {
        statistics?: string(name='Statistics'),
        comparisonOperator?: string(name='ComparisonOperator'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Info'),
  }(name='Escalations'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  namespace?: string(name='Namespace'),
  metricName?: string(name='MetricName'),
  resources?: string(name='Resources'),
  contactGroups?: string(name='ContactGroups'),
  webhook?: string(name='Webhook'),
  effectiveInterval?: string(name='EffectiveInterval'),
  noEffectiveInterval?: string(name='NoEffectiveInterval'),
  silenceTime?: int32(name='SilenceTime'),
  period?: string(name='Period'),
  interval?: string(name='Interval'),
  emailSubject?: string(name='EmailSubject'),
}

model PutResourceMetricRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model PutResourceMetricRuleResponse = {
  headers: map[string]string(name='headers'),
  body: PutResourceMetricRuleResponseBody(name='body'),
}

async function putResourceMetricRuleWithOptions(request: PutResourceMetricRuleRequest, runtime: Util.RuntimeOptions): PutResourceMetricRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutResourceMetricRule', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putResourceMetricRule(request: PutResourceMetricRuleRequest): PutResourceMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putResourceMetricRuleWithOptions(request, runtime);
}

model PutResourceMetricRulesRequest {
  rules?: [ 
    {
      escalations: {
        info: {
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
            statistics?: string(name='Statistics'),
            comparisonOperator?: string(name='ComparisonOperator'),
        }(name='Info'),
        warn: {
            threshold?: string(name='Threshold'),
            comparisonOperator?: string(name='ComparisonOperator'),
            times?: int32(name='Times'),
            statistics?: string(name='Statistics'),
        }(name='Warn'),
        critical: {
            times?: int32(name='Times'),
            threshold?: string(name='Threshold'),
            statistics?: string(name='Statistics'),
            comparisonOperator?: string(name='ComparisonOperator'),
        }(name='Critical'),
      }(name='Escalations'),
      metricName?: string(name='MetricName'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      effectiveInterval?: string(name='EffectiveInterval'),
      ruleId?: string(name='RuleId'),
      resources?: string(name='Resources'),
      silenceTime?: int32(name='SilenceTime'),
      webhook?: string(name='Webhook'),
      contactGroups?: string(name='ContactGroups'),
      namespace?: string(name='Namespace'),
      emailSubject?: string(name='EmailSubject'),
      period?: string(name='Period'),
      ruleName?: string(name='RuleName'),
      interval?: string(name='Interval'),
    }
  ](name='Rules'),
}

model PutResourceMetricRulesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  failedListResult?: {
    target?: [ 
    {
      result?: {
        success?: boolean(name='Success'),
        code?: string(name='Code'),
        message?: string(name='Message'),
      }(name='Result'),
      ruleId?: string(name='RuleId'),
    }
  ](name='Target')
  }(name='FailedListResult'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model PutResourceMetricRulesResponse = {
  headers: map[string]string(name='headers'),
  body: PutResourceMetricRulesResponseBody(name='body'),
}

async function putResourceMetricRulesWithOptions(request: PutResourceMetricRulesRequest, runtime: Util.RuntimeOptions): PutResourceMetricRulesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PutResourceMetricRules', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function putResourceMetricRules(request: PutResourceMetricRulesRequest): PutResourceMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return putResourceMetricRulesWithOptions(request, runtime);
}

model RemoveTagsRequest {
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  groupIds?: [ string ](name='GroupIds'),
}

model RemoveTagsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  tag?: {
    tags?: [ string ](name='Tags')
  }(name='Tag'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model RemoveTagsResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveTagsResponseBody(name='body'),
}

async function removeTagsWithOptions(request: RemoveTagsRequest, runtime: Util.RuntimeOptions): RemoveTagsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveTags', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeTags(request: RemoveTagsRequest): RemoveTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeTagsWithOptions(request, runtime);
}

model SendDryRunSystemEventRequest {
  product?: string(name='Product'),
  eventName?: string(name='EventName'),
  groupId?: string(name='GroupId'),
  eventContent?: string(name='EventContent'),
}

model SendDryRunSystemEventResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: string(name='Success'),
}

model SendDryRunSystemEventResponse = {
  headers: map[string]string(name='headers'),
  body: SendDryRunSystemEventResponseBody(name='body'),
}

async function sendDryRunSystemEventWithOptions(request: SendDryRunSystemEventRequest, runtime: Util.RuntimeOptions): SendDryRunSystemEventResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SendDryRunSystemEvent', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function sendDryRunSystemEvent(request: SendDryRunSystemEventRequest): SendDryRunSystemEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendDryRunSystemEventWithOptions(request, runtime);
}

model UninstallMonitoringAgentRequest {
  instanceId?: string(name='InstanceId'),
}

model UninstallMonitoringAgentResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UninstallMonitoringAgentResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallMonitoringAgentResponseBody(name='body'),
}

async function uninstallMonitoringAgentWithOptions(request: UninstallMonitoringAgentRequest, runtime: Util.RuntimeOptions): UninstallMonitoringAgentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UninstallMonitoringAgent', '2019-01-01', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function uninstallMonitoringAgent(request: UninstallMonitoringAgentRequest): UninstallMonitoringAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallMonitoringAgentWithOptions(request, runtime);
}

