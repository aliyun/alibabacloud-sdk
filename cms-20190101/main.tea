/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('cms', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddTagsRequest {
  groupIds?: [ string ](name='GroupIds'),
  regionId?: string(name='RegionId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model AddTagsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddTagsResponseBody(name='body'),
}

async function addTagsWithOptions(request: AddTagsRequest, runtime: Util.RuntimeOptions): AddTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupIds)) {
    query['GroupIds'] = request.groupIds;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddTags',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addTags(request: AddTagsRequest): AddTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTagsWithOptions(request, runtime);
}

model ApplyMetricRuleTemplateRequest {
  applyMode?: string(name='ApplyMode'),
  enableEndTime?: long(name='EnableEndTime'),
  enableStartTime?: long(name='EnableStartTime'),
  groupId?: long(name='GroupId'),
  notifyLevel?: long(name='NotifyLevel'),
  silenceTime?: long(name='SilenceTime'),
  templateIds?: string(name='TemplateIds'),
  webhook?: string(name='Webhook'),
}

model ApplyMetricRuleTemplateResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resource?: {
    alertResults?: [ 
      {
        code?: string(name='Code'),
        message?: string(name='Message'),
        ruleId?: string(name='RuleId'),
        ruleName?: string(name='RuleName'),
        success?: boolean(name='Success'),
      }
    ](name='AlertResults'),
    groupId?: long(name='GroupId'),
  }(name='Resource'),
  success?: boolean(name='Success'),
}

model ApplyMetricRuleTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyMetricRuleTemplateResponseBody(name='body'),
}

async function applyMetricRuleTemplateWithOptions(request: ApplyMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): ApplyMetricRuleTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.applyMode)) {
    query['ApplyMode'] = request.applyMode;
  }
  if (!Util.isUnset(request.enableEndTime)) {
    query['EnableEndTime'] = request.enableEndTime;
  }
  if (!Util.isUnset(request.enableStartTime)) {
    query['EnableStartTime'] = request.enableStartTime;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.notifyLevel)) {
    query['NotifyLevel'] = request.notifyLevel;
  }
  if (!Util.isUnset(request.silenceTime)) {
    query['SilenceTime'] = request.silenceTime;
  }
  if (!Util.isUnset(request.templateIds)) {
    query['TemplateIds'] = request.templateIds;
  }
  if (!Util.isUnset(request.webhook)) {
    query['Webhook'] = request.webhook;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyMetricRuleTemplate',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyMetricRuleTemplate(request: ApplyMetricRuleTemplateRequest): ApplyMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyMetricRuleTemplateWithOptions(request, runtime);
}

model BatchCreateInstantSiteMonitorRequest {
  regionId?: string(name='RegionId'),
  taskList?: [ 
    {
      address?: string(name='Address'),
      ispCities?: string(name='IspCities'),
      optionsJson?: string(name='OptionsJson'),
      taskName?: string(name='TaskName'),
      taskType?: string(name='TaskType'),
    }
  ](name='TaskList'),
}

model BatchCreateInstantSiteMonitorResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model BatchCreateInstantSiteMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchCreateInstantSiteMonitorResponseBody(name='body'),
}

async function batchCreateInstantSiteMonitorWithOptions(request: BatchCreateInstantSiteMonitorRequest, runtime: Util.RuntimeOptions): BatchCreateInstantSiteMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskList)) {
    query['TaskList'] = request.taskList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchCreateInstantSiteMonitor',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchCreateInstantSiteMonitor(request: BatchCreateInstantSiteMonitorRequest): BatchCreateInstantSiteMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchCreateInstantSiteMonitorWithOptions(request, runtime);
}

model BatchCreateIntantSiteMonitorRequest {
  regionId?: string(name='RegionId'),
  taskList?: [ 
    {
      address?: string(name='Address'),
      ispCities?: string(name='IspCities'),
      optionsJson?: string(name='OptionsJson'),
      taskName?: string(name='TaskName'),
      taskType?: string(name='TaskType'),
    }
  ](name='TaskList'),
}

model BatchCreateIntantSiteMonitorResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model BatchCreateIntantSiteMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchCreateIntantSiteMonitorResponseBody(name='body'),
}

async function batchCreateIntantSiteMonitorWithOptions(request: BatchCreateIntantSiteMonitorRequest, runtime: Util.RuntimeOptions): BatchCreateIntantSiteMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskList)) {
    query['TaskList'] = request.taskList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchCreateIntantSiteMonitor',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchCreateIntantSiteMonitor(request: BatchCreateIntantSiteMonitorRequest): BatchCreateIntantSiteMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchCreateIntantSiteMonitorWithOptions(request, runtime);
}

model CreateCmsCallNumOrderRequest {
  autoPay?: boolean(name='AutoPay'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  autoUseCoupon?: boolean(name='AutoUseCoupon'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  phoneCount?: string(name='PhoneCount'),
}

model CreateCmsCallNumOrderResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateCmsCallNumOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCmsCallNumOrderResponseBody(name='body'),
}

async function createCmsCallNumOrderWithOptions(request: CreateCmsCallNumOrderRequest, runtime: Util.RuntimeOptions): CreateCmsCallNumOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoRenewPeriod)) {
    query['AutoRenewPeriod'] = request.autoRenewPeriod;
  }
  if (!Util.isUnset(request.autoUseCoupon)) {
    query['AutoUseCoupon'] = request.autoUseCoupon;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.phoneCount)) {
    query['PhoneCount'] = request.phoneCount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCmsCallNumOrder',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCmsCallNumOrder(request: CreateCmsCallNumOrderRequest): CreateCmsCallNumOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCmsCallNumOrderWithOptions(request, runtime);
}

model CreateCmsOrderRequest {
  apiCount?: string(name='ApiCount'),
  autoPay?: boolean(name='AutoPay'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  autoUseCoupon?: boolean(name='AutoUseCoupon'),
  customTimeSeries?: string(name='CustomTimeSeries'),
  eventStoreNum?: string(name='EventStoreNum'),
  eventStoreTime?: string(name='EventStoreTime'),
  logMonitorStream?: string(name='LogMonitorStream'),
  payType?: string(name='PayType'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  phoneCount?: string(name='PhoneCount'),
  siteEcsNum?: string(name='SiteEcsNum'),
  siteOperatorNum?: string(name='SiteOperatorNum'),
  siteTaskNum?: string(name='SiteTaskNum'),
  smsCount?: string(name='SmsCount'),
  suggestType?: string(name='SuggestType'),
}

model CreateCmsOrderResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateCmsOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCmsOrderResponseBody(name='body'),
}

async function createCmsOrderWithOptions(request: CreateCmsOrderRequest, runtime: Util.RuntimeOptions): CreateCmsOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.apiCount)) {
    query['ApiCount'] = request.apiCount;
  }
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoRenewPeriod)) {
    query['AutoRenewPeriod'] = request.autoRenewPeriod;
  }
  if (!Util.isUnset(request.autoUseCoupon)) {
    query['AutoUseCoupon'] = request.autoUseCoupon;
  }
  if (!Util.isUnset(request.customTimeSeries)) {
    query['CustomTimeSeries'] = request.customTimeSeries;
  }
  if (!Util.isUnset(request.eventStoreNum)) {
    query['EventStoreNum'] = request.eventStoreNum;
  }
  if (!Util.isUnset(request.eventStoreTime)) {
    query['EventStoreTime'] = request.eventStoreTime;
  }
  if (!Util.isUnset(request.logMonitorStream)) {
    query['LogMonitorStream'] = request.logMonitorStream;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.phoneCount)) {
    query['PhoneCount'] = request.phoneCount;
  }
  if (!Util.isUnset(request.siteEcsNum)) {
    query['SiteEcsNum'] = request.siteEcsNum;
  }
  if (!Util.isUnset(request.siteOperatorNum)) {
    query['SiteOperatorNum'] = request.siteOperatorNum;
  }
  if (!Util.isUnset(request.siteTaskNum)) {
    query['SiteTaskNum'] = request.siteTaskNum;
  }
  if (!Util.isUnset(request.smsCount)) {
    query['SmsCount'] = request.smsCount;
  }
  if (!Util.isUnset(request.suggestType)) {
    query['SuggestType'] = request.suggestType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCmsOrder',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCmsOrder(request: CreateCmsOrderRequest): CreateCmsOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCmsOrderWithOptions(request, runtime);
}

model CreateCmsSmspackageOrderRequest {
  autoPay?: boolean(name='AutoPay'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod'),
  autoUseCoupon?: boolean(name='AutoUseCoupon'),
  period?: int32(name='Period'),
  periodUnit?: string(name='PeriodUnit'),
  smsCount?: string(name='SmsCount'),
}

model CreateCmsSmspackageOrderResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateCmsSmspackageOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCmsSmspackageOrderResponseBody(name='body'),
}

async function createCmsSmspackageOrderWithOptions(request: CreateCmsSmspackageOrderRequest, runtime: Util.RuntimeOptions): CreateCmsSmspackageOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoRenewPeriod)) {
    query['AutoRenewPeriod'] = request.autoRenewPeriod;
  }
  if (!Util.isUnset(request.autoUseCoupon)) {
    query['AutoUseCoupon'] = request.autoUseCoupon;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.periodUnit)) {
    query['PeriodUnit'] = request.periodUnit;
  }
  if (!Util.isUnset(request.smsCount)) {
    query['SmsCount'] = request.smsCount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCmsSmspackageOrder',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCmsSmspackageOrder(request: CreateCmsSmspackageOrderRequest): CreateCmsSmspackageOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCmsSmspackageOrderWithOptions(request, runtime);
}

model CreateDynamicTagGroupRequest {
  contactGroupList?: [ string ](name='ContactGroupList'),
  enableInstallAgent?: boolean(name='EnableInstallAgent'),
  enableSubscribeEvent?: boolean(name='EnableSubscribeEvent'),
  matchExpress?: [ 
    {
      tagName?: string(name='TagName'),
      tagValue?: string(name='TagValue'),
      tagValueMatchFunction?: string(name='TagValueMatchFunction'),
    }
  ](name='MatchExpress'),
  matchExpressFilterRelation?: string(name='MatchExpressFilterRelation'),
  regionId?: string(name='RegionId'),
  tagKey?: string(name='TagKey'),
  tagRegionId?: string(name='TagRegionId'),
  templateIdList?: [ string ](name='TemplateIdList'),
}

model CreateDynamicTagGroupResponseBody = {
  code?: string(name='Code'),
  id?: string(name='Id'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDynamicTagGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDynamicTagGroupResponseBody(name='body'),
}

async function createDynamicTagGroupWithOptions(request: CreateDynamicTagGroupRequest, runtime: Util.RuntimeOptions): CreateDynamicTagGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupList)) {
    query['ContactGroupList'] = request.contactGroupList;
  }
  if (!Util.isUnset(request.enableInstallAgent)) {
    query['EnableInstallAgent'] = request.enableInstallAgent;
  }
  if (!Util.isUnset(request.enableSubscribeEvent)) {
    query['EnableSubscribeEvent'] = request.enableSubscribeEvent;
  }
  if (!Util.isUnset(request.matchExpress)) {
    query['MatchExpress'] = request.matchExpress;
  }
  if (!Util.isUnset(request.matchExpressFilterRelation)) {
    query['MatchExpressFilterRelation'] = request.matchExpressFilterRelation;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  if (!Util.isUnset(request.tagRegionId)) {
    query['TagRegionId'] = request.tagRegionId;
  }
  if (!Util.isUnset(request.templateIdList)) {
    query['TemplateIdList'] = request.templateIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDynamicTagGroup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDynamicTagGroup(request: CreateDynamicTagGroupRequest): CreateDynamicTagGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDynamicTagGroupWithOptions(request, runtime);
}

model CreateGroupMetricRulesRequest {
  groupId?: long(name='GroupId'),
  groupMetricRules?: [ 
    {
      escalations: {
        critical: {
            comparisonOperator?: string(name='ComparisonOperator'),
            preCondition?: string(name='PreCondition'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
        }(name='Critical'),
        info: {
            comparisonOperator?: string(name='ComparisonOperator'),
            preCondition?: string(name='PreCondition'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
        }(name='Info'),
        warn: {
            comparisonOperator?: string(name='ComparisonOperator'),
            preCondition?: string(name='PreCondition'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
        }(name='Warn'),
      }(name='Escalations'),
      category?: string(name='Category'),
      contactGroups?: string(name='ContactGroups'),
      dimensions?: string(name='Dimensions'),
      effectiveInterval?: string(name='EffectiveInterval'),
      emailSubject?: string(name='EmailSubject'),
      interval?: string(name='Interval'),
      labels?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Labels'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      noDataPolicy?: string(name='NoDataPolicy'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      period?: string(name='Period'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      silenceTime?: int32(name='SilenceTime'),
      webhook?: string(name='Webhook'),
    }
  ](name='GroupMetricRules'),
  regionId?: string(name='RegionId'),
}

model CreateGroupMetricRulesResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resources?: {
    alertResult?: [ 
    {
      code?: int32(name='Code'),
      message?: string(name='Message'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      success?: boolean(name='Success'),
    }
  ](name='AlertResult')
  }(name='Resources'),
  success?: boolean(name='Success'),
}

model CreateGroupMetricRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGroupMetricRulesResponseBody(name='body'),
}

async function createGroupMetricRulesWithOptions(request: CreateGroupMetricRulesRequest, runtime: Util.RuntimeOptions): CreateGroupMetricRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupMetricRules)) {
    query['GroupMetricRules'] = request.groupMetricRules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGroupMetricRules',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGroupMetricRules(request: CreateGroupMetricRulesRequest): CreateGroupMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupMetricRulesWithOptions(request, runtime);
}

model CreateGroupMonitoringAgentProcessRequest {
  alertConfig?: [ 
    {
      comparisonOperator?: string(name='ComparisonOperator'),
      effectiveInterval?: string(name='EffectiveInterval'),
      escalationsLevel?: string(name='EscalationsLevel'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      silenceTime?: string(name='SilenceTime'),
      statistics?: string(name='Statistics'),
      threshold?: string(name='Threshold'),
      times?: string(name='Times'),
      webhook?: string(name='Webhook'),
    }
  ](name='AlertConfig'),
  groupId?: string(name='GroupId'),
  matchExpress?: [ 
    {
      function?: string(name='Function'),
      name?: string(name='Name'),
      value?: string(name='Value'),
    }
  ](name='MatchExpress'),
  matchExpressFilterRelation?: string(name='MatchExpressFilterRelation'),
  processName?: string(name='ProcessName'),
  regionId?: string(name='RegionId'),
}

model CreateGroupMonitoringAgentProcessResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateGroupMonitoringAgentProcessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGroupMonitoringAgentProcessResponseBody(name='body'),
}

async function createGroupMonitoringAgentProcessWithOptions(request: CreateGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): CreateGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertConfig)) {
    query['AlertConfig'] = request.alertConfig;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.matchExpress)) {
    query['MatchExpress'] = request.matchExpress;
  }
  if (!Util.isUnset(request.matchExpressFilterRelation)) {
    query['MatchExpressFilterRelation'] = request.matchExpressFilterRelation;
  }
  if (!Util.isUnset(request.processName)) {
    query['ProcessName'] = request.processName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGroupMonitoringAgentProcess',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGroupMonitoringAgentProcess(request: CreateGroupMonitoringAgentProcessRequest): CreateGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model CreateHostAvailabilityRequest {
  alertConfig?: {
    endTime?: int32(name='EndTime'),
    notifyType?: int32(name='NotifyType'),
    silenceTime?: int32(name='SilenceTime'),
    startTime?: int32(name='StartTime'),
    webHook?: string(name='WebHook'),
  }(name='AlertConfig'),
  taskOption?: {
    httpHeader?: string(name='HttpHeader'),
    httpMethod?: string(name='HttpMethod'),
    httpNegative?: boolean(name='HttpNegative'),
    httpPostContent?: string(name='HttpPostContent'),
    httpResponseCharset?: string(name='HttpResponseCharset'),
    httpResponseMatchContent?: string(name='HttpResponseMatchContent'),
    httpURI?: string(name='HttpURI'),
    interval?: int32(name='Interval'),
    telnetOrPingHost?: string(name='TelnetOrPingHost'),
  }(name='TaskOption'),
  alertConfigEscalationList?: [ 
    {
      aggregate?: string(name='Aggregate'),
      metricName?: string(name='MetricName'),
      operator?: string(name='Operator'),
      times?: int32(name='Times'),
      value?: string(name='Value'),
    }
  ](name='AlertConfigEscalationList'),
  groupId?: long(name='GroupId'),
  instanceList?: [ string ](name='InstanceList'),
  regionId?: string(name='RegionId'),
  taskName?: string(name='TaskName'),
  taskScope?: string(name='TaskScope'),
  taskType?: string(name='TaskType'),
}

model CreateHostAvailabilityResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: long(name='TaskId'),
}

model CreateHostAvailabilityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHostAvailabilityResponseBody(name='body'),
}

async function createHostAvailabilityWithOptions(request: CreateHostAvailabilityRequest, runtime: Util.RuntimeOptions): CreateHostAvailabilityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertConfigEscalationList)) {
    query['AlertConfigEscalationList'] = request.alertConfigEscalationList;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.instanceList)) {
    query['InstanceList'] = request.instanceList;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskScope)) {
    query['TaskScope'] = request.taskScope;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  if (!Util.isUnset(request.alertConfig)) {
    query['AlertConfig'] = request.alertConfig;
  }
  if (!Util.isUnset(request.taskOption)) {
    query['TaskOption'] = request.taskOption;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHostAvailability',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHostAvailability(request: CreateHostAvailabilityRequest): CreateHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHostAvailabilityWithOptions(request, runtime);
}

model CreateHybridMonitorNamespaceRequest {
  description?: string(name='Description'),
  namespace?: string(name='Namespace'),
  regionId?: string(name='RegionId'),
  spec?: string(name='Spec'),
}

model CreateHybridMonitorNamespaceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateHybridMonitorNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHybridMonitorNamespaceResponseBody(name='body'),
}

async function createHybridMonitorNamespaceWithOptions(request: CreateHybridMonitorNamespaceRequest, runtime: Util.RuntimeOptions): CreateHybridMonitorNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHybridMonitorNamespace',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHybridMonitorNamespace(request: CreateHybridMonitorNamespaceRequest): CreateHybridMonitorNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHybridMonitorNamespaceWithOptions(request, runtime);
}

model CreateHybridMonitorSLSGroupRequest {
  regionId?: string(name='RegionId'),
  SLSGroupConfig?: [ 
    {
      SLSLogstore?: string(name='SLSLogstore'),
      SLSProject?: string(name='SLSProject'),
      SLSRegion?: string(name='SLSRegion'),
      SLSUserId?: string(name='SLSUserId'),
    }
  ](name='SLSGroupConfig'),
  SLSGroupDescription?: string(name='SLSGroupDescription'),
  SLSGroupName?: string(name='SLSGroupName'),
}

model CreateHybridMonitorSLSGroupResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateHybridMonitorSLSGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHybridMonitorSLSGroupResponseBody(name='body'),
}

async function createHybridMonitorSLSGroupWithOptions(request: CreateHybridMonitorSLSGroupRequest, runtime: Util.RuntimeOptions): CreateHybridMonitorSLSGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.SLSGroupConfig)) {
    query['SLSGroupConfig'] = request.SLSGroupConfig;
  }
  if (!Util.isUnset(request.SLSGroupDescription)) {
    query['SLSGroupDescription'] = request.SLSGroupDescription;
  }
  if (!Util.isUnset(request.SLSGroupName)) {
    query['SLSGroupName'] = request.SLSGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHybridMonitorSLSGroup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHybridMonitorSLSGroup(request: CreateHybridMonitorSLSGroupRequest): CreateHybridMonitorSLSGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHybridMonitorSLSGroupWithOptions(request, runtime);
}

model CreateHybridMonitorTaskRequest {
  attachLabels?: [ 
    {
      name?: string(name='Name'),
      value?: string(name='Value'),
    }
  ](name='AttachLabels'),
  collectInterval?: string(name='CollectInterval'),
  collectTargetType?: string(name='CollectTargetType'),
  description?: string(name='Description'),
  groupId?: string(name='GroupId'),
  namespace?: string(name='Namespace'),
  regionId?: string(name='RegionId'),
  SLSProcessConfig?: {
    express?: [ 
      {
        alias?: string(name='Alias'),
        express?: string(name='Express'),
      }
    ](name='Express'),
    filter?: {
      filters?: [ 
        {
          operator?: string(name='Operator'),
          SLSKeyName?: string(name='SLSKeyName'),
          value?: string(name='Value'),
        }
      ](name='Filters'),
      relation?: string(name='Relation'),
    }(name='Filter'),
    groupBy?: [ 
      {
        alias?: string(name='Alias'),
        SLSKeyName?: string(name='SLSKeyName'),
      }
    ](name='GroupBy'),
    statistics?: [ 
      {
        alias?: string(name='Alias'),
        function?: string(name='Function'),
        parameter1?: string(name='Parameter1'),
        parameter2?: string(name='Parameter2'),
        SLSKeyName?: string(name='SLSKeyName'),
      }
    ](name='Statistics'),
  }(name='SLSProcessConfig'),
  targetUserId?: string(name='TargetUserId'),
  targetUserIdList?: string(name='TargetUserIdList'),
  taskName?: string(name='TaskName'),
  taskType?: string(name='TaskType'),
  YARMConfig?: string(name='YARMConfig'),
}

model CreateHybridMonitorTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  taskId?: long(name='TaskId'),
}

model CreateHybridMonitorTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHybridMonitorTaskResponseBody(name='body'),
}

async function createHybridMonitorTaskWithOptions(request: CreateHybridMonitorTaskRequest, runtime: Util.RuntimeOptions): CreateHybridMonitorTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.attachLabels)) {
    query['AttachLabels'] = request.attachLabels;
  }
  if (!Util.isUnset(request.collectInterval)) {
    query['CollectInterval'] = request.collectInterval;
  }
  if (!Util.isUnset(request.collectTargetType)) {
    query['CollectTargetType'] = request.collectTargetType;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.SLSProcessConfig)) {
    query['SLSProcessConfig'] = request.SLSProcessConfig;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  if (!Util.isUnset(request.targetUserIdList)) {
    query['TargetUserIdList'] = request.targetUserIdList;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  if (!Util.isUnset(request.YARMConfig)) {
    query['YARMConfig'] = request.YARMConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHybridMonitorTask',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHybridMonitorTask(request: CreateHybridMonitorTaskRequest): CreateHybridMonitorTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHybridMonitorTaskWithOptions(request, runtime);
}

model CreateInstantSiteMonitorRequest {
  address?: string(name='Address'),
  ispCities?: string(name='IspCities'),
  optionsJson?: string(name='OptionsJson'),
  randomIspCity?: int32(name='RandomIspCity'),
  regionId?: string(name='RegionId'),
  taskName?: string(name='TaskName'),
  taskType?: string(name='TaskType'),
}

model CreateInstantSiteMonitorResponseBody = {
  code?: string(name='Code'),
  createResultList?: [ 
    {
      taskId?: string(name='TaskId'),
      taskName?: string(name='TaskName'),
    }
  ](name='CreateResultList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateInstantSiteMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInstantSiteMonitorResponseBody(name='body'),
}

async function createInstantSiteMonitorWithOptions(request: CreateInstantSiteMonitorRequest, runtime: Util.RuntimeOptions): CreateInstantSiteMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.ispCities)) {
    query['IspCities'] = request.ispCities;
  }
  if (!Util.isUnset(request.optionsJson)) {
    query['OptionsJson'] = request.optionsJson;
  }
  if (!Util.isUnset(request.randomIspCity)) {
    query['RandomIspCity'] = request.randomIspCity;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstantSiteMonitor',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createInstantSiteMonitor(request: CreateInstantSiteMonitorRequest): CreateInstantSiteMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstantSiteMonitorWithOptions(request, runtime);
}

model CreateMetricRuleBlackListRequest {
  category?: string(name='Category'),
  effectiveTime?: string(name='EffectiveTime'),
  enableEndTime?: string(name='EnableEndTime'),
  enableStartTime?: string(name='EnableStartTime'),
  instances?: [ string ](name='Instances'),
  metrics?: [ 
    {
      metricName?: string(name='MetricName'),
      resource?: string(name='Resource'),
    }
  ](name='Metrics'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  regionId?: string(name='RegionId'),
  scopeType?: string(name='ScopeType'),
  scopeValue?: string(name='ScopeValue'),
}

model CreateMetricRuleBlackListResponseBody = {
  code?: string(name='Code'),
  id?: string(name='Id'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMetricRuleBlackListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMetricRuleBlackListResponseBody(name='body'),
}

async function createMetricRuleBlackListWithOptions(request: CreateMetricRuleBlackListRequest, runtime: Util.RuntimeOptions): CreateMetricRuleBlackListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.effectiveTime)) {
    query['EffectiveTime'] = request.effectiveTime;
  }
  if (!Util.isUnset(request.enableEndTime)) {
    query['EnableEndTime'] = request.enableEndTime;
  }
  if (!Util.isUnset(request.enableStartTime)) {
    query['EnableStartTime'] = request.enableStartTime;
  }
  if (!Util.isUnset(request.instances)) {
    query['Instances'] = request.instances;
  }
  if (!Util.isUnset(request.metrics)) {
    query['Metrics'] = request.metrics;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.scopeType)) {
    query['ScopeType'] = request.scopeType;
  }
  if (!Util.isUnset(request.scopeValue)) {
    query['ScopeValue'] = request.scopeValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMetricRuleBlackList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMetricRuleBlackList(request: CreateMetricRuleBlackListRequest): CreateMetricRuleBlackListResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMetricRuleBlackListWithOptions(request, runtime);
}

model CreateMetricRuleResourcesRequest {
  overwrite?: string(name='Overwrite'),
  resources?: string(name='Resources'),
  ruleId?: string(name='RuleId'),
}

model CreateMetricRuleResourcesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMetricRuleResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMetricRuleResourcesResponseBody(name='body'),
}

async function createMetricRuleResourcesWithOptions(request: CreateMetricRuleResourcesRequest, runtime: Util.RuntimeOptions): CreateMetricRuleResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.overwrite)) {
    query['Overwrite'] = request.overwrite;
  }
  if (!Util.isUnset(request.resources)) {
    query['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMetricRuleResources',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMetricRuleResources(request: CreateMetricRuleResourcesRequest): CreateMetricRuleResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMetricRuleResourcesWithOptions(request, runtime);
}

model CreateMetricRuleTemplateRequest {
  alertTemplates?: [ 
    {
      escalations: {
        critical: {
            comparisonOperator?: string(name='ComparisonOperator'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
        }(name='Critical'),
        info: {
            comparisonOperator?: string(name='ComparisonOperator'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
        }(name='Info'),
        warn: {
            comparisonOperator?: string(name='ComparisonOperator'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
        }(name='Warn'),
      }(name='Escalations'),
      category?: string(name='Category'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      period?: int32(name='Period'),
      ruleName?: string(name='RuleName'),
      selector?: string(name='Selector'),
      webhook?: string(name='Webhook'),
    }
  ](name='AlertTemplates'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model CreateMetricRuleTemplateResponseBody = {
  code?: int32(name='Code'),
  id?: long(name='Id'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMetricRuleTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMetricRuleTemplateResponseBody(name='body'),
}

async function createMetricRuleTemplateWithOptions(request: CreateMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): CreateMetricRuleTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertTemplates)) {
    query['AlertTemplates'] = request.alertTemplates;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMetricRuleTemplate',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMetricRuleTemplate(request: CreateMetricRuleTemplateRequest): CreateMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMetricRuleTemplateWithOptions(request, runtime);
}

model CreateMonitorAgentProcessRequest {
  instanceId?: string(name='InstanceId'),
  processName?: string(name='ProcessName'),
  processUser?: string(name='ProcessUser'),
  regionId?: string(name='RegionId'),
}

model CreateMonitorAgentProcessResponseBody = {
  code?: string(name='Code'),
  id?: long(name='Id'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMonitorAgentProcessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMonitorAgentProcessResponseBody(name='body'),
}

async function createMonitorAgentProcessWithOptions(request: CreateMonitorAgentProcessRequest, runtime: Util.RuntimeOptions): CreateMonitorAgentProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.processName)) {
    query['ProcessName'] = request.processName;
  }
  if (!Util.isUnset(request.processUser)) {
    query['ProcessUser'] = request.processUser;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorAgentProcess',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitorAgentProcess(request: CreateMonitorAgentProcessRequest): CreateMonitorAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorAgentProcessWithOptions(request, runtime);
}

model CreateMonitorGroupRequest {
  contactGroups?: string(name='ContactGroups'),
  groupName?: string(name='GroupName'),
  regionId?: string(name='RegionId'),
}

model CreateMonitorGroupResponseBody = {
  code?: int32(name='Code'),
  groupId?: long(name='GroupId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMonitorGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMonitorGroupResponseBody(name='body'),
}

async function createMonitorGroupWithOptions(request: CreateMonitorGroupRequest, runtime: Util.RuntimeOptions): CreateMonitorGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroups)) {
    query['ContactGroups'] = request.contactGroups;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorGroup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitorGroup(request: CreateMonitorGroupRequest): CreateMonitorGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorGroupWithOptions(request, runtime);
}

model CreateMonitorGroupByResourceGroupIdRequest {
  contactGroupList?: [ string ](name='ContactGroupList'),
  enableInstallAgent?: boolean(name='EnableInstallAgent'),
  enableSubscribeEvent?: boolean(name='EnableSubscribeEvent'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceGroupName?: string(name='ResourceGroupName'),
}

model CreateMonitorGroupByResourceGroupIdResponseBody = {
  code?: string(name='Code'),
  id?: long(name='Id'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMonitorGroupByResourceGroupIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMonitorGroupByResourceGroupIdResponseBody(name='body'),
}

async function createMonitorGroupByResourceGroupIdWithOptions(request: CreateMonitorGroupByResourceGroupIdRequest, runtime: Util.RuntimeOptions): CreateMonitorGroupByResourceGroupIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupList)) {
    query['ContactGroupList'] = request.contactGroupList;
  }
  if (!Util.isUnset(request.enableInstallAgent)) {
    query['EnableInstallAgent'] = request.enableInstallAgent;
  }
  if (!Util.isUnset(request.enableSubscribeEvent)) {
    query['EnableSubscribeEvent'] = request.enableSubscribeEvent;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceGroupName)) {
    query['ResourceGroupName'] = request.resourceGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorGroupByResourceGroupId',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitorGroupByResourceGroupId(request: CreateMonitorGroupByResourceGroupIdRequest): CreateMonitorGroupByResourceGroupIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorGroupByResourceGroupIdWithOptions(request, runtime);
}

model CreateMonitorGroupInstancesRequest {
  groupId?: string(name='GroupId'),
  instances?: [ 
    {
      category?: string(name='Category'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Instances'),
  regionId?: string(name='RegionId'),
}

model CreateMonitorGroupInstancesResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMonitorGroupInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMonitorGroupInstancesResponseBody(name='body'),
}

async function createMonitorGroupInstancesWithOptions(request: CreateMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): CreateMonitorGroupInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.instances)) {
    query['Instances'] = request.instances;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorGroupInstances',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitorGroupInstances(request: CreateMonitorGroupInstancesRequest): CreateMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorGroupInstancesWithOptions(request, runtime);
}

model CreateMonitorGroupNotifyPolicyRequest {
  endTime?: long(name='EndTime'),
  groupId?: string(name='GroupId'),
  policyType?: string(name='PolicyType'),
  regionId?: string(name='RegionId'),
  startTime?: long(name='StartTime'),
}

model CreateMonitorGroupNotifyPolicyResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
  success?: string(name='Success'),
}

model CreateMonitorGroupNotifyPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMonitorGroupNotifyPolicyResponseBody(name='body'),
}

async function createMonitorGroupNotifyPolicyWithOptions(request: CreateMonitorGroupNotifyPolicyRequest, runtime: Util.RuntimeOptions): CreateMonitorGroupNotifyPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.policyType)) {
    query['PolicyType'] = request.policyType;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorGroupNotifyPolicy',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitorGroupNotifyPolicy(request: CreateMonitorGroupNotifyPolicyRequest): CreateMonitorGroupNotifyPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorGroupNotifyPolicyWithOptions(request, runtime);
}

model CreateMonitoringAgentProcessRequest {
  instanceId?: string(name='InstanceId'),
  processName?: string(name='ProcessName'),
  processUser?: string(name='ProcessUser'),
  regionId?: string(name='RegionId'),
}

model CreateMonitoringAgentProcessResponseBody = {
  code?: string(name='Code'),
  id?: long(name='Id'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateMonitoringAgentProcessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMonitoringAgentProcessResponseBody(name='body'),
}

async function createMonitoringAgentProcessWithOptions(request: CreateMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): CreateMonitoringAgentProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.processName)) {
    query['ProcessName'] = request.processName;
  }
  if (!Util.isUnset(request.processUser)) {
    query['ProcessUser'] = request.processUser;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitoringAgentProcess',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitoringAgentProcess(request: CreateMonitoringAgentProcessRequest): CreateMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitoringAgentProcessWithOptions(request, runtime);
}

model CreateSiteMonitorRequest {
  address?: string(name='Address'),
  alertIds?: string(name='AlertIds'),
  interval?: string(name='Interval'),
  ispCities?: string(name='IspCities'),
  optionsJson?: string(name='OptionsJson'),
  regionId?: string(name='RegionId'),
  taskName?: string(name='TaskName'),
  taskType?: string(name='TaskType'),
}

model CreateSiteMonitorResponseBody = {
  code?: string(name='Code'),
  createResultList?: {
    createResultList?: [ 
    {
      taskId?: string(name='TaskId'),
      taskName?: string(name='TaskName'),
    }
  ](name='CreateResultList')
  }(name='CreateResultList'),
  data?: {
    attachAlertResult?: {
      contact?: [ 
      {
        code?: string(name='Code'),
        message?: string(name='Message'),
        requestId?: string(name='RequestId'),
        ruleId?: string(name='RuleId'),
        success?: string(name='Success'),
      }
    ](name='Contact')
    }(name='AttachAlertResult'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateSiteMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSiteMonitorResponseBody(name='body'),
}

async function createSiteMonitorWithOptions(request: CreateSiteMonitorRequest, runtime: Util.RuntimeOptions): CreateSiteMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.alertIds)) {
    query['AlertIds'] = request.alertIds;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.ispCities)) {
    query['IspCities'] = request.ispCities;
  }
  if (!Util.isUnset(request.optionsJson)) {
    query['OptionsJson'] = request.optionsJson;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSiteMonitor',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSiteMonitor(request: CreateSiteMonitorRequest): CreateSiteMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSiteMonitorWithOptions(request, runtime);
}

model DeleteContactRequest {
  contactName?: string(name='ContactName'),
}

model DeleteContactResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteContactResponseBody(name='body'),
}

async function deleteContactWithOptions(request: DeleteContactRequest, runtime: Util.RuntimeOptions): DeleteContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteContact',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteContact(request: DeleteContactRequest): DeleteContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContactWithOptions(request, runtime);
}

model DeleteContactGroupRequest {
  contactGroupName?: string(name='ContactGroupName'),
}

model DeleteContactGroupResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteContactGroupResponseBody(name='body'),
}

async function deleteContactGroupWithOptions(request: DeleteContactGroupRequest, runtime: Util.RuntimeOptions): DeleteContactGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupName)) {
    query['ContactGroupName'] = request.contactGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteContactGroup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteContactGroup(request: DeleteContactGroupRequest): DeleteContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContactGroupWithOptions(request, runtime);
}

model DeleteCustomMetricRequest {
  groupId?: string(name='GroupId'),
  md5?: string(name='Md5'),
  metricName?: string(name='MetricName'),
  regionId?: string(name='RegionId'),
  UUID?: string(name='UUID'),
}

model DeleteCustomMetricResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteCustomMetricResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCustomMetricResponseBody(name='body'),
}

async function deleteCustomMetricWithOptions(request: DeleteCustomMetricRequest, runtime: Util.RuntimeOptions): DeleteCustomMetricResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.md5)) {
    query['Md5'] = request.md5;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.UUID)) {
    query['UUID'] = request.UUID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomMetric',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCustomMetric(request: DeleteCustomMetricRequest): DeleteCustomMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomMetricWithOptions(request, runtime);
}

model DeleteDynamicTagGroupRequest {
  dynamicTagRuleId?: string(name='DynamicTagRuleId'),
  regionId?: string(name='RegionId'),
}

model DeleteDynamicTagGroupResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDynamicTagGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDynamicTagGroupResponseBody(name='body'),
}

async function deleteDynamicTagGroupWithOptions(request: DeleteDynamicTagGroupRequest, runtime: Util.RuntimeOptions): DeleteDynamicTagGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dynamicTagRuleId)) {
    query['DynamicTagRuleId'] = request.dynamicTagRuleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDynamicTagGroup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDynamicTagGroup(request: DeleteDynamicTagGroupRequest): DeleteDynamicTagGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDynamicTagGroupWithOptions(request, runtime);
}

model DeleteEventRuleTargetsRequest {
  ids?: [ string ](name='Ids'),
  regionId?: string(name='RegionId'),
  ruleName?: string(name='RuleName'),
}

model DeleteEventRuleTargetsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteEventRuleTargetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEventRuleTargetsResponseBody(name='body'),
}

async function deleteEventRuleTargetsWithOptions(request: DeleteEventRuleTargetsRequest, runtime: Util.RuntimeOptions): DeleteEventRuleTargetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventRuleTargets',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEventRuleTargets(request: DeleteEventRuleTargetsRequest): DeleteEventRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventRuleTargetsWithOptions(request, runtime);
}

model DeleteEventRulesRequest {
  ruleNames?: [ string ](name='RuleNames'),
}

model DeleteEventRulesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteEventRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEventRulesResponseBody(name='body'),
}

async function deleteEventRulesWithOptions(request: DeleteEventRulesRequest, runtime: Util.RuntimeOptions): DeleteEventRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleNames)) {
    query['RuleNames'] = request.ruleNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventRules',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEventRules(request: DeleteEventRulesRequest): DeleteEventRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventRulesWithOptions(request, runtime);
}

model DeleteExporterOutputRequest {
  destName?: string(name='DestName'),
  regionId?: string(name='RegionId'),
}

model DeleteExporterOutputResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteExporterOutputResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteExporterOutputResponseBody(name='body'),
}

async function deleteExporterOutputWithOptions(request: DeleteExporterOutputRequest, runtime: Util.RuntimeOptions): DeleteExporterOutputResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.destName)) {
    query['DestName'] = request.destName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteExporterOutput',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteExporterOutput(request: DeleteExporterOutputRequest): DeleteExporterOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExporterOutputWithOptions(request, runtime);
}

model DeleteExporterRuleRequest {
  regionId?: string(name='RegionId'),
  ruleName?: string(name='RuleName'),
}

model DeleteExporterRuleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteExporterRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteExporterRuleResponseBody(name='body'),
}

async function deleteExporterRuleWithOptions(request: DeleteExporterRuleRequest, runtime: Util.RuntimeOptions): DeleteExporterRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteExporterRule',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteExporterRule(request: DeleteExporterRuleRequest): DeleteExporterRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExporterRuleWithOptions(request, runtime);
}

model DeleteGroupMonitoringAgentProcessRequest {
  groupId?: string(name='GroupId'),
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
}

model DeleteGroupMonitoringAgentProcessResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteGroupMonitoringAgentProcessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGroupMonitoringAgentProcessResponseBody(name='body'),
}

async function deleteGroupMonitoringAgentProcessWithOptions(request: DeleteGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): DeleteGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGroupMonitoringAgentProcess',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGroupMonitoringAgentProcess(request: DeleteGroupMonitoringAgentProcessRequest): DeleteGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model DeleteHostAvailabilityRequest {
  id?: [ long ](name='Id'),
  regionId?: string(name='RegionId'),
}

model DeleteHostAvailabilityResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteHostAvailabilityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHostAvailabilityResponseBody(name='body'),
}

async function deleteHostAvailabilityWithOptions(request: DeleteHostAvailabilityRequest, runtime: Util.RuntimeOptions): DeleteHostAvailabilityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHostAvailability',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHostAvailability(request: DeleteHostAvailabilityRequest): DeleteHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHostAvailabilityWithOptions(request, runtime);
}

model DeleteHybridMonitorNamespaceRequest {
  namespace?: string(name='Namespace'),
  regionId?: string(name='RegionId'),
}

model DeleteHybridMonitorNamespaceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeleteHybridMonitorNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHybridMonitorNamespaceResponseBody(name='body'),
}

async function deleteHybridMonitorNamespaceWithOptions(request: DeleteHybridMonitorNamespaceRequest, runtime: Util.RuntimeOptions): DeleteHybridMonitorNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHybridMonitorNamespace',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHybridMonitorNamespace(request: DeleteHybridMonitorNamespaceRequest): DeleteHybridMonitorNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHybridMonitorNamespaceWithOptions(request, runtime);
}

model DeleteHybridMonitorSLSGroupRequest {
  regionId?: string(name='RegionId'),
  SLSGroupName?: string(name='SLSGroupName'),
}

model DeleteHybridMonitorSLSGroupResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeleteHybridMonitorSLSGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHybridMonitorSLSGroupResponseBody(name='body'),
}

async function deleteHybridMonitorSLSGroupWithOptions(request: DeleteHybridMonitorSLSGroupRequest, runtime: Util.RuntimeOptions): DeleteHybridMonitorSLSGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.SLSGroupName)) {
    query['SLSGroupName'] = request.SLSGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHybridMonitorSLSGroup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHybridMonitorSLSGroup(request: DeleteHybridMonitorSLSGroupRequest): DeleteHybridMonitorSLSGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHybridMonitorSLSGroupWithOptions(request, runtime);
}

model DeleteHybridMonitorTaskRequest {
  namespace?: string(name='Namespace'),
  regionId?: string(name='RegionId'),
  targetUserId?: string(name='TargetUserId'),
  taskId?: string(name='TaskId'),
}

model DeleteHybridMonitorTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeleteHybridMonitorTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHybridMonitorTaskResponseBody(name='body'),
}

async function deleteHybridMonitorTaskWithOptions(request: DeleteHybridMonitorTaskRequest, runtime: Util.RuntimeOptions): DeleteHybridMonitorTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHybridMonitorTask',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHybridMonitorTask(request: DeleteHybridMonitorTaskRequest): DeleteHybridMonitorTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHybridMonitorTaskWithOptions(request, runtime);
}

model DeleteLogMonitorRequest {
  logId?: long(name='LogId'),
  regionId?: string(name='RegionId'),
}

model DeleteLogMonitorResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteLogMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLogMonitorResponseBody(name='body'),
}

async function deleteLogMonitorWithOptions(request: DeleteLogMonitorRequest, runtime: Util.RuntimeOptions): DeleteLogMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.logId)) {
    query['LogId'] = request.logId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogMonitor',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLogMonitor(request: DeleteLogMonitorRequest): DeleteLogMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLogMonitorWithOptions(request, runtime);
}

model DeleteMetricRuleBlackListRequest {
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
}

model DeleteMetricRuleBlackListResponseBody = {
  code?: string(name='Code'),
  count?: int32(name='Count'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMetricRuleBlackListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMetricRuleBlackListResponseBody(name='body'),
}

async function deleteMetricRuleBlackListWithOptions(request: DeleteMetricRuleBlackListRequest, runtime: Util.RuntimeOptions): DeleteMetricRuleBlackListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMetricRuleBlackList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMetricRuleBlackList(request: DeleteMetricRuleBlackListRequest): DeleteMetricRuleBlackListResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRuleBlackListWithOptions(request, runtime);
}

model DeleteMetricRuleResourcesRequest {
  resources?: string(name='Resources'),
  ruleId?: string(name='RuleId'),
}

model DeleteMetricRuleResourcesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMetricRuleResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMetricRuleResourcesResponseBody(name='body'),
}

async function deleteMetricRuleResourcesWithOptions(request: DeleteMetricRuleResourcesRequest, runtime: Util.RuntimeOptions): DeleteMetricRuleResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resources)) {
    query['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMetricRuleResources',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMetricRuleResources(request: DeleteMetricRuleResourcesRequest): DeleteMetricRuleResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRuleResourcesWithOptions(request, runtime);
}

model DeleteMetricRuleTargetsRequest {
  regionId?: string(name='RegionId'),
  ruleId?: string(name='RuleId'),
  targetIds?: [ string ](name='TargetIds'),
}

model DeleteMetricRuleTargetsResponseBody = {
  code?: string(name='Code'),
  failIds?: {
    targetIds?: {
      targetId?: [ string ](name='TargetId')
    }(name='TargetIds'),
  }(name='FailIds'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMetricRuleTargetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMetricRuleTargetsResponseBody(name='body'),
}

async function deleteMetricRuleTargetsWithOptions(request: DeleteMetricRuleTargetsRequest, runtime: Util.RuntimeOptions): DeleteMetricRuleTargetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.targetIds)) {
    query['TargetIds'] = request.targetIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMetricRuleTargets',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMetricRuleTargets(request: DeleteMetricRuleTargetsRequest): DeleteMetricRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRuleTargetsWithOptions(request, runtime);
}

model DeleteMetricRuleTemplateRequest {
  regionId?: string(name='RegionId'),
  templateId?: string(name='TemplateId'),
}

model DeleteMetricRuleTemplateResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resource?: {
    templateId?: string(name='TemplateId'),
  }(name='Resource'),
  success?: boolean(name='Success'),
}

model DeleteMetricRuleTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMetricRuleTemplateResponseBody(name='body'),
}

async function deleteMetricRuleTemplateWithOptions(request: DeleteMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): DeleteMetricRuleTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMetricRuleTemplate',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMetricRuleTemplate(request: DeleteMetricRuleTemplateRequest): DeleteMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRuleTemplateWithOptions(request, runtime);
}

model DeleteMetricRulesRequest {
  id?: [ string ](name='Id'),
  regionId?: string(name='RegionId'),
}

model DeleteMetricRulesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMetricRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMetricRulesResponseBody(name='body'),
}

async function deleteMetricRulesWithOptions(request: DeleteMetricRulesRequest, runtime: Util.RuntimeOptions): DeleteMetricRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMetricRules',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMetricRules(request: DeleteMetricRulesRequest): DeleteMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMetricRulesWithOptions(request, runtime);
}

model DeleteMonitorGroupRequest {
  groupId?: long(name='GroupId'),
  regionId?: string(name='RegionId'),
}

model DeleteMonitorGroupResponseBody = {
  code?: int32(name='Code'),
  group?: {
    contactGroups?: {
      contactGroup?: [ 
      {
        name?: string(name='Name'),
      }
    ](name='ContactGroup')
    }(name='ContactGroups'),
    groupName?: string(name='GroupName'),
  }(name='Group'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMonitorGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMonitorGroupResponseBody(name='body'),
}

async function deleteMonitorGroupWithOptions(request: DeleteMonitorGroupRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMonitorGroup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMonitorGroup(request: DeleteMonitorGroupRequest): DeleteMonitorGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupWithOptions(request, runtime);
}

model DeleteMonitorGroupDynamicRuleRequest {
  category?: string(name='Category'),
  groupId?: long(name='GroupId'),
  regionId?: string(name='RegionId'),
}

model DeleteMonitorGroupDynamicRuleResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMonitorGroupDynamicRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMonitorGroupDynamicRuleResponseBody(name='body'),
}

async function deleteMonitorGroupDynamicRuleWithOptions(request: DeleteMonitorGroupDynamicRuleRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupDynamicRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMonitorGroupDynamicRule',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMonitorGroupDynamicRule(request: DeleteMonitorGroupDynamicRuleRequest): DeleteMonitorGroupDynamicRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupDynamicRuleWithOptions(request, runtime);
}

model DeleteMonitorGroupInstancesRequest {
  category?: string(name='Category'),
  groupId?: long(name='GroupId'),
  instanceIdList?: string(name='InstanceIdList'),
  regionId?: string(name='RegionId'),
}

model DeleteMonitorGroupInstancesResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMonitorGroupInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMonitorGroupInstancesResponseBody(name='body'),
}

async function deleteMonitorGroupInstancesWithOptions(request: DeleteMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.instanceIdList)) {
    query['InstanceIdList'] = request.instanceIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMonitorGroupInstances',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMonitorGroupInstances(request: DeleteMonitorGroupInstancesRequest): DeleteMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupInstancesWithOptions(request, runtime);
}

model DeleteMonitorGroupNotifyPolicyRequest {
  groupId?: string(name='GroupId'),
  policyType?: string(name='PolicyType'),
  regionId?: string(name='RegionId'),
}

model DeleteMonitorGroupNotifyPolicyResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
  success?: string(name='Success'),
}

model DeleteMonitorGroupNotifyPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMonitorGroupNotifyPolicyResponseBody(name='body'),
}

async function deleteMonitorGroupNotifyPolicyWithOptions(request: DeleteMonitorGroupNotifyPolicyRequest, runtime: Util.RuntimeOptions): DeleteMonitorGroupNotifyPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.policyType)) {
    query['PolicyType'] = request.policyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMonitorGroupNotifyPolicy',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMonitorGroupNotifyPolicy(request: DeleteMonitorGroupNotifyPolicyRequest): DeleteMonitorGroupNotifyPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitorGroupNotifyPolicyWithOptions(request, runtime);
}

model DeleteMonitoringAgentProcessRequest {
  instanceId?: string(name='InstanceId'),
  processId?: string(name='ProcessId'),
  processName?: string(name='ProcessName'),
  regionId?: string(name='RegionId'),
}

model DeleteMonitoringAgentProcessResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteMonitoringAgentProcessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteMonitoringAgentProcessResponseBody(name='body'),
}

async function deleteMonitoringAgentProcessWithOptions(request: DeleteMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): DeleteMonitoringAgentProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.processId)) {
    query['ProcessId'] = request.processId;
  }
  if (!Util.isUnset(request.processName)) {
    query['ProcessName'] = request.processName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMonitoringAgentProcess',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteMonitoringAgentProcess(request: DeleteMonitoringAgentProcessRequest): DeleteMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteMonitoringAgentProcessWithOptions(request, runtime);
}

model DeleteSiteMonitorsRequest {
  isDeleteAlarms?: boolean(name='IsDeleteAlarms'),
  regionId?: string(name='RegionId'),
  taskIds?: string(name='TaskIds'),
}

model DeleteSiteMonitorsResponseBody = {
  code?: string(name='Code'),
  data?: {
    count?: int32(name='count'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeleteSiteMonitorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSiteMonitorsResponseBody(name='body'),
}

async function deleteSiteMonitorsWithOptions(request: DeleteSiteMonitorsRequest, runtime: Util.RuntimeOptions): DeleteSiteMonitorsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isDeleteAlarms)) {
    query['IsDeleteAlarms'] = request.isDeleteAlarms;
  }
  if (!Util.isUnset(request.taskIds)) {
    query['TaskIds'] = request.taskIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSiteMonitors',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSiteMonitors(request: DeleteSiteMonitorsRequest): DeleteSiteMonitorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSiteMonitorsWithOptions(request, runtime);
}

model DescribeActiveMetricRuleListRequest {
  product?: string(name='Product'),
}

model DescribeActiveMetricRuleListResponseBody = {
  alertList?: {
    alert?: [ 
    {
      alertState?: string(name='AlertState'),
      contactGroups?: string(name='ContactGroups'),
      dimensions?: string(name='Dimensions'),
      effectiveInterval?: string(name='EffectiveInterval'),
      enableState?: boolean(name='EnableState'),
      escalations?: {
        critical?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Critical'),
        info?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Info'),
        warn?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
        }(name='Warn'),
      }(name='Escalations'),
      mailSubject?: string(name='MailSubject'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      period?: string(name='Period'),
      resources?: string(name='Resources'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      silenceTime?: string(name='SilenceTime'),
      webhook?: string(name='Webhook'),
    }
  ](name='Alert')
  }(name='AlertList'),
  code?: string(name='Code'),
  datapoints?: {
    alarm?: [ 
    {
      comparisonOperator?: string(name='ComparisonOperator'),
      contactGroups?: string(name='ContactGroups'),
      enable?: string(name='Enable'),
      endTime?: string(name='EndTime'),
      evaluationCount?: string(name='EvaluationCount'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      period?: string(name='Period'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      silenceTime?: string(name='SilenceTime'),
      startTime?: string(name='StartTime'),
      state?: string(name='State'),
      statistics?: string(name='Statistics'),
      threshold?: string(name='Threshold'),
      webhook?: string(name='Webhook'),
    }
  ](name='Alarm')
  }(name='Datapoints'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeActiveMetricRuleListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeActiveMetricRuleListResponseBody(name='body'),
}

async function describeActiveMetricRuleListWithOptions(request: DescribeActiveMetricRuleListRequest, runtime: Util.RuntimeOptions): DescribeActiveMetricRuleListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeActiveMetricRuleList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeActiveMetricRuleList(request: DescribeActiveMetricRuleListRequest): DescribeActiveMetricRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeActiveMetricRuleListWithOptions(request, runtime);
}

model DescribeAlertHistoryListRequest {
  ascending?: boolean(name='Ascending'),
  endTime?: string(name='EndTime'),
  groupId?: string(name='GroupId'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  startTime?: string(name='StartTime'),
  state?: string(name='State'),
  status?: string(name='Status'),
}

model DescribeAlertHistoryListResponseBody = {
  alarmHistoryList?: {
    alarmHistory?: [ 
    {
      alertTime?: long(name='AlertTime'),
      contactALIIMs?: {
        contactALIIM?: [ string ](name='ContactALIIM')
      }(name='ContactALIIMs'),
      contactGroups?: {
        contactGroup?: [ string ](name='ContactGroup')
      }(name='ContactGroups'),
      contactMails?: {
        contactMail?: [ string ](name='ContactMail')
      }(name='ContactMails'),
      contactSmses?: {
        contactSms?: [ string ](name='ContactSms')
      }(name='ContactSmses'),
      contacts?: {
        contact?: [ string ](name='Contact')
      }(name='Contacts'),
      dimensions?: string(name='Dimensions'),
      evaluationCount?: int32(name='EvaluationCount'),
      expression?: string(name='Expression'),
      groupId?: string(name='GroupId'),
      instanceName?: string(name='InstanceName'),
      lastTime?: long(name='LastTime'),
      level?: string(name='Level'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      state?: string(name='State'),
      status?: int32(name='Status'),
      value?: string(name='Value'),
      webhooks?: string(name='Webhooks'),
    }
  ](name='AlarmHistory')
  }(name='AlarmHistoryList'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
}

model DescribeAlertHistoryListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAlertHistoryListResponseBody(name='body'),
}

async function describeAlertHistoryListWithOptions(request: DescribeAlertHistoryListRequest, runtime: Util.RuntimeOptions): DescribeAlertHistoryListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ascending)) {
    query['Ascending'] = request.ascending;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlertHistoryList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAlertHistoryList(request: DescribeAlertHistoryListRequest): DescribeAlertHistoryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertHistoryListWithOptions(request, runtime);
}

model DescribeAlertLogCountRequest {
  contactGroup?: string(name='ContactGroup'),
  endTime?: long(name='EndTime'),
  groupBy?: string(name='GroupBy'),
  groupId?: string(name='GroupId'),
  lastMin?: string(name='LastMin'),
  level?: string(name='Level'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  product?: string(name='Product'),
  regionId?: string(name='RegionId'),
  ruleName?: string(name='RuleName'),
  searchKey?: string(name='SearchKey'),
  sendStatus?: string(name='SendStatus'),
  startTime?: long(name='StartTime'),
}

model DescribeAlertLogCountResponseBody = {
  alertLogCount?: [ 
    {
      count?: int32(name='Count'),
      logs?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Logs'),
    }
  ](name='AlertLogCount'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeAlertLogCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAlertLogCountResponseBody(name='body'),
}

async function describeAlertLogCountWithOptions(request: DescribeAlertLogCountRequest, runtime: Util.RuntimeOptions): DescribeAlertLogCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroup)) {
    query['ContactGroup'] = request.contactGroup;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.groupBy)) {
    query['GroupBy'] = request.groupBy;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lastMin)) {
    query['LastMin'] = request.lastMin;
  }
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.searchKey)) {
    query['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.sendStatus)) {
    query['SendStatus'] = request.sendStatus;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlertLogCount',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAlertLogCount(request: DescribeAlertLogCountRequest): DescribeAlertLogCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertLogCountWithOptions(request, runtime);
}

model DescribeAlertLogHistogramRequest {
  contactGroup?: string(name='ContactGroup'),
  endTime?: long(name='EndTime'),
  groupBy?: string(name='GroupBy'),
  groupId?: string(name='GroupId'),
  lastMin?: string(name='LastMin'),
  level?: string(name='Level'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  product?: string(name='Product'),
  regionId?: string(name='RegionId'),
  ruleName?: string(name='RuleName'),
  searchKey?: string(name='SearchKey'),
  sendStatus?: string(name='SendStatus'),
  startTime?: long(name='StartTime'),
}

model DescribeAlertLogHistogramResponseBody = {
  alertLogHistogramList?: [ 
    {
      count?: int32(name='Count'),
      from?: long(name='From'),
      to?: long(name='To'),
    }
  ](name='AlertLogHistogramList'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeAlertLogHistogramResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAlertLogHistogramResponseBody(name='body'),
}

async function describeAlertLogHistogramWithOptions(request: DescribeAlertLogHistogramRequest, runtime: Util.RuntimeOptions): DescribeAlertLogHistogramResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroup)) {
    query['ContactGroup'] = request.contactGroup;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.groupBy)) {
    query['GroupBy'] = request.groupBy;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lastMin)) {
    query['LastMin'] = request.lastMin;
  }
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.searchKey)) {
    query['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.sendStatus)) {
    query['SendStatus'] = request.sendStatus;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlertLogHistogram',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAlertLogHistogram(request: DescribeAlertLogHistogramRequest): DescribeAlertLogHistogramResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertLogHistogramWithOptions(request, runtime);
}

model DescribeAlertLogListRequest {
  contactGroup?: string(name='ContactGroup'),
  endTime?: long(name='EndTime'),
  groupBy?: string(name='GroupBy'),
  groupId?: string(name='GroupId'),
  lastMin?: string(name='LastMin'),
  level?: string(name='Level'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  product?: string(name='Product'),
  regionId?: string(name='RegionId'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  searchKey?: string(name='SearchKey'),
  sendStatus?: string(name='SendStatus'),
  startTime?: long(name='StartTime'),
}

model DescribeAlertLogListResponseBody = {
  alertLogList?: [ 
    {
      alertTime?: string(name='AlertTime'),
      blackListDetail?: string(name='BlackListDetail'),
      blackListName?: string(name='BlackListName'),
      blackListUUID?: string(name='BlackListUUID'),
      contactALIIWWList?: [ string ](name='ContactALIIWWList'),
      contactDingList?: [ string ](name='ContactDingList'),
      contactGroups?: [ string ](name='ContactGroups'),
      contactMailList?: [ string ](name='ContactMailList'),
      contactOnCallList?: [ string ](name='ContactOnCallList'),
      contactSMSList?: [ string ](name='ContactSMSList'),
      dimensions?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Dimensions'),
      dingdingWebhookList?: [ string ](name='DingdingWebhookList'),
      escalation?: {
        expression?: string(name='Expression'),
        level?: string(name='Level'),
        times?: int32(name='Times'),
      }(name='Escalation'),
      eventName?: string(name='EventName'),
      extendedInfo?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='ExtendedInfo'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      level?: string(name='Level'),
      levelChange?: string(name='LevelChange'),
      message?: string(name='Message'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      product?: string(name='Product'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      sendDetail?: {
        channelResultList?: [ 
          {
            channel?: string(name='Channel'),
            resultList?: [ 
              {
                code?: string(name='Code'),
                detail?: string(name='Detail'),
                requestId?: string(name='RequestId'),
                success?: boolean(name='Success'),
                notifyTargetList?: [ string ](name='notifyTargetList'),
              }
            ](name='ResultList'),
          }
        ](name='ChannelResultList'),
        resultCode?: string(name='ResultCode'),
      }(name='SendDetail'),
      sendResultList?: [ 
        {
          key?: string(name='Key'),
          value?: [ string ](name='Value'),
        }
      ](name='SendResultList'),
      sendStatus?: string(name='SendStatus'),
      webhookList?: [ 
        {
          code?: string(name='code'),
          message?: string(name='message'),
          url?: string(name='url'),
        }
      ](name='WebhookList'),
    }
  ](name='AlertLogList'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeAlertLogListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAlertLogListResponseBody(name='body'),
}

async function describeAlertLogListWithOptions(request: DescribeAlertLogListRequest, runtime: Util.RuntimeOptions): DescribeAlertLogListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroup)) {
    query['ContactGroup'] = request.contactGroup;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.groupBy)) {
    query['GroupBy'] = request.groupBy;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.lastMin)) {
    query['LastMin'] = request.lastMin;
  }
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.searchKey)) {
    query['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.sendStatus)) {
    query['SendStatus'] = request.sendStatus;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlertLogList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAlertLogList(request: DescribeAlertLogListRequest): DescribeAlertLogListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertLogListWithOptions(request, runtime);
}

model DescribeAlertingMetricRuleResourcesRequest {
  dimensions?: string(name='Dimensions'),
  groupId?: string(name='GroupId'),
  namespace?: string(name='Namespace'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  ruleId?: string(name='RuleId'),
}

model DescribeAlertingMetricRuleResourcesResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resources?: {
    resource?: [ 
    {
      dimensions?: string(name='Dimensions'),
      enable?: string(name='Enable'),
      escalation?: {
        resource?: [ 
        {
          comparisonOperator?: string(name='ComparisonOperator'),
          expression?: string(name='Expression'),
          expressionList?: {
            expressionList?: [ 
            {
              comparisonOperator?: string(name='ComparisonOperator'),
              metricName?: string(name='MetricName'),
              period?: string(name='Period'),
              statistics?: string(name='Statistics'),
              threshold?: string(name='Threshold'),
            }
          ](name='ExpressionList')
          }(name='ExpressionList'),
          expressionListJoin?: string(name='ExpressionListJoin'),
          level?: int32(name='Level'),
          preCondition?: string(name='PreCondition'),
          tag?: string(name='Tag'),
          threshold?: string(name='Threshold'),
          times?: int32(name='Times'),
        }
      ](name='Resource')
      }(name='Escalation'),
      groupId?: string(name='GroupId'),
      lastAlertTime?: string(name='LastAlertTime'),
      lastModifyTime?: string(name='LastModifyTime'),
      level?: int32(name='Level'),
      metricName?: string(name='MetricName'),
      metricValues?: string(name='MetricValues'),
      namespace?: string(name='Namespace'),
      productCategory?: string(name='ProductCategory'),
      resource?: string(name='Resource'),
      retryTimes?: string(name='RetryTimes'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      startTime?: string(name='StartTime'),
      statistics?: string(name='Statistics'),
      threshold?: string(name='Threshold'),
    }
  ](name='Resource')
  }(name='Resources'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model DescribeAlertingMetricRuleResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAlertingMetricRuleResourcesResponseBody(name='body'),
}

async function describeAlertingMetricRuleResourcesWithOptions(request: DescribeAlertingMetricRuleResourcesRequest, runtime: Util.RuntimeOptions): DescribeAlertingMetricRuleResourcesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAlertingMetricRuleResources',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAlertingMetricRuleResources(request: DescribeAlertingMetricRuleResourcesRequest): DescribeAlertingMetricRuleResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAlertingMetricRuleResourcesWithOptions(request, runtime);
}

model DescribeContactGroupListRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model DescribeContactGroupListResponseBody = {
  code?: string(name='Code'),
  contactGroupList?: {
    contactGroup?: [ 
    {
      contacts?: {
        contact?: [ string ](name='Contact')
      }(name='Contacts'),
      createTime?: long(name='CreateTime'),
      describe?: string(name='Describe'),
      enableSubscribed?: boolean(name='EnableSubscribed'),
      enabledWeeklyReport?: boolean(name='EnabledWeeklyReport'),
      name?: string(name='Name'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='ContactGroup')
  }(name='ContactGroupList'),
  contactGroups?: {
    contactGroup?: [ string ](name='ContactGroup')
  }(name='ContactGroups'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model DescribeContactGroupListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContactGroupListResponseBody(name='body'),
}

async function describeContactGroupListWithOptions(request: DescribeContactGroupListRequest, runtime: Util.RuntimeOptions): DescribeContactGroupListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContactGroupList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContactGroupList(request: DescribeContactGroupListRequest): DescribeContactGroupListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactGroupListWithOptions(request, runtime);
}

model DescribeContactListRequest {
  chanelType?: string(name='ChanelType'),
  chanelValue?: string(name='ChanelValue'),
  contactName?: string(name='ContactName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model DescribeContactListResponseBody = {
  code?: string(name='Code'),
  contacts?: {
    contact?: [ 
    {
      channels?: {
        aliIM?: string(name='AliIM'),
        dingWebHook?: string(name='DingWebHook'),
        mail?: string(name='Mail'),
        SMS?: string(name='SMS'),
      }(name='Channels'),
      channelsState?: {
        aliIM?: string(name='AliIM'),
        dingWebHook?: string(name='DingWebHook'),
        mail?: string(name='Mail'),
        SMS?: string(name='SMS'),
      }(name='ChannelsState'),
      contactGroups?: {
        contactGroup?: [ string ](name='ContactGroup')
      }(name='ContactGroups'),
      createTime?: long(name='CreateTime'),
      desc?: string(name='Desc'),
      lang?: string(name='Lang'),
      name?: string(name='Name'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='Contact')
  }(name='Contacts'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model DescribeContactListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContactListResponseBody(name='body'),
}

async function describeContactListWithOptions(request: DescribeContactListRequest, runtime: Util.RuntimeOptions): DescribeContactListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.chanelType)) {
    query['ChanelType'] = request.chanelType;
  }
  if (!Util.isUnset(request.chanelValue)) {
    query['ChanelValue'] = request.chanelValue;
  }
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContactList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContactList(request: DescribeContactListRequest): DescribeContactListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactListWithOptions(request, runtime);
}

model DescribeContactListByContactGroupRequest {
  contactGroupName?: string(name='ContactGroupName'),
  regionId?: string(name='RegionId'),
}

model DescribeContactListByContactGroupResponseBody = {
  code?: string(name='Code'),
  contacts?: {
    contact?: [ 
    {
      channels?: {
        aliIM?: string(name='AliIM'),
        dingWebHook?: string(name='DingWebHook'),
        mail?: string(name='Mail'),
        SMS?: string(name='SMS'),
      }(name='Channels'),
      createTime?: long(name='CreateTime'),
      desc?: string(name='Desc'),
      name?: string(name='Name'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='Contact')
  }(name='Contacts'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeContactListByContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContactListByContactGroupResponseBody(name='body'),
}

async function describeContactListByContactGroupWithOptions(request: DescribeContactListByContactGroupRequest, runtime: Util.RuntimeOptions): DescribeContactListByContactGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupName)) {
    query['ContactGroupName'] = request.contactGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContactListByContactGroup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContactListByContactGroup(request: DescribeContactListByContactGroupRequest): DescribeContactListByContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContactListByContactGroupWithOptions(request, runtime);
}

model DescribeCustomEventAttributeRequest {
  endTime?: string(name='EndTime'),
  eventId?: string(name='EventId'),
  groupId?: string(name='GroupId'),
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
}

model DescribeCustomEventAttributeResponseBody = {
  code?: string(name='Code'),
  customEvents?: {
    customEvent?: [ 
    {
      content?: string(name='Content'),
      groupId?: string(name='GroupId'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      time?: string(name='Time'),
    }
  ](name='CustomEvent')
  }(name='CustomEvents'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeCustomEventAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCustomEventAttributeResponseBody(name='body'),
}

async function describeCustomEventAttributeWithOptions(request: DescribeCustomEventAttributeRequest, runtime: Util.RuntimeOptions): DescribeCustomEventAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchKeywords)) {
    query['SearchKeywords'] = request.searchKeywords;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomEventAttribute',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCustomEventAttribute(request: DescribeCustomEventAttributeRequest): DescribeCustomEventAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomEventAttributeWithOptions(request, runtime);
}

model DescribeCustomEventCountRequest {
  endTime?: string(name='EndTime'),
  eventId?: string(name='EventId'),
  groupId?: string(name='GroupId'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
}

model DescribeCustomEventCountResponseBody = {
  code?: string(name='Code'),
  customEventCounts?: {
    customEventCount?: [ 
    {
      name?: string(name='Name'),
      num?: int32(name='Num'),
      time?: long(name='Time'),
    }
  ](name='CustomEventCount')
  }(name='CustomEventCounts'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeCustomEventCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCustomEventCountResponseBody(name='body'),
}

async function describeCustomEventCountWithOptions(request: DescribeCustomEventCountRequest, runtime: Util.RuntimeOptions): DescribeCustomEventCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.searchKeywords)) {
    query['SearchKeywords'] = request.searchKeywords;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomEventCount',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCustomEventCount(request: DescribeCustomEventCountRequest): DescribeCustomEventCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomEventCountWithOptions(request, runtime);
}

model DescribeCustomEventHistogramRequest {
  endTime?: string(name='EndTime'),
  eventId?: string(name='EventId'),
  groupId?: string(name='GroupId'),
  level?: string(name='Level'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
}

model DescribeCustomEventHistogramResponseBody = {
  code?: string(name='Code'),
  eventHistograms?: {
    eventHistogram?: [ 
    {
      count?: long(name='Count'),
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
    }
  ](name='EventHistogram')
  }(name='EventHistograms'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeCustomEventHistogramResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCustomEventHistogramResponseBody(name='body'),
}

async function describeCustomEventHistogramWithOptions(request: DescribeCustomEventHistogramRequest, runtime: Util.RuntimeOptions): DescribeCustomEventHistogramResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventId)) {
    query['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.searchKeywords)) {
    query['SearchKeywords'] = request.searchKeywords;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomEventHistogram',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCustomEventHistogram(request: DescribeCustomEventHistogramRequest): DescribeCustomEventHistogramResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomEventHistogramWithOptions(request, runtime);
}

model DescribeCustomMetricListRequest {
  dimension?: string(name='Dimension'),
  groupId?: string(name='GroupId'),
  md5?: string(name='Md5'),
  metricName?: string(name='MetricName'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model DescribeCustomMetricListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model DescribeCustomMetricListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCustomMetricListResponseBody(name='body'),
}

async function describeCustomMetricListWithOptions(request: DescribeCustomMetricListRequest, runtime: Util.RuntimeOptions): DescribeCustomMetricListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dimension)) {
    query['Dimension'] = request.dimension;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.md5)) {
    query['Md5'] = request.md5;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCustomMetricList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCustomMetricList(request: DescribeCustomMetricListRequest): DescribeCustomMetricListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCustomMetricListWithOptions(request, runtime);
}

model DescribeDynamicTagRuleListRequest {
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  tagKey?: string(name='TagKey'),
  tagRegionId?: string(name='TagRegionId'),
  tagValue?: string(name='TagValue'),
}

model DescribeDynamicTagRuleListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tagGroupList?: {
    tagGroup?: [ 
    {
      contactGroupList?: {
        contactGroupList?: [ string ](name='ContactGroupList')
      }(name='ContactGroupList'),
      dynamicTagRuleId?: string(name='DynamicTagRuleId'),
      matchExpress?: {
        matchExpress?: [ 
        {
          tagValue?: string(name='TagValue'),
          tagValueMatchFunction?: string(name='TagValueMatchFunction'),
        }
      ](name='MatchExpress')
      }(name='MatchExpress'),
      matchExpressFilterRelation?: string(name='MatchExpressFilterRelation'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      tagKey?: string(name='TagKey'),
      templateIdList?: {
        templateIdList?: [ string ](name='TemplateIdList')
      }(name='TemplateIdList'),
    }
  ](name='TagGroup')
  }(name='TagGroupList'),
  total?: int32(name='Total'),
}

model DescribeDynamicTagRuleListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDynamicTagRuleListResponseBody(name='body'),
}

async function describeDynamicTagRuleListWithOptions(request: DescribeDynamicTagRuleListRequest, runtime: Util.RuntimeOptions): DescribeDynamicTagRuleListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  if (!Util.isUnset(request.tagRegionId)) {
    query['TagRegionId'] = request.tagRegionId;
  }
  if (!Util.isUnset(request.tagValue)) {
    query['TagValue'] = request.tagValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDynamicTagRuleList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDynamicTagRuleList(request: DescribeDynamicTagRuleListRequest): DescribeDynamicTagRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDynamicTagRuleListWithOptions(request, runtime);
}

model DescribeEventRuleAttributeRequest {
  regionId?: string(name='RegionId'),
  ruleName?: string(name='RuleName'),
  silenceTime?: string(name='SilenceTime'),
}

model DescribeEventRuleAttributeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    description?: string(name='Description'),
    eventPattern?: {
      levelList?: {
        levelList?: [ string ](name='LevelList')
      }(name='LevelList'),
      nameList?: {
        nameList?: [ string ](name='NameList')
      }(name='NameList'),
      product?: string(name='Product'),
      statusList?: {
        statusList?: [ string ](name='StatusList')
      }(name='StatusList'),
    }(name='EventPattern'),
    eventType?: string(name='EventType'),
    groupId?: string(name='GroupId'),
    name?: string(name='Name'),
    state?: string(name='State'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model DescribeEventRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEventRuleAttributeResponseBody(name='body'),
}

async function describeEventRuleAttributeWithOptions(request: DescribeEventRuleAttributeRequest, runtime: Util.RuntimeOptions): DescribeEventRuleAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.silenceTime)) {
    query['SilenceTime'] = request.silenceTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEventRuleAttribute',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEventRuleAttribute(request: DescribeEventRuleAttributeRequest): DescribeEventRuleAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventRuleAttributeWithOptions(request, runtime);
}

model DescribeEventRuleListRequest {
  groupId?: string(name='GroupId'),
  namePrefix?: string(name='NamePrefix'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model DescribeEventRuleListResponseBody = {
  code?: string(name='Code'),
  eventRules?: {
    eventRule?: [ 
    {
      description?: string(name='Description'),
      eventPattern?: {
        eventPattern?: [ 
        {
          customFilters?: string(name='CustomFilters'),
          eventTypeList?: {
            eventTypeList?: [ string ](name='EventTypeList')
          }(name='EventTypeList'),
          keywordFilter?: {
            keywords?: {
              keywords?: [ string ](name='Keywords')
            }(name='Keywords'),
            relation?: string(name='Relation'),
          }(name='KeywordFilter'),
          levelList?: {
            levelList?: [ string ](name='LevelList')
          }(name='LevelList'),
          nameList?: {
            nameList?: [ string ](name='NameList')
          }(name='NameList'),
          product?: string(name='Product'),
          SQLFilter?: string(name='SQLFilter'),
        }
      ](name='EventPattern')
      }(name='EventPattern'),
      eventType?: string(name='EventType'),
      groupId?: string(name='GroupId'),
      name?: string(name='Name'),
      silenceTime?: long(name='SilenceTime'),
      state?: string(name='State'),
    }
  ](name='EventRule')
  }(name='EventRules'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model DescribeEventRuleListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEventRuleListResponseBody(name='body'),
}

async function describeEventRuleListWithOptions(request: DescribeEventRuleListRequest, runtime: Util.RuntimeOptions): DescribeEventRuleListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namePrefix)) {
    query['NamePrefix'] = request.namePrefix;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEventRuleList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEventRuleList(request: DescribeEventRuleListRequest): DescribeEventRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventRuleListWithOptions(request, runtime);
}

model DescribeEventRuleTargetListRequest {
  regionId?: string(name='RegionId'),
  ruleName?: string(name='RuleName'),
}

model DescribeEventRuleTargetListResponseBody = {
  code?: string(name='Code'),
  contactParameters?: {
    contactParameter?: [ 
    {
      contactGroupName?: string(name='ContactGroupName'),
      id?: string(name='Id'),
      level?: string(name='Level'),
    }
  ](name='ContactParameter')
  }(name='ContactParameters'),
  fcParameters?: {
    FCParameter?: [ 
    {
      arn?: string(name='Arn'),
      functionName?: string(name='FunctionName'),
      id?: string(name='Id'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='FCParameter')
  }(name='FcParameters'),
  message?: string(name='Message'),
  mnsParameters?: {
    mnsParameter?: [ 
    {
      arn?: string(name='Arn'),
      id?: string(name='Id'),
      queue?: string(name='Queue'),
      region?: string(name='Region'),
      topic?: string(name='Topic'),
    }
  ](name='MnsParameter')
  }(name='MnsParameters'),
  openApiParameters?: {
    openApiParameters?: [ 
    {
      action?: string(name='Action'),
      arn?: string(name='Arn'),
      id?: string(name='Id'),
      product?: string(name='Product'),
      region?: string(name='Region'),
      role?: string(name='Role'),
      version?: string(name='Version'),
    }
  ](name='OpenApiParameters')
  }(name='OpenApiParameters'),
  requestId?: string(name='RequestId'),
  slsParameters?: {
    slsParameter?: [ 
    {
      arn?: string(name='Arn'),
      id?: string(name='Id'),
      logStore?: string(name='LogStore'),
      project?: string(name='Project'),
      region?: string(name='Region'),
    }
  ](name='SlsParameter')
  }(name='SlsParameters'),
  webhookParameters?: {
    webhookParameter?: [ 
    {
      id?: string(name='Id'),
      method?: string(name='Method'),
      protocol?: string(name='Protocol'),
      url?: string(name='Url'),
    }
  ](name='WebhookParameter')
  }(name='WebhookParameters'),
}

model DescribeEventRuleTargetListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEventRuleTargetListResponseBody(name='body'),
}

async function describeEventRuleTargetListWithOptions(request: DescribeEventRuleTargetListRequest, runtime: Util.RuntimeOptions): DescribeEventRuleTargetListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEventRuleTargetList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEventRuleTargetList(request: DescribeEventRuleTargetListRequest): DescribeEventRuleTargetListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventRuleTargetListWithOptions(request, runtime);
}

model DescribeExporterOutputListRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model DescribeExporterOutputListResponseBody = {
  code?: string(name='Code'),
  datapoints?: {
    datapoint?: [ 
    {
      configJson?: {
        ak?: string(name='ak'),
        endpoint?: string(name='endpoint'),
        logstore?: string(name='logstore'),
        project?: string(name='project'),
      }(name='ConfigJson'),
      createTime?: long(name='CreateTime'),
      destName?: string(name='DestName'),
      destType?: string(name='DestType'),
    }
  ](name='Datapoint')
  }(name='Datapoints'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model DescribeExporterOutputListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeExporterOutputListResponseBody(name='body'),
}

async function describeExporterOutputListWithOptions(request: DescribeExporterOutputListRequest, runtime: Util.RuntimeOptions): DescribeExporterOutputListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExporterOutputList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeExporterOutputList(request: DescribeExporterOutputListRequest): DescribeExporterOutputListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExporterOutputListWithOptions(request, runtime);
}

model DescribeExporterRuleListRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model DescribeExporterRuleListResponseBody = {
  code?: string(name='Code'),
  datapoints?: {
    datapoint?: [ 
    {
      createTime?: long(name='CreateTime'),
      describe?: string(name='Describe'),
      dimension?: string(name='Dimension'),
      dstName?: {
        dstName?: [ string ](name='DstName')
      }(name='DstName'),
      enabled?: boolean(name='Enabled'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      ruleName?: string(name='RuleName'),
      targetWindows?: string(name='TargetWindows'),
    }
  ](name='Datapoint')
  }(name='Datapoints'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model DescribeExporterRuleListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeExporterRuleListResponseBody(name='body'),
}

async function describeExporterRuleListWithOptions(request: DescribeExporterRuleListRequest, runtime: Util.RuntimeOptions): DescribeExporterRuleListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeExporterRuleList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeExporterRuleList(request: DescribeExporterRuleListRequest): DescribeExporterRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeExporterRuleListWithOptions(request, runtime);
}

model DescribeGroupMonitoringAgentProcessRequest {
  groupId?: string(name='GroupId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  processName?: string(name='ProcessName'),
  regionId?: string(name='RegionId'),
}

model DescribeGroupMonitoringAgentProcessResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  processes?: {
    process?: [ 
    {
      alertConfig?: {
        alertConfig?: [ 
        {
          comparisonOperator?: string(name='ComparisonOperator'),
          effectiveInterval?: string(name='EffectiveInterval'),
          escalationsLevel?: string(name='EscalationsLevel'),
          noEffectiveInterval?: string(name='NoEffectiveInterval'),
          silenceTime?: string(name='SilenceTime'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: string(name='Times'),
          webhook?: string(name='Webhook'),
        }
      ](name='AlertConfig')
      }(name='AlertConfig'),
      groupId?: string(name='GroupId'),
      id?: string(name='Id'),
      matchExpress?: {
        matchExpress?: [ 
        {
          function?: string(name='Function'),
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='MatchExpress')
      }(name='MatchExpress'),
      matchExpressFilterRelation?: string(name='MatchExpressFilterRelation'),
      processName?: string(name='ProcessName'),
    }
  ](name='Process')
  }(name='Processes'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
}

model DescribeGroupMonitoringAgentProcessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGroupMonitoringAgentProcessResponseBody(name='body'),
}

async function describeGroupMonitoringAgentProcessWithOptions(request: DescribeGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): DescribeGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.processName)) {
    query['ProcessName'] = request.processName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGroupMonitoringAgentProcess',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGroupMonitoringAgentProcess(request: DescribeGroupMonitoringAgentProcessRequest): DescribeGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model DescribeHostAvailabilityListRequest {
  groupId?: long(name='GroupId'),
  id?: long(name='Id'),
  ids?: string(name='Ids'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  taskName?: string(name='TaskName'),
}

model DescribeHostAvailabilityListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskList?: {
    nodeTaskConfig?: [ 
    {
      alertConfig?: {
        endTime?: int32(name='EndTime'),
        escalationList?: {
          escalationList?: [ 
          {
            aggregate?: string(name='Aggregate'),
            metricName?: string(name='MetricName'),
            operator?: string(name='Operator'),
            times?: string(name='Times'),
            value?: string(name='Value'),
          }
        ](name='escalationList')
        }(name='EscalationList'),
        notifyType?: int32(name='NotifyType'),
        silenceTime?: int32(name='SilenceTime'),
        startTime?: int32(name='StartTime'),
        webHook?: string(name='WebHook'),
      }(name='AlertConfig'),
      disabled?: boolean(name='Disabled'),
      groupId?: long(name='GroupId'),
      groupName?: string(name='GroupName'),
      id?: long(name='Id'),
      instances?: {
        instance?: [ string ](name='Instance')
      }(name='Instances'),
      taskName?: string(name='TaskName'),
      taskOption?: {
        httpKeyword?: string(name='HttpKeyword'),
        httpMethod?: string(name='HttpMethod'),
        httpNegative?: boolean(name='HttpNegative'),
        httpPostContent?: string(name='HttpPostContent'),
        httpResponseCharset?: string(name='HttpResponseCharset'),
        httpURI?: string(name='HttpURI'),
        interval?: int32(name='Interval'),
        telnetOrPingHost?: string(name='TelnetOrPingHost'),
      }(name='TaskOption'),
      taskScope?: string(name='TaskScope'),
      taskType?: string(name='TaskType'),
    }
  ](name='NodeTaskConfig')
  }(name='TaskList'),
  total?: int32(name='Total'),
}

model DescribeHostAvailabilityListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHostAvailabilityListResponseBody(name='body'),
}

async function describeHostAvailabilityListWithOptions(request: DescribeHostAvailabilityListRequest, runtime: Util.RuntimeOptions): DescribeHostAvailabilityListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHostAvailabilityList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHostAvailabilityList(request: DescribeHostAvailabilityListRequest): DescribeHostAvailabilityListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHostAvailabilityListWithOptions(request, runtime);
}

model DescribeHybridMonitorDataListRequest {
  end?: long(name='End'),
  namespace?: string(name='Namespace'),
  period?: string(name='Period'),
  promSQL?: string(name='PromSQL'),
  regionId?: string(name='RegionId'),
  start?: long(name='Start'),
}

model DescribeHybridMonitorDataListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  timeSeries?: [ 
    {
      labels?: [ 
        {
          k?: string(name='K'),
          v?: string(name='V'),
        }
      ](name='Labels'),
      metricName?: string(name='MetricName'),
      values?: [ 
        {
          ts?: string(name='Ts'),
          v?: string(name='V'),
        }
      ](name='Values'),
    }
  ](name='TimeSeries'),
}

model DescribeHybridMonitorDataListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHybridMonitorDataListResponseBody(name='body'),
}

async function describeHybridMonitorDataListWithOptions(request: DescribeHybridMonitorDataListRequest, runtime: Util.RuntimeOptions): DescribeHybridMonitorDataListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.end)) {
    query['End'] = request.end;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.promSQL)) {
    query['PromSQL'] = request.promSQL;
  }
  if (!Util.isUnset(request.start)) {
    query['Start'] = request.start;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHybridMonitorDataList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHybridMonitorDataList(request: DescribeHybridMonitorDataListRequest): DescribeHybridMonitorDataListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHybridMonitorDataListWithOptions(request, runtime);
}

model DescribeHybridMonitorNamespaceListRequest {
  keyword?: string(name='Keyword'),
  namespace?: string(name='Namespace'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  showTaskStatistic?: boolean(name='ShowTaskStatistic'),
}

model DescribeHybridMonitorNamespaceListResponseBody = {
  code?: string(name='Code'),
  describeHybridMonitorNamespace?: [ 
    {
      aliyunProductMetricList?: [ 
        {
          namespaceList?: [ 
            {
              metricList?: [ 
                {
                  list?: [ string ](name='List'),
                  period?: long(name='Period'),
                }
              ](name='MetricList'),
              namespace?: string(name='Namespace'),
            }
          ](name='NamespaceList'),
          userId?: long(name='UserId'),
          YAMLConfig?: string(name='YAMLConfig'),
        }
      ](name='AliyunProductMetricList'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      detail?: {
        spec?: string(name='Spec'),
      }(name='Detail'),
      id?: string(name='Id'),
      isDelete?: int32(name='IsDelete'),
      modifyTime?: string(name='ModifyTime'),
      namespace?: string(name='Namespace'),
      notAliyunTaskNumber?: long(name='NotAliyunTaskNumber'),
    }
  ](name='DescribeHybridMonitorNamespace'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  total?: int32(name='Total'),
}

model DescribeHybridMonitorNamespaceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHybridMonitorNamespaceListResponseBody(name='body'),
}

async function describeHybridMonitorNamespaceListWithOptions(request: DescribeHybridMonitorNamespaceListRequest, runtime: Util.RuntimeOptions): DescribeHybridMonitorNamespaceListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.showTaskStatistic)) {
    query['ShowTaskStatistic'] = request.showTaskStatistic;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHybridMonitorNamespaceList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHybridMonitorNamespaceList(request: DescribeHybridMonitorNamespaceListRequest): DescribeHybridMonitorNamespaceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHybridMonitorNamespaceListWithOptions(request, runtime);
}

model DescribeHybridMonitorSLSGroupRequest {
  keyword?: string(name='Keyword'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
  SLSGroupName?: string(name='SLSGroupName'),
}

model DescribeHybridMonitorSLSGroupResponseBody = {
  code?: string(name='Code'),
  list?: [ 
    {
      createTime?: string(name='CreateTime'),
      SLSGroupConfig?: [ 
        {
          SLSLogstore?: string(name='SLSLogstore'),
          SLSProject?: string(name='SLSProject'),
          SLSRegion?: string(name='SLSRegion'),
          SLSUserId?: string(name='SLSUserId'),
        }
      ](name='SLSGroupConfig'),
      SLSGroupDescription?: string(name='SLSGroupDescription'),
      SLSGroupName?: string(name='SLSGroupName'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='List'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  total?: long(name='Total'),
}

model DescribeHybridMonitorSLSGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHybridMonitorSLSGroupResponseBody(name='body'),
}

async function describeHybridMonitorSLSGroupWithOptions(request: DescribeHybridMonitorSLSGroupRequest, runtime: Util.RuntimeOptions): DescribeHybridMonitorSLSGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.SLSGroupName)) {
    query['SLSGroupName'] = request.SLSGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHybridMonitorSLSGroup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHybridMonitorSLSGroup(request: DescribeHybridMonitorSLSGroupRequest): DescribeHybridMonitorSLSGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHybridMonitorSLSGroupWithOptions(request, runtime);
}

model DescribeHybridMonitorTaskListRequest {
  groupId?: string(name='GroupId'),
  includeAliyunTask?: boolean(name='IncludeAliyunTask'),
  keyword?: string(name='Keyword'),
  namespace?: string(name='Namespace'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  targetUserId?: long(name='TargetUserId'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model DescribeHybridMonitorTaskListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  taskList?: [ 
    {
      attachLabels?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='AttachLabels'),
      collectInterval?: int32(name='CollectInterval'),
      collectTargetEndpoint?: string(name='CollectTargetEndpoint'),
      collectTargetPath?: string(name='CollectTargetPath'),
      collectTargetType?: string(name='CollectTargetType'),
      collectTimout?: int32(name='CollectTimout'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      extraInfo?: string(name='ExtraInfo'),
      groupId?: string(name='GroupId'),
      instances?: [ string ](name='Instances'),
      logFilePath?: string(name='LogFilePath'),
      logProcess?: string(name='LogProcess'),
      logSample?: string(name='LogSample'),
      logSplit?: string(name='LogSplit'),
      matchExpress?: [ 
        {
          function?: string(name='Function'),
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='MatchExpress'),
      matchExpressRelation?: string(name='MatchExpressRelation'),
      namespace?: string(name='Namespace'),
      networkType?: string(name='NetworkType'),
      SLSProcess?: string(name='SLSProcess'),
      SLSProcessConfig?: {
        express?: [ 
          {
            alias?: string(name='Alias'),
            express?: string(name='Express'),
          }
        ](name='Express'),
        filter?: {
          filters?: [ 
            {
              operator?: string(name='Operator'),
              SLSKeyName?: string(name='SLSKeyName'),
              value?: string(name='Value'),
            }
          ](name='Filters'),
          relation?: string(name='Relation'),
        }(name='Filter'),
        groupBy?: [ 
          {
            alias?: string(name='Alias'),
            SLSKeyName?: string(name='SLSKeyName'),
          }
        ](name='GroupBy'),
        statistics?: [ 
          {
            alias?: string(name='Alias'),
            function?: string(name='Function'),
            parameter1?: string(name='Parameter1'),
            parameter2?: string(name='Parameter2'),
            SLSKeyName?: string(name='SLSKeyName'),
          }
        ](name='Statistics'),
      }(name='SLSProcessConfig'),
      targetUserId?: string(name='TargetUserId'),
      taskId?: string(name='TaskId'),
      taskName?: string(name='TaskName'),
      taskType?: string(name='TaskType'),
      uploadRegion?: string(name='UploadRegion'),
      YARMConfig?: string(name='YARMConfig'),
    }
  ](name='TaskList'),
  total?: int32(name='Total'),
}

model DescribeHybridMonitorTaskListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHybridMonitorTaskListResponseBody(name='body'),
}

async function describeHybridMonitorTaskListWithOptions(request: DescribeHybridMonitorTaskListRequest, runtime: Util.RuntimeOptions): DescribeHybridMonitorTaskListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.includeAliyunTask)) {
    query['IncludeAliyunTask'] = request.includeAliyunTask;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.targetUserId)) {
    query['TargetUserId'] = request.targetUserId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHybridMonitorTaskList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHybridMonitorTaskList(request: DescribeHybridMonitorTaskListRequest): DescribeHybridMonitorTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHybridMonitorTaskListWithOptions(request, runtime);
}

model DescribeLogMonitorAttributeRequest {
  metricName?: string(name='MetricName'),
  regionId?: string(name='RegionId'),
}

model DescribeLogMonitorAttributeResponseBody = {
  code?: string(name='Code'),
  logMonitor?: {
    aggregates?: [ 
      {
        alias?: string(name='Alias'),
        fieldName?: string(name='FieldName'),
        function?: string(name='Function'),
        max?: string(name='Max'),
        min?: string(name='Min'),
      }
    ](name='Aggregates'),
    gmtCreate?: long(name='GmtCreate'),
    groupId?: long(name='GroupId'),
    groupbys?: [ string ](name='Groupbys'),
    logId?: long(name='LogId'),
    metricExpress?: string(name='MetricExpress'),
    metricName?: string(name='MetricName'),
    slsLogstore?: string(name='SlsLogstore'),
    slsProject?: string(name='SlsProject'),
    slsRegionId?: string(name='SlsRegionId'),
    tumblingwindows?: [ string ](name='Tumblingwindows'),
    valueFilter?: [ 
      {
        key?: string(name='Key'),
        operator?: string(name='Operator'),
        value?: string(name='Value'),
      }
    ](name='ValueFilter'),
    valueFilterRelation?: string(name='ValueFilterRelation'),
  }(name='LogMonitor'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeLogMonitorAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLogMonitorAttributeResponseBody(name='body'),
}

async function describeLogMonitorAttributeWithOptions(request: DescribeLogMonitorAttributeRequest, runtime: Util.RuntimeOptions): DescribeLogMonitorAttributeResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogMonitorAttribute',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLogMonitorAttribute(request: DescribeLogMonitorAttributeRequest): DescribeLogMonitorAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogMonitorAttributeWithOptions(request, runtime);
}

model DescribeLogMonitorListRequest {
  groupId?: long(name='GroupId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  searchValue?: string(name='SearchValue'),
}

model DescribeLogMonitorListResponseBody = {
  code?: string(name='Code'),
  logMonitorList?: [ 
    {
      gmtCreate?: long(name='GmtCreate'),
      groupId?: long(name='GroupId'),
      logId?: long(name='LogId'),
      metricName?: string(name='MetricName'),
      slsLogstore?: string(name='SlsLogstore'),
      slsProject?: string(name='SlsProject'),
      slsRegionId?: string(name='SlsRegionId'),
      valueFilter?: [ 
        {
          key?: string(name='Key'),
          operator?: string(name='Operator'),
          value?: string(name='Value'),
        }
      ](name='ValueFilter'),
      valueFilterRelation?: string(name='ValueFilterRelation'),
    }
  ](name='LogMonitorList'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: long(name='Total'),
}

model DescribeLogMonitorListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLogMonitorListResponseBody(name='body'),
}

async function describeLogMonitorListWithOptions(request: DescribeLogMonitorListRequest, runtime: Util.RuntimeOptions): DescribeLogMonitorListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchValue)) {
    query['SearchValue'] = request.searchValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogMonitorList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLogMonitorList(request: DescribeLogMonitorListRequest): DescribeLogMonitorListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogMonitorListWithOptions(request, runtime);
}

model DescribeMetricDataRequest {
  dimensions?: string(name='Dimensions'),
  endTime?: string(name='EndTime'),
  express?: string(name='Express'),
  length?: string(name='Length'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  period?: string(name='Period'),
  regionId?: string(name='RegionId'),
  startTime?: string(name='StartTime'),
}

model DescribeMetricDataResponseBody = {
  code?: string(name='Code'),
  datapoints?: string(name='Datapoints'),
  message?: string(name='Message'),
  period?: string(name='Period'),
  requestId?: string(name='RequestId'),
}

model DescribeMetricDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMetricDataResponseBody(name='body'),
}

async function describeMetricDataWithOptions(request: DescribeMetricDataRequest, runtime: Util.RuntimeOptions): DescribeMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.express)) {
    query['Express'] = request.express;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetricData',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMetricData(request: DescribeMetricDataRequest): DescribeMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricDataWithOptions(request, runtime);
}

model DescribeMetricLastRequest {
  dimensions?: string(name='Dimensions'),
  endTime?: string(name='EndTime'),
  express?: string(name='Express'),
  length?: string(name='Length'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  nextToken?: string(name='NextToken'),
  period?: string(name='Period'),
  regionId?: string(name='RegionId'),
  startTime?: string(name='StartTime'),
}

model DescribeMetricLastResponseBody = {
  code?: string(name='Code'),
  datapoints?: string(name='Datapoints'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  period?: string(name='Period'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeMetricLastResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMetricLastResponseBody(name='body'),
}

async function describeMetricLastWithOptions(request: DescribeMetricLastRequest, runtime: Util.RuntimeOptions): DescribeMetricLastResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.express)) {
    query['Express'] = request.express;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetricLast',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMetricLast(request: DescribeMetricLastRequest): DescribeMetricLastResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricLastWithOptions(request, runtime);
}

model DescribeMetricListRequest {
  dimensions?: string(name='Dimensions'),
  endTime?: string(name='EndTime'),
  express?: string(name='Express'),
  length?: string(name='Length'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  nextToken?: string(name='NextToken'),
  period?: string(name='Period'),
  regionId?: string(name='RegionId'),
  startTime?: string(name='StartTime'),
}

model DescribeMetricListResponseBody = {
  code?: string(name='Code'),
  datapoints?: string(name='Datapoints'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  period?: string(name='Period'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeMetricListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMetricListResponseBody(name='body'),
}

async function describeMetricListWithOptions(request: DescribeMetricListRequest, runtime: Util.RuntimeOptions): DescribeMetricListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.express)) {
    query['Express'] = request.express;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetricList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMetricList(request: DescribeMetricListRequest): DescribeMetricListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricListWithOptions(request, runtime);
}

model DescribeMetricMetaListRequest {
  labels?: string(name='Labels'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model DescribeMetricMetaListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resources?: {
    resource?: [ 
    {
      description?: string(name='Description'),
      dimensions?: string(name='Dimensions'),
      labels?: string(name='Labels'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      periods?: string(name='Periods'),
      statistics?: string(name='Statistics'),
      unit?: string(name='Unit'),
    }
  ](name='Resource')
  }(name='Resources'),
  success?: boolean(name='Success'),
  totalCount?: string(name='TotalCount'),
}

model DescribeMetricMetaListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMetricMetaListResponseBody(name='body'),
}

async function describeMetricMetaListWithOptions(request: DescribeMetricMetaListRequest, runtime: Util.RuntimeOptions): DescribeMetricMetaListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetricMetaList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMetricMetaList(request: DescribeMetricMetaListRequest): DescribeMetricMetaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricMetaListWithOptions(request, runtime);
}

model DescribeMetricRuleBlackListRequest {
  category?: string(name='Category'),
  ids?: [ string ](name='Ids'),
  namespace?: string(name='Namespace'),
  order?: int32(name='Order'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model DescribeMetricRuleBlackListResponseBody = {
  code?: string(name='Code'),
  describeMetricRuleBlackList?: [ 
    {
      category?: string(name='Category'),
      createTime?: string(name='CreateTime'),
      effectiveTime?: string(name='EffectiveTime'),
      enableEndTime?: long(name='EnableEndTime'),
      enableStartTime?: long(name='EnableStartTime'),
      id?: string(name='Id'),
      instances?: [ string ](name='Instances'),
      isEnable?: boolean(name='IsEnable'),
      metrics?: [ 
        {
          metricName?: string(name='MetricName'),
          resource?: string(name='Resource'),
        }
      ](name='Metrics'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      scopeType?: string(name='ScopeType'),
      scopeValue?: [ string ](name='ScopeValue'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='DescribeMetricRuleBlackList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model DescribeMetricRuleBlackListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMetricRuleBlackListResponseBody(name='body'),
}

async function describeMetricRuleBlackListWithOptions(request: DescribeMetricRuleBlackListRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleBlackListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.ids)) {
    query['Ids'] = request.ids;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetricRuleBlackList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMetricRuleBlackList(request: DescribeMetricRuleBlackListRequest): DescribeMetricRuleBlackListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleBlackListWithOptions(request, runtime);
}

model DescribeMetricRuleCountRequest {
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  regionId?: string(name='RegionId'),
}

model DescribeMetricRuleCountResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  metricRuleCount?: {
    alarm?: int32(name='Alarm'),
    disable?: int32(name='Disable'),
    nodata?: int32(name='Nodata'),
    ok?: int32(name='Ok'),
    total?: int32(name='Total'),
  }(name='MetricRuleCount'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeMetricRuleCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMetricRuleCountResponseBody(name='body'),
}

async function describeMetricRuleCountWithOptions(request: DescribeMetricRuleCountRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleCountResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetricRuleCount',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMetricRuleCount(request: DescribeMetricRuleCountRequest): DescribeMetricRuleCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleCountWithOptions(request, runtime);
}

model DescribeMetricRuleListRequest {
  alertState?: string(name='AlertState'),
  dimensions?: string(name='Dimensions'),
  enableState?: boolean(name='EnableState'),
  groupId?: string(name='GroupId'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  ruleIds?: string(name='RuleIds'),
  ruleName?: string(name='RuleName'),
}

model DescribeMetricRuleListResponseBody = {
  alarms?: {
    alarm?: [ 
    {
      alertState?: string(name='AlertState'),
      compositeExpression?: {
        expressionList?: {
          expressionList?: [ 
          {
            comparisonOperator?: string(name='ComparisonOperator'),
            metricName?: string(name='MetricName'),
            period?: int32(name='Period'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
          }
        ](name='ExpressionList')
        }(name='ExpressionList'),
        expressionListJoin?: string(name='ExpressionListJoin'),
        expressionRaw?: string(name='ExpressionRaw'),
        level?: string(name='Level'),
        times?: int32(name='Times'),
      }(name='CompositeExpression'),
      contactGroups?: string(name='ContactGroups'),
      dimensions?: string(name='Dimensions'),
      effectiveInterval?: string(name='EffectiveInterval'),
      enableState?: boolean(name='EnableState'),
      escalations?: {
        critical?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          preCondition?: string(name='PreCondition'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: int32(name='Times'),
        }(name='Critical'),
        info?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          preCondition?: string(name='PreCondition'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: int32(name='Times'),
        }(name='Info'),
        warn?: {
          comparisonOperator?: string(name='ComparisonOperator'),
          preCondition?: string(name='PreCondition'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
          times?: int32(name='Times'),
        }(name='Warn'),
      }(name='Escalations'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      labels?: {
        labels?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Labels')
      }(name='Labels'),
      mailSubject?: string(name='MailSubject'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      noDataPolicy?: string(name='NoDataPolicy'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      period?: string(name='Period'),
      prometheus?: {
        annotations?: {
          annotations?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Annotations')
        }(name='Annotations'),
        level?: string(name='Level'),
        promQL?: string(name='PromQL'),
        times?: long(name='Times'),
      }(name='Prometheus'),
      resources?: string(name='Resources'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      silenceTime?: int32(name='SilenceTime'),
      sourceType?: string(name='SourceType'),
      webhook?: string(name='Webhook'),
    }
  ](name='Alarm')
  }(name='Alarms'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
}

model DescribeMetricRuleListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMetricRuleListResponseBody(name='body'),
}

async function describeMetricRuleListWithOptions(request: DescribeMetricRuleListRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertState)) {
    query['AlertState'] = request.alertState;
  }
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.enableState)) {
    query['EnableState'] = request.enableState;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleIds)) {
    query['RuleIds'] = request.ruleIds;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetricRuleList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMetricRuleList(request: DescribeMetricRuleListRequest): DescribeMetricRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleListWithOptions(request, runtime);
}

model DescribeMetricRuleTargetsRequest {
  regionId?: string(name='RegionId'),
  ruleId?: string(name='RuleId'),
}

model DescribeMetricRuleTargetsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  targets?: {
    target?: [ 
    {
      arn?: string(name='Arn'),
      id?: string(name='Id'),
      jsonParams?: string(name='JsonParams'),
      level?: string(name='Level'),
    }
  ](name='Target')
  }(name='Targets'),
}

model DescribeMetricRuleTargetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMetricRuleTargetsResponseBody(name='body'),
}

async function describeMetricRuleTargetsWithOptions(request: DescribeMetricRuleTargetsRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleTargetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetricRuleTargets',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMetricRuleTargets(request: DescribeMetricRuleTargetsRequest): DescribeMetricRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleTargetsWithOptions(request, runtime);
}

model DescribeMetricRuleTemplateAttributeRequest {
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  templateId?: string(name='TemplateId'),
}

model DescribeMetricRuleTemplateAttributeResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resource?: {
    alertTemplates?: {
      alertTemplate?: [ 
      {
        category?: string(name='Category'),
        escalations?: {
          critical?: {
            comparisonOperator?: string(name='ComparisonOperator'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
          }(name='Critical'),
          info?: {
            comparisonOperator?: string(name='ComparisonOperator'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
          }(name='Info'),
          warn?: {
            comparisonOperator?: string(name='ComparisonOperator'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
          }(name='Warn'),
        }(name='Escalations'),
        metricName?: string(name='MetricName'),
        namespace?: string(name='Namespace'),
        noDataPolicy?: string(name='NoDataPolicy'),
        ruleName?: string(name='RuleName'),
        selector?: string(name='Selector'),
        webhook?: string(name='Webhook'),
      }
    ](name='AlertTemplate')
    }(name='AlertTemplates'),
    description?: string(name='Description'),
    name?: string(name='Name'),
    restVersion?: string(name='RestVersion'),
    templateId?: string(name='TemplateId'),
  }(name='Resource'),
  success?: boolean(name='Success'),
}

model DescribeMetricRuleTemplateAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMetricRuleTemplateAttributeResponseBody(name='body'),
}

async function describeMetricRuleTemplateAttributeWithOptions(request: DescribeMetricRuleTemplateAttributeRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleTemplateAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetricRuleTemplateAttribute',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMetricRuleTemplateAttribute(request: DescribeMetricRuleTemplateAttributeRequest): DescribeMetricRuleTemplateAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleTemplateAttributeWithOptions(request, runtime);
}

model DescribeMetricRuleTemplateListRequest {
  history?: boolean(name='History'),
  keyword?: string(name='Keyword'),
  name?: string(name='Name'),
  order?: boolean(name='Order'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
  templateId?: long(name='TemplateId'),
}

model DescribeMetricRuleTemplateListResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  templates?: {
    template?: [ 
    {
      applyHistories?: {
        applyHistory?: [ 
        {
          applyTime?: long(name='ApplyTime'),
          groupId?: long(name='GroupId'),
          groupName?: string(name='GroupName'),
        }
      ](name='ApplyHistory')
      }(name='ApplyHistories'),
      description?: string(name='Description'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      name?: string(name='Name'),
      restVersion?: long(name='RestVersion'),
      templateId?: long(name='TemplateId'),
    }
  ](name='Template')
  }(name='Templates'),
  total?: long(name='Total'),
}

model DescribeMetricRuleTemplateListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMetricRuleTemplateListResponseBody(name='body'),
}

async function describeMetricRuleTemplateListWithOptions(request: DescribeMetricRuleTemplateListRequest, runtime: Util.RuntimeOptions): DescribeMetricRuleTemplateListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.history)) {
    query['History'] = request.history;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetricRuleTemplateList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMetricRuleTemplateList(request: DescribeMetricRuleTemplateListRequest): DescribeMetricRuleTemplateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricRuleTemplateListWithOptions(request, runtime);
}

model DescribeMetricTopRequest {
  dimensions?: string(name='Dimensions'),
  endTime?: string(name='EndTime'),
  express?: string(name='Express'),
  length?: string(name='Length'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  orderDesc?: string(name='OrderDesc'),
  orderby?: string(name='Orderby'),
  period?: string(name='Period'),
  regionId?: string(name='RegionId'),
  startTime?: string(name='StartTime'),
}

model DescribeMetricTopResponseBody = {
  code?: string(name='Code'),
  datapoints?: string(name='Datapoints'),
  message?: string(name='Message'),
  period?: string(name='Period'),
  requestId?: string(name='RequestId'),
}

model DescribeMetricTopResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMetricTopResponseBody(name='body'),
}

async function describeMetricTopWithOptions(request: DescribeMetricTopRequest, runtime: Util.RuntimeOptions): DescribeMetricTopResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.express)) {
    query['Express'] = request.express;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.orderDesc)) {
    query['OrderDesc'] = request.orderDesc;
  }
  if (!Util.isUnset(request.orderby)) {
    query['Orderby'] = request.orderby;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetricTop',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMetricTop(request: DescribeMetricTopRequest): DescribeMetricTopResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetricTopWithOptions(request, runtime);
}

model DescribeMonitorGroupCategoriesRequest {
  groupId?: long(name='GroupId'),
  regionId?: string(name='RegionId'),
}

model DescribeMonitorGroupCategoriesResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  monitorGroupCategories?: {
    groupId?: long(name='GroupId'),
    monitorGroupCategory?: {
      categoryItem?: [ 
      {
        category?: string(name='Category'),
        count?: int32(name='Count'),
      }
    ](name='CategoryItem')
    }(name='MonitorGroupCategory'),
  }(name='MonitorGroupCategories'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeMonitorGroupCategoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMonitorGroupCategoriesResponseBody(name='body'),
}

async function describeMonitorGroupCategoriesWithOptions(request: DescribeMonitorGroupCategoriesRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupCategoriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMonitorGroupCategories',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMonitorGroupCategories(request: DescribeMonitorGroupCategoriesRequest): DescribeMonitorGroupCategoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupCategoriesWithOptions(request, runtime);
}

model DescribeMonitorGroupDynamicRulesRequest {
  groupId?: long(name='GroupId'),
  regionId?: string(name='RegionId'),
}

model DescribeMonitorGroupDynamicRulesResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resource?: {
    resource?: [ 
    {
      category?: string(name='Category'),
      filterRelation?: string(name='FilterRelation'),
      filters?: {
        filter?: [ 
        {
          function?: string(name='Function'),
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Filter')
      }(name='Filters'),
    }
  ](name='Resource')
  }(name='Resource'),
  success?: boolean(name='Success'),
}

model DescribeMonitorGroupDynamicRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMonitorGroupDynamicRulesResponseBody(name='body'),
}

async function describeMonitorGroupDynamicRulesWithOptions(request: DescribeMonitorGroupDynamicRulesRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupDynamicRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMonitorGroupDynamicRules',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMonitorGroupDynamicRules(request: DescribeMonitorGroupDynamicRulesRequest): DescribeMonitorGroupDynamicRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupDynamicRulesWithOptions(request, runtime);
}

model DescribeMonitorGroupInstanceAttributeRequest {
  category?: string(name='Category'),
  groupId?: long(name='GroupId'),
  instanceIds?: string(name='InstanceIds'),
  keyword?: string(name='Keyword'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  total?: boolean(name='Total'),
}

model DescribeMonitorGroupInstanceAttributeResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  resources?: {
    resource?: [ 
    {
      category?: string(name='Category'),
      desc?: string(name='Desc'),
      dimension?: string(name='Dimension'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      networkType?: string(name='NetworkType'),
      region?: {
        availabilityZone?: string(name='AvailabilityZone'),
        regionId?: string(name='RegionId'),
      }(name='Region'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      vpc?: {
        vpcInstanceId?: string(name='VpcInstanceId'),
        vswitchInstanceId?: string(name='VswitchInstanceId'),
      }(name='Vpc'),
    }
  ](name='Resource')
  }(name='Resources'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model DescribeMonitorGroupInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMonitorGroupInstanceAttributeResponseBody(name='body'),
}

async function describeMonitorGroupInstanceAttributeWithOptions(request: DescribeMonitorGroupInstanceAttributeRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupInstanceAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.total)) {
    query['Total'] = request.total;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMonitorGroupInstanceAttribute',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMonitorGroupInstanceAttribute(request: DescribeMonitorGroupInstanceAttributeRequest): DescribeMonitorGroupInstanceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupInstanceAttributeWithOptions(request, runtime);
}

model DescribeMonitorGroupInstancesRequest {
  category?: string(name='Category'),
  groupId?: long(name='GroupId'),
  instanceIds?: string(name='InstanceIds'),
  keyword?: string(name='Keyword'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model DescribeMonitorGroupInstancesResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  resources?: {
    resource?: [ 
    {
      category?: string(name='Category'),
      id?: long(name='Id'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Resource')
  }(name='Resources'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model DescribeMonitorGroupInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMonitorGroupInstancesResponseBody(name='body'),
}

async function describeMonitorGroupInstancesWithOptions(request: DescribeMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMonitorGroupInstances',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMonitorGroupInstances(request: DescribeMonitorGroupInstancesRequest): DescribeMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupInstancesWithOptions(request, runtime);
}

model DescribeMonitorGroupNotifyPolicyListRequest {
  groupId?: string(name='GroupId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  policyType?: string(name='PolicyType'),
  regionId?: string(name='RegionId'),
}

model DescribeMonitorGroupNotifyPolicyListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  notifyPolicyList?: {
    notifyPolicy?: [ 
    {
      endTime?: long(name='EndTime'),
      groupId?: string(name='GroupId'),
      id?: string(name='Id'),
      startTime?: long(name='StartTime'),
      type?: string(name='Type'),
    }
  ](name='NotifyPolicy')
  }(name='NotifyPolicyList'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  total?: int32(name='Total'),
}

model DescribeMonitorGroupNotifyPolicyListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMonitorGroupNotifyPolicyListResponseBody(name='body'),
}

async function describeMonitorGroupNotifyPolicyListWithOptions(request: DescribeMonitorGroupNotifyPolicyListRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupNotifyPolicyListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.policyType)) {
    query['PolicyType'] = request.policyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMonitorGroupNotifyPolicyList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMonitorGroupNotifyPolicyList(request: DescribeMonitorGroupNotifyPolicyListRequest): DescribeMonitorGroupNotifyPolicyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupNotifyPolicyListWithOptions(request, runtime);
}

model DescribeMonitorGroupsRequest {
  dynamicTagRuleId?: string(name='DynamicTagRuleId'),
  groupFounderTagKey?: string(name='GroupFounderTagKey'),
  groupFounderTagValue?: string(name='GroupFounderTagValue'),
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  includeTemplateHistory?: boolean(name='IncludeTemplateHistory'),
  instanceId?: string(name='InstanceId'),
  keyword?: string(name='Keyword'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  selectContactGroups?: boolean(name='SelectContactGroups'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  type?: string(name='Type'),
}

model DescribeMonitorGroupsResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  resources?: {
    resource?: [ 
    {
      bindUrl?: string(name='BindUrl'),
      contactGroups?: {
        contactGroup?: [ 
        {
          name?: string(name='Name'),
        }
      ](name='ContactGroup')
      }(name='ContactGroups'),
      dynamicTagRuleId?: string(name='DynamicTagRuleId'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      groupFounderTagKey?: string(name='GroupFounderTagKey'),
      groupFounderTagValue?: string(name='GroupFounderTagValue'),
      groupId?: long(name='GroupId'),
      groupName?: string(name='GroupName'),
      serviceId?: string(name='ServiceId'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      templateIds?: {
        templateId?: [ string ](name='TemplateId')
      }(name='TemplateIds'),
      type?: string(name='Type'),
    }
  ](name='Resource')
  }(name='Resources'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model DescribeMonitorGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMonitorGroupsResponseBody(name='body'),
}

async function describeMonitorGroupsWithOptions(request: DescribeMonitorGroupsRequest, runtime: Util.RuntimeOptions): DescribeMonitorGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dynamicTagRuleId)) {
    query['DynamicTagRuleId'] = request.dynamicTagRuleId;
  }
  if (!Util.isUnset(request.groupFounderTagKey)) {
    query['GroupFounderTagKey'] = request.groupFounderTagKey;
  }
  if (!Util.isUnset(request.groupFounderTagValue)) {
    query['GroupFounderTagValue'] = request.groupFounderTagValue;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.includeTemplateHistory)) {
    query['IncludeTemplateHistory'] = request.includeTemplateHistory;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.selectContactGroups)) {
    query['SelectContactGroups'] = request.selectContactGroups;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMonitorGroups',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMonitorGroups(request: DescribeMonitorGroupsRequest): DescribeMonitorGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorGroupsWithOptions(request, runtime);
}

model DescribeMonitorResourceQuotaAttributeRequest {
  regionId?: string(name='RegionId'),
  showUsed?: boolean(name='ShowUsed'),
}

model DescribeMonitorResourceQuotaAttributeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resourceQuota?: {
    api?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='Api'),
    customMonitor?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='CustomMonitor'),
    enterpriseQuota?: {
      instanceId?: string(name='InstanceId'),
      suitInfo?: string(name='SuitInfo'),
    }(name='EnterpriseQuota'),
    eventMonitor?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='EventMonitor'),
    expireTime?: string(name='ExpireTime'),
    instanceId?: string(name='InstanceId'),
    logMonitor?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='LogMonitor'),
    phone?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='Phone'),
    SMS?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='SMS'),
    siteMonitorEcsProbe?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='SiteMonitorEcsProbe'),
    siteMonitorOperatorProbe?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='SiteMonitorOperatorProbe'),
    siteMonitorTask?: {
      quotaLimit?: int32(name='QuotaLimit'),
      quotaPackage?: int32(name='QuotaPackage'),
      quotaUsed?: int32(name='QuotaUsed'),
    }(name='SiteMonitorTask'),
    suitInfo?: string(name='SuitInfo'),
  }(name='ResourceQuota'),
}

model DescribeMonitorResourceQuotaAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMonitorResourceQuotaAttributeResponseBody(name='body'),
}

async function describeMonitorResourceQuotaAttributeWithOptions(request: DescribeMonitorResourceQuotaAttributeRequest, runtime: Util.RuntimeOptions): DescribeMonitorResourceQuotaAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.showUsed)) {
    query['ShowUsed'] = request.showUsed;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMonitorResourceQuotaAttribute',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMonitorResourceQuotaAttribute(request: DescribeMonitorResourceQuotaAttributeRequest): DescribeMonitorResourceQuotaAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitorResourceQuotaAttributeWithOptions(request, runtime);
}

model DescribeMonitoringAgentAccessKeyRequest {
  regionId?: string(name='RegionId'),
}

model DescribeMonitoringAgentAccessKeyResponseBody = {
  accessKey?: string(name='AccessKey'),
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  secretKey?: string(name='SecretKey'),
  success?: boolean(name='Success'),
}

model DescribeMonitoringAgentAccessKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMonitoringAgentAccessKeyResponseBody(name='body'),
}

async function describeMonitoringAgentAccessKeyWithOptions(request: DescribeMonitoringAgentAccessKeyRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentAccessKeyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
  };
  var params = new OpenApi.Params{
    action = 'DescribeMonitoringAgentAccessKey',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMonitoringAgentAccessKey(request: DescribeMonitoringAgentAccessKeyRequest): DescribeMonitoringAgentAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentAccessKeyWithOptions(request, runtime);
}

model DescribeMonitoringAgentConfigRequest {
  regionId?: string(name='RegionId'),
}

model DescribeMonitoringAgentConfigResponseBody = {
  autoInstall?: boolean(name='AutoInstall'),
  code?: string(name='Code'),
  enableActiveAlert?: string(name='EnableActiveAlert'),
  enableInstallAgentNewECS?: boolean(name='EnableInstallAgentNewECS'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeMonitoringAgentConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMonitoringAgentConfigResponseBody(name='body'),
}

async function describeMonitoringAgentConfigWithOptions(request: DescribeMonitoringAgentConfigRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
  };
  var params = new OpenApi.Params{
    action = 'DescribeMonitoringAgentConfig',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMonitoringAgentConfig(request: DescribeMonitoringAgentConfigRequest): DescribeMonitoringAgentConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentConfigWithOptions(request, runtime);
}

model DescribeMonitoringAgentHostsRequest {
  aliyunHost?: boolean(name='AliyunHost'),
  hostName?: string(name='HostName'),
  instanceIds?: string(name='InstanceIds'),
  instanceRegionId?: string(name='InstanceRegionId'),
  keyWord?: string(name='KeyWord'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  serialNumbers?: string(name='SerialNumbers'),
  status?: string(name='Status'),
}

model DescribeMonitoringAgentHostsResponseBody = {
  code?: string(name='Code'),
  hosts?: {
    host?: [ 
    {
      agentVersion?: string(name='AgentVersion'),
      aliUid?: long(name='AliUid'),
      eipAddress?: string(name='EipAddress'),
      eipId?: string(name='EipId'),
      hostName?: string(name='HostName'),
      instanceId?: string(name='InstanceId'),
      instanceTypeFamily?: string(name='InstanceTypeFamily'),
      ipGroup?: string(name='IpGroup'),
      natIp?: string(name='NatIp'),
      networkType?: string(name='NetworkType'),
      operatingSystem?: string(name='OperatingSystem'),
      region?: string(name='Region'),
      serialNumber?: string(name='SerialNumber'),
      isAliyunHost?: boolean(name='isAliyunHost'),
    }
  ](name='Host')
  }(name='Hosts'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  pageTotal?: int32(name='PageTotal'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model DescribeMonitoringAgentHostsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMonitoringAgentHostsResponseBody(name='body'),
}

async function describeMonitoringAgentHostsWithOptions(request: DescribeMonitoringAgentHostsRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentHostsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunHost)) {
    query['AliyunHost'] = request.aliyunHost;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.instanceRegionId)) {
    query['InstanceRegionId'] = request.instanceRegionId;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serialNumbers)) {
    query['SerialNumbers'] = request.serialNumbers;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMonitoringAgentHosts',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMonitoringAgentHosts(request: DescribeMonitoringAgentHostsRequest): DescribeMonitoringAgentHostsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentHostsWithOptions(request, runtime);
}

model DescribeMonitoringAgentProcessesRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model DescribeMonitoringAgentProcessesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nodeProcesses?: {
    nodeProcess?: [ 
    {
      command?: string(name='Command'),
      groupId?: string(name='GroupId'),
      instanceId?: string(name='InstanceId'),
      processId?: long(name='ProcessId'),
      processName?: string(name='ProcessName'),
      processUser?: string(name='ProcessUser'),
    }
  ](name='NodeProcess')
  }(name='NodeProcesses'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeMonitoringAgentProcessesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMonitoringAgentProcessesResponseBody(name='body'),
}

async function describeMonitoringAgentProcessesWithOptions(request: DescribeMonitoringAgentProcessesRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentProcessesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMonitoringAgentProcesses',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMonitoringAgentProcesses(request: DescribeMonitoringAgentProcessesRequest): DescribeMonitoringAgentProcessesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentProcessesWithOptions(request, runtime);
}

model DescribeMonitoringAgentStatusesRequest {
  instanceIds?: string(name='InstanceIds'),
  regionId?: string(name='RegionId'),
}

model DescribeMonitoringAgentStatusesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nodeStatusList?: {
    nodeStatus?: [ 
    {
      autoInstall?: boolean(name='AutoInstall'),
      instanceId?: string(name='InstanceId'),
      status?: string(name='Status'),
    }
  ](name='NodeStatus')
  }(name='NodeStatusList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeMonitoringAgentStatusesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMonitoringAgentStatusesResponseBody(name='body'),
}

async function describeMonitoringAgentStatusesWithOptions(request: DescribeMonitoringAgentStatusesRequest, runtime: Util.RuntimeOptions): DescribeMonitoringAgentStatusesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMonitoringAgentStatuses',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMonitoringAgentStatuses(request: DescribeMonitoringAgentStatusesRequest): DescribeMonitoringAgentStatusesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringAgentStatusesWithOptions(request, runtime);
}

model DescribeMonitoringConfigRequest {
  regionId?: string(name='RegionId'),
}

model DescribeMonitoringConfigResponseBody = {
  autoInstall?: boolean(name='AutoInstall'),
  code?: string(name='Code'),
  enableInstallAgentNewECS?: boolean(name='EnableInstallAgentNewECS'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeMonitoringConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMonitoringConfigResponseBody(name='body'),
}

async function describeMonitoringConfigWithOptions(request: DescribeMonitoringConfigRequest, runtime: Util.RuntimeOptions): DescribeMonitoringConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
  };
  var params = new OpenApi.Params{
    action = 'DescribeMonitoringConfig',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMonitoringConfig(request: DescribeMonitoringConfigRequest): DescribeMonitoringConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMonitoringConfigWithOptions(request, runtime);
}

model DescribeProductResourceTagKeyListRequest {
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
}

model DescribeProductResourceTagKeyListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tagKeys?: {
    tagKey?: [ string ](name='TagKey')
  }(name='TagKeys'),
}

model DescribeProductResourceTagKeyListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeProductResourceTagKeyListResponseBody(name='body'),
}

async function describeProductResourceTagKeyListWithOptions(request: DescribeProductResourceTagKeyListRequest, runtime: Util.RuntimeOptions): DescribeProductResourceTagKeyListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeProductResourceTagKeyList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeProductResourceTagKeyList(request: DescribeProductResourceTagKeyListRequest): DescribeProductResourceTagKeyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProductResourceTagKeyListWithOptions(request, runtime);
}

model DescribeProductsOfActiveMetricRuleRequest {
  regionId?: string(name='RegionId'),
}

model DescribeProductsOfActiveMetricRuleResponseBody = {
  allProductInitMetricRuleList?: {
    allProductInitMetricRule?: [ 
    {
      alertInitConfigList?: {
        alertInitConfig?: [ 
        {
          evaluationCount?: string(name='EvaluationCount'),
          metricName?: string(name='MetricName'),
          namespace?: string(name='Namespace'),
          period?: string(name='Period'),
          statistics?: string(name='Statistics'),
          threshold?: string(name='Threshold'),
        }
      ](name='AlertInitConfig')
      }(name='AlertInitConfigList'),
      product?: string(name='Product'),
    }
  ](name='AllProductInitMetricRule')
  }(name='AllProductInitMetricRuleList'),
  code?: int32(name='Code'),
  datapoints?: string(name='Datapoints'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeProductsOfActiveMetricRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeProductsOfActiveMetricRuleResponseBody(name='body'),
}

async function describeProductsOfActiveMetricRuleWithOptions(request: DescribeProductsOfActiveMetricRuleRequest, runtime: Util.RuntimeOptions): DescribeProductsOfActiveMetricRuleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
  };
  var params = new OpenApi.Params{
    action = 'DescribeProductsOfActiveMetricRule',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeProductsOfActiveMetricRule(request: DescribeProductsOfActiveMetricRuleRequest): DescribeProductsOfActiveMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProductsOfActiveMetricRuleWithOptions(request, runtime);
}

model DescribeProjectMetaRequest {
  labels?: string(name='Labels'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeProjectMetaResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  resources?: {
    resource?: [ 
    {
      description?: string(name='Description'),
      labels?: string(name='Labels'),
      namespace?: string(name='Namespace'),
    }
  ](name='Resource')
  }(name='Resources'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
}

model DescribeProjectMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeProjectMetaResponseBody(name='body'),
}

async function describeProjectMetaWithOptions(request: DescribeProjectMetaRequest, runtime: Util.RuntimeOptions): DescribeProjectMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeProjectMeta',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeProjectMeta(request: DescribeProjectMetaRequest): DescribeProjectMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProjectMetaWithOptions(request, runtime);
}

model DescribeSiteMonitorAttributeRequest {
  includeAlert?: boolean(name='IncludeAlert'),
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId'),
}

model DescribeSiteMonitorAttributeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  metricRules?: {
    metricRule?: [ 
    {
      actionEnable?: string(name='ActionEnable'),
      alarmActions?: string(name='AlarmActions'),
      comparisonOperator?: string(name='ComparisonOperator'),
      dimensions?: string(name='Dimensions'),
      evaluationCount?: string(name='EvaluationCount'),
      expression?: string(name='Expression'),
      level?: string(name='Level'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      okActions?: string(name='OkActions'),
      period?: string(name='Period'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      stateValue?: string(name='StateValue'),
      statistics?: string(name='Statistics'),
      threshold?: string(name='Threshold'),
    }
  ](name='MetricRule')
  }(name='MetricRules'),
  requestId?: string(name='RequestId'),
  siteMonitors?: {
    address?: string(name='Address'),
    interval?: string(name='Interval'),
    ispCities?: {
      ispCity?: [ 
      {
        city?: string(name='City'),
        cityName?: string(name='CityName'),
        isp?: string(name='Isp'),
        ispName?: string(name='IspName'),
      }
    ](name='IspCity')
    }(name='IspCities'),
    optionJson?: {
      attempts?: long(name='attempts'),
      authentication?: int32(name='authentication'),
      cookie?: string(name='cookie'),
      diagnosisMtr?: boolean(name='diagnosis_mtr'),
      diagnosisPing?: boolean(name='diagnosis_ping'),
      dnsMatchRule?: string(name='dns_match_rule'),
      dnsServer?: string(name='dns_server'),
      dnsType?: string(name='dns_type'),
      expectValue?: string(name='expect_value'),
      failureRate?: float(name='failure_rate'),
      header?: string(name='header'),
      httpMethod?: string(name='http_method'),
      isBase64Encode?: string(name='isBase64Encode'),
      matchRule?: int32(name='match_rule'),
      password?: string(name='password'),
      pingNum?: int32(name='ping_num'),
      port?: int32(name='port'),
      protocol?: string(name='protocol'),
      requestContent?: string(name='request_content'),
      requestFormat?: string(name='request_format'),
      responseContent?: string(name='response_content'),
      responseFormat?: string(name='response_format'),
      retryDelay?: int32(name='retry_delay'),
      timeOut?: long(name='time_out'),
      username?: string(name='username'),
    }(name='OptionJson'),
    taskId?: string(name='TaskId'),
    taskName?: string(name='TaskName'),
    taskState?: string(name='TaskState'),
    taskType?: string(name='TaskType'),
  }(name='SiteMonitors'),
  success?: boolean(name='Success'),
}

model DescribeSiteMonitorAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSiteMonitorAttributeResponseBody(name='body'),
}

async function describeSiteMonitorAttributeWithOptions(request: DescribeSiteMonitorAttributeRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.includeAlert)) {
    query['IncludeAlert'] = request.includeAlert;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSiteMonitorAttribute',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSiteMonitorAttribute(request: DescribeSiteMonitorAttributeRequest): DescribeSiteMonitorAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorAttributeWithOptions(request, runtime);
}

model DescribeSiteMonitorDataRequest {
  endTime?: string(name='EndTime'),
  length?: int32(name='Length'),
  metricName?: string(name='MetricName'),
  nextToken?: string(name='NextToken'),
  period?: string(name='Period'),
  regionId?: string(name='RegionId'),
  startTime?: string(name='StartTime'),
  taskId?: string(name='TaskId'),
  type?: string(name='Type'),
}

model DescribeSiteMonitorDataResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeSiteMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSiteMonitorDataResponseBody(name='body'),
}

async function describeSiteMonitorDataWithOptions(request: DescribeSiteMonitorDataRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSiteMonitorData',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSiteMonitorData(request: DescribeSiteMonitorDataRequest): DescribeSiteMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorDataWithOptions(request, runtime);
}

model DescribeSiteMonitorISPCityListRequest {
  city?: string(name='City'),
  IPV4?: boolean(name='IPV4'),
  IPV6?: boolean(name='IPV6'),
  isp?: string(name='Isp'),
  regionId?: string(name='RegionId'),
  viewAll?: boolean(name='ViewAll'),
}

model DescribeSiteMonitorISPCityListResponseBody = {
  code?: string(name='Code'),
  ispCityList?: {
    ispCity?: [ 
    {
      area_en?: string(name='Area.en'),
      area_zh_cN?: string(name='Area.zh_CN'),
      city?: string(name='City'),
      cityName_en?: string(name='CityName.en'),
      cityName_zh_cN?: string(name='CityName.zh_CN'),
      country?: string(name='Country'),
      country_en?: string(name='Country.en'),
      country_zh_cN?: string(name='Country.zh_CN'),
      IPPool?: {
        IPPool?: [ string ](name='IPPool')
      }(name='IPPool'),
      IPV4ProbeCount?: string(name='IPV4ProbeCount'),
      IPV6ProbeCount?: string(name='IPV6ProbeCount'),
      isp?: string(name='Isp'),
      ispName_en?: string(name='IspName.en'),
      ispName_zh_cN?: string(name='IspName.zh_CN'),
      region?: string(name='Region'),
      region_en?: string(name='Region.en'),
      region_zh_cN?: string(name='Region.zh_CN'),
    }
  ](name='IspCity')
  }(name='IspCityList'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeSiteMonitorISPCityListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSiteMonitorISPCityListResponseBody(name='body'),
}

async function describeSiteMonitorISPCityListWithOptions(request: DescribeSiteMonitorISPCityListRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorISPCityListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.city)) {
    query['City'] = request.city;
  }
  if (!Util.isUnset(request.IPV4)) {
    query['IPV4'] = request.IPV4;
  }
  if (!Util.isUnset(request.IPV6)) {
    query['IPV6'] = request.IPV6;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.viewAll)) {
    query['ViewAll'] = request.viewAll;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSiteMonitorISPCityList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSiteMonitorISPCityList(request: DescribeSiteMonitorISPCityListRequest): DescribeSiteMonitorISPCityListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorISPCityListWithOptions(request, runtime);
}

model DescribeSiteMonitorListRequest {
  keyword?: string(name='Keyword'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model DescribeSiteMonitorListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  siteMonitors?: {
    siteMonitor?: [ 
    {
      address?: string(name='Address'),
      createTime?: string(name='CreateTime'),
      interval?: string(name='Interval'),
      optionsJson?: {
        acceptableResponseCode?: string(name='acceptable_response_code'),
        attempts?: long(name='attempts'),
        authentication?: int32(name='authentication'),
        certVerify?: boolean(name='cert_verify'),
        cookie?: string(name='cookie'),
        diagnosisMtr?: boolean(name='diagnosis_mtr'),
        diagnosisPing?: boolean(name='diagnosis_ping'),
        dnsMatchRule?: string(name='dns_match_rule'),
        dnsServer?: string(name='dns_server'),
        dnsType?: string(name='dns_type'),
        enableOperatorDns?: boolean(name='enable_operator_dns'),
        failureRate?: float(name='failure_rate'),
        header?: string(name='header'),
        httpMethod?: string(name='http_method'),
        isBase64Encode?: string(name='isBase64Encode'),
        matchRule?: int32(name='match_rule'),
        password?: string(name='password'),
        pingNum?: int32(name='ping_num'),
        port?: int32(name='port'),
        protocol?: string(name='protocol'),
        proxyProtocol?: boolean(name='proxy_protocol'),
        requestContent?: string(name='request_content'),
        requestFormat?: string(name='request_format'),
        responseContent?: string(name='response_content'),
        responseFormat?: string(name='response_format'),
        retryDelay?: int32(name='retry_delay'),
        timeOut?: long(name='time_out'),
        unfollowRedirect?: boolean(name='unfollow_redirect'),
        username?: string(name='username'),
      }(name='OptionsJson'),
      taskId?: string(name='TaskId'),
      taskName?: string(name='TaskName'),
      taskState?: string(name='TaskState'),
      taskType?: string(name='TaskType'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='SiteMonitor')
  }(name='SiteMonitors'),
  success?: string(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSiteMonitorListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSiteMonitorListResponseBody(name='body'),
}

async function describeSiteMonitorListWithOptions(request: DescribeSiteMonitorListRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSiteMonitorList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSiteMonitorList(request: DescribeSiteMonitorListRequest): DescribeSiteMonitorListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorListWithOptions(request, runtime);
}

model DescribeSiteMonitorLogRequest {
  city?: string(name='City'),
  endTime?: string(name='EndTime'),
  filter?: string(name='Filter'),
  isp?: string(name='Isp'),
  length?: int32(name='Length'),
  metricName?: string(name='MetricName'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  startTime?: string(name='StartTime'),
  taskIds?: string(name='TaskIds'),
}

model DescribeSiteMonitorLogResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeSiteMonitorLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSiteMonitorLogResponseBody(name='body'),
}

async function describeSiteMonitorLogWithOptions(request: DescribeSiteMonitorLogRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.city)) {
    query['City'] = request.city;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.isp)) {
    query['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.length)) {
    query['Length'] = request.length;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.taskIds)) {
    query['TaskIds'] = request.taskIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSiteMonitorLog',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSiteMonitorLog(request: DescribeSiteMonitorLogRequest): DescribeSiteMonitorLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorLogWithOptions(request, runtime);
}

model DescribeSiteMonitorQuotaRequest {
  regionId?: string(name='RegionId'),
}

model DescribeSiteMonitorQuotaResponseBody = {
  code?: string(name='Code'),
  data?: {
    secondMonitor?: boolean(name='SecondMonitor'),
    siteMonitorIdcQuota?: int32(name='SiteMonitorIdcQuota'),
    siteMonitorOperatorQuotaQuota?: int32(name='SiteMonitorOperatorQuotaQuota'),
    siteMonitorQuotaTaskUsed?: int32(name='SiteMonitorQuotaTaskUsed'),
    siteMonitorTaskQuota?: int32(name='SiteMonitorTaskQuota'),
    siteMonitorVersion?: string(name='SiteMonitorVersion'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeSiteMonitorQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSiteMonitorQuotaResponseBody(name='body'),
}

async function describeSiteMonitorQuotaWithOptions(request: DescribeSiteMonitorQuotaRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorQuotaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
  };
  var params = new OpenApi.Params{
    action = 'DescribeSiteMonitorQuota',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSiteMonitorQuota(request: DescribeSiteMonitorQuotaRequest): DescribeSiteMonitorQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorQuotaWithOptions(request, runtime);
}

model DescribeSiteMonitorStatisticsRequest {
  metricName?: string(name='MetricName'),
  regionId?: string(name='RegionId'),
  startTime?: string(name='StartTime'),
  taskId?: string(name='TaskId'),
  timeRange?: string(name='TimeRange'),
}

model DescribeSiteMonitorStatisticsResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeSiteMonitorStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSiteMonitorStatisticsResponseBody(name='body'),
}

async function describeSiteMonitorStatisticsWithOptions(request: DescribeSiteMonitorStatisticsRequest, runtime: Util.RuntimeOptions): DescribeSiteMonitorStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.timeRange)) {
    query['TimeRange'] = request.timeRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSiteMonitorStatistics',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSiteMonitorStatistics(request: DescribeSiteMonitorStatisticsRequest): DescribeSiteMonitorStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSiteMonitorStatisticsWithOptions(request, runtime);
}

model DescribeSystemEventAttributeRequest {
  endTime?: string(name='EndTime'),
  eventType?: string(name='EventType'),
  groupId?: string(name='GroupId'),
  level?: string(name='Level'),
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  product?: string(name='Product'),
  regionId?: string(name='RegionId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
}

model DescribeSystemEventAttributeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  systemEvents?: {
    systemEvent?: [ 
    {
      content?: string(name='Content'),
      groupId?: string(name='GroupId'),
      instanceName?: string(name='InstanceName'),
      level?: string(name='Level'),
      name?: string(name='Name'),
      product?: string(name='Product'),
      regionId?: string(name='RegionId'),
      resourceId?: string(name='ResourceId'),
      status?: string(name='Status'),
      time?: long(name='Time'),
    }
  ](name='SystemEvent')
  }(name='SystemEvents'),
}

model DescribeSystemEventAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSystemEventAttributeResponseBody(name='body'),
}

async function describeSystemEventAttributeWithOptions(request: DescribeSystemEventAttributeRequest, runtime: Util.RuntimeOptions): DescribeSystemEventAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  if (!Util.isUnset(request.searchKeywords)) {
    query['SearchKeywords'] = request.searchKeywords;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSystemEventAttribute',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSystemEventAttribute(request: DescribeSystemEventAttributeRequest): DescribeSystemEventAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemEventAttributeWithOptions(request, runtime);
}

model DescribeSystemEventCountRequest {
  endTime?: string(name='EndTime'),
  eventType?: string(name='EventType'),
  groupId?: string(name='GroupId'),
  level?: string(name='Level'),
  name?: string(name='Name'),
  product?: string(name='Product'),
  regionId?: string(name='RegionId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
}

model DescribeSystemEventCountResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  systemEventCounts?: {
    systemEventCount?: [ 
    {
      content?: string(name='Content'),
      groupId?: string(name='GroupId'),
      instanceName?: string(name='InstanceName'),
      level?: string(name='Level'),
      name?: string(name='Name'),
      num?: long(name='Num'),
      product?: string(name='Product'),
      regionId?: string(name='RegionId'),
      resourceId?: string(name='ResourceId'),
      status?: string(name='Status'),
      time?: long(name='Time'),
    }
  ](name='SystemEventCount')
  }(name='SystemEventCounts'),
}

model DescribeSystemEventCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSystemEventCountResponseBody(name='body'),
}

async function describeSystemEventCountWithOptions(request: DescribeSystemEventCountRequest, runtime: Util.RuntimeOptions): DescribeSystemEventCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  if (!Util.isUnset(request.searchKeywords)) {
    query['SearchKeywords'] = request.searchKeywords;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSystemEventCount',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSystemEventCount(request: DescribeSystemEventCountRequest): DescribeSystemEventCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemEventCountWithOptions(request, runtime);
}

model DescribeSystemEventHistogramRequest {
  endTime?: string(name='EndTime'),
  eventType?: string(name='EventType'),
  groupId?: string(name='GroupId'),
  level?: string(name='Level'),
  name?: string(name='Name'),
  product?: string(name='Product'),
  regionId?: string(name='RegionId'),
  searchKeywords?: string(name='SearchKeywords'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
}

model DescribeSystemEventHistogramResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  systemEventHistograms?: {
    systemEventHistogram?: [ 
    {
      count?: long(name='Count'),
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
    }
  ](name='SystemEventHistogram')
  }(name='SystemEventHistograms'),
}

model DescribeSystemEventHistogramResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSystemEventHistogramResponseBody(name='body'),
}

async function describeSystemEventHistogramWithOptions(request: DescribeSystemEventHistogramRequest, runtime: Util.RuntimeOptions): DescribeSystemEventHistogramResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  if (!Util.isUnset(request.searchKeywords)) {
    query['SearchKeywords'] = request.searchKeywords;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSystemEventHistogram',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSystemEventHistogram(request: DescribeSystemEventHistogramRequest): DescribeSystemEventHistogramResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemEventHistogramWithOptions(request, runtime);
}

model DescribeSystemEventMetaListRequest {
  regionId?: string(name='RegionId'),
}

model DescribeSystemEventMetaListResponseBody = {
  code?: int32(name='Code'),
  data?: {
    resource?: [ 
    {
      eventType?: string(name='EventType'),
      level?: string(name='Level'),
      name?: string(name='Name'),
      nameDesc?: string(name='NameDesc'),
      nameDesc_en?: string(name='NameDesc.En'),
      product?: string(name='Product'),
      status?: string(name='Status'),
      statusDesc?: string(name='StatusDesc'),
    }
  ](name='Resource')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeSystemEventMetaListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSystemEventMetaListResponseBody(name='body'),
}

async function describeSystemEventMetaListWithOptions(request: DescribeSystemEventMetaListRequest, runtime: Util.RuntimeOptions): DescribeSystemEventMetaListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
  };
  var params = new OpenApi.Params{
    action = 'DescribeSystemEventMetaList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSystemEventMetaList(request: DescribeSystemEventMetaListRequest): DescribeSystemEventMetaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemEventMetaListWithOptions(request, runtime);
}

model DescribeTagKeyListRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model DescribeTagKeyListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tagKeys?: {
    tagKey?: [ string ](name='TagKey')
  }(name='TagKeys'),
}

model DescribeTagKeyListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTagKeyListResponseBody(name='body'),
}

async function describeTagKeyListWithOptions(request: DescribeTagKeyListRequest, runtime: Util.RuntimeOptions): DescribeTagKeyListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTagKeyList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTagKeyList(request: DescribeTagKeyListRequest): DescribeTagKeyListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagKeyListWithOptions(request, runtime);
}

model DescribeTagValueListRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  tagKey?: string(name='TagKey'),
}

model DescribeTagValueListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tagValues?: {
    tagValue?: [ string ](name='TagValue')
  }(name='TagValues'),
}

model DescribeTagValueListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTagValueListResponseBody(name='body'),
}

async function describeTagValueListWithOptions(request: DescribeTagValueListRequest, runtime: Util.RuntimeOptions): DescribeTagValueListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTagValueList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTagValueList(request: DescribeTagValueListRequest): DescribeTagValueListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagValueListWithOptions(request, runtime);
}

model DescribeUnhealthyHostAvailabilityRequest {
  id?: [ long ](name='Id'),
  regionId?: string(name='RegionId'),
}

model DescribeUnhealthyHostAvailabilityResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  unhealthyList?: {
    nodeTaskInstance?: [ 
    {
      id?: long(name='Id'),
      instanceList?: {
        string?: [ string ](name='String')
      }(name='InstanceList'),
    }
  ](name='NodeTaskInstance')
  }(name='UnhealthyList'),
}

model DescribeUnhealthyHostAvailabilityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUnhealthyHostAvailabilityResponseBody(name='body'),
}

async function describeUnhealthyHostAvailabilityWithOptions(request: DescribeUnhealthyHostAvailabilityRequest, runtime: Util.RuntimeOptions): DescribeUnhealthyHostAvailabilityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUnhealthyHostAvailability',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUnhealthyHostAvailability(request: DescribeUnhealthyHostAvailabilityRequest): DescribeUnhealthyHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUnhealthyHostAvailabilityWithOptions(request, runtime);
}

model DisableActiveMetricRuleRequest {
  product?: string(name='Product'),
  regionId?: string(name='RegionId'),
}

model DisableActiveMetricRuleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableActiveMetricRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableActiveMetricRuleResponseBody(name='body'),
}

async function disableActiveMetricRuleWithOptions(request: DisableActiveMetricRuleRequest, runtime: Util.RuntimeOptions): DisableActiveMetricRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableActiveMetricRule',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableActiveMetricRule(request: DisableActiveMetricRuleRequest): DisableActiveMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableActiveMetricRuleWithOptions(request, runtime);
}

model DisableEventRulesRequest {
  regionId?: string(name='RegionId'),
  ruleNames?: [ string ](name='RuleNames'),
}

model DisableEventRulesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableEventRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableEventRulesResponseBody(name='body'),
}

async function disableEventRulesWithOptions(request: DisableEventRulesRequest, runtime: Util.RuntimeOptions): DisableEventRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleNames)) {
    query['RuleNames'] = request.ruleNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableEventRules',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableEventRules(request: DisableEventRulesRequest): DisableEventRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableEventRulesWithOptions(request, runtime);
}

model DisableHostAvailabilityRequest {
  id?: [ long ](name='Id'),
  regionId?: string(name='RegionId'),
}

model DisableHostAvailabilityResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableHostAvailabilityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableHostAvailabilityResponseBody(name='body'),
}

async function disableHostAvailabilityWithOptions(request: DisableHostAvailabilityRequest, runtime: Util.RuntimeOptions): DisableHostAvailabilityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableHostAvailability',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableHostAvailability(request: DisableHostAvailabilityRequest): DisableHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableHostAvailabilityWithOptions(request, runtime);
}

model DisableMetricRulesRequest {
  regionId?: string(name='RegionId'),
  ruleId?: [ string ](name='RuleId'),
}

model DisableMetricRulesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableMetricRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableMetricRulesResponseBody(name='body'),
}

async function disableMetricRulesWithOptions(request: DisableMetricRulesRequest, runtime: Util.RuntimeOptions): DisableMetricRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableMetricRules',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableMetricRules(request: DisableMetricRulesRequest): DisableMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableMetricRulesWithOptions(request, runtime);
}

model DisableSiteMonitorsRequest {
  regionId?: string(name='RegionId'),
  taskIds?: string(name='TaskIds'),
}

model DisableSiteMonitorsResponseBody = {
  code?: string(name='Code'),
  data?: {
    count?: int32(name='count'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DisableSiteMonitorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableSiteMonitorsResponseBody(name='body'),
}

async function disableSiteMonitorsWithOptions(request: DisableSiteMonitorsRequest, runtime: Util.RuntimeOptions): DisableSiteMonitorsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskIds)) {
    query['TaskIds'] = request.taskIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableSiteMonitors',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableSiteMonitors(request: DisableSiteMonitorsRequest): DisableSiteMonitorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableSiteMonitorsWithOptions(request, runtime);
}

model EnableActiveMetricRuleRequest {
  product?: string(name='Product'),
  regionId?: string(name='RegionId'),
}

model EnableActiveMetricRuleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableActiveMetricRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableActiveMetricRuleResponseBody(name='body'),
}

async function enableActiveMetricRuleWithOptions(request: EnableActiveMetricRuleRequest, runtime: Util.RuntimeOptions): EnableActiveMetricRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableActiveMetricRule',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableActiveMetricRule(request: EnableActiveMetricRuleRequest): EnableActiveMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableActiveMetricRuleWithOptions(request, runtime);
}

model EnableEventRulesRequest {
  regionId?: string(name='RegionId'),
  ruleNames?: [ string ](name='RuleNames'),
}

model EnableEventRulesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableEventRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableEventRulesResponseBody(name='body'),
}

async function enableEventRulesWithOptions(request: EnableEventRulesRequest, runtime: Util.RuntimeOptions): EnableEventRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleNames)) {
    query['RuleNames'] = request.ruleNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableEventRules',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableEventRules(request: EnableEventRulesRequest): EnableEventRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableEventRulesWithOptions(request, runtime);
}

model EnableHostAvailabilityRequest {
  id?: [ long ](name='Id'),
  regionId?: string(name='RegionId'),
}

model EnableHostAvailabilityResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableHostAvailabilityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableHostAvailabilityResponseBody(name='body'),
}

async function enableHostAvailabilityWithOptions(request: EnableHostAvailabilityRequest, runtime: Util.RuntimeOptions): EnableHostAvailabilityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableHostAvailability',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableHostAvailability(request: EnableHostAvailabilityRequest): EnableHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableHostAvailabilityWithOptions(request, runtime);
}

model EnableMetricRuleBlackListRequest {
  id?: string(name='Id'),
  isEnable?: boolean(name='IsEnable'),
  regionId?: string(name='RegionId'),
}

model EnableMetricRuleBlackListResponseBody = {
  code?: string(name='Code'),
  count?: int32(name='Count'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableMetricRuleBlackListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableMetricRuleBlackListResponseBody(name='body'),
}

async function enableMetricRuleBlackListWithOptions(request: EnableMetricRuleBlackListRequest, runtime: Util.RuntimeOptions): EnableMetricRuleBlackListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.isEnable)) {
    query['IsEnable'] = request.isEnable;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableMetricRuleBlackList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableMetricRuleBlackList(request: EnableMetricRuleBlackListRequest): EnableMetricRuleBlackListResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableMetricRuleBlackListWithOptions(request, runtime);
}

model EnableMetricRulesRequest {
  regionId?: string(name='RegionId'),
  ruleId?: [ string ](name='RuleId'),
}

model EnableMetricRulesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableMetricRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableMetricRulesResponseBody(name='body'),
}

async function enableMetricRulesWithOptions(request: EnableMetricRulesRequest, runtime: Util.RuntimeOptions): EnableMetricRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableMetricRules',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableMetricRules(request: EnableMetricRulesRequest): EnableMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableMetricRulesWithOptions(request, runtime);
}

model EnableSiteMonitorsRequest {
  regionId?: string(name='RegionId'),
  taskIds?: string(name='TaskIds'),
}

model EnableSiteMonitorsResponseBody = {
  code?: string(name='Code'),
  data?: {
    count?: int32(name='count'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model EnableSiteMonitorsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableSiteMonitorsResponseBody(name='body'),
}

async function enableSiteMonitorsWithOptions(request: EnableSiteMonitorsRequest, runtime: Util.RuntimeOptions): EnableSiteMonitorsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskIds)) {
    query['TaskIds'] = request.taskIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableSiteMonitors',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableSiteMonitors(request: EnableSiteMonitorsRequest): EnableSiteMonitorsResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableSiteMonitorsWithOptions(request, runtime);
}

model InstallMonitoringAgentRequest {
  force?: boolean(name='Force'),
  installCommand?: string(name='InstallCommand'),
  instanceIds?: [ string ](name='InstanceIds'),
  regionId?: string(name='RegionId'),
}

model InstallMonitoringAgentResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InstallMonitoringAgentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallMonitoringAgentResponseBody(name='body'),
}

async function installMonitoringAgentWithOptions(request: InstallMonitoringAgentRequest, runtime: Util.RuntimeOptions): InstallMonitoringAgentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.installCommand)) {
    query['InstallCommand'] = request.installCommand;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallMonitoringAgent',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installMonitoringAgent(request: InstallMonitoringAgentRequest): InstallMonitoringAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return installMonitoringAgentWithOptions(request, runtime);
}

model ModifyGroupMonitoringAgentProcessRequest {
  alertConfig?: [ 
    {
      comparisonOperator?: string(name='ComparisonOperator'),
      effectiveInterval?: string(name='EffectiveInterval'),
      escalationsLevel?: string(name='EscalationsLevel'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      silenceTime?: string(name='SilenceTime'),
      statistics?: string(name='Statistics'),
      threshold?: string(name='Threshold'),
      times?: string(name='Times'),
      webhook?: string(name='Webhook'),
    }
  ](name='AlertConfig'),
  groupId?: string(name='GroupId'),
  id?: string(name='Id'),
  matchExpressFilterRelation?: string(name='MatchExpressFilterRelation'),
  regionId?: string(name='RegionId'),
}

model ModifyGroupMonitoringAgentProcessResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyGroupMonitoringAgentProcessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyGroupMonitoringAgentProcessResponseBody(name='body'),
}

async function modifyGroupMonitoringAgentProcessWithOptions(request: ModifyGroupMonitoringAgentProcessRequest, runtime: Util.RuntimeOptions): ModifyGroupMonitoringAgentProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertConfig)) {
    query['AlertConfig'] = request.alertConfig;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.matchExpressFilterRelation)) {
    query['MatchExpressFilterRelation'] = request.matchExpressFilterRelation;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyGroupMonitoringAgentProcess',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyGroupMonitoringAgentProcess(request: ModifyGroupMonitoringAgentProcessRequest): ModifyGroupMonitoringAgentProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyGroupMonitoringAgentProcessWithOptions(request, runtime);
}

model ModifyHostAvailabilityRequest {
  alertConfig?: {
    endTime?: int32(name='EndTime'),
    notifyType?: int32(name='NotifyType'),
    silenceTime?: int32(name='SilenceTime'),
    startTime?: int32(name='StartTime'),
    webHook?: string(name='WebHook'),
  }(name='AlertConfig'),
  taskOption?: {
    httpHeader?: string(name='HttpHeader'),
    httpMethod?: string(name='HttpMethod'),
    httpNegative?: boolean(name='HttpNegative'),
    httpPostContent?: string(name='HttpPostContent'),
    httpResponseCharset?: string(name='HttpResponseCharset'),
    httpResponseMatchContent?: string(name='HttpResponseMatchContent'),
    httpURI?: string(name='HttpURI'),
    interval?: int32(name='Interval'),
    telnetOrPingHost?: string(name='TelnetOrPingHost'),
  }(name='TaskOption'),
  alertConfigEscalationList?: [ 
    {
      aggregate?: string(name='Aggregate'),
      metricName?: string(name='MetricName'),
      operator?: string(name='Operator'),
      times?: int32(name='Times'),
      value?: string(name='Value'),
    }
  ](name='AlertConfigEscalationList'),
  groupId?: long(name='GroupId'),
  id?: long(name='Id'),
  instanceList?: [ string ](name='InstanceList'),
  regionId?: string(name='RegionId'),
  taskName?: string(name='TaskName'),
  taskScope?: string(name='TaskScope'),
}

model ModifyHostAvailabilityResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyHostAvailabilityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyHostAvailabilityResponseBody(name='body'),
}

async function modifyHostAvailabilityWithOptions(request: ModifyHostAvailabilityRequest, runtime: Util.RuntimeOptions): ModifyHostAvailabilityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertConfigEscalationList)) {
    query['AlertConfigEscalationList'] = request.alertConfigEscalationList;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.instanceList)) {
    query['InstanceList'] = request.instanceList;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.taskScope)) {
    query['TaskScope'] = request.taskScope;
  }
  if (!Util.isUnset(request.alertConfig)) {
    query['AlertConfig'] = request.alertConfig;
  }
  if (!Util.isUnset(request.taskOption)) {
    query['TaskOption'] = request.taskOption;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHostAvailability',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHostAvailability(request: ModifyHostAvailabilityRequest): ModifyHostAvailabilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHostAvailabilityWithOptions(request, runtime);
}

model ModifyHostInfoRequest {
  hostName?: string(name='HostName'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model ModifyHostInfoResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyHostInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyHostInfoResponseBody(name='body'),
}

async function modifyHostInfoWithOptions(request: ModifyHostInfoRequest, runtime: Util.RuntimeOptions): ModifyHostInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHostInfo',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHostInfo(request: ModifyHostInfoRequest): ModifyHostInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHostInfoWithOptions(request, runtime);
}

model ModifyHybridMonitorNamespaceRequest {
  description?: string(name='Description'),
  namespace?: string(name='Namespace'),
  regionId?: string(name='RegionId'),
  spec?: string(name='Spec'),
}

model ModifyHybridMonitorNamespaceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model ModifyHybridMonitorNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyHybridMonitorNamespaceResponseBody(name='body'),
}

async function modifyHybridMonitorNamespaceWithOptions(request: ModifyHybridMonitorNamespaceRequest, runtime: Util.RuntimeOptions): ModifyHybridMonitorNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.spec)) {
    query['Spec'] = request.spec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHybridMonitorNamespace',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHybridMonitorNamespace(request: ModifyHybridMonitorNamespaceRequest): ModifyHybridMonitorNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHybridMonitorNamespaceWithOptions(request, runtime);
}

model ModifyHybridMonitorSLSGroupRequest {
  regionId?: string(name='RegionId'),
  SLSGroupConfig?: [ 
    {
      SLSLogstore?: string(name='SLSLogstore'),
      SLSProject?: string(name='SLSProject'),
      SLSRegion?: string(name='SLSRegion'),
      SLSUserId?: string(name='SLSUserId'),
    }
  ](name='SLSGroupConfig'),
  SLSGroupDescription?: string(name='SLSGroupDescription'),
  SLSGroupName?: string(name='SLSGroupName'),
}

model ModifyHybridMonitorSLSGroupResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model ModifyHybridMonitorSLSGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyHybridMonitorSLSGroupResponseBody(name='body'),
}

async function modifyHybridMonitorSLSGroupWithOptions(request: ModifyHybridMonitorSLSGroupRequest, runtime: Util.RuntimeOptions): ModifyHybridMonitorSLSGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.SLSGroupConfig)) {
    query['SLSGroupConfig'] = request.SLSGroupConfig;
  }
  if (!Util.isUnset(request.SLSGroupDescription)) {
    query['SLSGroupDescription'] = request.SLSGroupDescription;
  }
  if (!Util.isUnset(request.SLSGroupName)) {
    query['SLSGroupName'] = request.SLSGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHybridMonitorSLSGroup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHybridMonitorSLSGroup(request: ModifyHybridMonitorSLSGroupRequest): ModifyHybridMonitorSLSGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHybridMonitorSLSGroupWithOptions(request, runtime);
}

model ModifyHybridMonitorTaskRequest {
  attachLabels?: [ 
    {
      name?: string(name='Name'),
      value?: string(name='Value'),
    }
  ](name='AttachLabels'),
  collectInterval?: string(name='CollectInterval'),
  description?: string(name='Description'),
  regionId?: string(name='RegionId'),
  SLSProcessConfig?: {
    express?: [ 
      {
        alias?: string(name='Alias'),
        express?: string(name='Express'),
      }
    ](name='Express'),
    filter?: {
      filters?: [ 
        {
          operator?: string(name='Operator'),
          SLSKeyName?: string(name='SLSKeyName'),
          value?: string(name='Value'),
        }
      ](name='Filters'),
      relation?: string(name='Relation'),
    }(name='Filter'),
    groupBy?: [ 
      {
        alias?: string(name='Alias'),
        SLSKeyName?: string(name='SLSKeyName'),
      }
    ](name='GroupBy'),
    statistics?: [ 
      {
        alias?: string(name='Alias'),
        function?: string(name='Function'),
        parameter1?: string(name='Parameter1'),
        parameter2?: string(name='Parameter2'),
        SLSKeyName?: string(name='SLSKeyName'),
      }
    ](name='Statistics'),
  }(name='SLSProcessConfig'),
  taskId?: string(name='TaskId'),
  taskName?: string(name='TaskName'),
}

model ModifyHybridMonitorTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model ModifyHybridMonitorTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyHybridMonitorTaskResponseBody(name='body'),
}

async function modifyHybridMonitorTaskWithOptions(request: ModifyHybridMonitorTaskRequest, runtime: Util.RuntimeOptions): ModifyHybridMonitorTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.attachLabels)) {
    query['AttachLabels'] = request.attachLabels;
  }
  if (!Util.isUnset(request.collectInterval)) {
    query['CollectInterval'] = request.collectInterval;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.SLSProcessConfig)) {
    query['SLSProcessConfig'] = request.SLSProcessConfig;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHybridMonitorTask',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHybridMonitorTask(request: ModifyHybridMonitorTaskRequest): ModifyHybridMonitorTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHybridMonitorTaskWithOptions(request, runtime);
}

model ModifyMetricRuleBlackListRequest {
  category?: string(name='Category'),
  effectiveTime?: string(name='EffectiveTime'),
  enableEndTime?: string(name='EnableEndTime'),
  enableStartTime?: string(name='EnableStartTime'),
  id?: string(name='Id'),
  instances?: [ string ](name='Instances'),
  metrics?: [ 
    {
      metricName?: string(name='MetricName'),
      resource?: string(name='Resource'),
    }
  ](name='Metrics'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  regionId?: string(name='RegionId'),
  scopeType?: string(name='ScopeType'),
  scopeValue?: string(name='ScopeValue'),
}

model ModifyMetricRuleBlackListResponseBody = {
  code?: string(name='Code'),
  count?: string(name='Count'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyMetricRuleBlackListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyMetricRuleBlackListResponseBody(name='body'),
}

async function modifyMetricRuleBlackListWithOptions(request: ModifyMetricRuleBlackListRequest, runtime: Util.RuntimeOptions): ModifyMetricRuleBlackListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.effectiveTime)) {
    query['EffectiveTime'] = request.effectiveTime;
  }
  if (!Util.isUnset(request.enableEndTime)) {
    query['EnableEndTime'] = request.enableEndTime;
  }
  if (!Util.isUnset(request.enableStartTime)) {
    query['EnableStartTime'] = request.enableStartTime;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.instances)) {
    query['Instances'] = request.instances;
  }
  if (!Util.isUnset(request.metrics)) {
    query['Metrics'] = request.metrics;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.scopeType)) {
    query['ScopeType'] = request.scopeType;
  }
  if (!Util.isUnset(request.scopeValue)) {
    query['ScopeValue'] = request.scopeValue;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyMetricRuleBlackList',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyMetricRuleBlackList(request: ModifyMetricRuleBlackListRequest): ModifyMetricRuleBlackListResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMetricRuleBlackListWithOptions(request, runtime);
}

model ModifyMetricRuleTemplateRequest {
  alertTemplates?: [ 
    {
      escalations: {
        critical: {
            comparisonOperator?: string(name='ComparisonOperator'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
        }(name='Critical'),
        info: {
            comparisonOperator?: string(name='ComparisonOperator'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
        }(name='Info'),
        warn: {
            comparisonOperator?: string(name='ComparisonOperator'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
        }(name='Warn'),
      }(name='Escalations'),
      category?: string(name='Category'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      period?: int32(name='Period'),
      ruleName?: string(name='RuleName'),
      selector?: string(name='Selector'),
      webhook?: string(name='Webhook'),
    }
  ](name='AlertTemplates'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  restVersion?: long(name='RestVersion'),
  templateId?: long(name='TemplateId'),
}

model ModifyMetricRuleTemplateResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyMetricRuleTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyMetricRuleTemplateResponseBody(name='body'),
}

async function modifyMetricRuleTemplateWithOptions(request: ModifyMetricRuleTemplateRequest, runtime: Util.RuntimeOptions): ModifyMetricRuleTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertTemplates)) {
    query['AlertTemplates'] = request.alertTemplates;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.restVersion)) {
    query['RestVersion'] = request.restVersion;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyMetricRuleTemplate',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyMetricRuleTemplate(request: ModifyMetricRuleTemplateRequest): ModifyMetricRuleTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMetricRuleTemplateWithOptions(request, runtime);
}

model ModifyMonitorGroupRequest {
  contactGroups?: string(name='ContactGroups'),
  groupId?: string(name='GroupId'),
  groupName?: string(name='GroupName'),
  regionId?: string(name='RegionId'),
}

model ModifyMonitorGroupResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyMonitorGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyMonitorGroupResponseBody(name='body'),
}

async function modifyMonitorGroupWithOptions(request: ModifyMonitorGroupRequest, runtime: Util.RuntimeOptions): ModifyMonitorGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroups)) {
    query['ContactGroups'] = request.contactGroups;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyMonitorGroup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyMonitorGroup(request: ModifyMonitorGroupRequest): ModifyMonitorGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMonitorGroupWithOptions(request, runtime);
}

model ModifyMonitorGroupInstancesRequest {
  groupId?: long(name='GroupId'),
  instances?: [ 
    {
      category?: string(name='Category'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      regionId?: string(name='RegionId'),
    }
  ](name='Instances'),
  regionId?: string(name='RegionId'),
}

model ModifyMonitorGroupInstancesResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyMonitorGroupInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyMonitorGroupInstancesResponseBody(name='body'),
}

async function modifyMonitorGroupInstancesWithOptions(request: ModifyMonitorGroupInstancesRequest, runtime: Util.RuntimeOptions): ModifyMonitorGroupInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.instances)) {
    query['Instances'] = request.instances;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyMonitorGroupInstances',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyMonitorGroupInstances(request: ModifyMonitorGroupInstancesRequest): ModifyMonitorGroupInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMonitorGroupInstancesWithOptions(request, runtime);
}

model ModifySiteMonitorRequest {
  address?: string(name='Address'),
  alertIds?: string(name='AlertIds'),
  interval?: string(name='Interval'),
  intervalUnit?: string(name='IntervalUnit'),
  ispCities?: string(name='IspCities'),
  optionsJson?: string(name='OptionsJson'),
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId'),
  taskName?: string(name='TaskName'),
}

model ModifySiteMonitorResponseBody = {
  code?: string(name='Code'),
  data?: {
    count?: int32(name='count'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model ModifySiteMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySiteMonitorResponseBody(name='body'),
}

async function modifySiteMonitorWithOptions(request: ModifySiteMonitorRequest, runtime: Util.RuntimeOptions): ModifySiteMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.alertIds)) {
    query['AlertIds'] = request.alertIds;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.intervalUnit)) {
    query['IntervalUnit'] = request.intervalUnit;
  }
  if (!Util.isUnset(request.ispCities)) {
    query['IspCities'] = request.ispCities;
  }
  if (!Util.isUnset(request.optionsJson)) {
    query['OptionsJson'] = request.optionsJson;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySiteMonitor',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySiteMonitor(request: ModifySiteMonitorRequest): ModifySiteMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySiteMonitorWithOptions(request, runtime);
}

model OpenCmsServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenCmsServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenCmsServiceResponseBody(name='body'),
}

async function openCmsServiceWithOptions(runtime: Util.RuntimeOptions): OpenCmsServiceResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'OpenCmsService',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openCmsService(): OpenCmsServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openCmsServiceWithOptions(runtime);
}

model PutContactRequest {
  channels?: {
    aliIM?: string(name='AliIM'),
    dingWebHook?: string(name='DingWebHook'),
    mail?: string(name='Mail'),
    SMS?: string(name='SMS'),
  }(name='Channels'),
  contactName?: string(name='ContactName'),
  describe?: string(name='Describe'),
  lang?: string(name='Lang'),
}

model PutContactResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutContactResponseBody(name='body'),
}

async function putContactWithOptions(request: PutContactRequest, runtime: Util.RuntimeOptions): PutContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactName)) {
    query['ContactName'] = request.contactName;
  }
  if (!Util.isUnset(request.describe)) {
    query['Describe'] = request.describe;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.channels)) {
    query['Channels'] = request.channels;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutContact',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putContact(request: PutContactRequest): PutContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return putContactWithOptions(request, runtime);
}

model PutContactGroupRequest {
  contactGroupName?: string(name='ContactGroupName'),
  contactNames?: [ string ](name='ContactNames'),
  describe?: string(name='Describe'),
  enableSubscribed?: boolean(name='EnableSubscribed'),
}

model PutContactGroupResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutContactGroupResponseBody(name='body'),
}

async function putContactGroupWithOptions(request: PutContactGroupRequest, runtime: Util.RuntimeOptions): PutContactGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroupName)) {
    query['ContactGroupName'] = request.contactGroupName;
  }
  if (!Util.isUnset(request.contactNames)) {
    query['ContactNames'] = request.contactNames;
  }
  if (!Util.isUnset(request.describe)) {
    query['Describe'] = request.describe;
  }
  if (!Util.isUnset(request.enableSubscribed)) {
    query['EnableSubscribed'] = request.enableSubscribed;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutContactGroup',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putContactGroup(request: PutContactGroupRequest): PutContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return putContactGroupWithOptions(request, runtime);
}

model PutCustomEventRequest {
  eventInfo?: [ 
    {
      content?: string(name='Content'),
      eventName?: string(name='EventName'),
      groupId?: string(name='GroupId'),
      time?: string(name='Time'),
    }
  ](name='EventInfo'),
  regionId?: string(name='RegionId'),
}

model PutCustomEventResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model PutCustomEventResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutCustomEventResponseBody(name='body'),
}

async function putCustomEventWithOptions(request: PutCustomEventRequest, runtime: Util.RuntimeOptions): PutCustomEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventInfo)) {
    query['EventInfo'] = request.eventInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutCustomEvent',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putCustomEvent(request: PutCustomEventRequest): PutCustomEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return putCustomEventWithOptions(request, runtime);
}

model PutCustomEventRuleRequest {
  contactGroups?: string(name='ContactGroups'),
  effectiveInterval?: string(name='EffectiveInterval'),
  emailSubject?: string(name='EmailSubject'),
  eventName?: string(name='EventName'),
  groupId?: string(name='GroupId'),
  level?: string(name='Level'),
  period?: string(name='Period'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  threshold?: string(name='Threshold'),
  webhook?: string(name='Webhook'),
}

model PutCustomEventRuleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutCustomEventRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutCustomEventRuleResponseBody(name='body'),
}

async function putCustomEventRuleWithOptions(request: PutCustomEventRuleRequest, runtime: Util.RuntimeOptions): PutCustomEventRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactGroups)) {
    query['ContactGroups'] = request.contactGroups;
  }
  if (!Util.isUnset(request.effectiveInterval)) {
    query['EffectiveInterval'] = request.effectiveInterval;
  }
  if (!Util.isUnset(request.emailSubject)) {
    query['EmailSubject'] = request.emailSubject;
  }
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  if (!Util.isUnset(request.webhook)) {
    query['Webhook'] = request.webhook;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutCustomEventRule',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putCustomEventRule(request: PutCustomEventRuleRequest): PutCustomEventRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putCustomEventRuleWithOptions(request, runtime);
}

model PutCustomMetricRequest {
  metricList?: [ 
    {
      dimensions?: string(name='Dimensions'),
      groupId?: string(name='GroupId'),
      metricName?: string(name='MetricName'),
      period?: string(name='Period'),
      time?: string(name='Time'),
      type?: string(name='Type'),
      values?: string(name='Values'),
    }
  ](name='MetricList'),
  regionId?: string(name='RegionId'),
}

model PutCustomMetricResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model PutCustomMetricResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutCustomMetricResponseBody(name='body'),
}

async function putCustomMetricWithOptions(request: PutCustomMetricRequest, runtime: Util.RuntimeOptions): PutCustomMetricResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.metricList)) {
    query['MetricList'] = request.metricList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutCustomMetric',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putCustomMetric(request: PutCustomMetricRequest): PutCustomMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return putCustomMetricWithOptions(request, runtime);
}

model PutCustomMetricRuleRequest {
  comparisonOperator?: string(name='ComparisonOperator'),
  contactGroups?: string(name='ContactGroups'),
  effectiveInterval?: string(name='EffectiveInterval'),
  emailSubject?: string(name='EmailSubject'),
  evaluationCount?: int32(name='EvaluationCount'),
  groupId?: string(name='GroupId'),
  level?: string(name='Level'),
  metricName?: string(name='MetricName'),
  period?: string(name='Period'),
  resources?: string(name='Resources'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  silenceTime?: int32(name='SilenceTime'),
  statistics?: string(name='Statistics'),
  threshold?: string(name='Threshold'),
  webhook?: string(name='Webhook'),
}

model PutCustomMetricRuleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutCustomMetricRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutCustomMetricRuleResponseBody(name='body'),
}

async function putCustomMetricRuleWithOptions(request: PutCustomMetricRuleRequest, runtime: Util.RuntimeOptions): PutCustomMetricRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comparisonOperator)) {
    query['ComparisonOperator'] = request.comparisonOperator;
  }
  if (!Util.isUnset(request.contactGroups)) {
    query['ContactGroups'] = request.contactGroups;
  }
  if (!Util.isUnset(request.effectiveInterval)) {
    query['EffectiveInterval'] = request.effectiveInterval;
  }
  if (!Util.isUnset(request.emailSubject)) {
    query['EmailSubject'] = request.emailSubject;
  }
  if (!Util.isUnset(request.evaluationCount)) {
    query['EvaluationCount'] = request.evaluationCount;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.resources)) {
    query['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.silenceTime)) {
    query['SilenceTime'] = request.silenceTime;
  }
  if (!Util.isUnset(request.statistics)) {
    query['Statistics'] = request.statistics;
  }
  if (!Util.isUnset(request.threshold)) {
    query['Threshold'] = request.threshold;
  }
  if (!Util.isUnset(request.webhook)) {
    query['Webhook'] = request.webhook;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutCustomMetricRule',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putCustomMetricRule(request: PutCustomMetricRuleRequest): PutCustomMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putCustomMetricRuleWithOptions(request, runtime);
}

model PutEventRuleRequest {
  description?: string(name='Description'),
  eventPattern?: [ 
    {
      customFilters?: string(name='CustomFilters'),
      eventTypeList?: [ string ](name='EventTypeList'),
      levelList?: [ string ](name='LevelList'),
      nameList?: [ string ](name='NameList'),
      product?: string(name='Product'),
      SQLFilter?: string(name='SQLFilter'),
      statusList?: [ string ](name='StatusList'),
    }
  ](name='EventPattern'),
  eventType?: string(name='EventType'),
  groupId?: string(name='GroupId'),
  regionId?: string(name='RegionId'),
  ruleName?: string(name='RuleName'),
  silenceTime?: long(name='SilenceTime'),
  state?: string(name='State'),
}

model PutEventRuleResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutEventRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutEventRuleResponseBody(name='body'),
}

async function putEventRuleWithOptions(request: PutEventRuleRequest, runtime: Util.RuntimeOptions): PutEventRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.eventPattern)) {
    query['EventPattern'] = request.eventPattern;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.silenceTime)) {
    query['SilenceTime'] = request.silenceTime;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutEventRule',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putEventRule(request: PutEventRuleRequest): PutEventRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putEventRuleWithOptions(request, runtime);
}

model PutEventRuleTargetsRequest {
  contactParameters?: [ 
    {
      contactGroupName?: string(name='ContactGroupName'),
      id?: string(name='Id'),
      level?: string(name='Level'),
    }
  ](name='ContactParameters'),
  fcParameters?: [ 
    {
      functionName?: string(name='FunctionName'),
      id?: string(name='Id'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='FcParameters'),
  mnsParameters?: [ 
    {
      id?: string(name='Id'),
      queue?: string(name='Queue'),
      region?: string(name='Region'),
      topic?: string(name='Topic'),
    }
  ](name='MnsParameters'),
  openApiParameters?: [ 
    {
      action?: string(name='Action'),
      arn?: string(name='Arn'),
      id?: string(name='Id'),
      jsonParams?: string(name='JsonParams'),
      product?: string(name='Product'),
      region?: string(name='Region'),
      role?: string(name='Role'),
      version?: string(name='Version'),
    }
  ](name='OpenApiParameters'),
  regionId?: string(name='RegionId'),
  ruleName?: string(name='RuleName'),
  slsParameters?: [ 
    {
      id?: string(name='Id'),
      logStore?: string(name='LogStore'),
      project?: string(name='Project'),
      region?: string(name='Region'),
    }
  ](name='SlsParameters'),
  webhookParameters?: [ 
    {
      id?: string(name='Id'),
      method?: string(name='Method'),
      protocol?: string(name='Protocol'),
      url?: string(name='Url'),
    }
  ](name='WebhookParameters'),
}

model PutEventRuleTargetsResponseBody = {
  code?: string(name='Code'),
  failedContactParameters?: {
    contactParameter?: [ 
    {
      contactGroupName?: string(name='ContactGroupName'),
      id?: int32(name='Id'),
      level?: string(name='Level'),
    }
  ](name='ContactParameter')
  }(name='FailedContactParameters'),
  failedFcParameters?: {
    fcParameter?: [ 
    {
      functionName?: string(name='FunctionName'),
      id?: int32(name='Id'),
      region?: string(name='Region'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='FcParameter')
  }(name='FailedFcParameters'),
  failedMnsParameters?: {
    mnsParameter?: [ 
    {
      id?: int32(name='Id'),
      queue?: string(name='Queue'),
      region?: string(name='Region'),
    }
  ](name='MnsParameter')
  }(name='FailedMnsParameters'),
  failedParameterCount?: string(name='FailedParameterCount'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutEventRuleTargetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutEventRuleTargetsResponseBody(name='body'),
}

async function putEventRuleTargetsWithOptions(request: PutEventRuleTargetsRequest, runtime: Util.RuntimeOptions): PutEventRuleTargetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactParameters)) {
    query['ContactParameters'] = request.contactParameters;
  }
  if (!Util.isUnset(request.fcParameters)) {
    query['FcParameters'] = request.fcParameters;
  }
  if (!Util.isUnset(request.mnsParameters)) {
    query['MnsParameters'] = request.mnsParameters;
  }
  if (!Util.isUnset(request.openApiParameters)) {
    query['OpenApiParameters'] = request.openApiParameters;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.slsParameters)) {
    query['SlsParameters'] = request.slsParameters;
  }
  if (!Util.isUnset(request.webhookParameters)) {
    query['WebhookParameters'] = request.webhookParameters;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutEventRuleTargets',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putEventRuleTargets(request: PutEventRuleTargetsRequest): PutEventRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putEventRuleTargetsWithOptions(request, runtime);
}

model PutExporterOutputRequest {
  configJson?: string(name='ConfigJson'),
  desc?: string(name='Desc'),
  destName?: string(name='DestName'),
  destType?: string(name='DestType'),
  regionId?: string(name='RegionId'),
}

model PutExporterOutputResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutExporterOutputResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutExporterOutputResponseBody(name='body'),
}

async function putExporterOutputWithOptions(request: PutExporterOutputRequest, runtime: Util.RuntimeOptions): PutExporterOutputResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configJson)) {
    query['ConfigJson'] = request.configJson;
  }
  if (!Util.isUnset(request.desc)) {
    query['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.destName)) {
    query['DestName'] = request.destName;
  }
  if (!Util.isUnset(request.destType)) {
    query['DestType'] = request.destType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutExporterOutput',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putExporterOutput(request: PutExporterOutputRequest): PutExporterOutputResponse {
  var runtime = new Util.RuntimeOptions{};
  return putExporterOutputWithOptions(request, runtime);
}

model PutExporterRuleRequest {
  describe?: string(name='Describe'),
  dstNames?: [ string ](name='DstNames'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  regionId?: string(name='RegionId'),
  ruleName?: string(name='RuleName'),
  targetWindows?: string(name='TargetWindows'),
}

model PutExporterRuleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutExporterRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutExporterRuleResponseBody(name='body'),
}

async function putExporterRuleWithOptions(request: PutExporterRuleRequest, runtime: Util.RuntimeOptions): PutExporterRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.describe)) {
    query['Describe'] = request.describe;
  }
  if (!Util.isUnset(request.dstNames)) {
    query['DstNames'] = request.dstNames;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.targetWindows)) {
    query['TargetWindows'] = request.targetWindows;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutExporterRule',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putExporterRule(request: PutExporterRuleRequest): PutExporterRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putExporterRuleWithOptions(request, runtime);
}

model PutGroupMetricRuleRequest {
  escalations?: {
    critical: {
        comparisonOperator?: string(name='ComparisonOperator'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Critical'),
    info: {
        comparisonOperator?: string(name='ComparisonOperator'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Info'),
    warn: {
        comparisonOperator?: string(name='ComparisonOperator'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Warn'),
  }(name='Escalations'),
  category?: string(name='Category'),
  contactGroups?: string(name='ContactGroups'),
  dimensions?: string(name='Dimensions'),
  effectiveInterval?: string(name='EffectiveInterval'),
  emailSubject?: string(name='EmailSubject'),
  extraDimensionJson?: string(name='ExtraDimensionJson'),
  groupId?: string(name='GroupId'),
  interval?: string(name='Interval'),
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  noDataPolicy?: string(name='NoDataPolicy'),
  noEffectiveInterval?: string(name='NoEffectiveInterval'),
  period?: string(name='Period'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  silenceTime?: int32(name='SilenceTime'),
  webhook?: string(name='Webhook'),
}

model PutGroupMetricRuleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  result?: {
    ruleId?: string(name='RuleId'),
  }(name='Result'),
  success?: boolean(name='Success'),
}

model PutGroupMetricRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutGroupMetricRuleResponseBody(name='body'),
}

async function putGroupMetricRuleWithOptions(request: PutGroupMetricRuleRequest, runtime: Util.RuntimeOptions): PutGroupMetricRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.contactGroups)) {
    query['ContactGroups'] = request.contactGroups;
  }
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.effectiveInterval)) {
    query['EffectiveInterval'] = request.effectiveInterval;
  }
  if (!Util.isUnset(request.emailSubject)) {
    query['EmailSubject'] = request.emailSubject;
  }
  if (!Util.isUnset(request.extraDimensionJson)) {
    query['ExtraDimensionJson'] = request.extraDimensionJson;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.noDataPolicy)) {
    query['NoDataPolicy'] = request.noDataPolicy;
  }
  if (!Util.isUnset(request.noEffectiveInterval)) {
    query['NoEffectiveInterval'] = request.noEffectiveInterval;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.silenceTime)) {
    query['SilenceTime'] = request.silenceTime;
  }
  if (!Util.isUnset(request.webhook)) {
    query['Webhook'] = request.webhook;
  }
  if (!Util.isUnset(request.escalations)) {
    query['Escalations'] = request.escalations;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutGroupMetricRule',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putGroupMetricRule(request: PutGroupMetricRuleRequest): PutGroupMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putGroupMetricRuleWithOptions(request, runtime);
}

model PutHybridMonitorMetricDataRequest {
  metricList?: [ 
    {
      labels?: [ 
        {
          key?: string(name='Key', description=''),
          value?: string(name='Value'),
        }
      ](name='Labels', description='Key'),
      name?: string(name='Name', description=''),
      TS?: long(name='TS', description='unix'),
      value?: string(name='Value', description=''),
    }
  ](name='MetricList', description=''),
  namespace?: string(name='Namespace'),
  regionId?: string(name='RegionId'),
}

model PutHybridMonitorMetricDataResponseBody = {
  code?: string(name='Code', description='code'),
  errorDetail?: [ 
    {
      errorMessage?: string(name='ErrorMessage', description=''),
      index?: long(name='Index', description='0'),
    }
  ](name='ErrorDetail', description=''),
  requestId?: string(name='RequestId', description='requestId'),
}

model PutHybridMonitorMetricDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutHybridMonitorMetricDataResponseBody(name='body'),
}

async function putHybridMonitorMetricDataWithOptions(request: PutHybridMonitorMetricDataRequest, runtime: Util.RuntimeOptions): PutHybridMonitorMetricDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.metricList)) {
    query['MetricList'] = request.metricList;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutHybridMonitorMetricData',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putHybridMonitorMetricData(request: PutHybridMonitorMetricDataRequest): PutHybridMonitorMetricDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return putHybridMonitorMetricDataWithOptions(request, runtime);
}

model PutLogMonitorRequest {
  aggregates?: [ 
    {
      alias?: string(name='Alias'),
      fieldName?: string(name='FieldName'),
      function?: string(name='Function'),
    }
  ](name='Aggregates'),
  groupId?: string(name='GroupId'),
  groupbys?: [ 
    {
      alias?: string(name='Alias'),
      fieldName?: string(name='FieldName'),
    }
  ](name='Groupbys'),
  logId?: string(name='LogId'),
  metricExpress?: string(name='MetricExpress'),
  metricName?: string(name='MetricName'),
  regionId?: string(name='RegionId'),
  slsLogstore?: string(name='SlsLogstore'),
  slsProject?: string(name='SlsProject'),
  slsRegionId?: string(name='SlsRegionId'),
  tumblingwindows?: string(name='Tumblingwindows'),
  unit?: string(name='Unit'),
  valueFilter?: [ 
    {
      key?: string(name='Key'),
      operator?: string(name='Operator'),
      value?: string(name='Value'),
    }
  ](name='ValueFilter'),
  valueFilterRelation?: string(name='ValueFilterRelation'),
}

model PutLogMonitorResponseBody = {
  code?: string(name='Code'),
  logId?: string(name='LogId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutLogMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutLogMonitorResponseBody(name='body'),
}

async function putLogMonitorWithOptions(request: PutLogMonitorRequest, runtime: Util.RuntimeOptions): PutLogMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aggregates)) {
    query['Aggregates'] = request.aggregates;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupbys)) {
    query['Groupbys'] = request.groupbys;
  }
  if (!Util.isUnset(request.logId)) {
    query['LogId'] = request.logId;
  }
  if (!Util.isUnset(request.metricExpress)) {
    query['MetricExpress'] = request.metricExpress;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.slsLogstore)) {
    query['SlsLogstore'] = request.slsLogstore;
  }
  if (!Util.isUnset(request.slsProject)) {
    query['SlsProject'] = request.slsProject;
  }
  if (!Util.isUnset(request.slsRegionId)) {
    query['SlsRegionId'] = request.slsRegionId;
  }
  if (!Util.isUnset(request.tumblingwindows)) {
    query['Tumblingwindows'] = request.tumblingwindows;
  }
  if (!Util.isUnset(request.unit)) {
    query['Unit'] = request.unit;
  }
  if (!Util.isUnset(request.valueFilter)) {
    query['ValueFilter'] = request.valueFilter;
  }
  if (!Util.isUnset(request.valueFilterRelation)) {
    query['ValueFilterRelation'] = request.valueFilterRelation;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutLogMonitor',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putLogMonitor(request: PutLogMonitorRequest): PutLogMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return putLogMonitorWithOptions(request, runtime);
}

model PutMetricRuleTargetsRequest {
  regionId?: string(name='RegionId'),
  ruleId?: string(name='RuleId'),
  targets?: [ 
    {
      arn?: string(name='Arn'),
      id?: string(name='Id'),
      jsonParams?: string(name='JsonParams'),
      level?: string(name='Level'),
    }
  ](name='Targets'),
}

model PutMetricRuleTargetsResponseBody = {
  code?: string(name='Code'),
  failData?: {
    targets?: {
      target?: [ 
      {
        arn?: string(name='Arn'),
        id?: string(name='Id'),
        level?: string(name='Level'),
      }
    ](name='Target')
    }(name='Targets'),
  }(name='FailData'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutMetricRuleTargetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutMetricRuleTargetsResponseBody(name='body'),
}

async function putMetricRuleTargetsWithOptions(request: PutMetricRuleTargetsRequest, runtime: Util.RuntimeOptions): PutMetricRuleTargetsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.targets)) {
    query['Targets'] = request.targets;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutMetricRuleTargets',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putMetricRuleTargets(request: PutMetricRuleTargetsRequest): PutMetricRuleTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  return putMetricRuleTargetsWithOptions(request, runtime);
}

model PutMonitorGroupDynamicRuleRequest {
  groupId?: long(name='GroupId'),
  groupRules?: [ 
    {
      category?: string(name='Category'),
      filterRelation?: string(name='FilterRelation'),
      filters?: [ 
        {
          function?: string(name='Function'),
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='Filters'),
    }
  ](name='GroupRules'),
  isAsync?: boolean(name='IsAsync'),
  regionId?: string(name='RegionId'),
}

model PutMonitorGroupDynamicRuleResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutMonitorGroupDynamicRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutMonitorGroupDynamicRuleResponseBody(name='body'),
}

async function putMonitorGroupDynamicRuleWithOptions(request: PutMonitorGroupDynamicRuleRequest, runtime: Util.RuntimeOptions): PutMonitorGroupDynamicRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.groupRules)) {
    query['GroupRules'] = request.groupRules;
  }
  if (!Util.isUnset(request.isAsync)) {
    query['IsAsync'] = request.isAsync;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutMonitorGroupDynamicRule',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putMonitorGroupDynamicRule(request: PutMonitorGroupDynamicRuleRequest): PutMonitorGroupDynamicRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putMonitorGroupDynamicRuleWithOptions(request, runtime);
}

model PutMonitoringConfigRequest {
  autoInstall?: boolean(name='AutoInstall'),
  enableInstallAgentNewECS?: boolean(name='EnableInstallAgentNewECS'),
  regionId?: string(name='RegionId'),
}

model PutMonitoringConfigResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutMonitoringConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutMonitoringConfigResponseBody(name='body'),
}

async function putMonitoringConfigWithOptions(request: PutMonitoringConfigRequest, runtime: Util.RuntimeOptions): PutMonitoringConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoInstall)) {
    query['AutoInstall'] = request.autoInstall;
  }
  if (!Util.isUnset(request.enableInstallAgentNewECS)) {
    query['EnableInstallAgentNewECS'] = request.enableInstallAgentNewECS;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutMonitoringConfig',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putMonitoringConfig(request: PutMonitoringConfigRequest): PutMonitoringConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return putMonitoringConfigWithOptions(request, runtime);
}

model PutResourceMetricRuleRequest {
  escalations?: {
    critical: {
        comparisonOperator?: string(name='ComparisonOperator'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Critical'),
    info: {
        comparisonOperator?: string(name='ComparisonOperator'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Info'),
    warn: {
        comparisonOperator?: string(name='ComparisonOperator'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Warn'),
  }(name='Escalations'),
  compositeExpression?: {
    expressionList?: [ 
      {
        comparisonOperator?: string(name='ComparisonOperator'),
        metricName?: string(name='MetricName'),
        period?: long(name='Period'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
      }
    ](name='ExpressionList'),
    expressionListJoin?: string(name='ExpressionListJoin'),
    expressionRaw?: string(name='ExpressionRaw'),
    level?: string(name='Level'),
    times?: int32(name='Times'),
  }(name='CompositeExpression'),
  contactGroups?: string(name='ContactGroups'),
  effectiveInterval?: string(name='EffectiveInterval'),
  emailSubject?: string(name='EmailSubject'),
  interval?: string(name='Interval'),
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  noDataPolicy?: string(name='NoDataPolicy'),
  noEffectiveInterval?: string(name='NoEffectiveInterval'),
  period?: string(name='Period'),
  prometheus?: {
    annotations?: [ 
      {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }
    ](name='Annotations'),
    level?: string(name='Level'),
    promQL?: string(name='PromQL'),
    times?: int32(name='Times'),
  }(name='Prometheus'),
  resources?: string(name='Resources'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  silenceTime?: int32(name='SilenceTime'),
  webhook?: string(name='Webhook'),
}

model PutResourceMetricRuleShrinkRequest {
  escalations?: {
    critical: {
        comparisonOperator?: string(name='ComparisonOperator'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Critical'),
    info: {
        comparisonOperator?: string(name='ComparisonOperator'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Info'),
    warn: {
        comparisonOperator?: string(name='ComparisonOperator'),
        statistics?: string(name='Statistics'),
        threshold?: string(name='Threshold'),
        times?: int32(name='Times'),
    }(name='Warn'),
  }(name='Escalations'),
  compositeExpressionShrink?: string(name='CompositeExpression'),
  contactGroups?: string(name='ContactGroups'),
  effectiveInterval?: string(name='EffectiveInterval'),
  emailSubject?: string(name='EmailSubject'),
  interval?: string(name='Interval'),
  labels?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Labels'),
  metricName?: string(name='MetricName'),
  namespace?: string(name='Namespace'),
  noDataPolicy?: string(name='NoDataPolicy'),
  noEffectiveInterval?: string(name='NoEffectiveInterval'),
  period?: string(name='Period'),
  prometheusShrink?: string(name='Prometheus'),
  resources?: string(name='Resources'),
  ruleId?: string(name='RuleId'),
  ruleName?: string(name='RuleName'),
  silenceTime?: int32(name='SilenceTime'),
  webhook?: string(name='Webhook'),
}

model PutResourceMetricRuleResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutResourceMetricRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutResourceMetricRuleResponseBody(name='body'),
}

async function putResourceMetricRuleWithOptions(tmpReq: PutResourceMetricRuleRequest, runtime: Util.RuntimeOptions): PutResourceMetricRuleResponse {
  Util.validateModel(tmpReq);
  var request = new PutResourceMetricRuleShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.compositeExpression)) {
    request.compositeExpressionShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.compositeExpression, 'CompositeExpression', 'json');
  }
  if (!Util.isUnset(tmpReq.prometheus)) {
    request.prometheusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.prometheus, 'Prometheus', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.compositeExpressionShrink)) {
    query['CompositeExpression'] = request.compositeExpressionShrink;
  }
  if (!Util.isUnset(request.contactGroups)) {
    query['ContactGroups'] = request.contactGroups;
  }
  if (!Util.isUnset(request.effectiveInterval)) {
    query['EffectiveInterval'] = request.effectiveInterval;
  }
  if (!Util.isUnset(request.emailSubject)) {
    query['EmailSubject'] = request.emailSubject;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.labels)) {
    query['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.metricName)) {
    query['MetricName'] = request.metricName;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.noDataPolicy)) {
    query['NoDataPolicy'] = request.noDataPolicy;
  }
  if (!Util.isUnset(request.noEffectiveInterval)) {
    query['NoEffectiveInterval'] = request.noEffectiveInterval;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.prometheusShrink)) {
    query['Prometheus'] = request.prometheusShrink;
  }
  if (!Util.isUnset(request.resources)) {
    query['Resources'] = request.resources;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.silenceTime)) {
    query['SilenceTime'] = request.silenceTime;
  }
  if (!Util.isUnset(request.webhook)) {
    query['Webhook'] = request.webhook;
  }
  if (!Util.isUnset(request.escalations)) {
    query['Escalations'] = request.escalations;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutResourceMetricRule',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putResourceMetricRule(request: PutResourceMetricRuleRequest): PutResourceMetricRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return putResourceMetricRuleWithOptions(request, runtime);
}

model PutResourceMetricRulesRequest {
  rules?: [ 
    {
      escalations: {
        critical: {
            comparisonOperator?: string(name='ComparisonOperator'),
            preCondition?: string(name='PreCondition'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
        }(name='Critical'),
        info: {
            comparisonOperator?: string(name='ComparisonOperator'),
            preCondition?: string(name='PreCondition'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
        }(name='Info'),
        warn: {
            comparisonOperator?: string(name='ComparisonOperator'),
            preCondition?: string(name='PreCondition'),
            statistics?: string(name='Statistics'),
            threshold?: string(name='Threshold'),
            times?: int32(name='Times'),
        }(name='Warn'),
      }(name='Escalations'),
      contactGroups?: string(name='ContactGroups'),
      effectiveInterval?: string(name='EffectiveInterval'),
      emailSubject?: string(name='EmailSubject'),
      interval?: string(name='Interval'),
      labels?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Labels'),
      metricName?: string(name='MetricName'),
      namespace?: string(name='Namespace'),
      noDataPolicy?: string(name='NoDataPolicy'),
      noEffectiveInterval?: string(name='NoEffectiveInterval'),
      period?: string(name='Period'),
      resources?: string(name='Resources'),
      ruleId?: string(name='RuleId'),
      ruleName?: string(name='RuleName'),
      silenceTime?: int32(name='SilenceTime'),
      webhook?: string(name='Webhook'),
    }
  ](name='Rules'),
}

model PutResourceMetricRulesResponseBody = {
  code?: string(name='Code'),
  failedListResult?: {
    target?: [ 
    {
      result?: {
        code?: string(name='Code'),
        message?: string(name='Message'),
        success?: boolean(name='Success'),
      }(name='Result'),
      ruleId?: string(name='RuleId'),
    }
  ](name='Target')
  }(name='FailedListResult'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PutResourceMetricRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutResourceMetricRulesResponseBody(name='body'),
}

async function putResourceMetricRulesWithOptions(request: PutResourceMetricRulesRequest, runtime: Util.RuntimeOptions): PutResourceMetricRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.rules)) {
    query['Rules'] = request.rules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutResourceMetricRules',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function putResourceMetricRules(request: PutResourceMetricRulesRequest): PutResourceMetricRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return putResourceMetricRulesWithOptions(request, runtime);
}

model RemoveTagsRequest {
  groupIds?: [ string ](name='GroupIds'),
  regionId?: string(name='RegionId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model RemoveTagsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tag?: {
    tags?: [ string ](name='Tags')
  }(name='Tag'),
}

model RemoveTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveTagsResponseBody(name='body'),
}

async function removeTagsWithOptions(request: RemoveTagsRequest, runtime: Util.RuntimeOptions): RemoveTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupIds)) {
    query['GroupIds'] = request.groupIds;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveTags',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeTags(request: RemoveTagsRequest): RemoveTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeTagsWithOptions(request, runtime);
}

model SendDryRunSystemEventRequest {
  eventContent?: string(name='EventContent'),
  eventName?: string(name='EventName'),
  groupId?: string(name='GroupId'),
  product?: string(name='Product'),
  regionId?: string(name='RegionId'),
}

model SendDryRunSystemEventResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model SendDryRunSystemEventResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendDryRunSystemEventResponseBody(name='body'),
}

async function sendDryRunSystemEventWithOptions(request: SendDryRunSystemEventRequest, runtime: Util.RuntimeOptions): SendDryRunSystemEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventContent)) {
    query['EventContent'] = request.eventContent;
  }
  if (!Util.isUnset(request.eventName)) {
    query['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.product)) {
    query['Product'] = request.product;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SendDryRunSystemEvent',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendDryRunSystemEvent(request: SendDryRunSystemEventRequest): SendDryRunSystemEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendDryRunSystemEventWithOptions(request, runtime);
}

model UninstallMonitoringAgentRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model UninstallMonitoringAgentResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UninstallMonitoringAgentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallMonitoringAgentResponseBody(name='body'),
}

async function uninstallMonitoringAgentWithOptions(request: UninstallMonitoringAgentRequest, runtime: Util.RuntimeOptions): UninstallMonitoringAgentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallMonitoringAgent',
    version = '2019-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallMonitoringAgent(request: UninstallMonitoringAgentRequest): UninstallMonitoringAgentResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallMonitoringAgentWithOptions(request, runtime);
}

