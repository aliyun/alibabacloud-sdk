/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'amqp-open';
  @version = '2019-12-12';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model CreateBindingRequest {
  argument?: string(name='Argument', position='Body'),
  bindingKey: string(name='BindingKey', position='Body'),
  bindingType: string(name='BindingType', position='Body'),
  destinationName: string(name='DestinationName', position='Body'),
  instanceId: string(name='InstanceId', position='Body'),
  regionId: string(name='RegionId', position='Host'),
  sourceExchange: string(name='SourceExchange', position='Body'),
  virtualHost: string(name='VirtualHost', position='Body'),
}

model CreateBindingResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateBindingResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBindingResponseBody(name='body'),
}

async function createBinding(request: CreateBindingRequest): CreateBindingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBinding', 'POST', '/', 'json', true, 'form', request);
}

model CreateExchangeRequest {
  alternateExchange?: string(name='AlternateExchange', position='Body'),
  autoDeleteState: boolean(name='AutoDeleteState', position='Body'),
  exchangeName: string(name='ExchangeName', position='Body'),
  exchangeType: string(name='ExchangeType', position='Body'),
  instanceId: string(name='InstanceId', position='Body'),
  internal: boolean(name='Internal', position='Body'),
  regionId: string(name='RegionId', position='Host'),
  virtualHost: string(name='VirtualHost', position='Body'),
}

model CreateExchangeResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateExchangeResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExchangeResponseBody(name='body'),
}

async function createExchange(request: CreateExchangeRequest): CreateExchangeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateExchange', 'POST', '/', 'json', true, 'form', request);
}

model CreateQueueRequest {
  autoDeleteState?: boolean(name='AutoDeleteState', position='Body'),
  autoExpireState?: long(name='AutoExpireState', position='Body'),
  deadLetterExchange?: string(name='DeadLetterExchange', position='Body'),
  deadLetterRoutingKey?: string(name='DeadLetterRoutingKey', position='Body'),
  exclusiveState?: boolean(name='ExclusiveState', position='Body'),
  instanceId: string(name='InstanceId', position='Body'),
  maxLength?: long(name='MaxLength', position='Body'),
  maximumPriority?: int32(name='MaximumPriority', position='Body'),
  messageTTL?: long(name='MessageTTL', position='Body'),
  queueName: string(name='QueueName', position='Body'),
  regionId: string(name='RegionId', position='Host'),
  virtualHost: string(name='VirtualHost', position='Body'),
}

model CreateQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateQueueResponse = {
  headers: map[string]string(name='headers'),
  body: CreateQueueResponseBody(name='body'),
}

async function createQueue(request: CreateQueueRequest): CreateQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateQueue', 'POST', '/', 'json', true, 'form', request);
}

model CreateVirtualHostRequest {
  instanceId: string(name='InstanceId', position='Body'),
  regionId: string(name='RegionId', position='Host'),
  virtualHost: string(name='VirtualHost', position='Body'),
}

model CreateVirtualHostResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateVirtualHostResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVirtualHostResponseBody(name='body'),
}

async function createVirtualHost(request: CreateVirtualHostRequest): CreateVirtualHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVirtualHost', 'POST', '/', 'json', true, 'form', request);
}

model DeleteBindingRequest {
  bindingKey: string(name='BindingKey', position='Body'),
  bindingType: string(name='BindingType', position='Body'),
  destinationName: string(name='DestinationName', position='Body'),
  instanceId: string(name='InstanceId', position='Body'),
  regionId: string(name='RegionId', position='Host'),
  sourceExchange: string(name='SourceExchange', position='Body'),
  virtualHost: string(name='VirtualHost', position='Body'),
}

model DeleteBindingResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBindingResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBindingResponseBody(name='body'),
}

async function deleteBinding(request: DeleteBindingRequest): DeleteBindingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBinding', 'POST', '/', 'json', true, 'form', request);
}

model DeleteExchangeRequest {
  exchangeName: string(name='ExchangeName', position='Body'),
  instanceId: string(name='InstanceId', position='Body'),
  regionId: string(name='RegionId', position='Host'),
  virtualHost: string(name='VirtualHost', position='Body'),
}

model DeleteExchangeResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExchangeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExchangeResponseBody(name='body'),
}

async function deleteExchange(request: DeleteExchangeRequest): DeleteExchangeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteExchange', 'POST', '/', 'json', true, 'form', request);
}

model DeleteQueueRequest {
  instanceId: string(name='InstanceId', position='Body'),
  queueName: string(name='QueueName', position='Body'),
  regionId: string(name='RegionId', position='Host'),
  virtualHost: string(name='VirtualHost', position='Body'),
}

model DeleteQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteQueueResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteQueueResponseBody(name='body'),
}

async function deleteQueue(request: DeleteQueueRequest): DeleteQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteQueue', 'POST', '/', 'json', true, 'form', request);
}

model DeleteVirtualHostRequest {
  instanceId: string(name='InstanceId', position='Body'),
  regionId: string(name='RegionId', position='Host'),
  virtualHost: string(name='VirtualHost', position='Body'),
}

model DeleteVirtualHostResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualHostResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVirtualHostResponseBody(name='body'),
}

async function deleteVirtualHost(request: DeleteVirtualHostRequest): DeleteVirtualHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVirtualHost', 'POST', '/', 'json', true, 'form', request);
}

model GetMetadataAmountRequest {
  instanceId?: string(name='InstanceId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
}

model GetMetadataAmountResponseBody = {
  data?: {
    currentExchanges?: int32(name='CurrentExchanges'),
    currentQueues?: int32(name='CurrentQueues'),
    currentVirtualHosts?: int32(name='CurrentVirtualHosts'),
    maxExchanges?: int32(name='MaxExchanges'),
    maxQueues?: int32(name='MaxQueues'),
    maxVirtualHosts?: int32(name='MaxVirtualHosts'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetadataAmountResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetadataAmountResponseBody(name='body'),
}

async function getMetadataAmount(request: GetMetadataAmountRequest): GetMetadataAmountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetadataAmount', 'GET', '/', 'json', false, 'json', request);
}

model ListBindingsRequest {
  instanceId: string(name='InstanceId', position='Query'),
  maxResults: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', minLength=1, position='Query'),
  regionId: string(name='RegionId', position='Host'),
  virtualHost: string(name='VirtualHost', position='Query'),
}

model ListBindingsResponseBody = {
  data?: {
    bindings?: [ 
      {
        argument?: string(name='Argument'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: string(name='BindingType'),
        destinationName?: string(name='DestinationName'),
        sourceExchange?: string(name='SourceExchange'),
      }
    ](name='Bindings'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListBindingsResponse = {
  headers: map[string]string(name='headers'),
  body: ListBindingsResponseBody(name='body'),
}

async function listBindings(request: ListBindingsRequest): ListBindingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListBindings', 'GET', '/', 'json', false, 'json', request);
}

model ListDownStreamBindingsRequest {
  exchangeName: string(name='ExchangeName', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  maxResults: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Host'),
  virtualHost: string(name='VirtualHost', position='Query'),
}

model ListDownStreamBindingsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    bindings?: [ 
      {
        argument?: string(name='Argument'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: string(name='BindingType'),
        destinationName?: string(name='DestinationName'),
        sourceExchange?: string(name='SourceExchange'),
      }
    ](name='Bindings'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDownStreamBindingsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDownStreamBindingsResponseBody(name='body'),
}

async function listDownStreamBindings(request: ListDownStreamBindingsRequest): ListDownStreamBindingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDownStreamBindings', 'GET', '/', 'json', false, 'json', request);
}

model ListExchangeUpStreamBindingsRequest {
  exchangeName: string(name='ExchangeName', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  maxResults: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Host'),
  virtualHost: string(name='VirtualHost', position='Query'),
}

model ListExchangeUpStreamBindingsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    bindings?: [ 
      {
        argument?: string(name='Argument'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: string(name='BindingType'),
        destinationName?: string(name='DestinationName'),
        sourceExchange?: string(name='SourceExchange'),
      }
    ](name='Bindings'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListExchangeUpStreamBindingsResponse = {
  headers: map[string]string(name='headers'),
  body: ListExchangeUpStreamBindingsResponseBody(name='body'),
}

async function listExchangeUpStreamBindings(request: ListExchangeUpStreamBindingsRequest): ListExchangeUpStreamBindingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExchangeUpStreamBindings', 'GET', '/', 'json', false, 'json', request);
}

model ListExchangesRequest {
  instanceId: string(name='InstanceId', position='Query'),
  maxResults: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Host'),
  virtualHost: string(name='VirtualHost', position='Query'),
}

model ListExchangesResponseBody = {
  data?: {
    exchanges?: [ 
      {
        attributes?: map[string]any(name='Attributes'),
        autoDeleteState?: boolean(name='AutoDeleteState'),
        createTime?: long(name='CreateTime'),
        exchangeType?: string(name='ExchangeType'),
        name?: string(name='Name'),
        VHostName?: string(name='VHostName'),
      }
    ](name='Exchanges'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListExchangesResponse = {
  headers: map[string]string(name='headers'),
  body: ListExchangesResponseBody(name='body'),
}

async function listExchanges(request: ListExchangesRequest): ListExchangesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExchanges', 'GET', '/', 'json', false, 'json', request);
}

model ListInstancesRequest {
  maxResults: int32(name='MaxResults', minimum=1, maximum=200, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Host'),
}

model ListInstancesResponseBody = {
  data?: {
    instances?: [ 
      {
        autoRenewInstance?: boolean(name='AutoRenewInstance'),
        classicEndpoint?: string(name='ClassicEndpoint'),
        expireTime?: long(name='ExpireTime'),
        instanceId?: string(name='InstanceId'),
        instanceName?: string(name='InstanceName'),
        instanceType?: string(name='InstanceType'),
        maxEipTps?: int32(name='MaxEipTps'),
        maxQueue?: int32(name='MaxQueue'),
        maxTps?: int32(name='MaxTps'),
        maxVhost?: int32(name='MaxVhost'),
        orderCreateTime?: long(name='OrderCreateTime'),
        orderType?: string(name='OrderType'),
        privateEndpoint?: string(name='PrivateEndpoint'),
        publicEndpoint?: string(name='PublicEndpoint'),
        status?: string(name='Status'),
        storageSize?: int32(name='StorageSize'),
        supportEIP?: boolean(name='SupportEIP'),
      }
    ](name='Instances'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstances', 'GET', '/', 'json', false, 'json', request);
}

model ListQueueConsumersRequest {
  instanceId: string(name='InstanceId', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  queryCount?: int32(name='QueryCount', minimum=1, maximum=100, position='Query'),
  queue: string(name='Queue', position='Query'),
  regionId: string(name='RegionId', position='Host'),
  virtualHost: string(name='VirtualHost', position='Query'),
}

model ListQueueConsumersResponseBody = {
  data?: {
    consumers?: [ 
      {
        consumerTag?: string(name='ConsumerTag'),
      }
    ](name='Consumers'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListQueueConsumersResponse = {
  headers: map[string]string(name='headers'),
  body: ListQueueConsumersResponseBody(name='body'),
}

async function listQueueConsumers(request: ListQueueConsumersRequest): ListQueueConsumersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListQueueConsumers', 'GET', '/', 'json', false, 'json', request);
}

model ListQueueUpStreamBindingsRequest {
  instanceId: string(name='InstanceId', position='Query'),
  maxResults: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  queueName: string(name='QueueName', position='Query'),
  regionId: string(name='RegionId', position='Host'),
  virtualHost: string(name='VirtualHost', position='Query'),
}

model ListQueueUpStreamBindingsResponseBody = {
  data?: {
    bindings?: [ 
      {
        argument?: string(name='Argument'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: string(name='BindingType'),
        destinationName?: string(name='DestinationName'),
        sourceExchange?: string(name='SourceExchange'),
      }
    ](name='Bindings'),
    maxResults?: string(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListQueueUpStreamBindingsResponse = {
  headers: map[string]string(name='headers'),
  body: ListQueueUpStreamBindingsResponseBody(name='body'),
}

async function listQueueUpStreamBindings(request: ListQueueUpStreamBindingsRequest): ListQueueUpStreamBindingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListQueueUpStreamBindings', 'GET', '/', 'json', false, 'json', request);
}

model ListQueuesRequest {
  instanceId: string(name='InstanceId', position='Query'),
  maxResults: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', minLength=1, position='Query'),
  regionId: string(name='RegionId', position='Host'),
  virtualHost: string(name='VirtualHost', position='Query'),
}

model ListQueuesResponseBody = {
  data?: {
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    queues?: [ 
      {
        attributes?: map[string]any(name='Attributes'),
        autoDeleteState?: boolean(name='AutoDeleteState'),
        createTime?: long(name='CreateTime'),
        exclusiveState?: boolean(name='ExclusiveState'),
        lastConsumeTime?: long(name='LastConsumeTime'),
        name?: string(name='Name'),
        ownerId?: string(name='OwnerId'),
        VHostName?: string(name='VHostName'),
      }
    ](name='Queues'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListQueuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListQueuesResponseBody(name='body'),
}

async function listQueues(request: ListQueuesRequest): ListQueuesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListQueues', 'GET', '/', 'json', false, 'json', request);
}

model ListVirtualHostsRequest {
  instanceId: string(name='InstanceId', position='Query'),
  maxResults: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Host'),
}

model ListVirtualHostsResponseBody = {
  data?: {
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    virtualHosts?: [ 
      {
        name?: string(name='Name'),
      }
    ](name='VirtualHosts'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListVirtualHostsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVirtualHostsResponseBody(name='body'),
}

async function listVirtualHosts(request: ListVirtualHostsRequest): ListVirtualHostsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVirtualHosts', 'GET', '/', 'json', false, 'json', request);
}

model UpdateInstanceNameRequest {
  instanceId: string(name='InstanceId', position='Query'),
  instanceName: string(name='InstanceName', position='Query'),
  regionId: string(name='RegionId', position='Host'),
}

model UpdateInstanceNameResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateInstanceNameResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateInstanceNameResponseBody(name='body'),
}

async function updateInstanceName(request: UpdateInstanceNameRequest): UpdateInstanceNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateInstanceName', 'POST', '/', 'json', false, 'json', request);
}

