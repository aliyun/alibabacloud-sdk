/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'amqp-open';
  @version = '2019-12-12';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model CreateAccountRequest {
  regionId?: string(name='RegionId', position='Host'),
  accountAccessKey: string(name='accountAccessKey', description='The AccessKey ID of your Alibaba Cloud account or RAM user. For information about how to obtain an AccessKey pair, see [Create an AccessKey pair](~~116401~~).

>  If you use the pair of static username and password that is created by using the Accesskey pair of a RAM user to access ApsaraMQ for RabbitMQ to send and receive messages, make sure that the RAM user is granted the required permissions. For more information, see [RAM policies](~~146559~~).', example='LTAI5t8be*******tEJ6vfo', position='Query'),
  createTimestamp: long(name='createTimestamp', description='The timestamp that indicates when the password is created. Unit: milliseconds.

>  This timestamp is specified by you and is used to generate a static password. The timestamp is not the timestamp that indicates when the system generates the password.', example='1671175303522', position='Query'),
  instanceId: string(name='instanceId', description='The ID of the instance for which you want to create a pair of static username and password.', example='amqp-cn-*********', position='Query'),
  secretSign: string(name='secretSign', description='The AccessKey secret signature. The system generates a static password based on the signature in the request, the AccessKey secret signature, and the username.

The system uses the HMAC-SHA1 algorithm to generate the AccessKey secret signature based on the timestamp that indicates when the username is created and the AccessKey ID. For more information, see the **"Sample code on how to generate a signature"** section of this topic.', example='4c1a6367ce4c4255e9617326f9133ac6359533f6', position='Query'),
  signature: string(name='signature', description='The signature. The system generates a static password based on the signature in the request, the AccessKey secret signature, and the username.

The system uses the HMAC-SHA1 algorithm to generate the signature based on the timestamp that indicates when the username is created and the AccessKey ID. For more information, see the **"Sample code on how to generate a signature"** section of this topic.', example='22c2d7d1769cb53c5a6d9213248e2de524c4f799', position='Query'),
  userName: string(name='userName', description='The static username that you want to create.

The value of this parameter is a Base64-encoded string that is generated based on the instance ID and AccessKey ID. For more information, see the "**Sample code on how to generate a username**" section of this topic.', example='MjphbXFwLWNuLXp***********************Q4YmVNbVZNMWVSWnRFSjZ2Zm8=', position='Query'),
}

model CreateAccountResponseBody = {
  code?: int32(name='Code', description='The HTTP status code. The status code 200 indicates that the request was successful.', example='200'),
  data?: {
    accessKey?: string(name='AccessKey', description='The AccessKey ID that is used to create the password.', example='LTAI5***********eRZtEJ6vfo'),
    createTimeStamp?: long(name='CreateTimeStamp', description='The timestamp that indicates when the password was created. Unit: milliseconds.', example='1671175303522'),
    instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='amqp-cn-*********'),
    masterUId?: long(name='MasterUId', description='The Alibaba Cloud account ID or RAM user to which the AccessKey pair that is used to create the static username and password belongs.', example='15657*********01'),
    password?: string(name='Password', description='The created static password.', example='NEMxQTYzNjdDRTVDNDI1NUU5NjE3**************1MzNGODoxNjcxMTc1MzEzNTIy'),
    userName?: string(name='UserName', description='The created static username.', example='MjphbXFwLWNuLXVxbTJ6cjc2djAwMzpMVEFJNX*******ZNMWVSWnRFSjZ2Zm8='),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='92385FD2-624A-48C9-8FB5-753F2AFA***'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.', example='true'),
}

model CreateAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAccountResponseBody(name='body'),
}

/**
  *
 */
async function createAccount(request: CreateAccountRequest): CreateAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAccount', 'POST', '/', 'json', false, 'json', request);
}

model CreateBindingRequest {
  regionId?: string(name='RegionId', position='Host'),
  argument?: string(name='Argument', description='The key-value pairs that are configured for the headers attributes of a message. One or more key-value pairs can be concatenated to configure the headers attributes of a message. You must specify the x-match attribute as one of the valid values. You can specify custom values for other attributes. Valid values of the x-match attribute:

*   \\*\\*all: \\*\\*A headers exchange routes a message to a queue only if all binding attributes of the queue except for x-match match the headers attributes of the message. This value is the default value.
*   \\*\\*any: \\*\\*A headers exchange routes a message to a queue if one or more binding attributes of the queue except for x-match match the headers attributes of the message.

Separate the attributes with semicolons (;). Separate the key and value of an attribute with a colon (:). Example: x-match:all;type:report;format:pdf. This parameter is available for only headers exchanges. You can set this parameter to an arbitrary value for other types of exchanges.', example='x-match:all;type:report;format:pdf', position='Body'),
  bindingKey: string(name='BindingKey', description='The binding key.

*   If the source exchange is not a topic exchange, the binding key must meet the following conventions:

    *   The binding key can contain only letters, digits, hyphens (-), underscores (\\_), periods (.), forward slashes (/), and at signs (@).
    *   The binding key must be 1 to 255 characters in length.

*   If the source exchange is a topic exchange, the binding key must meet the following conventions:

    *   The binding key can contain letters, digits, hyphens (-), underscores (\\_), asterisks (\\*), periods (.), number signs (#), forward slashes (/), and at signs (@).
    *   The binding key cannot start or end with a period (.). If a binding key starts with a number sign (#) or an asterisk (\\*), the number sign (#) or asterisk (\\*) must be followed by a period (.). If the binding key ends with a number sign (#) or an asterisk (\\*), the number sign (#) or asterisk (\\*) must be preceded by a period (.). If a number sign (#) or an asterisk (\\*) is used in the middle of a binding key, the number sign (#) or asterisk (\\*) must be preceded and followed by a period (.).
    *   The binding key must be 1 to 255 characters in length.', example='.test', position='Body'),
  bindingType: string(name='BindingType', description='The type of the object that you want to bind to the source exchange. Valid values:

*   \\*\\*0: \\*\\*Queue
*   \\*\\*1: \\*\\*Exchange', example='0', position='Body'),
  destinationName: string(name='DestinationName', description='The name of the object that you want to bind to the source exchange. You must create the object in the ApsaraMQ for RabbitMQ console in advance. The vhost of the object is the same as the vhost to which the source exchange specified by **SourceExchange** belongs. The vhost of the source exchange is the one specified by **VirtualHost**.', example='DemoQueue', position='Body'),
  instanceId: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='amqp-cn-v0h1kb9nu***', position='Body'),
  sourceExchange: string(name='SourceExchange', description='The name of the source exchange. You must create the source exchange in the ApsaraMQ for RabbitMQ console in advance.', example='NormalEX', position='Body'),
  virtualHost: string(name='VirtualHost', description='The virtual host (vhost) name. You must create the vhost in the ApsaraMQ for RabbitMQ console in advance. The object specified by **DestinationName** and the source exchange specified by **SourceExchange** must belong to the vhost.', example='test', position='Body'),
}

model CreateBindingResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='09768C14-E51C-4F4A-8077-30810032C***'),
}

model CreateBindingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateBindingResponseBody(name='body'),
}

async function createBinding(request: CreateBindingRequest): CreateBindingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBinding', 'POST', '/', 'json', true, 'form', request);
}

model CreateExchangeRequest {
  regionId?: string(name='RegionId', position='Host'),
  alternateExchange?: string(name='AlternateExchange', description='The alternate exchange. An alternate exchange is used to receive messages that fail to be routed to queues from the current exchange.', example='DemoAE', position='Body'),
  autoDeleteState: boolean(name='AutoDeleteState', description='Specifies whether to automatically delete the exchange. Valid values:

*   **true**: If the last queue that is bound to the exchange is unbound, the exchange is automatically deleted.
*   **false**: If the last queue that is bound to the exchange is unbound, the exchange is not automatically deleted.', example='false', position='Body'),
  exchangeName: string(name='ExchangeName', description='The name of the exchange that you want to create. The exchange name must meet the following conventions:

*   The name must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (\\_), periods (.), number signs (#), forward slashes (/), and at signs (@).
*   After the exchange is created, you cannot change its name. If you want to change its name, delete the exchange and create another exchange.', example='DemoExchange', position='Body'),
  exchangeType: string(name='ExchangeType', description='The exchange type. Valid values:

*   **DIRECT**: An exchange of this type routes a message to the queue whose binding key is exactly the same as the routing key of the message.
*   **TOPIC**: This type of exchange is similar to direct exchanges. An exchange of this type routes a message to one or more queues based on the results of the fuzzy match or multi-condition match between the routing key of the message and the binding keys of the current exchange.
*   **FANOUT**: An exchange of this type routes all received messages to all queues bound to this exchange. You can use a fanout exchange to broadcast messages.
*   **HEADERS**: This type of exchange is similar to direct exchanges. The only difference is that a headers exchange routes messages based on the headers attributes instead of routing keys. When you bind a headers exchange to a queue, you must configure binding attributes in the key-value format for the binding. When you send a message to a headers exchange, you must configure the headers attributes in the key-value format for the message. After a headers exchange receives a message, the exchange routes the message based on the matching results between the headers attributes of the message and the binding attributes of the bound queues.
*   **X-CONSISTENT-HASH**: An exchange of this type allows you to perform hash calculations on routing keys or header values and use consistent hashing to route a message to different queues.', example='DIRECT', position='Body'),
  instanceId: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ for which you want to create an exchange.', example='amqp-cn-v0h1kb9nu***', position='Body'),
  internal: boolean(name='Internal', description='Specifies whether the exchange is an internal exchange. Valid values:

*   **false**
*   **true**', example='false', position='Body'),
  virtualHost: string(name='VirtualHost', description='The name of the vhost to which the exchange that you want to create belongs.', example='test', position='Body'),
  xDelayedType?: string(name='XDelayedType', position='Body'),
}

model CreateExchangeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='021788F6-E50C-4BD6-9F80-66B0A19A6***'),
}

model CreateExchangeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateExchangeResponseBody(name='body'),
}

async function createExchange(request: CreateExchangeRequest): CreateExchangeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateExchange', 'POST', '/', 'json', true, 'form', request);
}

model CreateInstanceRequest {
  regionId?: string(name='RegionId', position='Host'),
  autoRenew?: boolean(name='AutoRenew', example='AutoRenewal', position='Query'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', example='1', position='Query'),
  clientToken?: string(name='ClientToken', example='c2c5d1274axxxxxxxx', position='Query'),
  instanceName?: string(name='InstanceName', position='Query'),
  instanceType?: string(name='InstanceType', example='professional', position='Query'),
  maxConnections?: int32(name='MaxConnections', example='50000', position='Query'),
  maxEipTps?: long(name='MaxEipTps', example='128', position='Query'),
  maxPrivateTps?: long(name='MaxPrivateTps', example='1000', position='Query'),
  paymentType: string(name='PaymentType', example='Subscription', position='Query'),
  period?: int32(name='Period', example='1', position='Query'),
  periodCycle?: string(name='PeriodCycle', example='Month', position='Query'),
  queueCapacity?: int32(name='QueueCapacity', example='1000', position='Query'),
  renewStatus?: string(name='RenewStatus', description='autoRenew和renewStatus都是续费方式，当两个同时填写时，以renewStatus为准', position='Query'),
  renewalDurationUnit?: string(name='RenewalDurationUnit', position='Query'),
  serverlessChargeType?: string(name='ServerlessChargeType', example='onDemand', position='Query'),
  storageSize?: int32(name='StorageSize', example='7', position='Query'),
  supportEip?: boolean(name='SupportEip', example='true', position='Query'),
  supportTracing?: boolean(name='SupportTracing', example='true', position='Query'),
  tracingStorageTime?: int32(name='TracingStorageTime', example='3', position='Query'),
}

model CreateInstanceResponseBody = {
  code?: int32(name='Code', example='200'),
  data?: any(name='Data', example='amqp-cn-xxxxx'),
  message?: string(name='Message', example='xxx failed,xxxx'),
  requestId?: string(name='RequestId', example='CCBB1225-C392-480E-8C7F-D09AB2CD2***'),
  success?: boolean(name='Success', example='true'),
}

model CreateInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateInstanceResponseBody(name='body'),
}

async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateQueueRequest {
  regionId?: string(name='RegionId', position='Host'),
  autoDeleteState?: boolean(name='AutoDeleteState', description='Specifies whether to automatically delete the queue. Valid values:

*   true: The queue is automatically deleted. After the last consumer unsubscribes from the queue, the queue is automatically deleted.
*   false: The queue is not automatically deleted.', example='false', position='Body'),
  autoExpireState?: long(name='AutoExpireState', description='The validity period after which the queue is automatically deleted. If the queue is not accessed within the specified period of time, the queue is automatically deleted.

Unit: milliseconds.

>  You can use the feature that corresponds to this parameter only after you enable the feature. To enable the feature, [submit a ticket](https://ticket-intl.console.aliyun.com/#/ticket/createIndex).', example='10000', position='Body'),
  deadLetterExchange?: string(name='DeadLetterExchange', description='The dead-letter exchange. A dead-letter exchange is used to receive rejected messages.

If a consumer rejects a message that cannot be redelivered, ApsaraMQ for RabbitMQ routes the message to the specified dead-letter exchange. Then, the dead-letter exchange routes the message to the queue that is bound to the dead-letter exchange for storage.', example='DLExchange', position='Body'),
  deadLetterRoutingKey?: string(name='DeadLetterRoutingKey', description='The dead-letter routing key. The key must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (\\_), periods (.), number signs (#), forward slashes (/), and at signs (@).', example='test.dl', position='Body'),
  exclusiveState?: boolean(name='ExclusiveState', description='Specifies whether the exchange is an exclusive exchange. Valid values:

*   true: The exchange is an exclusive exchange. Only the connection that declares the exclusive exchange can use the exclusive exchange. After the connection is closed, the exclusive exchange is automatically deleted.
*   false: The exchange is not an exclusive exchange.', example='false', position='Body'),
  instanceId: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance on which you want to create a queue.', example='amqp-cn-v0h1kb9nu***', position='Body'),
  maxLength?: long(name='MaxLength', description='This parameter is unavailable in the current version of ApsaraMQ for RabbitMQ.

The maximum number of messages that can be stored in the queue. If this threshold is exceeded, the earliest stored messages in the queue are deleted.', example='1000', position='Body'),
  maximumPriority?: int32(name='MaximumPriority', description='Queue priorities are not supported. The value does not affect the call or return results.', example='10', position='Body'),
  messageTTL?: long(name='MessageTTL', description='The message time to live (TTL) of the queue.

*   If the retention period of a message in the queue exceeds the message TTL of the queue, the message expires.
*   The message TTL must be set to a non-negative integer. The maximum message TTL is one day. Unit: milliseconds. For example, if the message TTL is 1,000 milliseconds, the message can be retained for up to 1 second in the queue.', example='1000', position='Body'),
  queueName: string(name='QueueName', description='The name of the queue that you want to create.

*   The name must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (\\_), periods (.), number signs (#), forward slashes (/), and at signs (@).
*   After the queue is created, you cannot change the name of the queue. If you want to change the name of the queue, delete the queue and create another queue.', example='DemoQueue', position='Body'),
  virtualHost: string(name='VirtualHost', description='The name of the vhost to which the queue that you want to create belongs. The name must be 1 to 255 characters in length, and can contain only letters, digits, hyphens (-), underscores (\\_), periods (.), number signs (#), forward slashes (/), and at signs (@).', example='test', position='Body'),
}

model CreateQueueResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='59B52E2C-0B8E-44EC-A314-D0314A50***'),
}

model CreateQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateQueueResponseBody(name='body'),
}

async function createQueue(request: CreateQueueRequest): CreateQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateQueue', 'POST', '/', 'json', true, 'form', request);
}

model CreateVirtualHostRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='amqp-cn-v0h1kb9n***', position='Body'),
  virtualHost: string(name='VirtualHost', description='The name of the vhost that you want to create. Valid values:

*   The name can contain letters, digits, hyphens (-), underscores (\\_), periods (.), number signs (#), forward slash (/), and at signs (@).
*   The name must be 1 to 255 characters in length.
*   After the vhost is created, you cannot change its name. If you want to change the name of a vhost, delete the vhost and create another vhost.', example='Demo', position='Body'),
}

model CreateVirtualHostResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='628705FD-03EE-4ABE-BB21-E1672960***'),
}

model CreateVirtualHostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateVirtualHostResponseBody(name='body'),
}

async function createVirtualHost(request: CreateVirtualHostRequest): CreateVirtualHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVirtualHost', 'POST', '/', 'json', true, 'form', request);
}

model DeleteAccountRequest {
  regionId?: string(name='RegionId', position='Host'),
  createTimestamp: long(name='CreateTimestamp', description='The timestamp that indicates when the pair of static username and password that you want to delete was created. Unit: milliseconds.

You can call the [ListAccounts](~~472730~~) operation to view the timestamp.', example='1671175303522', position='Query'),
  userName: string(name='UserName', description='The pair of username and password that you want to delete.', example='MjphbXFwLWNuLXVxbTJ5cjc3djAwMzpMVEFJNXQ4YmVNbVZNMWVSWnRFSjZ2Zm1=', position='Query'),
}

model DeleteAccountResponseBody = {
  code?: int32(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  data?: boolean(name='Data', description='The returned data.', example='true'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='021788F6-E50C-4BD6-9F80-66B0A19A6***'),
  success?: boolean(name='Success', description='Indicates whether the request is successful.', example='true'),
}

model DeleteAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAccountResponseBody(name='body'),
}

async function deleteAccount(request: DeleteAccountRequest): DeleteAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAccount', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBindingRequest {
  regionId?: string(name='RegionId', position='Host'),
  bindingKey: string(name='BindingKey', description='The binding key.', example='.test.', position='Body'),
  bindingType: string(name='BindingType', description='The type of the object that you want to unbind from the source exchange. Valid values:

*   **QUEUE**
*   **EXCHANGE**', example='QUEUE', position='Body'),
  destinationName: string(name='DestinationName', description='The name of the object that you want to unbind from the source exchange.', example='DemoQueue', position='Body'),
  instanceId: string(name='InstanceId', description='The instance ID.', example='amqp-cn-v0h1kb9nu***', position='Body'),
  sourceExchange: string(name='SourceExchange', description='The name of the source exchange.', example='NormalEX', position='Body'),
  virtualHost: string(name='VirtualHost', description='The vhost name.', example='test', position='Body'),
}

model DeleteBindingResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='021788F6-E50C-4BD6-9F80-66B0A19A6***'),
}

model DeleteBindingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteBindingResponseBody(name='body'),
}

async function deleteBinding(request: DeleteBindingRequest): DeleteBindingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBinding', 'POST', '/', 'json', true, 'form', request);
}

model DeleteExchangeRequest {
  regionId?: string(name='RegionId', position='Host'),
  exchangeName: string(name='ExchangeName', description='The name of the exchange that you want to delete.', example='DemoExchange', position='Body'),
  instanceId: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance whose exchange you want to delete.', example='amqp-cn-v0h1kb9nu***', position='Body'),
  virtualHost: string(name='VirtualHost', description='The vhost to which the exchange that you want to delete belongs.', example='test', position='Body'),
}

model DeleteExchangeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6961FFB8-6358-4EDC-9E3C-4A0C56CE6***'),
}

model DeleteExchangeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteExchangeResponseBody(name='body'),
}

/**
  * ## [](#)Usage notes
  * *   You cannot delete exchanges of the **headers** and **x-jms-topic** types.
  * *   You cannot delete built-in exchanges in a vhost. These exchanges are amq.direct, amq.topic, and amq.fanout.
  *
 */
async function deleteExchange(request: DeleteExchangeRequest): DeleteExchangeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteExchange', 'POST', '/', 'json', true, 'form', request);
}

model DeleteQueueRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The instance ID.', example='1880770869023***', position='Body'),
  queueName: string(name='QueueName', description='The queue name.', example='DemoQueue', position='Body'),
  virtualHost: string(name='VirtualHost', description='The vhost name.', example='Test', position='Body'),
}

model DeleteQueueResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='92385FD2-624A-48C9-8FB5-753F2AFA***'),
}

model DeleteQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteQueueResponseBody(name='body'),
}

async function deleteQueue(request: DeleteQueueRequest): DeleteQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteQueue', 'POST', '/', 'json', true, 'form', request);
}

model DeleteVirtualHostRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance to which the vhost you want to delete belongs.', example='amqp-cn-v0h1kb9nu***', position='Body'),
  virtualHost: string(name='VirtualHost', description='The name of the vhost that you want to delete.', example='test', position='Body'),
}

model DeleteVirtualHostResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4311050D-BD63-48F9-822B-947A75A1***'),
}

model DeleteVirtualHostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteVirtualHostResponseBody(name='body'),
}

/**
  * Before you delete a vhost, make sure that all exchanges and queues in the vhost are deleted.
  *
 */
async function deleteVirtualHost(request: DeleteVirtualHostRequest): DeleteVirtualHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVirtualHost', 'POST', '/', 'json', true, 'form', request);
}

model GetMetadataAmountRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='amqp-cn-v0h1kb9n***', position='Query'),
}

model GetMetadataAmountResponseBody = {
  data?: {
    currentExchanges?: int32(name='CurrentExchanges', description='The number of created exchanges on the ApsaraMQ for RabbitMQ instance.', example='7'),
    currentQueues?: int32(name='CurrentQueues', description='The number of created queues on the ApsaraMQ for RabbitMQ instance.', example='1'),
    currentVirtualHosts?: int32(name='CurrentVirtualHosts', description='The number of created vhosts on the ApsaraMQ for RabbitMQ instance.', example='1'),
    maxExchanges?: int32(name='MaxExchanges', description='The maximum number of exchanges that can be created on the ApsaraMQ for RabbitMQ instance.', example='20'),
    maxQueues?: int32(name='MaxQueues', description='The maximum number of queues that can be created on the ApsaraMQ for RabbitMQ instance.', example='20'),
    maxVirtualHosts?: int32(name='MaxVirtualHosts', description='The maximum number of vhosts that can be created on the ApsaraMQ for RabbitMQ instance.', example='10'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B75ACF23-2BEB-44AC-A0B6-AE14EDCA***'),
}

model GetMetadataAmountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMetadataAmountResponseBody(name='body'),
}

async function getMetadataAmount(request: GetMetadataAmountRequest): GetMetadataAmountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMetadataAmount', 'GET', '/', 'json', false, 'json', request);
}

model ListAccountsRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId?: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance for which you want to query the static username and password.', example='amqp-cn-20p****04', position='Query'),
}

model ListAccountsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  data?: map[string][ DataValue   ](name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='549A5A97-FE61-5A23-8126-3A11929C1EC4'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.', example='True'),
}

model ListAccountsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAccountsResponseBody(name='body'),
}

async function listAccounts(request: ListAccountsRequest): ListAccountsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAccounts', 'POST', '/', 'json', false, 'json', request);
}

model ListBindingsRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='1880770869023***', position='Query'),
  maxResults: int32(name='MaxResults', description='The maximum number of entries to return. Valid values:

**1 to 100**', example='1', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', description='The token that marks the end position of the previous returned page. To obtain the next batch of data, call the operation again by using the value of NextToken returned by the previous request. If you call this operation for the first time or want to query all results, set NextToken to an empty string.', example='caeba0bbb2be03f84eb48b699f0a****', minLength=1, position='Query'),
  virtualHost: string(name='VirtualHost', description='The vhost name.', example='Test', position='Query'),
}

model ListBindingsResponseBody = {
  data?: {
    bindings?: [ 
      {
        argument?: string(name='Argument', description='The x-match attribute. Valid values:

*   **all:** A headers exchange routes a message to a queue only if all binding attributes of the queue except for x-match match the headers attributes of the message. This value is the default value.
*   **any:** A headers exchange routes a message to a queue if one or more binding attributes of the queue except for x-match match the headers attributes of the message.

This parameter is available only for headers exchanges.', example='all'),
        bindingKey?: string(name='BindingKey', description='The binding key.

*   If the source exchange is not a topic exchange, the binding key must meet the following conventions:

    *   The binding key can contain only letters, digits, hyphens (-), underscores (\\_), periods (.), forward slashes (/), and at signs (@).
    *   The binding key must be 1 to 255 characters in length.

*   If the source exchange is a topic exchange, the binding key must meet the following conventions:

    *   The binding key can contain letters, digits, hyphens (-), underscores (\\_), asterisks (\\*), periods (.), number signs (#), forward slashes (/), and at signs (@).
    *   The binding key cannot start or end with a period (.). If a binding key starts with a number sign (#) or an asterisk (\\*), the number sign (#) or asterisk (\\*) must be followed by a period (.). If the binding key ends with a number sign (#) or an asterisk (\\*), the number sign (#) or asterisk (\\*) must be preceded by a period (.). If a number sign (#) or an asterisk (\\*) is used in the middle of a binding key, the number sign (#) or asterisk (\\*) must be preceded and followed by a period (.).
    *   The binding key must be 1 to 255 characters in length.', example='amq.test'),
        bindingType?: string(name='BindingType', description='The type of the object to which the source exchange is bound. Valid values:

*   **QUEUE**
*   **EXCHANGE**', example='QUEUE'),
        destinationName?: string(name='DestinationName', description='The name of the object to which the source exchange is bound.', example='QueueTest'),
        sourceExchange?: string(name='SourceExchange', description='The name of the source exchange.', example='test'),
      }
    ](name='Bindings', description='The bindings.'),
    maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='1'),
    nextToken?: string(name='NextToken', description='The token that marks the end of the current returned page. If this parameter is empty, all data is retrieved.', example='caebacccb2be03f84eb48b699f0a****'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='E0A71208-3E87-4732-81CC-B18E0B4B1***'),
}

model ListBindingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListBindingsResponseBody(name='body'),
}

async function listBindings(request: ListBindingsRequest): ListBindingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListBindings', 'GET', '/', 'json', false, 'json', request);
}

model ListDownStreamBindingsRequest {
  regionId?: string(name='RegionId', position='Host'),
  exchangeName: string(name='ExchangeName', description='The exchange name.', example='test', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance to which the exchange belongs.', example='1880770869023***', position='Query'),
  maxResults: int32(name='MaxResults', description='The maximum number of entries to return.', example='1', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', description='The token that marks the end position of the previous returned page. To obtain the next batch of data, call the operation again by using the value of NextToken returned by the previous request. If you call this operation for the first time or want to query all results, set NextToken to an empty string.', example='caeba0bbb2be03f84eb48b699f0a****', position='Query'),
  virtualHost: string(name='VirtualHost', description='The name of the vhost to which the exchange belongs.', example='test', position='Query'),
}

model ListDownStreamBindingsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  data?: {
    bindings?: [ 
      {
        argument?: string(name='Argument', description='The x-match attribute. Valid values:

*   **all:** A headers exchange routes a message to a queue only if all binding attributes of the queue except for x-match match the headers attributes of the message. This value is the default value.
*   **any:** A headers exchange routes a message to a queue if one or more binding attributes of the queue except for x-match match the headers attributes of the message.

This parameter is available only for headers exchanges.', example='test'),
        bindingKey?: string(name='BindingKey', description='The binding key.

*   If the source exchange is not a topic exchange, the binding key must meet the following conventions:

    *   The binding key can contain only letters, digits, hyphens (-), underscores (\\_), periods (.), forward slashes (/), and at signs (@).
    *   The binding key must be 1 to 255 characters in length.

*   If the source exchange is a topic exchange, the binding key must meet the following conventions:

    *   The binding key can contain letters, digits, hyphens (-), underscores (\\_), periods (.), number signs (#), forward slashes (/), and at signs (@).
    *   The binding key cannot start or end with a period (.). If a binding key starts with a number sign (#) or an asterisk (\\*), the number sign (#) or asterisk (\\*) must be followed by a period (.). If the binding key ends with a number sign (#) or an asterisk (\\*), the number sign (#) or asterisk (\\*) must be preceded by a period (.). If a number sign (#) or an asterisk (\\*) is used in the middle of a binding key, the number sign (#) or asterisk (\\*) must be preceded and followed by a period (.).
    *   The binding key must be 1 to 255 characters in length.', example='amq.test'),
        bindingType?: string(name='BindingType', description='The type of the object to which the source exchange is bound. Valid values:

*   **QUEUE**
*   **EXCHANGE**', example='QUEUE'),
        destinationName?: string(name='DestinationName', description='The name of the object to which the source exchange is bound.', example='QueueTest'),
        sourceExchange?: string(name='SourceExchange', description='The name of the source exchange.', example='test'),
      }
    ](name='Bindings', description='The bindings.'),
    maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='1'),
    nextToken?: string(name='NextToken', description='The token that marks the end of the current returned page. If this parameter is empty, all data is retrieved.', example='caebacccb2be03f84eb48b699f0a****'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='9C1E0502-0790-4FDB-8C96-6D5C8D9B7***'),
  success?: boolean(name='Success', description='Indicates whether the request is successful.', example='true'),
}

model ListDownStreamBindingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDownStreamBindingsResponseBody(name='body'),
}

async function listDownStreamBindings(request: ListDownStreamBindingsRequest): ListDownStreamBindingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDownStreamBindings', 'GET', '/', 'json', false, 'json', request);
}

model ListExchangeUpStreamBindingsRequest {
  regionId?: string(name='RegionId', position='Host'),
  exchangeName: string(name='ExchangeName', description='The exchange name.', example='test', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='1880770869023***', position='Query'),
  maxResults: int32(name='MaxResults', description='The maximum number of entries to return.', example='1', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', description='The token that marks the end position of the previous returned page. To obtain the next batch of data, call the operation again by using the value of NextToken returned by the previous request. If you call this operation for the first time or want to query all results, set NextToken to an empty string.', example='caeba0bbb2be03f84eb48b699f0a****', position='Query'),
  virtualHost: string(name='VirtualHost', description='The virtual host (vhost) name.', example='test', position='Query'),
}

model ListExchangeUpStreamBindingsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  data?: {
    bindings?: [ 
      {
        argument?: string(name='Argument', description='The x-match attribute. Valid values:

*   **all:** A headers exchange routes a message to a queue only if all binding attributes of the queue except for x-match match the headers attributes of the message. This value is the default value.
*   **any:** A headers exchange routes a message to a queue if one or more binding attributes of the queue except for x-match match the headers attributes of the message.

This parameter is available only for headers exchanges.', example='all'),
        bindingKey?: string(name='BindingKey', description='The binding key.

*   If the source exchange is not a topic exchange, the binding key must meet the following conventions:

    *   The binding key can contain only letters, digits, hyphens (-), underscores (\\_), periods (.), forward slashes (/), and at signs (@).
    *   The binding key must be 1 to 255 characters in length.

*   If the source exchange is a topic exchange, the binding key must meet the following conventions:

    *   The binding key can contain letters, digits, hyphens (-), underscores (\\_), periods (.), number signs (#), forward slashes (/), and at signs (@).
    *   The binding key cannot start or end with a period (.). If a binding key starts with a number sign (#) or an asterisk (\\*), the number sign (#) or asterisk (\\*) must be followed by a period (.). If the binding key ends with a number sign (#) or an asterisk (\\*), the number sign (#) or asterisk (\\*) must be preceded by a period (.). If a number sign (#) or an asterisk (\\*) is used in the middle of a binding key, the number sign (#) or asterisk (\\*) must be preceded and followed by a period (.).
    *   The binding key must be 1 to 255 characters in length.', example='amq.dle.test'),
        bindingType?: string(name='BindingType', description='The type of the object to which the source exchange is bound. Valid values:

*   **QUEUE**
*   **EXCHANGE**', example='EXCHANGE'),
        destinationName?: string(name='DestinationName', description='The name of the object to which the source exchange is bound.', example='test'),
        sourceExchange?: string(name='SourceExchange', description='The name of the source exchange.', example='dle'),
      }
    ](name='Bindings', description='The bindings.'),
    maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='1'),
    nextToken?: string(name='NextToken', description='The token that marks the end of the current returned page. If this parameter is empty, all data is retrieved.', example='caebacccb2be03f84eb48b699f0a****'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned message.', example='operation success'),
  requestId?: string(name='RequestId', description='The request ID.', example='2DCCCE88-BC82-4A4F-AF5E-9A759672B***'),
  success?: boolean(name='Success', description='Indicates whether the request is successful.', example='true'),
}

model ListExchangeUpStreamBindingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListExchangeUpStreamBindingsResponseBody(name='body'),
}

async function listExchangeUpStreamBindings(request: ListExchangeUpStreamBindingsRequest): ListExchangeUpStreamBindingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExchangeUpStreamBindings', 'GET', '/', 'json', false, 'json', request);
}

model ListExchangesRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='amqp-cn-7pp2mwbc****', position='Query'),
  maxResults: int32(name='MaxResults', description='The maximum number of entries to return. Valid values: **1 to 100**', example='1', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. Valid values:

*   If you call this operation for the first time or a next query is not required, leave this parameter empty.
*   If a next query is to be sent, set the value to the value of `NextToken` that is returned from the previous request.', example='AAAANDQBYW1xcC1jbi03cHAybXdiY3AwMGEBdmhvc3QBAXNkZndhYWJhATE2NDkzMTM4OTU5NDIB4o3z1pPwWzk4aYuiRffi8R6-****', position='Query'),
  virtualHost: string(name='VirtualHost', description='The vhost name.', example='test', position='Query'),
}

model ListExchangesResponseBody = {
  data?: {
    exchanges?: [ 
      {
        attributes?: map[string]any(name='Attributes', description='The attributes. This parameter is unavailable in the current version.', example='test'),
        autoDeleteState?: boolean(name='AutoDeleteState', description='Indicates whether the exchange was automatically deleted.', example='false'),
        createTime?: long(name='CreateTime', description='The timestamp that indicates when the exchange was created. Unit: milliseconds.', example='1580886216000'),
        exchangeType?: string(name='ExchangeType', description='The exchange type.', example='DIRECT'),
        name?: string(name='Name', description='The exchange name.', example='amq.direct'),
        vHostName?: string(name='VHostName', description='The vhost name.', example='test'),
      }
    ](name='Exchanges', description='The exchanges.'),
    maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='1'),
    nextToken?: string(name='NextToken', description='The token that marks the end of the current returned page.``

*   If the value of this parameter is empty, the next query is not required and the token used to start the next query is unavailable.``
*   If the value of this parameter is not empty, the next query is required, and the value is the token used to start the next query.``', example='AAAANDQBYW1xcC1jbi03cHAybXdiY3AwMGEBdmhvc3QBAXNkZndhYWJhATE2NDkzMTM4OTU5NDIB4o3z1pPwWzk4aYuiRffi8R6-****'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='FEBA5E0C-50D0-4FA6-A794-4901E5465***'),
}

model ListExchangesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListExchangesResponseBody(name='body'),
}

async function listExchanges(request: ListExchangesRequest): ListExchangesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExchanges', 'GET', '/', 'json', false, 'json', request);
}

model ListInstancesRequest {
  regionId?: string(name='RegionId', position='Host'),
  maxResults: int32(name='MaxResults', description='The maximum number of entries to return. Valid values: 1 to 100.', example='1', minimum=1, maximum=200, position='Query'),
  nextToken?: string(name='NextToken', description='The token that marks the end position of the previous returned page. To obtain the next batch of data, call the operation again by using the value of NextToken returned by the previous request. If you call this operation for the first time or want to query all results, set NextToken to an empty string.', example='caeba0bbb2be03f84eb48b699f0a****', position='Query'),
}

model ListInstancesResponseBody = {
  data?: {
    instances?: [ 
      {
        autoRenewInstance?: boolean(name='AutoRenewInstance', description='Indicates whether the instance is automatically renewed.', example='false'),
        classicEndpoint?: string(name='ClassicEndpoint', description='The endpoint that is used to access the instance over the classic network. This parameter is no longer available.', example='amqp-cn-st21x7kv****.not-support'),
        expireTime?: long(name='ExpireTime', description='The timestamp that indicates when the instance expires. Unit: milliseconds.', example='1651507200000'),
        instanceId?: string(name='InstanceId', description='The instance ID', example='amqp-cn-st21x7kv****'),
        instanceName?: string(name='InstanceName', description='The instance name.', example='amqp-cn-st21x7kv****'),
        instanceType?: string(name='InstanceType', description='The instance type.

*   PROFESSIONAL: Professional Edition
*   ENTERPRISE: Enterprise Edition
*   VIP: Enterprise Platinum Edition', example='professional'),
        maxEipTps?: int32(name='MaxEipTps', description='The maximum number of Internet-based transactions per second (TPS) for the instance.', example='24832'),
        maxQueue?: int32(name='MaxQueue', description='The maximum number of queues on the instance.', example='50'),
        maxTps?: int32(name='MaxTps', description='The maximum number of VPC-based TPS for the instance.', example='5000'),
        maxVhost?: int32(name='MaxVhost', description='The maximum number of vhosts on the instance.', example='50'),
        orderCreateTime?: long(name='OrderCreateTime', description='The timestamp that indicates when the order was created. Unit: milliseconds.', example='1572441939000'),
        orderType?: string(name='OrderType', description='The billing method. Valid values:

*   PrePaid: the subscription billing method.
*   POST_PAID: the pay-as-you-go billing method.', example='PRE_PAID'),
        privateEndpoint?: string(name='PrivateEndpoint', description='The virtual private cloud (VPC) endpoint of the instance.', example='amqp-cn-st21x7kv****.mq-amqp.cn-hangzhou-a.aliyuncs.com'),
        publicEndpoint?: string(name='PublicEndpoint', description='The public endpoint of the instance.', example='amqp-cn-st21x7kv****.mq-amqp.cn-hangzhou-a.aliyuncs.com'),
        status?: string(name='Status', description='The instance status. Valid values:

*   DEPLOYING: The instance is being deployed.
*   EXPIRED: The instance is expired.
*   SERVING: The instance is running.
*   RELEASED: The instance is released.', example='SERVING'),
        storageSize?: int32(name='StorageSize', description='The disk size. Unit: GB.

>  For Professional Edition instances and Enterprise Edition instances, this parameter is unavailable and \\*\\*-1\\*\\* is returned.', example='200'),
        supportEIP?: boolean(name='SupportEIP', description='Indicates whether the instance supports elastic IP addresses (EIPs).', example='true'),
        tags?: [ 
          {
            key?: string(name='Key', description='标签键。', example='region'),
            value?: string(name='Value', description='标签值。', example='hangzhou'),
          }
        ](name='Tags', description='标签列表。'),
      }
    ](name='Instances', description='The instances.'),
    maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='1'),
    nextToken?: string(name='NextToken', description='The token that marks the end of the current returned page. If this parameter is empty, all data is retrieved.', example='caebacccb2be03f84eb48b699f0a****'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='CCBB1225-C392-480E-8C7F-D09AB2CD2***'),
}

model ListInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstancesResponseBody(name='body'),
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstances', 'GET', '/', 'json', false, 'json', request);
}

model ListQueueConsumersRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='188077086902***', position='Query'),
  nextToken?: string(name='NextToken', description='The token that marks the end position of the previous returned page. To obtain the next batch of data, call the operation again by using the value of NextToken returned by the previous request. If you call this operation for the first time or want to query all results, set NextToken to an empty string.', example='caeba0bbb2be03f84eb48b699f0a****', position='Query'),
  queryCount?: int32(name='QueryCount', description='The number of data entries to return. If you do not configure this parameter, the default value 1 is used.

Valid values: 1 to 100.', example='1', minimum=1, maximum=100, position='Query'),
  queue: string(name='Queue', description='The name of the queue for which you want to query online consumers.', example='queue-rabbit-springboot-advance5', position='Query'),
  virtualHost: string(name='VirtualHost', description='The virtual host (vhost) name.', example='test', position='Query'),
}

model ListQueueConsumersResponseBody = {
  data?: {
    consumers?: [ 
      {
        consumerTag?: string(name='ConsumerTag', description='The consumer tag.', example='sgen-1'),
      }
    ](name='Consumers', description='The consumers.'),
    maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='1'),
    nextToken?: string(name='NextToken', description='The token that marks the end of the current returned page. If this parameter is empty, all data is retrieved.', example='caebacccb2be03f84eb48b699f0a****'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4409B7D5-E4EC-4EB5-804A-385DCDFCD***'),
}

model ListQueueConsumersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueueConsumersResponseBody(name='body'),
}

/**
  * ApsaraMQ for RabbitMQ allows you to query only online consumers.
  *
 */
async function listQueueConsumers(request: ListQueueConsumersRequest): ListQueueConsumersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListQueueConsumers', 'GET', '/', 'json', false, 'json', request);
}

model ListQueueUpStreamBindingsRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='1880770869023***', position='Query'),
  maxResults: int32(name='MaxResults', description='The maximum number of entries to return.', example='1', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', description='The token that marks the end position of the previous returned page. To obtain the next batch of data, call the operation again by using the value of NextToken returned by the previous request. If you call this operation for the first time or want to query all results, set NextToken to an empty string.', example='caeba0bbb2be03f84eb48b699f0a****', position='Query'),
  queueName: string(name='QueueName', description='The queue name.', example='QueueTest', position='Query'),
  virtualHost: string(name='VirtualHost', description='The virtual host (vhost) name.', example='test', position='Query'),
}

model ListQueueUpStreamBindingsResponseBody = {
  data?: {
    bindings?: [ 
      {
        argument?: string(name='Argument', description='The x-match attribute. Valid values:

*   **all:** A headers exchange routes a message to a queue only if all binding attributes of the queue except for x-match match the headers attributes of the message. This value is the default value.
*   **any:** A headers exchange routes a message to a queue if one or more binding attributes of the queue except for x-match match the headers attributes of the message.

This parameter is available for only headers exchanges.', example='all'),
        bindingKey?: string(name='BindingKey', description='The binding key.

*   If the source exchange is not a topic exchange, the binding key must meet the following conventions:

    *   The binding key can contain only letters, digits, hyphens (-), underscores (\\_), periods (.), forward slashes (/), and at signs (@).
    *   The binding key must be 1 to 255 characters in length.

*   If the source exchange is a topic exchange, the binding key must meet the following conventions:

    *   The binding key can contain letters, digits, hyphens (-), underscores (\\_), periods (.), number signs (#), forward slashes (/), and at signs (@).
    *   The binding key cannot start or end with a period (.). If a binding key starts with a number sign (#) or an asterisk (\\*), the number sign (#) or asterisk (\\*) must be followed by a period (.). If the binding key ends with a number sign (#) or an asterisk (\\*), the number sign (#) or asterisk (\\*) must be preceded by a period (.). If a number sign (#) or an asterisk (\\*) is used in the middle of a binding key, the number sign (#) or asterisk (\\*) must be preceded and followed by a period (.).
    *   The binding key must be 1 to 255 characters in length.', example='amq.test'),
        bindingType?: string(name='BindingType', description='The type of the object to which the source exchange is bound. Valid values:

*   **QUEUE**
*   **EXCHANGE**', example='QUEUE'),
        destinationName?: string(name='DestinationName', description='The name of the object to which the source exchange is bound.', example='QueueTest'),
        sourceExchange?: string(name='SourceExchange', description='The name of the source exchange.', example='test'),
      }
    ](name='Bindings', description='The bindings.'),
    maxResults?: string(name='MaxResults', description='The maximum number of entries returned.', example='1'),
    nextToken?: string(name='NextToken', description='The token that marks the end of the current returned page. If this parameter is empty, all data is retrieved.', example='caebacccb2be03f84eb48b699f0a****'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='8BFB1C9D-08A2-4859-A47C-403C9EFA2***'),
}

model ListQueueUpStreamBindingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueueUpStreamBindingsResponseBody(name='body'),
}

async function listQueueUpStreamBindings(request: ListQueueUpStreamBindingsRequest): ListQueueUpStreamBindingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListQueueUpStreamBindings', 'GET', '/', 'json', false, 'json', request);
}

model ListQueuesRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='1880770869023***', position='Query'),
  maxResults: int32(name='MaxResults', description='The maximum number of entries to return.', example='1', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', description='The token that marks the end position of the previous returned page. To obtain the next batch of data, call the operation again by using the value of NextToken returned by the previous request. If you call this operation for the first time or want to query all results, set NextToken to an empty string.', example='caeba0bbb2be03f84eb48b699f0a****', minLength=1, position='Query'),
  virtualHost: string(name='VirtualHost', description='The virtual host (vhost) name.', example='test', position='Query'),
}

model ListQueuesResponseBody = {
  data?: {
    maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='1'),
    nextToken?: string(name='NextToken', description='The token that marks the end of the current returned page. If this parameter is empty, all data is retrieved.', example='caebacccb2be03f84eb48b699f0a****'),
    queues?: [ 
      {
        attributes?: map[string]any(name='Attributes', description='The attributes.', example='test'),
        autoDeleteState?: boolean(name='AutoDeleteState', description='Indicates whether the queue was automatically deleted.', example='false'),
        createTime?: long(name='CreateTime', description='The time when the queue was created.', example='1580887085240'),
        exclusiveState?: boolean(name='ExclusiveState', description='Indicates whether the queue is an exclusive queue.', example='false'),
        lastConsumeTime?: long(name='LastConsumeTime', description='The time when messages in the queue were last consumed.', example='1680887085240'),
        name?: string(name='Name', description='The queue name.', example='QueueTest'),
        ownerId?: string(name='OwnerId', description='The ID of the ApsaraMQ for RabbitMQ instance to which the queue belongs.', example='1880770869023***'),
        vHostName?: string(name='VHostName', description='The vhost name.', example='test'),
      }
    ](name='Queues', description='The queues.'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='CE811989-9F02-42CE-97A6-2239CB5C2***'),
}

model ListQueuesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueuesResponseBody(name='body'),
}

async function listQueues(request: ListQueuesRequest): ListQueuesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListQueues', 'GET', '/', 'json', false, 'json', request);
}

model ListVirtualHostsRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='1880770869023***', position='Query'),
  maxResults: int32(name='MaxResults', description='The maximum number of entries to return. Valid values: **1 to 100**', example='2', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', description='The token that marks the end position of the previous returned page. To obtain the next batch of data, call the operation again by using the value of NextToken returned by the previous request. If you call this operation for the first time or want to query all results, set NextToken to an empty string.', example='caeba0bbb2be03f84eb48b699f0a****', position='Query'),
}

model ListVirtualHostsResponseBody = {
  data?: {
    maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='2'),
    nextToken?: string(name='NextToken', description='The token that marks the end of the current returned page. If this parameter is empty, all data is retrieved.', example='caebacccb2be03f84eb48b699f0a****'),
    virtualHosts?: [ 
      {
        name?: string(name='Name', description='The vhost name.', example='test'),
      }
    ](name='VirtualHosts', description='The vhosts.'),
  }(name='Data', description='The returned data.'),
  requestId?: string(name='RequestId', description='The request ID.', example='EF4DB019-DA4A-4CE3-B220-223BBC93F***'),
}

model ListVirtualHostsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVirtualHostsResponseBody(name='body'),
}

async function listVirtualHosts(request: ListVirtualHostsRequest): ListVirtualHostsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVirtualHosts', 'GET', '/', 'json', false, 'json', request);
}

model UpdateInstanceRequest {
  regionId?: string(name='RegionId', position='Host'),
  clientToken?: string(name='ClientToken', example='c2c5d1274axxxxxxxx', position='Query'),
  instanceId: string(name='InstanceId', example='amqp-cn-jtexxxxx', position='Query'),
  instanceType?: string(name='InstanceType', example='professional', position='Query'),
  maxConnections?: int32(name='MaxConnections', example='1000', position='Query'),
  maxEipTps?: long(name='MaxEipTps', example='128', position='Query'),
  maxPrivateTps?: long(name='MaxPrivateTps', example='1000', position='Query'),
  modifyType: string(name='ModifyType', example='UPGRADE', position='Query'),
  queueCapacity?: int32(name='QueueCapacity', example='1000', position='Query'),
  serverlessChargeType?: string(name='ServerlessChargeType', example='onDemand', position='Query'),
  storageSize?: int32(name='StorageSize', example='7', position='Query'),
  supportEip?: boolean(name='SupportEip', example='false', position='Query'),
  supportTracing?: boolean(name='SupportTracing', example='false', position='Query'),
  tracingStorageTime?: int32(name='TracingStorageTime', example='3', position='Query'),
}

model UpdateInstanceResponseBody = {
  code?: int32(name='Code', example='200'),
  data?: any(name='Data', example='{“instanceId”: “amqp-cn-jtexxxxx”, “orderId”: 2222222}'),
  message?: string(name='Message', example='InstanceNotExist'),
  requestId?: string(name='RequestId', example='628705FD-03EE-4ABE-BB21-E1672960***'),
  statusCode?: string(name='StatusCode', example='200'),
  success?: string(name='Success', example='true'),
}

model UpdateInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateInstanceResponseBody(name='body'),
}

async function updateInstance(request: UpdateInstanceRequest): UpdateInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateInstance', 'POST', '/', 'json', false, 'json', request);
}

model UpdateInstanceNameRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance for which you want to update the name.', example='amqp-cn-zvp2ajsj****', position='Query'),
  instanceName: string(name='InstanceName', description='The new name of the instance. No limits are imposed on the value. We recommend that you set this parameter to a maximum of 64 characters in length.', example='amqp-cn-ZVp2ajsj****', position='Query'),
}

model UpdateInstanceNameResponseBody = {
  code?: int32(name='Code', description='The returned HTTP status code.', example='200'),
  data?: string(name='Data', description='The returned data.', example='true'),
  message?: string(name='Message', description='The error message that is returned when an error occurs during the update of the instance name.', example='InstanceNotExist'),
  requestId?: string(name='RequestId', description='The request ID.', example='6DC68EC9-0E76-5435-B8C0-FF9492B4****'),
  success?: boolean(name='Success', description='The returned message that indicates the request is successful.', example='true'),
}

model UpdateInstanceNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateInstanceNameResponseBody(name='body'),
}

async function updateInstanceName(request: UpdateInstanceNameRequest): UpdateInstanceNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateInstanceName', 'POST', '/', 'json', false, 'json', request);
}

model DataValue = {
  masterUid?: long(name='masterUid', description='The Alibaba Cloud account ID or Resource Access Management (RAM) user to which the AccessKey pair that is used to create the static username and password belongs.', example='1565*******973901'),
  cInstanceId?: string(name='cInstanceId', description='The ID of the ApsaraMQ for RabbitMQ instance.', example='amqp-cn-uqm******03'),
  accessKey?: string(name='accessKey', description='The AccessKey ID that is used to create the static username and password.', example='LTAI5***********eRZtEJ6vfo'),
  userName?: string(name='userName', description='The static username.', example='MjphbXFwLWNuLXVxbTJ6cjc2djAwMzpMVEFJNX*******ZNMWVSWnRFSjZ2Zm8='),
  password?: string(name='password', description='The static password.', example='OUYwQzM2QjZBRkUxNDRFM***************MzZCNzdDQzoxNjcxNDMwMzkyODI1'),
  deleted?: long(name='deleted', description='The timestamp that indicates when the static username and password were deleted. Unit: milliseconds.', example='1671175303522'),
  createTimestamp?: long(name='createTimestamp', description='The timestamp that indicates when the static username and password were created. Unit: milliseconds.', example='1671175303522'),
}

