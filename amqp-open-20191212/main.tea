/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('amqp-open', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateBindingRequest {
  argument?: string(name='Argument'),
  bindingKey?: string(name='BindingKey'),
  bindingType?: string(name='BindingType'),
  destinationName?: string(name='DestinationName'),
  instanceId?: string(name='InstanceId'),
  sourceExchange?: string(name='SourceExchange'),
  virtualHost?: string(name='VirtualHost'),
}

model CreateBindingResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBindingResponseBody(name='body'),
}

async function createBindingWithOptions(request: CreateBindingRequest, runtime: Util.RuntimeOptions): CreateBindingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.argument)) {
    body['Argument'] = request.argument;
  }
  if (!Util.isUnset(request.bindingKey)) {
    body['BindingKey'] = request.bindingKey;
  }
  if (!Util.isUnset(request.bindingType)) {
    body['BindingType'] = request.bindingType;
  }
  if (!Util.isUnset(request.destinationName)) {
    body['DestinationName'] = request.destinationName;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.sourceExchange)) {
    body['SourceExchange'] = request.sourceExchange;
  }
  if (!Util.isUnset(request.virtualHost)) {
    body['VirtualHost'] = request.virtualHost;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateBinding',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBinding(request: CreateBindingRequest): CreateBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBindingWithOptions(request, runtime);
}

model CreateExchangeRequest {
  alternateExchange?: string(name='AlternateExchange'),
  autoDeleteState?: boolean(name='AutoDeleteState'),
  exchangeName?: string(name='ExchangeName'),
  exchangeType?: string(name='ExchangeType'),
  instanceId?: string(name='InstanceId'),
  internal?: boolean(name='Internal'),
  virtualHost?: string(name='VirtualHost'),
}

model CreateExchangeResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateExchangeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateExchangeResponseBody(name='body'),
}

async function createExchangeWithOptions(request: CreateExchangeRequest, runtime: Util.RuntimeOptions): CreateExchangeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.alternateExchange)) {
    body['AlternateExchange'] = request.alternateExchange;
  }
  if (!Util.isUnset(request.autoDeleteState)) {
    body['AutoDeleteState'] = request.autoDeleteState;
  }
  if (!Util.isUnset(request.exchangeName)) {
    body['ExchangeName'] = request.exchangeName;
  }
  if (!Util.isUnset(request.exchangeType)) {
    body['ExchangeType'] = request.exchangeType;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.internal)) {
    body['Internal'] = request.internal;
  }
  if (!Util.isUnset(request.virtualHost)) {
    body['VirtualHost'] = request.virtualHost;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateExchange',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createExchange(request: CreateExchangeRequest): CreateExchangeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createExchangeWithOptions(request, runtime);
}

model CreateQueueRequest {
  autoDeleteState?: boolean(name='AutoDeleteState'),
  autoExpireState?: long(name='AutoExpireState'),
  deadLetterExchange?: string(name='DeadLetterExchange'),
  deadLetterRoutingKey?: string(name='DeadLetterRoutingKey'),
  exclusiveState?: boolean(name='ExclusiveState'),
  instanceId?: string(name='InstanceId'),
  maxLength?: long(name='MaxLength'),
  maximumPriority?: int32(name='MaximumPriority'),
  messageTTL?: long(name='MessageTTL'),
  queueName?: string(name='QueueName'),
  virtualHost?: string(name='VirtualHost'),
}

model CreateQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateQueueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateQueueResponseBody(name='body'),
}

async function createQueueWithOptions(request: CreateQueueRequest, runtime: Util.RuntimeOptions): CreateQueueResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoDeleteState)) {
    body['AutoDeleteState'] = request.autoDeleteState;
  }
  if (!Util.isUnset(request.autoExpireState)) {
    body['AutoExpireState'] = request.autoExpireState;
  }
  if (!Util.isUnset(request.deadLetterExchange)) {
    body['DeadLetterExchange'] = request.deadLetterExchange;
  }
  if (!Util.isUnset(request.deadLetterRoutingKey)) {
    body['DeadLetterRoutingKey'] = request.deadLetterRoutingKey;
  }
  if (!Util.isUnset(request.exclusiveState)) {
    body['ExclusiveState'] = request.exclusiveState;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.maxLength)) {
    body['MaxLength'] = request.maxLength;
  }
  if (!Util.isUnset(request.maximumPriority)) {
    body['MaximumPriority'] = request.maximumPriority;
  }
  if (!Util.isUnset(request.messageTTL)) {
    body['MessageTTL'] = request.messageTTL;
  }
  if (!Util.isUnset(request.queueName)) {
    body['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.virtualHost)) {
    body['VirtualHost'] = request.virtualHost;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateQueue',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createQueue(request: CreateQueueRequest): CreateQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQueueWithOptions(request, runtime);
}

model CreateVirtualHostRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
}

model CreateVirtualHostResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateVirtualHostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVirtualHostResponseBody(name='body'),
}

async function createVirtualHostWithOptions(request: CreateVirtualHostRequest, runtime: Util.RuntimeOptions): CreateVirtualHostResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.virtualHost)) {
    body['VirtualHost'] = request.virtualHost;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVirtualHost',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVirtualHost(request: CreateVirtualHostRequest): CreateVirtualHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVirtualHostWithOptions(request, runtime);
}

model DeleteBindingRequest {
  bindingKey?: string(name='BindingKey'),
  bindingType?: string(name='BindingType'),
  destinationName?: string(name='DestinationName'),
  instanceId?: string(name='InstanceId'),
  sourceExchange?: string(name='SourceExchange'),
  virtualHost?: string(name='VirtualHost'),
}

model DeleteBindingResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBindingResponseBody(name='body'),
}

async function deleteBindingWithOptions(request: DeleteBindingRequest, runtime: Util.RuntimeOptions): DeleteBindingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bindingKey)) {
    body['BindingKey'] = request.bindingKey;
  }
  if (!Util.isUnset(request.bindingType)) {
    body['BindingType'] = request.bindingType;
  }
  if (!Util.isUnset(request.destinationName)) {
    body['DestinationName'] = request.destinationName;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.sourceExchange)) {
    body['SourceExchange'] = request.sourceExchange;
  }
  if (!Util.isUnset(request.virtualHost)) {
    body['VirtualHost'] = request.virtualHost;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBinding',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBinding(request: DeleteBindingRequest): DeleteBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBindingWithOptions(request, runtime);
}

model DeleteExchangeRequest {
  exchangeName?: string(name='ExchangeName'),
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
}

model DeleteExchangeResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExchangeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteExchangeResponseBody(name='body'),
}

async function deleteExchangeWithOptions(request: DeleteExchangeRequest, runtime: Util.RuntimeOptions): DeleteExchangeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.exchangeName)) {
    body['ExchangeName'] = request.exchangeName;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.virtualHost)) {
    body['VirtualHost'] = request.virtualHost;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteExchange',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteExchange(request: DeleteExchangeRequest): DeleteExchangeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExchangeWithOptions(request, runtime);
}

model DeleteQueueRequest {
  instanceId?: string(name='InstanceId'),
  queueName?: string(name='QueueName'),
  virtualHost?: string(name='VirtualHost'),
}

model DeleteQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteQueueResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteQueueResponseBody(name='body'),
}

async function deleteQueueWithOptions(request: DeleteQueueRequest, runtime: Util.RuntimeOptions): DeleteQueueResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.queueName)) {
    body['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.virtualHost)) {
    body['VirtualHost'] = request.virtualHost;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteQueue',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteQueue(request: DeleteQueueRequest): DeleteQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQueueWithOptions(request, runtime);
}

model DeleteVirtualHostRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
}

model DeleteVirtualHostResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualHostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVirtualHostResponseBody(name='body'),
}

async function deleteVirtualHostWithOptions(request: DeleteVirtualHostRequest, runtime: Util.RuntimeOptions): DeleteVirtualHostResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.virtualHost)) {
    body['VirtualHost'] = request.virtualHost;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVirtualHost',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVirtualHost(request: DeleteVirtualHostRequest): DeleteVirtualHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVirtualHostWithOptions(request, runtime);
}

model GetMetadataAmountRequest {
  instanceId?: string(name='InstanceId'),
}

model GetMetadataAmountResponseBody = {
  data?: {
    currentExchanges?: int32(name='CurrentExchanges'),
    currentQueues?: int32(name='CurrentQueues'),
    currentVirtualHosts?: int32(name='CurrentVirtualHosts'),
    maxExchanges?: int32(name='MaxExchanges'),
    maxQueues?: int32(name='MaxQueues'),
    maxVirtualHosts?: int32(name='MaxVirtualHosts'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetMetadataAmountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMetadataAmountResponseBody(name='body'),
}

async function getMetadataAmountWithOptions(request: GetMetadataAmountRequest, runtime: Util.RuntimeOptions): GetMetadataAmountResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetadataAmount',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetadataAmount(request: GetMetadataAmountRequest): GetMetadataAmountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetadataAmountWithOptions(request, runtime);
}

model ListBindingsRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  virtualHost?: string(name='VirtualHost'),
}

model ListBindingsResponseBody = {
  data?: {
    bindings?: [ 
      {
        argument?: string(name='Argument'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: string(name='BindingType'),
        destinationName?: string(name='DestinationName'),
        sourceExchange?: string(name='SourceExchange'),
      }
    ](name='Bindings'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListBindingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBindingsResponseBody(name='body'),
}

async function listBindingsWithOptions(request: ListBindingsRequest, runtime: Util.RuntimeOptions): ListBindingsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBindings',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBindings(request: ListBindingsRequest): ListBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBindingsWithOptions(request, runtime);
}

model ListDownStreamBindingsRequest {
  exchangeName?: string(name='ExchangeName'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  virtualHost?: string(name='VirtualHost'),
}

model ListDownStreamBindingsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    bindings?: [ 
      {
        argument?: string(name='Argument'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: string(name='BindingType'),
        destinationName?: string(name='DestinationName'),
        sourceExchange?: string(name='SourceExchange'),
      }
    ](name='Bindings'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDownStreamBindingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDownStreamBindingsResponseBody(name='body'),
}

async function listDownStreamBindingsWithOptions(request: ListDownStreamBindingsRequest, runtime: Util.RuntimeOptions): ListDownStreamBindingsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDownStreamBindings',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDownStreamBindings(request: ListDownStreamBindingsRequest): ListDownStreamBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDownStreamBindingsWithOptions(request, runtime);
}

model ListExchangeUpStreamBindingsRequest {
  exchangeName?: string(name='ExchangeName'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  virtualHost?: string(name='VirtualHost'),
}

model ListExchangeUpStreamBindingsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    bindings?: [ 
      {
        argument?: string(name='Argument'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: string(name='BindingType'),
        destinationName?: string(name='DestinationName'),
        sourceExchange?: string(name='SourceExchange'),
      }
    ](name='Bindings'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListExchangeUpStreamBindingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListExchangeUpStreamBindingsResponseBody(name='body'),
}

async function listExchangeUpStreamBindingsWithOptions(request: ListExchangeUpStreamBindingsRequest, runtime: Util.RuntimeOptions): ListExchangeUpStreamBindingsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExchangeUpStreamBindings',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listExchangeUpStreamBindings(request: ListExchangeUpStreamBindingsRequest): ListExchangeUpStreamBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExchangeUpStreamBindingsWithOptions(request, runtime);
}

model ListExchangesRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  virtualHost?: string(name='VirtualHost'),
}

model ListExchangesResponseBody = {
  data?: {
    exchanges?: [ 
      {
        attributes?: map[string]any(name='Attributes'),
        autoDeleteState?: boolean(name='AutoDeleteState'),
        createTime?: long(name='CreateTime'),
        exchangeType?: string(name='ExchangeType'),
        name?: string(name='Name'),
        VHostName?: string(name='VHostName'),
      }
    ](name='Exchanges'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListExchangesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListExchangesResponseBody(name='body'),
}

async function listExchangesWithOptions(request: ListExchangesRequest, runtime: Util.RuntimeOptions): ListExchangesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExchanges',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listExchanges(request: ListExchangesRequest): ListExchangesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExchangesWithOptions(request, runtime);
}

model ListInstancesRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListInstancesResponseBody = {
  data?: {
    instances?: [ 
      {
        autoRenewInstance?: boolean(name='AutoRenewInstance'),
        classicEndpoint?: string(name='ClassicEndpoint'),
        expireTime?: long(name='ExpireTime'),
        instanceId?: string(name='InstanceId'),
        instanceName?: string(name='InstanceName'),
        instanceType?: string(name='InstanceType'),
        maxEipTps?: int32(name='MaxEipTps'),
        maxQueue?: int32(name='MaxQueue'),
        maxTps?: int32(name='MaxTps'),
        maxVhost?: int32(name='MaxVhost'),
        orderCreateTime?: long(name='OrderCreateTime'),
        orderType?: string(name='OrderType'),
        privateEndpoint?: string(name='PrivateEndpoint'),
        publicEndpoint?: string(name='PublicEndpoint'),
        status?: string(name='Status'),
        storageSize?: int32(name='StorageSize'),
        supportEIP?: boolean(name='SupportEIP'),
      }
    ](name='Instances'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstancesWithOptions(request: ListInstancesRequest, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancesWithOptions(request, runtime);
}

model ListQueueConsumersRequest {
  instanceId?: string(name='InstanceId'),
  nextToken?: string(name='NextToken'),
  queryCount?: int32(name='QueryCount'),
  queue?: string(name='Queue'),
  virtualHost?: string(name='VirtualHost'),
}

model ListQueueConsumersResponseBody = {
  data?: {
    consumers?: [ 
      {
        consumerTag?: string(name='ConsumerTag'),
      }
    ](name='Consumers'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListQueueConsumersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListQueueConsumersResponseBody(name='body'),
}

async function listQueueConsumersWithOptions(request: ListQueueConsumersRequest, runtime: Util.RuntimeOptions): ListQueueConsumersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQueueConsumers',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listQueueConsumers(request: ListQueueConsumersRequest): ListQueueConsumersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQueueConsumersWithOptions(request, runtime);
}

model ListQueueUpStreamBindingsRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  queueName?: string(name='QueueName'),
  virtualHost?: string(name='VirtualHost'),
}

model ListQueueUpStreamBindingsResponseBody = {
  data?: {
    bindings?: [ 
      {
        argument?: string(name='Argument'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: string(name='BindingType'),
        destinationName?: string(name='DestinationName'),
        sourceExchange?: string(name='SourceExchange'),
      }
    ](name='Bindings'),
    maxResults?: string(name='MaxResults'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListQueueUpStreamBindingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListQueueUpStreamBindingsResponseBody(name='body'),
}

async function listQueueUpStreamBindingsWithOptions(request: ListQueueUpStreamBindingsRequest, runtime: Util.RuntimeOptions): ListQueueUpStreamBindingsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQueueUpStreamBindings',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listQueueUpStreamBindings(request: ListQueueUpStreamBindingsRequest): ListQueueUpStreamBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQueueUpStreamBindingsWithOptions(request, runtime);
}

model ListQueuesRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  virtualHost?: string(name='VirtualHost'),
}

model ListQueuesResponseBody = {
  data?: {
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    queues?: [ 
      {
        attributes?: map[string]any(name='Attributes'),
        autoDeleteState?: boolean(name='AutoDeleteState'),
        createTime?: long(name='CreateTime'),
        exclusiveState?: boolean(name='ExclusiveState'),
        lastConsumeTime?: long(name='LastConsumeTime'),
        name?: string(name='Name'),
        ownerId?: string(name='OwnerId'),
        VHostName?: string(name='VHostName'),
      }
    ](name='Queues'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListQueuesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListQueuesResponseBody(name='body'),
}

async function listQueuesWithOptions(request: ListQueuesRequest, runtime: Util.RuntimeOptions): ListQueuesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQueues',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listQueues(request: ListQueuesRequest): ListQueuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQueuesWithOptions(request, runtime);
}

model ListVirtualHostsRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListVirtualHostsResponseBody = {
  data?: {
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    virtualHosts?: [ 
      {
        name?: string(name='Name'),
      }
    ](name='VirtualHosts'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListVirtualHostsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVirtualHostsResponseBody(name='body'),
}

async function listVirtualHostsWithOptions(request: ListVirtualHostsRequest, runtime: Util.RuntimeOptions): ListVirtualHostsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVirtualHosts',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVirtualHosts(request: ListVirtualHostsRequest): ListVirtualHostsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVirtualHostsWithOptions(request, runtime);
}

model UpdateInstanceNameRequest {
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
}

model UpdateInstanceNameResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateInstanceNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceNameResponseBody(name='body'),
}

async function updateInstanceNameWithOptions(request: UpdateInstanceNameRequest, runtime: Util.RuntimeOptions): UpdateInstanceNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstanceName',
    version = '2019-12-12',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateInstanceName(request: UpdateInstanceNameRequest): UpdateInstanceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInstanceNameWithOptions(request, runtime);
}

