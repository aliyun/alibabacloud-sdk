/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  

  checkConfig(config);
  @endpoint = getEndpoint('amqp-open', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CreateBindingRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
  sourceExchange?: string(name='SourceExchange'),
  destinationName?: string(name='DestinationName'),
  bindingKey?: string(name='BindingKey'),
  bindingType?: string(name='BindingType'),
  argument?: string(name='Argument'),
}

model CreateBindingResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateBindingResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBindingResponseBody(name='body'),
}

async function createBindingWithOptions(request: CreateBindingRequest, runtime: Util.RuntimeOptions): CreateBindingResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateBinding', '2019-12-12', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createBinding(request: CreateBindingRequest): CreateBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBindingWithOptions(request, runtime);
}

model CreateExchangeRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
  exchangeName?: string(name='ExchangeName'),
  exchangeType?: string(name='ExchangeType'),
  autoDeleteState?: boolean(name='AutoDeleteState'),
  internal?: boolean(name='Internal'),
  alternateExchange?: string(name='AlternateExchange'),
}

model CreateExchangeResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateExchangeResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExchangeResponseBody(name='body'),
}

async function createExchangeWithOptions(request: CreateExchangeRequest, runtime: Util.RuntimeOptions): CreateExchangeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateExchange', '2019-12-12', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createExchange(request: CreateExchangeRequest): CreateExchangeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createExchangeWithOptions(request, runtime);
}

model CreateQueueRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
  queueName?: string(name='QueueName'),
  autoDeleteState?: boolean(name='AutoDeleteState'),
  exclusiveState?: boolean(name='ExclusiveState'),
  messageTTL?: long(name='MessageTTL'),
  autoExpireState?: long(name='AutoExpireState'),
  maxLength?: long(name='MaxLength'),
  deadLetterExchange?: string(name='DeadLetterExchange'),
  deadLetterRoutingKey?: string(name='DeadLetterRoutingKey'),
  maximumPriority?: int32(name='MaximumPriority'),
}

model CreateQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateQueueResponse = {
  headers: map[string]string(name='headers'),
  body: CreateQueueResponseBody(name='body'),
}

async function createQueueWithOptions(request: CreateQueueRequest, runtime: Util.RuntimeOptions): CreateQueueResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateQueue', '2019-12-12', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createQueue(request: CreateQueueRequest): CreateQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQueueWithOptions(request, runtime);
}

model CreateVirtualHostRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
}

model CreateVirtualHostResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateVirtualHostResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVirtualHostResponseBody(name='body'),
}

async function createVirtualHostWithOptions(request: CreateVirtualHostRequest, runtime: Util.RuntimeOptions): CreateVirtualHostResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVirtualHost', '2019-12-12', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVirtualHost(request: CreateVirtualHostRequest): CreateVirtualHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVirtualHostWithOptions(request, runtime);
}

model DeleteBindingRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
  sourceExchange?: string(name='SourceExchange'),
  destinationName?: string(name='DestinationName'),
  bindingType?: string(name='BindingType'),
  bindingKey?: string(name='BindingKey'),
}

model DeleteBindingResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBindingResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBindingResponseBody(name='body'),
}

async function deleteBindingWithOptions(request: DeleteBindingRequest, runtime: Util.RuntimeOptions): DeleteBindingResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteBinding', '2019-12-12', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteBinding(request: DeleteBindingRequest): DeleteBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBindingWithOptions(request, runtime);
}

model DeleteExchangeRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
  exchangeName?: string(name='ExchangeName'),
}

model DeleteExchangeResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteExchangeResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExchangeResponseBody(name='body'),
}

async function deleteExchangeWithOptions(request: DeleteExchangeRequest, runtime: Util.RuntimeOptions): DeleteExchangeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteExchange', '2019-12-12', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteExchange(request: DeleteExchangeRequest): DeleteExchangeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExchangeWithOptions(request, runtime);
}

model DeleteQueueRequest {
  instanceId?: string(name='InstanceId'),
  queueName?: string(name='QueueName'),
  virtualHost?: string(name='VirtualHost'),
}

model DeleteQueueResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteQueueResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteQueueResponseBody(name='body'),
}

async function deleteQueueWithOptions(request: DeleteQueueRequest, runtime: Util.RuntimeOptions): DeleteQueueResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteQueue', '2019-12-12', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteQueue(request: DeleteQueueRequest): DeleteQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQueueWithOptions(request, runtime);
}

model DeleteVirtualHostRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
}

model DeleteVirtualHostResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualHostResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVirtualHostResponseBody(name='body'),
}

async function deleteVirtualHostWithOptions(request: DeleteVirtualHostRequest, runtime: Util.RuntimeOptions): DeleteVirtualHostResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVirtualHost', '2019-12-12', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVirtualHost(request: DeleteVirtualHostRequest): DeleteVirtualHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVirtualHostWithOptions(request, runtime);
}

model GetMetadataAmountRequest {
  instanceId?: string(name='InstanceId'),
}

model GetMetadataAmountResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    maxVirtualHosts?: int32(name='MaxVirtualHosts'),
    currentVirtualHosts?: int32(name='CurrentVirtualHosts'),
    maxQueues?: int32(name='MaxQueues'),
    currentExchanges?: int32(name='CurrentExchanges'),
    maxExchanges?: int32(name='MaxExchanges'),
    currentQueues?: int32(name='CurrentQueues'),
  }(name='Data'),
}

model GetMetadataAmountResponse = {
  headers: map[string]string(name='headers'),
  body: GetMetadataAmountResponseBody(name='body'),
}

async function getMetadataAmountWithOptions(request: GetMetadataAmountRequest, runtime: Util.RuntimeOptions): GetMetadataAmountResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('GetMetadataAmount', '2019-12-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function getMetadataAmount(request: GetMetadataAmountRequest): GetMetadataAmountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetadataAmountWithOptions(request, runtime);
}

model ListBindingsRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
}

model ListBindingsResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    nextToken?: string(name='NextToken'),
    maxResults?: int32(name='MaxResults'),
    bindings?: [ 
      {
        sourceExchange?: string(name='SourceExchange'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: string(name='BindingType'),
        argument?: string(name='Argument'),
        destinationName?: string(name='DestinationName'),
      }
    ](name='Bindings'),
  }(name='Data'),
}

model ListBindingsResponse = {
  headers: map[string]string(name='headers'),
  body: ListBindingsResponseBody(name='body'),
}

async function listBindingsWithOptions(request: ListBindingsRequest, runtime: Util.RuntimeOptions): ListBindingsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListBindings', '2019-12-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listBindings(request: ListBindingsRequest): ListBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBindingsWithOptions(request, runtime);
}

model ListDownStreamBindingsRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
  exchangeName?: string(name='ExchangeName'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
}

model ListDownStreamBindingsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    nextToken?: string(name='NextToken'),
    maxResults?: int32(name='MaxResults'),
    bindings?: [ 
      {
        sourceExchange?: string(name='SourceExchange'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: string(name='BindingType'),
        argument?: string(name='Argument'),
        destinationName?: string(name='DestinationName'),
      }
    ](name='Bindings'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ListDownStreamBindingsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDownStreamBindingsResponseBody(name='body'),
}

async function listDownStreamBindingsWithOptions(request: ListDownStreamBindingsRequest, runtime: Util.RuntimeOptions): ListDownStreamBindingsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListDownStreamBindings', '2019-12-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listDownStreamBindings(request: ListDownStreamBindingsRequest): ListDownStreamBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDownStreamBindingsWithOptions(request, runtime);
}

model ListExchangesRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
}

model ListExchangesResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    nextToken?: string(name='NextToken'),
    maxResults?: int32(name='MaxResults'),
    exchanges?: [ 
      {
        autoDeleteState?: boolean(name='AutoDeleteState'),
        createTime?: long(name='CreateTime'),
        attributes?: map[string]any(name='Attributes'),
        VHostName?: string(name='VHostName'),
        name?: string(name='Name'),
        exchangeType?: string(name='ExchangeType'),
      }
    ](name='Exchanges'),
  }(name='Data'),
}

model ListExchangesResponse = {
  headers: map[string]string(name='headers'),
  body: ListExchangesResponseBody(name='body'),
}

async function listExchangesWithOptions(request: ListExchangesRequest, runtime: Util.RuntimeOptions): ListExchangesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListExchanges', '2019-12-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listExchanges(request: ListExchangesRequest): ListExchangesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExchangesWithOptions(request, runtime);
}

model ListExchangeUpStreamBindingsRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
  exchangeName?: string(name='ExchangeName'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
}

model ListExchangeUpStreamBindingsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    nextToken?: string(name='NextToken'),
    maxResults?: int32(name='MaxResults'),
    bindings?: [ 
      {
        sourceExchange?: string(name='SourceExchange'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: string(name='BindingType'),
        argument?: string(name='Argument'),
        destinationName?: string(name='DestinationName'),
      }
    ](name='Bindings'),
  }(name='Data'),
  code?: int32(name='Code'),
  success?: boolean(name='Success'),
}

model ListExchangeUpStreamBindingsResponse = {
  headers: map[string]string(name='headers'),
  body: ListExchangeUpStreamBindingsResponseBody(name='body'),
}

async function listExchangeUpStreamBindingsWithOptions(request: ListExchangeUpStreamBindingsRequest, runtime: Util.RuntimeOptions): ListExchangeUpStreamBindingsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListExchangeUpStreamBindings', '2019-12-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listExchangeUpStreamBindings(request: ListExchangeUpStreamBindingsRequest): ListExchangeUpStreamBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExchangeUpStreamBindingsWithOptions(request, runtime);
}

model ListInstancesRequest {
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
}

model ListInstancesResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    nextToken?: string(name='NextToken'),
    maxResults?: int32(name='MaxResults'),
    instances?: [ 
      {
        status?: string(name='Status'),
        supportEIP?: boolean(name='SupportEIP'),
        autoRenewInstance?: boolean(name='AutoRenewInstance'),
        expireTime?: long(name='ExpireTime'),
        orderCreateTime?: long(name='OrderCreateTime'),
        instanceName?: string(name='InstanceName'),
        privateEndpoint?: string(name='PrivateEndpoint'),
        orderType?: string(name='OrderType'),
        instanceId?: string(name='InstanceId'),
        instanceType?: string(name='InstanceType'),
        publicEndpoint?: string(name='PublicEndpoint'),
      }
    ](name='Instances'),
  }(name='Data'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstancesWithOptions(request: ListInstancesRequest, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListInstances', '2019-12-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancesWithOptions(request, runtime);
}

model ListQueueConsumersRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
  queue?: string(name='Queue'),
  nextToken?: string(name='NextToken'),
  queryCount?: int32(name='QueryCount'),
}

model ListQueueConsumersResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    nextToken?: string(name='NextToken'),
    consumers?: [ 
      {
        consumerTag?: string(name='ConsumerTag'),
      }
    ](name='Consumers'),
    maxResults?: int32(name='MaxResults'),
  }(name='Data'),
}

model ListQueueConsumersResponse = {
  headers: map[string]string(name='headers'),
  body: ListQueueConsumersResponseBody(name='body'),
}

async function listQueueConsumersWithOptions(request: ListQueueConsumersRequest, runtime: Util.RuntimeOptions): ListQueueConsumersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListQueueConsumers', '2019-12-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listQueueConsumers(request: ListQueueConsumersRequest): ListQueueConsumersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQueueConsumersWithOptions(request, runtime);
}

model ListQueuesRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
}

model ListQueuesResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    nextToken?: string(name='NextToken'),
    queues?: [ 
      {
        exclusiveState?: boolean(name='ExclusiveState'),
        autoDeleteState?: boolean(name='AutoDeleteState'),
        createTime?: long(name='CreateTime'),
        attributes?: map[string]any(name='Attributes'),
        VHostName?: string(name='VHostName'),
        name?: string(name='Name'),
        ownerId?: string(name='OwnerId'),
        lastConsumeTime?: long(name='LastConsumeTime'),
      }
    ](name='Queues'),
    maxResults?: int32(name='MaxResults'),
  }(name='Data'),
}

model ListQueuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListQueuesResponseBody(name='body'),
}

async function listQueuesWithOptions(request: ListQueuesRequest, runtime: Util.RuntimeOptions): ListQueuesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListQueues', '2019-12-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listQueues(request: ListQueuesRequest): ListQueuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQueuesWithOptions(request, runtime);
}

model ListQueueUpStreamBindingsRequest {
  instanceId?: string(name='InstanceId'),
  virtualHost?: string(name='VirtualHost'),
  queueName?: string(name='QueueName'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
}

model ListQueueUpStreamBindingsResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    nextToken?: string(name='NextToken'),
    maxResults?: string(name='MaxResults'),
    bindings?: [ 
      {
        sourceExchange?: string(name='SourceExchange'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: string(name='BindingType'),
        argument?: string(name='Argument'),
        destinationName?: string(name='DestinationName'),
      }
    ](name='Bindings'),
  }(name='Data'),
}

model ListQueueUpStreamBindingsResponse = {
  headers: map[string]string(name='headers'),
  body: ListQueueUpStreamBindingsResponseBody(name='body'),
}

async function listQueueUpStreamBindingsWithOptions(request: ListQueueUpStreamBindingsRequest, runtime: Util.RuntimeOptions): ListQueueUpStreamBindingsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListQueueUpStreamBindings', '2019-12-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listQueueUpStreamBindings(request: ListQueueUpStreamBindingsRequest): ListQueueUpStreamBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQueueUpStreamBindingsWithOptions(request, runtime);
}

model ListVirtualHostsRequest {
  instanceId?: string(name='InstanceId'),
  nextToken?: string(name='NextToken'),
  maxResults?: int32(name='MaxResults'),
}

model ListVirtualHostsResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    nextToken?: string(name='NextToken'),
    maxResults?: int32(name='MaxResults'),
    virtualHosts?: [ 
      {
        name?: string(name='Name'),
      }
    ](name='VirtualHosts'),
  }(name='Data'),
}

model ListVirtualHostsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVirtualHostsResponseBody(name='body'),
}

async function listVirtualHostsWithOptions(request: ListVirtualHostsRequest, runtime: Util.RuntimeOptions): ListVirtualHostsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListVirtualHosts', '2019-12-12', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listVirtualHosts(request: ListVirtualHostsRequest): ListVirtualHostsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVirtualHostsWithOptions(request, runtime);
}

