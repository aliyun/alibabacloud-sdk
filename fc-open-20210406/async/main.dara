/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'FC-Open';
  @version = '2021-04-06';
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'account-id.ap-northeast-1.fc.aliyuncs.com',
    ap-south-1 = 'account-id.ap-south-1.fc.aliyuncs.com',
    ap-southeast-1 = 'account-id.ap-southeast-1.fc.aliyuncs.com',
    ap-southeast-2 = 'account-id.ap-southeast-2.fc.aliyuncs.com',
    ap-southeast-3 = 'account-id.ap-southeast-3.fc.aliyuncs.com',
    ap-southeast-5 = 'account-id.ap-southeast-5.fc.aliyuncs.com',
    cn-beijing = 'account-id.cn-beijing.fc.aliyuncs.com',
    cn-chengdu = 'account-id.cn-chengdu.fc.aliyuncs.com',
    cn-hangzhou = 'account-id.cn-hangzhou.fc.aliyuncs.com',
    cn-hangzhou-finance = 'account-id.cn-hangzhou-finance.fc.aliyuncs.com',
    cn-hongkong = 'account-id.cn-hongkong.fc.aliyuncs.com',
    cn-huhehaote = 'account-id.cn-huhehaote.fc.aliyuncs.com',
    cn-north-2-gov-1 = 'account-id.cn-north-2-gov-1.fc.aliyuncs.com',
    cn-qingdao = 'account-id.cn-qingdao.fc.aliyuncs.com',
    cn-shanghai = 'account-id.cn-shanghai.fc.aliyuncs.com',
    cn-shenzhen = 'account-id.cn-shenzhen.fc.aliyuncs.com',
    cn-zhangjiakou = 'account-id.cn-zhangjiakou.fc.aliyuncs.com',
    eu-central-1 = 'account-id.eu-central-1.fc.aliyuncs.com',
    eu-west-1 = 'account-id.eu-west-1.fc.aliyuncs.com',
    us-east-1 = 'account-id.us-east-1.fc.aliyuncs.com',
    us-west-1 = 'account-id.us-west-1.fc.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AccelerationInfo {
  status?: string(name='status', description='镜像加速状态，取值 Preparing 或 Ready'),
}

model AsyncConfigMeta {
  functionName?: string(name='functionName', description='异步配置所属函数名称。'),
  qualifier?: string(name='qualifier', description='异步配置所属服务版本/别名。'),
  serviceName?: string(name='serviceName', description='异步配置所属服务名称。'),
}

model AvailableAZ {
  availableAZs?: string(name='availableAZs', description='az'),
}

model CDNEventsTriggerConfig {
  eventName?: string(name='eventName', description='eventName'),
  eventVersion?: string(name='eventVersion', description='eventVersion'),
  filter?: map[string][ string ](name='filter', description='filter'),
  notes?: string(name='notes', description='notes'),
}

model CertConfig {
  certName?: string(name='certName', description='证书名称'),
  certificate?: string(name='certificate', description='证书，如果是证书链则依次填写多个证书'),
  privateKey?: string(name='privateKey', description='私钥'),
}

model Code {
  ossBucketName?: string(name='ossBucketName', description='函数代码包的OSS bucket name'),
  ossObjectName?: string(name='ossObjectName', description='函数代码包的OSS对象名'),
  zipFile?: string(name='zipFile', description='直接在request body中上传code zip包的base64编码'),
}

model CustomContainerConfig {
  accelerationType?: string(name='accelerationType', description='镜像加速类型，取值Default为开启加速，None为关闭加速，默认开启'),
  args?: string(name='args', description='容器启动参数'),
  command?: string(name='command', description='容器启动命令，等同于 Docker ENTRYPOINT'),
  image?: string(name='image', description='容器镜像地址，实例值： registry-vpc.cn-hangzhou.aliyuncs.com/fc-demo/helloworld:v1beta1'),
  instanceID?: string(name='instanceID', description='ACR企业版镜像仓库ID，使用ACR企业版镜像时须传入'),
}

model CustomContainerConfigInfo {
  accelerationInfo?: AccelerationInfo(name='accelerationInfo'),
  accelerationType?: string(name='accelerationType', description='镜像加速类型，取值Default为开启加速，None为关闭加速，默认开启'),
  args?: string(name='args', description='容器启动参数'),
  command?: string(name='command', description='容器启动命令，等同于 Docker ENTRYPOINT'),
  image?: string(name='image', description='容器镜像地址，实例值： registry-vpc.cn-hangzhou.aliyuncs.com/fc-demo/helloworld:v1beta1'),
  instanceID?: string(name='instanceID', description='ACR企业版镜像仓库ID，使用ACR企业版镜像时须传入'),
}

model CustomDNS {
  dnsOptions?: [
    DNSOption
  ](name='dnsOptions', description='DNS resolver 配置参数列表'),
  nameServers?: [ string ](name='nameServers', description='DNS 服务器的 IP 地址列表'),
  searches?: [ string ](name='searches', description='DNS 搜索域的列表'),
}

model CustomRuntimeConfig {
  args?: [ string ](name='args', description='启动入口命令接收的参数'),
  command?: [ string ](name='command', description='启动入口命令'),
}

model DNSOption {
  name: string(name='name', description='DNS option 名称'),
  value?: string(name='value', description='DNS option 值'),
}

model Destination {
  destination?: string(name='destination', description='destination'),
}

model DestinationConfig {
  onFailure?: Destination(name='onFailure'),
  onSuccess?: Destination(name='onSuccess'),
}

model Error {
  errorCode?: string(name='errorCode', description='错误码'),
  errorMessage?: string(name='errorMessage', description='错误信息描述'),
}

model ErrorInfo {
  errorMessage?: string(name='errorMessage', description='错误信息'),
  stackTrace?: string(name='stackTrace', description='错误堆栈'),
}

model EventBridgeTriggerConfig {
  asyncInvocationType?: boolean(name='asyncInvocationType', description='asyncInvocationType'),
  eventRuleFilterPattern: string(name='eventRuleFilterPattern', description='eventRuleFilterPattern'),
  eventSourceConfig: EventSourceConfig(name='eventSourceConfig'),
  triggerEnable?: boolean(name='triggerEnable', description='triggerEnable'),
}

model EventSourceConfig {
  eventSourceParameters?: EventSourceParameters(name='eventSourceParameters'),
  eventSourceType: string(name='eventSourceType', description='eventSourceType'),
}

model EventSourceParameters {
  sourceMNSParameters?: SourceMNSParameters(name='sourceMNSParameters'),
  sourceRabbitMQParameters?: SourceRabbitMQParameters(name='sourceRabbitMQParameters'),
  sourceRocketMQParameters?: SourceRocketMQParameters(name='sourceRocketMQParameters'),
}

model HTTPTriggerConfig {
  authType?: string(name='authType', description='认证类型'),
  methods?: [ string ](name='methods', description='允许的HTTP方法列表'),
}

model InstanceLifecycleConfig {
  preFreeze?: LifecycleHook(name='preFreeze'),
  preStop?: LifecycleHook(name='preStop'),
}

model JaegerConfig {
  endpoint?: string(name='endpoint', description='endpoint'),
}

model JobConfig {
  maxRetryTime?: long(name='maxRetryTime', description='maxRetryTime'),
  triggerInterval?: long(name='triggerInterval', description='triggerInterval'),
}

model JobLogConfig {
  logstore?: string(name='logstore', description='logstore'),
  project?: string(name='project', description='project'),
}

model Layer {
  acl?: int32(name='acl', description='层访问类型'),
  arn?: string(name='arn', description='arn'),
  code?: LayerCode(name='code', description='层代码'),
  codeChecksum?: string(name='codeChecksum', description='层Checksum'),
  codeSize?: long(name='codeSize', description='层代码大小'),
  compatibleRuntime?: [ string ](name='compatibleRuntime', description='compatibleRuntime'),
  createTime?: string(name='createTime', description='层创建时间'),
  description?: string(name='description', description='层描述'),
  layerName?: string(name='layerName', description='层名称'),
  version?: int32(name='version', description='层版本'),
}

model LayerCode {
  location?: string(name='location', description='层代码位置'),
  repositoryType?: string(name='repositoryType', description='层代码类型'),
}

model LifecycleHook {
  handler?: string(name='handler', description='handler name'),
  timeout?: int32(name='timeout', description='timeout in second'),
}

model LogConfig {
  enableInstanceMetrics?: boolean(name='enableInstanceMetrics', description='开启实例级别指标'),
  enableRequestMetrics?: boolean(name='enableRequestMetrics', description='开启请求级别指标'),
  logBeginRule?: string(name='logBeginRule', description='日志切分规则'),
  logstore?: string(name='logstore', description='日志库'),
  project?: string(name='project', description='日志项目'),
}

model LogTriggerConfig {
  enable?: boolean(name='enable', description='enable'),
  functionParameter?: map[string]string(name='functionParameter', description='functionParameter'),
  jobConfig?: JobConfig(name='jobConfig'),
  logConfig?: JobLogConfig(name='logConfig'),
  sourceConfig?: SourceConfig(name='sourceConfig'),
}

model MeteringConfig {
  logConfig?: LogConfig(name='logConfig', description='日志仓库'),
  payerId?: string(name='payerId', description='支付用户'),
  role?: string(name='role', description='权限'),
}

model MnsTopicTriggerConfig {
  filterTag?: string(name='filterTag', description='filterTag'),
  notifyContentFormat?: string(name='notifyContentFormat', description='notifyContentFormat'),
  notifyStrategy?: string(name='notifyStrategy', description='notifyStrategy'),
}

model NASConfig {
  groupId?: int32(name='groupId', description='groupID'),
  mountPoints?: [ 
    {
      mountDir?: string(name='mountDir', description='本地挂载目录'),
      serverAddr?: string(name='serverAddr', description='NAS服务器地址'),
    }
  ](name='mountPoints', description='挂载点'),
  userId?: int32(name='userId', description='userID'),
}

model OSSTriggerConfig {
  events?: [ string ](name='events', description='events'),
  filter?: OSSTriggerFilter(name='filter'),
}

model OSSTriggerFilter {
  key?: OSSTriggerKey(name='key'),
}

model OSSTriggerKey {
  prefix?: string(name='prefix', description='prefix'),
  suffix?: string(name='suffix', description='suffix'),
}

model OnDemandConfig {
  maximumInstanceCount?: long(name='maximumInstanceCount', description='todo'),
  resource?: string(name='resource', description='函数详情'),
}

model OpenReservedCapacity {
  createdTime?: string(name='createdTime', description='createdTime'),
  cu?: long(name='cu', description='cu'),
  deadline?: string(name='deadline', description='deadline'),
  instanceId?: string(name='instanceId', description='instanceId'),
  isRefunded?: string(name='isRefunded', description='isRefunded'),
  lastModifiedTime?: string(name='lastModifiedTime', description='lastModifiedTime'),
}

model OutputCodeLocation {
  location?: string(name='location', description='location'),
  repositoryType?: string(name='repositoryType', description='repositoryType'),
}

model PathConfig {
  functionName?: string(name='functionName', description='该路径/方法对应的函数名称'),
  methods?: [ string ](name='methods', description='请求方法，不填表示当前路径的所有方法匹配同一函数'),
  path?: string(name='path', description='请求路径'),
  qualifier?: string(name='qualifier', description='该路径/方法对应服务的版本/别名'),
  serviceName?: string(name='serviceName', description='该路径/方法对应的服务名称'),
}

model PreFreeze {
  handler?: string(name='handler', description='preFreeze handler name'),
  timeout?: int32(name='timeout', description='handler timeout'),
}

model PreStop {
  handler?: string(name='handler', description='PreStop handler'),
  timeout?: int32(name='timeout', description='PreStop hander timeout'),
}

model RdsTriggerConfig {
  concurrency?: long(name='concurrency', description='concurrency'),
  eventFormat?: string(name='eventFormat', description='eventFormat'),
  retry?: long(name='retry', description='retry'),
  subscriptionObjects?: [ string ](name='subscriptionObjects', description='subscriptionObjects'),
}

model Resource {
  resourceArn?: string(name='resourceArn', description='resourceArn'),
  tags?: map[string]string(name='tags', description='tags'),
}

model RouteConfig {
  routes?: [
    PathConfig
  ](name='routes', description='routes'),
}

model ScheduledActions {
  endTime?: string(name='endTime', description='endTime'),
  name?: string(name='name', description='name'),
  scheduleExpression?: string(name='scheduleExpression', description='scheduleExpression'),
  startTime?: string(name='startTime', description='startTime'),
  target?: long(name='target', description='target'),
}

model SourceConfig {
  logstore?: string(name='logstore', description='logstore'),
}

model SourceMNSParameters {
  isBase64Decode?: boolean(name='IsBase64Decode', description='IsBase64Decode'),
  queueName: string(name='QueueName', description='QueueName'),
  regionId?: string(name='RegionId', description='RegionId'),
}

model SourceRabbitMQParameters {
  instanceId: string(name='InstanceId', description='InstanceId'),
  queueName: string(name='QueueName', description='QueueName'),
  regionId?: string(name='RegionId', description='RegionId'),
  virtualHostName: string(name='VirtualHostName', description='VirtualHostName'),
}

model SourceRocketMQParameters {
  groupID: string(name='GroupID', description='GroupID'),
  instanceId: string(name='InstanceId', description='InstanceId'),
  offset?: string(name='Offset', description='Offset'),
  regionId?: string(name='RegionId', description='RegionId'),
  tag?: string(name='Tag', description='Tag'),
  timestamp?: long(name='Timestamp', description='Timestamp'),
  topic: string(name='Topic', description='Topic'),
}

model StatefulAsyncInvocation {
  alreadyRetriedTimes?: long(name='alreadyRetriedTimes', description='异步任务调用失败后的已重试次数。'),
  destinationStatus?: string(name='destinationStatus', description='异步任务的目的状态。'),
  endTime?: long(name='endTime', description='异步任务的结束时间。'),
  events?: [
    StatefulAsyncInvocationEvent
  ](name='events', description='异步任务事件列表。'),
  functionName?: string(name='functionName', description='异步任务所属的函数的名称。'),
  instanceId?: string(name='instanceId', description='异步任务的执行实例ID。'),
  invocationErrorMessage?: string(name='invocationErrorMessage', description='异步任务的错误消息。'),
  invocationId?: string(name='invocationId', description='异步任务ID。'),
  invocationPayload?: string(name='invocationPayload', description='异步任务的任务触发事件。'),
  qualifier?: string(name='qualifier', description='异步任务所属的服务的别名或版本。'),
  requestId?: string(name='requestId', description='异步任务的请求ID。'),
  serviceName?: string(name='serviceName', description='异步任务所属的服务的名称。'),
  startedTime?: long(name='startedTime', description='异步任务的开始时间。'),
  status?: string(name='status', description='异步任务的执行状态。      Enqueued：异步消息已入队，等待处理。      Succeeded：调用执行成功。      Failed：调用执行失败。      Running：调用执行中。      Stopped：调用执行终止。      Stopping：执行停止中。      Invalid：您的执行因函数被删除等原因处于无效状态（任务未被执行）。      Expired：您为任务配置了最长排队等待的期限。该任务因为超期被丢弃（任务未被执行）。      Retrying：异步调用因执行错误重试中。'),
}

model StatefulAsyncInvocationEvent {
  eventDetail?: string(name='eventDetail', description='事件详细数据。'),
  eventId?: long(name='eventId', description='事件ID。'),
  status?: string(name='status', description='事件执行状态。'),
  timestamp?: long(name='timestamp', description='事件时间。'),
}

model TLSConfig {
  cipherSuites: [ string ](name='cipherSuites', description='TLS加密套件列表'),
  maxVersion?: string(name='maxVersion', description='TLS最大版本号'),
  minVersion: string(name='minVersion', description='TLS最小版本号'),
}

model TargetTrackingPolicies {
  endTime?: string(name='endTime', description='endTime'),
  maxCapacity?: long(name='maxCapacity', description='maxCapacity'),
  metricTarget?: double(name='metricTarget', description='metricTarget'),
  metricType?: string(name='metricType', description='metricType'),
  minCapacity?: long(name='minCapacity', description='minCapacity'),
  name?: string(name='name', description='name'),
  startTime?: string(name='startTime', description='startTime'),
}

model TimeTriggerConfig {
  cronExpression?: string(name='cronExpression', description='cronExpression'),
  enable?: boolean(name='enable', description='enable'),
  payload?: string(name='payload', description='payload'),
}

model TracingConfig {
  params: map[string]string(name='params', description='链路追踪参数。当协议类型为 Jaeger 时，参数为 map[string]string，其中 key 为 "endpoint"，value 为您的链路追踪内网接入点。例如 endpoint: http://tracing-analysis-dc-hz.aliyuncs.com/adapt_xxx/api/otlp/traces'),
  type: string(name='type', description='链路追踪协议类型，目前只支持 Jaeger'),
}

model VPCConfig {
  role?: string(name='role', description='Role'),
  securityGroupId?: string(name='securityGroupId', description='安全组ID'),
  vSwitchIds?: [ string ](name='vSwitchIds', description='VSwitch ID列表'),
  vpcId?: string(name='vpcId', description='VPC ID'),
}

model VendorConfig {
  meteringConfig?: MeteringConfig(name='meteringConfig'),
}

model CreateAliasRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重', position='Body'),
  aliasName: string(name='aliasName', description='别名名称', position='Body'),
  description?: string(name='description', description='别名描述', position='Body'),
  versionId: string(name='versionId', description='版本ID', position='Body'),
}

model CreateAliasResponseBody = {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
  aliasName?: string(name='aliasName', description='别名名称'),
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='别名描述'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  versionId?: string(name='versionId', description='版本ID'),
}

model CreateAliasResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAliasResponseBody(name='body'),
}

async function createAlias(request: CreateAliasRequest): CreateAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateAlias', 'POST', '/2021-04-06/services/{serviceName}/aliases', 'json', false, 'json', request);
}

model CreateCustomDomainRequest {
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  certConfig?: CertConfig(name='certConfig', position='Body'),
  domainName: string(name='domainName', position='Body'),
  protocol?: string(name='protocol', position='Body'),
  routeConfig?: RouteConfig(name='routeConfig', position='Body'),
  tlsConfig?: TLSConfig(name='tlsConfig', position='Body'),
}

model CreateCustomDomainResponseBody = {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime'),
  domainName?: string(name='domainName', description='Id of the request'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
}

model CreateCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCustomDomainResponseBody(name='body'),
}

async function createCustomDomain(request: CreateCustomDomainRequest): CreateCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateCustomDomain', 'POST', '/2021-04-06/custom-domains', 'json', false, 'json', request);
}

model CreateFunctionRequest {
  serviceName?: string(name='serviceName', description='服务名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcCodeChecksum?: string(name='X-Fc-Code-Checksum', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口', position='Body'),
  code?: Code(name='code', position='Body'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig', position='Body'),
  customDNS?: CustomDNS(name='customDNS', description='函数自定义DNS配置', position='Body'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig', description='Custom Runtime函数详细配置', position='Body'),
  description?: string(name='description', description='函数描述', position='Body'),
  environmentVariables?: map[string]string(name='environmentVariables', position='Body'),
  functionName: string(name='functionName', description='函数名称', position='Body'),
  handler: string(name='handler', description='function执行的入口，具体格式和语言相关', position='Body'),
  initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行', position='Body'),
  initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关', position='Body'),
  instanceConcurrency?: int32(name='instanceConcurrency', position='Body'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig', position='Body'),
  instanceSoftConcurrency?: int32(name='instanceSoftConcurrency', position='Body'),
  instanceType?: string(name='instanceType', position='Body'),
  layers?: [ string ](name='layers', description='层列表', position='Body'),
  memorySize?: int32(name='memorySize', description='function的内存规格，单位为MB，为64MB的倍数', position='Body'),
  runtime: string(name='runtime', description='function运行的语言环境，目前支持nodejs6, nodejs8, python2.7, python3, java8', position='Body'),
  timeout?: int32(name='timeout', description='function运行的超时时间，单位为秒，最小1秒，默认3秒。function超过这个时间后会被终止执行', position='Body'),
}

model CreateFunctionResponseBody = {
  caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
  codeChecksum?: string(name='codeChecksum', description='function code包的CRC64值'),
  codeSize?: long(name='codeSize', description='系统返回的function的code包大小，单位为byte Example : 1024'),
  createdTime?: string(name='createdTime', description='function创建时间'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS', description='函数自定义DNS配置'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig', description='Custom Runtime函数详细配置'),
  description?: string(name='description', description='函数描述'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionId?: string(name='functionId', description='系统为每个function生成的唯一ID'),
  functionName?: string(name='functionName', description='函数名称'),
  handler?: string(name='handler', description='function的执行入口'),
  initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
  initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
  instanceType?: string(name='instanceType'),
  lastModifiedTime?: string(name='lastModifiedTime', description='function上次修改时间'),
  layers?: [ string ](name='layers'),
  memorySize?: int32(name='memorySize', description='function设置的内存大小，单位为MB'),
  runtime?: string(name='runtime', description='function运行的语言环境，目前支持nodejs6, nodejs8, python2.7, python3, java8'),
  timeout?: int32(name='timeout', description='运行的超时时间，单位为秒'),
}

model CreateFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFunctionResponseBody(name='body'),
}

async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateFunction', 'POST', '/2021-04-06/services/{serviceName}/functions', 'json', false, 'json', request);
}

model CreateLayerVersionRequest {
  layerName?: string(name='layerName', description='A short description of struct', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  code?: Code(name='Code', position='Body'),
  compatibleRuntime?: [ string ](name='compatibleRuntime', position='Body'),
  description?: string(name='description', position='Body'),
}

model CreateLayerVersionResponseBody = {
  acl?: int32(name='acl'),
  arn?: string(name='arn'),
  code?: OutputCodeLocation(name='code'),
  codeChecksum?: string(name='codeChecksum'),
  codesize?: long(name='codesize'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  createTime?: string(name='createTime'),
  description?: string(name='description'),
  layerName?: string(name='layerName'),
  version?: int32(name='version'),
}

model CreateLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLayerVersionResponseBody(name='body'),
}

async function createLayerVersion(request: CreateLayerVersionRequest): CreateLayerVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateLayerVersion', 'POST', '/2021-04-06/layers/{layerName}/versions', 'json', false, 'json', request);
}

model CreateServiceRequest {
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  description?: string(name='description', description='服务描述', position='Body'),
  internetAccess?: boolean(name='internetAccess', description='公网访问设置', position='Body'),
  logConfig?: LogConfig(name='logConfig', position='Body'),
  nasConfig?: NASConfig(name='nasConfig', position='Body'),
  role?: string(name='role', description='服务角色', position='Body'),
  serviceName: string(name='serviceName', description='服务名称', position='Body'),
  tracingConfig?: TracingConfig(name='tracingConfig', position='Body'),
  vpcConfig?: VPCConfig(name='vpcConfig', position='Body'),
}

model CreateServiceResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='服务描述'),
  internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  role?: string(name='role', description='服务角色'),
  serviceId?: string(name='serviceId', description='服务ID'),
  serviceName?: string(name='serviceName', description='服务名称'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vendorConfig?: VendorConfig(name='vendorConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model CreateServiceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceResponseBody(name='body'),
}

async function createService(request: CreateServiceRequest): CreateServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateService', 'POST', '/2021-04-06/services', 'json', false, 'json', request);
}

model CreateTriggerRequest {
  serviceName: string(name='serviceName', description='service名称', position='Path'),
  functionName: string(name='functionName', description='function名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  description?: string(name='description', position='Body'),
  invocationRole?: string(name='invocationRole', description='event source，如OSS，使用该role去invoke function', position='Body'),
  qualifier?: string(name='qualifier', description='service版本', position='Body'),
  sourceArn?: string(name='sourceArn', description='event source的Aliyun Resource Name（ARN', position='Body'),
  triggerConfig: string(name='triggerConfig', description='trigger配置，针对不同的trigger类型，trigger配置会有所不同', position='Body'),
  triggerName: string(name='triggerName', description='trigger名称', position='Body'),
  triggerType: string(name='triggerType', description='trigger类型，如 oss, log, tablestore, timer, http, cdn_events, mns_topic', position='Body'),
}

model CreateTriggerResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description'),
  domainName?: string(name='domainName', description='域名名称，使用域名名称拼接上函数计算域名，可以采用HTTP协议调用到触发器对应版本的函数。例如{domainName}.cn-shanghai.fc.aliyuncs.com'),
  invocationRole?: string(name='invocationRole', description='调用函数使用的RAM角色的ARN'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次修改时间'),
  qualifier?: string(name='qualifier', description='service版本'),
  sourceArn?: string(name='sourceArn', description='event source的Aliyun Resource Name（ARN'),
  triggerConfig?: string(name='triggerConfig', description='trigger配置对象'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName', description='trigger名称'),
  triggerType?: string(name='triggerType', description='trigger类型，如 oss, log, tablestore, timer, http, cdn_events, mns_topic'),
  urlInternet?: string(name='urlInternet', description='公网域名地址。在互联网可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
  urlIntranet?: string(name='urlIntranet', description='私网域名地址。在VPC可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
}

model CreateTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTriggerResponseBody(name='body'),
}

async function createTrigger(request: CreateTriggerRequest): CreateTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateTrigger', 'POST', '/2021-04-06/services/{serviceName}/functions/{functionName}/triggers', 'json', false, 'json', request);
}

model CreateVpcBindingRequest {
  serviceName?: string(name='serviceName', description='A short description of struct', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  vpcId: string(name='vpcId', position='Body'),
}

model CreateVpcBindingResponse = {
  headers: map[string]string(name='headers'),
}

async function createVpcBinding(request: CreateVpcBindingRequest): CreateVpcBindingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'CreateVpcBinding', 'POST', '/2021-04-06/services/{serviceName}/bindings', 'none', false, 'json', request);
}

model DeleteAliasRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  aliasName: string(name='aliasName', description='别名', position='Path'),
  ifMatch?: string(name='If-Match', position='Header'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
}

model DeleteAliasResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteAlias(request: DeleteAliasRequest): DeleteAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteAlias', 'DELETE', '/2021-04-06/services/{serviceName}/aliases/{aliasName}', 'none', false, 'json', request);
}

model DeleteCustomDomainRequest {
  domainName: string(name='domainName', description='域名名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
}

model DeleteCustomDomainResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteCustomDomain(request: DeleteCustomDomainRequest): DeleteCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteCustomDomain', 'DELETE', '/2021-04-06/custom-domains/{domainName}', 'none', false, 'json', request);
}

model DeleteFunctionRequest {
  serviceName: string(name='serviceName', description='service名称', position='Path'),
  functionName: string(name='functionName', description='function名称', position='Path'),
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应', position='Header'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
}

model DeleteFunctionResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteFunction(request: DeleteFunctionRequest): DeleteFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFunction', 'DELETE', '/2021-04-06/services/{serviceName}/functions/{functionName}', 'none', false, 'json', request);
}

model DeleteFunctionAsyncInvokeConfigRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  functionName: string(name='functionName', description='函数名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  qualifier?: string(name='qualifier', description='限定符', position='Query'),
}

model DeleteFunctionAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteFunctionAsyncInvokeConfig(request: DeleteFunctionAsyncInvokeConfigRequest): DeleteFunctionAsyncInvokeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFunctionAsyncInvokeConfig', 'DELETE', '/2021-04-06/services/{serviceName}/functions/{functionName}/async-invoke-config', 'none', false, 'json', request);
}

model DeleteFunctionOnDemandConfigRequest {
  serviceName: string(name='serviceName', position='Path'),
  functionName: string(name='functionName', position='Path'),
  ifMatch?: string(name='If-Match', position='Header'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  qualifier: string(name='qualifier', description='服务别名或LATEST，不支持版本。', position='Query'),
}

model DeleteFunctionOnDemandConfigResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteFunctionOnDemandConfig(request: DeleteFunctionOnDemandConfigRequest): DeleteFunctionOnDemandConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteFunctionOnDemandConfig', 'DELETE', '/2021-04-06/services/{serviceName}/functions/{functionName}/on-demand-config', 'none', false, 'json', request);
}

model DeleteLayerVersionRequest {
  layerName: string(name='layerName', description='层名称', position='Path'),
  version: string(name='version', description='层版本', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
}

model DeleteLayerVersionResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteLayerVersion(request: DeleteLayerVersionRequest): DeleteLayerVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteLayerVersion', 'DELETE', '/2021-04-06/layers/{layerName}/versions/{version}', 'none', false, 'json', request);
}

model DeleteServiceRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应', position='Header'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
}

model DeleteServiceResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteService(request: DeleteServiceRequest): DeleteServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteService', 'DELETE', '/2021-04-06/services/{serviceName}', 'none', false, 'json', request);
}

model DeleteServiceVersionRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  versionId: string(name='versionId', description='版本ID', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
}

model DeleteServiceVersionResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteServiceVersion(request: DeleteServiceVersionRequest): DeleteServiceVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteServiceVersion', 'DELETE', '/2021-04-06/services/{serviceName}/versions/{versionId}', 'none', false, 'json', request);
}

model DeleteTriggerRequest {
  serviceName: string(name='serviceName', description='service名称', position='Path'),
  functionName: string(name='functionName', description='function名称', position='Path'),
  triggerName: string(name='triggerName', description='删除trigger', position='Path'),
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应', position='Header'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
}

model DeleteTriggerResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteTrigger(request: DeleteTriggerRequest): DeleteTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteTrigger', 'DELETE', '/2021-04-06/services/{serviceName}/functions/{functionName}/triggers/{triggerName}', 'none', false, 'json', request);
}

model DeleteVpcBindingRequest {
  serviceName?: string(name='serviceName', position='Path'),
  vpcId?: string(name='vpcId', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
}

model DeleteVpcBindingResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteVpcBinding(request: DeleteVpcBindingRequest): DeleteVpcBindingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeleteVpcBinding', 'DELETE', '/2021-04-06/services/{serviceName}/bindings/{vpcId}', 'none', false, 'json', request);
}

model DeregisterEventSourceRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  functionName: string(name='functionName', description='函数名称', position='Path'),
  sourceArn?: string(name='sourceArn', description='事件源资源标识符', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  qualifier?: string(name='qualifier', description='别名或版本', position='Query'),
}

model DeregisterEventSourceResponse = {
  headers: map[string]string(name='headers'),
}

async function deregisterEventSource(request: DeregisterEventSourceRequest): DeregisterEventSourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'DeregisterEventSource', 'DELETE', '/2021-04-06/services/{serviceName}/functions/{functionName}/event-sources/{sourceArn}', 'none', false, 'json', request);
}

model GetAccountSettingsRequest {
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
}

model GetAccountSettingsResponseBody = {
  availableAZs?: [ string ](name='availableAZs', description='可用区列表'),
  defaultRole?: string(name='defaultRole', description='默认服务角色'),
}

model GetAccountSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccountSettingsResponseBody(name='body'),
}

async function getAccountSettings(request: GetAccountSettingsRequest): GetAccountSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetAccountSettings', 'GET', '/2021-04-06/account-settings', 'json', false, 'json', request);
}

model GetAliasRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  aliasName: string(name='aliasName', description='别名', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
}

model GetAliasResponseBody = {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
  aliasName?: string(name='aliasName', description='别名名称'),
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='别名描述'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  versionId?: string(name='versionId', description='版本ID'),
}

model GetAliasResponse = {
  headers: map[string]string(name='headers'),
  body: GetAliasResponseBody(name='body'),
}

async function getAlias(request: GetAliasRequest): GetAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetAlias', 'GET', '/2021-04-06/services/{serviceName}/aliases/{aliasName}', 'json', false, 'json', request);
}

model GetCustomDomainRequest {
  domainName?: string(name='domainName', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
}

model GetCustomDomainResponseBody = {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime'),
  domainName?: string(name='domainName', description='Id of the request'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
}

model GetCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  body: GetCustomDomainResponseBody(name='body'),
}

async function getCustomDomain(request: GetCustomDomainRequest): GetCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetCustomDomain', 'GET', '/2021-04-06/custom-domains/{domainName}', 'json', false, 'json', request);
}

model GetFunctionRequest {
  serviceName: string(name='serviceName', description='service名称', position='Path'),
  functionName: string(name='functionName', description='function名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  qualifier?: string(name='qualifier', description='service版本, 可以是versionId或者aliasName', position='Query'),
}

model GetFunctionResponseBody = {
  caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
  codeChecksum?: string(name='codeChecksum', description='function code包的CRC64值'),
  codeSize?: long(name='codeSize', description='系统返回的function的code包大小，单位为byte Example : 1024'),
  createdTime?: string(name='createdTime', description='function创建时间'),
  customContainerConfig?: CustomContainerConfigInfo(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS', description='函数自定义DNS配置'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig', description='Custom Runtime函数详细配置'),
  description?: string(name='description', description='函数描述'),
  environmentVariables?: map[string]string(name='environmentVariables', description='为函数设置的环境变量，可以在函数中获取环境变量的值'),
  functionId?: string(name='functionId', description='系统为每个function生成的唯一ID'),
  functionName?: string(name='functionName', description='函数名称'),
  handler?: string(name='handler', description='function的执行入口'),
  initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
  initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
  instanceType?: string(name='instanceType'),
  lastModifiedTime?: string(name='lastModifiedTime', description='function上次修改时间'),
  layers?: [ string ](name='layers'),
  memorySize?: int32(name='memorySize', description='function设置的内存大小，单位为MB'),
  runtime?: string(name='runtime', description='function运行的语言环境，目前支持nodejs6, nodejs8, python2.7, python3, java8'),
  timeout?: int32(name='timeout', description='运行的超时时间，单位为秒'),
}

model GetFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: GetFunctionResponseBody(name='body'),
}

async function getFunction(request: GetFunctionRequest): GetFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunction', 'GET', '/2021-04-06/services/{serviceName}/functions/{functionName}', 'json', false, 'json', request);
}

model GetFunctionAsyncInvokeConfigRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  functionName: string(name='functionName', description='函数名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  qualifier?: string(name='qualifier', description='限定符', position='Query'),
}

model GetFunctionAsyncInvokeConfigResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  function?: string(name='function', description='函数名称'),
  lastModifiedTime?: string(name='lastModifiedTime', description='最后更改时间'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', description='消息最大存活时长'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', description='异步调用失败后的最大重试次数'),
  qualifier?: string(name='qualifier', description='限定符'),
  service?: string(name='service', description='服务名称'),
  statefulInvocation?: boolean(name='statefulInvocation'),
}

model GetFunctionAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetFunctionAsyncInvokeConfigResponseBody(name='body'),
}

async function getFunctionAsyncInvokeConfig(request: GetFunctionAsyncInvokeConfigRequest): GetFunctionAsyncInvokeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunctionAsyncInvokeConfig', 'GET', '/2021-04-06/services/{serviceName}/functions/{functionName}/async-invoke-config', 'json', false, 'json', request);
}

model GetFunctionCodeRequest {
  serviceName: string(name='serviceName', description='service名称', position='Path'),
  functionName: string(name='functionName', description='function名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  qualifier?: string(name='qualifier', description='service版本, 可以是versionId或者aliasName', position='Query'),
}

model GetFunctionCodeResponseBody = {
  checksum?: string(name='checksum', description='function code包的CRC64值'),
  url?: string(name='url', description='获取function代码的URL'),
}

model GetFunctionCodeResponse = {
  headers: map[string]string(name='headers'),
  body: GetFunctionCodeResponseBody(name='body'),
}

async function getFunctionCode(request: GetFunctionCodeRequest): GetFunctionCodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunctionCode', 'GET', '/2021-04-06/services/{serviceName}/functions/{functionName}/code', 'json', false, 'json', request);
}

model GetFunctionOnDemandConfigRequest {
  serviceName: string(name='serviceName', position='Path'),
  functionName: string(name='functionName', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  qualifier: string(name='qualifier', position='Query'),
}

model GetFunctionOnDemandConfigResponseBody = {
  maximumInstanceCount?: long(name='maximumInstanceCount'),
  resource?: string(name='resource', description='Id of the request'),
}

model GetFunctionOnDemandConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetFunctionOnDemandConfigResponseBody(name='body'),
}

async function getFunctionOnDemandConfig(request: GetFunctionOnDemandConfigRequest): GetFunctionOnDemandConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetFunctionOnDemandConfig', 'GET', '/2021-04-06/services/{serviceName}/functions/{functionName}/on-demand-config', 'json', false, 'json', request);
}

model GetLayerVersionRequest {
  layerName: string(name='layerName', description='层名称', position='Path'),
  version: string(name='version', description='层版本', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
}

model GetLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  body: Layer  
}

async function getLayerVersion(request: GetLayerVersionRequest): GetLayerVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetLayerVersion', 'GET', '/2021-04-06/layers/{layerName}/versions/{version}', 'json', false, 'json', request);
}

model GetProvisionConfigRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  functionName: string(name='functionName', description='函数名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  qualifier: string(name='qualifier', description='别名名称', position='Query'),
}

model GetProvisionConfigResponseBody = {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', description='是否始终分配CPU给函数实例。'),
  current?: long(name='current', description='实际资源个数'),
  currentError?: string(name='currentError', description='预留实例创建失败时的错误信息'),
  resource?: string(name='resource', description='资源描述'),
  scheduledActions?: [
    ScheduledActions
  ](name='scheduledActions', description='定时策略配置'),
  target?: long(name='target', description='目标资源个数'),
  targetTrackingPolicies?: [
    TargetTrackingPolicies
  ](name='targetTrackingPolicies', description='指标追踪伸缩策略配置'),
}

model GetProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetProvisionConfigResponseBody(name='body'),
}

async function getProvisionConfig(request: GetProvisionConfigRequest): GetProvisionConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetProvisionConfig', 'GET', '/2021-04-06/services/{serviceName}/functions/{functionName}/provision-config', 'json', false, 'json', request);
}

model GetResourceTagsRequest {
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  resourceArn: string(name='resourceArn', description='Resource ARN 全称或者简称', position='Query'),
}

model GetResourceTagsResponseBody = {
  resourceArn?: string(name='resourceArn', description='Resource ARN 全称'),
  tags?: map[string]string(name='tags', description='tag 列表'),
}

model GetResourceTagsResponse = {
  headers: map[string]string(name='headers'),
  body: GetResourceTagsResponseBody(name='body'),
}

async function getResourceTags(request: GetResourceTagsRequest): GetResourceTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetResourceTags', 'GET', '/2021-04-06/tag', 'json', false, 'json', request);
}

model GetServiceRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  qualifier?: string(name='qualifier', description='限定符', position='Query'),
}

model GetServiceResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='服务描述'),
  internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  role?: string(name='role', description='服务角色'),
  serviceId?: string(name='serviceId', description='服务ID'),
  serviceName?: string(name='serviceName', description='服务名称'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model GetServiceResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceResponseBody(name='body'),
}

async function getService(request: GetServiceRequest): GetServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetService', 'GET', '/2021-04-06/services/{serviceName}', 'json', false, 'json', request);
}

model GetStatefulAsyncInvocationRequest {
  serviceName: string(name='serviceName', position='Path'),
  functionName: string(name='functionName', position='Path'),
  invocationId: string(name='invocationId', position='Path'),
  accountID?: string(name='AccountID', position='Host'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcCodeChecksum?: string(name='X-Fc-Code-Checksum', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcInvocationType?: string(name='X-Fc-Invocation-Type', position='Header'),
  xFcLogType?: string(name='X-Fc-Log-Type', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  qualifier?: string(name='qualifier', position='Query'),
}

model GetStatefulAsyncInvocationResponse = {
  headers: map[string]string(name='headers'),
  body: StatefulAsyncInvocation  
}

async function getStatefulAsyncInvocation(request: GetStatefulAsyncInvocationRequest): GetStatefulAsyncInvocationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetStatefulAsyncInvocation', 'GET', '/2021-04-06/services/{serviceName}/functions/{functionName}/stateful-async-invocations/{invocationId}', 'json', false, 'json', request);
}

model GetTriggerRequest {
  serviceName: string(name='serviceName', description='service名称', position='Path'),
  functionName: string(name='functionName', description='function名称', position='Path'),
  triggerName: string(name='triggerName', description='trigger名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
}

model GetTriggerResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description'),
  domainName?: string(name='domainName', description='域名名称，使用域名名称拼接上函数计算域名，可以采用HTTP协议调用到触发器对应版本的函数。例如{domainName}.cn-shanghai.fc.aliyuncs.com'),
  invocationRole?: string(name='invocationRole', description='调用函数使用的RAM角色的ARN'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次修改时间'),
  qualifier?: string(name='qualifier', description='service版本'),
  sourceArn?: string(name='sourceArn', description='event source的Aliyun Resource Name（ARN'),
  triggerConfig?: string(name='triggerConfig', description='trigger配置对象'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName', description='trigger名称'),
  triggerType?: string(name='triggerType', description='trigger类型，如 oss, log, tablestore, timer, http, cdn_events, mns_topic'),
  urlInternet?: string(name='urlInternet', description='公网域名地址。在互联网可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
  urlIntranet?: string(name='urlIntranet', description='私网域名地址。在VPC可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
}

model GetTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: GetTriggerResponseBody(name='body'),
}

async function getTrigger(request: GetTriggerRequest): GetTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'GetTrigger', 'GET', '/2021-04-06/services/{serviceName}/functions/{functionName}/triggers/{triggerName}', 'json', false, 'json', request);
}

model InvokeFunctionRequest {
  serviceName: string(name='serviceName', description='service名称', position='Path'),
  functionName: string(name='functionName', description='function名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcInvocationType?: string(name='X-Fc-Invocation-Type', description='调用方式:Sync或者Async，默认值：Sync', position='Header'),
  xFcLogType?: string(name='X-Fc-Log-Type', description='请求返回日志类型, Tail 为返回函数日志最后 4KB 数据，None 或空值则返回不带有日志，默认为 None', position='Header'),
  xFcStatefulAsyncInvocationId?: string(name='X-Fc-Stateful-Async-Invocation-Id', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  body?: bytes(name='body', description='事件（event），binary type。函数计算服务将event传递给用户function来处理', position='Body'),
  qualifier?: string(name='qualifier', description='service版本, 可以是versionId或者aliasName', position='Query'),
}

model InvokeFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: bytes(name='body'),
}

async function invokeFunction(request: InvokeFunctionRequest): InvokeFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'InvokeFunction', 'POST', '/2021-04-06/services/{serviceName}/functions/{functionName}/invocations', 'byte', false, 'json', request);
}

model ListAliasesRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  limit?: int32(name='limit', description='最多返回个数', position='Query'),
  nextToken?: string(name='nextToken', description='下次查询token', position='Query'),
  prefix?: string(name='prefix', description='前缀', position='Query'),
  startKey?: string(name='startKey', description='起始key', position='Query'),
}

model ListAliasesResponseBody = {
  aliases?: [ 
    {
      additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
      aliasName?: string(name='aliasName', description='别名名称'),
      createdTime?: string(name='createdTime', description='创建时间'),
      description?: string(name='description', description='别名描述'),
      lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
      versionId?: string(name='versionId', description='版本ID'),
    }
  ](name='aliases', description='别名列表'),
  nextToken?: string(name='nextToken', description='下次查询token'),
}

model ListAliasesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAliasesResponseBody(name='body'),
}

async function listAliases(request: ListAliasesRequest): ListAliasesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListAliases', 'GET', '/2021-04-06/services/{serviceName}/aliases', 'json', false, 'json', request);
}

model ListCustomDomainsRequest {
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  limit?: int32(name='limit', position='Query'),
  nextToken?: string(name='nextToken', position='Query'),
  prefix?: string(name='prefix', position='Query'),
  startKey?: string(name='startKey', position='Query'),
}

model ListCustomDomainsResponseBody = {
  customDomains?: [ 
    {
      accountId?: string(name='accountId'),
      apiVersion?: string(name='apiVersion'),
      certConfig?: CertConfig(name='certConfig'),
      createdTime?: string(name='createdTime'),
      domainName?: string(name='domainName'),
      lastModifiedTime?: string(name='lastModifiedTime'),
      protocol?: string(name='protocol'),
      routeConfig?: RouteConfig(name='routeConfig'),
      tlsConfig?: TLSConfig(name='tlsConfig'),
    }
  ](name='customDomains'),
  nextToken?: string(name='nextToken'),
}

model ListCustomDomainsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCustomDomainsResponseBody(name='body'),
}

async function listCustomDomains(request: ListCustomDomainsRequest): ListCustomDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListCustomDomains', 'GET', '/2021-04-06/custom-domains', 'json', false, 'json', request);
}

model ListEventSourcesRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  functionName: string(name='functionName', description='函数名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  qualifier?: string(name='qualifier', description='别名或版本', position='Query'),
}

model ListEventSourcesResponseBody = {
  eventSources?: [ 
    {
      createdTime?: string(name='createdTime', description='创建时间'),
      sourceArn?: string(name='sourceArn', description='事件源资源标识符'),
    }
  ](name='eventSources', description='事件源列表'),
}

model ListEventSourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListEventSourcesResponseBody(name='body'),
}

async function listEventSources(request: ListEventSourcesRequest): ListEventSourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListEventSources', 'GET', '/2021-04-06/services/{serviceName}/functions/{functionName}/event-sources', 'json', false, 'json', request);
}

model ListFunctionAsyncInvokeConfigsRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  functionName: string(name='functionName', description='函数名称', position='Path'),
  accountID?: string(name='AccountID', position='Host'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcCodeChecksum?: string(name='X-Fc-Code-Checksum', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcInvocationType?: string(name='X-Fc-Invocation-Type', position='Header'),
  xFcLogType?: string(name='X-Fc-Log-Type', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  limit?: int32(name='limit', description='最多返回个数', position='Query'),
  nextToken?: string(name='nextToken', description='下次查询token', position='Query'),
}

model ListFunctionAsyncInvokeConfigsResponseBody = {
  configs?: [ 
    {
      createdTime?: string(name='createdTime', description='创建时间'),
      destinationConfig?: DestinationConfig(name='destinationConfig'),
      function?: string(name='function', description='函数名称'),
      lastModifiedTime?: string(name='lastModifiedTime', description='最后更改时间'),
      maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', description='消息最大存活时长'),
      maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', description='异步调用失败后的最大重试次数'),
      qualifier?: string(name='qualifier', description='限定符'),
      service?: string(name='service', description='服务名称'),
      statefulInvocation?: boolean(name='statefulInvocation'),
    }
  ](name='configs', description='异步配置列表'),
  nextToken?: string(name='nextToken', description='下次查询token'),
}

model ListFunctionAsyncInvokeConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFunctionAsyncInvokeConfigsResponseBody(name='body'),
}

async function listFunctionAsyncInvokeConfigs(request: ListFunctionAsyncInvokeConfigsRequest): ListFunctionAsyncInvokeConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFunctionAsyncInvokeConfigs', 'GET', '/2021-04-06/services/{serviceName}/functions/{functionName}/async-invoke-configs', 'json', false, 'json', request);
}

model ListFunctionsRequest {
  serviceName?: string(name='serviceName', description='service名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  limit?: int32(name='limit', description='限定此次返回资源的数量。如果不设定，默认返回20，最大不能超过100。返回结果可能小于指定的数量，但不会多于指定的数量', position='Query'),
  nextToken?: string(name='nextToken', description='用来返回更多结果。第一次查询不需要提供这个参数，后续查询的token从返回结果中获取', position='Query'),
  prefix?: string(name='prefix', description='限定返回的资源名称必须以prefix作为前缀', position='Query'),
  qualifier?: string(name='qualifier', description='service版本, 可以是versionId或者aliasName', position='Query'),
  startKey?: string(name='startKey', description='设定结果从startKey之后（包括startKey）按字母排序的第一个开始返回', position='Query'),
}

model ListFunctionsResponseBody = {
  functions?: [ 
    {
      caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
      codeChecksum?: string(name='codeChecksum', description='function code包的CRC64值'),
      codeSize?: long(name='codeSize', description='系统返回的function的code包大小，单位为byte Example : 1024'),
      createdTime?: string(name='createdTime', description='function创建时间'),
      customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
      description?: string(name='description', description='函数描述'),
      environmentVariables?: map[string]string(name='environmentVariables', description='为函数设置的环境变量，可以在函数中获取环境变量的值'),
      functionId?: string(name='functionId', description='系统为每个function生成的唯一ID'),
      functionName?: string(name='functionName', description='函数名称'),
      handler?: string(name='handler', description='function的执行入口'),
      initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
      initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
      instanceConcurrency?: int32(name='instanceConcurrency'),
      instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
      instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
      instanceType?: string(name='instanceType'),
      lastModifiedTime?: string(name='lastModifiedTime', description='function上次修改时间'),
      layers?: [ string ](name='layers'),
      memorySize?: int32(name='memorySize', description='function设置的内存大小，单位为MB'),
      runtime?: string(name='runtime', description='function运行的语言环境，目前支持nodejs6, nodejs8, python2.7, python3, java8'),
      timeout?: int32(name='timeout', description='运行的超时时间，单位为秒'),
    }
  ](name='functions', description='函数列表'),
  nextToken?: string(name='nextToken', description='用来返回更多的查询结果。如果这个值没有返回，则说明没有更多结果'),
}

model ListFunctionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFunctionsResponseBody(name='body'),
}

async function listFunctions(request: ListFunctionsRequest): ListFunctionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListFunctions', 'GET', '/2021-04-06/services/{serviceName}/functions', 'json', false, 'json', request);
}

model ListInstancesRequest {
  serviceName: string(name='serviceName', description='服务的名称', position='Path'),
  functionName: string(name='functionName', description='函数的名称', position='Path'),
  xFcAccountId: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  instanceIds?: [ string ](name='instanceIds', description='实例ID', position='Query'),
  limit?: int32(name='limit', description='限定此次返回资源的数量，取值范围[0,1000]。

返回结果可以小于指定的数量，但不能多于指定的数量。', position='Query'),
  qualifier?: string(name='qualifier', description='服务的版本或别名。默认是LATEST。

此处的qualifier同InvokeFunction的qualifier含义一致，即调用ListInstances时指定qualifier=test查询出来的实例，就是调用InvokeFunction时qualifier=test链路上的实例。', position='Query'),
}

model ListInstancesResponseBody = {
  instances?: [ 
    {
      instanceId?: string(name='instanceId', description='实例ID。

'),
      versionId?: string(name='versionId', description='实例所属的服务版本。如果是LATEST别名下的函数实例，则返回版本号为0。

'),
    }
  ](name='instances'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListInstances', 'GET', '/2021-04-06/services/{serviceName}/functions/{functionName}/instances', 'json', false, 'json', request);
}

model ListLayerVersionsRequest {
  layerName: string(name='layerName', description='层名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  limit?: int32(name='limit', description='本次读取的最大数据记录数量', position='Query'),
  startVersion?: int32(name='startVersion', description='起始版本', position='Query'),
}

model ListLayerVersionsResponseBody = {
  layers?: [
    Layer
  ](name='layers', description='层版本列表'),
  nextVersion?: int32(name='nextVersion', description='剩余列表起始版本号'),
}

model ListLayerVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListLayerVersionsResponseBody(name='body'),
}

async function listLayerVersions(request: ListLayerVersionsRequest): ListLayerVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLayerVersions', 'GET', '/2021-04-06/layers/{layerName}/versions', 'json', false, 'json', request);
}

model ListLayersRequest {
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  limit?: int32(name='limit', description='最大返回条目数', position='Query'),
  nextToken?: string(name='nextToken', description='下一个层名称', position='Query'),
  prefix?: string(name='prefix', description='层名称前缀', position='Query'),
  startKey?: string(name='startKey', description='起始层名称', position='Query'),
}

model ListLayersResponseBody = {
  layers?: [
    Layer
  ](name='layers', description='层列表'),
  nextToken?: string(name='nextToken', description='剩余列表起始层名'),
}

model ListLayersResponse = {
  headers: map[string]string(name='headers'),
  body: ListLayersResponseBody(name='body'),
}

async function listLayers(request: ListLayersRequest): ListLayersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListLayers', 'GET', '/2021-04-06/layers', 'json', false, 'json', request);
}

model ListOnDemandConfigsRequest {
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  limit?: int32(name='limit', description='限定此次返回资源的数量。如果不设定，默认返回20，最大不能超过100。返回结果可以小于指定的数量，但不会多于指定的数量。', position='Query'),
  nextToken?: string(name='nextToken', description='用来返回更多结果。第一次查询不需要提供这个参数，后续查询的Token从返回结果中获取。', position='Query'),
  prefix?: string(name='prefix', description='限定返回的资源名称，名称必须以Prefix作为前缀，例如Prefix是a，则返回的资源名均是以a开始的。', position='Query'),
  startKey?: string(name='startKey', description='设定结果从startKey之后（包括startKey）按字母排序的第一个开始返回。', position='Query'),
}

model ListOnDemandConfigsResponseBody = {
  configs?: [
    OnDemandConfig
  ](name='configs', description='预留实例配置'),
  nextToken?: string(name='nextToken', description='用来返回更多的查询结果。如果这个值没有返回，则说明没有更多结果。'),
}

model ListOnDemandConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListOnDemandConfigsResponseBody(name='body'),
}

async function listOnDemandConfigs(request: ListOnDemandConfigsRequest): ListOnDemandConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListOnDemandConfigs', 'GET', '/2021-04-06/on-demand-configs', 'json', false, 'json', request);
}

model ListProvisionConfigsRequest {
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  limit?: long(name='limit', description='限定此次返回资源的数量。如果不设定，默认返回20，最大不能超过100。返回结果可能小于指定的数量，但不会多于指定的数量	', position='Query'),
  nextToken?: string(name='nextToken', description='用来返回更多结果。第一次查询不需要提供这个参数，后续查询的token从返回结果中获取', position='Query'),
  qualifier?: string(name='qualifier', description='限定返回的资源名称必须属于该qualifier。qualifier只能是aliasName，且必须和serviceName共同使用', position='Query'),
  serviceName?: string(name='serviceName', description='限定返回的资源名称必须属于该service', position='Query'),
}

model ListProvisionConfigsResponseBody = {
  nextToken?: string(name='nextToken', description='下次查询的起始token	'),
  provisionConfigs?: [ 
    {
      alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', description='是否始终分配CPU给函数实例。'),
      current?: long(name='current', description='实际资源个数'),
      currentError?: string(name='currentError', description='预留实例创建失败时的错误信息'),
      resource?: string(name='resource', description='资源描述'),
      scheduledActions?: [
        ScheduledActions
      ](name='scheduledActions', description='定时策略配置'),
      target?: long(name='target', description='目标资源个数'),
      targetTrackingPolicies?: [
        TargetTrackingPolicies
      ](name='targetTrackingPolicies', description='指标追踪伸缩策略配置'),
    }
  ](name='provisionConfigs', description='预留实例列表'),
}

model ListProvisionConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProvisionConfigsResponseBody(name='body'),
}

async function listProvisionConfigs(request: ListProvisionConfigsRequest): ListProvisionConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListProvisionConfigs', 'GET', '/2021-04-06/provision-configs', 'json', false, 'json', request);
}

model ListReservedCapacitiesRequest {
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  limit?: string(name='limit', description='一次返回的数量，取值范围[1, 100]', position='Query'),
  nextToken?: string(name='nextToken', position='Query'),
}

model ListReservedCapacitiesResponseBody = {
  nextToken?: string(name='nextToken', description='nextToken'),
  reservedCapacities?: [
    OpenReservedCapacity
  ](name='reservedCapacities', description='reservedCapacities'),
}

model ListReservedCapacitiesResponse = {
  headers: map[string]string(name='headers'),
  body: ListReservedCapacitiesResponseBody(name='body'),
}

async function listReservedCapacities(request: ListReservedCapacitiesRequest): ListReservedCapacitiesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListReservedCapacities', 'GET', '/2021-04-06/reserved-capacities', 'json', false, 'json', request);
}

model ListServiceVersionsRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  direction?: string(name='direction', description='排序方向', position='Query'),
  limit?: int32(name='limit', description='最多返回个数', position='Query'),
  nextToken?: string(name='nextToken', description='下次查询token', position='Query'),
  startKey?: string(name='startKey', description='起始key', position='Query'),
}

model ListServiceVersionsResponseBody = {
  direction?: string(name='direction', description='排序方向'),
  nextToken?: string(name='nextToken', description='下次查询token'),
  versions?: [ 
    {
      createdTime?: string(name='createdTime', description='创建时间'),
      description?: string(name='description', description='版本描述'),
      lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
      versionId?: string(name='versionId', description='版本ID'),
    }
  ](name='versions', description='版本列表'),
}

model ListServiceVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListServiceVersionsResponseBody(name='body'),
}

async function listServiceVersions(request: ListServiceVersionsRequest): ListServiceVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListServiceVersions', 'GET', '/2021-04-06/services/{serviceName}/versions', 'json', false, 'json', request);
}

model ListServicesRequest {
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  limit?: int32(name='limit', description='最多返回个数', position='Query'),
  nextToken?: string(name='nextToken', description='下次查询token', position='Query'),
  prefix?: string(name='prefix', description='前缀', position='Query'),
  startKey?: string(name='startKey', description='起始key', position='Query'),
}

model ListServicesResponseBody = {
  nextToken?: string(name='nextToken', description='下次查询token'),
  services?: [ 
    {
      createdTime?: string(name='createdTime', description='创建时间'),
      description?: string(name='description', description='服务描述'),
      internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
      lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
      logConfig?: LogConfig(name='logConfig'),
      nasConfig?: NASConfig(name='nasConfig'),
      role?: string(name='role', description='服务角色'),
      serviceId?: string(name='serviceId', description='服务ID'),
      serviceName?: string(name='serviceName', description='服务信息'),
      tracingConfig?: TracingConfig(name='tracingConfig'),
      vpcConfig?: VPCConfig(name='vpcConfig'),
    }
  ](name='services', description='服务列表'),
}

model ListServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListServicesResponseBody(name='body'),
}

async function listServices(request: ListServicesRequest): ListServicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListServices', 'GET', '/2021-04-06/services', 'json', false, 'json', request);
}

model ListStatefulAsyncInvocationFunctionsRequest {
  xFcAccountId?: string(name='X-Fc-Account-Id', description='您的阿里云账号（主账号）ID。', position='Header'),
  xFcDate?: string(name='X-Fc-Date', description='发起API调用的日期，用于对请求签名。格式为yyyy-mm-ddhh:mm:ss。', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', description='用于链路追踪的ID。', position='Header'),
  limit?: int32(name='limit', description='限定此次返回资源的数量。如果不设定，默认返回20，最大不能超过100。返回结果可以小于指定的数量，但不会多于指定的数量。', minimum=0, maximum=100, position='Query'),
  nextToken?: string(name='nextToken', description='用来标记当前开始读取的位置，置空表示从头开始。第一次查询不需要提供这个参数，后续查询的Token从前一次查询的返回结果中获取。', position='Query'),
}

model ListStatefulAsyncInvocationFunctionsResponseBody = {
  data?: [
    AsyncConfigMeta
  ](name='data', description='返回的实际数据列表。'),
  nextToken?: string(name='nextToken', description='用来表示当前调用返回读取到的位置，空代表数据已经读取完毕。'),
}

model ListStatefulAsyncInvocationFunctionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListStatefulAsyncInvocationFunctionsResponseBody(name='body'),
}

async function listStatefulAsyncInvocationFunctions(request: ListStatefulAsyncInvocationFunctionsRequest): ListStatefulAsyncInvocationFunctionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListStatefulAsyncInvocationFunctions', 'GET', '/2021-04-06/stateful-async-invocation-functions', 'json', false, 'json', request);
}

model ListStatefulAsyncInvocationsRequest {
  serviceName: string(name='serviceName', position='Path'),
  functionName: string(name='functionName', position='Path'),
  accountID?: string(name='AccountID', position='Host'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcCodeChecksum?: string(name='X-Fc-Code-Checksum', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcInvocationType?: string(name='X-Fc-Invocation-Type', position='Header'),
  xFcLogType?: string(name='X-Fc-Log-Type', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  includePayload?: boolean(name='includePayload', position='Query'),
  invocationIdPrefix?: string(name='invocationIdPrefix', position='Query'),
  limit?: int32(name='limit', position='Query'),
  nextToken?: string(name='nextToken', position='Query'),
  qualifier?: string(name='qualifier', position='Query'),
  sortOrderByTime?: string(name='sortOrderByTime', position='Query'),
  startedTimeBegin?: long(name='startedTimeBegin', position='Query'),
  startedTimeEnd?: long(name='startedTimeEnd', position='Query'),
  status?: string(name='status', position='Query'),
}

model ListStatefulAsyncInvocationsResponseBody = {
  invocations?: [
    StatefulAsyncInvocation
  ](name='invocations'),
  nextToken?: string(name='nextToken'),
}

model ListStatefulAsyncInvocationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListStatefulAsyncInvocationsResponseBody(name='body'),
}

async function listStatefulAsyncInvocations(request: ListStatefulAsyncInvocationsRequest): ListStatefulAsyncInvocationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListStatefulAsyncInvocations', 'GET', '/2021-04-06/services/{serviceName}/functions/{functionName}/stateful-async-invocations', 'json', false, 'json', request);
}

model ListTaggedResourcesRequest {
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  limit?: int32(name='limit', position='Query'),
  nextToken?: string(name='nextToken', position='Query'),
}

model ListTaggedResourcesResponseBody = {
  nextToken?: string(name='nextToken'),
  resources?: [
    Resource
  ](name='resources'),
}

model ListTaggedResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTaggedResourcesResponseBody(name='body'),
}

async function listTaggedResources(request: ListTaggedResourcesRequest): ListTaggedResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTaggedResources', 'GET', '/2021-04-06/tags', 'json', false, 'json', request);
}

model ListTriggersRequest {
  serviceName: string(name='serviceName', description='service名称', position='Path'),
  functionName: string(name='functionName', description='function名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  limit?: int32(name='limit', description='限定此次返回资源的数量。如果不设定，默认返回20，最大不能超过100。返回结果可能小于指定的数量，但不会多于指定的数量', position='Query'),
  nextToken?: string(name='nextToken', description='用来返回更多结果。第一次查询不需要提供这个参数，后续查询的token从返回结果中获取', position='Query'),
  prefix?: string(name='prefix', description='限定返回的资源名称必须以prefix作为前缀', position='Query'),
  startKey?: string(name='startKey', description='设定结果从startKey之后（包括startKey）按字母排序的第一个开始返回', position='Query'),
}

model ListTriggersResponseBody = {
  nextToken?: string(name='nextToken', description='用来返回更多的查询结果。如果这个值没有返回，则说明没有更多结果'),
  triggers?: [ 
    {
      createdTime?: string(name='createdTime', description='创建时间'),
      description?: string(name='description'),
      domainName?: string(name='domainName', description='域名名称，使用域名名称拼接上函数计算域名，可以采用HTTP协议调用到触发器对应版本的函数。例如{domainName}.cn-shanghai.fc.aliyuncs.com'),
      invocationRole?: string(name='invocationRole', description='调用函数使用的RAM角色的ARN'),
      lastModifiedTime?: string(name='lastModifiedTime', description='上次修改时间'),
      qualifier?: string(name='qualifier', description='service版本'),
      sourceArn?: string(name='sourceArn', description='event source的Aliyun Resource Name（ARN'),
      triggerConfig?: string(name='triggerConfig', description='trigger配置对象'),
      triggerId?: string(name='triggerId'),
      triggerName?: string(name='triggerName', description='trigger名称'),
      triggerType?: string(name='triggerType', description='trigger类型，如 oss, log, tablestore, timer, http, cdn_events, mns_topic'),
      urlInternet?: string(name='urlInternet', description='公网域名地址。在互联网可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
      urlIntranet?: string(name='urlIntranet', description='私网域名地址。在VPC可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
    }
  ](name='triggers', description='Trigger列表'),
}

model ListTriggersResponse = {
  headers: map[string]string(name='headers'),
  body: ListTriggersResponseBody(name='body'),
}

async function listTriggers(request: ListTriggersRequest): ListTriggersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListTriggers', 'GET', '/2021-04-06/services/{serviceName}/functions/{functionName}/triggers', 'json', false, 'json', request);
}

model ListVpcBindingsRequest {
  serviceName?: string(name='serviceName', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
}

model ListVpcBindingsResponseBody = {
  vpcIds?: [ string ](name='vpcIds'),
}

model ListVpcBindingsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcBindingsResponseBody(name='body'),
}

async function listVpcBindings(request: ListVpcBindingsRequest): ListVpcBindingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'ListVpcBindings', 'GET', '/2021-04-06/services/{serviceName}/bindings', 'json', false, 'json', request);
}

model PublishServiceVersionRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  ifMatch?: string(name='If-Match', description='服务的ETag，可通过GetService接口获得。若发布版本时服务的ETag与传入的不一致，则发布版本会失败。', position='Header'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  description?: string(name='description', description='版本描述', position='Body'),
}

model PublishServiceVersionResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='版本描述'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  versionId?: string(name='versionId', description='版本ID'),
}

model PublishServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  body: PublishServiceVersionResponseBody(name='body'),
}

async function publishServiceVersion(request: PublishServiceVersionRequest): PublishServiceVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PublishServiceVersion', 'POST', '/2021-04-06/services/{serviceName}/versions', 'json', false, 'json', request);
}

model PutFunctionAsyncInvokeConfigRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  functionName: string(name='functionName', description='函数名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  destinationConfig?: DestinationConfig(name='destinationConfig', position='Body'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', description='消息最大存活时长', position='Body'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', description='异步调用失败后的最大重试次数', position='Body'),
  statefulInvocation?: boolean(name='statefulInvocation', position='Body'),
  qualifier?: string(name='qualifier', description='别名或版本', position='Query'),
}

model PutFunctionAsyncInvokeConfigResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  function?: string(name='function', description='函数名称'),
  lastModifiedTime?: string(name='lastModifiedTime', description='最后更改时间'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', description='消息最大存活时长'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', description='异步调用失败后的最大重试次数'),
  qualifier?: string(name='qualifier', description='限定符'),
  service?: string(name='service', description='服务名称'),
  statefulInvocation?: boolean(name='statefulInvocation'),
}

model PutFunctionAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  body: PutFunctionAsyncInvokeConfigResponseBody(name='body'),
}

async function putFunctionAsyncInvokeConfig(request: PutFunctionAsyncInvokeConfigRequest): PutFunctionAsyncInvokeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutFunctionAsyncInvokeConfig', 'PUT', '/2021-04-06/services/{serviceName}/functions/{functionName}/async-invoke-config', 'json', false, 'json', request);
}

model PutFunctionOnDemandConfigRequest {
  serviceName: string(name='serviceName', position='Path'),
  functionName: string(name='functionName', position='Path'),
  ifMatch?: string(name='If-Match', position='Header'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  maximumInstanceCount: long(name='maximumInstanceCount', position='Body'),
  qualifier: string(name='qualifier', position='Query'),
}

model PutFunctionOnDemandConfigResponseBody = {
  maximumInstanceCount?: long(name='maximumInstanceCount'),
  resource?: string(name='resource'),
}

model PutFunctionOnDemandConfigResponse = {
  headers: map[string]string(name='headers'),
  body: PutFunctionOnDemandConfigResponseBody(name='body'),
}

async function putFunctionOnDemandConfig(request: PutFunctionOnDemandConfigRequest): PutFunctionOnDemandConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutFunctionOnDemandConfig', 'PUT', '/2021-04-06/services/{serviceName}/functions/{functionName}/on-demand-config', 'json', false, 'json', request);
}

model PutProvisionConfigRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  functionName: string(name='functionName', description='函数名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', description='当实例进入空闲状态时，是否继续分配CPU。', position='Body'),
  scheduledActions?: [
    ScheduledActions
  ](name='scheduledActions', description='定时策略配置', position='Body'),
  target: long(name='target', description='预留的目标资源个数', position='Body'),
  targetTrackingPolicies?: [
    TargetTrackingPolicies
  ](name='targetTrackingPolicies', description='指标追踪伸缩策略配置', position='Body'),
  qualifier: string(name='qualifier', description='别名名称', position='Query'),
}

model PutProvisionConfigResponseBody = {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', description='是否始终分配CPU给函数实例。'),
  current?: long(name='current', description='实际资源个数'),
  resource?: string(name='resource', description='资源描述'),
  scheduledActions?: [
    ScheduledActions
  ](name='scheduledActions', description='定时策略配置'),
  target?: long(name='target', description='目标资源个数'),
  targetTrackingPolicies?: [
    TargetTrackingPolicies
  ](name='targetTrackingPolicies', description='指标追踪伸缩策略配置'),
}

model PutProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: PutProvisionConfigResponseBody(name='body'),
}

async function putProvisionConfig(request: PutProvisionConfigRequest): PutProvisionConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'PutProvisionConfig', 'PUT', '/2021-04-06/services/{serviceName}/functions/{functionName}/provision-config', 'json', false, 'json', request);
}

model RegisterEventSourceRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  functionName: string(name='functionName', description='函数名称', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  sourceArn: string(name='sourceArn', description='事件源资源标识符', position='Body'),
  qualifier?: string(name='qualifier', description='别名或版本', position='Query'),
}

model RegisterEventSourceResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  sourceArn?: string(name='sourceArn', description='事件源资源标识符'),
}

model RegisterEventSourceResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterEventSourceResponseBody(name='body'),
}

async function registerEventSource(request: RegisterEventSourceRequest): RegisterEventSourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'RegisterEventSource', 'POST', '/2021-04-06/services/{serviceName}/functions/{functionName}/event-sources', 'json', false, 'json', request);
}

model StopStatefulAsyncInvocationRequest {
  serviceName?: string(name='serviceName', position='Path'),
  functionName?: string(name='functionName', position='Path'),
  invocationId?: string(name='invocationId', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  qualifier?: string(name='qualifier', position='Query'),
}

model StopStatefulAsyncInvocationResponse = {
  headers: map[string]string(name='headers'),
}

async function stopStatefulAsyncInvocation(request: StopStatefulAsyncInvocationRequest): StopStatefulAsyncInvocationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'StopStatefulAsyncInvocation', 'PUT', '/2021-04-06/services/{serviceName}/functions/{functionName}/stateful-async-invocations/{invocationId}', 'none', false, 'json', request);
}

model TagResourceRequest {
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  resourceArn: string(name='resourceArn', position='Body'),
  tags: map[string]string(name='tags', position='Body'),
}

model TagResourceResponse = {
  headers: map[string]string(name='headers'),
}

async function tagResource(request: TagResourceRequest): TagResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'TagResource', 'POST', '/2021-04-06/tag', 'none', false, 'json', request);
}

model UntagResourceRequest {
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  all?: boolean(name='all', description='删除所有 tag，默认值为 false', position='Body'),
  resourceArn: string(name='resourceArn', description='目前只能给 top level 资源 service 进行标签的相关操作, ARN 可以是类似 services/foo 或者 acs:fc:cn-shanghai:123456789:services/foo', position='Body'),
  tagKeys?: [ string ](name='tagKeys', description='tag key 值列表， 最大为 20，当 all=false， length 至少为 1. 当 length 大于 1 时， 可以忽略 all 值', position='Body'),
}

model UntagResourceResponse = {
  headers: map[string]string(name='headers'),
}

async function untagResource(request: UntagResourceRequest): UntagResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UntagResource', 'PUT', '/2021-04-06/tag', 'none', false, 'json', request);
}

model UpdateAliasRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  aliasName: string(name='aliasName', description='别名', position='Path'),
  ifMatch?: string(name='If-Match', position='Header'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重', position='Body'),
  description?: string(name='description', description='别名描述', position='Body'),
  versionId?: string(name='versionId', description='版本ID', position='Body'),
}

model UpdateAliasResponseBody = {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
  aliasName?: string(name='aliasName', description='别名名称'),
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='别名描述'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  versionId?: string(name='versionId', description='版本ID'),
}

model UpdateAliasResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAliasResponseBody(name='body'),
}

async function updateAlias(request: UpdateAliasRequest): UpdateAliasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateAlias', 'PUT', '/2021-04-06/services/{serviceName}/aliases/{aliasName}', 'json', false, 'json', request);
}

model UpdateCustomDomainRequest {
  domainName?: string(name='domainName', position='Path'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  certConfig?: CertConfig(name='certConfig', position='Body'),
  protocol?: string(name='protocol', position='Body'),
  routeConfig?: RouteConfig(name='routeConfig', position='Body'),
  tlsConfig?: TLSConfig(name='tlsConfig', position='Body'),
}

model UpdateCustomDomainResponseBody = {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime'),
  domainName?: string(name='domainName'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
}

model UpdateCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCustomDomainResponseBody(name='body'),
}

async function updateCustomDomain(request: UpdateCustomDomainRequest): UpdateCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateCustomDomain', 'PUT', '/2021-04-06/custom-domains/{domainName}', 'json', false, 'json', request);
}

model UpdateFunctionRequest {
  serviceName?: string(name='serviceName', description='service名称', position='Path'),
  functionName?: string(name='functionName', description='function名称', position='Path'),
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应', position='Header'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcCodeChecksum?: string(name='X-Fc-Code-Checksum', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  instanceConcurrency?: int32(name='InstanceConcurrency', position='Body'),
  caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口', position='Body'),
  code?: Code(name='code', position='Body'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig', position='Body'),
  customDNS?: CustomDNS(name='customDNS', description='函数自定义DNS配置', position='Body'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig', description='Custom Runtime函数详细配置', position='Body'),
  description?: string(name='description', description='函数描述', position='Body'),
  environmentVariables?: map[string]string(name='environmentVariables', description='为函数设置的环境变量，可以在函数中获取环境变量的值', position='Body'),
  handler?: string(name='handler', description='function执行的入口，具体格式和语言相关', position='Body'),
  initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行', position='Body'),
  initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关', position='Body'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig', position='Body'),
  instanceSoftConcurrency?: int32(name='instanceSoftConcurrency', position='Body'),
  instanceType?: string(name='instanceType', position='Body'),
  layers?: [ string ](name='layers', position='Body'),
  memorySize?: int32(name='memorySize', description='function的内存规格，单位为MB，为64MB的倍数', position='Body'),
  runtime?: string(name='runtime', description='runtime', position='Body'),
  timeout?: int32(name='timeout', description='function运行的超时时间，单位为秒，最小1秒，默认3秒。function超过这个时间后会被终止执行', position='Body'),
}

model UpdateFunctionResponseBody = {
  caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
  codeChecksum?: string(name='codeChecksum', description='function code包的CRC64值'),
  codeSize?: long(name='codeSize', description='系统返回的function的code包大小，单位为byte Example : 1024'),
  createdTime?: string(name='createdTime', description='function创建时间'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS', description='函数自定义DNS配置'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig', description='Custom Runtime函数详细配置'),
  description?: string(name='description', description='函数描述'),
  environmentVariables?: map[string]string(name='environmentVariables', description='为函数设置的环境变量，可以在函数中获取环境变量的值'),
  functionId?: string(name='functionId', description='系统为每个function生成的唯一ID'),
  functionName?: string(name='functionName', description='函数名称'),
  handler?: string(name='handler', description='function的执行入口'),
  initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
  initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
  instanceType?: string(name='instanceType'),
  lastModifiedTime?: string(name='lastModifiedTime', description='function上次修改时间'),
  layers?: [ string ](name='layers'),
  memorySize?: int32(name='memorySize', description='function设置的内存大小，单位为MB'),
  runtime?: string(name='runtime', description='function运行的语言环境，目前支持nodejs6, nodejs8, python2.7, python3, java8'),
  timeout?: int32(name='timeout', description='运行的超时时间，单位为秒'),
}

model UpdateFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFunctionResponseBody(name='body'),
}

async function updateFunction(request: UpdateFunctionRequest): UpdateFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateFunction', 'PUT', '/2021-04-06/services/{serviceName}/functions/{functionName}', 'json', false, 'json', request);
}

model UpdateServiceRequest {
  serviceName: string(name='serviceName', description='服务名称', position='Path'),
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应', position='Header'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  description?: string(name='description', description='服务描述', position='Body'),
  internetAccess?: boolean(name='internetAccess', description='公网访问设置', position='Body'),
  logConfig?: LogConfig(name='logConfig', position='Body'),
  nasConfig?: NASConfig(name='nasConfig', position='Body'),
  role?: string(name='role', description='服务角色', position='Body'),
  tracingConfig?: TracingConfig(name='tracingConfig', position='Body'),
  vpcConfig?: VPCConfig(name='vpcConfig', position='Body'),
}

model UpdateServiceResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='服务描述'),
  internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  role?: string(name='role', description='服务角色'),
  serviceId?: string(name='serviceId', description='服务ID'),
  serviceName?: string(name='serviceName', description='服务名称'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vendorConfig?: VendorConfig(name='vendorConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model UpdateServiceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateServiceResponseBody(name='body'),
}

async function updateService(request: UpdateServiceRequest): UpdateServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateService', 'PUT', '/2021-04-06/services/{serviceName}', 'json', false, 'json', request);
}

model UpdateTriggerRequest {
  serviceName: string(name='serviceName', description='service名称', position='Path'),
  functionName: string(name='functionName', description='function名称', position='Path'),
  triggerName: string(name='triggerName', description='trigger名称', position='Path'),
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应', position='Header'),
  xFcAccountId?: string(name='X-Fc-Account-Id', position='Header'),
  xFcDate?: string(name='X-Fc-Date', position='Header'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', position='Header'),
  description?: string(name='description', position='Body'),
  invocationRole?: string(name='invocationRole', description='event source，如OSS，使用该role去invoke function', position='Body'),
  qualifier?: string(name='qualifier', description='service版本', position='Body'),
  triggerConfig?: string(name='triggerConfig', description='trigger配置，针对不同的trigger类型，trigger配置会有所不同	', position='Body'),
}

model UpdateTriggerResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description'),
  domainName?: string(name='domainName', description='域名名称，使用域名名称拼接上函数计算域名，可以采用HTTP协议调用到触发器对应版本的函数。例如{domainName}.cn-shanghai.fc.aliyuncs.com'),
  invocationRole?: string(name='invocationRole', description='调用函数使用的RAM角色的ARN'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次修改时间'),
  qualifier?: string(name='qualifier', description='service版本'),
  sourceArn?: string(name='sourceArn', description='event source的Aliyun Resource Name（ARN'),
  triggerConfig?: string(name='triggerConfig', description='trigger配置对象'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName', description='trigger名称'),
  triggerType?: string(name='triggerType', description='trigger类型，如 oss, log, tablestore, timer, http, cdn_events, mns_topic'),
  urlInternet?: string(name='urlInternet', description='公网域名地址。在互联网可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
  urlIntranet?: string(name='urlIntranet', description='私网域名地址。在VPC可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
}

model UpdateTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTriggerResponseBody(name='body'),
}

async function updateTrigger(request: UpdateTriggerRequest): UpdateTriggerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RESTFUL', 'UpdateTrigger', 'PUT', '/2021-04-06/services/{serviceName}/functions/{functionName}/triggers/{triggerName}', 'json', false, 'json', request);
}

