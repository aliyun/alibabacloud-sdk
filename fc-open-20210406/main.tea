/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  @endpointMap = {
    ap-northeast-1 = 'account-id.ap-northeast-1.fc.aliyuncs.com',
    ap-south-1 = 'account-id.ap-south-1.fc.aliyuncs.com',
    ap-southeast-1 = 'account-id.ap-southeast-1.fc.aliyuncs.com',
    ap-southeast-2 = 'account-id.ap-southeast-2.fc.aliyuncs.com',
    ap-southeast-3 = 'account-id.ap-southeast-3.fc.aliyuncs.com',
    ap-southeast-5 = 'account-id.ap-southeast-5.fc.aliyuncs.com',
    cn-beijing = 'account-id.cn-beijing.fc.aliyuncs.com',
    cn-chengdu = 'account-id.cn-chengdu.fc.aliyuncs.com',
    cn-hangzhou = 'account-id.cn-hangzhou.fc.aliyuncs.com',
    cn-hangzhou-finance = 'account-id.cn-hangzhou-finance.fc.aliyuncs.com',
    cn-hongkong = 'account-id.cn-hongkong.fc.aliyuncs.com',
    cn-huhehaote = 'account-id.cn-huhehaote.fc.aliyuncs.com',
    cn-north-2-gov-1 = 'account-id.cn-north-2-gov-1.fc.aliyuncs.com',
    cn-qingdao = 'account-id.cn-qingdao.fc.aliyuncs.com',
    cn-shanghai = 'account-id.cn-shanghai.fc.aliyuncs.com',
    cn-shenzhen = 'account-id.cn-shenzhen.fc.aliyuncs.com',
    cn-zhangjiakou = 'account-id.cn-zhangjiakou.fc.aliyuncs.com',
    eu-central-1 = 'account-id.eu-central-1.fc.aliyuncs.com',
    eu-west-1 = 'account-id.eu-west-1.fc.aliyuncs.com',
    us-east-1 = 'account-id.us-east-1.fc.aliyuncs.com',
    us-west-1 = 'account-id.us-west-1.fc.aliyuncs.com',
  };
  checkConfig(config);
  @endpoint = getEndpoint('fc-open', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model PathConfig {
  functionName?: string(name='functionName', description='该路径/方法对应的函数名称'),
  methods?: [ string ](name='methods', description='请求方法，不填表示当前路径的所有方法匹配同一函数'),
  path?: string(name='path', description='请求路径'),
  qualifier?: string(name='qualifier', description='该路径/方法对应服务的版本/别名'),
  serviceName?: string(name='serviceName', description='该路径/方法对应的服务名称'),
}

model RouteConfig {
  routes?: [
    PathConfig
  ](name='routes', description='routes'),
}

model CertConfig {
  certName?: string(name='certName', description='证书名称'),
  certificate?: string(name='certificate', description='证书，如果是证书链则依次填写多个证书'),
  privateKey?: string(name='privateKey', description='私钥'),
}

model InstanceLifecycleConfig {
  preFreeze?: LifecycleHook(name='preFreeze'),
  preStop?: LifecycleHook(name='preStop'),
}

model CustomContainerConfig {
  args?: string(name='args', description='容器启动参数'),
  command?: string(name='command', description='容器启动命令，等同于 Docker ENTRYPOINT'),
  image?: string(name='image', description='容器镜像地址，实例值： registry-vpc.cn-hangzhou.aliyuncs.com/fc-demo/helloworld:v1beta1'),
  accelerationType?: string(name='accelerationType', description='镜像加速类型，取值Default为开启加速，None为关闭加速，默认关闭'),
}

model LifecycleHook {
  handler?: string(name='handler', description='handler name'),
  timeout?: int32(name='timeout', description='timeout in second'),
}

model Code {
  ossBucketName?: string(name='ossBucketName', description='函数代码包的OSS bucket name'),
  ossObjectName?: string(name='ossObjectName', description='函数代码包的OSS对象名'),
  zipFile?: string(name='zipFile', description='直接在request body中上传code zip包的base64编码'),
  codeCheckSum?: string(name='codeCheckSum', description='codeCheckSum'),
  err?: string(name='err', description='error'),
}

model OutputCodeLocation {
  repositoryType?: string(name='repositoryType', description='repositoryType'),
  location?: string(name='location', description='location'),
}

model VPCConfig {
  securityGroupId?: string(name='securityGroupId', description='安全组ID'),
  vSwitchIds?: [ string ](name='vSwitchIds', description='VSwitch ID列表'),
  vpcId?: string(name='vpcId', description='VPC ID'),
  role?: string(name='role', description='Role'),
}

model NASConfig {
  groupId?: string(name='groupId', description='groupID'),
  mountPoints?: [ 
    {
      mountDir?: string(name='mountDir', description='本地挂载目录'),
      serverAddr?: string(name='serverAddr', description='NAS服务器地址'),
    }
  ](name='mountPoints', description='挂载点'),
  userId?: string(name='userId', description='userID'),
}

model TracingConfig {
  type?: string(name='type', description='链路追踪类型'),
  params?: map[string]string(name='params', description='链路追踪参数'),
  jaegerConfig?: JaegerConfig(name='jaegerConfig'),
}

model JaegerConfig {
  endpoint?: string(name='endpoint', description='endpoint'),
}

model LogConfig {
  logstore?: string(name='logstore', description='日志库'),
  project?: string(name='project', description='日志项目'),
  enableRequestMetrics?: boolean(name='enableRequestMetrics', description='开启请求级别指标'),
  enableInstanceMetrics?: boolean(name='enableInstanceMetrics', description='开启实例级别指标'),
}

model AccelerationInfo {
  status?: string(name='status', description='镜像加速状态，取值 Preparing 或 Ready'),
}

model CustomContainerConfigInfo {
  args?: string(name='args', description='容器启动参数'),
  command?: string(name='command', description='容器启动命令，等同于 Docker ENTRYPOINT'),
  image?: string(name='image', description='容器镜像地址，实例值： registry-vpc.cn-hangzhou.aliyuncs.com/fc-demo/helloworld:v1beta1'),
  accelerationType?: string(name='accelerationType', description='镜像加速类型，取值Default为开启加速，None为关闭加速，默认关闭'),
  accelerationInfo?: AccelerationInfo(name='accelerationInfo'),
}

model Destination {
  destination?: string(name='destination', description='destination'),
}

model DestinationConfig {
  onSuccess?: Destination(name='onSuccess'),
  onFailure?: Destination(name='onFailure'),
}

model Layer {
  layerName?: string(name='layerName', description='层名称'),
  version?: int32(name='version', description='层版本'),
  description?: string(name='description', description='层描述'),
  code?: LayerCode(name='code', description='层代码'),
  codeSize?: long(name='codeSize', description='层代码大小'),
  codeChecksum?: string(name='codeChecksum', description='层Checksum'),
  createTime?: string(name='createTime', description='层创建时间'),
  acl?: int32(name='acl', description='层访问类型'),
  arn?: string(name='arn', description='arn'),
  compatibleRuntime?: [ string ](name='compatibleRuntime', description='compatibleRuntime'),
}

model LayerCode {
  repositoryType?: string(name='repositoryType', description='层代码类型'),
  location?: string(name='location', description='层代码位置'),
}

model ScheduledActions {
  name?: string(name='name', description='name'),
  startTime?: string(name='startTime', description='startTime'),
  endTime?: string(name='endTime', description='endTime'),
  target?: long(name='target', description='target'),
  scheduleExpression?: string(name='scheduleExpression', description='scheduleExpression'),
}

model TargetTrackingPolicies {
  name?: string(name='name', description='name'),
  startTime?: string(name='startTime', description='startTime'),
  endTime?: string(name='endTime', description='endTime'),
  metricType?: string(name='metricType', description='metricType'),
  metricTarget?: double(name='metricTarget', description='metricTarget'),
  minCapacity?: long(name='minCapacity', description='minCapacity'),
  maxCapacity?: long(name='maxCapacity', description='maxCapacity'),
}

model StatefulAsyncInvocation {
  functionName?: string(name='functionName', description='functionName'),
  serviceName?: string(name='serviceName', description='serviceName'),
  qualifier?: string(name='qualifier', description='qualifier'),
  invocationId?: string(name='invocationId', description='invocationId'),
  status?: string(name='status', description='status'),
  startedTime?: long(name='startedTime', description='startedTime'),
  endTime?: long(name='endTime', description='endTime'),
  destinationStatus?: string(name='destinationStatus', description='destinationStatus'),
  invocationErrorMessage?: string(name='invocationErrorMessage', description='invocationErrorMessage'),
  invocationPayload?: string(name='invocationPayload', description='invocationPayload'),
  alreadyRetriedTimes?: long(name='alreadyRetriedTimes', description='alreadyRetriedTimes'),
  requestId?: string(name='requestId', description='requestId'),
}

model OnDemandConfig {
  resource?: string(name='resource', description='函数详情'),
  maximumInstanceCount?: long(name='maximumInstanceCount', description='todo'),
}

model OpenReservedCapacity {
  instanceId?: string(name='instanceId', description='instanceId'),
  cu?: long(name='cu', description='cu'),
  deadline?: string(name='deadline', description='deadline'),
  createdTime?: string(name='createdTime', description='createdTime'),
  lastModifiedTime?: string(name='lastModifiedTime', description='lastModifiedTime'),
  isRefunded?: string(name='isRefunded', description='isRefunded'),
}

model Resource {
  resourceArn?: string(name='resourceArn', description='resourceArn'),
  tags?: map[string]string(name='tags', description='tags'),
}

model CreateAliasRequest {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
  aliasName?: string(name='aliasName', description='别名名称'),
  description?: string(name='description', description='别名描述'),
  versionId?: string(name='versionId', description='版本ID'),
}

model CreateAliasResponseBody = {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
  aliasName?: string(name='aliasName', description='别名名称'),
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='别名描述'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  versionId?: string(name='versionId', description='版本ID'),
}

model CreateAliasResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAliasResponseBody(name='body'),
}

async function createAlias(serviceName: string, request: CreateAliasRequest): CreateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAliasWithOptions(serviceName, request, headers, runtime);
}

async function createAliasWithOptions(serviceName: string, request: CreateAliasRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAliasResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.additionalVersionWeight)) {
    body.additionalVersionWeight = request.additionalVersionWeight;
  }
  if (!Util.isUnset(request.aliasName)) {
    body.aliasName = request.aliasName;
  }
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }
  if (!Util.isUnset(request.versionId)) {
    body.versionId = request.versionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateAlias', '2021-04-06', 'HTTPS', 'POST', 'AK', `/2021-04-06/services/${serviceName}/aliases`, 'json', req, runtime);
}

model CreateCustomDomainRequest {
  domainName?: string(name='domainName'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  certConfig?: CertConfig(name='certConfig'),
}

model CreateCustomDomainResponseBody = {
  domainName?: string(name='domainName', description='Id of the request'),
  accountId?: string(name='accountId'),
  protocol?: string(name='protocol'),
  certConfig?: CertConfig(name='certConfig'),
  apiVersion?: string(name='apiVersion'),
  routeConfig?: RouteConfig(name='routeConfig'),
  createdTime?: string(name='createdTime'),
  lastModifiedTime?: string(name='lastModifiedTime'),
}

model CreateCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCustomDomainResponseBody(name='body'),
}

async function createCustomDomain(request: CreateCustomDomainRequest): CreateCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createCustomDomainWithOptions(request, headers, runtime);
}

async function createCustomDomainWithOptions(request: CreateCustomDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateCustomDomainResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.domainName)) {
    body.domainName = request.domainName;
  }
  if (!Util.isUnset(request.protocol)) {
    body.protocol = request.protocol;
  }
  if (!Util.isUnset(request.routeConfig)) {
    body.routeConfig = request.routeConfig;
  }
  if (!Util.isUnset(request.certConfig)) {
    body.certConfig = request.certConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateCustomDomain', '2021-04-06', 'HTTPS', 'POST', 'AK', `/2021-04-06/custom-domains`, 'json', req, runtime);
}

model CreateFunctionHeaders {
  commonHeaders?: map[string]string,
  xFcCodeChecksum?: string(name='x-fc-code-checksum', description='code checksum'),
}

model CreateFunctionRequest {
  code?: Code(name='code'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  layers?: [ string ](name='layers', description='层列表'),
  description?: string(name='description', description='函数描述'),
  functionName?: string(name='functionName', description='函数名称'),
  handler?: string(name='handler', description='function执行的入口，具体格式和语言相关'),
  initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
  initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
  memorySize?: int32(name='memorySize', description='function的内存规格，单位为MB，为64MB的倍数'),
  runtime?: string(name='runtime', description='function运行的语言环境，目前支持nodejs6, nodejs8, python2.7, python3, java8'),
  timeout?: int32(name='timeout', description='function运行的超时时间，单位为秒，最小1秒，默认3秒。function超过这个时间后会被终止执行'),
  caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  instanceType?: string(name='instanceType'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
}

model CreateFunctionResponseBody = {
  codeChecksum?: string(name='codeChecksum', description='function code包的CRC64值'),
  codeSize?: long(name='codeSize', description='系统返回的function的code包大小，单位为byte Example : 1024'),
  createdTime?: string(name='createdTime', description='function创建时间'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  layers?: [ string ](name='layers'),
  description?: string(name='description', description='函数描述'),
  functionId?: string(name='functionId', description='系统为每个function生成的唯一ID'),
  functionName?: string(name='functionName', description='函数名称'),
  handler?: string(name='handler', description='function的执行入口'),
  lastModifiedTime?: string(name='lastModifiedTime', description='function上次修改时间'),
  memorySize?: int32(name='memorySize', description='function设置的内存大小，单位为MB'),
  runtime?: string(name='runtime', description='function运行的语言环境，目前支持nodejs6, nodejs8, python2.7, python3, java8'),
  timeout?: int32(name='timeout', description='运行的超时时间，单位为秒'),
  initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
  initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
  caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  instanceType?: string(name='instanceType'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
}

model CreateFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFunctionResponseBody(name='body'),
}

async function createFunction(serviceName: string, request: CreateFunctionRequest): CreateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateFunctionHeaders{};
  return createFunctionWithOptions(serviceName, request, headers, runtime);
}

async function createFunctionWithOptions(serviceName: string, request: CreateFunctionRequest, headers: CreateFunctionHeaders, runtime: Util.RuntimeOptions): CreateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.code)) {
    body.code = request.code;
  }
  if (!Util.isUnset(request.customContainerConfig)) {
    body.customContainerConfig = request.customContainerConfig;
  }
  if (!Util.isUnset(request.layers)) {
    body.layers = request.layers;
  }
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }
  if (!Util.isUnset(request.functionName)) {
    body.functionName = request.functionName;
  }
  if (!Util.isUnset(request.handler)) {
    body.handler = request.handler;
  }
  if (!Util.isUnset(request.initializationTimeout)) {
    body.initializationTimeout = request.initializationTimeout;
  }
  if (!Util.isUnset(request.initializer)) {
    body.initializer = request.initializer;
  }
  if (!Util.isUnset(request.memorySize)) {
    body.memorySize = request.memorySize;
  }
  if (!Util.isUnset(request.runtime)) {
    body.runtime = request.runtime;
  }
  if (!Util.isUnset(request.timeout)) {
    body.timeout = request.timeout;
  }
  if (!Util.isUnset(request.caPort)) {
    body.caPort = request.caPort;
  }
  if (!Util.isUnset(request.environmentVariables)) {
    body.environmentVariables = request.environmentVariables;
  }
  if (!Util.isUnset(request.instanceConcurrency)) {
    body.instanceConcurrency = request.instanceConcurrency;
  }
  if (!Util.isUnset(request.instanceType)) {
    body.instanceType = request.instanceType;
  }
  if (!Util.isUnset(request.instanceLifecycleConfig)) {
    body.instanceLifecycleConfig = request.instanceLifecycleConfig;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcCodeChecksum)) {
    realHeaders.x-fc-code-checksum = headers.xFcCodeChecksum;
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateFunction', '2021-04-06', 'HTTPS', 'POST', 'AK', `/2021-04-06/services/${serviceName}/functions`, 'json', req, runtime);
}

model CreateLayerVersionRequest {
  description?: string(name='description'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  code?: Code(name='Code'),
}

model CreateLayerVersionResponseBody = {
  layerName?: string(name='layerName'),
  version?: int32(name='version'),
  description?: string(name='description'),
  code?: OutputCodeLocation(name='code'),
  codesize?: long(name='codesize'),
  codeChecksum?: string(name='codeChecksum'),
  createTime?: string(name='createTime'),
  acl?: int32(name='acl'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  arn?: string(name='Arn'),
}

model CreateLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLayerVersionResponseBody(name='body'),
}

async function createLayerVersion(layerName: string, request: CreateLayerVersionRequest): CreateLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLayerVersionWithOptions(layerName, request, headers, runtime);
}

async function createLayerVersionWithOptions(layerName: string, request: CreateLayerVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLayerVersionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }
  if (!Util.isUnset(request.compatibleRuntime)) {
    body.compatibleRuntime = request.compatibleRuntime;
  }
  if (!Util.isUnset(request.code)) {
    body.Code = request.code;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateLayerVersion', '2021-04-06', 'HTTPS', 'POST', 'AK', `/2021-04-06/layers/${layerName}/versions`, 'json', req, runtime);
}

model CreateServiceRequest {
  description?: string(name='description', description='服务描述'),
  internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  role?: string(name='role', description='服务角色'),
  serviceName?: string(name='serviceName', description='服务名称'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
}

model CreateServiceResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='服务描述'),
  internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  role?: string(name='role', description='服务角色'),
  serviceId?: string(name='serviceId', description='服务ID'),
  serviceName?: string(name='serviceName', description='服务名称'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
}

model CreateServiceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceResponseBody(name='body'),
}

async function createService(request: CreateServiceRequest): CreateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createServiceWithOptions(request, headers, runtime);
}

async function createServiceWithOptions(request: CreateServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateServiceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }
  if (!Util.isUnset(request.internetAccess)) {
    body.internetAccess = request.internetAccess;
  }
  if (!Util.isUnset(request.logConfig)) {
    body.logConfig = request.logConfig;
  }
  if (!Util.isUnset(request.nasConfig)) {
    body.nasConfig = request.nasConfig;
  }
  if (!Util.isUnset(request.role)) {
    body.role = request.role;
  }
  if (!Util.isUnset(request.serviceName)) {
    body.serviceName = request.serviceName;
  }
  if (!Util.isUnset(request.vpcConfig)) {
    body.vpcConfig = request.vpcConfig;
  }
  if (!Util.isUnset(request.tracingConfig)) {
    body.tracingConfig = request.tracingConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateService', '2021-04-06', 'HTTPS', 'POST', 'AK', `/2021-04-06/services`, 'json', req, runtime);
}

model CreateTriggerRequest {
  invocationRole?: string(name='invocationRole', description='event source，如OSS，使用该role去invoke function'),
  qualifier?: string(name='qualifier', description='service版本'),
  sourceArn?: string(name='sourceArn', description='event source的Aliyun Resource Name（ARN'),
  triggerConfig?: map[string]string(name='triggerConfig', description='trigger配置，针对不同的trigger类型，trigger配置会有所不同'),
  triggerName?: string(name='triggerName', description='trigger名称'),
  triggerType?: string(name='triggerType', description='trigger类型，如 oss, log, tablestore, timer, http, cdn_events, mns_topic'),
  description?: string(name='description'),
}

model CreateTriggerResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  invocationRole?: string(name='invocationRole', description='调用函数使用的RAM角色的ARN'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次修改时间'),
  qualifier?: string(name='qualifier', description='service版本'),
  sourceArn?: string(name='sourceArn', description='event source的Aliyun Resource Name（ARN'),
  triggerConfig?: string(name='triggerConfig', description='trigger配置对象'),
  triggerName?: string(name='triggerName', description='trigger名称'),
  triggerType?: string(name='triggerType', description='trigger类型，如 oss, log, tablestore, timer, http, cdn_events, mns_topic'),
  description?: string(name='description'),
  triggerId?: string(name='triggerId'),
}

model CreateTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTriggerResponseBody(name='body'),
}

async function createTrigger(serviceName: string, functionName: string, request: CreateTriggerRequest): CreateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createTriggerWithOptions(serviceName, functionName, request, headers, runtime);
}

async function createTriggerWithOptions(serviceName: string, functionName: string, request: CreateTriggerRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateTriggerResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.invocationRole)) {
    body.invocationRole = request.invocationRole;
  }
  if (!Util.isUnset(request.qualifier)) {
    body.qualifier = request.qualifier;
  }
  if (!Util.isUnset(request.sourceArn)) {
    body.sourceArn = request.sourceArn;
  }
  if (!Util.isUnset(request.triggerConfig)) {
    body.triggerConfig = request.triggerConfig;
  }
  if (!Util.isUnset(request.triggerName)) {
    body.triggerName = request.triggerName;
  }
  if (!Util.isUnset(request.triggerType)) {
    body.triggerType = request.triggerType;
  }
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateTrigger', '2021-04-06', 'HTTPS', 'POST', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/triggers`, 'json', req, runtime);
}

model CreateVpcBindingRequest {
  vpcId?: string(name='vpcId'),
}

model CreateVpcBindingResponse = {
  headers: map[string]string(name='headers'),
}

async function createVpcBinding(serviceName: string, request: CreateVpcBindingRequest): CreateVpcBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createVpcBindingWithOptions(serviceName, request, headers, runtime);
}

async function createVpcBindingWithOptions(serviceName: string, request: CreateVpcBindingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateVpcBindingResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.vpcId)) {
    body.vpcId = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('CreateVpcBinding', '2021-04-06', 'HTTPS', 'POST', 'AK', `/2021-04-06/services/${serviceName}/binding`, 'none', req, runtime);
}

model DeleteAliasHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
}

model DeleteAliasResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteAlias(serviceName: string, aliasName: string): DeleteAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteAliasHeaders{};
  return deleteAliasWithOptions(serviceName, aliasName, headers, runtime);
}

async function deleteAliasWithOptions(serviceName: string, aliasName: string, headers: DeleteAliasHeaders, runtime: Util.RuntimeOptions): DeleteAliasResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders.If-Match = headers.ifMatch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  return doROARequest('DeleteAlias', '2021-04-06', 'HTTPS', 'DELETE', 'AK', `/2021-04-06/services/${serviceName}/aliases/${aliasName}`, 'none', req, runtime);
}

model DeleteCustomDomainResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteCustomDomain(domainName: string): DeleteCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteCustomDomainWithOptions(domainName, headers, runtime);
}

async function deleteCustomDomainWithOptions(domainName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteCustomDomainResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeleteCustomDomain', '2021-04-06', 'HTTPS', 'DELETE', 'AK', `/2021-04-06/custom-domains/${domainName}`, 'none', req, runtime);
}

model DeleteFunctionHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应'),
}

model DeleteFunctionResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteFunction(serviceName: string, functionName: string): DeleteFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteFunctionHeaders{};
  return deleteFunctionWithOptions(serviceName, functionName, headers, runtime);
}

async function deleteFunctionWithOptions(serviceName: string, functionName: string, headers: DeleteFunctionHeaders, runtime: Util.RuntimeOptions): DeleteFunctionResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders.If-Match = headers.ifMatch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  return doROARequest('DeleteFunction', '2021-04-06', 'HTTPS', 'DELETE', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}`, 'none', req, runtime);
}

model DeleteFunctionAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier', description='限定符'),
}

model DeleteFunctionAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteFunctionAsyncInvokeConfig(serviceName: string, functionName: string, request: DeleteFunctionAsyncInvokeConfigRequest): DeleteFunctionAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFunctionAsyncInvokeConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function deleteFunctionAsyncInvokeConfigWithOptions(serviceName: string, functionName: string, request: DeleteFunctionAsyncInvokeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFunctionAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteFunctionAsyncInvokeConfig', '2021-04-06', 'HTTPS', 'DELETE', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/async-invoke-config`, 'none', req, runtime);
}

model DeleteFunctionOnDemandConfigHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
}

model DeleteFunctionOnDemandConfigRequest {
  qualifier?: string(name='qualifier'),
}

model DeleteFunctionOnDemandConfigResponseBody = {
  requestId?: string(name='requestId', description='Id of the request'),
}

model DeleteFunctionOnDemandConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFunctionOnDemandConfigResponseBody(name='body'),
}

async function deleteFunctionOnDemandConfig(serviceName: string, functionName: string, request: DeleteFunctionOnDemandConfigRequest): DeleteFunctionOnDemandConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteFunctionOnDemandConfigHeaders{};
  return deleteFunctionOnDemandConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function deleteFunctionOnDemandConfigWithOptions(serviceName: string, functionName: string, request: DeleteFunctionOnDemandConfigRequest, headers: DeleteFunctionOnDemandConfigHeaders, runtime: Util.RuntimeOptions): DeleteFunctionOnDemandConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders.If-Match = headers.ifMatch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DeleteFunctionOnDemandConfig', '2021-04-06', 'HTTPS', 'DELETE', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/on-demand-config`, 'json', req, runtime);
}

model DeleteLayerVersionResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteLayerVersion(layerName: string, version: string): DeleteLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLayerVersionWithOptions(layerName, version, headers, runtime);
}

async function deleteLayerVersionWithOptions(layerName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLayerVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeleteLayerVersion', '2021-04-06', 'HTTPS', 'DELETE', 'AK', `/2021-04-06/layers/${layerName}/versions/${version}`, 'none', req, runtime);
}

model DeleteServiceHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应'),
}

model DeleteServiceResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteService(serviceName: string): DeleteServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteServiceHeaders{};
  return deleteServiceWithOptions(serviceName, headers, runtime);
}

async function deleteServiceWithOptions(serviceName: string, headers: DeleteServiceHeaders, runtime: Util.RuntimeOptions): DeleteServiceResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders.If-Match = headers.ifMatch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  return doROARequest('DeleteService', '2021-04-06', 'HTTPS', 'DELETE', 'AK', `/2021-04-06/services/${serviceName}`, 'none', req, runtime);
}

model DeleteServiceVersionResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteServiceVersion(serviceName: string, versionId: string): DeleteServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteServiceVersionWithOptions(serviceName, versionId, headers, runtime);
}

async function deleteServiceVersionWithOptions(serviceName: string, versionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteServiceVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('DeleteServiceVersion', '2021-04-06', 'HTTPS', 'DELETE', 'AK', `/2021-04-06/services/${serviceName}/versions/${versionId}`, 'none', req, runtime);
}

model DeleteTriggerHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应'),
}

model DeleteTriggerResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteTrigger(serviceName: string, functionName: string, triggerName: string): DeleteTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteTriggerHeaders{};
  return deleteTriggerWithOptions(serviceName, functionName, triggerName, headers, runtime);
}

async function deleteTriggerWithOptions(serviceName: string, functionName: string, triggerName: string, headers: DeleteTriggerHeaders, runtime: Util.RuntimeOptions): DeleteTriggerResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders.If-Match = headers.ifMatch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  return doROARequest('DeleteTrigger', '2021-04-06', 'HTTPS', 'DELETE', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/triggers/${triggerName}`, 'none', req, runtime);
}

model DeleteVpcBindingRequest {
  vpcId?: string(name='vpcId'),
}

model DeleteVpcBindingResponse = {
  headers: map[string]string(name='headers'),
}

async function deleteVpcBinding(serviceName: string, request: DeleteVpcBindingRequest): DeleteVpcBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteVpcBindingWithOptions(serviceName, request, headers, runtime);
}

async function deleteVpcBindingWithOptions(serviceName: string, request: DeleteVpcBindingRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteVpcBindingResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.vpcId)) {
    body.vpcId = request.vpcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('DeleteVpcBinding', '2021-04-06', 'HTTPS', 'DELETE', 'AK', `/2021-04-06/services/${serviceName}/binding`, 'none', req, runtime);
}

model GetAccountSettingsResponseBody = {
  availableAZs?: [ string ](name='availableAZs', description='可用区列表'),
}

model GetAccountSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccountSettingsResponseBody(name='body'),
}

async function getAccountSettings(): GetAccountSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAccountSettingsWithOptions(headers, runtime);
}

async function getAccountSettingsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetAccountSettingsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetAccountSettings', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/account-settings`, 'json', req, runtime);
}

model GetAliasResponseBody = {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
  aliasName?: string(name='aliasName', description='别名名称'),
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='别名描述'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  versionId?: string(name='versionId', description='版本ID'),
}

model GetAliasResponse = {
  headers: map[string]string(name='headers'),
  body: GetAliasResponseBody(name='body'),
}

async function getAlias(serviceName: string, aliasName: string): GetAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getAliasWithOptions(serviceName, aliasName, headers, runtime);
}

async function getAliasWithOptions(serviceName: string, aliasName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetAliasResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetAlias', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}/aliases/${aliasName}`, 'json', req, runtime);
}

model GetCustomDomainResponseBody = {
  domainName?: string(name='domainName', description='Id of the request'),
  accountId?: string(name='accountId'),
  protocol?: string(name='protocol'),
  apiVersion?: string(name='apiVersion'),
  createdTime?: string(name='createdTime'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  certConfig?: CertConfig(name='certConfig'),
  routeConfig?: RouteConfig(name='routeConfig'),
}

model GetCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  body: GetCustomDomainResponseBody(name='body'),
}

async function getCustomDomain(domainName: string): GetCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getCustomDomainWithOptions(domainName, headers, runtime);
}

async function getCustomDomainWithOptions(domainName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetCustomDomainResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetCustomDomain', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/custom-domains/${domainName}`, 'json', req, runtime);
}

model GetFunctionRequest {
  qualifier?: string(name='qualifier', description='service版本, 可以是versionId或者aliasName'),
}

model GetFunctionResponseBody = {
  codeChecksum?: string(name='codeChecksum', description='function code包的CRC64值'),
  codeSize?: long(name='codeSize', description='系统返回的function的code包大小，单位为byte Example : 1024'),
  createdTime?: string(name='createdTime', description='function创建时间'),
  description?: string(name='description', description='函数描述'),
  environmentVariables?: map[string]string(name='environmentVariables', description='为函数设置的环境变量，可以在函数中获取环境变量的值'),
  functionId?: string(name='functionId', description='系统为每个function生成的唯一ID'),
  functionName?: string(name='functionName', description='函数名称'),
  handler?: string(name='handler', description='function的执行入口'),
  lastModifiedTime?: string(name='lastModifiedTime', description='function上次修改时间'),
  memorySize?: int32(name='memorySize', description='function设置的内存大小，单位为MB'),
  runtime?: string(name='runtime', description='function运行的语言环境，目前支持nodejs6, nodejs8, python2.7, python3, java8'),
  timeout?: int32(name='timeout', description='运行的超时时间，单位为秒'),
  initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
  initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
  caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
  customContainerConfig?: CustomContainerConfigInfo(name='customContainerConfig'),
  layers?: [ string ](name='layers'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  instanceType?: string(name='instanceType'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
}

model GetFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: GetFunctionResponseBody(name='body'),
}

async function getFunction(serviceName: string, functionName: string, request: GetFunctionRequest): GetFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionWithOptions(serviceName, functionName, request, headers, runtime);
}

async function getFunctionWithOptions(serviceName: string, functionName: string, request: GetFunctionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetFunction', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}`, 'json', req, runtime);
}

model GetFunctionAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier', description='限定符'),
}

model GetFunctionAsyncInvokeConfigResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  function?: string(name='function', description='函数名称'),
  lastModifiedTime?: string(name='lastModifiedTime', description='最后更改时间'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', description='消息最大存活时长'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', description='异步调用失败后的最大重试次数'),
  qualifier?: string(name='qualifier', description='限定符'),
  service?: string(name='service', description='服务名称'),
  statefulInvocation?: boolean(name='statefulInvocation'),
}

model GetFunctionAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetFunctionAsyncInvokeConfigResponseBody(name='body'),
}

async function getFunctionAsyncInvokeConfig(serviceName: string, functionName: string, request: GetFunctionAsyncInvokeConfigRequest): GetFunctionAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionAsyncInvokeConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function getFunctionAsyncInvokeConfigWithOptions(serviceName: string, functionName: string, request: GetFunctionAsyncInvokeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetFunctionAsyncInvokeConfig', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/async-invoke-config`, 'json', req, runtime);
}

model GetFunctionCodeRequest {
  qualifier?: string(name='qualifier', description='service版本, 可以是versionId或者aliasName'),
}

model GetFunctionCodeResponseBody = {
  checksum?: string(name='checksum', description='function code包的CRC64值'),
  url?: string(name='url', description='获取function代码的URL'),
}

model GetFunctionCodeResponse = {
  headers: map[string]string(name='headers'),
  body: GetFunctionCodeResponseBody(name='body'),
}

async function getFunctionCode(serviceName: string, functionName: string, request: GetFunctionCodeRequest): GetFunctionCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionCodeWithOptions(serviceName, functionName, request, headers, runtime);
}

async function getFunctionCodeWithOptions(serviceName: string, functionName: string, request: GetFunctionCodeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionCodeResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetFunctionCode', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/code`, 'json', req, runtime);
}

model GetFunctionOnDemandConfigRequest {
  qualifier?: string(name='qualifier'),
}

model GetFunctionOnDemandConfigResponseBody = {
  resource?: string(name='resource', description='Id of the request'),
  maximumInstanceCount?: long(name='maximumInstanceCount'),
}

model GetFunctionOnDemandConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetFunctionOnDemandConfigResponseBody(name='body'),
}

async function getFunctionOnDemandConfig(serviceName: string, functionName: string, request: GetFunctionOnDemandConfigRequest): GetFunctionOnDemandConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFunctionOnDemandConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function getFunctionOnDemandConfigWithOptions(serviceName: string, functionName: string, request: GetFunctionOnDemandConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFunctionOnDemandConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetFunctionOnDemandConfig', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/on-demand-config`, 'json', req, runtime);
}

model GetLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  body: Layer  
}

async function getLayerVersion(layerName: string, version: string): GetLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLayerVersionWithOptions(layerName, version, headers, runtime);
}

async function getLayerVersionWithOptions(layerName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLayerVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetLayerVersion', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/layers/${layerName}/versions/${version}`, 'json', req, runtime);
}

model GetLayerVersionByArnResponseBody = {
  layerName?: string(name='layerName'),
  version?: int32(name='version'),
  description?: string(name='description'),
  code?: OutputCodeLocation(name='code'),
  codesize?: long(name='codesize'),
  codeChecksum?: string(name='codeChecksum'),
  createTime?: string(name='createTime'),
  acl?: int32(name='acl'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  arn?: string(name='Arn'),
}

model GetLayerVersionByArnResponse = {
  headers: map[string]string(name='headers'),
  body: GetLayerVersionByArnResponseBody(name='body'),
}

async function getLayerVersionByArn(arn: string): GetLayerVersionByArnResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLayerVersionByArnWithOptions(arn, headers, runtime);
}

async function getLayerVersionByArnWithOptions(arn: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLayerVersionByArnResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetLayerVersionByArn', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/layerarn/${arn}`, 'json', req, runtime);
}

model GetProvisionConfigRequest {
  qualifier?: string(name='qualifier', description='别名名称'),
  target?: long(name='target', description='预留的目标资源个数'),
}

model GetProvisionConfigResponseBody = {
  resource?: string(name='resource', description='资源描述'),
  target?: long(name='target', description='目标资源个数'),
  current?: long(name='current', description='实际资源个数'),
  scheduledActions?: [
    ScheduledActions
  ](name='scheduledActions', description='定时策略配置'),
  targetTrackingPolicies?: [
    TargetTrackingPolicies
  ](name='targetTrackingPolicies', description='指标追踪伸缩策略配置'),
}

model GetProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetProvisionConfigResponseBody(name='body'),
}

async function getProvisionConfig(serviceName: string, functionName: string, request: GetProvisionConfigRequest): GetProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProvisionConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function getProvisionConfigWithOptions(serviceName: string, functionName: string, request: GetProvisionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.target)) {
    body.target = request.target;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('GetProvisionConfig', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/provision-config`, 'json', req, runtime);
}

model GetResourceTagsRequest {
  resourceArn?: string(name='resourceArn', description='Resource ARN 全称或者简称'),
}

model GetResourceTagsResponseBody = {
  resourceArn?: string(name='resourceArn', description='Resource ARN 全称'),
  tags?: map[string]string(name='tags', description='tag 列表'),
}

model GetResourceTagsResponse = {
  headers: map[string]string(name='headers'),
  body: GetResourceTagsResponseBody(name='body'),
}

async function getResourceTags(request: GetResourceTagsRequest): GetResourceTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getResourceTagsWithOptions(request, headers, runtime);
}

async function getResourceTagsWithOptions(request: GetResourceTagsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetResourceTagsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.resourceArn)) {
    query.resourceArn = request.resourceArn;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetResourceTags', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/tag`, 'json', req, runtime);
}

model GetServiceRequest {
  qualifier?: string(name='qualifier', description='限定符'),
}

model GetServiceResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='服务描述'),
  internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  role?: string(name='role', description='服务角色'),
  serviceId?: string(name='serviceId', description='服务ID'),
  serviceName?: string(name='serviceName', description='服务名称'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
}

model GetServiceResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceResponseBody(name='body'),
}

async function getService(serviceName: string, request: GetServiceRequest): GetServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getServiceWithOptions(serviceName, request, headers, runtime);
}

async function getServiceWithOptions(serviceName: string, request: GetServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetServiceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetService', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}`, 'json', req, runtime);
}

model GetStatefulAsyncInvocationRequest {
  qualifier?: string(name='qualifier'),
}

model GetStatefulAsyncInvocationResponse = {
  headers: map[string]string(name='headers'),
  body: StatefulAsyncInvocation  
}

async function getStatefulAsyncInvocation(serviceName: string, functionName: string, invocationId: string, request: GetStatefulAsyncInvocationRequest): GetStatefulAsyncInvocationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getStatefulAsyncInvocationWithOptions(serviceName, functionName, invocationId, request, headers, runtime);
}

async function getStatefulAsyncInvocationWithOptions(serviceName: string, functionName: string, invocationId: string, request: GetStatefulAsyncInvocationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetStatefulAsyncInvocationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetStatefulAsyncInvocation', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/stateful-async-invocations/${invocationId}`, 'json', req, runtime);
}

model GetTriggerResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  invocationRole?: string(name='invocationRole', description='调用函数使用的RAM角色的ARN'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次修改时间'),
  qualifier?: string(name='qualifier', description='service版本'),
  sourceArn?: string(name='sourceArn', description='event source的Aliyun Resource Name（ARN'),
  triggerConfig?: string(name='triggerConfig', description='trigger配置对象'),
  triggerName?: string(name='triggerName', description='trigger名称'),
  triggerType?: string(name='triggerType', description='trigger类型，如 oss, log, tablestore, timer, http, cdn_events, mns_topic'),
  description?: string(name='description'),
  triggerId?: string(name='triggerId'),
}

model GetTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: GetTriggerResponseBody(name='body'),
}

async function getTrigger(serviceName: string, functionName: string, triggerName: string): GetTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTriggerWithOptions(serviceName, functionName, triggerName, headers, runtime);
}

async function getTriggerWithOptions(serviceName: string, functionName: string, triggerName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetTriggerResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('GetTrigger', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/triggers/${triggerName}`, 'json', req, runtime);
}

model InvokeFunctionHeaders {
  commonHeaders?: map[string]string,
  xFcInvocationType?: string(name='x-fc-invocation-type', description='调用方式:Sync或者Async，默认值：Sync'),
  xFcLogType?: string(name='x-fc-log-type', description='请求返回日志类型, Tail 为返回函数日志最后 4KB 数据，None 或空值则返回不带有日志，默认为 None'),
  xFcAccountId?: string(name='X-Fc-Account-Id', description='用户 uid'),
  xFcStatefulAsyncInvocationId?: string(name='x-fc-stateful-async-invocation-id'),
}

model InvokeFunctionRequest {
  qualifier?: string(name='qualifier', description='service版本, 可以是versionId或者aliasName'),
  body?: string(name='body', description='事件（event），binary type。函数计算服务将event传递给用户function来处理'),
}

model InvokeFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: readable(name='body'),
}

async function invokeFunction(serviceName: string, functionName: string, request: InvokeFunctionRequest): InvokeFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new InvokeFunctionHeaders{};
  return invokeFunctionWithOptions(serviceName, functionName, request, headers, runtime);
}

async function invokeFunctionWithOptions(serviceName: string, functionName: string, request: InvokeFunctionRequest, headers: InvokeFunctionHeaders, runtime: Util.RuntimeOptions): InvokeFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcInvocationType)) {
    realHeaders.x-fc-invocation-type = headers.xFcInvocationType;
  }
  if (!Util.isUnset(headers.xFcLogType)) {
    realHeaders.x-fc-log-type = headers.xFcLogType;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders.X-Fc-Account-Id = headers.xFcAccountId;
  }
  if (!Util.isUnset(headers.xFcStatefulAsyncInvocationId)) {
    realHeaders.x-fc-stateful-async-invocation-id = headers.xFcStatefulAsyncInvocationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = request.body,
  };
  var res = new InvokeFunctionResponse{};
  var tmp = Util.assertAsMap(doROARequest('InvokeFunction', '2021-04-06', 'HTTPS', 'POST', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/invocations`, 'binary', req, runtime));
  if (!Util.isUnset(tmp.body)) {
    var respBody = Util.assertAsReadable(tmp.body);
    res.body = respBody;
  }
  if (!Util.isUnset(tmp.headers)) {
    var respHeaders = Util.assertAsMap(tmp.headers);
    res.headers = Util.stringifyMapValue(respHeaders);
  }
  return res;
}

model ListAliasesRequest {
  limit?: int32(name='limit', description='最多返回个数'),
  nextToken?: string(name='nextToken', description='下次查询token'),
  prefix?: string(name='prefix', description='前缀'),
  startKey?: string(name='startKey', description='起始key'),
}

model ListAliasesResponseBody = {
  aliases?: [ 
    {
      additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
      aliasName?: string(name='aliasName', description='别名名称'),
      createdTime?: string(name='createdTime', description='创建时间'),
      description?: string(name='description', description='别名描述'),
      lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
      versionId?: string(name='versionId', description='版本ID'),
    }
  ](name='aliases', description='别名列表'),
  nextToken?: string(name='nextToken', description='下次查询token'),
}

model ListAliasesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAliasesResponseBody(name='body'),
}

async function listAliases(serviceName: string, request: ListAliasesRequest): ListAliasesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listAliasesWithOptions(serviceName, request, headers, runtime);
}

async function listAliasesWithOptions(serviceName: string, request: ListAliasesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListAliasesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query.limit = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query.nextToken = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query.prefix = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query.startKey = request.startKey;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListAliases', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}/aliases`, 'json', req, runtime);
}

model ListCustomDomainsRequest {
  prefix?: string(name='prefix'),
  startKey?: string(name='startKey'),
  nextToken?: string(name='nextToken'),
  limit?: int32(name='limit'),
}

model ListCustomDomainsResponseBody = {
  nextToken?: string(name='nextToken'),
  customDomains?: [ 
    {
      domainName?: string(name='domainName'),
      accountId?: string(name='accountId'),
      protocol?: string(name='protocol'),
      apiVersion?: string(name='apiVersion'),
      createdTime?: string(name='createdTime'),
      lastModifiedTime?: string(name='lastModifiedTime'),
      certConfig?: CertConfig(name='certConfig'),
      routeConfig?: RouteConfig(name='routeConfig'),
    }
  ](name='customDomains'),
}

model ListCustomDomainsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCustomDomainsResponseBody(name='body'),
}

async function listCustomDomains(request: ListCustomDomainsRequest): ListCustomDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listCustomDomainsWithOptions(request, headers, runtime);
}

async function listCustomDomainsWithOptions(request: ListCustomDomainsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListCustomDomainsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.prefix)) {
    query.prefix = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query.startKey = request.startKey;
  }
  if (!Util.isUnset(request.nextToken)) {
    query.nextToken = request.nextToken;
  }
  if (!Util.isUnset(request.limit)) {
    query.limit = request.limit;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListCustomDomains', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/custom-domains`, 'json', req, runtime);
}

model ListFunctionAsyncInvokeConfigsRequest {
  limit?: int32(name='limit', description='最多返回个数'),
  nextToken?: string(name='nextToken', description='下次查询token'),
}

model ListFunctionAsyncInvokeConfigsResponseBody = {
  configs?: [ 
    {
      createdTime?: string(name='createdTime', description='创建时间'),
      destinationConfig?: DestinationConfig(name='destinationConfig'),
      function?: string(name='function', description='函数名称'),
      lastModifiedTime?: string(name='lastModifiedTime', description='最后更改时间'),
      maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', description='消息最大存活时长'),
      maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', description='异步调用失败后的最大重试次数'),
      qualifier?: string(name='qualifier', description='限定符'),
      service?: string(name='service', description='服务名称'),
      statefulInvocation?: boolean(name='statefulInvocation'),
    }
  ](name='configs', description='异步配置列表'),
  nextToken?: string(name='nextToken', description='下次查询token'),
}

model ListFunctionAsyncInvokeConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFunctionAsyncInvokeConfigsResponseBody(name='body'),
}

async function listFunctionAsyncInvokeConfigs(serviceName: string, functionName: string, request: ListFunctionAsyncInvokeConfigsRequest): ListFunctionAsyncInvokeConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionAsyncInvokeConfigsWithOptions(serviceName, functionName, request, headers, runtime);
}

async function listFunctionAsyncInvokeConfigsWithOptions(serviceName: string, functionName: string, request: ListFunctionAsyncInvokeConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionAsyncInvokeConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query.limit = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query.nextToken = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListFunctionAsyncInvokeConfigs', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/async-invoke-configs`, 'json', req, runtime);
}

model ListFunctionsRequest {
  qualifier?: string(name='qualifier', description='service版本, 可以是versionId或者aliasName'),
  limit?: int32(name='limit', description='限定此次返回资源的数量。如果不设定，默认返回20，最大不能超过100。返回结果可能小于指定的数量，但不会多于指定的数量'),
  nextToken?: string(name='nextToken', description='用来返回更多结果。第一次查询不需要提供这个参数，后续查询的token从返回结果中获取'),
  prefix?: string(name='prefix', description='限定返回的资源名称必须以prefix作为前缀'),
  startKey?: string(name='startKey', description='设定结果从startKey之后（包括startKey）按字母排序的第一个开始返回'),
}

model ListFunctionsResponseBody = {
  functions?: [ 
    {
      codeChecksum?: string(name='codeChecksum', description='function code包的CRC64值'),
      codeSize?: long(name='codeSize', description='系统返回的function的code包大小，单位为byte Example : 1024'),
      createdTime?: string(name='createdTime', description='function创建时间'),
      customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
      description?: string(name='description', description='函数描述'),
      environmentVariables?: map[string]string(name='environmentVariables', description='为函数设置的环境变量，可以在函数中获取环境变量的值'),
      functionId?: string(name='functionId', description='系统为每个function生成的唯一ID'),
      functionName?: string(name='functionName', description='函数名称'),
      handler?: string(name='handler', description='function的执行入口'),
      lastModifiedTime?: string(name='lastModifiedTime', description='function上次修改时间'),
      memorySize?: int32(name='memorySize', description='function设置的内存大小，单位为MB'),
      runtime?: string(name='runtime', description='function运行的语言环境，目前支持nodejs6, nodejs8, python2.7, python3, java8'),
      timeout?: int32(name='timeout', description='运行的超时时间，单位为秒'),
      initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
      initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
      caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
      instanceConcurrency?: int32(name='instanceConcurrency'),
      instanceType?: string(name='instanceType'),
      layers?: [ string ](name='layers'),
      instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
    }
  ](name='functions', description='函数列表'),
  nextToken?: string(name='nextToken', description='用来返回更多的查询结果。如果这个值没有返回，则说明没有更多结果'),
}

model ListFunctionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFunctionsResponseBody(name='body'),
}

async function listFunctions(serviceName: string, request: ListFunctionsRequest): ListFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFunctionsWithOptions(serviceName, request, headers, runtime);
}

async function listFunctionsWithOptions(serviceName: string, request: ListFunctionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFunctionsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }
  if (!Util.isUnset(request.limit)) {
    query.limit = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query.nextToken = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query.prefix = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query.startKey = request.startKey;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListFunctions', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}/functions`, 'json', req, runtime);
}

model ListLayersRequest {
  prefix?: string(name='prefix', description='层名称前缀'),
  startKey?: string(name='startKey', description='起始层名称'),
  nextToken?: string(name='nextToken', description='下一个层名称'),
  limit?: int32(name='limit', description='最大返回条目数'),
}

model ListLayersResponseBody = {
  layers?: [
    Layer
  ](name='layers', description='层列表'),
  nextToken?: string(name='nextToken', description='剩余列表起始层名'),
}

model ListLayersResponse = {
  headers: map[string]string(name='headers'),
  body: ListLayersResponseBody(name='body'),
}

async function listLayers(request: ListLayersRequest): ListLayersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLayersWithOptions(request, headers, runtime);
}

async function listLayersWithOptions(request: ListLayersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLayersResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.prefix)) {
    query.prefix = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query.startKey = request.startKey;
  }
  if (!Util.isUnset(request.nextToken)) {
    query.nextToken = request.nextToken;
  }
  if (!Util.isUnset(request.limit)) {
    query.limit = request.limit;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListLayers', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/layers`, 'json', req, runtime);
}

model ListLayerVersionsRequest {
  startVersion?: int32(name='startVersion', description='起始版本'),
  limit?: int32(name='limit', description='本次读取的最大数据记录数量'),
}

model ListLayerVersionsResponseBody = {
  layers?: [
    Layer
  ](name='layers', description='层版本列表'),
  nextVersion?: int32(name='nextVersion', description='剩余列表起始版本号'),
}

model ListLayerVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListLayerVersionsResponseBody(name='body'),
}

async function listLayerVersions(layerName: string, request: ListLayerVersionsRequest): ListLayerVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLayerVersionsWithOptions(layerName, request, headers, runtime);
}

async function listLayerVersionsWithOptions(layerName: string, request: ListLayerVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLayerVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.startVersion)) {
    query.startVersion = request.startVersion;
  }
  if (!Util.isUnset(request.limit)) {
    query.limit = request.limit;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListLayerVersions', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/layers/${layerName}/versions`, 'json', req, runtime);
}

model ListOnDemandConfigsRequest {
  prefix?: string(name='prefix', description='限定返回的资源名称，名称必须以Prefix作为前缀，例如Prefix是a，则返回的资源名均是以a开始的。'),
  startKey?: string(name='startKey', description='设定结果从startKey之后（包括startKey）按字母排序的第一个开始返回。'),
  nextToken?: string(name='nextToken', description='用来返回更多结果。第一次查询不需要提供这个参数，后续查询的Token从返回结果中获取。'),
  limit?: int32(name='limit', description='限定此次返回资源的数量。如果不设定，默认返回20，最大不能超过100。返回结果可以小于指定的数量，但不会多于指定的数量。'),
}

model ListOnDemandConfigsResponseBody = {
  configs?: [
    OnDemandConfig
  ](name='configs', description='预留实例配置'),
  nextToken?: string(name='nextToken', description='用来返回更多的查询结果。如果这个值没有返回，则说明没有更多结果。'),
}

model ListOnDemandConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListOnDemandConfigsResponseBody(name='body'),
}

async function listOnDemandConfigs(request: ListOnDemandConfigsRequest): ListOnDemandConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listOnDemandConfigsWithOptions(request, headers, runtime);
}

async function listOnDemandConfigsWithOptions(request: ListOnDemandConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListOnDemandConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.prefix)) {
    query.prefix = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query.startKey = request.startKey;
  }
  if (!Util.isUnset(request.nextToken)) {
    query.nextToken = request.nextToken;
  }
  if (!Util.isUnset(request.limit)) {
    query.limit = request.limit;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListOnDemandConfigs', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/on-demand-configs`, 'json', req, runtime);
}

model ListProvisionConfigsRequest {
  limit?: long(name='limit', description='限定此次返回资源的数量。如果不设定，默认返回20，最大不能超过100。返回结果可能小于指定的数量，但不会多于指定的数量	'),
  nextToken?: string(name='nextToken', description='用来返回更多结果。第一次查询不需要提供这个参数，后续查询的token从返回结果中获取'),
  serviceName?: string(name='serviceName', description='限定返回的资源名称必须属于该service'),
  qualifier?: string(name='qualifier', description='限定返回的资源名称必须属于该qualifier。qualifier只能是aliasName，且必须和serviceName共同使用'),
}

model ListProvisionConfigsResponseBody = {
  nextToken?: string(name='nextToken', description='下次查询的起始token	'),
  provisionConfigs?: [ 
    {
      resource?: string(name='resource', description='资源描述'),
      target?: long(name='target', description='目标资源个数'),
      current?: long(name='current', description='实际资源个数'),
      scheduledActions?: [
        ScheduledActions
      ](name='scheduledActions', description='定时策略配置'),
      targetTrackingPolicies?: [
        TargetTrackingPolicies
      ](name='targetTrackingPolicies', description='指标追踪伸缩策略配置'),
    }
  ](name='provisionConfigs', description='预留实例列表'),
}

model ListProvisionConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProvisionConfigsResponseBody(name='body'),
}

async function listProvisionConfigs(request: ListProvisionConfigsRequest): ListProvisionConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProvisionConfigsWithOptions(request, headers, runtime);
}

async function listProvisionConfigsWithOptions(request: ListProvisionConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProvisionConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query.limit = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query.nextToken = request.nextToken;
  }
  if (!Util.isUnset(request.serviceName)) {
    query.serviceName = request.serviceName;
  }
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListProvisionConfigs', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/provision-configs`, 'json', req, runtime);
}

model ListReservedCapacitiesRequest {
  nextToken?: string(name='nextToken'),
  limit?: string(name='limit'),
}

model ListReservedCapacitiesResponseBody = {
  reservedCapacities?: [
    OpenReservedCapacity
  ](name='reservedCapacities', description='reservedCapacities'),
  nextToken?: string(name='nextToken', description='nextToken'),
}

model ListReservedCapacitiesResponse = {
  headers: map[string]string(name='headers'),
  body: ListReservedCapacitiesResponseBody(name='body'),
}

async function listReservedCapacities(request: ListReservedCapacitiesRequest): ListReservedCapacitiesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listReservedCapacitiesWithOptions(request, headers, runtime);
}

async function listReservedCapacitiesWithOptions(request: ListReservedCapacitiesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListReservedCapacitiesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.nextToken)) {
    query.nextToken = request.nextToken;
  }
  if (!Util.isUnset(request.limit)) {
    query.limit = request.limit;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListReservedCapacities', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/reservedCapacities`, 'json', req, runtime);
}

model ListServicesRequest {
  limit?: int32(name='limit', description='最多返回个数'),
  nextToken?: string(name='nextToken', description='下次查询token'),
  prefix?: string(name='prefix', description='前缀'),
  startKey?: string(name='startKey', description='起始key'),
}

model ListServicesResponseBody = {
  nextToken?: string(name='nextToken', description='下次查询token'),
  services?: [ 
    {
      createdTime?: string(name='createdTime', description='创建时间'),
      description?: string(name='description', description='服务描述'),
      internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
      lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
      logConfig?: LogConfig(name='logConfig'),
      nasConfig?: NASConfig(name='nasConfig'),
      role?: string(name='role', description='服务角色'),
      serviceId?: string(name='serviceId', description='服务ID'),
      serviceName?: string(name='serviceName', description='服务信息'),
      vpcConfig?: VPCConfig(name='vpcConfig'),
      tracingConfig?: TracingConfig(name='tracingConfig'),
    }
  ](name='services', description='服务列表'),
}

model ListServicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListServicesResponseBody(name='body'),
}

async function listServices(request: ListServicesRequest): ListServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServicesWithOptions(request, headers, runtime);
}

async function listServicesWithOptions(request: ListServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServicesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query.limit = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query.nextToken = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query.prefix = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query.startKey = request.startKey;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListServices', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services`, 'json', req, runtime);
}

model ListServiceVersionsRequest {
  limit?: int32(name='limit', description='最多返回个数'),
  nextToken?: string(name='nextToken', description='下次查询token'),
  startKey?: string(name='startKey', description='起始key'),
  direction?: string(name='direction', description='排序方向'),
}

model ListServiceVersionsResponseBody = {
  direction?: string(name='direction', description='排序方向'),
  nextToken?: string(name='nextToken', description='下次查询token'),
  versions?: [ 
    {
      createdTime?: string(name='createdTime', description='创建时间'),
      description?: string(name='description', description='版本描述'),
      lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
      versionId?: string(name='versionId', description='版本ID'),
    }
  ](name='versions', description='版本列表'),
}

model ListServiceVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListServiceVersionsResponseBody(name='body'),
}

async function listServiceVersions(serviceName: string, request: ListServiceVersionsRequest): ListServiceVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceVersionsWithOptions(serviceName, request, headers, runtime);
}

async function listServiceVersionsWithOptions(serviceName: string, request: ListServiceVersionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query.limit = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query.nextToken = request.nextToken;
  }
  if (!Util.isUnset(request.startKey)) {
    query.startKey = request.startKey;
  }
  if (!Util.isUnset(request.direction)) {
    query.direction = request.direction;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListServiceVersions', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}/versions`, 'json', req, runtime);
}

model ListStatefulAsyncInvocationsRequest {
  qualifier?: string(name='qualifier'),
  status?: string(name='status'),
  nextToken?: string(name='nextToken'),
  limit?: int32(name='limit'),
  startedTimeBegin?: long(name='startedTimeBegin'),
  startedTimeEnd?: long(name='startedTimeEnd'),
  sortOrderByTime?: string(name='sortOrderByTime'),
  invocationIdPrefix?: string(name='invocationIdPrefix'),
  includePayload?: boolean(name='includePayload'),
}

model ListStatefulAsyncInvocationsResponseBody = {
  nextToken?: string(name='nextToken'),
  invocations?: [
    StatefulAsyncInvocation
  ](name='invocations'),
}

model ListStatefulAsyncInvocationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListStatefulAsyncInvocationsResponseBody(name='body'),
}

async function listStatefulAsyncInvocations(serviceName: string, functionName: string, request: ListStatefulAsyncInvocationsRequest): ListStatefulAsyncInvocationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listStatefulAsyncInvocationsWithOptions(serviceName, functionName, request, headers, runtime);
}

async function listStatefulAsyncInvocationsWithOptions(serviceName: string, functionName: string, request: ListStatefulAsyncInvocationsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListStatefulAsyncInvocationsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }
  if (!Util.isUnset(request.status)) {
    query.status = request.status;
  }
  if (!Util.isUnset(request.nextToken)) {
    query.nextToken = request.nextToken;
  }
  if (!Util.isUnset(request.limit)) {
    query.limit = request.limit;
  }
  if (!Util.isUnset(request.startedTimeBegin)) {
    query.startedTimeBegin = request.startedTimeBegin;
  }
  if (!Util.isUnset(request.startedTimeEnd)) {
    query.startedTimeEnd = request.startedTimeEnd;
  }
  if (!Util.isUnset(request.sortOrderByTime)) {
    query.sortOrderByTime = request.sortOrderByTime;
  }
  if (!Util.isUnset(request.invocationIdPrefix)) {
    query.invocationIdPrefix = request.invocationIdPrefix;
  }
  if (!Util.isUnset(request.includePayload)) {
    query.includePayload = request.includePayload;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListStatefulAsyncInvocations', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/stateful-async-invocations`, 'json', req, runtime);
}

model ListTaggedResourcesRequest {
  nextToken?: string(name='nextToken'),
  limit?: int32(name='limit'),
}

model ListTaggedResourcesResponseBody = {
  nextToken?: string(name='nextToken'),
  resources?: [
    Resource
  ](name='resources'),
}

model ListTaggedResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTaggedResourcesResponseBody(name='body'),
}

async function listTaggedResources(request: ListTaggedResourcesRequest): ListTaggedResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTaggedResourcesWithOptions(request, headers, runtime);
}

async function listTaggedResourcesWithOptions(request: ListTaggedResourcesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTaggedResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.nextToken)) {
    query.nextToken = request.nextToken;
  }
  if (!Util.isUnset(request.limit)) {
    query.limit = request.limit;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListTaggedResources', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/tags`, 'json', req, runtime);
}

model ListTriggersRequest {
  limit?: int32(name='limit', description='限定此次返回资源的数量。如果不设定，默认返回20，最大不能超过100。返回结果可能小于指定的数量，但不会多于指定的数量'),
  nextToken?: int32(name='nextToken', description='用来返回更多结果。第一次查询不需要提供这个参数，后续查询的token从返回结果中获取'),
  prefix?: string(name='prefix', description='限定返回的资源名称必须以prefix作为前缀'),
  startKey?: string(name='startKey', description='设定结果从startKey之后（包括startKey）按字母排序的第一个开始返回'),
}

model ListTriggersResponseBody = {
  nextToken?: string(name='nextToken', description='用来返回更多的查询结果。如果这个值没有返回，则说明没有更多结果'),
  triggers?: [ 
    {
      createdTime?: string(name='createdTime', description='创建时间'),
      invocationRole?: string(name='invocationRole', description='调用函数使用的RAM角色的ARN'),
      lastModifiedTime?: string(name='lastModifiedTime', description='上次修改时间'),
      qualifier?: string(name='qualifier', description='service版本'),
      sourceArn?: string(name='sourceArn', description='event source的Aliyun Resource Name（ARN'),
      triggerConfig?: string(name='triggerConfig', description='trigger配置对象'),
      triggerName?: string(name='triggerName', description='trigger名称'),
      triggerType?: string(name='triggerType', description='trigger类型，如 oss, log, tablestore, timer, http, cdn_events, mns_topic'),
      description?: string(name='description'),
      triggerId?: string(name='triggerId'),
    }
  ](name='triggers', description='Trigger列表'),
}

model ListTriggersResponse = {
  headers: map[string]string(name='headers'),
  body: ListTriggersResponseBody(name='body'),
}

async function listTriggers(serviceName: string, functionName: string, request: ListTriggersRequest): ListTriggersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listTriggersWithOptions(serviceName, functionName, request, headers, runtime);
}

async function listTriggersWithOptions(serviceName: string, functionName: string, request: ListTriggersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListTriggersResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query.limit = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query.nextToken = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query.prefix = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query.startKey = request.startKey;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListTriggers', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/triggers`, 'json', req, runtime);
}

model ListVpcBindingsResponseBody = {
  vpcIds?: [ string ](name='vpcIds'),
}

model ListVpcBindingsResponse = {
  headers: map[string]string(name='headers'),
  body: ListVpcBindingsResponseBody(name='body'),
}

async function listVpcBindings(serviceName: string): ListVpcBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listVpcBindingsWithOptions(serviceName, headers, runtime);
}

async function listVpcBindingsWithOptions(serviceName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListVpcBindingsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('ListVpcBindings', '2021-04-06', 'HTTPS', 'GET', 'AK', `/2021-04-06/services/${serviceName}/bindings`, 'json', req, runtime);
}

model PermanentDeleteLayerVersionResponseBody = {
  requestId?: string(name='requestId', description='Id of the request'),
}

model PermanentDeleteLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  body: PermanentDeleteLayerVersionResponseBody(name='body'),
}

async function permanentDeleteLayerVersion(userID: string, layerName: string, version: string): PermanentDeleteLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return permanentDeleteLayerVersionWithOptions(userID, layerName, version, headers, runtime);
}

async function permanentDeleteLayerVersionWithOptions(userID: string, layerName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): PermanentDeleteLayerVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('PermanentDeleteLayerVersion', '2021-04-06', 'HTTPS', 'DELETE', 'AK', `/2021-04-06/adminlayers/${userID}/${layerName}/versions/${version}`, 'json', req, runtime);
}

model PublishLayerAsPublicResponseBody = {
  requestId?: string(name='requestId', description='Id of the request'),
}

model PublishLayerAsPublicResponse = {
  headers: map[string]string(name='headers'),
  body: PublishLayerAsPublicResponseBody(name='body'),
}

async function publishLayerAsPublic(layerName: string, version: string): PublishLayerAsPublicResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return publishLayerAsPublicWithOptions(layerName, version, headers, runtime);
}

async function publishLayerAsPublicWithOptions(layerName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): PublishLayerAsPublicResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  return doROARequest('PublishLayerAsPublic', '2021-04-06', 'HTTPS', 'POST', 'AK', `/2021-04-06/layers/${layerName}/versions/${version}`, 'json', req, runtime);
}

model PublishServiceVersionHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
}

model PublishServiceVersionRequest {
  description?: string(name='description', description='版本描述'),
}

model PublishServiceVersionResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='版本描述'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  versionId?: string(name='versionId', description='版本ID'),
}

model PublishServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  body: PublishServiceVersionResponseBody(name='body'),
}

async function publishServiceVersion(serviceName: string, request: PublishServiceVersionRequest): PublishServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PublishServiceVersionHeaders{};
  return publishServiceVersionWithOptions(serviceName, request, headers, runtime);
}

async function publishServiceVersionWithOptions(serviceName: string, request: PublishServiceVersionRequest, headers: PublishServiceVersionHeaders, runtime: Util.RuntimeOptions): PublishServiceVersionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders.If-Match = headers.ifMatch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('PublishServiceVersion', '2021-04-06', 'HTTPS', 'POST', 'AK', `/2021-04-06/services/${serviceName}/versions`, 'json', req, runtime);
}

model PutFunctionAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier', description='别名或版本'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', description='消息最大存活时长'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', description='异步调用失败后的最大重试次数'),
  statefulInvocation?: boolean(name='statefulInvocation'),
}

model PutFunctionAsyncInvokeConfigResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  function?: string(name='function', description='函数名称'),
  lastModifiedTime?: string(name='lastModifiedTime', description='最后更改时间'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', description='消息最大存活时长'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', description='异步调用失败后的最大重试次数'),
  qualifier?: string(name='qualifier', description='限定符'),
  service?: string(name='service', description='服务名称'),
  statefulInvocation?: boolean(name='statefulInvocation'),
}

model PutFunctionAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  body: PutFunctionAsyncInvokeConfigResponseBody(name='body'),
}

async function putFunctionAsyncInvokeConfig(serviceName: string, functionName: string, request: PutFunctionAsyncInvokeConfigRequest): PutFunctionAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putFunctionAsyncInvokeConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function putFunctionAsyncInvokeConfigWithOptions(serviceName: string, functionName: string, request: PutFunctionAsyncInvokeConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutFunctionAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.destinationConfig)) {
    body.destinationConfig = request.destinationConfig;
  }
  if (!Util.isUnset(request.maxAsyncEventAgeInSeconds)) {
    body.maxAsyncEventAgeInSeconds = request.maxAsyncEventAgeInSeconds;
  }
  if (!Util.isUnset(request.maxAsyncRetryAttempts)) {
    body.maxAsyncRetryAttempts = request.maxAsyncRetryAttempts;
  }
  if (!Util.isUnset(request.statefulInvocation)) {
    body.statefulInvocation = request.statefulInvocation;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('PutFunctionAsyncInvokeConfig', '2021-04-06', 'HTTPS', 'PUT', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/async-invoke-config`, 'json', req, runtime);
}

model PutFunctionOnDemandConfigHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
}

model PutFunctionOnDemandConfigRequest {
  qualifier?: string(name='qualifier'),
  maximumInstanceCount?: long(name='maximumInstanceCount'),
}

model PutFunctionOnDemandConfigResponseBody = {
  resource?: string(name='resource'),
  maximumInstanceCount?: long(name='maximumInstanceCount'),
}

model PutFunctionOnDemandConfigResponse = {
  headers: map[string]string(name='headers'),
  body: PutFunctionOnDemandConfigResponseBody(name='body'),
}

async function putFunctionOnDemandConfig(serviceName: string, functionName: string, request: PutFunctionOnDemandConfigRequest): PutFunctionOnDemandConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PutFunctionOnDemandConfigHeaders{};
  return putFunctionOnDemandConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function putFunctionOnDemandConfigWithOptions(serviceName: string, functionName: string, request: PutFunctionOnDemandConfigRequest, headers: PutFunctionOnDemandConfigHeaders, runtime: Util.RuntimeOptions): PutFunctionOnDemandConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.maximumInstanceCount)) {
    body.maximumInstanceCount = request.maximumInstanceCount;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders.If-Match = headers.ifMatch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('PutFunctionOnDemandConfig', '2021-04-06', 'HTTPS', 'PUT', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/on-demand-config`, 'json', req, runtime);
}

model PutProvisionConfigRequest {
  qualifier?: string(name='qualifier', description='别名名称'),
  target?: long(name='target', description='预留的目标资源个数'),
  scheduledActions?: [
    ScheduledActions
  ](name='scheduledActions', description='定时策略配置'),
  targetTrackingPolicies?: [
    TargetTrackingPolicies
  ](name='targetTrackingPolicies', description='指标追踪伸缩策略配置'),
}

model PutProvisionConfigResponseBody = {
  resource?: string(name='resource', description='资源描述'),
  target?: long(name='target', description='目标资源个数'),
  current?: long(name='current', description='实际资源个数'),
  scheduledActions?: [
    ScheduledActions
  ](name='scheduledActions', description='定时策略配置'),
  targetTrackingPolicies?: [
    TargetTrackingPolicies
  ](name='targetTrackingPolicies', description='指标追踪伸缩策略配置'),
}

model PutProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  body: PutProvisionConfigResponseBody(name='body'),
}

async function putProvisionConfig(serviceName: string, functionName: string, request: PutProvisionConfigRequest): PutProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return putProvisionConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function putProvisionConfigWithOptions(serviceName: string, functionName: string, request: PutProvisionConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PutProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.target)) {
    body.target = request.target;
  }
  if (!Util.isUnset(request.scheduledActions)) {
    body.scheduledActions = request.scheduledActions;
  }
  if (!Util.isUnset(request.targetTrackingPolicies)) {
    body.targetTrackingPolicies = request.targetTrackingPolicies;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('PutProvisionConfig', '2021-04-06', 'HTTPS', 'PUT', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/provision-config`, 'json', req, runtime);
}

model StopStatefulAsyncInvocationRequest {
  qualifier?: string(name='qualifier'),
}

model StopStatefulAsyncInvocationResponse = {
  headers: map[string]string(name='headers'),
}

async function stopStatefulAsyncInvocation(serviceName: string, functionName: string, invocationId: string, request: StopStatefulAsyncInvocationRequest): StopStatefulAsyncInvocationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopStatefulAsyncInvocationWithOptions(serviceName, functionName, invocationId, request, headers, runtime);
}

async function stopStatefulAsyncInvocationWithOptions(serviceName: string, functionName: string, invocationId: string, request: StopStatefulAsyncInvocationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): StopStatefulAsyncInvocationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query.qualifier = request.qualifier;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('StopStatefulAsyncInvocation', '2021-04-06', 'HTTPS', 'PUT', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/stateful-async-invocations/${invocationId}`, 'none', req, runtime);
}

model TagResourceRequest {
  resourceArn?: string(name='resourceArn'),
  tags?: map[string]string(name='tags'),
}

model TagResourceResponse = {
  headers: map[string]string(name='headers'),
}

async function tagResource(request: TagResourceRequest): TagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return tagResourceWithOptions(request, headers, runtime);
}

async function tagResourceWithOptions(request: TagResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TagResourceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.resourceArn)) {
    body.resourceArn = request.resourceArn;
  }
  if (!Util.isUnset(request.tags)) {
    body.tags = request.tags;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('TagResource', '2021-04-06', 'HTTPS', 'POST', 'AK', `/2021-04-06/tag`, 'none', req, runtime);
}

model UntagResourceRequest {
  resourceArn?: string(name='resourceArn', description='目前只能给 top level 资源 service 进行标签的相关操作, ARN 可以是类似 services/foo 或者 acs:fc:cn-shanghai:123456789:services/foo'),
  tagKeys	?: [ string ](name='tagKeys	', description='tag key 值列表， 最大为 20，当 all=false， length 至少为 1. 当 length 大于 1 时， 可以忽略 all 值'),
  all?: boolean(name='all', description='删除所有 tag，默认值为 false'),
}

model UntagResourceResponse = {
  headers: map[string]string(name='headers'),
}

async function untagResource(request: UntagResourceRequest): UntagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return untagResourceWithOptions(request, headers, runtime);
}

async function untagResourceWithOptions(request: UntagResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UntagResourceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.resourceArn)) {
    body.resourceArn = request.resourceArn;
  }
  if (!Util.isUnset(request.tagKeys	)) {
    body.tagKeys	 = request.tagKeys	;
  }
  if (!Util.isUnset(request.all)) {
    body.all = request.all;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UntagResource', '2021-04-06', 'HTTPS', 'DELETE', 'AK', `/2021-04-06/tag`, 'none', req, runtime);
}

model UpdateAliasHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
}

model UpdateAliasRequest {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
  description?: string(name='description', description='别名描述'),
  versionId?: string(name='versionId', description='版本ID'),
}

model UpdateAliasResponseBody = {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
  aliasName?: string(name='aliasName', description='别名名称'),
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='别名描述'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  versionId?: string(name='versionId', description='版本ID'),
}

model UpdateAliasResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAliasResponseBody(name='body'),
}

async function updateAlias(serviceName: string, aliasName: string, request: UpdateAliasRequest): UpdateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UpdateAliasHeaders{};
  return updateAliasWithOptions(serviceName, aliasName, request, headers, runtime);
}

async function updateAliasWithOptions(serviceName: string, aliasName: string, request: UpdateAliasRequest, headers: UpdateAliasHeaders, runtime: Util.RuntimeOptions): UpdateAliasResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.additionalVersionWeight)) {
    body.additionalVersionWeight = request.additionalVersionWeight;
  }
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }
  if (!Util.isUnset(request.versionId)) {
    body.versionId = request.versionId;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders.If-Match = headers.ifMatch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateAlias', '2021-04-06', 'HTTPS', 'PUT', 'AK', `/2021-04-06/services/${serviceName}/aliases/${aliasName}`, 'json', req, runtime);
}

model UpdateCustomDomainRequest {
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  certConfig?: CertConfig(name='certConfig'),
}

model UpdateCustomDomainResponseBody = {
  domainName?: string(name='domainName'),
  accountId?: string(name='accountId'),
  protocol?: string(name='protocol'),
  apiVersion?: string(name='apiVersion'),
  createdTime?: string(name='createdTime'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  certConfig?: CertConfig(name='certConfig'),
  routeConfig?: RouteConfig(name='routeConfig'),
}

model UpdateCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateCustomDomainResponseBody(name='body'),
}

async function updateCustomDomain(domainName: string, request: UpdateCustomDomainRequest): UpdateCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateCustomDomainWithOptions(domainName, request, headers, runtime);
}

async function updateCustomDomainWithOptions(domainName: string, request: UpdateCustomDomainRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateCustomDomainResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.protocol)) {
    body.protocol = request.protocol;
  }
  if (!Util.isUnset(request.routeConfig)) {
    body.routeConfig = request.routeConfig;
  }
  if (!Util.isUnset(request.certConfig)) {
    body.certConfig = request.certConfig;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateCustomDomain', '2021-04-06', 'HTTPS', 'PUT', 'AK', `/2021-04-06/custom-domains/${domainName}`, 'json', req, runtime);
}

model UpdateFunctionHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应'),
  xFcCodeChecksum?: string(name='x-fc-code-checksum', description='代码校验'),
}

model UpdateFunctionRequest {
  code?: Code(name='code'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  layers?: [ string ](name='layers'),
  description?: string(name='description', description='函数描述'),
  environmentVariables?: map[string]string(name='environmentVariables', description='为函数设置的环境变量，可以在函数中获取环境变量的值'),
  handler?: string(name='handler', description='function执行的入口，具体格式和语言相关'),
  memorySize?: int32(name='memorySize', description='function的内存规格，单位为MB，为64MB的倍数'),
  runtime?: string(name='runtime', description='runtime'),
  timeout?: int32(name='timeout', description='function运行的超时时间，单位为秒，最小1秒，默认3秒。function超过这个时间后会被终止执行'),
  initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
  initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
  caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
  instanceConcurrency?: int32(name='InstanceConcurrency'),
  instanceType?: string(name='instanceType'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
}

model UpdateFunctionResponseBody = {
  codeChecksum?: string(name='codeChecksum', description='function code包的CRC64值'),
  codeSize?: long(name='codeSize', description='系统返回的function的code包大小，单位为byte Example : 1024'),
  createdTime?: string(name='createdTime', description='function创建时间'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  layers?: [ string ](name='layers'),
  description?: string(name='description', description='函数描述'),
  environmentVariables?: map[string]string(name='environmentVariables', description='为函数设置的环境变量，可以在函数中获取环境变量的值'),
  functionId?: string(name='functionId', description='系统为每个function生成的唯一ID'),
  functionName?: string(name='functionName', description='函数名称'),
  handler?: string(name='handler', description='function的执行入口'),
  lastModifiedTime?: string(name='lastModifiedTime', description='function上次修改时间'),
  memorySize?: int32(name='memorySize', description='function设置的内存大小，单位为MB'),
  runtime?: string(name='runtime', description='function运行的语言环境，目前支持nodejs6, nodejs8, python2.7, python3, java8'),
  timeout?: int32(name='timeout', description='运行的超时时间，单位为秒'),
  initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
  initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
  caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
  instanceType?: string(name='instanceType'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
}

model UpdateFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFunctionResponseBody(name='body'),
}

async function updateFunction(serviceName: string, functionName: string, request: UpdateFunctionRequest): UpdateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UpdateFunctionHeaders{};
  return updateFunctionWithOptions(serviceName, functionName, request, headers, runtime);
}

async function updateFunctionWithOptions(serviceName: string, functionName: string, request: UpdateFunctionRequest, headers: UpdateFunctionHeaders, runtime: Util.RuntimeOptions): UpdateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.code)) {
    body.code = request.code;
  }
  if (!Util.isUnset(request.customContainerConfig)) {
    body.customContainerConfig = request.customContainerConfig;
  }
  if (!Util.isUnset(request.layers)) {
    body.layers = request.layers;
  }
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }
  if (!Util.isUnset(request.environmentVariables)) {
    body.environmentVariables = request.environmentVariables;
  }
  if (!Util.isUnset(request.handler)) {
    body.handler = request.handler;
  }
  if (!Util.isUnset(request.memorySize)) {
    body.memorySize = request.memorySize;
  }
  if (!Util.isUnset(request.runtime)) {
    body.runtime = request.runtime;
  }
  if (!Util.isUnset(request.timeout)) {
    body.timeout = request.timeout;
  }
  if (!Util.isUnset(request.initializationTimeout)) {
    body.initializationTimeout = request.initializationTimeout;
  }
  if (!Util.isUnset(request.initializer)) {
    body.initializer = request.initializer;
  }
  if (!Util.isUnset(request.caPort)) {
    body.caPort = request.caPort;
  }
  if (!Util.isUnset(request.instanceConcurrency)) {
    body.InstanceConcurrency = request.instanceConcurrency;
  }
  if (!Util.isUnset(request.instanceType)) {
    body.instanceType = request.instanceType;
  }
  if (!Util.isUnset(request.instanceLifecycleConfig)) {
    body.instanceLifecycleConfig = request.instanceLifecycleConfig;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders.If-Match = headers.ifMatch;
  }
  if (!Util.isUnset(headers.xFcCodeChecksum)) {
    realHeaders.x-fc-code-checksum = headers.xFcCodeChecksum;
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateFunction', '2021-04-06', 'HTTPS', 'PUT', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}`, 'json', req, runtime);
}

model UpdateServiceHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应'),
}

model UpdateServiceRequest {
  description?: string(name='description', description='服务描述'),
  internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  role?: string(name='role', description='服务角色'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
}

model UpdateServiceResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='服务描述'),
  internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  role?: string(name='role', description='服务角色'),
  serviceId?: string(name='serviceId', description='服务ID'),
  serviceName?: string(name='serviceName', description='服务名称'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
}

model UpdateServiceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateServiceResponseBody(name='body'),
}

async function updateService(serviceName: string, request: UpdateServiceRequest): UpdateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UpdateServiceHeaders{};
  return updateServiceWithOptions(serviceName, request, headers, runtime);
}

async function updateServiceWithOptions(serviceName: string, request: UpdateServiceRequest, headers: UpdateServiceHeaders, runtime: Util.RuntimeOptions): UpdateServiceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }
  if (!Util.isUnset(request.internetAccess)) {
    body.internetAccess = request.internetAccess;
  }
  if (!Util.isUnset(request.logConfig)) {
    body.logConfig = request.logConfig;
  }
  if (!Util.isUnset(request.nasConfig)) {
    body.nasConfig = request.nasConfig;
  }
  if (!Util.isUnset(request.role)) {
    body.role = request.role;
  }
  if (!Util.isUnset(request.vpcConfig)) {
    body.vpcConfig = request.vpcConfig;
  }
  if (!Util.isUnset(request.tracingConfig)) {
    body.tracingConfig = request.tracingConfig;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders.If-Match = headers.ifMatch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateService', '2021-04-06', 'HTTPS', 'PUT', 'AK', `/2021-04-06/services/${serviceName}`, 'json', req, runtime);
}

model UpdateTriggerHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应'),
}

model UpdateTriggerRequest {
  invocationRole?: string(name='invocationRole', description='event source，如OSS，使用该role去invoke function'),
  qualifier?: string(name='qualifier', description='service版本'),
  triggerConfig?: map[string]string(name='triggerConfig', description='trigger配置，针对不同的trigger类型，trigger配置会有所不同	'),
  description?: string(name='description'),
}

model UpdateTriggerResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  invocationRole?: string(name='invocationRole', description='调用函数使用的RAM角色的ARN'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次修改时间'),
  qualifier?: string(name='qualifier', description='service版本'),
  sourceArn?: string(name='sourceArn', description='event source的Aliyun Resource Name（ARN'),
  triggerConfig?: string(name='triggerConfig', description='trigger配置对象'),
  triggerName?: string(name='triggerName', description='trigger名称'),
  triggerType?: string(name='triggerType', description='trigger类型，如 oss, log, tablestore, timer, http, cdn_events, mns_topic'),
  description?: string(name='description'),
  triggerId?: string(name='triggerId'),
}

model UpdateTriggerResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTriggerResponseBody(name='body'),
}

async function updateTrigger(serviceName: string, functionName: string, triggerName: string, request: UpdateTriggerRequest): UpdateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UpdateTriggerHeaders{};
  return updateTriggerWithOptions(serviceName, functionName, triggerName, request, headers, runtime);
}

async function updateTriggerWithOptions(serviceName: string, functionName: string, triggerName: string, request: UpdateTriggerRequest, headers: UpdateTriggerHeaders, runtime: Util.RuntimeOptions): UpdateTriggerResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.invocationRole)) {
    body.invocationRole = request.invocationRole;
  }
  if (!Util.isUnset(request.qualifier)) {
    body.qualifier = request.qualifier;
  }
  if (!Util.isUnset(request.triggerConfig)) {
    body.triggerConfig = request.triggerConfig;
  }
  if (!Util.isUnset(request.description)) {
    body.description = request.description;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders.If-Match = headers.ifMatch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateTrigger', '2021-04-06', 'HTTPS', 'PUT', 'AK', `/2021-04-06/services/${serviceName}/functions/${functionName}/triggers/${triggerName}`, 'json', req, runtime);
}

