/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'account-id.ap-northeast-1.fc.aliyuncs.com',
    ap-south-1 = 'account-id.ap-south-1.fc.aliyuncs.com',
    ap-southeast-1 = 'account-id.ap-southeast-1.fc.aliyuncs.com',
    ap-southeast-2 = 'account-id.ap-southeast-2.fc.aliyuncs.com',
    ap-southeast-3 = 'account-id.ap-southeast-3.fc.aliyuncs.com',
    ap-southeast-5 = 'account-id.ap-southeast-5.fc.aliyuncs.com',
    cn-beijing = 'account-id.cn-beijing.fc.aliyuncs.com',
    cn-chengdu = 'account-id.cn-chengdu.fc.aliyuncs.com',
    cn-hangzhou = 'account-id.cn-hangzhou.fc.aliyuncs.com',
    cn-hangzhou-finance = 'account-id.cn-hangzhou-finance.fc.aliyuncs.com',
    cn-hongkong = 'account-id.cn-hongkong.fc.aliyuncs.com',
    cn-huhehaote = 'account-id.cn-huhehaote.fc.aliyuncs.com',
    cn-north-2-gov-1 = 'account-id.cn-north-2-gov-1.fc.aliyuncs.com',
    cn-qingdao = 'account-id.cn-qingdao.fc.aliyuncs.com',
    cn-shanghai = 'account-id.cn-shanghai.fc.aliyuncs.com',
    cn-shenzhen = 'account-id.cn-shenzhen.fc.aliyuncs.com',
    cn-zhangjiakou = 'account-id.cn-zhangjiakou.fc.aliyuncs.com',
    eu-central-1 = 'account-id.eu-central-1.fc.aliyuncs.com',
    eu-west-1 = 'account-id.eu-west-1.fc.aliyuncs.com',
    us-east-1 = 'account-id.us-east-1.fc.aliyuncs.com',
    us-west-1 = 'account-id.us-west-1.fc.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('fc-open', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AccelerationInfo {
  status?: string(name='status'),
}

model AsyncConfigMeta {
  functionName?: string(name='functionName'),
  qualifier?: string(name='qualifier'),
  serviceName?: string(name='serviceName'),
}

model AvailableAZ {
  availableAZs?: string(name='availableAZs'),
}

model CDNEventsTriggerConfig {
  eventName?: string(name='eventName'),
  eventVersion?: string(name='eventVersion'),
  filter?: map[string][ string ](name='filter'),
  notes?: string(name='notes'),
}

model CertConfig {
  certName?: string(name='certName'),
  certificate?: string(name='certificate'),
  privateKey?: string(name='privateKey'),
}

model Code {
  ossBucketName?: string(name='ossBucketName'),
  ossObjectName?: string(name='ossObjectName'),
  zipFile?: string(name='zipFile'),
}

model CustomContainerConfig {
  accelerationType?: string(name='accelerationType'),
  args?: string(name='args'),
  command?: string(name='command'),
  image?: string(name='image'),
  instanceID?: string(name='instanceID'),
  webServerMode?: boolean(name='webServerMode'),
}

model CustomContainerConfigInfo {
  accelerationInfo?: AccelerationInfo(name='accelerationInfo'),
  accelerationType?: string(name='accelerationType'),
  args?: string(name='args'),
  command?: string(name='command'),
  image?: string(name='image'),
  instanceID?: string(name='instanceID'),
  webServerMode?: boolean(name='webServerMode'),
}

model CustomDNS {
  dnsOptions?: [
    DNSOption
  ](name='dnsOptions'),
  nameServers?: [ string ](name='nameServers'),
  searches?: [ string ](name='searches'),
}

model CustomHealthCheckConfig {
  failureThreshold?: int32(name='failureThreshold'),
  httpGetUrl?: string(name='httpGetUrl'),
  initialDelaySeconds?: int32(name='initialDelaySeconds'),
  periodSeconds?: int32(name='periodSeconds'),
  successThreshold?: int32(name='successThreshold'),
  timeoutSeconds?: int32(name='timeoutSeconds'),
}

model CustomRuntimeConfig {
  args?: [ string ](name='args'),
  command?: [ string ](name='command'),
}

model DNSOption {
  name?: string(name='name'),
  value?: string(name='value'),
}

model Destination {
  destination?: string(name='destination'),
}

model DestinationConfig {
  onFailure?: Destination(name='onFailure'),
  onSuccess?: Destination(name='onSuccess'),
}

model Error {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
}

model ErrorInfo {
  errorMessage?: string(name='errorMessage'),
  stackTrace?: string(name='stackTrace'),
}

model EventBridgeTriggerConfig {
  asyncInvocationType?: boolean(name='asyncInvocationType'),
  eventRuleFilterPattern?: string(name='eventRuleFilterPattern'),
  eventSourceConfig?: EventSourceConfig(name='eventSourceConfig'),
  triggerEnable?: boolean(name='triggerEnable'),
}

model EventSourceConfig {
  eventSourceParameters?: EventSourceParameters(name='eventSourceParameters'),
  eventSourceType?: string(name='eventSourceType'),
}

model EventSourceParameters {
  sourceMNSParameters?: SourceMNSParameters(name='sourceMNSParameters'),
  sourceRabbitMQParameters?: SourceRabbitMQParameters(name='sourceRabbitMQParameters'),
  sourceRocketMQParameters?: SourceRocketMQParameters(name='sourceRocketMQParameters'),
}

model HTTPTriggerConfig {
  authType?: string(name='authType'),
  disableURLInternet?: boolean(name='disableURLInternet'),
  methods?: [ string ](name='methods'),
}

model InstanceLifecycleConfig {
  preFreeze?: LifecycleHook(name='preFreeze'),
  preStop?: LifecycleHook(name='preStop'),
}

model JaegerConfig {
  endpoint?: string(name='endpoint'),
}

model JobConfig {
  maxRetryTime?: long(name='maxRetryTime'),
  triggerInterval?: long(name='triggerInterval'),
}

model JobLogConfig {
  logstore?: string(name='logstore'),
  project?: string(name='project'),
}

model Layer {
  acl?: int32(name='acl'),
  arn?: string(name='arn'),
  arnV2?: string(name='arnV2'),
  code?: LayerCode(name='code'),
  codeChecksum?: string(name='codeChecksum'),
  codeSize?: long(name='codeSize'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  createTime?: string(name='createTime'),
  description?: string(name='description'),
  layerName?: string(name='layerName'),
  license?: string(name='license'),
  version?: int32(name='version'),
}

model LayerCode {
  location?: string(name='location'),
  repositoryType?: string(name='repositoryType'),
}

model LifecycleHook {
  handler?: string(name='handler'),
  timeout?: int32(name='timeout'),
}

model LogConfig {
  enableInstanceMetrics?: boolean(name='enableInstanceMetrics'),
  enableRequestMetrics?: boolean(name='enableRequestMetrics'),
  logBeginRule?: string(name='logBeginRule'),
  logstore?: string(name='logstore'),
  project?: string(name='project'),
}

model LogTriggerConfig {
  enable?: boolean(name='enable'),
  functionParameter?: map[string]string(name='functionParameter'),
  jobConfig?: JobConfig(name='jobConfig'),
  logConfig?: JobLogConfig(name='logConfig'),
  sourceConfig?: SourceConfig(name='sourceConfig'),
}

model MeteringConfig {
  logConfig?: LogConfig(name='logConfig'),
  payerId?: string(name='payerId'),
  role?: string(name='role'),
}

model MnsTopicTriggerConfig {
  filterTag?: string(name='filterTag'),
  notifyContentFormat?: string(name='notifyContentFormat'),
  notifyStrategy?: string(name='notifyStrategy'),
}

model NASConfig {
  groupId?: int32(name='groupId'),
  mountPoints?: [ 
    {
      mountDir?: string(name='mountDir'),
      serverAddr?: string(name='serverAddr'),
    }
  ](name='mountPoints'),
  userId?: int32(name='userId'),
}

model OSSMountConfig {
  mountPoints?: [ 
    {
      bucketName?: string(name='bucketName'),
      endpoint?: string(name='endpoint'),
      mountDir?: string(name='mountDir'),
      readOnly?: boolean(name='readOnly'),
    }
  ](name='mountPoints'),
}

model OSSTriggerConfig {
  events?: [ string ](name='events'),
  filter?: OSSTriggerFilter(name='filter'),
}

model OSSTriggerFilter {
  key?: OSSTriggerKey(name='key'),
}

model OSSTriggerKey {
  prefix?: string(name='prefix'),
  suffix?: string(name='suffix'),
}

model OnDemandConfig {
  maximumInstanceCount?: long(name='maximumInstanceCount'),
  resource?: string(name='resource'),
}

model OpenReservedCapacity {
  createdTime?: string(name='createdTime'),
  cu?: long(name='cu'),
  deadline?: string(name='deadline'),
  instanceId?: string(name='instanceId'),
  isRefunded?: string(name='isRefunded'),
  lastModifiedTime?: string(name='lastModifiedTime'),
}

model OutputCodeLocation {
  location?: string(name='location'),
  repositoryType?: string(name='repositoryType'),
}

model PathConfig {
  functionName?: string(name='functionName'),
  methods?: [ string ](name='methods'),
  path?: string(name='path'),
  qualifier?: string(name='qualifier'),
  serviceName?: string(name='serviceName'),
}

model PolicyItem {
  key?: bytes(name='key'),
  operator?: bytes(name='operator'),
  type?: bytes(name='type'),
  value?: bytes(name='value'),
}

model PreFreeze {
  handler?: string(name='handler'),
  timeout?: int32(name='timeout'),
}

model PreStop {
  handler?: string(name='handler'),
  timeout?: int32(name='timeout'),
}

model RdsTriggerConfig {
  concurrency?: long(name='concurrency'),
  eventFormat?: string(name='eventFormat'),
  retry?: long(name='retry'),
  subscriptionObjects?: [ string ](name='subscriptionObjects'),
}

model Resource {
  resourceArn?: string(name='resourceArn'),
  tags?: map[string]string(name='tags'),
}

model RouteConfig {
  routes?: [
    PathConfig
  ](name='routes'),
}

model RoutePolicy {
  condition?: bytes(name='condition'),
  policyItems?: PolicyItem(name='policyItems'),
}

model ScheduledActions {
  endTime?: string(name='endTime'),
  name?: string(name='name'),
  scheduleExpression?: string(name='scheduleExpression'),
  startTime?: string(name='startTime'),
  target?: long(name='target'),
}

model SourceConfig {
  logstore?: string(name='logstore'),
}

model SourceMNSParameters {
  isBase64Decode?: boolean(name='IsBase64Decode'),
  queueName?: string(name='QueueName'),
  regionId?: string(name='RegionId'),
}

model SourceRabbitMQParameters {
  instanceId?: string(name='InstanceId'),
  queueName?: string(name='QueueName'),
  regionId?: string(name='RegionId'),
  virtualHostName?: string(name='VirtualHostName'),
}

model SourceRocketMQParameters {
  groupID?: string(name='GroupID'),
  instanceId?: string(name='InstanceId'),
  offset?: string(name='Offset'),
  regionId?: string(name='RegionId'),
  tag?: string(name='Tag'),
  timestamp?: long(name='Timestamp'),
  topic?: string(name='Topic'),
}

model StatefulAsyncInvocation {
  alreadyRetriedTimes?: long(name='alreadyRetriedTimes'),
  destinationStatus?: string(name='destinationStatus'),
  endTime?: long(name='endTime'),
  events?: [
    StatefulAsyncInvocationEvent
  ](name='events'),
  functionName?: string(name='functionName'),
  instanceId?: string(name='instanceId'),
  invocationErrorMessage?: string(name='invocationErrorMessage'),
  invocationId?: string(name='invocationId'),
  invocationPayload?: string(name='invocationPayload'),
  qualifier?: string(name='qualifier'),
  requestId?: string(name='requestId'),
  serviceName?: string(name='serviceName'),
  startedTime?: long(name='startedTime'),
  status?: string(name='status'),
}

model StatefulAsyncInvocationEvent {
  eventDetail?: string(name='eventDetail'),
  eventId?: long(name='eventId'),
  status?: string(name='status'),
  timestamp?: long(name='timestamp'),
}

model TLSConfig {
  cipherSuites?: [ string ](name='cipherSuites'),
  maxVersion?: string(name='maxVersion'),
  minVersion?: string(name='minVersion'),
}

model TargetTrackingPolicies {
  endTime?: string(name='endTime'),
  maxCapacity?: long(name='maxCapacity'),
  metricTarget?: double(name='metricTarget'),
  metricType?: string(name='metricType'),
  minCapacity?: long(name='minCapacity'),
  name?: string(name='name'),
  startTime?: string(name='startTime'),
}

model TimeTriggerConfig {
  cronExpression?: string(name='cronExpression'),
  enable?: boolean(name='enable'),
  payload?: string(name='payload'),
}

model TracingConfig {
  params?: map[string]string(name='params'),
  type?: string(name='type'),
}

model Trigger {
  createdTime?: string(name='createdTime'),
  domainName?: string(name='domainName'),
  invocationRole?: string(name='invocationRole'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  qualifier?: string(name='qualifier'),
  sourceArn?: string(name='sourceArn'),
  status?: string(name='status'),
  targetArn?: string(name='targetArn'),
  triggerConfig?: string(name='triggerConfig'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName'),
  triggerType?: string(name='triggerType'),
  urlInternet?: string(name='urlInternet'),
  urlIntranet?: string(name='urlIntranet'),
}

model VPCConfig {
  role?: string(name='role'),
  securityGroupId?: string(name='securityGroupId'),
  vSwitchIds?: [ string ](name='vSwitchIds'),
  vpcId?: string(name='vpcId'),
}

model VendorConfig {
  meteringConfig?: MeteringConfig(name='meteringConfig'),
}

model ClaimGPUInstanceHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ClaimGPUInstanceRequest {
  diskPerformanceLevel?: string(name='diskPerformanceLevel'),
  diskSizeGigabytes?: string(name='diskSizeGigabytes'),
  imageId?: string(name='imageId'),
  instanceType?: string(name='instanceType'),
  internetBandwidthOut?: string(name='internetBandwidthOut'),
  password?: string(name='password'),
  sourceCidrIp?: string(name='sourceCidrIp'),
  tcpPortRange?: [ string ](name='tcpPortRange'),
  udpPortRange?: [ string ](name='udpPortRange'),
}

model ClaimGPUInstanceResponseBody = {
  createdTime?: string(name='createdTime'),
  instanceId?: string(name='instanceId'),
  publicIp?: string(name='publicIp'),
}

model ClaimGPUInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ClaimGPUInstanceResponseBody(name='body'),
}

async function claimGPUInstance(request: ClaimGPUInstanceRequest): ClaimGPUInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ClaimGPUInstanceHeaders{};
  return claimGPUInstanceWithOptions(request, headers, runtime);
}

async function claimGPUInstanceWithOptions(request: ClaimGPUInstanceRequest, headers: ClaimGPUInstanceHeaders, runtime: Util.RuntimeOptions): ClaimGPUInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.diskPerformanceLevel)) {
    body['diskPerformanceLevel'] = request.diskPerformanceLevel;
  }
  if (!Util.isUnset(request.diskSizeGigabytes)) {
    body['diskSizeGigabytes'] = request.diskSizeGigabytes;
  }
  if (!Util.isUnset(request.imageId)) {
    body['imageId'] = request.imageId;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['instanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.internetBandwidthOut)) {
    body['internetBandwidthOut'] = request.internetBandwidthOut;
  }
  if (!Util.isUnset(request.password)) {
    body['password'] = request.password;
  }
  if (!Util.isUnset(request.sourceCidrIp)) {
    body['sourceCidrIp'] = request.sourceCidrIp;
  }
  if (!Util.isUnset(request.tcpPortRange)) {
    body['tcpPortRange'] = request.tcpPortRange;
  }
  if (!Util.isUnset(request.udpPortRange)) {
    body['udpPortRange'] = request.udpPortRange;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ClaimGPUInstance',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/gpuInstances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateAliasHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model CreateAliasRequest {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName'),
  description?: string(name='description'),
  resolvePolicy?: string(name='resolvePolicy'),
  routePolicy?: RoutePolicy(name='routePolicy'),
  versionId?: string(name='versionId'),
}

model CreateAliasResponseBody = {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName'),
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  versionId?: string(name='versionId'),
}

model CreateAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAliasResponseBody(name='body'),
}

async function createAlias(serviceName: string, request: CreateAliasRequest): CreateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateAliasHeaders{};
  return createAliasWithOptions(serviceName, request, headers, runtime);
}

async function createAliasWithOptions(serviceName: string, request: CreateAliasRequest, headers: CreateAliasHeaders, runtime: Util.RuntimeOptions): CreateAliasResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.additionalVersionWeight)) {
    body['additionalVersionWeight'] = request.additionalVersionWeight;
  }
  if (!Util.isUnset(request.aliasName)) {
    body['aliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.resolvePolicy)) {
    body['resolvePolicy'] = request.resolvePolicy;
  }
  if (!Util.isUnset(request.routePolicy)) {
    body['routePolicy'] = request.routePolicy;
  }
  if (!Util.isUnset(request.versionId)) {
    body['versionId'] = request.versionId;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlias',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/aliases`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateCustomDomainHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model CreateCustomDomainRequest {
  certConfig?: CertConfig(name='certConfig'),
  domainName?: string(name='domainName'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
}

model CreateCustomDomainResponseBody = {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime'),
  domainName?: string(name='domainName'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
}

model CreateCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCustomDomainResponseBody(name='body'),
}

async function createCustomDomain(request: CreateCustomDomainRequest): CreateCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateCustomDomainHeaders{};
  return createCustomDomainWithOptions(request, headers, runtime);
}

async function createCustomDomainWithOptions(request: CreateCustomDomainRequest, headers: CreateCustomDomainHeaders, runtime: Util.RuntimeOptions): CreateCustomDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.certConfig)) {
    body['certConfig'] = request.certConfig;
  }
  if (!Util.isUnset(request.domainName)) {
    body['domainName'] = request.domainName;
  }
  if (!Util.isUnset(request.protocol)) {
    body['protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.routeConfig)) {
    body['routeConfig'] = request.routeConfig;
  }
  if (!Util.isUnset(request.tlsConfig)) {
    body['tlsConfig'] = request.tlsConfig;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomDomain',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/custom-domains`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateFunctionHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcCodeChecksum?: string(name='X-Fc-Code-Checksum'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model CreateFunctionRequest {
  caPort?: int32(name='caPort'),
  code?: Code(name='code'),
  cpu?: float(name='cpu'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customHealthCheckConfig?: CustomHealthCheckConfig(name='customHealthCheckConfig'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionName?: string(name='functionName'),
  handler?: string(name='handler'),
  initializationTimeout?: int32(name='initializationTimeout'),
  initializer?: string(name='initializer'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
  instanceType?: string(name='instanceType'),
  layers?: [ string ](name='layers'),
  memorySize?: int32(name='memorySize'),
  runtime?: string(name='runtime'),
  timeout?: int32(name='timeout'),
}

model CreateFunctionResponseBody = {
  caPort?: int32(name='caPort'),
  codeChecksum?: string(name='codeChecksum'),
  codeSize?: long(name='codeSize'),
  cpu?: float(name='cpu'),
  createdTime?: string(name='createdTime'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customHealthCheckConfig?: CustomHealthCheckConfig(name='customHealthCheckConfig'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionId?: string(name='functionId'),
  functionName?: string(name='functionName'),
  handler?: string(name='handler'),
  initializationTimeout?: int32(name='initializationTimeout'),
  initializer?: string(name='initializer'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
  instanceType?: string(name='instanceType'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  layers?: [ string ](name='layers'),
  memorySize?: int32(name='memorySize'),
  runtime?: string(name='runtime'),
  timeout?: int32(name='timeout'),
}

model CreateFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFunctionResponseBody(name='body'),
}

async function createFunction(serviceName: string, request: CreateFunctionRequest): CreateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateFunctionHeaders{};
  return createFunctionWithOptions(serviceName, request, headers, runtime);
}

async function createFunctionWithOptions(serviceName: string, request: CreateFunctionRequest, headers: CreateFunctionHeaders, runtime: Util.RuntimeOptions): CreateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.caPort)) {
    body['caPort'] = request.caPort;
  }
  if (!Util.isUnset(request.code)) {
    body['code'] = request.code;
  }
  if (!Util.isUnset(request.cpu)) {
    body['cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.customContainerConfig)) {
    body['customContainerConfig'] = request.customContainerConfig;
  }
  if (!Util.isUnset(request.customDNS)) {
    body['customDNS'] = request.customDNS;
  }
  if (!Util.isUnset(request.customHealthCheckConfig)) {
    body['customHealthCheckConfig'] = request.customHealthCheckConfig;
  }
  if (!Util.isUnset(request.customRuntimeConfig)) {
    body['customRuntimeConfig'] = request.customRuntimeConfig;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.diskSize)) {
    body['diskSize'] = request.diskSize;
  }
  if (!Util.isUnset(request.environmentVariables)) {
    body['environmentVariables'] = request.environmentVariables;
  }
  if (!Util.isUnset(request.functionName)) {
    body['functionName'] = request.functionName;
  }
  if (!Util.isUnset(request.handler)) {
    body['handler'] = request.handler;
  }
  if (!Util.isUnset(request.initializationTimeout)) {
    body['initializationTimeout'] = request.initializationTimeout;
  }
  if (!Util.isUnset(request.initializer)) {
    body['initializer'] = request.initializer;
  }
  if (!Util.isUnset(request.instanceConcurrency)) {
    body['instanceConcurrency'] = request.instanceConcurrency;
  }
  if (!Util.isUnset(request.instanceLifecycleConfig)) {
    body['instanceLifecycleConfig'] = request.instanceLifecycleConfig;
  }
  if (!Util.isUnset(request.instanceSoftConcurrency)) {
    body['instanceSoftConcurrency'] = request.instanceSoftConcurrency;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['instanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.layers)) {
    body['layers'] = request.layers;
  }
  if (!Util.isUnset(request.memorySize)) {
    body['memorySize'] = request.memorySize;
  }
  if (!Util.isUnset(request.runtime)) {
    body['runtime'] = request.runtime;
  }
  if (!Util.isUnset(request.timeout)) {
    body['timeout'] = request.timeout;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcCodeChecksum)) {
    realHeaders['X-Fc-Code-Checksum'] = Util.toJSONString(headers.xFcCodeChecksum);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFunction',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateLayerVersionHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model CreateLayerVersionRequest {
  code?: Code(name='Code'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  description?: string(name='description'),
}

model CreateLayerVersionResponseBody = {
  acl?: int32(name='acl'),
  arn?: string(name='arn'),
  code?: OutputCodeLocation(name='code'),
  codeChecksum?: string(name='codeChecksum'),
  codesize?: long(name='codesize'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  createTime?: string(name='createTime'),
  description?: string(name='description'),
  layerName?: string(name='layerName'),
  version?: int32(name='version'),
}

model CreateLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLayerVersionResponseBody(name='body'),
}

async function createLayerVersion(layerName: string, request: CreateLayerVersionRequest): CreateLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateLayerVersionHeaders{};
  return createLayerVersionWithOptions(layerName, request, headers, runtime);
}

async function createLayerVersionWithOptions(layerName: string, request: CreateLayerVersionRequest, headers: CreateLayerVersionHeaders, runtime: Util.RuntimeOptions): CreateLayerVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.code)) {
    body['Code'] = request.code;
  }
  if (!Util.isUnset(request.compatibleRuntime)) {
    body['compatibleRuntime'] = request.compatibleRuntime;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLayerVersion',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateServiceHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model CreateServiceRequest {
  description?: string(name='description'),
  internetAccess?: boolean(name='internetAccess'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role'),
  serviceName?: string(name='serviceName'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model CreateServiceResponseBody = {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  internetAccess?: boolean(name='internetAccess'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role'),
  serviceId?: string(name='serviceId'),
  serviceName?: string(name='serviceName'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model CreateServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceResponseBody(name='body'),
}

async function createService(request: CreateServiceRequest): CreateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateServiceHeaders{};
  return createServiceWithOptions(request, headers, runtime);
}

async function createServiceWithOptions(request: CreateServiceRequest, headers: CreateServiceHeaders, runtime: Util.RuntimeOptions): CreateServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.internetAccess)) {
    body['internetAccess'] = request.internetAccess;
  }
  if (!Util.isUnset(request.logConfig)) {
    body['logConfig'] = request.logConfig;
  }
  if (!Util.isUnset(request.nasConfig)) {
    body['nasConfig'] = request.nasConfig;
  }
  if (!Util.isUnset(request.ossMountConfig)) {
    body['ossMountConfig'] = request.ossMountConfig;
  }
  if (!Util.isUnset(request.role)) {
    body['role'] = request.role;
  }
  if (!Util.isUnset(request.serviceName)) {
    body['serviceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.tracingConfig)) {
    body['tracingConfig'] = request.tracingConfig;
  }
  if (!Util.isUnset(request.vpcConfig)) {
    body['vpcConfig'] = request.vpcConfig;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateService',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTriggerHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model CreateTriggerRequest {
  description?: string(name='description'),
  invocationRole?: string(name='invocationRole'),
  qualifier?: string(name='qualifier'),
  sourceArn?: string(name='sourceArn'),
  triggerConfig?: string(name='triggerConfig'),
  triggerName?: string(name='triggerName'),
  triggerType?: string(name='triggerType'),
}

model CreateTriggerResponseBody = {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  domainName?: string(name='domainName'),
  invocationRole?: string(name='invocationRole'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  qualifier?: string(name='qualifier'),
  sourceArn?: string(name='sourceArn'),
  triggerConfig?: string(name='triggerConfig'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName'),
  triggerType?: string(name='triggerType'),
  urlInternet?: string(name='urlInternet'),
  urlIntranet?: string(name='urlIntranet'),
}

model CreateTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTriggerResponseBody(name='body'),
}

async function createTrigger(serviceName: string, functionName: string, request: CreateTriggerRequest): CreateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateTriggerHeaders{};
  return createTriggerWithOptions(serviceName, functionName, request, headers, runtime);
}

async function createTriggerWithOptions(serviceName: string, functionName: string, request: CreateTriggerRequest, headers: CreateTriggerHeaders, runtime: Util.RuntimeOptions): CreateTriggerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.invocationRole)) {
    body['invocationRole'] = request.invocationRole;
  }
  if (!Util.isUnset(request.qualifier)) {
    body['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.sourceArn)) {
    body['sourceArn'] = request.sourceArn;
  }
  if (!Util.isUnset(request.triggerConfig)) {
    body['triggerConfig'] = request.triggerConfig;
  }
  if (!Util.isUnset(request.triggerName)) {
    body['triggerName'] = request.triggerName;
  }
  if (!Util.isUnset(request.triggerType)) {
    body['triggerType'] = request.triggerType;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrigger',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateVpcBindingHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model CreateVpcBindingRequest {
  vpcId?: string(name='vpcId'),
}

model CreateVpcBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createVpcBinding(serviceName: string, request: CreateVpcBindingRequest): CreateVpcBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateVpcBindingHeaders{};
  return createVpcBindingWithOptions(serviceName, request, headers, runtime);
}

async function createVpcBindingWithOptions(serviceName: string, request: CreateVpcBindingRequest, headers: CreateVpcBindingHeaders, runtime: Util.RuntimeOptions): CreateVpcBindingResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.vpcId)) {
    body['vpcId'] = request.vpcId;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpcBinding',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/bindings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteAliasHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteAlias(serviceName: string, aliasName: string): DeleteAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteAliasHeaders{};
  return deleteAliasWithOptions(serviceName, aliasName, headers, runtime);
}

async function deleteAliasWithOptions(serviceName: string, aliasName: string, headers: DeleteAliasHeaders, runtime: Util.RuntimeOptions): DeleteAliasResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlias',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/aliases/${OpenApiUtil.getEncodeParam(aliasName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteCustomDomainHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteCustomDomain(domainName: string): DeleteCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteCustomDomainHeaders{};
  return deleteCustomDomainWithOptions(domainName, headers, runtime);
}

async function deleteCustomDomainWithOptions(domainName: string, headers: DeleteCustomDomainHeaders, runtime: Util.RuntimeOptions): DeleteCustomDomainResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomDomain',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/custom-domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteFunctionHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteFunction(serviceName: string, functionName: string): DeleteFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteFunctionHeaders{};
  return deleteFunctionWithOptions(serviceName, functionName, headers, runtime);
}

async function deleteFunctionWithOptions(serviceName: string, functionName: string, headers: DeleteFunctionHeaders, runtime: Util.RuntimeOptions): DeleteFunctionResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunction',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteFunctionAsyncInvokeConfigHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteFunctionAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier'),
}

model DeleteFunctionAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteFunctionAsyncInvokeConfig(serviceName: string, functionName: string, request: DeleteFunctionAsyncInvokeConfigRequest): DeleteFunctionAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteFunctionAsyncInvokeConfigHeaders{};
  return deleteFunctionAsyncInvokeConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function deleteFunctionAsyncInvokeConfigWithOptions(serviceName: string, functionName: string, request: DeleteFunctionAsyncInvokeConfigRequest, headers: DeleteFunctionAsyncInvokeConfigHeaders, runtime: Util.RuntimeOptions): DeleteFunctionAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunctionAsyncInvokeConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-config`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteFunctionOnDemandConfigHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteFunctionOnDemandConfigRequest {
  qualifier?: string(name='qualifier'),
}

model DeleteFunctionOnDemandConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteFunctionOnDemandConfig(serviceName: string, functionName: string, request: DeleteFunctionOnDemandConfigRequest): DeleteFunctionOnDemandConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteFunctionOnDemandConfigHeaders{};
  return deleteFunctionOnDemandConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function deleteFunctionOnDemandConfigWithOptions(serviceName: string, functionName: string, request: DeleteFunctionOnDemandConfigRequest, headers: DeleteFunctionOnDemandConfigHeaders, runtime: Util.RuntimeOptions): DeleteFunctionOnDemandConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunctionOnDemandConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/on-demand-config`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteLayerVersionHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteLayerVersion(layerName: string, version: string): DeleteLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteLayerVersionHeaders{};
  return deleteLayerVersionWithOptions(layerName, version, headers, runtime);
}

async function deleteLayerVersionWithOptions(layerName: string, version: string, headers: DeleteLayerVersionHeaders, runtime: Util.RuntimeOptions): DeleteLayerVersionResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLayerVersion',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions/${OpenApiUtil.getEncodeParam(version)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteService(serviceName: string): DeleteServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteServiceHeaders{};
  return deleteServiceWithOptions(serviceName, headers, runtime);
}

async function deleteServiceWithOptions(serviceName: string, headers: DeleteServiceHeaders, runtime: Util.RuntimeOptions): DeleteServiceResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteService',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceVersionHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteServiceVersion(serviceName: string, versionId: string): DeleteServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteServiceVersionHeaders{};
  return deleteServiceVersionWithOptions(serviceName, versionId, headers, runtime);
}

async function deleteServiceVersionWithOptions(serviceName: string, versionId: string, headers: DeleteServiceVersionHeaders, runtime: Util.RuntimeOptions): DeleteServiceVersionResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceVersion',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/versions/${OpenApiUtil.getEncodeParam(versionId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteTriggerHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteTrigger(serviceName: string, functionName: string, triggerName: string): DeleteTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteTriggerHeaders{};
  return deleteTriggerWithOptions(serviceName, functionName, triggerName, headers, runtime);
}

async function deleteTriggerWithOptions(serviceName: string, functionName: string, triggerName: string, headers: DeleteTriggerHeaders, runtime: Util.RuntimeOptions): DeleteTriggerResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTrigger',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers/${OpenApiUtil.getEncodeParam(triggerName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteVpcBindingHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteVpcBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteVpcBinding(serviceName: string, vpcId: string): DeleteVpcBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteVpcBindingHeaders{};
  return deleteVpcBindingWithOptions(serviceName, vpcId, headers, runtime);
}

async function deleteVpcBindingWithOptions(serviceName: string, vpcId: string, headers: DeleteVpcBindingHeaders, runtime: Util.RuntimeOptions): DeleteVpcBindingResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpcBinding',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/bindings/${OpenApiUtil.getEncodeParam(vpcId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeregisterEventSourceHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeregisterEventSourceRequest {
  qualifier?: string(name='qualifier'),
}

model DeregisterEventSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deregisterEventSource(serviceName: string, functionName: string, sourceArn: string, request: DeregisterEventSourceRequest): DeregisterEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeregisterEventSourceHeaders{};
  return deregisterEventSourceWithOptions(serviceName, functionName, sourceArn, request, headers, runtime);
}

async function deregisterEventSourceWithOptions(serviceName: string, functionName: string, sourceArn: string, request: DeregisterEventSourceRequest, headers: DeregisterEventSourceHeaders, runtime: Util.RuntimeOptions): DeregisterEventSourceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeregisterEventSource',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/event-sources/${OpenApiUtil.getEncodeParam(sourceArn)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetAccountSettingsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetAccountSettingsResponseBody = {
  availableAZs?: [ string ](name='availableAZs'),
  defaultRole?: string(name='defaultRole'),
}

model GetAccountSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAccountSettingsResponseBody(name='body'),
}

async function getAccountSettings(): GetAccountSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetAccountSettingsHeaders{};
  return getAccountSettingsWithOptions(headers, runtime);
}

async function getAccountSettingsWithOptions(headers: GetAccountSettingsHeaders, runtime: Util.RuntimeOptions): GetAccountSettingsResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'GetAccountSettings',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/account-settings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetAliasHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetAliasResponseBody = {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName'),
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  resolvePolicy?: string(name='resolvePolicy'),
  routePolicy?: RoutePolicy(name='routePolicy'),
  versionId?: string(name='versionId'),
}

model GetAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAliasResponseBody(name='body'),
}

async function getAlias(serviceName: string, aliasName: string): GetAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetAliasHeaders{};
  return getAliasWithOptions(serviceName, aliasName, headers, runtime);
}

async function getAliasWithOptions(serviceName: string, aliasName: string, headers: GetAliasHeaders, runtime: Util.RuntimeOptions): GetAliasResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'GetAlias',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/aliases/${OpenApiUtil.getEncodeParam(aliasName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetCustomDomainHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetCustomDomainResponseBody = {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime'),
  domainName?: string(name='domainName'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
}

model GetCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCustomDomainResponseBody(name='body'),
}

async function getCustomDomain(domainName: string): GetCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetCustomDomainHeaders{};
  return getCustomDomainWithOptions(domainName, headers, runtime);
}

async function getCustomDomainWithOptions(domainName: string, headers: GetCustomDomainHeaders, runtime: Util.RuntimeOptions): GetCustomDomainResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'GetCustomDomain',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/custom-domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFunctionHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetFunctionRequest {
  qualifier?: string(name='qualifier'),
}

model GetFunctionResponseBody = {
  caPort?: int32(name='caPort'),
  codeChecksum?: string(name='codeChecksum'),
  codeSize?: long(name='codeSize'),
  cpu?: float(name='cpu'),
  createdTime?: string(name='createdTime'),
  customContainerConfig?: CustomContainerConfigInfo(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customHealthCheckConfig?: CustomHealthCheckConfig(name='customHealthCheckConfig'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionId?: string(name='functionId'),
  functionName?: string(name='functionName'),
  handler?: string(name='handler'),
  initializationTimeout?: int32(name='initializationTimeout'),
  initializer?: string(name='initializer'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
  instanceType?: string(name='instanceType'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  layers?: [ string ](name='layers'),
  layersArnV2?: [ string ](name='layersArnV2'),
  memorySize?: int32(name='memorySize'),
  runtime?: string(name='runtime'),
  timeout?: int32(name='timeout'),
}

model GetFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFunctionResponseBody(name='body'),
}

async function getFunction(serviceName: string, functionName: string, request: GetFunctionRequest): GetFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetFunctionHeaders{};
  return getFunctionWithOptions(serviceName, functionName, request, headers, runtime);
}

async function getFunctionWithOptions(serviceName: string, functionName: string, request: GetFunctionRequest, headers: GetFunctionHeaders, runtime: Util.RuntimeOptions): GetFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunction',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFunctionAsyncInvokeConfigHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetFunctionAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier'),
}

model GetFunctionAsyncInvokeConfigResponseBody = {
  createdTime?: string(name='createdTime'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  function?: string(name='function'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts'),
  qualifier?: string(name='qualifier'),
  service?: string(name='service'),
  statefulInvocation?: boolean(name='statefulInvocation'),
}

model GetFunctionAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFunctionAsyncInvokeConfigResponseBody(name='body'),
}

async function getFunctionAsyncInvokeConfig(serviceName: string, functionName: string, request: GetFunctionAsyncInvokeConfigRequest): GetFunctionAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetFunctionAsyncInvokeConfigHeaders{};
  return getFunctionAsyncInvokeConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function getFunctionAsyncInvokeConfigWithOptions(serviceName: string, functionName: string, request: GetFunctionAsyncInvokeConfigRequest, headers: GetFunctionAsyncInvokeConfigHeaders, runtime: Util.RuntimeOptions): GetFunctionAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionAsyncInvokeConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFunctionCodeHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetFunctionCodeRequest {
  qualifier?: string(name='qualifier'),
}

model GetFunctionCodeResponseBody = {
  checksum?: string(name='checksum'),
  url?: string(name='url'),
}

model GetFunctionCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFunctionCodeResponseBody(name='body'),
}

async function getFunctionCode(serviceName: string, functionName: string, request: GetFunctionCodeRequest): GetFunctionCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetFunctionCodeHeaders{};
  return getFunctionCodeWithOptions(serviceName, functionName, request, headers, runtime);
}

async function getFunctionCodeWithOptions(serviceName: string, functionName: string, request: GetFunctionCodeRequest, headers: GetFunctionCodeHeaders, runtime: Util.RuntimeOptions): GetFunctionCodeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionCode',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/code`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFunctionOnDemandConfigHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetFunctionOnDemandConfigRequest {
  qualifier?: string(name='qualifier'),
}

model GetFunctionOnDemandConfigResponseBody = {
  maximumInstanceCount?: long(name='maximumInstanceCount'),
  resource?: string(name='resource'),
}

model GetFunctionOnDemandConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFunctionOnDemandConfigResponseBody(name='body'),
}

async function getFunctionOnDemandConfig(serviceName: string, functionName: string, request: GetFunctionOnDemandConfigRequest): GetFunctionOnDemandConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetFunctionOnDemandConfigHeaders{};
  return getFunctionOnDemandConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function getFunctionOnDemandConfigWithOptions(serviceName: string, functionName: string, request: GetFunctionOnDemandConfigRequest, headers: GetFunctionOnDemandConfigHeaders, runtime: Util.RuntimeOptions): GetFunctionOnDemandConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionOnDemandConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/on-demand-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetLayerVersionHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Layer  
}

async function getLayerVersion(layerName: string, version: string): GetLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetLayerVersionHeaders{};
  return getLayerVersionWithOptions(layerName, version, headers, runtime);
}

async function getLayerVersionWithOptions(layerName: string, version: string, headers: GetLayerVersionHeaders, runtime: Util.RuntimeOptions): GetLayerVersionResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'GetLayerVersion',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions/${OpenApiUtil.getEncodeParam(version)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProvisionConfigHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetProvisionConfigRequest {
  qualifier?: string(name='qualifier'),
}

model GetProvisionConfigResponseBody = {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU'),
  current?: long(name='current'),
  currentError?: string(name='currentError'),
  resource?: string(name='resource'),
  scheduledActions?: [
    ScheduledActions
  ](name='scheduledActions'),
  target?: long(name='target'),
  targetTrackingPolicies?: [
    TargetTrackingPolicies
  ](name='targetTrackingPolicies'),
}

model GetProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProvisionConfigResponseBody(name='body'),
}

async function getProvisionConfig(serviceName: string, functionName: string, request: GetProvisionConfigRequest): GetProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetProvisionConfigHeaders{};
  return getProvisionConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function getProvisionConfigWithOptions(serviceName: string, functionName: string, request: GetProvisionConfigRequest, headers: GetProvisionConfigHeaders, runtime: Util.RuntimeOptions): GetProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProvisionConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/provision-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetResourceTagsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetResourceTagsRequest {
  resourceArn?: string(name='resourceArn'),
}

model GetResourceTagsResponseBody = {
  resourceArn?: string(name='resourceArn'),
  tags?: map[string]string(name='tags'),
}

model GetResourceTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceTagsResponseBody(name='body'),
}

async function getResourceTags(request: GetResourceTagsRequest): GetResourceTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetResourceTagsHeaders{};
  return getResourceTagsWithOptions(request, headers, runtime);
}

async function getResourceTagsWithOptions(request: GetResourceTagsRequest, headers: GetResourceTagsHeaders, runtime: Util.RuntimeOptions): GetResourceTagsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.resourceArn)) {
    query['resourceArn'] = request.resourceArn;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceTags',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/tag`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetServiceRequest {
  qualifier?: string(name='qualifier'),
}

model GetServiceResponseBody = {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  internetAccess?: boolean(name='internetAccess'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role'),
  serviceId?: string(name='serviceId'),
  serviceName?: string(name='serviceName'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model GetServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceResponseBody(name='body'),
}

async function getService(serviceName: string, request: GetServiceRequest): GetServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetServiceHeaders{};
  return getServiceWithOptions(serviceName, request, headers, runtime);
}

async function getServiceWithOptions(serviceName: string, request: GetServiceRequest, headers: GetServiceHeaders, runtime: Util.RuntimeOptions): GetServiceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetService',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetStatefulAsyncInvocationHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcCodeChecksum?: string(name='X-Fc-Code-Checksum'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcInvocationType?: string(name='X-Fc-Invocation-Type'),
  xFcLogType?: string(name='X-Fc-Log-Type'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetStatefulAsyncInvocationRequest {
  qualifier?: string(name='qualifier'),
}

model GetStatefulAsyncInvocationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StatefulAsyncInvocation  
}

async function getStatefulAsyncInvocation(serviceName: string, functionName: string, invocationId: string, request: GetStatefulAsyncInvocationRequest): GetStatefulAsyncInvocationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetStatefulAsyncInvocationHeaders{};
  return getStatefulAsyncInvocationWithOptions(serviceName, functionName, invocationId, request, headers, runtime);
}

async function getStatefulAsyncInvocationWithOptions(serviceName: string, functionName: string, invocationId: string, request: GetStatefulAsyncInvocationRequest, headers: GetStatefulAsyncInvocationHeaders, runtime: Util.RuntimeOptions): GetStatefulAsyncInvocationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcCodeChecksum)) {
    realHeaders['X-Fc-Code-Checksum'] = Util.toJSONString(headers.xFcCodeChecksum);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcInvocationType)) {
    realHeaders['X-Fc-Invocation-Type'] = Util.toJSONString(headers.xFcInvocationType);
  }
  if (!Util.isUnset(headers.xFcLogType)) {
    realHeaders['X-Fc-Log-Type'] = Util.toJSONString(headers.xFcLogType);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetStatefulAsyncInvocation',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/stateful-async-invocations/${OpenApiUtil.getEncodeParam(invocationId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTriggerHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetTriggerResponseBody = {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  domainName?: string(name='domainName'),
  invocationRole?: string(name='invocationRole'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  qualifier?: string(name='qualifier'),
  sourceArn?: string(name='sourceArn'),
  triggerConfig?: string(name='triggerConfig'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName'),
  triggerType?: string(name='triggerType'),
  urlInternet?: string(name='urlInternet'),
  urlIntranet?: string(name='urlIntranet'),
}

model GetTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTriggerResponseBody(name='body'),
}

async function getTrigger(serviceName: string, functionName: string, triggerName: string): GetTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetTriggerHeaders{};
  return getTriggerWithOptions(serviceName, functionName, triggerName, headers, runtime);
}

async function getTriggerWithOptions(serviceName: string, functionName: string, triggerName: string, headers: GetTriggerHeaders, runtime: Util.RuntimeOptions): GetTriggerResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'GetTrigger',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers/${OpenApiUtil.getEncodeParam(triggerName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InvokeFunctionHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcInvocationType?: string(name='X-Fc-Invocation-Type'),
  xFcLogType?: string(name='X-Fc-Log-Type'),
  xFcStatefulAsyncInvocationId?: string(name='X-Fc-Stateful-Async-Invocation-Id'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model InvokeFunctionRequest {
  body?: bytes(name='body'),
  qualifier?: string(name='qualifier'),
}

model InvokeFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: bytes(name='body'),
}

async function invokeFunction(serviceName: string, functionName: string, request: InvokeFunctionRequest): InvokeFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new InvokeFunctionHeaders{};
  return invokeFunctionWithOptions(serviceName, functionName, request, headers, runtime);
}

async function invokeFunctionWithOptions(serviceName: string, functionName: string, request: InvokeFunctionRequest, headers: InvokeFunctionHeaders, runtime: Util.RuntimeOptions): InvokeFunctionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var body : string = '';
  if (!Util.isUnset(request.body)) {
    body = Util.toString(request.body);
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcInvocationType)) {
    realHeaders['X-Fc-Invocation-Type'] = Util.toJSONString(headers.xFcInvocationType);
  }
  if (!Util.isUnset(headers.xFcLogType)) {
    realHeaders['X-Fc-Log-Type'] = Util.toJSONString(headers.xFcLogType);
  }
  if (!Util.isUnset(headers.xFcStatefulAsyncInvocationId)) {
    realHeaders['X-Fc-Stateful-Async-Invocation-Id'] = Util.toJSONString(headers.xFcStatefulAsyncInvocationId);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = body,
  };
  var params = new OpenApi.Params{
    action = 'InvokeFunction',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/invocations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'byte',
  };
  return callApi(params, req, runtime);
}

model ListAliasesHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListAliasesRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  prefix?: string(name='prefix'),
  startKey?: string(name='startKey'),
}

model ListAliasesResponseBody = {
  aliases?: [ 
    {
      additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
      aliasName?: string(name='aliasName'),
      createdTime?: string(name='createdTime'),
      description?: string(name='description'),
      lastModifiedTime?: string(name='lastModifiedTime'),
      resolvePolicy?: string(name='resolvePolicy'),
      routePolicy?: RoutePolicy(name='routePolicy'),
      versionId?: string(name='versionId'),
    }
  ](name='aliases'),
  nextToken?: string(name='nextToken'),
}

model ListAliasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAliasesResponseBody(name='body'),
}

async function listAliases(serviceName: string, request: ListAliasesRequest): ListAliasesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListAliasesHeaders{};
  return listAliasesWithOptions(serviceName, request, headers, runtime);
}

async function listAliasesWithOptions(serviceName: string, request: ListAliasesRequest, headers: ListAliasesHeaders, runtime: Util.RuntimeOptions): ListAliasesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAliases',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/aliases`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListCustomDomainsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListCustomDomainsRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  prefix?: string(name='prefix'),
  startKey?: string(name='startKey'),
}

model ListCustomDomainsResponseBody = {
  customDomains?: [ 
    {
      accountId?: string(name='accountId'),
      apiVersion?: string(name='apiVersion'),
      certConfig?: CertConfig(name='certConfig'),
      createdTime?: string(name='createdTime'),
      domainName?: string(name='domainName'),
      lastModifiedTime?: string(name='lastModifiedTime'),
      protocol?: string(name='protocol'),
      routeConfig?: RouteConfig(name='routeConfig'),
      tlsConfig?: TLSConfig(name='tlsConfig'),
    }
  ](name='customDomains'),
  nextToken?: string(name='nextToken'),
}

model ListCustomDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCustomDomainsResponseBody(name='body'),
}

async function listCustomDomains(request: ListCustomDomainsRequest): ListCustomDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListCustomDomainsHeaders{};
  return listCustomDomainsWithOptions(request, headers, runtime);
}

async function listCustomDomainsWithOptions(request: ListCustomDomainsRequest, headers: ListCustomDomainsHeaders, runtime: Util.RuntimeOptions): ListCustomDomainsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCustomDomains',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/custom-domains`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEventSourcesHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListEventSourcesRequest {
  qualifier?: string(name='qualifier'),
}

model ListEventSourcesResponseBody = {
  eventSources?: [ 
    {
      createdTime?: string(name='createdTime'),
      sourceArn?: string(name='sourceArn'),
    }
  ](name='eventSources'),
}

model ListEventSourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventSourcesResponseBody(name='body'),
}

async function listEventSources(serviceName: string, functionName: string, request: ListEventSourcesRequest): ListEventSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListEventSourcesHeaders{};
  return listEventSourcesWithOptions(serviceName, functionName, request, headers, runtime);
}

async function listEventSourcesWithOptions(serviceName: string, functionName: string, request: ListEventSourcesRequest, headers: ListEventSourcesHeaders, runtime: Util.RuntimeOptions): ListEventSourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEventSources',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/event-sources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFunctionAsyncInvokeConfigsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcCodeChecksum?: string(name='X-Fc-Code-Checksum'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcInvocationType?: string(name='X-Fc-Invocation-Type'),
  xFcLogType?: string(name='X-Fc-Log-Type'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListFunctionAsyncInvokeConfigsRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
}

model ListFunctionAsyncInvokeConfigsResponseBody = {
  configs?: [ 
    {
      createdTime?: string(name='createdTime'),
      destinationConfig?: DestinationConfig(name='destinationConfig'),
      function?: string(name='function'),
      lastModifiedTime?: string(name='lastModifiedTime'),
      maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds'),
      maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts'),
      qualifier?: string(name='qualifier'),
      service?: string(name='service'),
      statefulInvocation?: boolean(name='statefulInvocation'),
    }
  ](name='configs'),
  nextToken?: string(name='nextToken'),
}

model ListFunctionAsyncInvokeConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFunctionAsyncInvokeConfigsResponseBody(name='body'),
}

async function listFunctionAsyncInvokeConfigs(serviceName: string, functionName: string, request: ListFunctionAsyncInvokeConfigsRequest): ListFunctionAsyncInvokeConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListFunctionAsyncInvokeConfigsHeaders{};
  return listFunctionAsyncInvokeConfigsWithOptions(serviceName, functionName, request, headers, runtime);
}

async function listFunctionAsyncInvokeConfigsWithOptions(serviceName: string, functionName: string, request: ListFunctionAsyncInvokeConfigsRequest, headers: ListFunctionAsyncInvokeConfigsHeaders, runtime: Util.RuntimeOptions): ListFunctionAsyncInvokeConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcCodeChecksum)) {
    realHeaders['X-Fc-Code-Checksum'] = Util.toJSONString(headers.xFcCodeChecksum);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcInvocationType)) {
    realHeaders['X-Fc-Invocation-Type'] = Util.toJSONString(headers.xFcInvocationType);
  }
  if (!Util.isUnset(headers.xFcLogType)) {
    realHeaders['X-Fc-Log-Type'] = Util.toJSONString(headers.xFcLogType);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionAsyncInvokeConfigs',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFunctionsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListFunctionsRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  prefix?: string(name='prefix'),
  qualifier?: string(name='qualifier'),
  startKey?: string(name='startKey'),
}

model ListFunctionsResponseBody = {
  functions?: [ 
    {
      caPort?: int32(name='caPort'),
      codeChecksum?: string(name='codeChecksum'),
      codeSize?: long(name='codeSize'),
      cpu?: float(name='cpu'),
      createdTime?: string(name='createdTime'),
      customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
      customHealthCheckConfig?: CustomHealthCheckConfig(name='customHealthCheckConfig'),
      description?: string(name='description'),
      diskSize?: int32(name='diskSize'),
      environmentVariables?: map[string]string(name='environmentVariables'),
      functionId?: string(name='functionId'),
      functionName?: string(name='functionName'),
      handler?: string(name='handler'),
      initializationTimeout?: int32(name='initializationTimeout'),
      initializer?: string(name='initializer'),
      instanceConcurrency?: int32(name='instanceConcurrency'),
      instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
      instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
      instanceType?: string(name='instanceType'),
      lastModifiedTime?: string(name='lastModifiedTime'),
      layers?: [ string ](name='layers'),
      memorySize?: int32(name='memorySize'),
      runtime?: string(name='runtime'),
      timeout?: int32(name='timeout'),
    }
  ](name='functions'),
  nextToken?: string(name='nextToken'),
}

model ListFunctionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFunctionsResponseBody(name='body'),
}

async function listFunctions(serviceName: string, request: ListFunctionsRequest): ListFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListFunctionsHeaders{};
  return listFunctionsWithOptions(serviceName, request, headers, runtime);
}

async function listFunctionsWithOptions(serviceName: string, request: ListFunctionsRequest, headers: ListFunctionsHeaders, runtime: Util.RuntimeOptions): ListFunctionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctions',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListInstancesHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
}

model ListInstancesRequest {
  instanceIds?: [ string ](name='instanceIds'),
  limit?: int32(name='limit'),
  qualifier?: string(name='qualifier'),
}

model ListInstancesResponseBody = {
  instances?: [ 
    {
      instanceId?: string(name='instanceId'),
      versionId?: string(name='versionId'),
    }
  ](name='instances'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstances(serviceName: string, functionName: string, request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListInstancesHeaders{};
  return listInstancesWithOptions(serviceName, functionName, request, headers, runtime);
}

async function listInstancesWithOptions(serviceName: string, functionName: string, request: ListInstancesRequest, headers: ListInstancesHeaders, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['instanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListLayerVersionsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListLayerVersionsRequest {
  limit?: int32(name='limit'),
  startVersion?: int32(name='startVersion'),
}

model ListLayerVersionsResponseBody = {
  layers?: [
    Layer
  ](name='layers'),
  nextVersion?: int32(name='nextVersion'),
}

model ListLayerVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLayerVersionsResponseBody(name='body'),
}

async function listLayerVersions(layerName: string, request: ListLayerVersionsRequest): ListLayerVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListLayerVersionsHeaders{};
  return listLayerVersionsWithOptions(layerName, request, headers, runtime);
}

async function listLayerVersionsWithOptions(layerName: string, request: ListLayerVersionsRequest, headers: ListLayerVersionsHeaders, runtime: Util.RuntimeOptions): ListLayerVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.startVersion)) {
    query['startVersion'] = request.startVersion;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLayerVersions',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/layers/${OpenApiUtil.getEncodeParam(layerName)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListLayersHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListLayersRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  official?: boolean(name='official'),
  prefix?: string(name='prefix'),
  public?: boolean(name='public'),
  startKey?: string(name='startKey'),
}

model ListLayersResponseBody = {
  layers?: [
    Layer
  ](name='layers'),
  nextToken?: string(name='nextToken'),
}

model ListLayersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLayersResponseBody(name='body'),
}

async function listLayers(request: ListLayersRequest): ListLayersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListLayersHeaders{};
  return listLayersWithOptions(request, headers, runtime);
}

async function listLayersWithOptions(request: ListLayersRequest, headers: ListLayersHeaders, runtime: Util.RuntimeOptions): ListLayersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.official)) {
    query['official'] = request.official;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.public)) {
    query['public'] = request.public;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLayers',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/layers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListOnDemandConfigsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListOnDemandConfigsRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  prefix?: string(name='prefix'),
  startKey?: string(name='startKey'),
}

model ListOnDemandConfigsResponseBody = {
  configs?: [
    OnDemandConfig
  ](name='configs'),
  nextToken?: string(name='nextToken'),
}

model ListOnDemandConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOnDemandConfigsResponseBody(name='body'),
}

async function listOnDemandConfigs(request: ListOnDemandConfigsRequest): ListOnDemandConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListOnDemandConfigsHeaders{};
  return listOnDemandConfigsWithOptions(request, headers, runtime);
}

async function listOnDemandConfigsWithOptions(request: ListOnDemandConfigsRequest, headers: ListOnDemandConfigsHeaders, runtime: Util.RuntimeOptions): ListOnDemandConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOnDemandConfigs',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/on-demand-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProvisionConfigsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListProvisionConfigsRequest {
  limit?: long(name='limit'),
  nextToken?: string(name='nextToken'),
  qualifier?: string(name='qualifier'),
  serviceName?: string(name='serviceName'),
}

model ListProvisionConfigsResponseBody = {
  nextToken?: string(name='nextToken'),
  provisionConfigs?: [ 
    {
      alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU'),
      current?: long(name='current'),
      currentError?: string(name='currentError'),
      resource?: string(name='resource'),
      scheduledActions?: [
        ScheduledActions
      ](name='scheduledActions'),
      target?: long(name='target'),
      targetTrackingPolicies?: [
        TargetTrackingPolicies
      ](name='targetTrackingPolicies'),
    }
  ](name='provisionConfigs'),
}

model ListProvisionConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProvisionConfigsResponseBody(name='body'),
}

async function listProvisionConfigs(request: ListProvisionConfigsRequest): ListProvisionConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListProvisionConfigsHeaders{};
  return listProvisionConfigsWithOptions(request, headers, runtime);
}

async function listProvisionConfigsWithOptions(request: ListProvisionConfigsRequest, headers: ListProvisionConfigsHeaders, runtime: Util.RuntimeOptions): ListProvisionConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['serviceName'] = request.serviceName;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProvisionConfigs',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/provision-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListReservedCapacitiesHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListReservedCapacitiesRequest {
  limit?: string(name='limit'),
  nextToken?: string(name='nextToken'),
}

model ListReservedCapacitiesResponseBody = {
  nextToken?: string(name='nextToken'),
  reservedCapacities?: [
    OpenReservedCapacity
  ](name='reservedCapacities'),
}

model ListReservedCapacitiesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListReservedCapacitiesResponseBody(name='body'),
}

async function listReservedCapacities(request: ListReservedCapacitiesRequest): ListReservedCapacitiesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListReservedCapacitiesHeaders{};
  return listReservedCapacitiesWithOptions(request, headers, runtime);
}

async function listReservedCapacitiesWithOptions(request: ListReservedCapacitiesRequest, headers: ListReservedCapacitiesHeaders, runtime: Util.RuntimeOptions): ListReservedCapacitiesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListReservedCapacities',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/reserved-capacities`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListServiceVersionsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListServiceVersionsRequest {
  direction?: string(name='direction'),
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  startKey?: string(name='startKey'),
}

model ListServiceVersionsResponseBody = {
  direction?: string(name='direction'),
  nextToken?: string(name='nextToken'),
  versions?: [ 
    {
      createdTime?: string(name='createdTime'),
      description?: string(name='description'),
      lastModifiedTime?: string(name='lastModifiedTime'),
      versionId?: string(name='versionId'),
    }
  ](name='versions'),
}

model ListServiceVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceVersionsResponseBody(name='body'),
}

async function listServiceVersions(serviceName: string, request: ListServiceVersionsRequest): ListServiceVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListServiceVersionsHeaders{};
  return listServiceVersionsWithOptions(serviceName, request, headers, runtime);
}

async function listServiceVersionsWithOptions(serviceName: string, request: ListServiceVersionsRequest, headers: ListServiceVersionsHeaders, runtime: Util.RuntimeOptions): ListServiceVersionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.direction)) {
    query['direction'] = request.direction;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceVersions',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListServicesHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListServicesRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  prefix?: string(name='prefix'),
  startKey?: string(name='startKey'),
}

model ListServicesResponseBody = {
  nextToken?: string(name='nextToken'),
  services?: [ 
    {
      createdTime?: string(name='createdTime'),
      description?: string(name='description'),
      internetAccess?: boolean(name='internetAccess'),
      lastModifiedTime?: string(name='lastModifiedTime'),
      logConfig?: LogConfig(name='logConfig'),
      nasConfig?: NASConfig(name='nasConfig'),
      ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
      role?: string(name='role'),
      serviceId?: string(name='serviceId'),
      serviceName?: string(name='serviceName'),
      tracingConfig?: TracingConfig(name='tracingConfig'),
      vpcConfig?: VPCConfig(name='vpcConfig'),
    }
  ](name='services'),
}

model ListServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServicesResponseBody(name='body'),
}

async function listServices(request: ListServicesRequest): ListServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListServicesHeaders{};
  return listServicesWithOptions(request, headers, runtime);
}

async function listServicesWithOptions(request: ListServicesRequest, headers: ListServicesHeaders, runtime: Util.RuntimeOptions): ListServicesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServices',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListStatefulAsyncInvocationFunctionsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListStatefulAsyncInvocationFunctionsRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
}

model ListStatefulAsyncInvocationFunctionsResponseBody = {
  data?: [
    AsyncConfigMeta
  ](name='data'),
  nextToken?: string(name='nextToken'),
}

model ListStatefulAsyncInvocationFunctionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListStatefulAsyncInvocationFunctionsResponseBody(name='body'),
}

async function listStatefulAsyncInvocationFunctions(request: ListStatefulAsyncInvocationFunctionsRequest): ListStatefulAsyncInvocationFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListStatefulAsyncInvocationFunctionsHeaders{};
  return listStatefulAsyncInvocationFunctionsWithOptions(request, headers, runtime);
}

async function listStatefulAsyncInvocationFunctionsWithOptions(request: ListStatefulAsyncInvocationFunctionsRequest, headers: ListStatefulAsyncInvocationFunctionsHeaders, runtime: Util.RuntimeOptions): ListStatefulAsyncInvocationFunctionsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListStatefulAsyncInvocationFunctions',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/stateful-async-invocation-functions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListStatefulAsyncInvocationsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcCodeChecksum?: string(name='X-Fc-Code-Checksum'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcInvocationType?: string(name='X-Fc-Invocation-Type'),
  xFcLogType?: string(name='X-Fc-Log-Type'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListStatefulAsyncInvocationsRequest {
  includePayload?: boolean(name='includePayload'),
  invocationIdPrefix?: string(name='invocationIdPrefix'),
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  qualifier?: string(name='qualifier'),
  sortOrderByTime?: string(name='sortOrderByTime'),
  startedTimeBegin?: long(name='startedTimeBegin'),
  startedTimeEnd?: long(name='startedTimeEnd'),
  status?: string(name='status'),
}

model ListStatefulAsyncInvocationsResponseBody = {
  invocations?: [
    StatefulAsyncInvocation
  ](name='invocations'),
  nextToken?: string(name='nextToken'),
}

model ListStatefulAsyncInvocationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListStatefulAsyncInvocationsResponseBody(name='body'),
}

async function listStatefulAsyncInvocations(serviceName: string, functionName: string, request: ListStatefulAsyncInvocationsRequest): ListStatefulAsyncInvocationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListStatefulAsyncInvocationsHeaders{};
  return listStatefulAsyncInvocationsWithOptions(serviceName, functionName, request, headers, runtime);
}

async function listStatefulAsyncInvocationsWithOptions(serviceName: string, functionName: string, request: ListStatefulAsyncInvocationsRequest, headers: ListStatefulAsyncInvocationsHeaders, runtime: Util.RuntimeOptions): ListStatefulAsyncInvocationsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.includePayload)) {
    query['includePayload'] = request.includePayload;
  }
  if (!Util.isUnset(request.invocationIdPrefix)) {
    query['invocationIdPrefix'] = request.invocationIdPrefix;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.sortOrderByTime)) {
    query['sortOrderByTime'] = request.sortOrderByTime;
  }
  if (!Util.isUnset(request.startedTimeBegin)) {
    query['startedTimeBegin'] = request.startedTimeBegin;
  }
  if (!Util.isUnset(request.startedTimeEnd)) {
    query['startedTimeEnd'] = request.startedTimeEnd;
  }
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcCodeChecksum)) {
    realHeaders['X-Fc-Code-Checksum'] = Util.toJSONString(headers.xFcCodeChecksum);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcInvocationType)) {
    realHeaders['X-Fc-Invocation-Type'] = Util.toJSONString(headers.xFcInvocationType);
  }
  if (!Util.isUnset(headers.xFcLogType)) {
    realHeaders['X-Fc-Log-Type'] = Util.toJSONString(headers.xFcLogType);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListStatefulAsyncInvocations',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/stateful-async-invocations`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTaggedResourcesHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListTaggedResourcesRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
}

model ListTaggedResourcesResponseBody = {
  nextToken?: string(name='nextToken'),
  resources?: [
    Resource
  ](name='resources'),
}

model ListTaggedResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTaggedResourcesResponseBody(name='body'),
}

async function listTaggedResources(request: ListTaggedResourcesRequest): ListTaggedResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListTaggedResourcesHeaders{};
  return listTaggedResourcesWithOptions(request, headers, runtime);
}

async function listTaggedResourcesWithOptions(request: ListTaggedResourcesRequest, headers: ListTaggedResourcesHeaders, runtime: Util.RuntimeOptions): ListTaggedResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTaggedResources',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTriggersHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListTriggersRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  prefix?: string(name='prefix'),
  startKey?: string(name='startKey'),
}

model ListTriggersResponseBody = {
  nextToken?: string(name='nextToken'),
  triggers?: [ 
    {
      createdTime?: string(name='createdTime'),
      description?: string(name='description'),
      domainName?: string(name='domainName'),
      invocationRole?: string(name='invocationRole'),
      lastModifiedTime?: string(name='lastModifiedTime'),
      qualifier?: string(name='qualifier'),
      sourceArn?: string(name='sourceArn'),
      triggerConfig?: string(name='triggerConfig'),
      triggerId?: string(name='triggerId'),
      triggerName?: string(name='triggerName'),
      triggerType?: string(name='triggerType'),
      urlInternet?: string(name='urlInternet'),
      urlIntranet?: string(name='urlIntranet'),
    }
  ](name='triggers'),
}

model ListTriggersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTriggersResponseBody(name='body'),
}

async function listTriggers(serviceName: string, functionName: string, request: ListTriggersRequest): ListTriggersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListTriggersHeaders{};
  return listTriggersWithOptions(serviceName, functionName, request, headers, runtime);
}

async function listTriggersWithOptions(serviceName: string, functionName: string, request: ListTriggersRequest, headers: ListTriggersHeaders, runtime: Util.RuntimeOptions): ListTriggersResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTriggers',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListVpcBindingsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListVpcBindingsResponseBody = {
  vpcIds?: [ string ](name='vpcIds'),
}

model ListVpcBindingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVpcBindingsResponseBody(name='body'),
}

async function listVpcBindings(serviceName: string): ListVpcBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListVpcBindingsHeaders{};
  return listVpcBindingsWithOptions(serviceName, headers, runtime);
}

async function listVpcBindingsWithOptions(serviceName: string, headers: ListVpcBindingsHeaders, runtime: Util.RuntimeOptions): ListVpcBindingsResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'ListVpcBindings',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/bindings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PublishServiceVersionHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model PublishServiceVersionRequest {
  description?: string(name='description'),
}

model PublishServiceVersionResponseBody = {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  versionId?: string(name='versionId'),
}

model PublishServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishServiceVersionResponseBody(name='body'),
}

async function publishServiceVersion(serviceName: string, request: PublishServiceVersionRequest): PublishServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PublishServiceVersionHeaders{};
  return publishServiceVersionWithOptions(serviceName, request, headers, runtime);
}

async function publishServiceVersionWithOptions(serviceName: string, request: PublishServiceVersionRequest, headers: PublishServiceVersionHeaders, runtime: Util.RuntimeOptions): PublishServiceVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PublishServiceVersion',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PutFunctionAsyncInvokeConfigHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model PutFunctionAsyncInvokeConfigRequest {
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts'),
  statefulInvocation?: boolean(name='statefulInvocation'),
  qualifier?: string(name='qualifier'),
}

model PutFunctionAsyncInvokeConfigResponseBody = {
  createdTime?: string(name='createdTime'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  function?: string(name='function'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts'),
  qualifier?: string(name='qualifier'),
  service?: string(name='service'),
  statefulInvocation?: boolean(name='statefulInvocation'),
}

model PutFunctionAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutFunctionAsyncInvokeConfigResponseBody(name='body'),
}

async function putFunctionAsyncInvokeConfig(serviceName: string, functionName: string, request: PutFunctionAsyncInvokeConfigRequest): PutFunctionAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PutFunctionAsyncInvokeConfigHeaders{};
  return putFunctionAsyncInvokeConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function putFunctionAsyncInvokeConfigWithOptions(serviceName: string, functionName: string, request: PutFunctionAsyncInvokeConfigRequest, headers: PutFunctionAsyncInvokeConfigHeaders, runtime: Util.RuntimeOptions): PutFunctionAsyncInvokeConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.destinationConfig)) {
    body['destinationConfig'] = request.destinationConfig;
  }
  if (!Util.isUnset(request.maxAsyncEventAgeInSeconds)) {
    body['maxAsyncEventAgeInSeconds'] = request.maxAsyncEventAgeInSeconds;
  }
  if (!Util.isUnset(request.maxAsyncRetryAttempts)) {
    body['maxAsyncRetryAttempts'] = request.maxAsyncRetryAttempts;
  }
  if (!Util.isUnset(request.statefulInvocation)) {
    body['statefulInvocation'] = request.statefulInvocation;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutFunctionAsyncInvokeConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/async-invoke-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PutFunctionOnDemandConfigHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model PutFunctionOnDemandConfigRequest {
  maximumInstanceCount?: long(name='maximumInstanceCount'),
  qualifier?: string(name='qualifier'),
}

model PutFunctionOnDemandConfigResponseBody = {
  maximumInstanceCount?: long(name='maximumInstanceCount'),
  resource?: string(name='resource'),
}

model PutFunctionOnDemandConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutFunctionOnDemandConfigResponseBody(name='body'),
}

async function putFunctionOnDemandConfig(serviceName: string, functionName: string, request: PutFunctionOnDemandConfigRequest): PutFunctionOnDemandConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PutFunctionOnDemandConfigHeaders{};
  return putFunctionOnDemandConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function putFunctionOnDemandConfigWithOptions(serviceName: string, functionName: string, request: PutFunctionOnDemandConfigRequest, headers: PutFunctionOnDemandConfigHeaders, runtime: Util.RuntimeOptions): PutFunctionOnDemandConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.maximumInstanceCount)) {
    body['maximumInstanceCount'] = request.maximumInstanceCount;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutFunctionOnDemandConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/on-demand-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PutLayerACLHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model PutLayerACLRequest {
  public?: boolean(name='public'),
}

model PutLayerACLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function putLayerACL(layerName: string, request: PutLayerACLRequest): PutLayerACLResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PutLayerACLHeaders{};
  return putLayerACLWithOptions(layerName, request, headers, runtime);
}

async function putLayerACLWithOptions(layerName: string, request: PutLayerACLRequest, headers: PutLayerACLHeaders, runtime: Util.RuntimeOptions): PutLayerACLResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.public)) {
    query['public'] = request.public;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PutLayerACL',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/layers/${OpenApiUtil.getEncodeParam(layerName)}/acl`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model PutProvisionConfigHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model PutProvisionConfigRequest {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU'),
  scheduledActions?: [
    ScheduledActions
  ](name='scheduledActions'),
  target?: long(name='target'),
  targetTrackingPolicies?: [
    TargetTrackingPolicies
  ](name='targetTrackingPolicies'),
  qualifier?: string(name='qualifier'),
}

model PutProvisionConfigResponseBody = {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU'),
  current?: long(name='current'),
  resource?: string(name='resource'),
  scheduledActions?: [
    ScheduledActions
  ](name='scheduledActions'),
  target?: long(name='target'),
  targetTrackingPolicies?: [
    TargetTrackingPolicies
  ](name='targetTrackingPolicies'),
}

model PutProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutProvisionConfigResponseBody(name='body'),
}

async function putProvisionConfig(serviceName: string, functionName: string, request: PutProvisionConfigRequest): PutProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PutProvisionConfigHeaders{};
  return putProvisionConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function putProvisionConfigWithOptions(serviceName: string, functionName: string, request: PutProvisionConfigRequest, headers: PutProvisionConfigHeaders, runtime: Util.RuntimeOptions): PutProvisionConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.alwaysAllocateCPU)) {
    body['alwaysAllocateCPU'] = request.alwaysAllocateCPU;
  }
  if (!Util.isUnset(request.scheduledActions)) {
    body['scheduledActions'] = request.scheduledActions;
  }
  if (!Util.isUnset(request.target)) {
    body['target'] = request.target;
  }
  if (!Util.isUnset(request.targetTrackingPolicies)) {
    body['targetTrackingPolicies'] = request.targetTrackingPolicies;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutProvisionConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/provision-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RegisterEventSourceHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model RegisterEventSourceRequest {
  sourceArn?: string(name='sourceArn'),
  qualifier?: string(name='qualifier'),
}

model RegisterEventSourceResponseBody = {
  createdTime?: string(name='createdTime'),
  sourceArn?: string(name='sourceArn'),
}

model RegisterEventSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterEventSourceResponseBody(name='body'),
}

async function registerEventSource(serviceName: string, functionName: string, request: RegisterEventSourceRequest): RegisterEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new RegisterEventSourceHeaders{};
  return registerEventSourceWithOptions(serviceName, functionName, request, headers, runtime);
}

async function registerEventSourceWithOptions(serviceName: string, functionName: string, request: RegisterEventSourceRequest, headers: RegisterEventSourceHeaders, runtime: Util.RuntimeOptions): RegisterEventSourceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var body : map[string]any = {};
  if (!Util.isUnset(request.sourceArn)) {
    body['sourceArn'] = request.sourceArn;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RegisterEventSource',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/event-sources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ReleaseGPUInstanceHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ReleaseGPUInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function releaseGPUInstance(instanceId: string): ReleaseGPUInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ReleaseGPUInstanceHeaders{};
  return releaseGPUInstanceWithOptions(instanceId, headers, runtime);
}

async function releaseGPUInstanceWithOptions(instanceId: string, headers: ReleaseGPUInstanceHeaders, runtime: Util.RuntimeOptions): ReleaseGPUInstanceResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'ReleaseGPUInstance',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/gpuInstances/${OpenApiUtil.getEncodeParam(instanceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model StopStatefulAsyncInvocationHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model StopStatefulAsyncInvocationRequest {
  qualifier?: string(name='qualifier'),
}

model StopStatefulAsyncInvocationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function stopStatefulAsyncInvocation(serviceName: string, functionName: string, invocationId: string, request: StopStatefulAsyncInvocationRequest): StopStatefulAsyncInvocationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new StopStatefulAsyncInvocationHeaders{};
  return stopStatefulAsyncInvocationWithOptions(serviceName, functionName, invocationId, request, headers, runtime);
}

async function stopStatefulAsyncInvocationWithOptions(serviceName: string, functionName: string, invocationId: string, request: StopStatefulAsyncInvocationRequest, headers: StopStatefulAsyncInvocationHeaders, runtime: Util.RuntimeOptions): StopStatefulAsyncInvocationResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopStatefulAsyncInvocation',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/stateful-async-invocations/${OpenApiUtil.getEncodeParam(invocationId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model TagResourceHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model TagResourceRequest {
  resourceArn?: string(name='resourceArn'),
  tags?: map[string]string(name='tags'),
}

model TagResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function tagResource(request: TagResourceRequest): TagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new TagResourceHeaders{};
  return tagResourceWithOptions(request, headers, runtime);
}

async function tagResourceWithOptions(request: TagResourceRequest, headers: TagResourceHeaders, runtime: Util.RuntimeOptions): TagResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceArn)) {
    body['resourceArn'] = request.resourceArn;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResource',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/tag`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UntagResourceHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model UntagResourceRequest {
  all?: boolean(name='all'),
  resourceArn?: string(name='resourceArn'),
  tagKeys?: [ string ](name='tagKeys'),
}

model UntagResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function untagResource(request: UntagResourceRequest): UntagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UntagResourceHeaders{};
  return untagResourceWithOptions(request, headers, runtime);
}

async function untagResourceWithOptions(request: UntagResourceRequest, headers: UntagResourceHeaders, runtime: Util.RuntimeOptions): UntagResourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.all)) {
    body['all'] = request.all;
  }
  if (!Util.isUnset(request.resourceArn)) {
    body['resourceArn'] = request.resourceArn;
  }
  if (!Util.isUnset(request.tagKeys)) {
    body['tagKeys'] = request.tagKeys;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UntagResource',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/tag`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UpdateAliasHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model UpdateAliasRequest {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  description?: string(name='description'),
  resolvePolicy?: string(name='resolvePolicy'),
  routePolicy?: RoutePolicy(name='routePolicy'),
  versionId?: string(name='versionId'),
}

model UpdateAliasResponseBody = {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight'),
  aliasName?: string(name='aliasName'),
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  versionId?: string(name='versionId'),
}

model UpdateAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAliasResponseBody(name='body'),
}

async function updateAlias(serviceName: string, aliasName: string, request: UpdateAliasRequest): UpdateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UpdateAliasHeaders{};
  return updateAliasWithOptions(serviceName, aliasName, request, headers, runtime);
}

async function updateAliasWithOptions(serviceName: string, aliasName: string, request: UpdateAliasRequest, headers: UpdateAliasHeaders, runtime: Util.RuntimeOptions): UpdateAliasResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.additionalVersionWeight)) {
    body['additionalVersionWeight'] = request.additionalVersionWeight;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.resolvePolicy)) {
    body['resolvePolicy'] = request.resolvePolicy;
  }
  if (!Util.isUnset(request.routePolicy)) {
    body['routePolicy'] = request.routePolicy;
  }
  if (!Util.isUnset(request.versionId)) {
    body['versionId'] = request.versionId;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlias',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/aliases/${OpenApiUtil.getEncodeParam(aliasName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateCustomDomainHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model UpdateCustomDomainRequest {
  certConfig?: CertConfig(name='certConfig'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
}

model UpdateCustomDomainResponseBody = {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime'),
  domainName?: string(name='domainName'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
}

model UpdateCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCustomDomainResponseBody(name='body'),
}

async function updateCustomDomain(domainName: string, request: UpdateCustomDomainRequest): UpdateCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UpdateCustomDomainHeaders{};
  return updateCustomDomainWithOptions(domainName, request, headers, runtime);
}

async function updateCustomDomainWithOptions(domainName: string, request: UpdateCustomDomainRequest, headers: UpdateCustomDomainHeaders, runtime: Util.RuntimeOptions): UpdateCustomDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.certConfig)) {
    body['certConfig'] = request.certConfig;
  }
  if (!Util.isUnset(request.protocol)) {
    body['protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.routeConfig)) {
    body['routeConfig'] = request.routeConfig;
  }
  if (!Util.isUnset(request.tlsConfig)) {
    body['tlsConfig'] = request.tlsConfig;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCustomDomain',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/custom-domains/${OpenApiUtil.getEncodeParam(domainName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateFunctionHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcCodeChecksum?: string(name='X-Fc-Code-Checksum'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model UpdateFunctionRequest {
  instanceConcurrency?: int32(name='InstanceConcurrency'),
  caPort?: int32(name='caPort'),
  code?: Code(name='code'),
  cpu?: float(name='cpu'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customHealthCheckConfig?: CustomHealthCheckConfig(name='customHealthCheckConfig'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  handler?: string(name='handler'),
  initializationTimeout?: int32(name='initializationTimeout'),
  initializer?: string(name='initializer'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
  instanceType?: string(name='instanceType'),
  layers?: [ string ](name='layers'),
  memorySize?: int32(name='memorySize'),
  runtime?: string(name='runtime'),
  timeout?: int32(name='timeout'),
}

model UpdateFunctionResponseBody = {
  caPort?: int32(name='caPort'),
  codeChecksum?: string(name='codeChecksum'),
  codeSize?: long(name='codeSize'),
  cpu?: float(name='cpu'),
  createdTime?: string(name='createdTime'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS'),
  customHealthCheckConfig?: CustomHealthCheckConfig(name='customHealthCheckConfig'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig'),
  description?: string(name='description'),
  diskSize?: int32(name='diskSize'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionId?: string(name='functionId'),
  functionName?: string(name='functionName'),
  handler?: string(name='handler'),
  initializationTimeout?: int32(name='initializationTimeout'),
  initializer?: string(name='initializer'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
  instanceType?: string(name='instanceType'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  layers?: [ string ](name='layers'),
  memorySize?: int32(name='memorySize'),
  runtime?: string(name='runtime'),
  timeout?: int32(name='timeout'),
}

model UpdateFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFunctionResponseBody(name='body'),
}

async function updateFunction(serviceName: string, functionName: string, request: UpdateFunctionRequest): UpdateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UpdateFunctionHeaders{};
  return updateFunctionWithOptions(serviceName, functionName, request, headers, runtime);
}

async function updateFunctionWithOptions(serviceName: string, functionName: string, request: UpdateFunctionRequest, headers: UpdateFunctionHeaders, runtime: Util.RuntimeOptions): UpdateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceConcurrency)) {
    body['InstanceConcurrency'] = request.instanceConcurrency;
  }
  if (!Util.isUnset(request.caPort)) {
    body['caPort'] = request.caPort;
  }
  if (!Util.isUnset(request.code)) {
    body['code'] = request.code;
  }
  if (!Util.isUnset(request.cpu)) {
    body['cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.customContainerConfig)) {
    body['customContainerConfig'] = request.customContainerConfig;
  }
  if (!Util.isUnset(request.customDNS)) {
    body['customDNS'] = request.customDNS;
  }
  if (!Util.isUnset(request.customHealthCheckConfig)) {
    body['customHealthCheckConfig'] = request.customHealthCheckConfig;
  }
  if (!Util.isUnset(request.customRuntimeConfig)) {
    body['customRuntimeConfig'] = request.customRuntimeConfig;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.diskSize)) {
    body['diskSize'] = request.diskSize;
  }
  if (!Util.isUnset(request.environmentVariables)) {
    body['environmentVariables'] = request.environmentVariables;
  }
  if (!Util.isUnset(request.handler)) {
    body['handler'] = request.handler;
  }
  if (!Util.isUnset(request.initializationTimeout)) {
    body['initializationTimeout'] = request.initializationTimeout;
  }
  if (!Util.isUnset(request.initializer)) {
    body['initializer'] = request.initializer;
  }
  if (!Util.isUnset(request.instanceLifecycleConfig)) {
    body['instanceLifecycleConfig'] = request.instanceLifecycleConfig;
  }
  if (!Util.isUnset(request.instanceSoftConcurrency)) {
    body['instanceSoftConcurrency'] = request.instanceSoftConcurrency;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['instanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.layers)) {
    body['layers'] = request.layers;
  }
  if (!Util.isUnset(request.memorySize)) {
    body['memorySize'] = request.memorySize;
  }
  if (!Util.isUnset(request.runtime)) {
    body['runtime'] = request.runtime;
  }
  if (!Util.isUnset(request.timeout)) {
    body['timeout'] = request.timeout;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcCodeChecksum)) {
    realHeaders['X-Fc-Code-Checksum'] = Util.toJSONString(headers.xFcCodeChecksum);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFunction',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model UpdateServiceRequest {
  description?: string(name='description'),
  internetAccess?: boolean(name='internetAccess'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model UpdateServiceResponseBody = {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  internetAccess?: boolean(name='internetAccess'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  ossMountConfig?: OSSMountConfig(name='ossMountConfig'),
  role?: string(name='role'),
  serviceId?: string(name='serviceId'),
  serviceName?: string(name='serviceName'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model UpdateServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceResponseBody(name='body'),
}

async function updateService(serviceName: string, request: UpdateServiceRequest): UpdateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UpdateServiceHeaders{};
  return updateServiceWithOptions(serviceName, request, headers, runtime);
}

async function updateServiceWithOptions(serviceName: string, request: UpdateServiceRequest, headers: UpdateServiceHeaders, runtime: Util.RuntimeOptions): UpdateServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.internetAccess)) {
    body['internetAccess'] = request.internetAccess;
  }
  if (!Util.isUnset(request.logConfig)) {
    body['logConfig'] = request.logConfig;
  }
  if (!Util.isUnset(request.nasConfig)) {
    body['nasConfig'] = request.nasConfig;
  }
  if (!Util.isUnset(request.ossMountConfig)) {
    body['ossMountConfig'] = request.ossMountConfig;
  }
  if (!Util.isUnset(request.role)) {
    body['role'] = request.role;
  }
  if (!Util.isUnset(request.tracingConfig)) {
    body['tracingConfig'] = request.tracingConfig;
  }
  if (!Util.isUnset(request.vpcConfig)) {
    body['vpcConfig'] = request.vpcConfig;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateService',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateTriggerHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model UpdateTriggerRequest {
  description?: string(name='description'),
  invocationRole?: string(name='invocationRole'),
  qualifier?: string(name='qualifier'),
  triggerConfig?: string(name='triggerConfig'),
}

model UpdateTriggerResponseBody = {
  createdTime?: string(name='createdTime'),
  description?: string(name='description'),
  domainName?: string(name='domainName'),
  invocationRole?: string(name='invocationRole'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  qualifier?: string(name='qualifier'),
  sourceArn?: string(name='sourceArn'),
  triggerConfig?: string(name='triggerConfig'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName'),
  triggerType?: string(name='triggerType'),
  urlInternet?: string(name='urlInternet'),
  urlIntranet?: string(name='urlIntranet'),
}

model UpdateTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTriggerResponseBody(name='body'),
}

async function updateTrigger(serviceName: string, functionName: string, triggerName: string, request: UpdateTriggerRequest): UpdateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UpdateTriggerHeaders{};
  return updateTriggerWithOptions(serviceName, functionName, triggerName, request, headers, runtime);
}

async function updateTriggerWithOptions(serviceName: string, functionName: string, triggerName: string, request: UpdateTriggerRequest, headers: UpdateTriggerHeaders, runtime: Util.RuntimeOptions): UpdateTriggerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.invocationRole)) {
    body['invocationRole'] = request.invocationRole;
  }
  if (!Util.isUnset(request.qualifier)) {
    body['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.triggerConfig)) {
    body['triggerConfig'] = request.triggerConfig;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrigger',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${OpenApiUtil.getEncodeParam(serviceName)}/functions/${OpenApiUtil.getEncodeParam(functionName)}/triggers/${OpenApiUtil.getEncodeParam(triggerName)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

