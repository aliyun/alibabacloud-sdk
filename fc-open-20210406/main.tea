/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'account-id.ap-northeast-1.fc.aliyuncs.com',
    ap-south-1 = 'account-id.ap-south-1.fc.aliyuncs.com',
    ap-southeast-1 = 'account-id.ap-southeast-1.fc.aliyuncs.com',
    ap-southeast-2 = 'account-id.ap-southeast-2.fc.aliyuncs.com',
    ap-southeast-3 = 'account-id.ap-southeast-3.fc.aliyuncs.com',
    ap-southeast-5 = 'account-id.ap-southeast-5.fc.aliyuncs.com',
    cn-beijing = 'account-id.cn-beijing.fc.aliyuncs.com',
    cn-chengdu = 'account-id.cn-chengdu.fc.aliyuncs.com',
    cn-hangzhou = 'account-id.cn-hangzhou.fc.aliyuncs.com',
    cn-hangzhou-finance = 'account-id.cn-hangzhou-finance.fc.aliyuncs.com',
    cn-hongkong = 'account-id.cn-hongkong.fc.aliyuncs.com',
    cn-huhehaote = 'account-id.cn-huhehaote.fc.aliyuncs.com',
    cn-north-2-gov-1 = 'account-id.cn-north-2-gov-1.fc.aliyuncs.com',
    cn-qingdao = 'account-id.cn-qingdao.fc.aliyuncs.com',
    cn-shanghai = 'account-id.cn-shanghai.fc.aliyuncs.com',
    cn-shenzhen = 'account-id.cn-shenzhen.fc.aliyuncs.com',
    cn-zhangjiakou = 'account-id.cn-zhangjiakou.fc.aliyuncs.com',
    eu-central-1 = 'account-id.eu-central-1.fc.aliyuncs.com',
    eu-west-1 = 'account-id.eu-west-1.fc.aliyuncs.com',
    us-east-1 = 'account-id.us-east-1.fc.aliyuncs.com',
    us-west-1 = 'account-id.us-west-1.fc.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('fc-open', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AccelerationInfo {
  status?: string(name='status', description='镜像加速状态，取值 Preparing 或 Ready'),
}

model AsyncConfigMeta {
  functionName?: string(name='functionName', description='异步配置所属函数名称。'),
  qualifier?: string(name='qualifier', description='异步配置所属服务版本/别名。'),
  serviceName?: string(name='serviceName', description='异步配置所属服务名称。'),
}

model AvailableAZ {
  availableAZs?: string(name='availableAZs', description='az'),
}

model CDNEventsTriggerConfig {
  eventName?: string(name='eventName', description='eventName'),
  eventVersion?: string(name='eventVersion', description='eventVersion'),
  filter?: map[string][ string ](name='filter', description='filter'),
  notes?: string(name='notes', description='notes'),
}

model CertConfig {
  certName?: string(name='certName', description='证书名称'),
  certificate?: string(name='certificate', description='证书，如果是证书链则依次填写多个证书'),
  privateKey?: string(name='privateKey', description='私钥'),
}

model Code {
  ossBucketName?: string(name='ossBucketName', description='函数代码包的OSS bucket name'),
  ossObjectName?: string(name='ossObjectName', description='函数代码包的OSS对象名'),
  zipFile?: string(name='zipFile', description='直接在request body中上传code zip包的base64编码'),
}

model CustomContainerConfig {
  accelerationType?: string(name='accelerationType', description='镜像加速类型，取值Default为开启加速，None为关闭加速，默认开启'),
  args?: string(name='args', description='容器启动参数'),
  command?: string(name='command', description='容器启动命令，等同于 Docker ENTRYPOINT'),
  image?: string(name='image', description='容器镜像地址，实例值： registry-vpc.cn-hangzhou.aliyuncs.com/fc-demo/helloworld:v1beta1'),
  instanceID?: string(name='instanceID', description='ACR企业版镜像仓库ID，使用ACR企业版镜像时须传入'),
}

model CustomContainerConfigInfo {
  accelerationInfo?: AccelerationInfo(name='accelerationInfo'),
  accelerationType?: string(name='accelerationType', description='镜像加速类型，取值Default为开启加速，None为关闭加速，默认开启'),
  args?: string(name='args', description='容器启动参数'),
  command?: string(name='command', description='容器启动命令，等同于 Docker ENTRYPOINT'),
  image?: string(name='image', description='容器镜像地址，实例值： registry-vpc.cn-hangzhou.aliyuncs.com/fc-demo/helloworld:v1beta1'),
  instanceID?: string(name='instanceID', description='ACR企业版镜像仓库ID，使用ACR企业版镜像时须传入'),
}

model CustomDNS {
  dnsOptions?: [
    DNSOption
  ](name='dnsOptions', description='DNS resolver 配置参数列表'),
  nameServers?: [ string ](name='nameServers', description='DNS 服务器的 IP 地址列表'),
  searches?: [ string ](name='searches', description='DNS 搜索域的列表'),
}

model CustomRuntimeConfig {
  args?: [ string ](name='args', description='启动入口命令接收的参数'),
  command?: [ string ](name='command', description='启动入口命令'),
}

model DNSOption {
  name?: string(name='name', description='DNS option 名称'),
  value?: string(name='value', description='DNS option 值'),
}

model Destination {
  destination?: string(name='destination', description='destination'),
}

model DestinationConfig {
  onFailure?: Destination(name='onFailure'),
  onSuccess?: Destination(name='onSuccess'),
}

model Error {
  errorCode?: string(name='errorCode', description='错误码'),
  errorMessage?: string(name='errorMessage', description='错误信息描述'),
}

model ErrorInfo {
  errorMessage?: string(name='errorMessage', description='错误信息'),
  stackTrace?: string(name='stackTrace', description='错误堆栈'),
}

model EventBridgeTriggerConfig {
  asyncInvocationType?: boolean(name='asyncInvocationType', description='asyncInvocationType'),
  eventRuleFilterPattern?: string(name='eventRuleFilterPattern', description='eventRuleFilterPattern'),
  eventSourceConfig?: EventSourceConfig(name='eventSourceConfig'),
  triggerEnable?: boolean(name='triggerEnable', description='triggerEnable'),
}

model EventSourceConfig {
  eventSourceParameters?: EventSourceParameters(name='eventSourceParameters'),
  eventSourceType?: string(name='eventSourceType', description='eventSourceType'),
}

model EventSourceParameters {
  sourceMNSParameters?: SourceMNSParameters(name='sourceMNSParameters'),
  sourceRabbitMQParameters?: SourceRabbitMQParameters(name='sourceRabbitMQParameters'),
  sourceRocketMQParameters?: SourceRocketMQParameters(name='sourceRocketMQParameters'),
}

model HTTPTriggerConfig {
  authType?: string(name='authType', description='认证类型'),
  methods?: [ string ](name='methods', description='允许的HTTP方法列表'),
}

model InstanceLifecycleConfig {
  preFreeze?: LifecycleHook(name='preFreeze'),
  preStop?: LifecycleHook(name='preStop'),
}

model JaegerConfig {
  endpoint?: string(name='endpoint', description='endpoint'),
}

model JobConfig {
  maxRetryTime?: long(name='maxRetryTime', description='maxRetryTime'),
  triggerInterval?: long(name='triggerInterval', description='triggerInterval'),
}

model JobLogConfig {
  logstore?: string(name='logstore', description='logstore'),
  project?: string(name='project', description='project'),
}

model Layer {
  acl?: int32(name='acl', description='层访问类型'),
  arn?: string(name='arn', description='arn'),
  code?: LayerCode(name='code', description='层代码'),
  codeChecksum?: string(name='codeChecksum', description='层Checksum'),
  codeSize?: long(name='codeSize', description='层代码大小'),
  compatibleRuntime?: [ string ](name='compatibleRuntime', description='compatibleRuntime'),
  createTime?: string(name='createTime', description='层创建时间'),
  description?: string(name='description', description='层描述'),
  layerName?: string(name='layerName', description='层名称'),
  version?: int32(name='version', description='层版本'),
}

model LayerCode {
  location?: string(name='location', description='层代码位置'),
  repositoryType?: string(name='repositoryType', description='层代码类型'),
}

model LifecycleHook {
  handler?: string(name='handler', description='handler name'),
  timeout?: int32(name='timeout', description='timeout in second'),
}

model LogConfig {
  enableInstanceMetrics?: boolean(name='enableInstanceMetrics', description='开启实例级别指标'),
  enableRequestMetrics?: boolean(name='enableRequestMetrics', description='开启请求级别指标'),
  logBeginRule?: string(name='logBeginRule', description='日志切分规则'),
  logstore?: string(name='logstore', description='日志库'),
  project?: string(name='project', description='日志项目'),
}

model LogTriggerConfig {
  enable?: boolean(name='enable', description='enable'),
  functionParameter?: map[string]string(name='functionParameter', description='functionParameter'),
  jobConfig?: JobConfig(name='jobConfig'),
  logConfig?: JobLogConfig(name='logConfig'),
  sourceConfig?: SourceConfig(name='sourceConfig'),
}

model MeteringConfig {
  logConfig?: LogConfig(name='logConfig', description='日志仓库'),
  payerId?: string(name='payerId', description='支付用户'),
  role?: string(name='role', description='权限'),
}

model MnsTopicTriggerConfig {
  filterTag?: string(name='filterTag', description='filterTag'),
  notifyContentFormat?: string(name='notifyContentFormat', description='notifyContentFormat'),
  notifyStrategy?: string(name='notifyStrategy', description='notifyStrategy'),
}

model NASConfig {
  groupId?: int32(name='groupId', description='groupID'),
  mountPoints?: [ 
    {
      mountDir?: string(name='mountDir', description='本地挂载目录'),
      serverAddr?: string(name='serverAddr', description='NAS服务器地址'),
    }
  ](name='mountPoints', description='挂载点'),
  userId?: int32(name='userId', description='userID'),
}

model OSSTriggerConfig {
  events?: [ string ](name='events', description='events'),
  filter?: OSSTriggerFilter(name='filter'),
}

model OSSTriggerFilter {
  key?: OSSTriggerKey(name='key'),
}

model OSSTriggerKey {
  prefix?: string(name='prefix', description='prefix'),
  suffix?: string(name='suffix', description='suffix'),
}

model OnDemandConfig {
  maximumInstanceCount?: long(name='maximumInstanceCount', description='todo'),
  resource?: string(name='resource', description='函数详情'),
}

model OpenReservedCapacity {
  createdTime?: string(name='createdTime', description='createdTime'),
  cu?: long(name='cu', description='cu'),
  deadline?: string(name='deadline', description='deadline'),
  instanceId?: string(name='instanceId', description='instanceId'),
  isRefunded?: string(name='isRefunded', description='isRefunded'),
  lastModifiedTime?: string(name='lastModifiedTime', description='lastModifiedTime'),
}

model OutputCodeLocation {
  location?: string(name='location', description='location'),
  repositoryType?: string(name='repositoryType', description='repositoryType'),
}

model PathConfig {
  functionName?: string(name='functionName', description='该路径/方法对应的函数名称'),
  methods?: [ string ](name='methods', description='请求方法，不填表示当前路径的所有方法匹配同一函数'),
  path?: string(name='path', description='请求路径'),
  qualifier?: string(name='qualifier', description='该路径/方法对应服务的版本/别名'),
  serviceName?: string(name='serviceName', description='该路径/方法对应的服务名称'),
}

model PreFreeze {
  handler?: string(name='handler', description='preFreeze handler name'),
  timeout?: int32(name='timeout', description='handler timeout'),
}

model PreStop {
  handler?: string(name='handler', description='PreStop handler'),
  timeout?: int32(name='timeout', description='PreStop hander timeout'),
}

model RdsTriggerConfig {
  concurrency?: long(name='concurrency', description='concurrency'),
  eventFormat?: string(name='eventFormat', description='eventFormat'),
  retry?: long(name='retry', description='retry'),
  subscriptionObjects?: [ string ](name='subscriptionObjects', description='subscriptionObjects'),
}

model Resource {
  resourceArn?: string(name='resourceArn', description='resourceArn'),
  tags?: map[string]string(name='tags', description='tags'),
}

model RouteConfig {
  routes?: [
    PathConfig
  ](name='routes', description='routes'),
}

model ScheduledActions {
  endTime?: string(name='endTime', description='endTime'),
  name?: string(name='name', description='name'),
  scheduleExpression?: string(name='scheduleExpression', description='scheduleExpression'),
  startTime?: string(name='startTime', description='startTime'),
  target?: long(name='target', description='target'),
}

model SourceConfig {
  logstore?: string(name='logstore', description='logstore'),
}

model SourceMNSParameters {
  isBase64Decode?: boolean(name='IsBase64Decode', description='IsBase64Decode'),
  queueName?: string(name='QueueName', description='QueueName'),
  regionId?: string(name='RegionId', description='RegionId'),
}

model SourceRabbitMQParameters {
  instanceId?: string(name='InstanceId', description='InstanceId'),
  queueName?: string(name='QueueName', description='QueueName'),
  regionId?: string(name='RegionId', description='RegionId'),
  virtualHostName?: string(name='VirtualHostName', description='VirtualHostName'),
}

model SourceRocketMQParameters {
  groupID?: string(name='GroupID', description='GroupID'),
  instanceId?: string(name='InstanceId', description='InstanceId'),
  offset?: string(name='Offset', description='Offset'),
  regionId?: string(name='RegionId', description='RegionId'),
  tag?: string(name='Tag', description='Tag'),
  timestamp?: long(name='Timestamp', description='Timestamp'),
  topic?: string(name='Topic', description='Topic'),
}

model StatefulAsyncInvocation {
  alreadyRetriedTimes?: long(name='alreadyRetriedTimes', description='异步任务调用失败后的已重试次数。'),
  destinationStatus?: string(name='destinationStatus', description='异步任务的目的状态。'),
  endTime?: long(name='endTime', description='异步任务的结束时间。'),
  events?: [
    StatefulAsyncInvocationEvent
  ](name='events', description='异步任务事件列表。'),
  functionName?: string(name='functionName', description='异步任务所属的函数的名称。'),
  instanceId?: string(name='instanceId', description='异步任务的执行实例ID。'),
  invocationErrorMessage?: string(name='invocationErrorMessage', description='异步任务的错误消息。'),
  invocationId?: string(name='invocationId', description='异步任务ID。'),
  invocationPayload?: string(name='invocationPayload', description='异步任务的任务触发事件。'),
  qualifier?: string(name='qualifier', description='异步任务所属的服务的别名或版本。'),
  requestId?: string(name='requestId', description='异步任务的请求ID。'),
  serviceName?: string(name='serviceName', description='异步任务所属的服务的名称。'),
  startedTime?: long(name='startedTime', description='异步任务的开始时间。'),
  status?: string(name='status', description='异步任务的执行状态。      Enqueued：异步消息已入队，等待处理。      Succeeded：调用执行成功。      Failed：调用执行失败。      Running：调用执行中。      Stopped：调用执行终止。      Stopping：执行停止中。      Invalid：您的执行因函数被删除等原因处于无效状态（任务未被执行）。      Expired：您为任务配置了最长排队等待的期限。该任务因为超期被丢弃（任务未被执行）。      Retrying：异步调用因执行错误重试中。'),
}

model StatefulAsyncInvocationEvent {
  eventDetail?: string(name='eventDetail', description='事件详细数据。'),
  eventId?: long(name='eventId', description='事件ID。'),
  status?: string(name='status', description='事件执行状态。'),
  timestamp?: long(name='timestamp', description='事件时间。'),
}

model TLSConfig {
  cipherSuites?: [ string ](name='cipherSuites', description='TLS加密套件列表'),
  maxVersion?: string(name='maxVersion', description='TLS最大版本号'),
  minVersion?: string(name='minVersion', description='TLS最小版本号'),
}

model TargetTrackingPolicies {
  endTime?: string(name='endTime', description='endTime'),
  maxCapacity?: long(name='maxCapacity', description='maxCapacity'),
  metricTarget?: double(name='metricTarget', description='metricTarget'),
  metricType?: string(name='metricType', description='metricType'),
  minCapacity?: long(name='minCapacity', description='minCapacity'),
  name?: string(name='name', description='name'),
  startTime?: string(name='startTime', description='startTime'),
}

model TimeTriggerConfig {
  cronExpression?: string(name='cronExpression', description='cronExpression'),
  enable?: boolean(name='enable', description='enable'),
  payload?: string(name='payload', description='payload'),
}

model TracingConfig {
  params?: map[string]string(name='params', description='链路追踪参数。当协议类型为 Jaeger 时，参数为 map[string]string，其中 key 为 "endpoint"，value 为您的链路追踪内网接入点。例如 endpoint: http://tracing-analysis-dc-hz.aliyuncs.com/adapt_xxx/api/otlp/traces'),
  type?: string(name='type', description='链路追踪协议类型，目前只支持 Jaeger'),
}

model VPCConfig {
  role?: string(name='role', description='Role'),
  securityGroupId?: string(name='securityGroupId', description='安全组ID'),
  vSwitchIds?: [ string ](name='vSwitchIds', description='VSwitch ID列表'),
  vpcId?: string(name='vpcId', description='VPC ID'),
}

model VendorConfig {
  meteringConfig?: MeteringConfig(name='meteringConfig'),
}

model CreateAliasHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model CreateAliasRequest {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
  aliasName?: string(name='aliasName', description='别名名称'),
  description?: string(name='description', description='别名描述'),
  versionId?: string(name='versionId', description='版本ID'),
}

model CreateAliasResponseBody = {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
  aliasName?: string(name='aliasName', description='别名名称'),
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='别名描述'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  versionId?: string(name='versionId', description='版本ID'),
}

model CreateAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAliasResponseBody(name='body'),
}

async function createAlias(serviceName: string, request: CreateAliasRequest): CreateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateAliasHeaders{};
  return createAliasWithOptions(serviceName, request, headers, runtime);
}

async function createAliasWithOptions(serviceName: string, request: CreateAliasRequest, headers: CreateAliasHeaders, runtime: Util.RuntimeOptions): CreateAliasResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.additionalVersionWeight)) {
    body['additionalVersionWeight'] = request.additionalVersionWeight;
  }
  if (!Util.isUnset(request.aliasName)) {
    body['aliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.versionId)) {
    body['versionId'] = request.versionId;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAlias',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/aliases`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateCustomDomainHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model CreateCustomDomainRequest {
  certConfig?: CertConfig(name='certConfig'),
  domainName?: string(name='domainName'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
}

model CreateCustomDomainResponseBody = {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime'),
  domainName?: string(name='domainName', description='Id of the request'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
}

model CreateCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCustomDomainResponseBody(name='body'),
}

async function createCustomDomain(request: CreateCustomDomainRequest): CreateCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateCustomDomainHeaders{};
  return createCustomDomainWithOptions(request, headers, runtime);
}

async function createCustomDomainWithOptions(request: CreateCustomDomainRequest, headers: CreateCustomDomainHeaders, runtime: Util.RuntimeOptions): CreateCustomDomainResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.certConfig)) {
    body['certConfig'] = request.certConfig;
  }
  if (!Util.isUnset(request.domainName)) {
    body['domainName'] = request.domainName;
  }
  if (!Util.isUnset(request.protocol)) {
    body['protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.routeConfig)) {
    body['routeConfig'] = request.routeConfig;
  }
  if (!Util.isUnset(request.tlsConfig)) {
    body['tlsConfig'] = request.tlsConfig;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCustomDomain',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/custom-domains`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateFunctionHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcCodeChecksum?: string(name='X-Fc-Code-Checksum'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model CreateFunctionRequest {
  caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
  code?: Code(name='code'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS', description='函数自定义DNS配置'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig', description='Custom Runtime函数详细配置'),
  description?: string(name='description', description='函数描述'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionName?: string(name='functionName', description='函数名称'),
  handler?: string(name='handler', description='function执行的入口，具体格式和语言相关'),
  initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
  initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
  instanceType?: string(name='instanceType'),
  layers?: [ string ](name='layers', description='层列表'),
  memorySize?: int32(name='memorySize', description='function的内存规格，单位为MB，为64MB的倍数'),
  runtime?: string(name='runtime', description='function运行的语言环境，目前支持nodejs6, nodejs8, python2.7, python3, java8'),
  timeout?: int32(name='timeout', description='function运行的超时时间，单位为秒，最小1秒，默认3秒。function超过这个时间后会被终止执行'),
}

model CreateFunctionResponseBody = {
  caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
  codeChecksum?: string(name='codeChecksum', description='function code包的CRC64值'),
  codeSize?: long(name='codeSize', description='系统返回的function的code包大小，单位为byte Example : 1024'),
  createdTime?: string(name='createdTime', description='function创建时间'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS', description='函数自定义DNS配置'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig', description='Custom Runtime函数详细配置'),
  description?: string(name='description', description='函数描述'),
  environmentVariables?: map[string]string(name='environmentVariables'),
  functionId?: string(name='functionId', description='系统为每个function生成的唯一ID'),
  functionName?: string(name='functionName', description='函数名称'),
  handler?: string(name='handler', description='function的执行入口'),
  initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
  initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
  instanceType?: string(name='instanceType'),
  lastModifiedTime?: string(name='lastModifiedTime', description='function上次修改时间'),
  layers?: [ string ](name='layers'),
  memorySize?: int32(name='memorySize', description='function设置的内存大小，单位为MB'),
  runtime?: string(name='runtime', description='function运行的语言环境，目前支持nodejs6, nodejs8, python2.7, python3, java8'),
  timeout?: int32(name='timeout', description='运行的超时时间，单位为秒'),
}

model CreateFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFunctionResponseBody(name='body'),
}

async function createFunction(serviceName: string, request: CreateFunctionRequest): CreateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateFunctionHeaders{};
  return createFunctionWithOptions(serviceName, request, headers, runtime);
}

async function createFunctionWithOptions(serviceName: string, request: CreateFunctionRequest, headers: CreateFunctionHeaders, runtime: Util.RuntimeOptions): CreateFunctionResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.caPort)) {
    body['caPort'] = request.caPort;
  }
  if (!Util.isUnset(request.code)) {
    body['code'] = request.code;
  }
  if (!Util.isUnset(request.customContainerConfig)) {
    body['customContainerConfig'] = request.customContainerConfig;
  }
  if (!Util.isUnset(request.customDNS)) {
    body['customDNS'] = request.customDNS;
  }
  if (!Util.isUnset(request.customRuntimeConfig)) {
    body['customRuntimeConfig'] = request.customRuntimeConfig;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.environmentVariables)) {
    body['environmentVariables'] = request.environmentVariables;
  }
  if (!Util.isUnset(request.functionName)) {
    body['functionName'] = request.functionName;
  }
  if (!Util.isUnset(request.handler)) {
    body['handler'] = request.handler;
  }
  if (!Util.isUnset(request.initializationTimeout)) {
    body['initializationTimeout'] = request.initializationTimeout;
  }
  if (!Util.isUnset(request.initializer)) {
    body['initializer'] = request.initializer;
  }
  if (!Util.isUnset(request.instanceConcurrency)) {
    body['instanceConcurrency'] = request.instanceConcurrency;
  }
  if (!Util.isUnset(request.instanceLifecycleConfig)) {
    body['instanceLifecycleConfig'] = request.instanceLifecycleConfig;
  }
  if (!Util.isUnset(request.instanceSoftConcurrency)) {
    body['instanceSoftConcurrency'] = request.instanceSoftConcurrency;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['instanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.layers)) {
    body['layers'] = request.layers;
  }
  if (!Util.isUnset(request.memorySize)) {
    body['memorySize'] = request.memorySize;
  }
  if (!Util.isUnset(request.runtime)) {
    body['runtime'] = request.runtime;
  }
  if (!Util.isUnset(request.timeout)) {
    body['timeout'] = request.timeout;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcCodeChecksum)) {
    realHeaders['X-Fc-Code-Checksum'] = Util.toJSONString(headers.xFcCodeChecksum);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFunction',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateLayerVersionHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model CreateLayerVersionRequest {
  code?: Code(name='Code'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  description?: string(name='description'),
}

model CreateLayerVersionResponseBody = {
  acl?: int32(name='acl'),
  arn?: string(name='arn'),
  code?: OutputCodeLocation(name='code'),
  codeChecksum?: string(name='codeChecksum'),
  codesize?: long(name='codesize'),
  compatibleRuntime?: [ string ](name='compatibleRuntime'),
  createTime?: string(name='createTime'),
  description?: string(name='description'),
  layerName?: string(name='layerName'),
  version?: int32(name='version'),
}

model CreateLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLayerVersionResponseBody(name='body'),
}

async function createLayerVersion(layerName: string, request: CreateLayerVersionRequest): CreateLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateLayerVersionHeaders{};
  return createLayerVersionWithOptions(layerName, request, headers, runtime);
}

async function createLayerVersionWithOptions(layerName: string, request: CreateLayerVersionRequest, headers: CreateLayerVersionHeaders, runtime: Util.RuntimeOptions): CreateLayerVersionResponse {
  Util.validateModel(request);
  layerName = OpenApiUtil.getEncodeParam(layerName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.code)) {
    body['Code'] = request.code;
  }
  if (!Util.isUnset(request.compatibleRuntime)) {
    body['compatibleRuntime'] = request.compatibleRuntime;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLayerVersion',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/layers/${layerName}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateServiceHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model CreateServiceRequest {
  description?: string(name='description', description='服务描述'),
  internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  role?: string(name='role', description='服务角色'),
  serviceName?: string(name='serviceName', description='服务名称'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model CreateServiceResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='服务描述'),
  internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  role?: string(name='role', description='服务角色'),
  serviceId?: string(name='serviceId', description='服务ID'),
  serviceName?: string(name='serviceName', description='服务名称'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vendorConfig?: VendorConfig(name='vendorConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model CreateServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceResponseBody(name='body'),
}

async function createService(request: CreateServiceRequest): CreateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateServiceHeaders{};
  return createServiceWithOptions(request, headers, runtime);
}

async function createServiceWithOptions(request: CreateServiceRequest, headers: CreateServiceHeaders, runtime: Util.RuntimeOptions): CreateServiceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.internetAccess)) {
    body['internetAccess'] = request.internetAccess;
  }
  if (!Util.isUnset(request.logConfig)) {
    body['logConfig'] = request.logConfig;
  }
  if (!Util.isUnset(request.nasConfig)) {
    body['nasConfig'] = request.nasConfig;
  }
  if (!Util.isUnset(request.role)) {
    body['role'] = request.role;
  }
  if (!Util.isUnset(request.serviceName)) {
    body['serviceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.tracingConfig)) {
    body['tracingConfig'] = request.tracingConfig;
  }
  if (!Util.isUnset(request.vpcConfig)) {
    body['vpcConfig'] = request.vpcConfig;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateService',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateTriggerHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model CreateTriggerRequest {
  description?: string(name='description'),
  invocationRole?: string(name='invocationRole', description='event source，如OSS，使用该role去invoke function'),
  qualifier?: string(name='qualifier', description='service版本'),
  sourceArn?: string(name='sourceArn', description='event source的Aliyun Resource Name（ARN'),
  triggerConfig?: string(name='triggerConfig', description='trigger配置，针对不同的trigger类型，trigger配置会有所不同'),
  triggerName?: string(name='triggerName', description='trigger名称'),
  triggerType?: string(name='triggerType', description='trigger类型，如 oss, log, tablestore, timer, http, cdn_events, mns_topic'),
}

model CreateTriggerResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description'),
  domainName?: string(name='domainName', description='域名名称，使用域名名称拼接上函数计算域名，可以采用HTTP协议调用到触发器对应版本的函数。例如{domainName}.cn-shanghai.fc.aliyuncs.com'),
  invocationRole?: string(name='invocationRole', description='调用函数使用的RAM角色的ARN'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次修改时间'),
  qualifier?: string(name='qualifier', description='service版本'),
  sourceArn?: string(name='sourceArn', description='event source的Aliyun Resource Name（ARN'),
  triggerConfig?: string(name='triggerConfig', description='trigger配置对象'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName', description='trigger名称'),
  triggerType?: string(name='triggerType', description='trigger类型，如 oss, log, tablestore, timer, http, cdn_events, mns_topic'),
  urlInternet?: string(name='urlInternet', description='公网域名地址。在互联网可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
  urlIntranet?: string(name='urlIntranet', description='私网域名地址。在VPC可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
}

model CreateTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTriggerResponseBody(name='body'),
}

async function createTrigger(serviceName: string, functionName: string, request: CreateTriggerRequest): CreateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateTriggerHeaders{};
  return createTriggerWithOptions(serviceName, functionName, request, headers, runtime);
}

async function createTriggerWithOptions(serviceName: string, functionName: string, request: CreateTriggerRequest, headers: CreateTriggerHeaders, runtime: Util.RuntimeOptions): CreateTriggerResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.invocationRole)) {
    body['invocationRole'] = request.invocationRole;
  }
  if (!Util.isUnset(request.qualifier)) {
    body['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.sourceArn)) {
    body['sourceArn'] = request.sourceArn;
  }
  if (!Util.isUnset(request.triggerConfig)) {
    body['triggerConfig'] = request.triggerConfig;
  }
  if (!Util.isUnset(request.triggerName)) {
    body['triggerName'] = request.triggerName;
  }
  if (!Util.isUnset(request.triggerType)) {
    body['triggerType'] = request.triggerType;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTrigger',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/triggers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateVpcBindingHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model CreateVpcBindingRequest {
  vpcId?: string(name='vpcId'),
}

model CreateVpcBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createVpcBinding(serviceName: string, request: CreateVpcBindingRequest): CreateVpcBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateVpcBindingHeaders{};
  return createVpcBindingWithOptions(serviceName, request, headers, runtime);
}

async function createVpcBindingWithOptions(serviceName: string, request: CreateVpcBindingRequest, headers: CreateVpcBindingHeaders, runtime: Util.RuntimeOptions): CreateVpcBindingResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.vpcId)) {
    body['vpcId'] = request.vpcId;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVpcBinding',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/bindings`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteAliasHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteAlias(serviceName: string, aliasName: string): DeleteAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteAliasHeaders{};
  return deleteAliasWithOptions(serviceName, aliasName, headers, runtime);
}

async function deleteAliasWithOptions(serviceName: string, aliasName: string, headers: DeleteAliasHeaders, runtime: Util.RuntimeOptions): DeleteAliasResponse {
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  aliasName = OpenApiUtil.getEncodeParam(aliasName);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteAlias',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/aliases/${aliasName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteCustomDomainHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteCustomDomain(domainName: string): DeleteCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteCustomDomainHeaders{};
  return deleteCustomDomainWithOptions(domainName, headers, runtime);
}

async function deleteCustomDomainWithOptions(domainName: string, headers: DeleteCustomDomainHeaders, runtime: Util.RuntimeOptions): DeleteCustomDomainResponse {
  domainName = OpenApiUtil.getEncodeParam(domainName);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomDomain',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/custom-domains/${domainName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteFunctionHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteFunction(serviceName: string, functionName: string): DeleteFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteFunctionHeaders{};
  return deleteFunctionWithOptions(serviceName, functionName, headers, runtime);
}

async function deleteFunctionWithOptions(serviceName: string, functionName: string, headers: DeleteFunctionHeaders, runtime: Util.RuntimeOptions): DeleteFunctionResponse {
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunction',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteFunctionAsyncInvokeConfigHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteFunctionAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier', description='限定符'),
}

model DeleteFunctionAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteFunctionAsyncInvokeConfig(serviceName: string, functionName: string, request: DeleteFunctionAsyncInvokeConfigRequest): DeleteFunctionAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteFunctionAsyncInvokeConfigHeaders{};
  return deleteFunctionAsyncInvokeConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function deleteFunctionAsyncInvokeConfigWithOptions(serviceName: string, functionName: string, request: DeleteFunctionAsyncInvokeConfigRequest, headers: DeleteFunctionAsyncInvokeConfigHeaders, runtime: Util.RuntimeOptions): DeleteFunctionAsyncInvokeConfigResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunctionAsyncInvokeConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/async-invoke-config`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteFunctionOnDemandConfigHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteFunctionOnDemandConfigRequest {
  qualifier?: string(name='qualifier', description='服务别名或LATEST，不支持版本。'),
}

model DeleteFunctionOnDemandConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteFunctionOnDemandConfig(serviceName: string, functionName: string, request: DeleteFunctionOnDemandConfigRequest): DeleteFunctionOnDemandConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteFunctionOnDemandConfigHeaders{};
  return deleteFunctionOnDemandConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function deleteFunctionOnDemandConfigWithOptions(serviceName: string, functionName: string, request: DeleteFunctionOnDemandConfigRequest, headers: DeleteFunctionOnDemandConfigHeaders, runtime: Util.RuntimeOptions): DeleteFunctionOnDemandConfigResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunctionOnDemandConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/on-demand-config`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteLayerVersionHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteLayerVersion(layerName: string, version: string): DeleteLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteLayerVersionHeaders{};
  return deleteLayerVersionWithOptions(layerName, version, headers, runtime);
}

async function deleteLayerVersionWithOptions(layerName: string, version: string, headers: DeleteLayerVersionHeaders, runtime: Util.RuntimeOptions): DeleteLayerVersionResponse {
  layerName = OpenApiUtil.getEncodeParam(layerName);
  version = OpenApiUtil.getEncodeParam(version);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLayerVersion',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/layers/${layerName}/versions/${version}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteService(serviceName: string): DeleteServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteServiceHeaders{};
  return deleteServiceWithOptions(serviceName, headers, runtime);
}

async function deleteServiceWithOptions(serviceName: string, headers: DeleteServiceHeaders, runtime: Util.RuntimeOptions): DeleteServiceResponse {
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteService',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteServiceVersionHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteServiceVersion(serviceName: string, versionId: string): DeleteServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteServiceVersionHeaders{};
  return deleteServiceVersionWithOptions(serviceName, versionId, headers, runtime);
}

async function deleteServiceVersionWithOptions(serviceName: string, versionId: string, headers: DeleteServiceVersionHeaders, runtime: Util.RuntimeOptions): DeleteServiceVersionResponse {
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  versionId = OpenApiUtil.getEncodeParam(versionId);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceVersion',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/versions/${versionId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteTriggerHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteTrigger(serviceName: string, functionName: string, triggerName: string): DeleteTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteTriggerHeaders{};
  return deleteTriggerWithOptions(serviceName, functionName, triggerName, headers, runtime);
}

async function deleteTriggerWithOptions(serviceName: string, functionName: string, triggerName: string, headers: DeleteTriggerHeaders, runtime: Util.RuntimeOptions): DeleteTriggerResponse {
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  triggerName = OpenApiUtil.getEncodeParam(triggerName);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteTrigger',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/triggers/${triggerName}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteVpcBindingHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeleteVpcBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteVpcBinding(serviceName: string, vpcId: string): DeleteVpcBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteVpcBindingHeaders{};
  return deleteVpcBindingWithOptions(serviceName, vpcId, headers, runtime);
}

async function deleteVpcBindingWithOptions(serviceName: string, vpcId: string, headers: DeleteVpcBindingHeaders, runtime: Util.RuntimeOptions): DeleteVpcBindingResponse {
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  vpcId = OpenApiUtil.getEncodeParam(vpcId);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteVpcBinding',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/bindings/${vpcId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeregisterEventSourceHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model DeregisterEventSourceRequest {
  qualifier?: string(name='qualifier', description='别名或版本'),
}

model DeregisterEventSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deregisterEventSource(serviceName: string, functionName: string, sourceArn: string, request: DeregisterEventSourceRequest): DeregisterEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeregisterEventSourceHeaders{};
  return deregisterEventSourceWithOptions(serviceName, functionName, sourceArn, request, headers, runtime);
}

async function deregisterEventSourceWithOptions(serviceName: string, functionName: string, sourceArn: string, request: DeregisterEventSourceRequest, headers: DeregisterEventSourceHeaders, runtime: Util.RuntimeOptions): DeregisterEventSourceResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  sourceArn = OpenApiUtil.getEncodeParam(sourceArn);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeregisterEventSource',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/event-sources/${sourceArn}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model GetAccountSettingsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetAccountSettingsResponseBody = {
  availableAZs?: [ string ](name='availableAZs', description='可用区列表'),
  defaultRole?: string(name='defaultRole', description='默认服务角色'),
}

model GetAccountSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAccountSettingsResponseBody(name='body'),
}

async function getAccountSettings(): GetAccountSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetAccountSettingsHeaders{};
  return getAccountSettingsWithOptions(headers, runtime);
}

async function getAccountSettingsWithOptions(headers: GetAccountSettingsHeaders, runtime: Util.RuntimeOptions): GetAccountSettingsResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'GetAccountSettings',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/account-settings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetAliasHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetAliasResponseBody = {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
  aliasName?: string(name='aliasName', description='别名名称'),
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='别名描述'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  versionId?: string(name='versionId', description='版本ID'),
}

model GetAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAliasResponseBody(name='body'),
}

async function getAlias(serviceName: string, aliasName: string): GetAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetAliasHeaders{};
  return getAliasWithOptions(serviceName, aliasName, headers, runtime);
}

async function getAliasWithOptions(serviceName: string, aliasName: string, headers: GetAliasHeaders, runtime: Util.RuntimeOptions): GetAliasResponse {
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  aliasName = OpenApiUtil.getEncodeParam(aliasName);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'GetAlias',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/aliases/${aliasName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetCustomDomainHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetCustomDomainResponseBody = {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime'),
  domainName?: string(name='domainName', description='Id of the request'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
}

model GetCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCustomDomainResponseBody(name='body'),
}

async function getCustomDomain(domainName: string): GetCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetCustomDomainHeaders{};
  return getCustomDomainWithOptions(domainName, headers, runtime);
}

async function getCustomDomainWithOptions(domainName: string, headers: GetCustomDomainHeaders, runtime: Util.RuntimeOptions): GetCustomDomainResponse {
  domainName = OpenApiUtil.getEncodeParam(domainName);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'GetCustomDomain',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/custom-domains/${domainName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFunctionHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetFunctionRequest {
  qualifier?: string(name='qualifier', description='service版本, 可以是versionId或者aliasName'),
}

model GetFunctionResponseBody = {
  caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
  codeChecksum?: string(name='codeChecksum', description='function code包的CRC64值'),
  codeSize?: long(name='codeSize', description='系统返回的function的code包大小，单位为byte Example : 1024'),
  createdTime?: string(name='createdTime', description='function创建时间'),
  customContainerConfig?: CustomContainerConfigInfo(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS', description='函数自定义DNS配置'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig', description='Custom Runtime函数详细配置'),
  description?: string(name='description', description='函数描述'),
  environmentVariables?: map[string]string(name='environmentVariables', description='为函数设置的环境变量，可以在函数中获取环境变量的值'),
  functionId?: string(name='functionId', description='系统为每个function生成的唯一ID'),
  functionName?: string(name='functionName', description='函数名称'),
  handler?: string(name='handler', description='function的执行入口'),
  initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
  initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
  instanceConcurrency?: int32(name='instanceConcurrency'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
  instanceType?: string(name='instanceType'),
  lastModifiedTime?: string(name='lastModifiedTime', description='function上次修改时间'),
  layers?: [ string ](name='layers'),
  memorySize?: int32(name='memorySize', description='function设置的内存大小，单位为MB'),
  runtime?: string(name='runtime', description='function运行的语言环境，目前支持nodejs6, nodejs8, python2.7, python3, java8'),
  timeout?: int32(name='timeout', description='运行的超时时间，单位为秒'),
}

model GetFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFunctionResponseBody(name='body'),
}

async function getFunction(serviceName: string, functionName: string, request: GetFunctionRequest): GetFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetFunctionHeaders{};
  return getFunctionWithOptions(serviceName, functionName, request, headers, runtime);
}

async function getFunctionWithOptions(serviceName: string, functionName: string, request: GetFunctionRequest, headers: GetFunctionHeaders, runtime: Util.RuntimeOptions): GetFunctionResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunction',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFunctionAsyncInvokeConfigHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetFunctionAsyncInvokeConfigRequest {
  qualifier?: string(name='qualifier', description='限定符'),
}

model GetFunctionAsyncInvokeConfigResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  function?: string(name='function', description='函数名称'),
  lastModifiedTime?: string(name='lastModifiedTime', description='最后更改时间'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', description='消息最大存活时长'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', description='异步调用失败后的最大重试次数'),
  qualifier?: string(name='qualifier', description='限定符'),
  service?: string(name='service', description='服务名称'),
  statefulInvocation?: boolean(name='statefulInvocation'),
}

model GetFunctionAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFunctionAsyncInvokeConfigResponseBody(name='body'),
}

async function getFunctionAsyncInvokeConfig(serviceName: string, functionName: string, request: GetFunctionAsyncInvokeConfigRequest): GetFunctionAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetFunctionAsyncInvokeConfigHeaders{};
  return getFunctionAsyncInvokeConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function getFunctionAsyncInvokeConfigWithOptions(serviceName: string, functionName: string, request: GetFunctionAsyncInvokeConfigRequest, headers: GetFunctionAsyncInvokeConfigHeaders, runtime: Util.RuntimeOptions): GetFunctionAsyncInvokeConfigResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionAsyncInvokeConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/async-invoke-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFunctionCodeHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetFunctionCodeRequest {
  qualifier?: string(name='qualifier', description='service版本, 可以是versionId或者aliasName'),
}

model GetFunctionCodeResponseBody = {
  checksum?: string(name='checksum', description='function code包的CRC64值'),
  url?: string(name='url', description='获取function代码的URL'),
}

model GetFunctionCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFunctionCodeResponseBody(name='body'),
}

async function getFunctionCode(serviceName: string, functionName: string, request: GetFunctionCodeRequest): GetFunctionCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetFunctionCodeHeaders{};
  return getFunctionCodeWithOptions(serviceName, functionName, request, headers, runtime);
}

async function getFunctionCodeWithOptions(serviceName: string, functionName: string, request: GetFunctionCodeRequest, headers: GetFunctionCodeHeaders, runtime: Util.RuntimeOptions): GetFunctionCodeResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionCode',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/code`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetFunctionOnDemandConfigHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetFunctionOnDemandConfigRequest {
  qualifier?: string(name='qualifier'),
}

model GetFunctionOnDemandConfigResponseBody = {
  maximumInstanceCount?: long(name='maximumInstanceCount'),
  resource?: string(name='resource', description='Id of the request'),
}

model GetFunctionOnDemandConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFunctionOnDemandConfigResponseBody(name='body'),
}

async function getFunctionOnDemandConfig(serviceName: string, functionName: string, request: GetFunctionOnDemandConfigRequest): GetFunctionOnDemandConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetFunctionOnDemandConfigHeaders{};
  return getFunctionOnDemandConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function getFunctionOnDemandConfigWithOptions(serviceName: string, functionName: string, request: GetFunctionOnDemandConfigRequest, headers: GetFunctionOnDemandConfigHeaders, runtime: Util.RuntimeOptions): GetFunctionOnDemandConfigResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFunctionOnDemandConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/on-demand-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetLayerVersionHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetLayerVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Layer  
}

async function getLayerVersion(layerName: string, version: string): GetLayerVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetLayerVersionHeaders{};
  return getLayerVersionWithOptions(layerName, version, headers, runtime);
}

async function getLayerVersionWithOptions(layerName: string, version: string, headers: GetLayerVersionHeaders, runtime: Util.RuntimeOptions): GetLayerVersionResponse {
  layerName = OpenApiUtil.getEncodeParam(layerName);
  version = OpenApiUtil.getEncodeParam(version);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'GetLayerVersion',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/layers/${layerName}/versions/${version}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetProvisionConfigHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetProvisionConfigRequest {
  qualifier?: string(name='qualifier', description='别名名称'),
}

model GetProvisionConfigResponseBody = {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', description='是否始终分配CPU给函数实例。'),
  current?: long(name='current', description='实际资源个数'),
  currentError?: string(name='currentError', description='预留实例创建失败时的错误信息'),
  resource?: string(name='resource', description='资源描述'),
  scheduledActions?: [
    ScheduledActions
  ](name='scheduledActions', description='定时策略配置'),
  target?: long(name='target', description='目标资源个数'),
  targetTrackingPolicies?: [
    TargetTrackingPolicies
  ](name='targetTrackingPolicies', description='指标追踪伸缩策略配置'),
}

model GetProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProvisionConfigResponseBody(name='body'),
}

async function getProvisionConfig(serviceName: string, functionName: string, request: GetProvisionConfigRequest): GetProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetProvisionConfigHeaders{};
  return getProvisionConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function getProvisionConfigWithOptions(serviceName: string, functionName: string, request: GetProvisionConfigRequest, headers: GetProvisionConfigHeaders, runtime: Util.RuntimeOptions): GetProvisionConfigResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProvisionConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/provision-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetResourceTagsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetResourceTagsRequest {
  resourceArn?: string(name='resourceArn', description='Resource ARN 全称或者简称'),
}

model GetResourceTagsResponseBody = {
  resourceArn?: string(name='resourceArn', description='Resource ARN 全称'),
  tags?: map[string]string(name='tags', description='tag 列表'),
}

model GetResourceTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourceTagsResponseBody(name='body'),
}

async function getResourceTags(request: GetResourceTagsRequest): GetResourceTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetResourceTagsHeaders{};
  return getResourceTagsWithOptions(request, headers, runtime);
}

async function getResourceTagsWithOptions(request: GetResourceTagsRequest, headers: GetResourceTagsHeaders, runtime: Util.RuntimeOptions): GetResourceTagsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.resourceArn)) {
    query['resourceArn'] = request.resourceArn;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceTags',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/tag`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetServiceHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetServiceRequest {
  qualifier?: string(name='qualifier', description='限定符'),
}

model GetServiceResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='服务描述'),
  internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  role?: string(name='role', description='服务角色'),
  serviceId?: string(name='serviceId', description='服务ID'),
  serviceName?: string(name='serviceName', description='服务名称'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model GetServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceResponseBody(name='body'),
}

async function getService(serviceName: string, request: GetServiceRequest): GetServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetServiceHeaders{};
  return getServiceWithOptions(serviceName, request, headers, runtime);
}

async function getServiceWithOptions(serviceName: string, request: GetServiceRequest, headers: GetServiceHeaders, runtime: Util.RuntimeOptions): GetServiceResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetService',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetStatefulAsyncInvocationHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcCodeChecksum?: string(name='X-Fc-Code-Checksum'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcInvocationType?: string(name='X-Fc-Invocation-Type'),
  xFcLogType?: string(name='X-Fc-Log-Type'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetStatefulAsyncInvocationRequest {
  qualifier?: string(name='qualifier'),
}

model GetStatefulAsyncInvocationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StatefulAsyncInvocation  
}

async function getStatefulAsyncInvocation(serviceName: string, functionName: string, invocationId: string, request: GetStatefulAsyncInvocationRequest): GetStatefulAsyncInvocationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetStatefulAsyncInvocationHeaders{};
  return getStatefulAsyncInvocationWithOptions(serviceName, functionName, invocationId, request, headers, runtime);
}

async function getStatefulAsyncInvocationWithOptions(serviceName: string, functionName: string, invocationId: string, request: GetStatefulAsyncInvocationRequest, headers: GetStatefulAsyncInvocationHeaders, runtime: Util.RuntimeOptions): GetStatefulAsyncInvocationResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  invocationId = OpenApiUtil.getEncodeParam(invocationId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcCodeChecksum)) {
    realHeaders['X-Fc-Code-Checksum'] = Util.toJSONString(headers.xFcCodeChecksum);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcInvocationType)) {
    realHeaders['X-Fc-Invocation-Type'] = Util.toJSONString(headers.xFcInvocationType);
  }
  if (!Util.isUnset(headers.xFcLogType)) {
    realHeaders['X-Fc-Log-Type'] = Util.toJSONString(headers.xFcLogType);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetStatefulAsyncInvocation',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/stateful-async-invocations/${invocationId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetTriggerHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model GetTriggerResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description'),
  domainName?: string(name='domainName', description='域名名称，使用域名名称拼接上函数计算域名，可以采用HTTP协议调用到触发器对应版本的函数。例如{domainName}.cn-shanghai.fc.aliyuncs.com'),
  invocationRole?: string(name='invocationRole', description='调用函数使用的RAM角色的ARN'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次修改时间'),
  qualifier?: string(name='qualifier', description='service版本'),
  sourceArn?: string(name='sourceArn', description='event source的Aliyun Resource Name（ARN'),
  triggerConfig?: string(name='triggerConfig', description='trigger配置对象'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName', description='trigger名称'),
  triggerType?: string(name='triggerType', description='trigger类型，如 oss, log, tablestore, timer, http, cdn_events, mns_topic'),
  urlInternet?: string(name='urlInternet', description='公网域名地址。在互联网可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
  urlIntranet?: string(name='urlIntranet', description='私网域名地址。在VPC可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
}

model GetTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTriggerResponseBody(name='body'),
}

async function getTrigger(serviceName: string, functionName: string, triggerName: string): GetTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetTriggerHeaders{};
  return getTriggerWithOptions(serviceName, functionName, triggerName, headers, runtime);
}

async function getTriggerWithOptions(serviceName: string, functionName: string, triggerName: string, headers: GetTriggerHeaders, runtime: Util.RuntimeOptions): GetTriggerResponse {
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  triggerName = OpenApiUtil.getEncodeParam(triggerName);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'GetTrigger',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/triggers/${triggerName}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model InvokeFunctionHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcInvocationType?: string(name='X-Fc-Invocation-Type', description='调用方式:Sync或者Async，默认值：Sync'),
  xFcLogType?: string(name='X-Fc-Log-Type', description='请求返回日志类型, Tail 为返回函数日志最后 4KB 数据，None 或空值则返回不带有日志，默认为 None'),
  xFcStatefulAsyncInvocationId?: string(name='X-Fc-Stateful-Async-Invocation-Id'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model InvokeFunctionRequest {
  body?: bytes(name='body', description='事件（event），binary type。函数计算服务将event传递给用户function来处理'),
  qualifier?: string(name='qualifier', description='service版本, 可以是versionId或者aliasName'),
}

model InvokeFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: bytes(name='body'),
}

async function invokeFunction(serviceName: string, functionName: string, request: InvokeFunctionRequest): InvokeFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new InvokeFunctionHeaders{};
  return invokeFunctionWithOptions(serviceName, functionName, request, headers, runtime);
}

async function invokeFunctionWithOptions(serviceName: string, functionName: string, request: InvokeFunctionRequest, headers: InvokeFunctionHeaders, runtime: Util.RuntimeOptions): InvokeFunctionResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcInvocationType)) {
    realHeaders['X-Fc-Invocation-Type'] = Util.toJSONString(headers.xFcInvocationType);
  }
  if (!Util.isUnset(headers.xFcLogType)) {
    realHeaders['X-Fc-Log-Type'] = Util.toJSONString(headers.xFcLogType);
  }
  if (!Util.isUnset(headers.xFcStatefulAsyncInvocationId)) {
    realHeaders['X-Fc-Stateful-Async-Invocation-Id'] = Util.toJSONString(headers.xFcStatefulAsyncInvocationId);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = Util.toString(request.body),
  };
  var params = new OpenApi.Params{
    action = 'InvokeFunction',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/invocations`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'byte',
  };
  return callApi(params, req, runtime);
}

model ListAliasesHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListAliasesRequest {
  limit?: int32(name='limit', description='最多返回个数'),
  nextToken?: string(name='nextToken', description='下次查询token'),
  prefix?: string(name='prefix', description='前缀'),
  startKey?: string(name='startKey', description='起始key'),
}

model ListAliasesResponseBody = {
  aliases?: [ 
    {
      additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
      aliasName?: string(name='aliasName', description='别名名称'),
      createdTime?: string(name='createdTime', description='创建时间'),
      description?: string(name='description', description='别名描述'),
      lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
      versionId?: string(name='versionId', description='版本ID'),
    }
  ](name='aliases', description='别名列表'),
  nextToken?: string(name='nextToken', description='下次查询token'),
}

model ListAliasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAliasesResponseBody(name='body'),
}

async function listAliases(serviceName: string, request: ListAliasesRequest): ListAliasesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListAliasesHeaders{};
  return listAliasesWithOptions(serviceName, request, headers, runtime);
}

async function listAliasesWithOptions(serviceName: string, request: ListAliasesRequest, headers: ListAliasesHeaders, runtime: Util.RuntimeOptions): ListAliasesResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAliases',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/aliases`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListCustomDomainsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListCustomDomainsRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  prefix?: string(name='prefix'),
  startKey?: string(name='startKey'),
}

model ListCustomDomainsResponseBody = {
  customDomains?: [ 
    {
      accountId?: string(name='accountId'),
      apiVersion?: string(name='apiVersion'),
      certConfig?: CertConfig(name='certConfig'),
      createdTime?: string(name='createdTime'),
      domainName?: string(name='domainName'),
      lastModifiedTime?: string(name='lastModifiedTime'),
      protocol?: string(name='protocol'),
      routeConfig?: RouteConfig(name='routeConfig'),
      tlsConfig?: TLSConfig(name='tlsConfig'),
    }
  ](name='customDomains'),
  nextToken?: string(name='nextToken'),
}

model ListCustomDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCustomDomainsResponseBody(name='body'),
}

async function listCustomDomains(request: ListCustomDomainsRequest): ListCustomDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListCustomDomainsHeaders{};
  return listCustomDomainsWithOptions(request, headers, runtime);
}

async function listCustomDomainsWithOptions(request: ListCustomDomainsRequest, headers: ListCustomDomainsHeaders, runtime: Util.RuntimeOptions): ListCustomDomainsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCustomDomains',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/custom-domains`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEventSourcesHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListEventSourcesRequest {
  qualifier?: string(name='qualifier', description='别名或版本'),
}

model ListEventSourcesResponseBody = {
  eventSources?: [ 
    {
      createdTime?: string(name='createdTime', description='创建时间'),
      sourceArn?: string(name='sourceArn', description='事件源资源标识符'),
    }
  ](name='eventSources', description='事件源列表'),
}

model ListEventSourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventSourcesResponseBody(name='body'),
}

async function listEventSources(serviceName: string, functionName: string, request: ListEventSourcesRequest): ListEventSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListEventSourcesHeaders{};
  return listEventSourcesWithOptions(serviceName, functionName, request, headers, runtime);
}

async function listEventSourcesWithOptions(serviceName: string, functionName: string, request: ListEventSourcesRequest, headers: ListEventSourcesHeaders, runtime: Util.RuntimeOptions): ListEventSourcesResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEventSources',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/event-sources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFunctionAsyncInvokeConfigsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcCodeChecksum?: string(name='X-Fc-Code-Checksum'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcInvocationType?: string(name='X-Fc-Invocation-Type'),
  xFcLogType?: string(name='X-Fc-Log-Type'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListFunctionAsyncInvokeConfigsRequest {
  limit?: int32(name='limit', description='最多返回个数'),
  nextToken?: string(name='nextToken', description='下次查询token'),
}

model ListFunctionAsyncInvokeConfigsResponseBody = {
  configs?: [ 
    {
      createdTime?: string(name='createdTime', description='创建时间'),
      destinationConfig?: DestinationConfig(name='destinationConfig'),
      function?: string(name='function', description='函数名称'),
      lastModifiedTime?: string(name='lastModifiedTime', description='最后更改时间'),
      maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', description='消息最大存活时长'),
      maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', description='异步调用失败后的最大重试次数'),
      qualifier?: string(name='qualifier', description='限定符'),
      service?: string(name='service', description='服务名称'),
      statefulInvocation?: boolean(name='statefulInvocation'),
    }
  ](name='configs', description='异步配置列表'),
  nextToken?: string(name='nextToken', description='下次查询token'),
}

model ListFunctionAsyncInvokeConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFunctionAsyncInvokeConfigsResponseBody(name='body'),
}

async function listFunctionAsyncInvokeConfigs(serviceName: string, functionName: string, request: ListFunctionAsyncInvokeConfigsRequest): ListFunctionAsyncInvokeConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListFunctionAsyncInvokeConfigsHeaders{};
  return listFunctionAsyncInvokeConfigsWithOptions(serviceName, functionName, request, headers, runtime);
}

async function listFunctionAsyncInvokeConfigsWithOptions(serviceName: string, functionName: string, request: ListFunctionAsyncInvokeConfigsRequest, headers: ListFunctionAsyncInvokeConfigsHeaders, runtime: Util.RuntimeOptions): ListFunctionAsyncInvokeConfigsResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcCodeChecksum)) {
    realHeaders['X-Fc-Code-Checksum'] = Util.toJSONString(headers.xFcCodeChecksum);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcInvocationType)) {
    realHeaders['X-Fc-Invocation-Type'] = Util.toJSONString(headers.xFcInvocationType);
  }
  if (!Util.isUnset(headers.xFcLogType)) {
    realHeaders['X-Fc-Log-Type'] = Util.toJSONString(headers.xFcLogType);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionAsyncInvokeConfigs',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/async-invoke-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFunctionsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListFunctionsRequest {
  limit?: int32(name='limit', description='限定此次返回资源的数量。如果不设定，默认返回20，最大不能超过100。返回结果可能小于指定的数量，但不会多于指定的数量'),
  nextToken?: string(name='nextToken', description='用来返回更多结果。第一次查询不需要提供这个参数，后续查询的token从返回结果中获取'),
  prefix?: string(name='prefix', description='限定返回的资源名称必须以prefix作为前缀'),
  qualifier?: string(name='qualifier', description='service版本, 可以是versionId或者aliasName'),
  startKey?: string(name='startKey', description='设定结果从startKey之后（包括startKey）按字母排序的第一个开始返回'),
}

model ListFunctionsResponseBody = {
  functions?: [ 
    {
      caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
      codeChecksum?: string(name='codeChecksum', description='function code包的CRC64值'),
      codeSize?: long(name='codeSize', description='系统返回的function的code包大小，单位为byte Example : 1024'),
      createdTime?: string(name='createdTime', description='function创建时间'),
      customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
      description?: string(name='description', description='函数描述'),
      environmentVariables?: map[string]string(name='environmentVariables', description='为函数设置的环境变量，可以在函数中获取环境变量的值'),
      functionId?: string(name='functionId', description='系统为每个function生成的唯一ID'),
      functionName?: string(name='functionName', description='函数名称'),
      handler?: string(name='handler', description='function的执行入口'),
      initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
      initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
      instanceConcurrency?: int32(name='instanceConcurrency'),
      instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
      instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
      instanceType?: string(name='instanceType'),
      lastModifiedTime?: string(name='lastModifiedTime', description='function上次修改时间'),
      layers?: [ string ](name='layers'),
      memorySize?: int32(name='memorySize', description='function设置的内存大小，单位为MB'),
      runtime?: string(name='runtime', description='function运行的语言环境，目前支持nodejs6, nodejs8, python2.7, python3, java8'),
      timeout?: int32(name='timeout', description='运行的超时时间，单位为秒'),
    }
  ](name='functions', description='函数列表'),
  nextToken?: string(name='nextToken', description='用来返回更多的查询结果。如果这个值没有返回，则说明没有更多结果'),
}

model ListFunctionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFunctionsResponseBody(name='body'),
}

async function listFunctions(serviceName: string, request: ListFunctionsRequest): ListFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListFunctionsHeaders{};
  return listFunctionsWithOptions(serviceName, request, headers, runtime);
}

async function listFunctionsWithOptions(serviceName: string, request: ListFunctionsRequest, headers: ListFunctionsHeaders, runtime: Util.RuntimeOptions): ListFunctionsResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctions',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListInstancesHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListInstancesRequest {
  instanceIds?: [ string ](name='instanceIds', description='实例ID'),
  limit?: int32(name='limit', description='限定此次返回资源的数量，取值范围[0,1000]。

返回结果可以小于指定的数量，但不能多于指定的数量。'),
  qualifier?: string(name='qualifier', description='服务的版本或别名。默认是LATEST。

此处的qualifier同InvokeFunction的qualifier含义一致，即调用ListInstances时指定qualifier=test查询出来的实例，就是调用InvokeFunction时qualifier=test链路上的实例。'),
}

model ListInstancesResponseBody = {
  instances?: [ 
    {
      instanceId?: string(name='instanceId', description='实例ID。'),
      versionId?: string(name='versionId', description='实例所属的服务版本。如果是LATEST别名下的函数实例，则返回版本号为0。'),
    }
  ](name='instances'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstances(serviceName: string, functionName: string, request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListInstancesHeaders{};
  return listInstancesWithOptions(serviceName, functionName, request, headers, runtime);
}

async function listInstancesWithOptions(serviceName: string, functionName: string, request: ListInstancesRequest, headers: ListInstancesHeaders, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceIds)) {
    query['instanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListLayerVersionsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListLayerVersionsRequest {
  limit?: int32(name='limit', description='本次读取的最大数据记录数量'),
  startVersion?: int32(name='startVersion', description='起始版本'),
}

model ListLayerVersionsResponseBody = {
  layers?: [
    Layer
  ](name='layers', description='层版本列表'),
  nextVersion?: int32(name='nextVersion', description='剩余列表起始版本号'),
}

model ListLayerVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLayerVersionsResponseBody(name='body'),
}

async function listLayerVersions(layerName: string, request: ListLayerVersionsRequest): ListLayerVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListLayerVersionsHeaders{};
  return listLayerVersionsWithOptions(layerName, request, headers, runtime);
}

async function listLayerVersionsWithOptions(layerName: string, request: ListLayerVersionsRequest, headers: ListLayerVersionsHeaders, runtime: Util.RuntimeOptions): ListLayerVersionsResponse {
  Util.validateModel(request);
  layerName = OpenApiUtil.getEncodeParam(layerName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.startVersion)) {
    query['startVersion'] = request.startVersion;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLayerVersions',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/layers/${layerName}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListLayersHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListLayersRequest {
  limit?: int32(name='limit', description='最大返回条目数'),
  nextToken?: string(name='nextToken', description='下一个层名称'),
  prefix?: string(name='prefix', description='层名称前缀'),
  startKey?: string(name='startKey', description='起始层名称'),
}

model ListLayersResponseBody = {
  layers?: [
    Layer
  ](name='layers', description='层列表'),
  nextToken?: string(name='nextToken', description='剩余列表起始层名'),
}

model ListLayersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLayersResponseBody(name='body'),
}

async function listLayers(request: ListLayersRequest): ListLayersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListLayersHeaders{};
  return listLayersWithOptions(request, headers, runtime);
}

async function listLayersWithOptions(request: ListLayersRequest, headers: ListLayersHeaders, runtime: Util.RuntimeOptions): ListLayersResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLayers',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/layers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListOnDemandConfigsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListOnDemandConfigsRequest {
  limit?: int32(name='limit', description='限定此次返回资源的数量。如果不设定，默认返回20，最大不能超过100。返回结果可以小于指定的数量，但不会多于指定的数量。'),
  nextToken?: string(name='nextToken', description='用来返回更多结果。第一次查询不需要提供这个参数，后续查询的Token从返回结果中获取。'),
  prefix?: string(name='prefix', description='限定返回的资源名称，名称必须以Prefix作为前缀，例如Prefix是a，则返回的资源名均是以a开始的。'),
  startKey?: string(name='startKey', description='设定结果从startKey之后（包括startKey）按字母排序的第一个开始返回。'),
}

model ListOnDemandConfigsResponseBody = {
  configs?: [
    OnDemandConfig
  ](name='configs', description='预留实例配置'),
  nextToken?: string(name='nextToken', description='用来返回更多的查询结果。如果这个值没有返回，则说明没有更多结果。'),
}

model ListOnDemandConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOnDemandConfigsResponseBody(name='body'),
}

async function listOnDemandConfigs(request: ListOnDemandConfigsRequest): ListOnDemandConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListOnDemandConfigsHeaders{};
  return listOnDemandConfigsWithOptions(request, headers, runtime);
}

async function listOnDemandConfigsWithOptions(request: ListOnDemandConfigsRequest, headers: ListOnDemandConfigsHeaders, runtime: Util.RuntimeOptions): ListOnDemandConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOnDemandConfigs',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/on-demand-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListProvisionConfigsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListProvisionConfigsRequest {
  limit?: long(name='limit', description='限定此次返回资源的数量。如果不设定，默认返回20，最大不能超过100。返回结果可能小于指定的数量，但不会多于指定的数量'),
  nextToken?: string(name='nextToken', description='用来返回更多结果。第一次查询不需要提供这个参数，后续查询的token从返回结果中获取'),
  qualifier?: string(name='qualifier', description='限定返回的资源名称必须属于该qualifier。qualifier只能是aliasName，且必须和serviceName共同使用'),
  serviceName?: string(name='serviceName', description='限定返回的资源名称必须属于该service'),
}

model ListProvisionConfigsResponseBody = {
  nextToken?: string(name='nextToken', description='下次查询的起始token'),
  provisionConfigs?: [ 
    {
      alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', description='是否始终分配CPU给函数实例。'),
      current?: long(name='current', description='实际资源个数'),
      currentError?: string(name='currentError', description='预留实例创建失败时的错误信息'),
      resource?: string(name='resource', description='资源描述'),
      scheduledActions?: [
        ScheduledActions
      ](name='scheduledActions', description='定时策略配置'),
      target?: long(name='target', description='目标资源个数'),
      targetTrackingPolicies?: [
        TargetTrackingPolicies
      ](name='targetTrackingPolicies', description='指标追踪伸缩策略配置'),
    }
  ](name='provisionConfigs', description='预留实例列表'),
}

model ListProvisionConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProvisionConfigsResponseBody(name='body'),
}

async function listProvisionConfigs(request: ListProvisionConfigsRequest): ListProvisionConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListProvisionConfigsHeaders{};
  return listProvisionConfigsWithOptions(request, headers, runtime);
}

async function listProvisionConfigsWithOptions(request: ListProvisionConfigsRequest, headers: ListProvisionConfigsHeaders, runtime: Util.RuntimeOptions): ListProvisionConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['serviceName'] = request.serviceName;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProvisionConfigs',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/provision-configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListReservedCapacitiesHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListReservedCapacitiesRequest {
  limit?: string(name='limit', description='一次返回的数量，取值范围[1, 100]'),
  nextToken?: string(name='nextToken'),
}

model ListReservedCapacitiesResponseBody = {
  nextToken?: string(name='nextToken', description='nextToken'),
  reservedCapacities?: [
    OpenReservedCapacity
  ](name='reservedCapacities', description='reservedCapacities'),
}

model ListReservedCapacitiesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListReservedCapacitiesResponseBody(name='body'),
}

async function listReservedCapacities(request: ListReservedCapacitiesRequest): ListReservedCapacitiesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListReservedCapacitiesHeaders{};
  return listReservedCapacitiesWithOptions(request, headers, runtime);
}

async function listReservedCapacitiesWithOptions(request: ListReservedCapacitiesRequest, headers: ListReservedCapacitiesHeaders, runtime: Util.RuntimeOptions): ListReservedCapacitiesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListReservedCapacities',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/reserved-capacities`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListServiceVersionsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListServiceVersionsRequest {
  direction?: string(name='direction', description='排序方向'),
  limit?: int32(name='limit', description='最多返回个数'),
  nextToken?: string(name='nextToken', description='下次查询token'),
  startKey?: string(name='startKey', description='起始key'),
}

model ListServiceVersionsResponseBody = {
  direction?: string(name='direction', description='排序方向'),
  nextToken?: string(name='nextToken', description='下次查询token'),
  versions?: [ 
    {
      createdTime?: string(name='createdTime', description='创建时间'),
      description?: string(name='description', description='版本描述'),
      lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
      versionId?: string(name='versionId', description='版本ID'),
    }
  ](name='versions', description='版本列表'),
}

model ListServiceVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceVersionsResponseBody(name='body'),
}

async function listServiceVersions(serviceName: string, request: ListServiceVersionsRequest): ListServiceVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListServiceVersionsHeaders{};
  return listServiceVersionsWithOptions(serviceName, request, headers, runtime);
}

async function listServiceVersionsWithOptions(serviceName: string, request: ListServiceVersionsRequest, headers: ListServiceVersionsHeaders, runtime: Util.RuntimeOptions): ListServiceVersionsResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.direction)) {
    query['direction'] = request.direction;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceVersions',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListServicesHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListServicesRequest {
  limit?: int32(name='limit', description='最多返回个数'),
  nextToken?: string(name='nextToken', description='下次查询token'),
  prefix?: string(name='prefix', description='前缀'),
  startKey?: string(name='startKey', description='起始key'),
}

model ListServicesResponseBody = {
  nextToken?: string(name='nextToken', description='下次查询token'),
  services?: [ 
    {
      createdTime?: string(name='createdTime', description='创建时间'),
      description?: string(name='description', description='服务描述'),
      internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
      lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
      logConfig?: LogConfig(name='logConfig'),
      nasConfig?: NASConfig(name='nasConfig'),
      role?: string(name='role', description='服务角色'),
      serviceId?: string(name='serviceId', description='服务ID'),
      serviceName?: string(name='serviceName', description='服务信息'),
      tracingConfig?: TracingConfig(name='tracingConfig'),
      vpcConfig?: VPCConfig(name='vpcConfig'),
    }
  ](name='services', description='服务列表'),
}

model ListServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServicesResponseBody(name='body'),
}

async function listServices(request: ListServicesRequest): ListServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListServicesHeaders{};
  return listServicesWithOptions(request, headers, runtime);
}

async function listServicesWithOptions(request: ListServicesRequest, headers: ListServicesHeaders, runtime: Util.RuntimeOptions): ListServicesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServices',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListStatefulAsyncInvocationFunctionsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id', description='您的阿里云账号（主账号）ID。'),
  xFcDate?: string(name='X-Fc-Date', description='发起API调用的日期，用于对请求签名。格式为yyyy-mm-ddhh:mm:ss。'),
  xFcTraceId?: string(name='X-Fc-Trace-Id', description='用于链路追踪的ID。'),
}

model ListStatefulAsyncInvocationFunctionsRequest {
  limit?: int32(name='limit', description='限定此次返回资源的数量。如果不设定，默认返回20，最大不能超过100。返回结果可以小于指定的数量，但不会多于指定的数量。'),
  nextToken?: string(name='nextToken', description='用来标记当前开始读取的位置，置空表示从头开始。第一次查询不需要提供这个参数，后续查询的Token从前一次查询的返回结果中获取。'),
}

model ListStatefulAsyncInvocationFunctionsResponseBody = {
  data?: [
    AsyncConfigMeta
  ](name='data', description='返回的实际数据列表。'),
  nextToken?: string(name='nextToken', description='用来表示当前调用返回读取到的位置，空代表数据已经读取完毕。'),
}

model ListStatefulAsyncInvocationFunctionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListStatefulAsyncInvocationFunctionsResponseBody(name='body'),
}

async function listStatefulAsyncInvocationFunctions(request: ListStatefulAsyncInvocationFunctionsRequest): ListStatefulAsyncInvocationFunctionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListStatefulAsyncInvocationFunctionsHeaders{};
  return listStatefulAsyncInvocationFunctionsWithOptions(request, headers, runtime);
}

async function listStatefulAsyncInvocationFunctionsWithOptions(request: ListStatefulAsyncInvocationFunctionsRequest, headers: ListStatefulAsyncInvocationFunctionsHeaders, runtime: Util.RuntimeOptions): ListStatefulAsyncInvocationFunctionsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListStatefulAsyncInvocationFunctions',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/stateful-async-invocation-functions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListStatefulAsyncInvocationsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcCodeChecksum?: string(name='X-Fc-Code-Checksum'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcInvocationType?: string(name='X-Fc-Invocation-Type'),
  xFcLogType?: string(name='X-Fc-Log-Type'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListStatefulAsyncInvocationsRequest {
  includePayload?: boolean(name='includePayload'),
  invocationIdPrefix?: string(name='invocationIdPrefix'),
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
  qualifier?: string(name='qualifier'),
  sortOrderByTime?: string(name='sortOrderByTime'),
  startedTimeBegin?: long(name='startedTimeBegin'),
  startedTimeEnd?: long(name='startedTimeEnd'),
  status?: string(name='status'),
}

model ListStatefulAsyncInvocationsResponseBody = {
  invocations?: [
    StatefulAsyncInvocation
  ](name='invocations'),
  nextToken?: string(name='nextToken'),
}

model ListStatefulAsyncInvocationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListStatefulAsyncInvocationsResponseBody(name='body'),
}

async function listStatefulAsyncInvocations(serviceName: string, functionName: string, request: ListStatefulAsyncInvocationsRequest): ListStatefulAsyncInvocationsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListStatefulAsyncInvocationsHeaders{};
  return listStatefulAsyncInvocationsWithOptions(serviceName, functionName, request, headers, runtime);
}

async function listStatefulAsyncInvocationsWithOptions(serviceName: string, functionName: string, request: ListStatefulAsyncInvocationsRequest, headers: ListStatefulAsyncInvocationsHeaders, runtime: Util.RuntimeOptions): ListStatefulAsyncInvocationsResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.includePayload)) {
    query['includePayload'] = request.includePayload;
  }
  if (!Util.isUnset(request.invocationIdPrefix)) {
    query['invocationIdPrefix'] = request.invocationIdPrefix;
  }
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.sortOrderByTime)) {
    query['sortOrderByTime'] = request.sortOrderByTime;
  }
  if (!Util.isUnset(request.startedTimeBegin)) {
    query['startedTimeBegin'] = request.startedTimeBegin;
  }
  if (!Util.isUnset(request.startedTimeEnd)) {
    query['startedTimeEnd'] = request.startedTimeEnd;
  }
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcCodeChecksum)) {
    realHeaders['X-Fc-Code-Checksum'] = Util.toJSONString(headers.xFcCodeChecksum);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcInvocationType)) {
    realHeaders['X-Fc-Invocation-Type'] = Util.toJSONString(headers.xFcInvocationType);
  }
  if (!Util.isUnset(headers.xFcLogType)) {
    realHeaders['X-Fc-Log-Type'] = Util.toJSONString(headers.xFcLogType);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListStatefulAsyncInvocations',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/stateful-async-invocations`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTaggedResourcesHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListTaggedResourcesRequest {
  limit?: int32(name='limit'),
  nextToken?: string(name='nextToken'),
}

model ListTaggedResourcesResponseBody = {
  nextToken?: string(name='nextToken'),
  resources?: [
    Resource
  ](name='resources'),
}

model ListTaggedResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTaggedResourcesResponseBody(name='body'),
}

async function listTaggedResources(request: ListTaggedResourcesRequest): ListTaggedResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListTaggedResourcesHeaders{};
  return listTaggedResourcesWithOptions(request, headers, runtime);
}

async function listTaggedResourcesWithOptions(request: ListTaggedResourcesRequest, headers: ListTaggedResourcesHeaders, runtime: Util.RuntimeOptions): ListTaggedResourcesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTaggedResources',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/tags`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListTriggersHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListTriggersRequest {
  limit?: int32(name='limit', description='限定此次返回资源的数量。如果不设定，默认返回20，最大不能超过100。返回结果可能小于指定的数量，但不会多于指定的数量'),
  nextToken?: string(name='nextToken', description='用来返回更多结果。第一次查询不需要提供这个参数，后续查询的token从返回结果中获取'),
  prefix?: string(name='prefix', description='限定返回的资源名称必须以prefix作为前缀'),
  startKey?: string(name='startKey', description='设定结果从startKey之后（包括startKey）按字母排序的第一个开始返回'),
}

model ListTriggersResponseBody = {
  nextToken?: string(name='nextToken', description='用来返回更多的查询结果。如果这个值没有返回，则说明没有更多结果'),
  triggers?: [ 
    {
      createdTime?: string(name='createdTime', description='创建时间'),
      description?: string(name='description'),
      domainName?: string(name='domainName', description='域名名称，使用域名名称拼接上函数计算域名，可以采用HTTP协议调用到触发器对应版本的函数。例如{domainName}.cn-shanghai.fc.aliyuncs.com'),
      invocationRole?: string(name='invocationRole', description='调用函数使用的RAM角色的ARN'),
      lastModifiedTime?: string(name='lastModifiedTime', description='上次修改时间'),
      qualifier?: string(name='qualifier', description='service版本'),
      sourceArn?: string(name='sourceArn', description='event source的Aliyun Resource Name（ARN'),
      triggerConfig?: string(name='triggerConfig', description='trigger配置对象'),
      triggerId?: string(name='triggerId'),
      triggerName?: string(name='triggerName', description='trigger名称'),
      triggerType?: string(name='triggerType', description='trigger类型，如 oss, log, tablestore, timer, http, cdn_events, mns_topic'),
      urlInternet?: string(name='urlInternet', description='公网域名地址。在互联网可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
      urlIntranet?: string(name='urlIntranet', description='私网域名地址。在VPC可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
    }
  ](name='triggers', description='Trigger列表'),
}

model ListTriggersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTriggersResponseBody(name='body'),
}

async function listTriggers(serviceName: string, functionName: string, request: ListTriggersRequest): ListTriggersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListTriggersHeaders{};
  return listTriggersWithOptions(serviceName, functionName, request, headers, runtime);
}

async function listTriggersWithOptions(serviceName: string, functionName: string, request: ListTriggersRequest, headers: ListTriggersHeaders, runtime: Util.RuntimeOptions): ListTriggersResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.limit)) {
    query['limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['nextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.prefix)) {
    query['prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.startKey)) {
    query['startKey'] = request.startKey;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTriggers',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/triggers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListVpcBindingsHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model ListVpcBindingsResponseBody = {
  vpcIds?: [ string ](name='vpcIds'),
}

model ListVpcBindingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVpcBindingsResponseBody(name='body'),
}

async function listVpcBindings(serviceName: string): ListVpcBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListVpcBindingsHeaders{};
  return listVpcBindingsWithOptions(serviceName, headers, runtime);
}

async function listVpcBindingsWithOptions(serviceName: string, headers: ListVpcBindingsHeaders, runtime: Util.RuntimeOptions): ListVpcBindingsResponse {
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'ListVpcBindings',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/bindings`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PublishServiceVersionHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match', description='服务的ETag，可通过GetService接口获得。若发布版本时服务的ETag与传入的不一致，则发布版本会失败。'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model PublishServiceVersionRequest {
  description?: string(name='description', description='版本描述'),
}

model PublishServiceVersionResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='版本描述'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  versionId?: string(name='versionId', description='版本ID'),
}

model PublishServiceVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PublishServiceVersionResponseBody(name='body'),
}

async function publishServiceVersion(serviceName: string, request: PublishServiceVersionRequest): PublishServiceVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PublishServiceVersionHeaders{};
  return publishServiceVersionWithOptions(serviceName, request, headers, runtime);
}

async function publishServiceVersionWithOptions(serviceName: string, request: PublishServiceVersionRequest, headers: PublishServiceVersionHeaders, runtime: Util.RuntimeOptions): PublishServiceVersionResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PublishServiceVersion',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PutFunctionAsyncInvokeConfigHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model PutFunctionAsyncInvokeConfigRequest {
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', description='消息最大存活时长'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', description='异步调用失败后的最大重试次数'),
  statefulInvocation?: boolean(name='statefulInvocation'),
  qualifier?: string(name='qualifier', description='别名或版本'),
}

model PutFunctionAsyncInvokeConfigResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  destinationConfig?: DestinationConfig(name='destinationConfig'),
  function?: string(name='function', description='函数名称'),
  lastModifiedTime?: string(name='lastModifiedTime', description='最后更改时间'),
  maxAsyncEventAgeInSeconds?: long(name='maxAsyncEventAgeInSeconds', description='消息最大存活时长'),
  maxAsyncRetryAttempts?: long(name='maxAsyncRetryAttempts', description='异步调用失败后的最大重试次数'),
  qualifier?: string(name='qualifier', description='限定符'),
  service?: string(name='service', description='服务名称'),
  statefulInvocation?: boolean(name='statefulInvocation'),
}

model PutFunctionAsyncInvokeConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutFunctionAsyncInvokeConfigResponseBody(name='body'),
}

async function putFunctionAsyncInvokeConfig(serviceName: string, functionName: string, request: PutFunctionAsyncInvokeConfigRequest): PutFunctionAsyncInvokeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PutFunctionAsyncInvokeConfigHeaders{};
  return putFunctionAsyncInvokeConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function putFunctionAsyncInvokeConfigWithOptions(serviceName: string, functionName: string, request: PutFunctionAsyncInvokeConfigRequest, headers: PutFunctionAsyncInvokeConfigHeaders, runtime: Util.RuntimeOptions): PutFunctionAsyncInvokeConfigResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.destinationConfig)) {
    body['destinationConfig'] = request.destinationConfig;
  }
  if (!Util.isUnset(request.maxAsyncEventAgeInSeconds)) {
    body['maxAsyncEventAgeInSeconds'] = request.maxAsyncEventAgeInSeconds;
  }
  if (!Util.isUnset(request.maxAsyncRetryAttempts)) {
    body['maxAsyncRetryAttempts'] = request.maxAsyncRetryAttempts;
  }
  if (!Util.isUnset(request.statefulInvocation)) {
    body['statefulInvocation'] = request.statefulInvocation;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutFunctionAsyncInvokeConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/async-invoke-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PutFunctionOnDemandConfigHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model PutFunctionOnDemandConfigRequest {
  maximumInstanceCount?: long(name='maximumInstanceCount'),
  qualifier?: string(name='qualifier'),
}

model PutFunctionOnDemandConfigResponseBody = {
  maximumInstanceCount?: long(name='maximumInstanceCount'),
  resource?: string(name='resource'),
}

model PutFunctionOnDemandConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutFunctionOnDemandConfigResponseBody(name='body'),
}

async function putFunctionOnDemandConfig(serviceName: string, functionName: string, request: PutFunctionOnDemandConfigRequest): PutFunctionOnDemandConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PutFunctionOnDemandConfigHeaders{};
  return putFunctionOnDemandConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function putFunctionOnDemandConfigWithOptions(serviceName: string, functionName: string, request: PutFunctionOnDemandConfigRequest, headers: PutFunctionOnDemandConfigHeaders, runtime: Util.RuntimeOptions): PutFunctionOnDemandConfigResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.maximumInstanceCount)) {
    body['maximumInstanceCount'] = request.maximumInstanceCount;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutFunctionOnDemandConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/on-demand-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PutProvisionConfigHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model PutProvisionConfigRequest {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', description='当实例进入空闲状态时，是否继续分配CPU。'),
  scheduledActions?: [
    ScheduledActions
  ](name='scheduledActions', description='定时策略配置'),
  target?: long(name='target', description='预留的目标资源个数'),
  targetTrackingPolicies?: [
    TargetTrackingPolicies
  ](name='targetTrackingPolicies', description='指标追踪伸缩策略配置'),
  qualifier?: string(name='qualifier', description='别名名称'),
}

model PutProvisionConfigResponseBody = {
  alwaysAllocateCPU?: boolean(name='alwaysAllocateCPU', description='是否始终分配CPU给函数实例。'),
  current?: long(name='current', description='实际资源个数'),
  resource?: string(name='resource', description='资源描述'),
  scheduledActions?: [
    ScheduledActions
  ](name='scheduledActions', description='定时策略配置'),
  target?: long(name='target', description='目标资源个数'),
  targetTrackingPolicies?: [
    TargetTrackingPolicies
  ](name='targetTrackingPolicies', description='指标追踪伸缩策略配置'),
}

model PutProvisionConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PutProvisionConfigResponseBody(name='body'),
}

async function putProvisionConfig(serviceName: string, functionName: string, request: PutProvisionConfigRequest): PutProvisionConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new PutProvisionConfigHeaders{};
  return putProvisionConfigWithOptions(serviceName, functionName, request, headers, runtime);
}

async function putProvisionConfigWithOptions(serviceName: string, functionName: string, request: PutProvisionConfigRequest, headers: PutProvisionConfigHeaders, runtime: Util.RuntimeOptions): PutProvisionConfigResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.alwaysAllocateCPU)) {
    body['alwaysAllocateCPU'] = request.alwaysAllocateCPU;
  }
  if (!Util.isUnset(request.scheduledActions)) {
    body['scheduledActions'] = request.scheduledActions;
  }
  if (!Util.isUnset(request.target)) {
    body['target'] = request.target;
  }
  if (!Util.isUnset(request.targetTrackingPolicies)) {
    body['targetTrackingPolicies'] = request.targetTrackingPolicies;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PutProvisionConfig',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/provision-config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RegisterEventSourceHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model RegisterEventSourceRequest {
  sourceArn?: string(name='sourceArn', description='事件源资源标识符'),
  qualifier?: string(name='qualifier', description='别名或版本'),
}

model RegisterEventSourceResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  sourceArn?: string(name='sourceArn', description='事件源资源标识符'),
}

model RegisterEventSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterEventSourceResponseBody(name='body'),
}

async function registerEventSource(serviceName: string, functionName: string, request: RegisterEventSourceRequest): RegisterEventSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new RegisterEventSourceHeaders{};
  return registerEventSourceWithOptions(serviceName, functionName, request, headers, runtime);
}

async function registerEventSourceWithOptions(serviceName: string, functionName: string, request: RegisterEventSourceRequest, headers: RegisterEventSourceHeaders, runtime: Util.RuntimeOptions): RegisterEventSourceResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var body : map[string]any= {};
  if (!Util.isUnset(request.sourceArn)) {
    body['sourceArn'] = request.sourceArn;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RegisterEventSource',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/event-sources`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopStatefulAsyncInvocationHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model StopStatefulAsyncInvocationRequest {
  qualifier?: string(name='qualifier'),
}

model StopStatefulAsyncInvocationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function stopStatefulAsyncInvocation(serviceName: string, functionName: string, invocationId: string, request: StopStatefulAsyncInvocationRequest): StopStatefulAsyncInvocationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new StopStatefulAsyncInvocationHeaders{};
  return stopStatefulAsyncInvocationWithOptions(serviceName, functionName, invocationId, request, headers, runtime);
}

async function stopStatefulAsyncInvocationWithOptions(serviceName: string, functionName: string, invocationId: string, request: StopStatefulAsyncInvocationRequest, headers: StopStatefulAsyncInvocationHeaders, runtime: Util.RuntimeOptions): StopStatefulAsyncInvocationResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  invocationId = OpenApiUtil.getEncodeParam(invocationId);
  var query : map[string]any= {};
  if (!Util.isUnset(request.qualifier)) {
    query['qualifier'] = request.qualifier;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopStatefulAsyncInvocation',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/stateful-async-invocations/${invocationId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model TagResourceHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model TagResourceRequest {
  resourceArn?: string(name='resourceArn'),
  tags?: map[string]string(name='tags'),
}

model TagResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function tagResource(request: TagResourceRequest): TagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new TagResourceHeaders{};
  return tagResourceWithOptions(request, headers, runtime);
}

async function tagResourceWithOptions(request: TagResourceRequest, headers: TagResourceHeaders, runtime: Util.RuntimeOptions): TagResourceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.resourceArn)) {
    body['resourceArn'] = request.resourceArn;
  }
  if (!Util.isUnset(request.tags)) {
    body['tags'] = request.tags;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TagResource',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/tag`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UntagResourceHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model UntagResourceRequest {
  all?: boolean(name='all', description='删除所有 tag，默认值为 false'),
  resourceArn?: string(name='resourceArn', description='目前只能给 top level 资源 service 进行标签的相关操作, ARN 可以是类似 services/foo 或者 acs:fc:cn-shanghai:123456789:services/foo'),
  tagKeys?: [ string ](name='tagKeys', description='tag key 值列表， 最大为 20，当 all=false， length 至少为 1. 当 length 大于 1 时， 可以忽略 all 值'),
}

model UntagResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function untagResource(request: UntagResourceRequest): UntagResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UntagResourceHeaders{};
  return untagResourceWithOptions(request, headers, runtime);
}

async function untagResourceWithOptions(request: UntagResourceRequest, headers: UntagResourceHeaders, runtime: Util.RuntimeOptions): UntagResourceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.all)) {
    body['all'] = request.all;
  }
  if (!Util.isUnset(request.resourceArn)) {
    body['resourceArn'] = request.resourceArn;
  }
  if (!Util.isUnset(request.tagKeys)) {
    body['tagKeys'] = request.tagKeys;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UntagResource',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/tag`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model UpdateAliasHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model UpdateAliasRequest {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
  description?: string(name='description', description='别名描述'),
  versionId?: string(name='versionId', description='版本ID'),
}

model UpdateAliasResponseBody = {
  additionalVersionWeight?: map[string]float(name='additionalVersionWeight', description='额外版本权重'),
  aliasName?: string(name='aliasName', description='别名名称'),
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='别名描述'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  versionId?: string(name='versionId', description='版本ID'),
}

model UpdateAliasResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAliasResponseBody(name='body'),
}

async function updateAlias(serviceName: string, aliasName: string, request: UpdateAliasRequest): UpdateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UpdateAliasHeaders{};
  return updateAliasWithOptions(serviceName, aliasName, request, headers, runtime);
}

async function updateAliasWithOptions(serviceName: string, aliasName: string, request: UpdateAliasRequest, headers: UpdateAliasHeaders, runtime: Util.RuntimeOptions): UpdateAliasResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  aliasName = OpenApiUtil.getEncodeParam(aliasName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.additionalVersionWeight)) {
    body['additionalVersionWeight'] = request.additionalVersionWeight;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.versionId)) {
    body['versionId'] = request.versionId;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlias',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/aliases/${aliasName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateCustomDomainHeaders {
  commonHeaders?: map[string]string,
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model UpdateCustomDomainRequest {
  certConfig?: CertConfig(name='certConfig'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
}

model UpdateCustomDomainResponseBody = {
  accountId?: string(name='accountId'),
  apiVersion?: string(name='apiVersion'),
  certConfig?: CertConfig(name='certConfig'),
  createdTime?: string(name='createdTime'),
  domainName?: string(name='domainName'),
  lastModifiedTime?: string(name='lastModifiedTime'),
  protocol?: string(name='protocol'),
  routeConfig?: RouteConfig(name='routeConfig'),
  tlsConfig?: TLSConfig(name='tlsConfig'),
}

model UpdateCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCustomDomainResponseBody(name='body'),
}

async function updateCustomDomain(domainName: string, request: UpdateCustomDomainRequest): UpdateCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UpdateCustomDomainHeaders{};
  return updateCustomDomainWithOptions(domainName, request, headers, runtime);
}

async function updateCustomDomainWithOptions(domainName: string, request: UpdateCustomDomainRequest, headers: UpdateCustomDomainHeaders, runtime: Util.RuntimeOptions): UpdateCustomDomainResponse {
  Util.validateModel(request);
  domainName = OpenApiUtil.getEncodeParam(domainName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.certConfig)) {
    body['certConfig'] = request.certConfig;
  }
  if (!Util.isUnset(request.protocol)) {
    body['protocol'] = request.protocol;
  }
  if (!Util.isUnset(request.routeConfig)) {
    body['routeConfig'] = request.routeConfig;
  }
  if (!Util.isUnset(request.tlsConfig)) {
    body['tlsConfig'] = request.tlsConfig;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCustomDomain',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/custom-domains/${domainName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateFunctionHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcCodeChecksum?: string(name='X-Fc-Code-Checksum'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model UpdateFunctionRequest {
  instanceConcurrency?: int32(name='InstanceConcurrency'),
  caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
  code?: Code(name='code'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS', description='函数自定义DNS配置'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig', description='Custom Runtime函数详细配置'),
  description?: string(name='description', description='函数描述'),
  environmentVariables?: map[string]string(name='environmentVariables', description='为函数设置的环境变量，可以在函数中获取环境变量的值'),
  handler?: string(name='handler', description='function执行的入口，具体格式和语言相关'),
  initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
  initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
  instanceType?: string(name='instanceType'),
  layers?: [ string ](name='layers'),
  memorySize?: int32(name='memorySize', description='function的内存规格，单位为MB，为64MB的倍数'),
  runtime?: string(name='runtime', description='runtime'),
  timeout?: int32(name='timeout', description='function运行的超时时间，单位为秒，最小1秒，默认3秒。function超过这个时间后会被终止执行'),
}

model UpdateFunctionResponseBody = {
  caPort?: int32(name='caPort', description='自定义、自定义容器运行时 HTTP Server 的监听端口'),
  codeChecksum?: string(name='codeChecksum', description='function code包的CRC64值'),
  codeSize?: long(name='codeSize', description='系统返回的function的code包大小，单位为byte Example : 1024'),
  createdTime?: string(name='createdTime', description='function创建时间'),
  customContainerConfig?: CustomContainerConfig(name='customContainerConfig'),
  customDNS?: CustomDNS(name='customDNS', description='函数自定义DNS配置'),
  customRuntimeConfig?: CustomRuntimeConfig(name='customRuntimeConfig', description='Custom Runtime函数详细配置'),
  description?: string(name='description', description='函数描述'),
  environmentVariables?: map[string]string(name='environmentVariables', description='为函数设置的环境变量，可以在函数中获取环境变量的值'),
  functionId?: string(name='functionId', description='系统为每个function生成的唯一ID'),
  functionName?: string(name='functionName', description='函数名称'),
  handler?: string(name='handler', description='function的执行入口'),
  initializationTimeout?: int32(name='initializationTimeout', description='初始化function运行的超时时间，单位为秒，最小1秒，默认3秒。初始化function超过这个时间后会被终止执行'),
  initializer?: string(name='initializer', description='初始化 function 执行的入口，具体格式和语言相关'),
  instanceLifecycleConfig?: InstanceLifecycleConfig(name='instanceLifecycleConfig'),
  instanceSoftConcurrency?: int32(name='instanceSoftConcurrency'),
  instanceType?: string(name='instanceType'),
  lastModifiedTime?: string(name='lastModifiedTime', description='function上次修改时间'),
  layers?: [ string ](name='layers'),
  memorySize?: int32(name='memorySize', description='function设置的内存大小，单位为MB'),
  runtime?: string(name='runtime', description='function运行的语言环境，目前支持nodejs6, nodejs8, python2.7, python3, java8'),
  timeout?: int32(name='timeout', description='运行的超时时间，单位为秒'),
}

model UpdateFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFunctionResponseBody(name='body'),
}

async function updateFunction(serviceName: string, functionName: string, request: UpdateFunctionRequest): UpdateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UpdateFunctionHeaders{};
  return updateFunctionWithOptions(serviceName, functionName, request, headers, runtime);
}

async function updateFunctionWithOptions(serviceName: string, functionName: string, request: UpdateFunctionRequest, headers: UpdateFunctionHeaders, runtime: Util.RuntimeOptions): UpdateFunctionResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.instanceConcurrency)) {
    body['InstanceConcurrency'] = request.instanceConcurrency;
  }
  if (!Util.isUnset(request.caPort)) {
    body['caPort'] = request.caPort;
  }
  if (!Util.isUnset(request.code)) {
    body['code'] = request.code;
  }
  if (!Util.isUnset(request.customContainerConfig)) {
    body['customContainerConfig'] = request.customContainerConfig;
  }
  if (!Util.isUnset(request.customDNS)) {
    body['customDNS'] = request.customDNS;
  }
  if (!Util.isUnset(request.customRuntimeConfig)) {
    body['customRuntimeConfig'] = request.customRuntimeConfig;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.environmentVariables)) {
    body['environmentVariables'] = request.environmentVariables;
  }
  if (!Util.isUnset(request.handler)) {
    body['handler'] = request.handler;
  }
  if (!Util.isUnset(request.initializationTimeout)) {
    body['initializationTimeout'] = request.initializationTimeout;
  }
  if (!Util.isUnset(request.initializer)) {
    body['initializer'] = request.initializer;
  }
  if (!Util.isUnset(request.instanceLifecycleConfig)) {
    body['instanceLifecycleConfig'] = request.instanceLifecycleConfig;
  }
  if (!Util.isUnset(request.instanceSoftConcurrency)) {
    body['instanceSoftConcurrency'] = request.instanceSoftConcurrency;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['instanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.layers)) {
    body['layers'] = request.layers;
  }
  if (!Util.isUnset(request.memorySize)) {
    body['memorySize'] = request.memorySize;
  }
  if (!Util.isUnset(request.runtime)) {
    body['runtime'] = request.runtime;
  }
  if (!Util.isUnset(request.timeout)) {
    body['timeout'] = request.timeout;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcCodeChecksum)) {
    realHeaders['X-Fc-Code-Checksum'] = Util.toJSONString(headers.xFcCodeChecksum);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFunction',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateServiceHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model UpdateServiceRequest {
  description?: string(name='description', description='服务描述'),
  internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  role?: string(name='role', description='服务角色'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model UpdateServiceResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description', description='服务描述'),
  internetAccess?: boolean(name='internetAccess', description='公网访问设置'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次更新时间'),
  logConfig?: LogConfig(name='logConfig'),
  nasConfig?: NASConfig(name='nasConfig'),
  role?: string(name='role', description='服务角色'),
  serviceId?: string(name='serviceId', description='服务ID'),
  serviceName?: string(name='serviceName', description='服务名称'),
  tracingConfig?: TracingConfig(name='tracingConfig'),
  vendorConfig?: VendorConfig(name='vendorConfig'),
  vpcConfig?: VPCConfig(name='vpcConfig'),
}

model UpdateServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServiceResponseBody(name='body'),
}

async function updateService(serviceName: string, request: UpdateServiceRequest): UpdateServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UpdateServiceHeaders{};
  return updateServiceWithOptions(serviceName, request, headers, runtime);
}

async function updateServiceWithOptions(serviceName: string, request: UpdateServiceRequest, headers: UpdateServiceHeaders, runtime: Util.RuntimeOptions): UpdateServiceResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.internetAccess)) {
    body['internetAccess'] = request.internetAccess;
  }
  if (!Util.isUnset(request.logConfig)) {
    body['logConfig'] = request.logConfig;
  }
  if (!Util.isUnset(request.nasConfig)) {
    body['nasConfig'] = request.nasConfig;
  }
  if (!Util.isUnset(request.role)) {
    body['role'] = request.role;
  }
  if (!Util.isUnset(request.tracingConfig)) {
    body['tracingConfig'] = request.tracingConfig;
  }
  if (!Util.isUnset(request.vpcConfig)) {
    body['vpcConfig'] = request.vpcConfig;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateService',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateTriggerHeaders {
  commonHeaders?: map[string]string,
  ifMatch?: string(name='If-Match', description='用于确保实际更改的资源和期望更改的资源是一致的，该值来自Create，Get和Update API的响应'),
  xFcAccountId?: string(name='X-Fc-Account-Id'),
  xFcDate?: string(name='X-Fc-Date'),
  xFcTraceId?: string(name='X-Fc-Trace-Id'),
}

model UpdateTriggerRequest {
  description?: string(name='description'),
  invocationRole?: string(name='invocationRole', description='event source，如OSS，使用该role去invoke function'),
  qualifier?: string(name='qualifier', description='service版本'),
  triggerConfig?: string(name='triggerConfig', description='trigger配置，针对不同的trigger类型，trigger配置会有所不同'),
}

model UpdateTriggerResponseBody = {
  createdTime?: string(name='createdTime', description='创建时间'),
  description?: string(name='description'),
  domainName?: string(name='domainName', description='域名名称，使用域名名称拼接上函数计算域名，可以采用HTTP协议调用到触发器对应版本的函数。例如{domainName}.cn-shanghai.fc.aliyuncs.com'),
  invocationRole?: string(name='invocationRole', description='调用函数使用的RAM角色的ARN'),
  lastModifiedTime?: string(name='lastModifiedTime', description='上次修改时间'),
  qualifier?: string(name='qualifier', description='service版本'),
  sourceArn?: string(name='sourceArn', description='event source的Aliyun Resource Name（ARN'),
  triggerConfig?: string(name='triggerConfig', description='trigger配置对象'),
  triggerId?: string(name='triggerId'),
  triggerName?: string(name='triggerName', description='trigger名称'),
  triggerType?: string(name='triggerType', description='trigger类型，如 oss, log, tablestore, timer, http, cdn_events, mns_topic'),
  urlInternet?: string(name='urlInternet', description='公网域名地址。在互联网可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
  urlIntranet?: string(name='urlIntranet', description='私网域名地址。在VPC可以通过HTTP协议或者HTTPS协议访问HTTP Trigger。'),
}

model UpdateTriggerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTriggerResponseBody(name='body'),
}

async function updateTrigger(serviceName: string, functionName: string, triggerName: string, request: UpdateTriggerRequest): UpdateTriggerResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UpdateTriggerHeaders{};
  return updateTriggerWithOptions(serviceName, functionName, triggerName, request, headers, runtime);
}

async function updateTriggerWithOptions(serviceName: string, functionName: string, triggerName: string, request: UpdateTriggerRequest, headers: UpdateTriggerHeaders, runtime: Util.RuntimeOptions): UpdateTriggerResponse {
  Util.validateModel(request);
  serviceName = OpenApiUtil.getEncodeParam(serviceName);
  functionName = OpenApiUtil.getEncodeParam(functionName);
  triggerName = OpenApiUtil.getEncodeParam(triggerName);
  var body : map[string]any= {};
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.invocationRole)) {
    body['invocationRole'] = request.invocationRole;
  }
  if (!Util.isUnset(request.qualifier)) {
    body['qualifier'] = request.qualifier;
  }
  if (!Util.isUnset(request.triggerConfig)) {
    body['triggerConfig'] = request.triggerConfig;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.ifMatch)) {
    realHeaders['If-Match'] = Util.toJSONString(headers.ifMatch);
  }
  if (!Util.isUnset(headers.xFcAccountId)) {
    realHeaders['X-Fc-Account-Id'] = Util.toJSONString(headers.xFcAccountId);
  }
  if (!Util.isUnset(headers.xFcDate)) {
    realHeaders['X-Fc-Date'] = Util.toJSONString(headers.xFcDate);
  }
  if (!Util.isUnset(headers.xFcTraceId)) {
    realHeaders['X-Fc-Trace-Id'] = Util.toJSONString(headers.xFcTraceId);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTrigger',
    version = '2021-04-06',
    protocol = 'HTTPS',
    pathname = `/2021-04-06/services/${serviceName}/functions/${functionName}/triggers/${triggerName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

