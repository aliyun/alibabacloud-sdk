/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'ddoscoo';
  @version = '2020-01-01';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddAutoCcBlacklistRequest {
  regionId?: string(name='RegionId', position='Host'),
  blacklist: string(name='Blacklist', description='The IP addresses that you want to manage. This parameter is a JSON string. The string contains the following field:

*   **src**: the IP address. This field is required and must be of the STRING type.', example='[{"src":"198.51.XX.XX"},{"src":"198.52.XX.XX"}]', position='Query'),
  expireTime: int32(name='ExpireTime', description='The expiration time. You can specify a custom expiration time. Valid values: **300** to **604800**. Unit: seconds.', example='300', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the **DescribeInstanceIds** operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
}

model AddAutoCcBlacklistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model AddAutoCcBlacklistResponse = {
  headers: map[string]string(name='headers'),
  body: AddAutoCcBlacklistResponseBody(name='body'),
}

async function addAutoCcBlacklist(request: AddAutoCcBlacklistRequest): AddAutoCcBlacklistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddAutoCcBlacklist', 'POST', '/', 'json', false, 'json', request);
}

model AddAutoCcWhitelistRequest {
  regionId?: string(name='RegionId', position='Host'),
  expireTime?: int32(name='ExpireTime', description='This parameter is deprecated.

> This parameter indicates the validity period of the IP address blacklist. By default, the traffic from the IP addresses that you add to the whitelist is always allowed. You do not need to set this parameter.', example='0', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  whitelist: string(name='Whitelist', description='The configuration of the IP addresses that you want to add to the whitelist. The value is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that contains the following fields:

*   **src**: the IP address that you want to add. This parameter is required. Data type: string.', example='[{"src":"192.XX.XX.1"},{"src":"192.XX.XX.2"}]', position='Query'),
}

model AddAutoCcWhitelistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='AB5025DA-5C52-5207-B6AC-3F198758B678'),
}

model AddAutoCcWhitelistResponse = {
  headers: map[string]string(name='headers'),
  body: AddAutoCcWhitelistResponseBody(name='body'),
}

/**
  * You can call the AddAutoCcWhitelist operation to add IP addresses to the whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance. This way, the Anti-DDoS Pro or Anti-DDoS Premium instance allows traffic from the IP addresses.
  * By default, the traffic from the IP addresses that you add to the whitelist is always allowed. If you no longer use the whitelist, you can call the [EmptyAutoCcWhitelist](~~157505~~) operation to remove the IP addresses from the whitelist.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function addAutoCcWhitelist(request: AddAutoCcWhitelistRequest): AddAutoCcWhitelistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddAutoCcWhitelist', 'POST', '/', 'json', false, 'json', request);
}

model AssociateWebCertRequest {
  regionId?: string(name='RegionId', position='Host'),
  cert?: string(name='Cert', description='The public key of the certificate that you want to associate. This parameter must be used together with the **CertName** and **Key** parameters.

> If you specify a value for the **CertName**, **Cert**, and **Key** parameters, you do not need to specify a value for the **CertId** parameter.', example='-----BEGIN CERTIFICATE----- 62EcYPWd2Oy1vs6MTXcJSfN9Z7rZ9fmxWr2BFN2XbahgnsSXM48ixZJ4krc+1M+j2kcubVpsE2cgHdj4v8H6jUz9Ji4mr7vMNS6dXv8PUkl/qoDeNGCNdyTS5NIL5ir+g92cL8IGOkjgvhlqt9vc65Cgb4mL+n5+DV9uOyTZTW/MojmlgfUekC2xiXa54nxJf17Y1TADGSbyJbsC0Q9nIrHsPl8YKkvRWvIAqYxXZ7wRwWWmv4TMxFhWRiNY7yZIo2ZUhl02SIDNggIEeg== -----END CERTIFICATE-----', position='Query'),
  certId?: int32(name='CertId', description='The ID of the certificate that you want to associate. If the certificate that you want to associate has been issued in Certificate Management Service, you can specify the certificate ID to associate the certificate.

> If you specify the certificate ID, you do not need to specify a value for the **CertName**, **Cert**, and **Key** parameters.', example='2404693', position='Query'),
  certName?: string(name='CertName', description='The name of the certificate that you want to associate. This parameter must be used together with the **Cert** and **Key** parameters.

> If you specify a value for the **CertName**, **Cert**, and **Key** parameters, you do not need to specify a value for the **CertId** parameter.', example='example-cert', position='Query'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  key?: string(name='Key', description='The private key of the certificate that you want to associate. This parameter must be used together with the **CertName** and **Cert** parameters.

> If you specify a value for the **CertName**, **Cert**, and **Key** parameters, you do not need to specify a value for the **CertId** parameter.', example='-----BEGIN RSA PRIVATE KEY----- DADTPZoOHd9WtZ3UKHJTRgNQmioPQn2bqdKHop+B/dn/4VZL7Jt8zSDGM9sTMThLyvsmLQKBgQCr+ujntC1kN6pGBj2Fw2l/EA/W3rYEce2tyhjgmG7rZ+A/jVE9fld5sQra6ZdwBcQJaiygoIYoaMF2EjRwc0qwHaluq0C15f6ujSoHh2e+D5zdmkTg/3NKNjqNv6xA2gYpinVDzFdZ9Zujxvuh9o4Vqf0YF8bv5UK5G04RtKadOw== -----END RSA PRIVATE KEY-----', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model AssociateWebCertResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='40F11005-A75C-4644-95F2-52A4E7D43E91'),
}

model AssociateWebCertResponse = {
  headers: map[string]string(name='headers'),
  body: AssociateWebCertResponseBody(name='body'),
}

async function associateWebCert(request: AssociateWebCertRequest): AssociateWebCertResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AssociateWebCert', 'POST', '/', 'json', false, 'json', request);
}

model AttachSceneDefenseObjectRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  objectType: string(name='ObjectType', description='The type of the object. Set the value to **Domain**, which indicates a domain name.', example='Domain', position='Query'),
  objects: string(name='Objects', description='The object that you want to add to the policy. Separate multiple objects with commas (,).', example='www.aliyun.com', position='Query'),
  policyId: string(name='PolicyId', description='The ID of the policy.

> You can call the [DescribeSceneDefensePolicies](~~159382~~) operation to query the IDs of all policies.', example='321a-fd31-df51-****', position='Query'),
}

model AttachSceneDefenseObjectResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model AttachSceneDefenseObjectResponse = {
  headers: map[string]string(name='headers'),
  body: AttachSceneDefenseObjectResponseBody(name='body'),
}

async function attachSceneDefenseObject(request: AttachSceneDefenseObjectRequest): AttachSceneDefenseObjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachSceneDefenseObject', 'POST', '/', 'json', false, 'json', request);
}

model ConfigL7RsPolicyRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query the domain names for which forwarding rules are configured.', example='www.aliyun.com', position='Query'),
  policy: string(name='Policy', description='The back-to-origin policy. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:

*   **ProxyMode**: The load balancing algorithm for back-to-origin traffic. This field is required and must be a string. Valid values:

    *   **ip_hash**: the IP hash algorithm. This algorithm is used to redirect the requests from the same IP address to the same origin server.
    *   **rr**: the round-robin algorithm. This algorithm is used to redirect requests to origin servers in turn. If you use this algorithm, you can specify a weight for each server based on server performance.
    *   **least_time**: the least response time algorithm. This algorithm is used to minimize the latency when requests are forwarded from Anti-DDoS Pro or Anti-DDoS Premium instances to origin servers based on the intelligent DNS resolution feature.

*   **Attributes**: the parameters for back-to-origin. This field is optional and must be a JSON array. Each element in the array contains the following fields:

    *   **RealServer**: the address of the origin server. This field is optional and must be a string.

    *   **Attribute**: the parameter for back-to-origin. This field is optional and must be a JSON object. The value contains the following field:

        *   **Weight**: the weight of the server. This field is optional and must be an integer. This field takes effect only when **ProxyMode** is set to **rr**. Valid values: **1** to **100**. Default value: **100**. An origin server with a higher weight receives more requests.', example='{"ProxyMode":"rr","Attributes":[{"RealServer":"1.***.***.1","Attribute":{"Weight":100}},{"RealServer":"2.***.***.2","Attribute":{"Weight":100}}]}', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](~~94485~~).', example='rg-acfm2pz25js****', position='Query'),
}

model ConfigL7RsPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ConfigL7RsPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigL7RsPolicyResponseBody(name='body'),
}

/**
  * If multiple origin servers are configured for a website that is added to Anti-DDoS Pro or Anti-DDoS Premium, you can modify the load balancing algorithms for back-to-origin traffic based on back-to-origin policies. The IP hash algorithm is used by default. You can change the algorithm to the round-robin or least response time algorithm. For more information, see the description of the **Policy** parameter in the "Request parameters" section of this topic.
  *
 */
async function configL7RsPolicy(request: ConfigL7RsPolicyRequest): ConfigL7RsPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigL7RsPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ConfigLayer4RemarkRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  listeners: string(name='Listeners', description='The port forwarding rule that you want to manage.

This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can perform this operation only on one port forwarding rule at a time.

> You can call the [DescribeNetworkRules](~~157484~~) to query existing port forwarding rules.

Each port forwarding rule contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
*   **Remark**: the remarks of the port forwarding rule. This field is required and must be of the STRING type. The value can contain letters, digits, and some special characters, such as `, . + - * / _`. The value can be up to 200 characters in length.', example='[{\\"InstanceId\\":\\"ddosDip-sg-4hr2b3l****\\",\\"FrontendPort\\":2020,\\"Protocol\\":\\"udp\\",\\"Remark\\":\\"test\\"}]', position='Query'),
}

model ConfigLayer4RemarkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6E46CC51-36BE-1100-B14C-DAF8381B8F73'),
}

model ConfigLayer4RemarkResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigLayer4RemarkResponseBody(name='body'),
}

async function configLayer4Remark(request: ConfigLayer4RemarkRequest): ConfigLayer4RemarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigLayer4Remark', 'POST', '/', 'json', false, 'json', request);
}

model ConfigLayer4RuleBakModeRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  bakMode: string(name='BakMode', description='The mode that you want to use to forward service traffic. Valid values:

*   **0**: the default mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the origin IP address that you specified when you created the port forwarding rule. You can call the [CreateNetworkRules](~~157482~~) operation to create a port forwarding rule.
*   **1**: the origin redundancy mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary or secondary origin servers. You can call the [ConfigLayer4RulePolicy](~~312684~~) operation to configure IP addresses.', example='1', position='Query'),
  listeners: string(name='Listeners', description='The port forwarding rule that you want to manage.

This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can perform this operation only on one port forwarding rule at a time.

> You can call the [DescribeNetworkRules](~~157484~~) to query existing port forwarding rules.

Each port forwarding rule contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.', example='[{\\"InstanceId\\":\\"ddosDip-sg-4hr2b3l****\\",\\"FrontendPort\\":2020,\\"Protocol\\":\\"udp\\"}]', position='Query'),
}

model ConfigLayer4RuleBakModeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CC042262-15A3-4A49-ADF0-130968EA47BC'),
}

model ConfigLayer4RuleBakModeResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigLayer4RuleBakModeResponseBody(name='body'),
}

async function configLayer4RuleBakMode(request: ConfigLayer4RuleBakModeRequest): ConfigLayer4RuleBakModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigLayer4RuleBakMode', 'POST', '/', 'json', false, 'json', request);
}

model ConfigLayer4RulePolicyRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  listeners: string(name='Listeners', description='The port forwarding rule that you want to manage.

This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can perform this operation only on one port forwarding rule at a time.

> You can call the [DescribeNetworkRules](~~157484~~) to query existing port forwarding rules.

Each port forwarding rule contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.

*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.

*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.

*   **BackendPort**: the port of the origin server. This field is required and must be of the INTEGER type.

*   **PriRealServers**: the IP addresses of the primary origin server. This field is required and must be a JSON array. Each element in a JSON array indicates an IP address of the primary origin server. You can configure a maximum of 20 IP addresses.

    Each element in the JSON array contains the following field:

    *   **RealServer**: the IP address of the primary origin server. This field is required and must be of the STRING type.

*   **SecRealServers**: the IP addresses of the secondary origin server. This field is required and must be a JSON array. Each element in a JSON array indicates an IP address of the secondary origin server. You can configure a maximum of 20 IP addresses.

    Each element in the JSON array contains the following field:

    *   **RealServer**: the IP address of the secondary origin server. This field is required and must be of the STRING type.

*   **CurrentRsIndex**: the origin server that you want to use to receive service traffic. This field is required and must be of the INTEGER type. Valid values:

    *   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
    *   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.', example='[{\\"InstanceId\\":\\"ddosDip-sg-4hr2b3l****\\",\\"Protocol\\":\\"udp\\",\\"FrontendPort\\":2020,\\"BackendPort\\":2022,\\"PriRealServers\\":[{\\"RealServer\\":\\"192.0.2.1\\"},{\\"RealServer\\":\\"192.0.2.2\\"}],\\"SecRealServers\\":[{\\"RealServer\\":\\"192.0.2.3\\"},{\\"RealServer\\":\\"192.0.2.4\\"}],\\"CurrentRsIndex\\":1}]', position='Query'),
}

model ConfigLayer4RulePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CC042262-15A3-4A49-ADF0-130968EA47BC'),
}

model ConfigLayer4RulePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigLayer4RulePolicyResponseBody(name='body'),
}

async function configLayer4RulePolicy(request: ConfigLayer4RulePolicyRequest): ConfigLayer4RulePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigLayer4RulePolicy', 'POST', '/', 'json', false, 'json', request);
}

model ConfigNetworkRegionBlockRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  config: string(name='Config', description='The details of the configurations of blocked locations. This parameter is a JSON string. The value consists of the following fields:

*   **RegionBlockSwitch**: the status of the Location Blacklist policy. This field is required and must be of the string type. Valid values:

    *   **on**: enables the policy.
    *   **off**: disables the policy.

*   **Countries**: the codes of the countries or areas from which you want to block requests. This field is optional and must be of the array type.

    **

    **Note**For more information, see the **Codes of countries and areas** section of the [Codes of administrative regions in China and codes of countries and areas](~~167926~~) topic.

    For example, `[1,2]` specifies China and Australia.

*   **Provinces**: the codes of the administrative regions in China from which you want to block requests. This field is optional and must be of the array type.

    **

    **Note**For more information, see the **Codes of administrative regions in China** section of the [Codes of administrative regions in China and codes of countries and areas](~~167926~~) topic.

    For example, `[11,12]` specifies Beijing and Tianjin.', example='{"RegionBlockSwitch":"off","Countries":[],"Provinces":[11,12,13,14,15,21,22,23,31,32,33,34,35,36,37,41,42,43,44,45,46,50,51,52,53,54,61,62,63,64,65,71,81,82]}', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
}

model ConfigNetworkRegionBlockResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model ConfigNetworkRegionBlockResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigNetworkRegionBlockResponseBody(name='body'),
}

async function configNetworkRegionBlock(request: ConfigNetworkRegionBlockRequest): ConfigNetworkRegionBlockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigNetworkRegionBlock', 'POST', '/', 'json', false, 'json', request);
}

model ConfigNetworkRulesRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  networkRules: string(name='NetworkRules', description='The details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
*   **BackendPort**: the port of the origin server. This field is required and must be of the INTEGER type.
*   **RealServers**: the IP addresses of the origin server. This field is required and must be a JSON array. You can specify up to 20 IP addresses.

> You can modify only the value of **RealServers** when you modify a port forwarding rule.', example='[{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080,"BackendPort":8080,"RealServers":["1.1.1.1","2.2.2.2","3.3.3.3"]}]', position='Query'),
}

model ConfigNetworkRulesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CC042262-15A3-4A49-ADF0-130968EA47BC'),
}

model ConfigNetworkRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigNetworkRulesResponseBody(name='body'),
}

async function configNetworkRules(request: ConfigNetworkRulesRequest): ConfigNetworkRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigNetworkRules', 'POST', '/', 'json', false, 'json', request);
}

model ConfigUdpReflectRequest {
  config: string(name='Config', description='The configuration of the filtering policy for UDP reflection attacks.

The value is a string that consists of a JSON struct. The JSON struct contains the following field:

*   **UdpSports**: the source ports of the UDP traffic that you want to block. This field is required and must be of the ARRAY type. Example: `[17,19]`.

    We recommend that you block the following source ports of UDP traffic:

    *   UDP 17: QOTD reflection attacks
    *   UDP 19: CharGEN reflection attacks
    *   UDP 69: TFTP reflection attacks
    *   UDP 111: Portmap reflection attacks
    *   UDP 123: NTP reflection attacks
    *   UDP 137: NetBIOS reflection attacks
    *   UDP 161: SNMPv2 reflection attacks
    *   UDP 389: CLDAP reflection attacks
    *   UDP 1194: OpenVPN reflection attacks
    *   UDP 1900: SSDP reflection attacks
    *   UDP 3389: RDP reflection attacks
    *   UDP 11211: memcached reflection attacks', example='{\\"UdpSports\\":[17,19]}', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-i7m25564****', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the instance. Valid values:

*   **cn-hangzhou**: Chinese mainland, which indicates Anti-DDoS Pro instances. This is the default value.
*   **ap-southeast-1**: outside the Chinese mainland, which indicates Anti-DDoS Premium instances.', example='cn-hangzhou', position='Query'),
}

model ConfigUdpReflectResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='9EC62E89-BD30-4FCD-9CB8-FA53865FF0D7'),
}

model ConfigUdpReflectResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigUdpReflectResponseBody(name='body'),
}

/**
  * You can call this operation to configure filtering policies to filter out UDP traffic from specific ports. This helps defend against UDP reflection attacks.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function configUdpReflect(request: ConfigUdpReflectRequest): ConfigUdpReflectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigUdpReflect', 'POST', '/', 'json', false, 'json', request);
}

model ConfigWebCCTemplateRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  template: string(name='Template', description='The mode of the Frequency Control policy. Valid values:

*   **default**: Normal
*   **gf_under_attack**: Emergency
*   **gf_sos_verify**: Strict
*   **gf_sos_enhance**: Super Strict', example='default', position='Query'),
}

model ConfigWebCCTemplateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ConfigWebCCTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigWebCCTemplateResponseBody(name='body'),
}

async function configWebCCTemplate(request: ConfigWebCCTemplateRequest): ConfigWebCCTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigWebCCTemplate', 'POST', '/', 'json', false, 'json', request);
}

model ConfigWebIpSetRequest {
  regionId?: string(name='RegionId', position='Host'),
  blackList?: [ string ](name='BlackList', description='IP address N or CIDR block N that you want to add to the blacklist. The maximum value of N is 200. You can add up to 200 IP addresses or CIDR blocks to the blacklist.', example='1.1.1.1', position='Query'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  whiteList?: [ string ](name='WhiteList', description='IP address N or CIDR block N that you want to add to the whitelist. The maximum value of N is 200. You can add up to 200 IP addresses or CIDR blocks to the whitelist.', example='2.2.2.2/24', position='Query'),
}

model ConfigWebIpSetResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ConfigWebIpSetResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigWebIpSetResponseBody(name='body'),
}

async function configWebIpSet(request: ConfigWebIpSetRequest): ConfigWebIpSetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigWebIpSet', 'POST', '/', 'json', false, 'json', request);
}

model CreateAsyncTaskRequest {
  regionId?: string(name='RegionId', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  taskParams: string(name='TaskParams', description='The details of the asynchronous export task. The value is a JSON string. The field in the value varies with **TaskType**.

If **TaskType** is set to **1**, **3**, **4**, **5**, or **6**, the following filed is returned:

*   **instanceId**: the ID of the instance. This field is required and must be of the STRING type.

If **TaskType** is set to **2**, the following field is returned:

*   **domain**: the domain name of the website, which must be of the STRING type. If you do not specify this field, the forwarding rules of all websites are exported.', example='{"instanceId": "ddoscoo-cn-mp91j1ao****"}', position='Query'),
  taskType: int32(name='TaskType', description='The type of the asynchronous export task that you want to create. Valid values:

*   **1**: the task to export the port forwarding rules of an instance
*   **2**: the task to export the forwarding rules of a website protected by an instance
*   **3**: the task to export the session persistence and health check settings of an instance
*   **4**: the task to export the anti-DDoS mitigation policies of an instance
*   **5**: the task to download the blacklist for destination IP addresses of an instance
*   **6**: the task to download the whitelist for destination IP addresses of an instance', example='5', position='Query'),
}

model CreateAsyncTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model CreateAsyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAsyncTaskResponseBody(name='body'),
}

async function createAsyncTask(request: CreateAsyncTaskRequest): CreateAsyncTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAsyncTask', 'POST', '/', 'json', false, 'json', request);
}

model CreateDomainResourceRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name of the website that you want to add to the Anti-DDoS Pro or Anti-DDoS Premium instance.', example='www.example.com', position='Query'),
  httpsExt?: string(name='HttpsExt', description='The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:

*   **Http2https**: specifies whether to turn on Enforce HTTPS Routing. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enforce HTTPS Routing is turned off. The value 1 indicates that Enforce HTTPS Routing is turned on. The default value is 0.

    If your website supports both HTTP and HTTPS, this feature meets your business requirements. If you enable this feature, all HTTP requests to access the website are redirected to HTTPS requests on the standard port 443.

*   **Https2http**: specifies whether to turn on Enable HTTP. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP is turned off. The value 1 indicates that Enable HTTP is turned on. The default value is 0.

    If your website does not support HTTPS, this feature meets your business requirements If this feature is enabled, all HTTPS requests are redirected to HTTP requests and forwarded to origin servers. This feature can redirect WebSockets requests to WebSocket requests. Requests are redirected over the standard port 80.

*   **Http2**: specifies whether to turn on Enable HTTP/2. This field is optional. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on. The default value is 0.

    After you turn on the switch, HTTP/2 is used.', example='{"Http2":1,"Http2https":1,"Https2http":1}', position='Query'),
  instanceIds: [ string ](name='InstanceIds', description='An array consisting of the IDs of instances that you want to associate.', position='Query'),
  proxyTypes: [ 
    {
      proxyPorts: [ int32 ](name='ProxyPorts', description='An array that consists of port numbers.'),
      proxyType?: string(name='ProxyType', description='The type of the protocol. Valid values:

*   **http**
*   **https**
*   **websocket**
*   **websockets**', example='http'),
    }
  ](name='ProxyTypes', description='An array that consists of the details of the protocol type and port number.', position='Query'),
  realServers: [ string ](name='RealServers', description='An array that consists of the addresses of origin servers.', position='Query'),
  rsType: int32(name='RsType', description='The address type of the origin server. Valid values:

*   **0**: IP address

*   **1**: domain name

    If you deploy proxies, such as a Web Application Firewall (WAF) instance, between the origin server and the Anti-DDoS Pro or Anti-DDoS Premium instance, set the value to 1. If you use the domain name, you must enter the address of the proxy, such as the CNAME of WAF.', example='0', position='Query'),
}

model CreateDomainResourceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='39499F01-19D9-4EA4-A0E9-C6014BA5CDBE'),
}

model CreateDomainResourceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDomainResourceResponseBody(name='body'),
}

async function createDomainResource(request: CreateDomainResourceRequest): CreateDomainResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDomainResource', 'POST', '/', 'json', false, 'json', request);
}

model CreateNetworkRulesRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  networkRules: string(name='NetworkRules', description='The details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
*   **BackendPort**: the port of the origin server. This field is required and must be of the INTEGER type.
*   **RealServers**: the IP addresses of the origin server. This field is required and must be a JSON array. You can specify up to 20 IP addresses.', example='[{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080,"BackendPort":8080,"RealServers":["1.1.1.1","2.2.2.2"]}]', position='Query'),
}

model CreateNetworkRulesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='ADCA45A5-D15C-4B7D-9F81-138B0B36D0BD'),
}

model CreateNetworkRulesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNetworkRulesResponseBody(name='body'),
}

async function createNetworkRules(request: CreateNetworkRulesRequest): CreateNetworkRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNetworkRules', 'POST', '/', 'json', false, 'json', request);
}

model CreatePortRequest {
  regionId?: string(name='RegionId', position='Host'),
  backendPort?: string(name='BackendPort', description='The port of the origin server. Valid values: **0** to **65535**.', example='55', position='Query'),
  frontendPort: string(name='FrontendPort', description='The forwarding port. Valid values: **0** to **65535**.', example='55', position='Query'),
  frontendProtocol: string(name='FrontendProtocol', description='The type of the protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the Anti-DDoS Pro or Anti-DDoS Premium instance to which the port forwarding rule belongs.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-st21zbyq****', position='Query'),
  realServers: [ string ](name='RealServers', description='An array that consists of the IP addresses of origin servers.', position='Query'),
}

model CreatePortResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4787A9A6-8230-4B4A-8211-AFBF7C416B4D'),
}

model CreatePortResponse = {
  headers: map[string]string(name='headers'),
  body: CreatePortResponseBody(name='body'),
}

/**
  * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](~~95820~~).
  *
 */
async function createPort(request: CreatePortRequest): CreatePortResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePort', 'POST', '/', 'json', false, 'json', request);
}

model CreateSceneDefensePolicyRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  endTime: long(name='EndTime', description='The end time of the policy. This value is a UNIX timestamp. Units: milliseconds.', example='1586016000000', position='Query'),
  name: string(name='Name', description='The name of the policy.', example='testpolicy', position='Query'),
  startTime: long(name='StartTime', description='The start time of the policy. This value is a UNIX timestamp. Units: milliseconds.', example='1585670400000', position='Query'),
  template: string(name='Template', description='The template of the policy. Valid values:

*   **promotion**: important activity
*   **bypass**: all traffic forwarded', example='promotion', position='Query'),
}

model CreateSceneDefensePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model CreateSceneDefensePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSceneDefensePolicyResponseBody(name='body'),
}

async function createSceneDefensePolicy(request: CreateSceneDefensePolicyRequest): CreateSceneDefensePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSceneDefensePolicy', 'POST', '/', 'json', false, 'json', request);
}

model CreateSchedulerRuleRequest {
  regionId?: string(name='RegionId', position='Host'),
  param?: string(name='Param', description='The details of the CDN interaction rule. This parameter is a JSON string. The following list describes the fields in the value of the parameter:

*   **ParamType**: the type of the scheduling rule. This field is required and must be of the string type. Set the value to **cdn**. This indicates that you want to modify a CDN interaction rule.

*   **ParamData**: the values of parameters that you want to modify for the CDN interaction rule. This field is required and must be of the map type. The ParamData parameter contains the following parameters:

    *   **Domain**: the accelerated domain in CDN. This parameter is required and must be of the string type.
    *   **Cname**: the CNAME that is assigned to the accelerated domain. This parameter is required and must be of the string type.
    *   **AccessQps**: the queries per second (QPS) threshold that is used to switch service traffic to Anti-DDoS Pro or Anti-DDoS Premium. This parameter is required and must be of the integer type.
    *   **UpstreamQps**: the QPS threshold that is used to switch service traffic to CDN. This parameter is optional and must be of the integer type.', example='{"ParamType":"cdn","ParamData":"Domain":"example.aliyundoc.com","Cname":"demo.aliyundoc.com","AccessQps":100,"UpstreamQps":100}}', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  ruleName: string(name='RuleName', description='The name of the rule.', example='testrule', position='Query'),
  ruleType: int32(name='RuleType', description='The type of the custom defense rule. Valid values:

*   **2**: tiered protection
*   **3**: network acceleration
*   **5**: CDN interaction
*   **6**: cloud service interaction', example='2', position='Query'),
  rules: string(name='Rules', description='The details of the scheduling rule. This parameter is a JSON string. The following list describes the fields in the value of the parameter:

*   **Type**: the address type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type. Valid values:

    *   **A**: IP address
    *   **CNAME**: domain name

*   **Value**: the address of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type.

*   **Priority**: the priority of the scheduling rule. This field is required and must be of the integer type. Valid values: **0** to **100**. A larger value indicates a higher priority.

*   **ValueType**: the type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the integer type. Valid values:

    *   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
    *   **2**: the IP address of the interaction resource in the tiered protection scenario
    *   **3**: the IP address that is used to accelerate access in the network acceleration scenario
    *   **5**: the domain name that is configured in Alibaba Cloud CDN (CDN) in the CDN interaction scenario
    *   **6** the IP address of the interaction resource in the cloud service interaction scenario

*   **RegionId**: the region where the interaction resource is deployed. This parameter must be specified when **ValueType** is set to **2**. The value must be of the string type.', example='[{"Type":"A", "Value":"1.1.XX.XX", "Priority":80,"ValueType":2, "RegionId":"cn-hangzhou" },{"Type":"A", "Value":"203.199.XX.XX", "Priority":80,"ValueType":1}]', position='Query'),
}

model CreateSchedulerRuleResponseBody = {
  cname?: string(name='Cname', description='The CNAME that is assigned by Sec-Traffic Manager for the scheduling rule.

> To enable the scheduling rule, you must map the domain name of the service to the CNAME.', example='48k7b372gpl4****.aliyunddos0001.com'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8DFB602D-1AAC-46C4-90F2-C84086E7A6E4'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='testrule'),
}

model CreateSchedulerRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSchedulerRuleResponseBody(name='body'),
}

async function createSchedulerRule(request: CreateSchedulerRuleRequest): CreateSchedulerRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSchedulerRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateTagResourcesRequest {
  regionId: string(name='RegionId', description='The region ID of the instance. Set the value to **cn-hangzhou**, which indicates an Anti-DDoS Pro instance in the Chinese mainland.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not specify this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
  resourceIds: [ string ](name='ResourceIds', description='An array consisting of the IDs of the Anti-DDoS Pro instances to which you want to add the tag.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.', example='INSTANCE', position='Query'),
  tags?: [ 
    {
      key?: string(name='Key', description='The key of the tag to add.', example='testkey'),
      value?: string(name='Value', description='The value of the tag to add.', example='testvalue'),
    }
  ](name='Tags', description='An array that consists of the tags to add.', position='Query'),
}

model CreateTagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model CreateTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTagResourcesResponseBody(name='body'),
}

/**
  * You can call the CreateTagResources operation to add a tag to multiple Anti-DDoS Pro instances at a time.
  * > Anti-DDoS Premium does not support the tag feature.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function createTagResources(request: CreateTagResourcesRequest): CreateTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTagResources', 'POST', '/', 'json', false, 'json', request);
}

model CreateWebCCRuleRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  act: string(name='Act', description='The blocking type. Valid values:

*   **close**: blocks the request.
*   **captcha**: enables Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) verification.', example='close', position='Query'),
  count: int32(name='Count', description='The number of requests that are allowed from an individual IP address. Valid values: **2** to **2000**.', example='60', position='Query'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  interval: int32(name='Interval', description='The detection interval. Valid values: **5** to **10800**. Unit: seconds.', example='20', position='Query'),
  mode: string(name='Mode', description='The match mode. Valid values:

*   **prefix**: prefix match.
*   **match**: exact match.

> If the **Uri** of the check path contains parameters, you must set the value to Prefix Match.', example='prefix', position='Query'),
  name: string(name='Name', description='The name of the rule. The name can be up to 128 characters in length and contain letters, digits, and underscores (\\_).', example='testrule', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  ttl: int32(name='Ttl', description='The blocking duration. Valid values: **1** to **1440**. Unit: minutes.', example='10', position='Query'),
  uri: string(name='Uri', description='The check path.', example='/abc/a.php', position='Query'),
}

model CreateWebCCRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model CreateWebCCRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateWebCCRuleResponseBody(name='body'),
}

async function createWebCCRule(request: CreateWebCCRuleRequest): CreateWebCCRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateWebCCRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateWebRuleRequest {
  regionId?: string(name='RegionId', position='Host'),
  defenseId?: string(name='DefenseId', description='The ID of the associated defense. This parameter applies to scenarios in which other cloud services, such as Object Storage Service (OSS), are integrated with Anti-DDoS Pro or Anti-DDoS Premium.

> This parameter is in internal preview. Do not use this parameter.

For example, if you integrate OSS with Anti-DDoS Pro or Anti-DDoS Premium, Anti-DDoS Pro or Anti-DDoS Premium allocates an IP address pool for the OSS production account. Each IP address corresponds to a unique defense ID. A defense ID is a CNAME, which is automatically resolved to the IP address of the required Anti-DDoS Pro or Anti-DDoS Premium instance. A defense ID can be resolved to the same IP address to facilitate scheduling.

> You can specify only one of the following parameters: **InstanceIds** and **DefenseId**.', example='testid', position='Query'),
  domain: string(name='Domain', description='The domain name of the website that you want to add to the instance.', example='example.aliyundoc.com', position='Query'),
  httpsExt?: string(name='HttpsExt', description='The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:

*   **Http2https**: specifies whether to turn on Enforce HTTPS Routing. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enforce HTTPS Routing is turned off. The value 1 indicates that Enforce HTTPS Routing is turned on. The default value is 0.

    If your website supports both HTTP and HTTPS, this feature meets your business requirements. If you enable this feature, all HTTP requests to access the website are redirected to HTTPS requests on the standard port 443.

*   **Https2http**: specifies whether to turn on Enable HTTP. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP is turned off. The value 1 indicates that Enable HTTP is turned on. The default value is 0.

    If your website does not support HTTPS, this feature meets your business requirements If this feature is enabled, all HTTPS requests are redirected to HTTP requests and forwarded to origin servers. This feature can redirect WebSockets requests to WebSocket requests. Requests are redirected over the standard port 80.

*   **Http2**: specifies whether to turn on Enable HTTP/2. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on. The default value is 0.

    After you turn on Enable HTTP/2, the protocol type is HTTP/2.', example='{"Http2":1,"Http2https":1,"Https2http":1}', position='Query'),
  instanceIds?: [ string ](name='InstanceIds', description='An array consisting of the IDs of instances that you want to associate.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](~~94485~~).', example='rg-acfm2pz25js****', position='Query'),
  rsType: int32(name='RsType', description='The address type of the origin server. Valid values:

*   **0**: IP address
*   **1**: domain name The domain name of the origin server is returned if you deploy proxies, such as Web Application Firewall (WAF), between the origin server and the instance. In this case, the address of the proxy, such as the CNAME provided by WAF, is returned.', example='0', position='Query'),
  rules: string(name='Rules', description='The details of the forwarding rule. The value is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that contains the following fields:

*   **ProxyRules**: the information about the origin server. The information includes the port number and IP address. This field is required and must be a JSON array. Each element in a JSON array is a JSON struct that contains the following fields:

    *   **ProxyPort**: the port number. This field is required and must be an integer.
    *   **RealServers**: the IP address. This field is required and must be a string array.

*   **ProxyType**: the protocol type. This field is required and must be a string. Valid values: **http**, **https**, **websocket**, and **websockets**.', example='[{"ProxyRules":[{"ProxyPort":443,"RealServers":["192.1.XX.XX"]}],"ProxyType":"https"}]', position='Query'),
}

model CreateWebRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9EC62E89-BD30-4FCD-9CB8-FA53865FF0D7'),
}

model CreateWebRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateWebRuleResponseBody(name='body'),
}

async function createWebRule(request: CreateWebRuleRequest): CreateWebRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateWebRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAsyncTaskRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  taskId: int32(name='TaskId', description='The ID of the task that you want to delete.

> You can call the [DescribeAsyncTasks](~~159405~~) operation to query the IDs of all asynchronous export tasks.', example='1', position='Query'),
}

model DeleteAsyncTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DeleteAsyncTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAsyncTaskResponseBody(name='body'),
}

async function deleteAsyncTask(request: DeleteAsyncTaskRequest): DeleteAsyncTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAsyncTask', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAutoCcBlacklistRequest {
  regionId?: string(name='RegionId', position='Host'),
  blacklist: string(name='Blacklist', description='The IP addresses that you want to manage. This parameter is a JSON string. The string contains the following fields:

*   **src**: the IP address. This field is required and must be of the STRING type.', example='[{"src":"198.51.XX.XX"},{"src":"198.52.XX.XX"}]', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
}

model DeleteAutoCcBlacklistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DeleteAutoCcBlacklistResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAutoCcBlacklistResponseBody(name='body'),
}

async function deleteAutoCcBlacklist(request: DeleteAutoCcBlacklistRequest): DeleteAutoCcBlacklistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAutoCcBlacklist', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAutoCcWhitelistRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  whitelist: string(name='Whitelist', description='The IP addresses that you want to manage. This parameter is a JSON string. This parameter is a JSON string. The string contains the following field:

*   **src**: the IP address. This field is required and must be of the string type.', example='[{"src":"1.1.1.1"},{"src":"2.2.2.2"}]', position='Query'),
}

model DeleteAutoCcWhitelistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DeleteAutoCcWhitelistResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAutoCcWhitelistResponseBody(name='body'),
}

async function deleteAutoCcWhitelist(request: DeleteAutoCcWhitelistRequest): DeleteAutoCcWhitelistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAutoCcWhitelist', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDomainResourceRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name for which the forwarding rule is configured.', example='www.example.com', position='Query'),
}

model DeleteDomainResourceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='39499F01-19D9-4EA4-A0E9-C6014BA5CDBE'),
}

model DeleteDomainResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDomainResourceResponseBody(name='body'),
}

async function deleteDomainResource(request: DeleteDomainResourceRequest): DeleteDomainResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDomainResource', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNetworkRuleRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  networkRule: string(name='NetworkRule', description='An array that consists of the information about the port forwarding rule. This parameter is a JSON string. The string contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.', example='[{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080}]', position='Query'),
}

model DeleteNetworkRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='49AD2F34-694A-4024-9B0E-DDCFC59CCC13'),
}

model DeleteNetworkRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteNetworkRuleResponseBody(name='body'),
}

async function deleteNetworkRule(request: DeleteNetworkRuleRequest): DeleteNetworkRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNetworkRule', 'POST', '/', 'json', false, 'json', request);
}

model DeletePortRequest {
  regionId?: string(name='RegionId', position='Host'),
  backendPort?: string(name='BackendPort', description='The port of the origin server. Valid values: **0** to **65535**.', example='55', position='Query'),
  frontendPort: string(name='FrontendPort', description='The forwarding port. Valid values: **0** to **65535**.', example='55', position='Query'),
  frontendProtocol: string(name='FrontendProtocol', description='The type of the protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the Anti-DDoS Pro or Anti-DDoS Premium instance to which the port forwarding rule belongs.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-st21zbyq****', position='Query'),
  realServers?: [ string ](name='RealServers', description='An array that consists of the IP addresses of origin servers.', position='Query'),
}

model DeletePortResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='39499F01-19D9-4EA4-A0E9-C6014BA5CDBE'),
}

model DeletePortResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePortResponseBody(name='body'),
}

/**
  * After you delete a port forwarding rule, the Anti-DDoS Pro or Anti-DDoS Premium instance no longer forwards service traffic on the Layer 4 port. Before you delete a specific port forwarding rule, make sure that the service traffic destined for the Layer 4 port is redirected to the origin server. This can prevent negative impacts on your services.
  * > You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](~~95820~~).
  *
 */
async function deletePort(request: DeletePortRequest): DeletePortResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePort', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSceneDefensePolicyRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  policyId: string(name='PolicyId', description='The ID of the policy that you want to delete.

> You can call the [DescribeSceneDefensePolicies](~~159382~~) operation to query the IDs of all policies.', example='321a-fd31-df51-****', position='Query'),
}

model DeleteSceneDefensePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model DeleteSceneDefensePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSceneDefensePolicyResponseBody(name='body'),
}

async function deleteSceneDefensePolicy(request: DeleteSceneDefensePolicyRequest): DeleteSceneDefensePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSceneDefensePolicy', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSchedulerRuleRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  ruleName: string(name='RuleName', description='The name of the scheduling rule that you want to delete.', example='testrule', position='Query'),
}

model DeleteSchedulerRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DeleteSchedulerRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSchedulerRuleResponseBody(name='body'),
}

async function deleteSchedulerRule(request: DeleteSchedulerRuleRequest): DeleteSchedulerRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSchedulerRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteTagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags from the specified resource. Valid values:

*   **true**: yes.
*   **false** no. This is the default value.', example='false', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the instance. Set the value to **cn-hangzhou**, which indicates an Anti-DDoS Pro instance in the Chinese mainland.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
  resourceIds: [ string ](name='ResourceIds', description='An array consisting of the IDs of instances from which you want to remove tags.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.', example='INSTANCE', position='Query'),
  tagKey?: [ string ](name='TagKey', description='An array consisting of the keys of the tags that you want to remove.', example='testkey', position='Query'),
}

model DeleteTagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
}

model DeleteTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTagResourcesResponseBody(name='body'),
}

/**
  * You can call the DeleteTagResources operation to remove tags from Anti-DDoS Pro instances.
  * > Only Anti-DDoS Pro supports tags.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function deleteTagResources(request: DeleteTagResourcesRequest): DeleteTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteTagResources', 'POST', '/', 'json', false, 'json', request);
}

model DeleteWebCCRuleRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  name: string(name='Name', description='The name of the custom frequency control rule that you want to delete.', example='wq', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DeleteWebCCRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DeleteWebCCRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWebCCRuleResponseBody(name='body'),
}

async function deleteWebCCRule(request: DeleteWebCCRuleRequest): DeleteWebCCRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWebCCRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteWebCacheCustomRuleRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name for which you want to delete the custom rules of the Static Page Caching policy.

> You can call the [DescribeDomains](~~91724~~) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.', example='www.aliyundoc.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
  ruleNames: [ string ](name='RuleNames', description='An array consisting of the names of the rules that you want to delete.', example='test', position='Query'),
}

model DeleteWebCacheCustomRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
}

model DeleteWebCacheCustomRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWebCacheCustomRuleResponseBody(name='body'),
}

/**
  * You can call the DeleteWebCacheCustomRule operation to delete the custom rules of the Static Page Caching policy for a website.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function deleteWebCacheCustomRule(request: DeleteWebCacheCustomRuleRequest): DeleteWebCacheCustomRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWebCacheCustomRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteWebPreciseAccessRuleRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  ruleNames: [ string ](name='RuleNames', description='An array that consists of the names of rules to delete.', example='testrule', position='Query'),
}

model DeleteWebPreciseAccessRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DeleteWebPreciseAccessRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWebPreciseAccessRuleResponseBody(name='body'),
}

async function deleteWebPreciseAccessRule(request: DeleteWebPreciseAccessRuleRequest): DeleteWebPreciseAccessRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWebPreciseAccessRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteWebRuleRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name of the website from which you want to delete the forwarding rule.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query the domain names for which forwarding rules are configured.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](~~94485~~).', example='rg-acfm2pz25js****', position='Query'),
}

model DeleteWebRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='9EC62E89-BD30-4FCD-9CB8-FA53865FF0D7'),
}

model DeleteWebRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWebRuleResponseBody(name='body'),
}

async function deleteWebRule(request: DeleteWebRuleRequest): DeleteWebRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWebRule', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAsyncTasksRequest {
  regionId?: string(name='RegionId', position='Host'),
  pageNumber: int32(name='PageNumber', description='The number of the page to return.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries to return on each page.', example='10', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
}

model DescribeAsyncTasksResponseBody = {
  asyncTasks?: [ 
    {
      endTime?: long(name='EndTime', description='The end time of the task. This value is a UNIX timestamp. Unit: milliseconds.', example='157927362000'),
      startTime?: long(name='StartTime', description='The start time of the task. The value is a UNIX timestamp. Unit: milliseconds.', example='156927362000'),
      taskId?: long(name='TaskId', description='The ID of the job.', example='1'),
      taskParams?: string(name='TaskParams', description='The task parameter. The value is a JSON string. The returned field in the value varies based on the value of **TaskType**.

If **TaskType** is set to **1**, **3**, **4**, **5**, or **6**, the following filed is returned:

*   **instanceId**: the ID of the instance. Data type: string.

If **TaskType** is set to **2**, the following field is returned:

*   **domain**: the domain name of the website. Data type: string.', example='{"instanceId": "ddoscoo-cn-mp91j1ao****"}'),
      taskResult?: string(name='TaskResult', description='The execution result of the task. The value is a JSON string. The returned fields in the value vary based on the value of **TaskType**.

If **TaskType** is set to **1**, **3**, **4**, **5**, or **6**, the following fields are returned:

*   **instanceId**: the ID of the instance. Data type: string.
*   **url**: the URL to download the exported file from Object Storage Service (OSS). Data type: string.

If **TaskType** is set to **2**, the following fields are returned:

*   **domain**: the domain name of the website. Data type: string.
*   **url**: the URL to download the exported file from OSS. Data type: string.', example='{"instanceId": "ddoscoo-cn-mp91j1ao****","url": "https://****.oss-cn-beijing.aliyuncs.com/heap.bin?Expires=1584785140&OSSAccessKeyId=TMP.3KfzD82FyRJevJdEkRX6JEFHhbvRBBb75PZJnyJmksA2QkMm47xFAFDgMhEV8Nm6Vxr8xExMfiy9LsUFAcLcTBrN3r****&Signature=Sj8BNcsxJLE8l5qm4cjNlDt8gv****"}'),
      taskStatus?: int32(name='TaskStatus', description='The status of the task. Valid values:

*   **0**: indicates that the task is being initialized.
*   **1**: indicates that the task is in progress.
*   **2**: indicates that the task is successful.
*   **3**: indicates that the task failed.', example='2'),
      taskType?: int32(name='TaskType', description='The type of the task. Valid values:

*   **1**: the task to export the port forwarding rules of an instance
*   **2**: the task to export the forwarding rules of a website protected by an instance
*   **3**: the task to export the sessions and health check settings of an instance
*   **4**: the task to export the mitigation policies of an instance
*   **5**: the task to download the blacklist for destination IP addresses of an instance
*   **6**: the task to download the whitelist for destination IP addresses of an instance', example='5'),
    }
  ](name='AsyncTasks', description='An array that consists of the details of the asynchronous export tasks.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
  totalCount?: int32(name='TotalCount', description='The total number of asynchronous export tasks that are returned.', example='1'),
}

model DescribeAsyncTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAsyncTasksResponseBody(name='body'),
}

/**
  * You can call the DescribeAsyncTasks operation to query the details of asynchronous export tasks, such as the IDs, start time, end time, status, parameters, and results.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeAsyncTasks(request: DescribeAsyncTasksRequest): DescribeAsyncTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAsyncTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAttackAnalysisMaxQpsRequest {
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.', example='1619798400', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.', example='1622476799', position='Query'),
}

model DescribeAttackAnalysisMaxQpsResponseBody = {
  qps?: long(name='Qps', description='The peak queries per second (QPS) of DDoS attacks. Units: QPS.', example='41652'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='8DFB602D-1AAC-46C4-90F2-C84086E7A6E4'),
}

model DescribeAttackAnalysisMaxQpsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAttackAnalysisMaxQpsResponseBody(name='body'),
}

async function describeAttackAnalysisMaxQps(request: DescribeAttackAnalysisMaxQpsRequest): DescribeAttackAnalysisMaxQpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAttackAnalysisMaxQps', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAutoCcBlacklistRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  keyWord?: string(name='KeyWord', description='The keyword for the query. This keyword is used to specify the prefix of the source IP address that you want to query.

> The keyword must be greater than three characters in length.', example='138', position='Query'),
  pageNumber: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries to return on each page.', example='10', position='Query'),
}

model DescribeAutoCcBlacklistResponseBody = {
  autoCcBlacklist?: [ 
    {
      destIp?: string(name='DestIp', description='The IP address of the instance.', example='192.0.XX.XX'),
      endTime?: long(name='EndTime', description='The validity period of the IP address in the blacklist. The value is a UNIX timestamp. Unit: seconds.', example='1584093569'),
      sourceIp?: string(name='SourceIp', description='The IP address in the blacklist.', example='47.100.XX.XX'),
      type?: string(name='Type', description='The mode of how the IP address is added to the blacklist. Valid values:

*   **manual**: manually added
*   **auto**: automatically added', example='manual'),
    }
  ](name='AutoCcBlacklist', description='An array that consists of the details of the IP addresses in the blacklist of the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='E78C8472-0B15-42D5-AF22-A32A78818AB2'),
  totalCount?: long(name='TotalCount', description='The total number of returned IP addresses in the blacklist.', example='2'),
}

model DescribeAutoCcBlacklistResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoCcBlacklistResponseBody(name='body'),
}

async function describeAutoCcBlacklist(request: DescribeAutoCcBlacklistRequest): DescribeAutoCcBlacklistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoCcBlacklist', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAutoCcListCountRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the **DescribeInstanceIds** operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  queryType?: string(name='QueryType', description='The mode of how an IP address is added to the whitelist or blacklist. Valid values:

*   **manual**: manually added
*   **auto**: automatically added', example='manual', position='Query'),
}

model DescribeAutoCcListCountResponseBody = {
  blackCount?: int32(name='BlackCount', description='The total number of IP addresses in the blacklist.', example='0'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5AC3785F-C789-4622-87A4-F58BE7F6B184'),
  whiteCount?: int32(name='WhiteCount', description='The total number of IP addresses in the whitelist.', example='2'),
}

model DescribeAutoCcListCountResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoCcListCountResponseBody(name='body'),
}

async function describeAutoCcListCount(request: DescribeAutoCcListCountRequest): DescribeAutoCcListCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoCcListCount', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAutoCcWhitelistRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  keyWord?: string(name='KeyWord', description='The keyword for the query. This keyword is used to specify the prefix of the source IP address that you want to query.

> The keyword must be greater than three characters in length.', example='138', position='Query'),
  pageNumber: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries to return on each page.', example='10', position='Query'),
}

model DescribeAutoCcWhitelistResponseBody = {
  autoCcWhitelist?: [ 
    {
      destIp?: string(name='DestIp', description='The IP address of the instance.', example='203.***.***.117'),
      endTime?: long(name='EndTime', description='The validity period of the IP address in the whitelist. Unit: seconds. **0** indicates that the IP address in the whitelist never expires.', example='0'),
      sourceIp?: string(name='SourceIp', description='The IP addresses that is contained in the IP address whitelist.', example='2.2.2.2'),
      type?: string(name='Type', description='The mode of how an IP address is added to the whitelist. Valid values:

*   **manual**: manually added
*   **auto**: automatically added', example='manual'),
    }
  ](name='AutoCcWhitelist', description='An array that consists of details of the IP address in the whitelist of the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F09D085E-5E0F-4FF2-B32E-F4A644049162'),
  totalCount?: long(name='TotalCount', description='The total number of returned IP addresses in the whitelist.', example='2'),
}

model DescribeAutoCcWhitelistResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoCcWhitelistResponseBody(name='body'),
}

async function describeAutoCcWhitelist(request: DescribeAutoCcWhitelistRequest): DescribeAutoCcWhitelistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoCcWhitelist', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackSourceCidrRequest {
  regionId?: string(name='RegionId', position='Host'),
  ipVersion?: string(name='IpVersion', description='The IP version of the back-to-origin CIDR block.

*   **Ipv4**
*   **Ipv6**', example='IPv4', position='Query'),
  line?: string(name='Line', description='The Internet service provider (ISP) line that you want to query.', example='coop-line-001', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
}

model DescribeBackSourceCidrResponseBody = {
  cidrs?: [ string ](name='Cidrs', description='An array that consists of the back-to-origin CIDR blocks of the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DescribeBackSourceCidrResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackSourceCidrResponseBody(name='body'),
}

async function describeBackSourceCidr(request: DescribeBackSourceCidrRequest): DescribeBackSourceCidrResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackSourceCidr', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBlackholeStatusRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceIds: [ string ](name='InstanceIds', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
}

model DescribeBlackholeStatusResponseBody = {
  blackholeStatus?: [ 
    {
      blackStatus?: string(name='BlackStatus', description='Indicates whether blackhole filtering is triggered for the instance. Valid values:

*   **blackhole**: yes
*   **normal**: no', example='blackhole'),
      endTime?: long(name='EndTime', description='The end time of blackhole filtering. The value is a UNIX timestamp. Unit: seconds.', example='1540196323'),
      ip?: string(name='Ip', description='The IP address of the instance.', example='203.***.***.132'),
      startTime?: long(name='StartTime', description='The start time of blackhole filtering. The value is a UNIX timestamp. Unit: seconds.', example='1540195323'),
    }
  ](name='BlackholeStatus', description='An array that consists of the blackhole filtering status of the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DescribeBlackholeStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBlackholeStatusResponseBody(name='body'),
}

async function describeBlackholeStatus(request: DescribeBlackholeStatusRequest): DescribeBlackholeStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBlackholeStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBlockStatusRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceIds: [ string ](name='InstanceIds', description='An array consisting of information about the IDs of the instances that you want to query.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
}

model DescribeBlockStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  statusList?: [ 
    {
      blockStatusList?: [ 
        {
          blockStatus?: string(name='BlockStatus', description='The blocking status of the network traffic. Valid values:

*   **areablock**: Network traffic is blocked.
*   **normal**: Network traffic is not blocked.', example='areablock'),
          endTime?: long(name='EndTime', description='The end time of the blocking. This value is a UNIX timestamp. Unit: seconds.', example='1540196323'),
          line?: string(name='Line', description='The Internet service provider (ISP) line from which the traffic is blocked. Valid values:

*   **ct**: China Telecom (International)
*   **cut**: China Unicom (International)', example='cut'),
          startTime?: long(name='StartTime', description='The start time of the blocking. This value is a UNIX timestamp. Unit: seconds.', example='1540195323'),
        }
      ](name='BlockStatusList', description='An array that consists of details of the Diversion from Origin Server configuration.'),
      ip?: string(name='Ip', description='The IP address of the instance.', example='203.XX.XX.88'),
    }
  ](name='StatusList', description='An array that consists of details of the Diversion from Origin Server configurations of the instance.'),
}

model DescribeBlockStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBlockStatusResponseBody(name='body'),
}

/**
  * This operation is used to query the Diversion from Origin Server configurations of one or more Anti-DDoS Pro instances.
  * > This operation is suitable only for Anti-DDoS Pro.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeBlockStatus(request: DescribeBlockStatusRequest): DescribeBlockStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBlockStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCertsRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeCertsResponseBody = {
  certs?: [ 
    {
      common?: string(name='Common', description='The domain name that is associated with the certificate.', example='www.aliyun.com'),
      domainRelated?: boolean(name='DomainRelated', description='Indicates whether the certificate is associated with the domain name. Valid values:

*   **true**: The certificate is associated with the domain name.
*   **false**: The certificate is not associated with the domain name.', example='true'),
      endDate?: string(name='EndDate', description='The expiration date of the certificate. string', example='2021-09-12'),
      id?: int32(name='Id', description='The ID of the certificate.', example='81'),
      issuer?: string(name='Issuer', description='The certificate authority (CA) that issued the certificate.', example='Symantec'),
      name?: string(name='Name', description='The name of the certificate.', example='testcert'),
      startDate?: string(name='StartDate', description='The issuance date of the certificate. string', example='2019-09-12'),
    }
  ](name='Certs', description='The certificate information about the website.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DescribeCertsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCertsResponseBody(name='body'),
}

async function describeCerts(request: DescribeCertsRequest): DescribeCertsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCerts', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCnameReusesRequest {
  regionId?: string(name='RegionId', position='Host'),
  domains: [ string ](name='Domains', description='An array that consists of the domain names of websites.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeCnameReusesResponseBody = {
  cnameReuses?: [ 
    {
      cname?: string(name='Cname', description='The CNAME record that is reused by the website.', example='4o6ep6q217k9****.aliyunddos0004.com'),
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
      enable?: int32(name='Enable', description='Indicates whether CNAME reuse is enabled. Valid values:

*   **0**: no
*   **1**: yes', example='1'),
    }
  ](name='CnameReuses', description='An array that consists of the CNAME reuse information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DescribeCnameReusesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCnameReusesResponseBody(name='body'),
}

/**
  * > This operation is suitable only for Anti-DDoS Premium.
  *
 */
async function describeCnameReuses(request: DescribeCnameReusesRequest): DescribeCnameReusesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCnameReuses', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDDoSEventsRequest {
  regionId?: string(name='RegionId', position='Host'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  instanceIds: [ string ](name='InstanceIds', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  pageNumber: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries to return on each page.', example='10', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribeDDoSEventsResponseBody = {
  dDoSEvents?: [ 
    {
      bps?: long(name='Bps', description='The bandwidth of attack traffic. Unit: bit/s.', example='0'),
      endTime?: long(name='EndTime', description='The time when the DDoS attack stopped. The value is a UNIX timestamp. Unit: seconds.', example='1583933330'),
      eventType?: string(name='EventType', description='The type of the attack event. Valid values:

*   **defense**: traffic scrubbing events
*   **blackhole**: blackhole filtering events', example='blackhole'),
      ip?: string(name='Ip', description='The attacked IP address.', example='203.***.***.132'),
      port?: string(name='Port', description='The attacked port.', example='80'),
      pps?: long(name='Pps', description='The packet forwarding rate of attack traffic. Unit: packets per second (pps).', example='0'),
      region?: string(name='Region', description='The region from which the attack was launched. Valid values:

*   **cn**: a region in the Chinese mainland
*   **alb-ap-northeast-1-gf-x**: Japan (Tokyo)
*   **alb-ap-southeast-gf-x**: Singapore
*   **alb-cn-hongkong-gf-x**: Hong Kong (China)
*   **alb-eu-central-1-gf-x**: Germany (Frankfurt)
*   **alb-us-west-1-gf-x**: US (Silicon Valley)

> The values except **cn** are returned only when **RegionId** is set to **ap-southeast-1**.', example='cn'),
      startTime?: long(name='StartTime', description='The time when the DDoS attack started. The value is a UNIX timestamp. Unit: seconds.', example='1583933277'),
    }
  ](name='DDoSEvents', description='The DDoS attack events.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0CA72AF5-1795-4350-8C77-50A448A2F334'),
  total?: long(name='Total', description='The total number of returned attack events.', example='1'),
}

model DescribeDDoSEventsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDDoSEventsResponseBody(name='body'),
}

async function describeDDoSEvents(request: DescribeDDoSEventsRequest): DescribeDDoSEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDDoSEvents', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDDosAllEventListRequest {
  endTime: long(name='EndTime', description='The end of the time range to query. The DDoS attack events occur before **EndTime** are queried. This value is a UNIX timestamp. Unit: seconds.', example='1640966399', position='Query'),
  eventType?: string(name='EventType', description='The type of the DDoS attack events you want to query. Valid values:

*   **web-cc**: resource exhaustion attacks
*   **cc**: connection flood attacks
*   **defense**: DDoS attacks that trigger traffic scrubbing
*   **blackhole**: DDoS attacks that trigger blackhole filtering

If you want to query multiple types of DDoS attack events, separate them with commas (,).

If you do not configure this parameter, DDoS attack events of all types are queried.', example='defense', position='Query'),
  pageNumber: int32(name='PageNumber', description='The number of the page to return.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries to return on each page.', example='10', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The DDoS attack events occur after **StartTime** are queried. This value is a UNIX timestamp. Unit: seconds.', example='1609430400', position='Query'),
}

model DescribeDDosAllEventListResponseBody = {
  attackEvents?: [ 
    {
      area?: string(name='Area', description='The source location or region from which the attack was initiated. Valid values:

*   **cn**: Chinese mainland
*   **alb-cn-hongkong-gf-2**: China (Hongkong)
*   **alb-us-west-1-gf-2**: US (Silicon Valley)
*   **alb-ap-northeast-1-gf-1**: Japan (Tokyo)
*   **alb-ap-southeast-gf-1**: Singapore
*   **alb-eu-central-1-gf-1**: Germany (Frankfurt)
*   **alb-eu-central-1-gf-1** or **selb-eu-west-1-gf-1a**: UK (London)
*   **alb-us-east-gf-1**: US (Virginia)
*   **CT-yundi**: China (Hongkong) This value is returned only for Anti-DDoS Premium instances of the Secure Chinese Mainland Acceleration (Sec-CMA) mitigation plan.', example='cn'),
      endTime?: long(name='EndTime', description='The time when the DDoS attack stopped. This value is a UNIX timestamp. Unit: seconds.', example='1634546030'),
      eventType?: string(name='EventType', description='The type of the DDoS attack event. Valid values:

*   **web-cc**: resource exhaustion attacks
*   **cc**: connection flood attacks
*   **defense**: DDoS attacks that trigger traffic scrubbing
*   **blackhole**: DDoS attacks that trigger blackhole filtering', example='cc'),
      ip?: string(name='Ip', description='The attacked object. The attacked object varies based on the attack event type. The following list describes different attacked objects of different attack event types:

*   If **EventType** is set to **web-cc**, the value of this parameter indicates the domain name of the attacked website.
*   If **EventType** is set to **cc**, the value of this parameter indicates the IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.
*   If **EventType** is set to **defense** or **blackhole**, the value of this parameter indicates the IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.', example='203.107.XX.XX'),
      mbps?: long(name='Mbps', description='The peak bandwidth of the attack traffic. Unit: Mbit/s.', example='101899'),
      port?: string(name='Port', description='The attacked port.

> If **EventType** is set to **web-cc**, this parameter is not returned.', example='80'),
      pps?: long(name='Pps', description='The peak packet forwarding rate of attack traffic. Unit: packets per second (pps).', example='9664270'),
      startTime?: long(name='StartTime', description='The time when the DDoS attack started. This value is a UNIX timestamp. Unit: seconds.', example='1634543764'),
    }
  ](name='AttackEvents', description='An array that consists of attack events.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25D83ED5-28CB-5683-9CF7-AECE521F3005'),
  total?: long(name='Total', description='The total number of DDoS attack events.', example='1'),
}

model DescribeDDosAllEventListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDDosAllEventListResponseBody(name='body'),
}

/**
  * You can call the DescribeDDosAllEventList operation to query DDoS attack events within a specific time range by page. The information about a DDoS attack event includes the start time and end time of the attack, attack event type, attacked object, peak bandwidth of attack traffic, and peak packet forwarding rate.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeDDosAllEventList(request: DescribeDDosAllEventListRequest): DescribeDDosAllEventListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDDosAllEventList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDDosEventAreaRequest {
  eventType: string(name='EventType', description='The type of the attack event that you want to query. Valid values:

*   **defense**: attack events that trigger traffic scrubbing
*   **blackhole**: attack events that trigger blackhole filtering', example='defense', position='Query'),
  ip: string(name='Ip', description='The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.', example='203.***.***.199', position='Query'),
  startTime: long(name='StartTime', description='The UNIX timestamp when the query starts. Unit: seconds.

> You can call the [DescribeDDosAllEventList](~~188604~~) operation to query the beginning time of all attack events.', example='1598948471', position='Query'),
}

model DescribeDDosEventAreaResponseBody = {
  areas?: [ 
    {
      area?: string(name='Area', description='The code or ID of the source region. For more information, see [Codes of administrative regions in China and codes of countries and areas](~~167926~~). For example, **110000** indicates Beijing, China, and **us** indicates the United States.', example='110000'),
      inPkts?: long(name='InPkts', description='The number of request packets that were sent from the source region.', example='228'),
    }
  ](name='Areas', description='The information about the source region from which the volumetric attack was initiated.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='11710C9F-BC5E-481A-BEC5-C6D8FBFCA827'),
}

model DescribeDDosEventAreaResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDDosEventAreaResponseBody(name='body'),
}

/**
  * > This operation is suitable only for volumetric attacks.
  *
 */
async function describeDDosEventArea(request: DescribeDDosEventAreaRequest): DescribeDDosEventAreaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDDosEventArea', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDDosEventAttackTypeRequest {
  eventType: string(name='EventType', description='The type of the attack event that you want to query. Valid values:

*   **defense**: attack events that trigger traffic scrubbing
*   **blackhole**: attack events that trigger blackhole filtering', example='defense', position='Query'),
  ip: string(name='Ip', description='The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.', example='203.***.***.199', position='Query'),
  startTime: long(name='StartTime', description='The UNIX timestamp when the query starts. Unit: seconds.

> You can call the [DescribeDDosAllEventList](~~188604~~) operation to query the beginning time of all attack events.', example='1598948471', position='Query'),
}

model DescribeDDosEventAttackTypeResponseBody = {
  attackTypes?: [ 
    {
      attackType?: string(name='AttackType', description='The type of the attack Valid values:

*   **QOTD-Reflect-Flood**: QOTD reflection attacks
*   **CharGEN-Reflect-Flood**: CHARGEN reflection attacks
*   **DNS-Reflect-Flood**: DNS reflection attacks
*   **TFTP-Reflect-Flood**: TFTP reflection attacks
*   **Portmap-Reflect-Flood**: Portmap reflection attacks
*   **NTP-Reflect-Flood**: NTP reflection attacks
*   **NetBIOS-Reflect-Flood**: NetBIOS reflection attacks
*   **SNMPv2-Reflect-Flood**: SNMPv2 reflection attacks
*   **CLDAP-Reflect-Flood**: CLDAP reflection attacks
*   **Ripv1-Reflect-Flood**: RIPv1 reflection attacks
*   **OpenVPN-Reflect-Flood**: OpenVPN reflection attacks
*   **SSDP-Reflect-Flood**: SSDP reflection attacks
*   **NetAssistant-Reflect-Flood**: NetAssistant reflection attacks
*   **WSDiscovery-Reflect-Flood**: WS-Discovery reflection attacks
*   **Kad-Reflect-Flood**: Kad reflection attacks
*   **mDNS-Reflect-Flood**: mDNS reflection attacks
*   **10001-Reflect-Flood**: reflection attacks over port 10001
*   **Memcached-Reflect-Flood**: Memcached reflection attacks
*   **QNP-Reflect-Flood**: QNP reflection attacks
*   **DVR-Reflect-Flood**: DVR reflection attacks
*   **CoAP-Reflect-Flood**: CoAP reflection attacks
*   **ADDP-Reflect-Flood**: ADDP reflection attacks
*   **Tcp-Syn**: TCP SYN flood attacks
*   **Tcp-Fin**: TCP FIN flood attacks
*   **Tcp-Ack**: TCP ACK flood attacks
*   **Tcp-Rst**: TCP RST flood attacks
*   **Tcp-Pushack**: TCP PSH-ACK flood attacks
*   **Tcp-Synack**: TCP SYN-ACK flood attacks
*   **Udp-None**: UDP attacks
*   **Udp-Ssh**: UDP-based SSH attacks
*   **Udp-Dns**: UDP-based DNS attacks
*   **Udp-Http**: UDP-based HTTP attacks
*   **Udp-Https**: UDP-based HTTPS attacks
*   **Udp-Ntp**: UDP-based NTP attacks
*   **Udp-Ldap**: UDP-based LDAP attacks
*   **Udp-Ssdp**: UDP-based SSDP attacks
*   **Udp-Memcached**: Memcached UDP reflection attacks
*   **Tcp-Other**: other TCP attacks
*   **Icmp**: ICMP flood attacks
*   **Igmp**: IGMP flood attacks
*   **Ipv6**: IPv6 attacks', example='Tcp-Syn'),
      inPkts?: long(name='InPkts', description='The number of request packets of the attack type.', example='145902'),
    }
  ](name='AttackTypes', description='The information about the attack types.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6F644A6E-40E7-483F-9DBB-CC27E16BB555'),
}

model DescribeDDosEventAttackTypeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDDosEventAttackTypeResponseBody(name='body'),
}

/**
  * > This operation is suitable only for volumetric attacks.
  *
 */
async function describeDDosEventAttackType(request: DescribeDDosEventAttackTypeRequest): DescribeDDosEventAttackTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDDosEventAttackType', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDDosEventIspRequest {
  eventType: string(name='EventType', description='The type of the attack event that you want to query. Valid values:

*   **defense**: attack events that trigger traffic scrubbing
*   **blackhole**: attack events that trigger blackhole filtering', example='defense', position='Query'),
  ip: string(name='Ip', description='The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.', example='203.***.***.199', position='Query'),
  startTime: long(name='StartTime', description='The UNIX timestamp when the query starts. Unit: seconds.

> You can call the [DescribeDDosAllEventList](~~188604~~) operation to query the beginning time of all attack events.', example='1598948471', position='Query'),
}

model DescribeDDosEventIspResponseBody = {
  isps?: [ 
    {
      inPkts?: long(name='InPkts', description='The number of request packets that were sent from the ISP.', example='230'),
      isp?: string(name='Isp', description='The code of the ISP. Valid values:

*   **100017**: China Telecom
*   **100026**: China Unicom
*   **100025**: China Mobile
*   **100027**: China Education and Research Network
*   **100020**: China Mobile Tietong
*   **1000143**: Dr.Peng Telecom & Media Group
*   **100080**: Beijing Gehua CATV Network
*   **1000139**: National Radio and Television Administration
*   **100023**: Oriental Cable Network
*   **100063**: Founder Broadband
*   **1000337**: China Internet Exchange
*   **100021**: 21Vianet Group
*   **1000333**: Wasu Media Holding
*   **100093**: Wangsu Science & Technology
*   **1000401**: Tencent
*   **100099**: Baidu
*   **1000323**: Alibaba Cloud
*   **100098**: Alibaba', example='1000323'),
    }
  ](name='Isps', description='An array that consists of the ISPs for the volumetric attack.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C4A3BCD1-4A32-4342-941A-4745AE69508C'),
}

model DescribeDDosEventIspResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDDosEventIspResponseBody(name='body'),
}

/**
  * > This operation is suitable only for volumetric attacks.
  *
 */
async function describeDDosEventIsp(request: DescribeDDosEventIspRequest): DescribeDDosEventIspResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDDosEventIsp', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDDosEventMaxRequest {
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.', example='1604073600', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.', example='1598889600', position='Query'),
}

model DescribeDDosEventMaxResponseBody = {
  cps?: long(name='Cps', description='The peak of connection flood attacks. Unit: connections per seconds (CPS).', example='1302'),
  mbps?: long(name='Mbps', description='The peak of volumetric attacks. Unit: Mbit/s.', example='6809'),
  qps?: long(name='Qps', description='The peak of resource exhaustion attacks. Unit: queries per second (QPS).', example='26314'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5AE2FC86-C840-41AE-9F1A-3A2747C7C1DF'),
}

model DescribeDDosEventMaxResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDDosEventMaxResponseBody(name='body'),
}

async function describeDDosEventMax(request: DescribeDDosEventMaxRequest): DescribeDDosEventMaxResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDDosEventMax', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDDosEventSrcIpRequest {
  eventType: string(name='EventType', description='The type of the attack event that you want to query. Valid values:

*   **defense**: attack events that trigger traffic scrubbing
*   **blackhole**: attack events that trigger blackhole filtering', example='defense', position='Query'),
  ip: string(name='Ip', description='The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.', example='203.***.***.199', position='Query'),
  range: long(name='Range', description='The number of source IP addresses that you want to return. The source IP addresses are returned in descending order of attack traffic. By default, the top **five** source IP addresses are returned.', example='2', position='Query'),
  startTime: long(name='StartTime', description='The UNIX timestamp when the query starts. Unit: seconds.

> You can call the [DescribeDDosAllEventList](~~188604~~) operation to query the beginning time of all attack events.', example='1598948471', position='Query'),
}

model DescribeDDosEventSrcIpResponseBody = {
  ips?: [ 
    {
      areaId?: string(name='AreaId', description='The code or ID of the source region. For more information, see [Codes of administrative regions in China and codes of countries and areas](~~167926~~). For example, **110000** indicates Beijing, China, and **us** indicates the United States.', example='110000'),
      isp?: string(name='Isp', description='The Internet service provider (ISP) for the volumetric attack. Valid values:

*   **100017**: China Telecom
*   **100026**: China Unicom
*   **100025**: China Mobile
*   **100027**: China Education and Research Network
*   **100020**: China Mobile Tietong
*   **1000143**: Dr.Peng Telecom & Media Group
*   **100080**: Beijing Gehua CATV Network
*   **1000139**: National Radio and Television Administration
*   **100023**: Oriental Cable Network
*   **100063**: Founder Broadband
*   **1000337**: China Internet Exchange
*   **100021**: 21Vianet Group
*   **1000333**: Wasu Media Holding
*   **100093**: Wangsu Science & Technology
*   **1000401**: Tencent
*   **100099**: Baidu
*   **1000323**: Alibaba Cloud
*   **100098**: Alibaba', example='100026'),
      srcIp?: string(name='SrcIp', description='The source IP address of the volumetric attack.', example='218.***.***.24'),
    }
  ](name='Ips', description='An array that consists of information about the source IP address of the volumetric attack.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='38A0224E-FDBC-4733-A362-B391827FC1E9'),
}

model DescribeDDosEventSrcIpResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDDosEventSrcIpResponseBody(name='body'),
}

/**
  * > This operation is suitable only for volumetric attacks.
  *
 */
async function describeDDosEventSrcIp(request: DescribeDDosEventSrcIpRequest): DescribeDDosEventSrcIpResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDDosEventSrcIp', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDefenseCountStatisticsRequest {
  regionId?: string(name='RegionId', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
}

model DescribeDefenseCountStatisticsResponseBody = {
  defenseCountStatistics?: {
    defenseCountTotalUsageOfCurrentMonth?: int32(name='DefenseCountTotalUsageOfCurrentMonth', description='The number of advanced mitigation sessions that are used within the current calendar month.', example='0'),
    flowPackCountRemain?: int32(name='FlowPackCountRemain', description='The number of available global advanced mitigation sessions for the Insurance mitigation plan.', example='0'),
    maxUsableDefenseCountCurrentMonth?: int32(name='MaxUsableDefenseCountCurrentMonth', description='The maximum number of advanced mitigation sessions available for the current calendar month. The advanced mitigation sessions include the advanced mitigation sessions that are provided free of charge and the global advanced mitigation sessions that you purchase.', example='20'),
    secHighSpeedCountRemain?: int32(name='SecHighSpeedCountRemain', description='The number of available global advanced mitigation sessions for the Secure Chinese Mainland Acceleration (Sec-CMA) mitigation plan.', example='0'),
  }(name='DefenseCountStatistics', description='The statistics on the number of advanced mitigation sessions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='310A41FD-0990-5610-92E0-A6A55D7C6444'),
}

model DescribeDefenseCountStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDefenseCountStatisticsResponseBody(name='body'),
}

/**
  * You can call the DescribeDefenseCountStatistics operation to query the information about advanced mitigation sessions of an Anti-DDoS Premium instance. For example, you can query the number of advanced mitigation sessions that are used within the current calendar month and the number of available global advanced mitigation sessions.
  * > This operation is suitable only for Anti-DDoS Premium.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeDefenseCountStatistics(request: DescribeDefenseCountStatisticsRequest): DescribeDefenseCountStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDefenseCountStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDefenseRecordsRequest {
  regionId?: string(name='RegionId', example='ap-southeast-1', position='Host'),
  endTime: long(name='EndTime', description='The end of the time range to query. This value is a UNIX timestamp. Units: miliseconds.

> The time must be in the latest 90 days.', example='1583683200000', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  pageNumber: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: **50**.', example='10', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. This value is a UNIX timestamp. Units: miliseconds.

> The time must be in the latest 90 days.', example='1582992000000', position='Query'),
}

model DescribeDefenseRecordsResponseBody = {
  defenseRecords?: [ 
    {
      attackPeak?: long(name='AttackPeak', description='The peak attack traffic. Unit: bit/s.', example='6584186000'),
      endTime?: long(name='EndTime', description='The end time of the advanced mitigation session. This value is a UNIX timestamp. Units: miliseconds.', example='1583683200000'),
      eventCount?: int32(name='EventCount', description='The number of attacks.', example='2'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-mp91j1ao****'),
      startTime?: long(name='StartTime', description='The start time of the advanced mitigation session. This value is a UNIX timestamp. Units: miliseconds.', example='1582992000000'),
      status?: int32(name='Status', description='The status of the advanced mitigation session. Valid values:

*   **0**: The advanced mitigation session is being used.
*   **1**: The advanced mitigation session is used.', example='0'),
    }
  ](name='DefenseRecords', description='An array that consists of details of the log of an advanced mitigation session.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
  totalCount?: long(name='TotalCount', description='The total number of advanced mitigation sessions.', example='1'),
}

model DescribeDefenseRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDefenseRecordsResponseBody(name='body'),
}

/**
  * > This operation is suitable only for Anti-DDoS Premium.
  *
 */
async function describeDefenseRecords(request: DescribeDefenseRecordsRequest): DescribeDefenseRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDefenseRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainAttackEventsRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  pageNumber: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries to return on each page.', example='10', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribeDomainAttackEventsResponseBody = {
  domainAttackEvents?: [ 
    {
      domain?: string(name='Domain', description='The attacked domain name.', example='www.aliyun.com'),
      endTime?: long(name='EndTime', description='The time when the DDoS attack stopped. The value is a UNIX timestamp. Unit: seconds.', example='1560320160'),
      maxQps?: long(name='MaxQps', description='The peak attack QPS.', example='1000'),
      startTime?: long(name='StartTime', description='The time when the DDoS attack started. The value is a UNIX timestamp. Unit: seconds.', example='1560312900'),
    }
  ](name='DomainAttackEvents', description='An array that consists of the details of the DDoS attack event.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  totalCount?: long(name='TotalCount', description='The total number of returned DDoS attack events.', example='1'),
}

model DescribeDomainAttackEventsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainAttackEventsResponseBody(name='body'),
}

async function describeDomainAttackEvents(request: DescribeDomainAttackEventsRequest): DescribeDomainAttackEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainAttackEvents', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainOverviewRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain?: string(name='Domain', description='The domain name of the website that you want to query. If you leave this parameter unspecified, the statistics on all domain names are queried.

> The domain name must be added to Anti-DDoS Pro or Anti-DDoS Premium. You can call the [DescribeDomains](~~91724~~) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.', example='example.aliyundoc.com', position='Query'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds. If you leave this parameter unspecified, the current system time is used as the end time.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1623427200', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](~~94485~~).', example='rg-acfm2pz25js****', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1619798400', position='Query'),
}

model DescribeDomainOverviewResponseBody = {
  maxHttp?: long(name='MaxHttp', description='The peak queries per second (QPS) during HTTP traffic scrubbing. Unit: QPS.', example='41652'),
  maxHttps?: long(name='MaxHttps', description='The peak QPS during HTTPS traffic scrubbing. Unit: QPS.', example='0'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DescribeDomainOverviewResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainOverviewResponseBody(name='body'),
}

async function describeDomainOverview(request: DescribeDomainOverviewRequest): DescribeDomainOverviewResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainOverview', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainQPSListRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain?: string(name='Domain', description='The domain name of the website. If you do not specify this parameter, the statistics on the QPS of all domain names are queried.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  interval: long(name='Interval', description='The interval for returning data. Unit: seconds.', example='1000', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribeDomainQPSListResponseBody = {
  domainQPSList?: [ 
    {
      attackQps?: long(name='AttackQps', description='The attack QPS.', example='1'),
      cacheHits?: long(name='CacheHits', description='The number of cache hits.', example='0'),
      index?: long(name='Index', description='The index number of the returned data.', example='0'),
      maxAttackQps?: long(name='MaxAttackQps', description='The peak attack QPS.', example='37'),
      maxNormalQps?: long(name='MaxNormalQps', description='The peak of normal QPS.', example='93'),
      maxQps?: long(name='MaxQps', description='The peak of total QPS.', example='130'),
      time?: long(name='Time', description='The time when the data was collected. The value is a UNIX timestamp. Unit: seconds.', example='1582992000'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='20008'),
      totalQps?: long(name='TotalQps', description='The total QPS.', example='1'),
    }
  ](name='DomainQPSList', description='An array that consists of the statistics on the QPS of the website.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='327F2ABB-104D-437A-AAB5-D633E29A8C51'),
}

model DescribeDomainQPSListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainQPSListResponseBody(name='body'),
}

async function describeDomainQPSList(request: DescribeDomainQPSListRequest): DescribeDomainQPSListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainQPSList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainQpsWithCacheRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribeDomainQpsWithCacheResponseBody = {
  blocks?: [ string ](name='Blocks', description='An array that consists of the attack QPS.'),
  cacheHits?: [ string ](name='CacheHits', description='An array consisting of cache hit ratios.'),
  ccBlockQps?: [ string ](name='CcBlockQps', description='An array consisting of the QPS that is blocked by the Frequency Control policy.'),
  ccJsQps?: [ string ](name='CcJsQps', description='An array consisting of the QPS for which the Frequency Control policy triggers Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA).'),
  interval?: int32(name='Interval', description='The intervals between every two adjacent records. Unit: seconds.', example='20384'),
  ipBlockQps?: [ string ](name='IpBlockQps', description='An array consisting of the QPS that is blocked by the blacklist for domain names.'),
  preciseBlocks?: [ string ](name='PreciseBlocks', description='An array consisting of the QPS that is blocked by the Accurate Access Control policy.'),
  preciseJsQps?: [ string ](name='PreciseJsQps', description='An array consisting of the QPS for which the Accurate Access Control policy triggers the JavaScript challenge.'),
  regionBlocks?: [ string ](name='RegionBlocks', description='An array consisting of the QPS that is blocked by the Location Blacklist policy.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
  startTime?: long(name='StartTime', description='The start time. The value is a UNIX timestamp. Unit: seconds.', example='1582992000'),
  totals?: [ string ](name='Totals', description='An array consisting of the total QPS.'),
}

model DescribeDomainQpsWithCacheResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainQpsWithCacheResponseBody(name='body'),
}

async function describeDomainQpsWithCache(request: DescribeDomainQpsWithCacheRequest): DescribeDomainQpsWithCacheResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainQpsWithCache', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainResourceRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain?: string(name='Domain', description='The domain name of the website that you want to query.', example='www.example.com', position='Query'),
  instanceIds?: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances to query.', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Default value: **1**.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries to return on each page.', example='10', position='Query'),
  queryDomainPattern?: string(name='QueryDomainPattern', description='The match mode. Valid values:

*   **fuzzy**: fuzzy match. This is the default value.
*   **exact**: exact match.', example='fuzzy', position='Query'),
}

model DescribeDomainResourceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='39499F01-19D9-4EA4-A0E9-C6014BA5CDBE'),
  totalCount?: long(name='TotalCount', description='The total number of forwarding rules.', example='1'),
  webRules?: [ 
    {
      blackList?: [ string ](name='BlackList', description='An array consisting of the IP addresses that are included in the blacklist of the domain name.'),
      ccEnabled?: boolean(name='CcEnabled', description='Indicates whether the Frequency Control policy is enabled. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
      ccRuleEnabled?: boolean(name='CcRuleEnabled', description='Indicates whether the Custom Rule switch of the Frequency Control policy is turned on. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
      ccTemplate?: string(name='CcTemplate', description='The mode of the Frequency Control policy. Valid values:

*   **default**: the Normal mode
*   **gf_under_attack**: the Emergency mode
*   **gf_sos_verify**: the Strict mode
*   **gf_sos_verify**: the Super Strict mode', example='default'),
      certName?: string(name='CertName', description='The name of the SSL certificate used by the domain name.', example='49944XX.pem'),
      cname?: string(name='Cname', description='The CNAME provided by the instance to which the domain name is added.', example='0ekb69x3j9wvXXXX.aliyunddosXXXX.com'),
      customCiphers?: [ string ](name='CustomCiphers', description='An array that consists of custom cipher suites.'),
      domain?: string(name='Domain', description='The domain name of the website.', example='www.example.com'),
      http2Enable?: boolean(name='Http2Enable', description='Indicates whether Enable HTTP/2 is turned on. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
      http2HttpsEnable?: boolean(name='Http2HttpsEnable', description='Indicates whether Enforce HTTPS Routing is turned on. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
      https2HttpEnable?: boolean(name='Https2HttpEnable', description='Indicates whether Enable HTTP is turned on. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
      httpsExt?: string(name='HttpsExt', description='The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:

*   **Http2https**: indicates whether the feature of redirecting HTTP requests to HTTPS requests is enabled. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that the feature is disabled. The value 1 indicates that the feature is enabled.
*   **Https2http**: indicates whether the feature of redirecting HTTPS requests to HTTP requests is enabled. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that the feature is disabled. The value 1 indicates that the feature is enabled.
*   **Http2**: indicates whether HTTP/2 is supported. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that HTTP/2 is not supported. The value 1 indicates that HTTP/2 is supported.', example='{"Https2http":0,"Http2":0,"Http2https":0}'),
      instanceIds?: [ string ](name='InstanceIds', description='An array consisting of the IDs of the instances to which the domain name is added.'),
      policyMode?: string(name='PolicyMode', description='The scheduling algorithm for back-to-origin traffic. Valid values:

*   **ip_hash**: the IP hash algorithm. This algorithm is used to redirect the requests from the same IP address to the same origin server.
*   **rr**: the round-robin algorithm. This algorithm is used to redirect requests to origin servers in turn.
*   **least_time**: the least response time algorithm. This algorithm is used to minimize the latency when requests are forwarded from Anti-DDoS Pro or Anti-DDoS Premium instances to origin servers based on the intelligent DNS resolution feature.', example='ip_hash'),
      proxyEnabled?: boolean(name='ProxyEnabled', description='Indicates whether the instance forwards the traffic that is destined for the website. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
      proxyTypes?: [ 
        {
          proxyPorts?: [ string ](name='ProxyPorts', description='An array that consists of the port numbers.'),
          proxyType?: string(name='ProxyType', description='The type of the protocol. Valid values:

*   **http**
*   **https**
*   **websocket**
*   **websockets**', example='http'),
        }
      ](name='ProxyTypes', description='An array that consists of the details of the protocol type and port number.'),
      punishReason?: int32(name='PunishReason', description='The reason why the domain name is invalid. Valid values:

*   **1**: No ICP filing is completed for the domain name.
*   **2**: The business for which you registered the domain name does not meet regulatory requirements.

If the two reasons are both involved, the value **2** is returned.', example='1'),
      punishStatus?: boolean(name='PunishStatus', description='Indicates whether the domain name is invalid. Valid values:

*   **true**: The domain name is invalid. You can view the specific reasons from the **PunishReason** parameter.
*   **false**: The domain name is valid.', example='false'),
      realServers?: [ string ](name='RealServers', description='An array that consists of the addresses of the origin servers.'),
      rsType?: int32(name='RsType', description='The address type of the origin server. Valid values:

*   **0**: IP address
*   **1**: domain name', example='0'),
      ssl13Enabled?: boolean(name='Ssl13Enabled', description='Indicates whether TLS 1.3 is supported. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
      sslCiphers?: string(name='SslCiphers', description='The type of the cipher suite. Valid values:

*   **default**: custom cipher suite
*   **all**: all cipher suites
*   **strong**: strong cipher suites', example='default'),
      sslProtocols?: string(name='SslProtocols', description='The version of the TLS protocol. Valid values:

*   **tls1.0**: TLS 1.0 or later
*   **tls1.1**: TLS 1.1 or later
*   **tls1.2**: TLS 1.2 or later', example='tls1.0'),
      whiteList?: [ string ](name='WhiteList', description='An array consisting of the IP addresses that are included in the whitelist of the domain name.'),
    }
  ](name='WebRules', description='An array that consists of the configurations of the forwarding rule.'),
}

model DescribeDomainResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainResourceResponseBody(name='body'),
}

/**
  * You can call the DescribeDomainResource operation to query the configurations of the forwarding rules that you create for a website by page. The configurations include the domain name-related configurations, protocol-related configurations, HTTPS-related configurations, and configurations that are used to mitigate HTTP flood attacks.
  * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](~~95820~~).
  * ### Limits
  * You can call this operation up to 50 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeDomainResource(request: DescribeDomainResourceRequest): DescribeDomainResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainResource', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainStatusCodeCountRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribeDomainStatusCodeCountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  status200?: long(name='Status200', description='The number of 200 status codes within the specified period of time.', example='951159'),
  status2XX?: long(name='Status2XX', description='The number of 2xx status codes within the specified period of time.', example='951472'),
  status3XX?: long(name='Status3XX', description='The number of 3xx status codes within the specified period of time.', example='133209'),
  status403?: long(name='Status403', description='The number of 403 status codes within the specified period of time.', example='0'),
  status404?: long(name='Status404', description='The number of 404 status codes within the specified period of time.', example='897'),
  status405?: long(name='Status405', description='The number of 405 status codes within the specified period of time.', example='0'),
  status4XX?: long(name='Status4XX', description='The number of 4xx status codes within the specified period of time.', example='5653'),
  status501?: long(name='Status501', description='The number of 501 status codes within the specified period of time.', example='0'),
  status502?: long(name='Status502', description='The number of 502 status codes within the specified period of time.', example='0'),
  status503?: long(name='Status503', description='The number of 503 status codes within the specified period of time.', example='0'),
  status504?: long(name='Status504', description='The number of 504 status codes within the specified period of time.', example='0'),
  status5XX?: long(name='Status5XX', description='The number of 5xx status codes within the specified period of time.', example='14'),
}

model DescribeDomainStatusCodeCountResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainStatusCodeCountResponseBody(name='body'),
}

async function describeDomainStatusCodeCount(request: DescribeDomainStatusCodeCountRequest): DescribeDomainStatusCodeCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainStatusCodeCount', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainStatusCodeListRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain?: string(name='Domain', description='The domain name of the website. If you do not specify this parameter, the statistics on response status codes of all domain names are queried.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  interval: long(name='Interval', description='The interval for returning data. Unit: seconds.', example='1000', position='Query'),
  queryType: string(name='QueryType', description='The source of the statistics. Valid values:

*   **gf**: Anti-DDoS Pro or Anti-DDoS Premium
*   **upstrem**: origin server', example='gf', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The start time of the event. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribeDomainStatusCodeListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3B63C0DD-8AC5-44B2-95D6-064CA9296B9C'),
  statusCodeList?: [ 
    {
      index?: int32(name='Index', description='The index number of the returned data.', example='0'),
      status200?: long(name='Status200', description='The number of 200 status codes.', example='15520'),
      status2XX?: long(name='Status2XX', description='The number of 2xx status codes.', example='15520'),
      status3XX?: long(name='Status3XX', description='The number of 3xx status codes.', example='0'),
      status403?: long(name='Status403', description='The number of 403 status codes.', example='0'),
      status404?: long(name='Status404', description='The number of 404 status codes.', example='0'),
      status405?: long(name='Status405', description='The number of 405 status codes.', example='0'),
      status4XX?: long(name='Status4XX', description='The number of 4xx status codes.', example='4486'),
      status501?: long(name='Status501', description='The number of 501 status codes.', example='0'),
      status502?: long(name='Status502', description='The number of 502 status codes.', example='0'),
      status503?: long(name='Status503', description='The number of 503 status codes.', example='0'),
      status504?: long(name='Status504', description='The number of 504 status codes.', example='0'),
      status5XX?: long(name='Status5XX', description='The number of 5xx status codes.', example='0'),
      time?: long(name='Time', description='The time when the data was collected. The value is a UNIX timestamp. Unit: seconds.', example='1582992000'),
    }
  ](name='StatusCodeList', description='The statistics on response status codes.'),
}

model DescribeDomainStatusCodeListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainStatusCodeListResponseBody(name='body'),
}

async function describeDomainStatusCodeList(request: DescribeDomainStatusCodeListRequest): DescribeDomainStatusCodeListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainStatusCodeList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainTopAttackListRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribeDomainTopAttackListResponseBody = {
  attackList?: [ 
    {
      attack?: long(name='Attack', description='The attack QPS. Unit: QPS', example='0'),
      count?: long(name='Count', description='The number of all QPS, which includes normal and attack QPS. Unit: QPS.', example='294'),
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
    }
  ](name='AttackList', description='The peak QPS of the website.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DescribeDomainTopAttackListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainTopAttackListResponseBody(name='body'),
}

async function describeDomainTopAttackList(request: DescribeDomainTopAttackListRequest): DescribeDomainTopAttackListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainTopAttackList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainViewSourceCountriesRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribeDomainViewSourceCountriesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  sourceCountrys?: [ 
    {
      count?: long(name='Count', description='The total number of requests.', example='3390671'),
      countryId?: string(name='CountryId', description='The abbreviation of the country or area. For more information, see the **Codes of countries and areas** section of the [Codes of administrative regions in China and codes of countries and areas](~~167926~~) topic. For example, **cn** indicates China, and **us** indicates the United States.', example='cn'),
    }
  ](name='SourceCountrys', description='An array consisting of the country or area from which the requests are sent.'),
}

model DescribeDomainViewSourceCountriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainViewSourceCountriesResponseBody(name='body'),
}

async function describeDomainViewSourceCountries(request: DescribeDomainViewSourceCountriesRequest): DescribeDomainViewSourceCountriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainViewSourceCountries', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainViewSourceProvincesRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribeDomainViewSourceProvincesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  sourceProvinces?: [ 
    {
      count?: long(name='Count', description='The total number of requests.', example='3390671'),
      provinceId?: string(name='ProvinceId', description='The ID of the region inside China. For more information, see the **Codes of administrative regions in China** section of the [Codes of administrative regions in China and codes of countries and areas](~~167926~~) topic. For example, **110000** indicates Beijing, and **120000** indicates Tianjin.', example='440000'),
    }
  ](name='SourceProvinces', description='An array consisting of the details of the administrative region in China from which the requests are sent.'),
}

model DescribeDomainViewSourceProvincesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainViewSourceProvincesResponseBody(name='body'),
}

async function describeDomainViewSourceProvinces(request: DescribeDomainViewSourceProvincesRequest): DescribeDomainViewSourceProvincesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainViewSourceProvinces', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainViewTopCostTimeRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
  top: int32(name='Top', description='The number of URLs to query. Valid values: **1** to **100**.', example='5', minimum=1, maximum=100, position='Query'),
}

model DescribeDomainViewTopCostTimeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  urlList?: [ 
    {
      costTime?: float(name='CostTime', description='The response duration. Unit: milliseconds.', example='3000'),
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
      url?: string(name='Url', description='The URL that is Base64-encoded.', example='Lw=='),
    }
  ](name='UrlList', description='The URLs which require the longest time to respond to requests.'),
}

model DescribeDomainViewTopCostTimeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainViewTopCostTimeResponseBody(name='body'),
}

async function describeDomainViewTopCostTime(request: DescribeDomainViewTopCostTimeRequest): DescribeDomainViewTopCostTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainViewTopCostTime', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainViewTopUrlRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
  top: int32(name='Top', description='The number of URLs to query. Valid values: **1** to **100**.', example='5', minimum=1, maximum=100, position='Query'),
}

model DescribeDomainViewTopUrlResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  urlList?: [ 
    {
      count?: long(name='Count', description='The total number of requests.', example='3390671'),
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
      url?: string(name='Url', description='The URL that is Base64-encoded.', example='Lw=='),
    }
  ](name='UrlList', description='An array consisting of the URLs that receive the most requests.'),
}

model DescribeDomainViewTopUrlResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainViewTopUrlResponseBody(name='body'),
}

async function describeDomainViewTopUrl(request: DescribeDomainViewTopUrlRequest): DescribeDomainViewTopUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainViewTopUrl', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainsRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceIds?: [ string ](name='InstanceIds', description='The ID of the instance that you want to query.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](~~94485~~).', example='rg-acfm2pz25js****', position='Query'),
}

model DescribeDomainsResponseBody = {
  domains?: [ string ](name='Domains', description='An array consisting of details of the domain name for which the forwarding rules are configured.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F908E959-ADA8-4D7B-8A05-FF2F67F50964'),
}

model DescribeDomainsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDomainsResponseBody(name='body'),
}

async function describeDomains(request: DescribeDomainsRequest): DescribeDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomains', 'POST', '/', 'json', false, 'json', request);
}

model DescribeElasticBandwidthSpecRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
}

model DescribeElasticBandwidthSpecResponseBody = {
  elasticBandwidthSpec?: [ string ](name='ElasticBandwidthSpec', description='An array that consists of the available burstable protection bandwidths. Unit: Gbit/s.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DescribeElasticBandwidthSpecResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeElasticBandwidthSpecResponseBody(name='body'),
}

/**
  * > This operation is suitable only for Anti-DDoS Pro.
  *
 */
async function describeElasticBandwidthSpec(request: DescribeElasticBandwidthSpecRequest): DescribeElasticBandwidthSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeElasticBandwidthSpec', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHeadersRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
}

model DescribeHeadersResponseBody = {
  customHeader?: {
    domain?: string(name='Domain'),
    headers?: string(name='Headers'),
  }(name='CustomHeader'),
  requestId?: string(name='RequestId'),
}

model DescribeHeadersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHeadersResponseBody(name='body'),
}

async function describeHeaders(request: DescribeHeadersRequest): DescribeHeadersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHeaders', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHealthCheckListRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  networkRules: string(name='NetworkRules', description='The information about the port forwarding rule. This parameter is a JSON string. The string contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.', example='[{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080}]', position='Query'),
}

model DescribeHealthCheckListResponseBody = {
  healthCheckList?: [ 
    {
      frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='8080'),
      healthCheck?: {
        domain?: string(name='Domain', description='The domain name.

> This parameter is returned only when the Layer 7 health check configuration is queried.', example='www.aliyun.com'),
        down?: int32(name='Down', description='The number of consecutive failed health checks that must occur before a port is declared unhealthy. Valid values: **1** to **10**.', example='3'),
        interval?: int32(name='Interval', description='The interval at which checks are performed. Valid values: **1** to **30**. Unit: seconds.', example='15'),
        port?: int32(name='Port', description='The port that was checked.', example='8080'),
        timeout?: int32(name='Timeout', description='The response timeout period. Valid values: **1** to **30**. Unit: seconds.', example='5'),
        type?: string(name='Type', description='The type of the protocol. Valid values:

*   **tcp**: The Layer 4 health check configuration was queried.
*   **http**: The Layer 7 health check configuration was queried.', example='tcp'),
        up?: int32(name='Up', description='The number of consecutive successful health checks that must occur before a port is declared healthy. Valid values: **1** to **10**.', example='3'),
        uri?: string(name='Uri', description='The check path.

> This parameter is returned only when the Layer 7 health check configuration is queried.', example='/abc'),
      }(name='HealthCheck', description='The health check configuration.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-mp91j1ao****'),
      protocol?: string(name='Protocol', description='The forwarding protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp'),
    }
  ](name='HealthCheckList', description='An array that consists of information about the health check configuration.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='83B4AF42-E8EE-4DC9-BD73-87B7733A36F9'),
}

model DescribeHealthCheckListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHealthCheckListResponseBody(name='body'),
}

async function describeHealthCheckList(request: DescribeHealthCheckListRequest): DescribeHealthCheckListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHealthCheckList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHealthCheckStatusRequest {
  regionId?: string(name='RegionId', position='Host'),
  networkRules: string(name='NetworkRules', description='An array that consists of the details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.', example='[{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080}]', position='Query'),
}

model DescribeHealthCheckStatusResponseBody = {
  healthCheckStatus?: [ 
    {
      frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='8080'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-mp91j1ao****'),
      protocol?: string(name='Protocol', description='The forwarding protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp'),
      realServerStatusList?: [ 
        {
          address?: string(name='Address', description='The IP address of the origin server.', example='192.0.XX.XX'),
          status?: string(name='Status', description='The health state of the IP address. Valid values:

*   **normal**: healthy
*   **abnormal**: unhealthy', example='abnormal'),
        }
      ](name='RealServerStatusList', description='An array that consists of the health states of the IP addresses of the origin server.'),
      status?: string(name='Status', description='The health status of the origin server. Valid values:

*   **normal**: healthy
*   **abnormal**: unhealthy', example='normal'),
    }
  ](name='HealthCheckStatus', description='An array that consists of the details of the health status of the origin server.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='DE9FF9E1-569C-4B6C-AB6A-0F6D927BB27C'),
}

model DescribeHealthCheckStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHealthCheckStatusResponseBody(name='body'),
}

async function describeHealthCheckStatus(request: DescribeHealthCheckStatusRequest): DescribeHealthCheckStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHealthCheckStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceDetailsRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceIds: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances to query.', position='Query'),
}

model DescribeInstanceDetailsResponseBody = {
  instanceDetails?: [ 
    {
      eipInfos?: [ 
        {
          eip?: string(name='Eip', description='The IP address of the instance.', example='203.117.XX.XX'),
          ipMode?: string(name='IpMode', description='The IP address-based forwarding mode of the instance. Valid values:

*   **fnat**: Requests from IPv4 addresses are forwarded to origin servers that use IPv4 addresses and requests from IPv6 addresses are forwarded to origin servers that use IPv6 addresses.
*   **v6tov4**: All requests are forwarded to origin servers that use IPv4 addresses.', example='fnat'),
          ipVersion?: string(name='IpVersion', description='The IP version of the protocol. Valid values:

*   **Ipv4**: IPv4
*   **Ipv6**: IPv6', example='Ipv4'),
          status?: string(name='Status', description='The status of the instance. Valid values:

*   **normal**
*   **expired**', example='normal'),
        }
      ](name='EipInfos', description='The information about the IP address of the instance.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-zvp2eibz****'),
      line?: string(name='Line', description='The protection line of the instance.', example='coop-line-001'),
    }
  ](name='InstanceDetails', description='The IP address and ISP line information about the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3C814429-21A5-4673-827E-FDD19DC75681'),
}

model DescribeInstanceDetailsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceDetailsResponseBody(name='body'),
}

/**
  * You can call the DescribeInstanceDetails operation to query the information about the IP addresses and ISP lines of the instances. The information includes the IP address, status, and protection line.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeInstanceDetails(request: DescribeInstanceDetailsRequest): DescribeInstanceDetailsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceDetails', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceIdsRequest {
  regionId?: string(name='RegionId', position='Host'),
  edition?: int32(name='Edition', description='The type of the instance that you want to query. Valid values:

*   **0**: Anti-DDoS Premium instance of the Insurance mitigation plan
*   **1**: Anti-DDoS Premium instance of the Unlimited mitigation plan
*   **2**: Anti-DDoS Premium instance of the Chinese Mainland Acceleration (CMA) mitigation plan
*   **9**: Anti-DDoS Pro instance of the Profession mitigation plan', example='9', position='Query'),
  instanceIds?: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances to query.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
}

model DescribeInstanceIdsResponseBody = {
  instanceIds?: [ 
    {
      edition?: int32(name='Edition', description='The mitigation plan of the instance. Valid values:

*   **0**: Anti-DDoS Premium instance of the Insurance mitigation plan
*   **1**: Anti-DDoS Premium instance of the Unlimited mitigation plan
*   **2**: Anti-DDoS Premium instance of the CMA mitigation plan
*   **3**: Anti-DDoS Premium instance of the Secure Chinese Mainland Acceleration (Sec-CMA) mitigation plan
*   **9**: Anti-DDoS Pro instance of the Profession mitigation plan', example='9'),
      instanceId?: string(name='InstanceId', description='The ID of the instance', example='ddoscoo-cn-zvp2eibz****'),
      ipMode?: string(name='IpMode', description='The IP address-based forwarding mode of the instance. Valid values:

*   **fnat**: Requests from IPv4 addresses are forwarded to origin servers that use IPv4 addresses and requests from IPv6 addresses are forwarded to origin servers that use IPv6 addresses.
*   **v6tov4**: All requests are forwarded to origin servers that use IPv4 addresses.', example='fnat'),
      ipVersion?: string(name='IpVersion', description='The IP version of the protocol of the instance. Valid values:

*   **Ipv4**
*   **Ipv6**', example='Ipv4'),
      remark?: string(name='Remark', description='The description of the instance.', example='test'),
    }
  ](name='InstanceIds', description='An array that consists of the ID, version, description, and IP address type of the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='310A41FD-0990-5610-92E0-A6A55D7C6444'),
}

model DescribeInstanceIdsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceIdsResponseBody(name='body'),
}

/**
  * You can call this operation to query the information about all Anti-DDoS Pro or Anti-DDoS Premium instances, such as the ID, version, description, and IP address type.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeInstanceIds(request: DescribeInstanceIdsRequest): DescribeInstanceIdsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceIds', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceSpecsRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceIds: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances to query.', position='Query'),
}

model DescribeInstanceSpecsResponseBody = {
  instanceSpecs?: [ 
    {
      bandwidthMbps?: int32(name='BandwidthMbps', description='The clean bandwidth of normal services. Unit: Mbit/s.', example='100'),
      baseBandwidth?: int32(name='BaseBandwidth', description='The basic protection bandwidth. Unit: Gbit/s.', example='30'),
      connLimit?: long(name='ConnLimit', description='The specification of concurrent connections of the instance.', example='100000'),
      cpsLimit?: long(name='CpsLimit', description='The specification of new connections of the instance.', example='5000'),
      defenseCount?: int32(name='DefenseCount', description='The number of available advanced mitigation sessions for this month. If **-1** is returned, advanced mitigation capabilities are unlimited.

> This parameter is returned only when **RegionId** is set to **ap-southeast-1**. If RegionId is set to ap-southeast-1, the specifications of Anti-DDoS Premium instances are queried.', example='2'),
      domainLimit?: int32(name='DomainLimit', description='The number of domain names that can be protected by the instance.', example='50'),
      elasticBandwidth?: int32(name='ElasticBandwidth', description='The burstable protection bandwidth. Unit: Gbit/s.', example='30'),
      elasticBw?: int32(name='ElasticBw', description='The burstable clean bandwidth. Unit: Mbit/s.', example='300'),
      elasticBwModel?: string(name='ElasticBwModel', description='The metering method of the burstable clean bandwidth. Valid values:

*   **day**: the metering method of daily 95th percentile
*   **month**: the metering method of monthly 95th percentile', example='day'),
      functionVersion?: string(name='FunctionVersion', description='The function plan of the instance. Valid values:

*   **default**: Standard
*   **enhance**: Enhanced
*   **cnhk**: Chinese Mainland Acceleration (CMA)
*   **cnhk_default**: Secure Chinese Mainland Acceleration (Sec-CMA) standard function plan
*   **cnhk_enhance**: Sec-CMA enhanced function plan', example='default'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-zvp2eibz****'),
      portLimit?: int32(name='PortLimit', description='The number of ports that can be protected by the instance.', example='50'),
      qpsLimit?: int32(name='QpsLimit', description='The clean queries per second (QPS) of normal services.', example='3000'),
      siteLimit?: int32(name='SiteLimit', description='The number of sites that can be protected by the instance.', example='5'),
    }
  ](name='InstanceSpecs', description='An array that consists of the specifications of instances.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4E3A9B5F-5DDB-593D-A1E6-F1F451DB5E0B'),
}

model DescribeInstanceSpecsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceSpecsResponseBody(name='body'),
}

/**
  * You can call the DescribeInstanceSpecs operation to query the specifications of multiple Anti-DDoS Pro or Anti-DDoS Premium instances at a time. The specifications include the clean bandwidth, protection bandwidth, function plan, and the numbers of domain names and ports that can be protected.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeInstanceSpecs(request: DescribeInstanceSpecsRequest): DescribeInstanceSpecsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceSpecs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceStatisticsRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceIds: [ string ](name='InstanceIds', description='The ID of the instance that you want to query.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
}

model DescribeInstanceStatisticsResponseBody = {
  instanceStatistics?: [ 
    {
      defenseCountUsage?: int32(name='DefenseCountUsage', description='The number of advanced mitigation sessions that are used in this month.

> This parameter is returned only if Anti-DDoS Premium instances are queried.', example='1'),
      domainUsage?: int32(name='DomainUsage', description='The number of domain names that are protected by the instance.', example='1'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-mp91j1ao****'),
      portUsage?: int32(name='PortUsage', description='The number of ports that are protected by the instance.', example='2'),
      siteUsage?: int32(name='SiteUsage', description='The number of websites that are protected by the instance.', example='1'),
    }
  ](name='InstanceStatistics', description='The statistics on the instances.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='642319A9-D1F2-4459-A447-E57CFC599FDE'),
}

model DescribeInstanceStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceStatisticsResponseBody(name='body'),
}

async function describeInstanceStatistics(request: DescribeInstanceStatisticsRequest): DescribeInstanceStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceStatusRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance to query.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all Anti-DDoS Pro or Anti-DDoS Premium instances.', example='ddoscoo-cn-6ja1y6p5****', position='Query'),
  productType: int32(name='ProductType', description='The type of the instance to query. Valid values:

*   **1**: an Anti-DDoS Pro instance
*   **2**: an Anti-DDoS Premium instance', example='1', position='Query'),
}

model DescribeInstanceStatusResponseBody = {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-6ja1y6p5****'),
  instanceStatus?: int32(name='InstanceStatus', description='The status of the instance. Valid values:

*   **1**: normal
*   **2**: expired
*   **3**: overdue
*   **4**: released', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='112777CC-2AD6-46FC-A263-00B931406FCD'),
}

model DescribeInstanceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceStatusResponseBody(name='body'),
}

async function describeInstanceStatus(request: DescribeInstanceStatusRequest): DescribeInstanceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstancesRequest {
  regionId?: string(name='RegionId', position='Host'),
  edition?: int32(name='Edition', description='The mitigation plan of the instance to query. Valid values:

*   **0**: Anti-DDoS Premium instance of the Insurance mitigation plan
*   **1**: Anti-DDoS Premium instance of the Unlimited mitigation plan
*   **2**: Anti-DDoS Premium instance of the Chinese Mainland Acceleration (CMA) mitigation plan
*   **9**: Anti-DDoS Pro instance of the Profession mitigation plan', example='9', position='Query'),
  enabled?: int32(name='Enabled', description='The traffic forwarding status of the instance to query. Valid values:

*   **0**: The instance no longer forwards service traffic.
*   **1**: The instance forwards service traffic as expected.', example='1', position='Query'),
  expireEndTime?: long(name='ExpireEndTime', description='The end of the time range to query. Instances whose expiration time is earlier than the point in time are queried.**** The value is a UNIX timestamp. Unit: milliseconds.', example='1640361700000', position='Query'),
  expireStartTime?: long(name='ExpireStartTime', description='The beginning of the time range to query. Instances whose expiration time is later than the point in time are queried.**** The value is a UNIX timestamp. Unit: milliseconds.', example='1640361500000', position='Query'),
  instanceIds?: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances to query.', position='Query'),
  ip?: string(name='Ip', description='The IP address of the instance to query.', example='203.107.XX.XX', position='Query'),
  pageNumber: string(name='PageNumber', description='The number of the page to return.', example='1', position='Query'),
  pageSize: string(name='PageSize', description='The number of entries to return on each page.', example='10', position='Query'),
  remark?: string(name='Remark', description='The description of the instance to query. Fuzzy match is supported.', example='doc-test', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
  status?: [ int32 ](name='Status', description='An array that consists of the states of the instances to query.', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of tag N that is added to the instance to query. The maximum value of N is 200. You can specify up to 200 tags. When you specify tags, take note of the following rules:

*   Each tag consists of a key (**Key**) and a value (**Value**), which are separated by a comma (,).
*   Separate multiple tags with commas (,).

> : The tag key (**Key**) and tag value (**Value**) must be specified in pairs.', example='test-key'),
      value?: string(name='Value', description='The value of tag N that is added to the instance to query. The maximum value of N is 200. You can specify up to 200 tags. When you specify tags, take note of the following rules:

*   Each tag consists of a key (**Key**) and a value (**Value**), which are separated by a comma (,).
*   Separate multiple tags with commas (,).

> : The tag key (**Key**) and tag value (**Value**) must be specified in pairs.', example='test-value'),
    }
  ](name='Tag', description='An array consisting of the tags that are added to the instance to query.', position='Query'),
}

model DescribeInstancesResponseBody = {
  instances?: [ 
    {
      createTime?: long(name='CreateTime', description='The time when the instance was created. The value is a UNIX timestamp. Unit: milliseconds.', example='1637751953000'),
      debtStatus?: int32(name='DebtStatus', description='The overdue status of the instance. The value is fixed as **0**, which indicates that your Alibaba Cloud account does not have overdue payments. The instance supports only the subscription billing method.', example='0'),
      edition?: int32(name='Edition', description='The mitigation plan of the instance. Valid values:

*   **0**: Anti-DDoS Premium instance of the Insurance mitigation plan
*   **1**: Anti-DDoS Premium instance of the Unlimited mitigation plan
*   **2**: Anti-DDoS Premium instance of the CMA mitigation plan
*   **9**: Anti-DDoS Pro instance of the Profession mitigation plan', example='9'),
      enabled?: int32(name='Enabled', description='The forwarding status of the instance. Valid values:

*   **0**: The instance no longer forwards service traffic.
*   **1**: The instance forwards service traffic as expected.', example='1'),
      expireTime?: long(name='ExpireTime', description='The time when the instance expires. The value is a UNIX timestamp. Unit: milliseconds.', example='1640361600000'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-7pp2g9ed****'),
      ipMode?: string(name='IpMode', description='The IP address-based forwarding mode of the instance. Valid values:

*   **fnat**: Requests from IPv4 addresses are forwarded to origin servers that use IPv4 addresses and requests from IPv6 addresses are forwarded to origin servers that use IPv6 addresses.
*   **v6tov4**: All requests are forwarded to origin servers that use IPv4 addresses.', example='fnat'),
      ipVersion?: string(name='IpVersion', description='The IP version of the protocol of the instance. Valid values:

*   **Ipv4**: IPv4
*   **Ipv6**: IPv6', example='Ipv4'),
      isFirstOpenBw?: long(name='IsFirstOpenBw', description='Indicates whether the 95th percentile metering method has been enabled for the instance. Valid values:

*   0: no
*   1: yes', example='0'),
      remark?: string(name='Remark', description='The description of the instance.', example='doc-test'),
      status?: int32(name='Status', description='The state of the instance. Valid values:

*   **1**: normal
*   **2**: expired', example='1'),
    }
  ](name='Instances', description='An array that consists of the details of the instances.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A0AF40CC-814A-5A86-AEAA-6F19E88B8A39'),
  totalCount?: long(name='TotalCount', description='The total number of the instances.', example='1'),
}

model DescribeInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstancesResponseBody(name='body'),
}

/**
  * You can call the DescribeInstances operation to query the details of Anti-DDoS Pro or Anti-DDoS Premium instances within the Alibaba Cloud account by page. The details include the ID, mitigation plan, expiration time, and forwarding status.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeInstances(request: DescribeInstancesRequest): DescribeInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeL7RsPolicyRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name of the website to query.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query the domain names for which forwarding rules are configured.', example='example.com', position='Query'),
  realServers?: [ string ](name='RealServers', description='An array that consists of N addresses of origin servers to query. The maximum value of N is 200. You can specify up to 200 addresses.', example='1.***.***.1', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](~~94485~~).', example='rg-acfm2pz25js****', position='Query'),
}

model DescribeL7RsPolicyResponseBody = {
  attributes?: [ 
    {
      attribute?: {
        weight?: int32(name='Weight', description='The weight of the origin server. This parameter takes effect only when **ProxyMode** is set to **rr**.

Valid values: **1** to **100**. Default value: **100**. A server with a higher weight receives more requests.', example='100'),
      }(name='Attribute', description='The parameter for back-to-origin.'),
      realServer?: string(name='RealServer', description='The address of the origin server.', example='1.***.***.1'),
      rsType?: int32(name='RsType', description='The address type of the origin server. Valid values:

*   **0**: IP address
*   **1**: domain name', example='0'),
    }
  ](name='Attributes', description='The details of the parameters for back-to-origin.'),
  proxyMode?: string(name='ProxyMode', description='The scheduling algorithm for back-to-origin traffic. Valid values:

*   **ip_hash**: the IP hash algorithm. This algorithm is used to redirect the requests from the same IP address to the same origin server.
*   **rr**: the round-robin algorithm. This algorithm is used to redirect requests to origin servers in turn.
*   **least_time**: the least response time algorithm. This algorithm is used to minimize the latency when requests are forwarded from Anti-DDoS Pro or Anti-DDoS Premium instances to origin servers based on the intelligent DNS resolution feature.', example='rr'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9E7F6B2C-03F2-462F-9076-B782CF0DD502'),
}

model DescribeL7RsPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeL7RsPolicyResponseBody(name='body'),
}

async function describeL7RsPolicy(request: DescribeL7RsPolicyRequest): DescribeL7RsPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeL7RsPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLayer4RulePolicyRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  listeners: string(name='Listeners', description='The port forwarding rule that you want to query.

This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can query only one port forwarding rule at a time.

> You can call the [DescribeNetworkRules](~~157484~~) to query existing port forwarding rules.

Each port forwarding rule contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the string type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the string type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the integer type.', example='[{\\"InstanceId\\":\\"ddosDip-sg-4hr2b3l****\\",\\"FrontendPort\\":2020,\\"Protocol\\":\\"udp\\"}]', position='Query'),
}

model DescribeLayer4RulePolicyResponseBody = {
  backendPort?: int32(name='BackendPort', description='The port of the origin server.', example='2022'),
  bakMode?: string(name='BakMode', description='The mode that is used to forward service traffic. Valid values:

*   0: the default mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the origin IP address that you specified when you created the port forwarding rule. You can call the [CreateNetworkRules](~~157482~~) operation to create a port forwarding rule.
*   1: the origin redundancy mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary or secondary origin servers. You can call the [ConfigLayer4RulePolicy](~~312684~~) operation to configure IP addresses.', example='1'),
  currentIndex?: int32(name='CurrentIndex', description='The origin server that is used to receive service traffic. Valid values:

*   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
*   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.', example='1'),
  forwardProtocol?: string(name='ForwardProtocol', description='The type of the protocol.', example='udp'),
  frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='2020'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddosDip-sg-4hr2b3l****'),
  priRealServers?: [ 
    {
      currentIndex?: int32(name='CurrentIndex', description='The origin server that is used to receive service traffic. Valid values:

*   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
*   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.', example='1'),
      eip?: string(name='Eip', description='The IP address of the instance.', example='203.107.XX.XX'),
      frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='2020'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddosDip-sg-4hr2b3l****'),
      protocol?: string(name='Protocol', description='The type of the protocol.', example='udp'),
      realServer?: string(name='RealServer', description='The IP address of the primary origin server.', example='192.0.2.1'),
    }
  ](name='PriRealServers', description='An array that consists of the information about the primary origin server, including the IP addresses, forwarding protocol, and forwarding port.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6E46CC51-36BE-1100-B14C-DAF8381B8F73'),
  secRealServers?: [ 
    {
      currentIndex?: int32(name='CurrentIndex', description='The origin server that is used to receive service traffic. Valid values:

*   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
*   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.', example='1'),
      eip?: string(name='Eip', description='The IP address of the instance.', example='203.107.XX.XX'),
      frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='2020'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddosDip-sg-4hr2b3l****'),
      protocol?: string(name='Protocol', description='The type of the protocol.', example='udp'),
      realServer?: string(name='RealServer', description='The IP address of the secondary origin server.', example='192.0.2.3'),
    }
  ](name='SecRealServers', description='An array that consists of the information about the secondary origin server, including the IP addresses, forwarding protocol, and forwarding port.'),
}

model DescribeLayer4RulePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLayer4RulePolicyResponseBody(name='body'),
}

async function describeLayer4RulePolicy(request: DescribeLayer4RulePolicyRequest): DescribeLayer4RulePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLayer4RulePolicy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLogStoreExistStatusRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeLogStoreExistStatusResponseBody = {
  existStatus?: boolean(name='ExistStatus', description='Indicates whether a Logstore is created for Anti-DDoS Pro or Anti-DDoS Premium. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model DescribeLogStoreExistStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLogStoreExistStatusResponseBody(name='body'),
}

async function describeLogStoreExistStatus(request: DescribeLogStoreExistStatusRequest): DescribeLogStoreExistStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLogStoreExistStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNetworkRegionBlockRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
}

model DescribeNetworkRegionBlockResponseBody = {
  config?: {
    countries?: [ string ](name='Countries', description='An array consisting of the codes of the countries or areas from which the requests are blocked.'),
    provinces?: [ string ](name='Provinces', description='An array consisting of the codes of the administrative regions in China from which the requests are blocked.'),
    regionBlockSwitch?: string(name='RegionBlockSwitch', description='The status of the Location Blacklist policy. Valid values:

*   **on**: enabled
*   **off**: disabled', example='on'),
  }(name='Config', description='The configuration of blocked locations.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DescribeNetworkRegionBlockResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkRegionBlockResponseBody(name='body'),
}

async function describeNetworkRegionBlock(request: DescribeNetworkRegionBlockRequest): DescribeNetworkRegionBlockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworkRegionBlock', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNetworkRuleAttributesRequest {
  regionId?: string(name='RegionId', position='Host'),
  networkRules: string(name='NetworkRules', description='The details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.', example='[{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080}]', position='Query'),
}

model DescribeNetworkRuleAttributesResponseBody = {
  networkRuleAttributes?: [ 
    {
      config?: {
        cc?: {
          sblack?: [ 
            {
              cnt?: int32(name='Cnt', description='The threshold that the number of connections initiated from a source IP address can exceed the limit. Set the value to **5**. If the number of connections initiated from a source IP address exceeds the limit five times during the check, the source IP address is added to the blacklist.', example='5'),
              during?: int32(name='During', description='The interval at which checks are performed. Set the value to **60**. Unit: seconds.', example='60'),
              expires?: int32(name='Expires', description='The validity period of the IP address in the blacklist. Valid values: **60** to **604800**. Unit: seconds.', example='600'),
              type?: int32(name='Type', description='The type of the limit that causes a source IP address to be added to the blacklist. Valid values:

*   **1**: Source New Connection Rate Limit
*   **2**: Source Concurrent Connection Rate Limit
*   **3**: PPS Limit for Source
*   **4**: Bandwidth Limit for Source', example='1'),
            }
          ](name='Sblack', description='The protection policy that a source IP address is added to the blacklist when the number of connections initiated from the IP address frequently exceeds the limit.'),
        }(name='Cc', description='The protection policy applied when the number of connections initiated from a source IP address frequently exceeds the limit.'),
        nodataConn?: string(name='NodataConn', description='The status of the Empty Connection switch. Valid values:

*   **on**: The switch is turned on.
*   **off**: The switch is turned off.', example='off'),
        payloadLen?: {
          max?: int32(name='Max', description='The maximum length of a packet. Valid values: **0** to **6000**. Unit: bytes.', example='6000'),
          min?: int32(name='Min', description='The minimum length of a packet. Valid values: **0** to **6000**. Unit: bytes.', example='0'),
        }(name='PayloadLen', description='The settings of the Packet Length Limit policy.'),
        persistenceTimeout?: int32(name='PersistenceTimeout', description='The timeout period of session persistence. Valid values: **30** to **3600**. Unit: seconds. Default value: **0**, which indicates that session persistence is disabled.', example='0'),
        sla?: {
          cps?: int32(name='Cps', description='The maximum number of new connections per second that can be established over the port of the destination instance. Valid values: **100** to **100000**.', example='100000'),
          cpsEnable?: int32(name='CpsEnable', description='The status of the Destination New Connection Rate Limit switch. Valid values:

*   **0**: The switch is turned off.
*   **1**: The switch is turned on.', example='1'),
          maxconn?: int32(name='Maxconn', description='The maximum number of concurrent connections that can be established over the port of the destination instance. Valid values: **1000** to **1000000**.', example='1000000'),
          maxconnEnable?: int32(name='MaxconnEnable', description='The status of the Destination Concurrent Connection Rate Limit switch. Valid values:

*   **0**: The switch is turned off.
*   **1**: The switch is turned on.', example='0'),
        }(name='Sla', description='The settings of the Speed Limit for Destination policy.'),
        slimit?: {
          bps?: long(name='Bps', description='The bandwidth limit for a source IP address. Valid values: **1024** to **268435456**. Unit: bytes/s. Default value: **0**, which indicates that the bandwidth for a source IP address is unlimited.', example='0'),
          cps?: int32(name='Cps', description='The maximum number of new connections per second that can be initiated from a source IP address. Valid values: **1** to **500000**.', example='0'),
          cpsEnable?: int32(name='CpsEnable', description='The status of the Source New Connection Rate Limit switch. Valid values:

*   **0**: The switch is turned off.
*   **1**: The switch is turned on.', example='0'),
          cpsMode?: int32(name='CpsMode', description='The mode of the Source New Connection Rate Limit switch. Valid values:

*   **1**: the manual mode
*   **2**: the automatic mode', example='1'),
          maxconn?: int32(name='Maxconn', description='The maximum number of concurrent connections initiated from a source IP address. Valid values: **1** to **500000**.', example='0'),
          maxconnEnable?: int32(name='MaxconnEnable', description='The status of the Source Concurrent Connection Rate Limit switch. Valid values:

*   **0**: The switch is turned off.
*   **1**: The switch is turned on.', example='0'),
          pps?: long(name='Pps', description='The packets per second (pps) limit for a source IP address. Valid values: **1** to **100000**. Unit: packets/s. Default value: **0**, which indicates that the pps for a source IP address is unlimited.', example='0'),
        }(name='Slimit', description='The settings of the Speed Limit for Source policy.'),
        synproxy?: string(name='Synproxy', description='The status of the False Source switch. Valid values:

*   **on**: The switch is turned on.
*   **off**: The switch is turned off.', example='off'),
      }(name='Config', description='The mitigation settings of the port forwarding rule.'),
      frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='8080'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-mp91j1ao****'),
      protocol?: string(name='Protocol', description='The forwarding protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp'),
    }
  ](name='NetworkRuleAttributes', description='An array that consists of the mitigation settings of the port forwarding rule for a non-website service. The mitigation settings include session persistence and DDoS mitigation policies.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F9F2F77D-307C-4F15-8D02-AB5957EEBF97'),
}

model DescribeNetworkRuleAttributesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkRuleAttributesResponseBody(name='body'),
}

async function describeNetworkRuleAttributes(request: DescribeNetworkRuleAttributesRequest): DescribeNetworkRuleAttributesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworkRuleAttributes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeNetworkRulesRequest {
  regionId?: string(name='RegionId', position='Host'),
  forwardProtocol?: string(name='ForwardProtocol', description='The forwarding protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp', position='Query'),
  frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='80', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  pageNumber: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries to return on each page.', example='10', position='Query'),
}

model DescribeNetworkRulesResponseBody = {
  networkRules?: [ 
    {
      backendPort?: int32(name='BackendPort', description='The port of the origin server.', example='80'),
      frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='80'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-mp91j1ao****'),
      isAutoCreate?: boolean(name='IsAutoCreate', description='Indicates whether the port forwarding rule is automatically created. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
      protocol?: string(name='Protocol', description='The forwarding protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp'),
      realServers?: [ string ](name='RealServers', description='An array that consists of IP addresses of origin servers.'),
    }
  ](name='NetworkRules', description='An array that consists of the details of a port forwarding rule.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8597F235-FA5E-4FC7-BAD9-E4C0B01BC771'),
  totalCount?: long(name='TotalCount', description='The total number of returned port forwarding rules.', example='1'),
}

model DescribeNetworkRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeNetworkRulesResponseBody(name='body'),
}

async function describeNetworkRules(request: DescribeNetworkRulesRequest): DescribeNetworkRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeNetworkRules', 'POST', '/', 'json', false, 'json', request);
}

model DescribeOpEntitiesRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.

> The time must be in the latest 30 days.', example='1583683200000', position='Query'),
  entityObject?: string(name='EntityObject', description='The operation object that you want to query.', example='203.***.***.132', position='Query'),
  entityType?: int32(name='EntityType', description='The type of the operation object that you want to query. Valid values:

*   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
*   **2**: Anti-DDoS plans
*   **3**: ECS instances
*   **4**: all logs', example='1', position='Query'),
  pageNumber: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: **50**.', example='10', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.

> The time must be in the latest 30 days.', example='1582992000000', position='Query'),
}

model DescribeOpEntitiesResponseBody = {
  opEntities?: [ 
    {
      entityObject?: string(name='EntityObject', description='The operation object.', example='203.***.***.132'),
      entityType?: int32(name='EntityType', description='The type of the operation object. Valid values:

*   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
*   **2**: Anti-DDoS plans
*   **3**: ECS instances
*   **4**: all logs', example='1'),
      gmtCreate?: long(name='GmtCreate', description='The time when the operation was performed. The value is a UNIX timestamp. Unit: milliseconds.', example='1584451769000'),
      opAccount?: string(name='OpAccount', description='The ID of the Alibaba Cloud account that is used to call the API operation.', example='128965410602****'),
      opAction?: int32(name='OpAction', description='The type of the operation. Valid values:

*   **1**: configuring burstable protection bandwidth.
*   **5**: using Anti-DDoS plans.
*   **8**: changing IP addresses of ECS instances.
*   **9**: deactivating blackhole filtering.
*   **10**: configuring the Diversion from Origin Server policy.
*   **11**: clearing all logs.
*   **12**: downgrading the specifications of instances. If the instance expires or the account has overdue payments, this operation is performed to downgrade the burstable protection bandwidth.
*   **13**: restoring the specifications of instances. If the instance is renewed or you have paid the overdue payments within your account, this operation is performed to restore the burstable protection bandwidth.', example='9'),
      opDesc?: string(name='OpDesc', description='The details of the operation. This parameter is a JSON string. The string contains the following fields:

*   **newEntity**: the values of the parameters after the operation. This field must be of the STRING type.
*   **oldEntity**: the values of the parameters before the operation. This field must be of the STRING type.

Both **newEntity** and **oldEntity** are JSON strings. The returned parameters vary with **OpAtion**.

If **OpAction** is **1**, **12**, or **13**, the following parameter is returned:

*   **elasticBandwidth**: the burstable protection bandwidth. The value is of the INTEGER type.

    For example: `{"newEntity":{"elasticBandwidth":300},"oldEntity":{"elasticBandwidth":300}}`

If **OpAction** is **5**, the following parameters are returned:

*   **bandwidth**: the burstable protection bandwidth. The value is of the INTEGER type. Unit: Gbit/s.

*   **count**: the number of Anti-DDoS plans. The value is of the INTEGER type.

*   **deductCount**: the number of used Anti-DDoS plans. The value is of the INTEGER type.

*   **expireTime**: the expiration time of the Anti-DDoS plans. The value is of the LONG type. The value is a UNIX timestamp. Unit: milliseconds.

*   **instanceId**: the ID of the instance. The value is of the STRING type.

*   **peakFlow**: the peak throughput on the instance. The value is of the INTEGER type. Unit: bit/s.

    For example: `{"newEntity":{"bandwidth":100,"count":4,"deductCount":1,"expireTime":1616299196000,"instanceId":"ddoscoo-cn-v641kpmq****","peakFlow":751427000}}`

If **OpAction** is **8**, the following parameter is returned:

*   **instanceId**: the ID of the ECS instance whose IP address is changed. The value is of the STRING type.

    For example: `{"newEntity":{"instanceId":"i-wz9h6nc313zptbqn****"}}`

If **OpAction** is **9**, the following parameter is returned:

*   **actionMethod**: the operation method. The value is of the STRING type. Valid value: **undo**, which indicates that you deactivated blackhole filtering.

    For example: `{"newEntity":{"actionMethod":"undo"}}`

If **OpAction** is **10**, the following parameters are returned:

*   **actionMethod**: the operation method. The value is of the STRING type. Valid values:

    *   **do**: The Diversion from Origin Server policy is enabled.
    *   **undo**: The Diversion from Origin Server policy is disabled.

*   **lines**: The Internet service provider (ISP) line from which the traffic is blocked. Valid values:

    *   **ct**: China Telecom (International)
    *   **cut**: China Unicom (International)

    For example: `{"newEntity":{"actionMethod":"undo","lines":["ct"]}}`

If **OpAction** is **11**, no parameter is returned, and the description is empty.', example='{"newEntity":{"actionMethod":"undo"}}'),
    }
  ](name='OpEntities', description='An array that consists of the details of the operation log.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='FB24D70C-71F5-4000-8CD8-22CDA0C53CD1'),
  totalCount?: long(name='TotalCount', description='The total number of returned operation records.', example='1'),
}

model DescribeOpEntitiesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeOpEntitiesResponseBody(name='body'),
}

/**
  * > This operation is suitable only for Anti-DDoS Pro.
  * You can query operations performed on Anti-DDoS Pro, such as configuring burstable protection bandwidth, deactivating blackhole filtering, configuring the Diversion from Origin Server policy, using Anti-DDoS plans, changing the IP addresses of Elastic Compute Service (ECS) instances, and clearing all logs.
  *
 */
async function describeOpEntities(request: DescribeOpEntitiesRequest): DescribeOpEntitiesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeOpEntities', 'POST', '/', 'json', false, 'json', request);
}

model DescribePortRequest {
  regionId?: string(name='RegionId', position='Host'),
  frontendPort?: int32(name='FrontendPort', description='The forwarding port to query. Valid values: **0** to **65535**.', example='55', position='Query'),
  frontendProtocol?: string(name='FrontendProtocol', description='The type of the forwarding protocol to query. Valid values:

*   **tcp**
*   **udp**', example='tcp', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the instance to query.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-7e225i41****', position='Query'),
  pageNumber: int32(name='PageNumber', description='The number of the page to return. For example, if you want to obtain results on the first page, set the value to **1**.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries to return on each page.', example='10', position='Query'),
}

model DescribePortResponseBody = {
  networkRules?: [ 
    {
      backendPort?: int32(name='BackendPort', description='The port of the origin server.', example='55'),
      frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='55'),
      frontendProtocol?: string(name='FrontendProtocol', description='The type of the protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp'),
      instanceId?: string(name='InstanceId', description='The ID of the instance to which the port forwarding rule is applied.', example='ddoscoo-cn-7e225i41****'),
      isAutoCreate?: boolean(name='IsAutoCreate', description='Indicates whether the port forwarding rule is automatically created by the instance. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
      realServers?: [ string ](name='RealServers', description='An array that consists of IP addresses of origin servers.'),
    }
  ](name='NetworkRules', description='An array that consists of port forwarding rules.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='39499F01-19D9-4EA4-A0E9-C6014BA5CDBE'),
  totalCount?: long(name='TotalCount', description='The number of port forwarding rules returned.', example='1'),
}

model DescribePortResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePortResponseBody(name='body'),
}

/**
  * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](~~95820~~).
  *
 */
async function describePort(request: DescribePortRequest): DescribePortResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePort', 'POST', '/', 'json', false, 'json', request);
}

model DescribePortAttackMaxFlowRequest {
  regionId?: string(name='RegionId', position='Host'),
  endTime: long(name='EndTime', description='The end of the time range to query. This value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  instanceIds: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances to query.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. This value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribePortAttackMaxFlowResponseBody = {
  bps?: long(name='Bps', description='The peak bandwidth of attack traffic. Unit: bit/s.', example='149559'),
  pps?: long(name='Pps', description='The peak packet rate of attack traffic . Unit: packets per second (pps).', example='23'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DescribePortAttackMaxFlowResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePortAttackMaxFlowResponseBody(name='body'),
}

/**
  * You can call this operation to query the peak bandwidth and peak packet rate of attack traffic on one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describePortAttackMaxFlow(request: DescribePortAttackMaxFlowRequest): DescribePortAttackMaxFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePortAttackMaxFlow', 'POST', '/', 'json', false, 'json', request);
}

model DescribePortAutoCcStatusRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceIds: [ string ](name='InstanceIds', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
}

model DescribePortAutoCcStatusResponseBody = {
  portAutoCcStatus?: [ 
    {
      mode?: string(name='Mode', description='The mode of the Intelligent Protection policy. Valid values:

*   **normal**
*   **loose**
*   **strict**', example='normal'),
      switch?: string(name='Switch', description='The status of the Intelligent Protection policy. Valid values:

*   **on**: enabled
*   **off**: disabled', example='on'),
      webMode?: string(name='WebMode', description='The protection mode for ports 80 and 443. Valid values:

*   **normal**
*   **loose**
*   **strict**', example='normal'),
      webSwitch?: string(name='WebSwitch', description='The status of the Intelligent Protection policy for ports 80 and 443. Valid values:

*   **on**: enabled
*   **off**: disabled', example='off'),
    }
  ](name='PortAutoCcStatus', description='An array that consists of the configurations of the Intelligent Protection policy.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BC3C6403-F248-4125-B2C9-8733ED94EA85'),
}

model DescribePortAutoCcStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePortAutoCcStatusResponseBody(name='body'),
}

async function describePortAutoCcStatus(request: DescribePortAutoCcStatusRequest): DescribePortAutoCcStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePortAutoCcStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribePortConnsCountRequest {
  regionId?: string(name='RegionId', position='Host'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  instanceIds: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  port?: string(name='Port', description='The number of port that you want to query. If you do not specify this parameter, all ports are queried.', example='80', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribePortConnsCountResponseBody = {
  actConns?: long(name='ActConns', description='The number of active connections.', example='159'),
  conns?: long(name='Conns', description='The number of concurrent connections.', example='46340'),
  cps?: long(name='Cps', description='The number of new connections.', example='0'),
  inActConns?: long(name='InActConns', description='The number of inactive connections.', example='121'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='48859E14-A9FB-4100-99FF-AAB75CA46776'),
}

model DescribePortConnsCountResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePortConnsCountResponseBody(name='body'),
}

async function describePortConnsCount(request: DescribePortConnsCountRequest): DescribePortConnsCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePortConnsCount', 'POST', '/', 'json', false, 'json', request);
}

model DescribePortConnsListRequest {
  regionId?: string(name='RegionId', position='Host'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  instanceIds: [ string ](name='InstanceIds', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  interval: int32(name='Interval', description='The interval for returning data. Unit: seconds.', example='1000', position='Query'),
  port?: string(name='Port', description='The number of port that you want to query. If you do not specify this parameter, all ports are queried.', example='80', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribePortConnsListResponseBody = {
  connsList?: [ 
    {
      actConns?: long(name='ActConns', description='The number of active connections.', example='3'),
      conns?: long(name='Conns', description='The number of concurrent connections.', example='8'),
      cps?: long(name='Cps', description='The new connection creation rate.', example='0'),
      inActConns?: long(name='InActConns', description='The number of inactive connections.', example='2'),
      index?: long(name='Index', description='The index number of the returned data.', example='16506'),
    }
  ](name='ConnsList', description='An array that consists of the connections established over the port.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6D48AED0-41DB-5D9B-B484-3B6AAD312AD1'),
}

model DescribePortConnsListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePortConnsListResponseBody(name='body'),
}

async function describePortConnsList(request: DescribePortConnsListRequest): DescribePortConnsListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePortConnsList', 'POST', '/', 'json', false, 'json', request);
}

model DescribePortFlowListRequest {
  regionId?: string(name='RegionId', position='Host'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

**

**This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  instanceIds: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  interval: int32(name='Interval', description='The interval for returning data. Unit: seconds. The interval that you can specify varies based on the time range to query. The time range to query is determined by the values of **StartTime** and **EndTime**.

*   If the time range to query is no greater than 1 hour, we recommend that you specify the interval from 60 seconds to the time range to query.
*   If the time range to query is greater than 1 hour but no greater than 6 hours, we recommend that you specify the interval from 600 seconds to the time range to query.
*   If the time range to query is greater than 6 hours but no greater than 24 hours, we recommend that you specify the interval from 1,800 seconds to the time range to query.
*   If the time range to query is greater than 24 hours but no greater than 7 days, we recommend that you specify the interval from 3,600 seconds to the time range to query.
*   If the time range to query is greater than 7 days but no greater than 15 days, we recommend that you specify the interval from 14,400 seconds to the time range to query.
*   If the time range to query is greater than 15 days, we recommend that you specify the interval from 43,200 seconds to the time range to query.', example='1000', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](~~94485~~).', example='rg-acfm2pz25js****', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

**

**This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribePortFlowListResponseBody = {
  portFlowList?: [ 
    {
      attackBps?: long(name='AttackBps', description='The bandwidth of attack traffic. Unit: bit/s.', example='0'),
      attackPps?: long(name='AttackPps', description='The packet forwarding rate of attack traffic. Unit: pps.', example='0'),
      inBps?: long(name='InBps', description='The inbound bandwidth. Unit: bit/s.', example='2176000'),
      inPps?: long(name='InPps', description='The packet forwarding rate of inbound traffic. Unit: packets per second.', example='2934'),
      index?: long(name='Index', description='The index number of the returned data.', example='0'),
      outBps?: long(name='OutBps', description='The outbound bandwidth. Unit: bit/s.', example='4389'),
      outPps?: long(name='OutPps', description='The packet forwarding rate of outbound traffic. Unit: packets per second (pps).', example='5'),
      region?: string(name='Region', description='The source region of the traffic. Valid values:

*   **cn**: mainland China
*   **alb-ap-northeast-1-gf-x**: Japan (Tokyo)
*   **alb-ap-southeast-gf-x**: Singapore
*   **alb-cn-hongkong-gf-x**: Hong Kong (China)
*   **alb-eu-central-1-gf-x**: Germany (Frankfurt)
*   **alb-us-west-1-gf-x**: US (Silicon Valley)

> The values except **cn** are returned only when **RegionId** is set to **ap-southeast-1**.', example='cn'),
      time?: long(name='Time', description='The time when the data was collected. The value is a UNIX timestamp. Unit: seconds.', example='1582992000'),
    }
  ](name='PortFlowList', description='The returned traffic data.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='FFC77501-BDF8-4BC8-9BF5-B295FBC3189B'),
}

model DescribePortFlowListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePortFlowListResponseBody(name='body'),
}

async function describePortFlowList(request: DescribePortFlowListRequest): DescribePortFlowListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePortFlowList', 'POST', '/', 'json', false, 'json', request);
}

model DescribePortMaxConnsRequest {
  regionId?: string(name='RegionId', position='Host'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  instanceIds: [ string ](name='InstanceIds', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribePortMaxConnsResponseBody = {
  portMaxConns?: [ 
    {
      cps?: long(name='Cps', description='The maximum number of connections per second (CPS).', example='100'),
      ip?: string(name='Ip', description='The IP address of the instance.', example='203.***.***.117'),
      port?: string(name='Port', description='The port of the instance.', example='80'),
    }
  ](name='PortMaxConns', description='An array consisting of the details of the maximum number of connections that are established over a port of the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='08F79110-2AF5-4FA7-998E-7C5E75EACF9C'),
}

model DescribePortMaxConnsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePortMaxConnsResponseBody(name='body'),
}

async function describePortMaxConns(request: DescribePortMaxConnsRequest): DescribePortMaxConnsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePortMaxConns', 'POST', '/', 'json', false, 'json', request);
}

model DescribePortViewSourceCountriesRequest {
  regionId?: string(name='RegionId', position='Host'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  instanceIds: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances to query.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](~~94485~~).', example='rg-acfm2pz25js****', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribePortViewSourceCountriesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  sourceCountrys?: [ 
    {
      count?: long(name='Count', description='The number of requests.', example='3390671'),
      countryId?: string(name='CountryId', description='The abbreviation of the country or area. For example, **cn** indicates China and **us** indicates the United States.

> For more information, see [Location parameters](~~167926~~).', example='cn'),
    }
  ](name='SourceCountrys', description='An array consisting of countries or areas from which the requests are sent.'),
}

model DescribePortViewSourceCountriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePortViewSourceCountriesResponseBody(name='body'),
}

async function describePortViewSourceCountries(request: DescribePortViewSourceCountriesRequest): DescribePortViewSourceCountriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePortViewSourceCountries', 'POST', '/', 'json', false, 'json', request);
}

model DescribePortViewSourceIspsRequest {
  regionId?: string(name='RegionId', position='Host'),
  endTime: long(name='EndTime', description='The end of the time range to query. This value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  instanceIds: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances to query.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. This value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribePortViewSourceIspsResponseBody = {
  isps?: [ 
    {
      count?: long(name='Count', description='The total number of requests that are sent from the ISP.

> This parameter does not indicate the accurate number of requests. You can use this parameter to calculate the proportion of requests from different ISPs.', example='3390671'),
      ispId?: string(name='IspId', description='The ID of the ISP. For more information, see the ISP codes table.', example='100017'),
    }
  ](name='Isps', description='An array that consists of the details of the ISP.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DescribePortViewSourceIspsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePortViewSourceIspsResponseBody(name='body'),
}

/**
  * You can call the DescribePortViewSourceIsps operation to query the ISPs from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
  * > The data returned for this operation cannot reflect the actual traffic volume because Layer 4 identity authentication algorithms are updated for Anti-DDoS Pro and Anti-DDoS Premium. You can call this operation to calculate only the proportion of requests sent from different ISPs. If you want to query the request traffic volume, we recommend that you call the [DescribePortFlowList](~~157460~~) operation.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describePortViewSourceIsps(request: DescribePortViewSourceIspsRequest): DescribePortViewSourceIspsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePortViewSourceIsps', 'POST', '/', 'json', false, 'json', request);
}

model DescribePortViewSourceProvincesRequest {
  regionId?: string(name='RegionId', position='Host'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds. If you do not configure this parameter, the current system time is used as the end time.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200', position='Query'),
  instanceIds: [ string ](name='InstanceIds', description='The IDs of instances to query.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](~~94485~~).', example='rg-acfm2pz25js****', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1582992000', position='Query'),
}

model DescribePortViewSourceProvincesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  sourceProvinces?: [ 
    {
      count?: long(name='Count', description='The total number of requests that are sent from the ISP.

> This parameter does not indicate the accurate number of requests. You can use this parameter to calculate the proportion of requests from different administrative regions in China.', example='3390671'),
      provinceId?: string(name='ProvinceId', description='The ID of the administrative region in China from which the requests are sent. For example, **110000** indicates Beijing, and **120000** indicates Tianjin.

> For more information, see [Location parameters](~~167926~~).', example='440000'),
    }
  ](name='SourceProvinces', description='Details about the administrative region in China from which the requests are sent.'),
}

model DescribePortViewSourceProvincesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePortViewSourceProvincesResponseBody(name='body'),
}

async function describePortViewSourceProvinces(request: DescribePortViewSourceProvincesRequest): DescribePortViewSourceProvincesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePortViewSourceProvinces', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSceneDefenseObjectsRequest {
  regionId?: string(name='RegionId', position='Host'),
  policyId: string(name='PolicyId', description='The ID of the policy that you want to query.

> You can call the [DescribeSceneDefensePolicies](~~159382~~) operation to query the IDs of all policies.', example='47e07ebd-0ba5-4afc-957b-59d15b90****', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
}

model DescribeSceneDefenseObjectsResponseBody = {
  objects?: [ 
    {
      domain?: string(name='Domain', description='The domain name that is protected by the policy.', example='www.aliyundoc.com'),
      policyId?: string(name='PolicyId', description='The ID of the policy.', example='47e07ebd-0ba5-4afc-957b-59d15b90****'),
      vip?: string(name='Vip', description='The IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance that is protected by the policy.', example='203.XX.XX.119'),
    }
  ](name='Objects', description='The information about the protected assets.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='FE07E73F-F19E-4A51-B62F-AC59E3B962D8'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model DescribeSceneDefenseObjectsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSceneDefenseObjectsResponseBody(name='body'),
}

/**
  * You can call the DescribeSceneDefenseObjects operation to query the protected objects of a scenario-specific custom policy.
  * Before you call this operation, make sure that you have created a scenario-specific custom policy by calling the [CreateSceneDefensePolicy](~~159779~~) operation.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeSceneDefenseObjects(request: DescribeSceneDefenseObjectsRequest): DescribeSceneDefenseObjectsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSceneDefenseObjects', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSceneDefensePoliciesRequest {
  regionId?: string(name='RegionId', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
  status?: string(name='Status', description='The status of the policy. Valid values:

*   **0**: disabled
*   **1**: pending enabling
*   **2**: enabled
*   **3**: expired', example='1', position='Query'),
  template?: string(name='Template', description='The type of the template that is used to create the policy. Valid values:

*   **promotion**: the Important Activity template
*   **bypass**: the Forward All template', example='promotion', position='Query'),
}

model DescribeSceneDefensePoliciesResponseBody = {
  policies?: [ 
    {
      done?: int32(name='Done', description='The execution status of the policy. Valid values:

*   **1**: not executed or execution completed
*   **0**: being executed
*   **-1**: execution failed', example='1'),
      endTime?: long(name='EndTime', description='The time at which the policy expires. The value is a UNIX timestamp. Unit: milliseconds.', example='1586016000000'),
      name?: string(name='Name', description='The name of the policy.', example='testpolicy'),
      objectCount?: int32(name='ObjectCount', description='The number of objects that are protected by the policy.', example='1'),
      policyId?: string(name='PolicyId', description='The ID of the policy.', example='321a-fd31-df51-****'),
      runtimePolicies?: [ 
        {
          newValue?: string(name='NewValue', description='The protection rule that is applied when the policy takes effect.

If you set **PolicyType** to **1**, the value is **{"cc_rule_enable": false }**. The value indicates that the Frequency Control policy is disabled.

If you set **PolicyType** to **2**, the value is **{"ai_rule_enable": 0}**. The value indicates that the Intelligent Protection policy is disabled.', example='{"cc_rule_enable": false }'),
          policyType?: int32(name='PolicyType', description='The protection policy whose status is changed when the policy takes effect. Valid values:

*   **1**: indicates that the Frequency Control policy is changed.
*   **2**: indicates that the Intelligent Protection policy is changed.', example='1'),
          status?: int32(name='Status', description='The running status of the policy. Valid values:

*   **0**: The policy has not been issued or is restored.
*   **1**: The policy is pending.
*   **2**: The policy is being restored.
*   **3**: The policy takes effect.
*   **4**: The policy fails to take effect.
*   **5**:The policy fails to be restored.
*   **6**: The configurations of the protected objects for the policy does not exist because the configurations may be deleted.', example='3'),
          oldValue?: string(name='oldValue', description='The protection rule that is applied before the policy takes effect.

If you set **PolicyType** to **1**, the value is **{"cc_rule_enable": true}**. The value indicates that the Frequency Control policy is enabled.

If you set **PolicyType** to **2**, the value is **{"ai_rule_enable": 1}**. The value indicates that the Intelligent Protection policy is enabled.', example='{"cc_rule_enable": true}'),
        }
      ](name='RuntimePolicies', description='The running rules of the policy.'),
      startTime?: long(name='StartTime', description='The time at which the policy takes effect. The value is a UNIX timestamp. Unit: milliseconds.', example='1585670400000'),
      status?: int32(name='Status', description='The status of the policy. Valid values:

*   **0**: disabled
*   **1**: pending enabling
*   **2**: enabled
*   **3**: expired', example='1'),
      template?: string(name='Template', description='The type of the template that is used to create the policy. Valid values:

*   **promotion**: the Important Activity template
*   **bypass**: the Forward All template', example='promotion'),
    }
  ](name='Policies', description='An array that consists of the configurations of the scenario-specific custom policy.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model DescribeSceneDefensePoliciesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSceneDefensePoliciesResponseBody(name='body'),
}

/**
  * You can call the DescribeSceneDefensePolicies operation to query the configurations of a scenario-specific custom policy that is created. For example, you can query the status, protected objects, and protection rules of the policy.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeSceneDefensePolicies(request: DescribeSceneDefensePoliciesRequest): DescribeSceneDefensePoliciesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSceneDefensePolicies', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSchedulerRulesRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries to return on each page.', example='10', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='testrule', position='Query'),
}

model DescribeSchedulerRulesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='11C55595-1757-4B17-9ACE-4ACB68C2D989'),
  schedulerRules?: [ 
    {
      cname?: string(name='Cname', description='The Canonical Name (CNAME) record assigned by Sec-Traffic Manager for the scheduling rule.', example='4eru5229a843****.aliyunddos0001.com'),
      param?: {
        paramData?: {
          cloudInstanceId?: string(name='CloudInstanceId', description='The ID of the GA instance.', example='ga-bp1htlajy5509rc99****'),
        }(name='ParamData', description='The interaction resource.'),
        paramType?: string(name='ParamType', description='The type of the interaction resource. Valid value: **GA**, which indicates that the Global Accelerator instance is used.', example='GA'),
      }(name='Param', description='The scheduling rule for the Global Accelerator instance that interacts with Anti-DDoS Pro or Anti-DDoS Premium.'),
      ruleName?: string(name='RuleName', description='The name of the rule.', example='doctest'),
      ruleType?: string(name='RuleType', description='The type of the rule. Valid values:

*   **2**: tiered protection
*   **3**: network acceleration
*   **5**: Alibaba Cloud CDN (CDN) interaction
*   **6**: cloud service interaction', example='6'),
      rules?: [ 
        {
          priority?: int32(name='Priority', description='The priority of the rule.', example='100'),
          regionId?: string(name='RegionId', description='The ID of the region.

> This parameter is returned only if the **RuleType** parameter is set to **2**.', example='1'),
          restoreDelay?: int32(name='RestoreDelay', description='The waiting time of switching back. Unit: minutes.', example='60'),
          status?: int32(name='Status', description='The status of the scheduling rule. Valid values:

*   **0**: disabled
*   **1**: enabled', example='0'),
          type?: string(name='Type', description='The address type of the interaction resource. Valid values:

*   **A**: IPv4 address
*   **CNAME**: CNAME record', example='A'),
          value?: string(name='Value', description='The address of the interaction resource.', example='203.***.***.39'),
          valueType?: int32(name='ValueType', description='The address type of the interaction resource. Valid values:

*   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
*   **2**: the IP address of the interaction resource in the tiered protection scenario
*   **3**: the IP address that is used to accelerate access in the network acceleration scenario
*   **5**: the domain name that is configured in CDN in the CDN interaction scenario
*   **6** the IP address of the interaction resource in the cloud service interaction scenario', example='1'),
        }
      ](name='Rules', description='An array that consists of the rules.'),
    }
  ](name='SchedulerRules', description='The information about the scheduling rule.'),
  totalCount?: string(name='TotalCount', description='The total number of returned scheduling rules.', example='1'),
}

model DescribeSchedulerRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSchedulerRulesResponseBody(name='body'),
}

async function describeSchedulerRules(request: DescribeSchedulerRulesRequest): DescribeSchedulerRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSchedulerRules', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSlsAuthStatusRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeSlsAuthStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
  slsAuthStatus?: boolean(name='SlsAuthStatus', description='Indicates whether Anti-DDoS Pro or Anti-DDoS Premium is authorized to access Log Service. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model DescribeSlsAuthStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSlsAuthStatusResponseBody(name='body'),
}

async function describeSlsAuthStatus(request: DescribeSlsAuthStatusRequest): DescribeSlsAuthStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSlsAuthStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSlsLogstoreInfoRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeSlsLogstoreInfoResponseBody = {
  logStore?: string(name='LogStore', description='The Logstore of the Anti-DDoS Pro or Anti-DDoS Premium instance.', example='ddoscoo-logstore'),
  project?: string(name='Project', description='The Logstore project of the Anti-DDoS Pro or Anti-DDoS Premium instance.', example='ddoscoo-project-181071506993****-cn-hangzhou'),
  quota?: long(name='Quota', description='The available log storage capacity. Unit: bytes.', example='3298534883328'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
  ttl?: int32(name='Ttl', description='The log storage duration. Unit: days.', example='180'),
  used?: long(name='Used', description='The used log storage capacity. Unit: bytes.

> The statistics on Log Service are delayed for about two hours.', example='0'),
}

model DescribeSlsLogstoreInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSlsLogstoreInfoResponseBody(name='body'),
}

async function describeSlsLogstoreInfo(request: DescribeSlsLogstoreInfoRequest): DescribeSlsLogstoreInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSlsLogstoreInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSlsOpenStatusRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeSlsOpenStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
  slsOpenStatus?: boolean(name='SlsOpenStatus', description='Indicates whether Log Service is activated. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model DescribeSlsOpenStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSlsOpenStatusResponseBody(name='body'),
}

async function describeSlsOpenStatus(request: DescribeSlsOpenStatusRequest): DescribeSlsOpenStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSlsOpenStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeStsGrantStatusRequest {
  regionId?: string(name='RegionId', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
  role: string(name='Role', description='The name of the RAM role to query. Set the value to **AliyunDDoSCOODefaultRole**, which indicates the default role of Anti-DDoS Pro or Anti-DDoS Premium.

> Anti-DDoS Pro or Anti-DDoS Premium uses the default role to access other cloud services.', example='AliyunDDoSCOODefaultRole', position='Query'),
}

model DescribeStsGrantStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
  stsGrant?: {
    status?: int32(name='Status', description='The authorization status. Valid values:

*   **0**: Anti-DDoS Pro or Anti-DDoS Premium is not authorized to access other cloud services.
*   **1**: Anti-DDoS Pro or Anti-DDoS Premium is authorized to access other cloud services.', example='1'),
  }(name='StsGrant', description='The authorization status of Anti-DDoS Pro or Anti-DDoS Premium.'),
}

model DescribeStsGrantStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeStsGrantStatusResponseBody(name='body'),
}

/**
  * You can call the DescribeStsGrantStatus operation to query whether Anti-DDoS Pro or Anti-DDoS Premium of the current Alibaba Cloud account is authorized to access other cloud services.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeStsGrantStatus(request: DescribeStsGrantStatusRequest): DescribeStsGrantStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeStsGrantStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSystemLogRequest {
  regionId?: string(name='RegionId', position='Host'),
  endTime: long(name='EndTime', description='The end of the time range to query. The bills of the burstable clean bandwidth that are issued before this point in time are queried. The value is a UNIX timestamp. Unit: milliseconds.', example='1640966400000', position='Query'),
  entityObject?: string(name='EntityObject', description='The IP address of the instance.

> You can call the [DescribeInstanceDetails](~~91490~~) operation to query the IP addresses of all instances.', example='203.107.XX.XX', position='Query'),
  entityType?: int32(name='EntityType', description='The type of the system log. Set the value to **20**, which indicates the billing logs for the burstable clean bandwidth.

> You must specify this parameter. Otherwise, the call fails.', example='20', position='Query'),
  pageNumber: int32(name='PageNumber', description='The number of the page to return.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries to return on each page.', example='10', position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The bills of the burstable clean bandwidth that are issued after this point in time are queried. The value is a UNIX timestamp. Unit: milliseconds.', example='1609430400000', position='Query'),
}

model DescribeSystemLogResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='8BC3A33A-F832-58DB-952F-7682A25AD14C'),
  systemLog?: [ 
    {
      entityObject?: string(name='EntityObject', description='The IP address of the instance.', example='203.107.XX.XX'),
      entityType?: int32(name='EntityType', description='The type of the system log. The value is fixed as **20**, which indicates the billing logs for burstable clean bandwidth.', example='20'),
      gmtCreate?: long(name='GmtCreate', description='The time when the bill was generated. The value is a UNIX timestamp. Unit: milliseconds.', example='1631793531000'),
      gmtModified?: long(name='GmtModified', description='The time when the bill was last modified. The value is a UNIX timestamp. Unit: milliseconds.', example='1635425407000'),
      opAccount?: string(name='OpAccount', description='The ID of the Alibaba Cloud account to which the bill belongs.', example='171986973287****'),
      opAction?: int32(name='OpAction', description='The operation type. The value is fixed as **100**, which indicates the billing logs for the burstable clean bandwidth that you increased.', example='100'),
      opDesc?: string(name='OpDesc', description='The details of the bill. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:

*   **newEntity**: the bill record, which contains the following fields. Data type: object.

    *   **billValue**: the usage of the burstable clean bandwidth within a month. Unit: Mbit/s. Data type: integer.
    *   **instanceId**: the ID of the instance. Data type: string.
    *   **ip**: the IP address of the instance. Data type: string.
    *   **maxBw**: the peak service traffic (monthly 95th percentile bandwidth) within a month. Unit: Mbit/s. Data type: string.
    *   **month**: the month in which the bill of the previous calendar month is issued. This value is a UNIX timestamp. Unit: milliseconds. Data type: long.
    *   **overBandwidth**: the peak service traffic minus the clean bandwidth of the instance. Unit: Mbit/s. Data type: integer.
    *   **peakTime**: the time in point of the peak service traffic that is measured for billing. This value is a UNIX timestamp. Unit: seconds. Data type: long.
    *   **startTimestamp**: the beginning of the time range for the peak service traffic range. This value is a UNIX timestamp. Unit: seconds. Data type: long.', example='{"newEntity":{"billValue":"60","instanceId":"ddoscoo-cn-zz121ogz****","ip":"203.107.XX.XX","maxBw":"300","month":1627747200000,"overBandwidth":"120","peakTime":1629871200,"startTimestamp":1629871200}}'),
      status?: int32(name='Status', description='The status of the bill. Valid values:

*   **0**: to be billed
*   **1**: billed
*   **2**: terminated', example='1'),
    }
  ](name='SystemLog', description='An array that consists of details of the billing logs for the burstable clean bandwidth.'),
  total?: long(name='Total', description='The total number of billing logs for the burstable clean bandwidth.', example='1'),
}

model DescribeSystemLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSystemLogResponseBody(name='body'),
}

/**
  * You can call the DescribeSystemLog operation to query the system logs of Anti-DDoS Pro or Anti-DDoS Premium. The system logs contain only billing logs for the burstable clean bandwidth.
  * If you have enabled the burstable clean bandwidth feature, you can call this operation to query the details of the bills of the burstable clean bandwidth.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeSystemLog(request: DescribeSystemLogRequest): DescribeSystemLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSystemLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTagKeysRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**.', example='10', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the instance. Set the value to **cn-hangzhou**, which indicates an Anti-DDoS Pro instance in the Chinese mainland.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.', example='INSTANCE', position='Query'),
}

model DescribeTagKeysResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned on each page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
  tagKeys?: [ 
    {
      tagCount?: int32(name='TagCount', description='The number of Anti-DDoS Pro instances to which the tag key is added.', example='2'),
      tagKey?: string(name='TagKey', description='The tag key.', example='aa1'),
    }
  ](name='TagKeys', description='An array that consists of the details of the tag key.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeTagKeysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTagKeysResponseBody(name='body'),
}

/**
  * You can call this operation to query all tag keys and the Anti-DDoS Pro instances to which the tag keys are added by page.
  * > The tag feature is suitable only for Anti-DDoS Pro.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeTagKeys(request: DescribeTagKeysRequest): DescribeTagKeysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTagKeys', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The query token. Set the value to the value of **NextToken** that is returned in the last call.

> You do not need to configure this parameter if you call this operation for the first time.', example='RGuYpqDdKhzXb8C3.D1BwQgc1tMBsoxdGiEKHHUUCf****', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the instance. Set the value to **cn-hangzhou**, which indicates an Anti-DDoS Pro instance in the Chinese mainland.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
  resourceIds?: [ string ](name='ResourceIds', description='An array consisting of IDs of the Anti-DDoS Pro instances that you want to query.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  resourceType: string(name='ResourceType', description='The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.', example='INSTANCE', position='Query'),
  tags?: [ 
    {
      key?: string(name='Key', description='The key of the tag that you want to query.

> 

*   You must specify at least one of the **ResourceIds.N** and **Tags.N.Key** parameters.

*   You can call the [DescribeTagKeys](~~159785~~) operation to query all tag keys.', example='testkey'),
      value?: string(name='Value', description='The value of the tag that you want to query.', example='testvalue'),
    }
  ](name='Tags', description='An array consisting of tags that you want to query. Each tag consists of a tag **key** and a tag **value**.', position='Query'),
}

model DescribeTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The query token that is returned in this call.', example='RGuYpqDdKhzXb8C3.D1BwQgc1tMBsoxdGiEKHHUUCf****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='36E698F7-48A4-48D0-9554-0BB4BAAB99B3'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId', description='The ID of the Anti-DDoS Pro instance.', example='ddoscoo-cn-zz121ogz****'),
      resourceType?: string(name='ResourceType', description='The type of the resource. The value is fixed as **INSTANCE**, which indicates an Anti-DDoS Pro instance.', example='INSTANCE'),
      tagKey?: string(name='TagKey', description='The key of the tag that is added to the Anti-DDoS Pro instance.', example='testvalue'),
      tagValue?: string(name='TagValue', description='The value of the tag that is added to the Anti-DDoS Pro instance.', example='testkey'),
    }
  ](name='TagResource')
  }(name='TagResources', description='An array consisting of the details of the tags that are added to the Anti-DDoS Pro instance.'),
}

model DescribeTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTagResourcesResponseBody(name='body'),
}

/**
  * You can call the DescribeTagResources operation to query the information about the tags that are added to an Anti-DDoS Pro instance.
  * > Only Anti-DDoS Pro supports tags.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeTagResources(request: DescribeTagResourcesRequest): DescribeTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTagResources', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUdpReflectRequest {
  instanceId: string(name='InstanceId', description='The ID of the instance to query.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-i7m25564****', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the instance. Valid values:

*   **cn-hangzhou**: Chinese mainland, which indicates an Anti-DDoS Pro instance. This is the default value.
*   **ap-southeast-1**: outside the Chinese mainland, which indicates an Anti-DDoS Premium instance.', example='cn-hangzhou', position='Query'),
}

model DescribeUdpReflectResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F97A8766-FB4D-411A-9CD5-2CFF701B592F'),
  udpSports?: [ string ](name='UdpSports', description='An array consisting of the source ports of the UDP traffic that are filtered out by the filtering policies for UDP reflection attacks.'),
}

model DescribeUdpReflectResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUdpReflectResponseBody(name='body'),
}

async function describeUdpReflect(request: DescribeUdpReflectRequest): DescribeUdpReflectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUdpReflect', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUnBlackholeCountRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeUnBlackholeCountResponseBody = {
  remainCount?: int32(name='RemainCount', description='The remaining quota that you can deactivate blackhole filtering.', example='5'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='232929FA-40B6-4C53-9476-EE335ABA44CD'),
  totalCount?: int32(name='TotalCount', description='The total quota that you can deactivate blackhole filtering.', example='5'),
}

model DescribeUnBlackholeCountResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUnBlackholeCountResponseBody(name='body'),
}

async function describeUnBlackholeCount(request: DescribeUnBlackholeCountRequest): DescribeUnBlackholeCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUnBlackholeCount', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUnBlockCountRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeUnBlockCountResponseBody = {
  remainCount?: int32(name='RemainCount', description='The remaining quota that you can use the Diversion from Origin Server policy.', example='7'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  totalCount?: int32(name='TotalCount', description='The total quota that you can use the Diversion from Origin Server policy.', example='10'),
}

model DescribeUnBlockCountResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUnBlockCountResponseBody(name='body'),
}

/**
  * > This operation is suitable only for Anti-DDoS Pro.
  *
 */
async function describeUnBlockCount(request: DescribeUnBlockCountRequest): DescribeUnBlockCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUnBlockCount', 'POST', '/', 'json', false, 'json', request);
}

model DescribeWebAccessLogDispatchStatusRequest {
  regionId?: string(name='RegionId', position='Host'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**.', example='10', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
}

model DescribeWebAccessLogDispatchStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
  slsConfigStatus?: [ 
    {
      domain?: string(name='Domain', description='The domain name.', example='www.aliyundoc.com'),
      enable?: boolean(name='Enable', description='Indicates whether the log analysis feature is enabled. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
    }
  ](name='SlsConfigStatus', description='Indicates whether the log analysis feature is enabled for domain names.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeWebAccessLogDispatchStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeWebAccessLogDispatchStatusResponseBody(name='body'),
}

/**
  * You can call the DescribeWebAccessLogDispatchStatus operation to check whether the log analysis feature is enabled for all domain names that are added to your Anti-DDoS Pro or Anti-DDoS Premium instance.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeWebAccessLogDispatchStatus(request: DescribeWebAccessLogDispatchStatusRequest): DescribeWebAccessLogDispatchStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeWebAccessLogDispatchStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeWebAccessLogEmptyCountRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeWebAccessLogEmptyCountResponseBody = {
  availableCount?: int32(name='AvailableCount', description='The remaining quota that you can clear the Logstore.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model DescribeWebAccessLogEmptyCountResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeWebAccessLogEmptyCountResponseBody(name='body'),
}

async function describeWebAccessLogEmptyCount(request: DescribeWebAccessLogEmptyCountRequest): DescribeWebAccessLogEmptyCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeWebAccessLogEmptyCount', 'POST', '/', 'json', false, 'json', request);
}

model DescribeWebAccessLogStatusRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeWebAccessLogStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
  slsLogstore?: string(name='SlsLogstore', description='The Logstore of the instance.', example='ddoscoo-logstore'),
  slsProject?: string(name='SlsProject', description='The Log Service project of the instance.', example='ddoscoo-project-128965410602****-cn-hangzhou'),
  slsStatus?: boolean(name='SlsStatus', description='Indicates whether the Log Analysis feature is enabled for the website. Valid values:

*   **true**: enabled
*   **false**: disabled', example='true'),
}

model DescribeWebAccessLogStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeWebAccessLogStatusResponseBody(name='body'),
}

async function describeWebAccessLogStatus(request: DescribeWebAccessLogStatusRequest): DescribeWebAccessLogStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeWebAccessLogStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeWebAccessModeRequest {
  regionId?: string(name='RegionId', position='Host'),
  domains: [ string ](name='Domains', description='The domain name of the website.

> A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
}

model DescribeWebAccessModeResponseBody = {
  domainModes?: [ 
    {
      accessMode?: int32(name='AccessMode', description='The mode in which the website service is added. Valid values:

*   **0**: A record
*   **1**: anti-DDoS mode
*   **2**: origin redundancy mode', example='0'),
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
    }
  ](name='DomainModes', description='An array consisting of the modes in which the website service is added.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DescribeWebAccessModeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeWebAccessModeResponseBody(name='body'),
}

async function describeWebAccessMode(request: DescribeWebAccessModeRequest): DescribeWebAccessModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeWebAccessMode', 'POST', '/', 'json', false, 'json', request);
}

model DescribeWebAreaBlockConfigsRequest {
  regionId?: string(name='RegionId', position='Host'),
  domains: [ string ](name='Domains', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeWebAreaBlockConfigsResponseBody = {
  areaBlockConfigs?: [ 
    {
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
      regionList?: [ 
        {
          block?: int32(name='Block', description='Indicates whether the location is blocked. Valid values:

*   **0**: yes
*   **1**: no', example='0'),
          region?: string(name='Region', description='The name of the location.', example='CN-SHANGHAI'),
        }
      ](name='RegionList', description='The configuration of the blocked locations.'),
    }
  ](name='AreaBlockConfigs', description='An array that consists of the configurations of the Location Blacklist (Domain Names) policy.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DescribeWebAreaBlockConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeWebAreaBlockConfigsResponseBody(name='body'),
}

async function describeWebAreaBlockConfigs(request: DescribeWebAreaBlockConfigsRequest): DescribeWebAreaBlockConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeWebAreaBlockConfigs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeWebCCRulesRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.', example='1', position='Query'),
  pageSize: string(name='PageSize', description='The number of entries to return on each page.', example='10', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeWebCCRulesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='EAED912D-909E-45F0-AF74-AC0CCDCAE314'),
  totalCount?: long(name='TotalCount', description='The total number of returned custom frequency control rules.', example='1'),
  webCCRules?: [ 
    {
      act?: string(name='Act', description='The blocking type. Valid values:

*   **close**: blocks requests.
*   **captcha**: enables Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) verification.', example='close'),
      count?: int32(name='Count', description='The number of requests that are allowed from an individual IP address. Valid values: **2** to **2000**.', example='3'),
      interval?: int32(name='Interval', description='The check intervals. Valid values: **5** to **10800**. Unit: seconds.', example='5'),
      mode?: string(name='Mode', description='The match mode. Valid values:

*   **prefix**: prefix match
*   **match**: exact match', example='prefix'),
      name?: string(name='Name', description='The name of the rule.', example='wq'),
      ttl?: int32(name='Ttl', description='The blocking duration. Valid values: **1** to **1440**. Unit: minutes.', example='60'),
      uri?: string(name='Uri', description='The check path.', example='/hello'),
    }
  ](name='WebCCRules', description='An array that consists of the details of the custom frequency control rule.'),
}

model DescribeWebCCRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeWebCCRulesResponseBody(name='body'),
}

async function describeWebCCRules(request: DescribeWebCCRulesRequest): DescribeWebCCRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeWebCCRules', 'POST', '/', 'json', false, 'json', request);
}

model DescribeWebCacheConfigsRequest {
  regionId?: string(name='RegionId', position='Host'),
  domains: [ string ](name='Domains', description='An array consisting of domain names for which you want to query the Static Page Caching configurations.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
}

model DescribeWebCacheConfigsResponseBody = {
  domainCacheConfigs?: [ 
    {
      customRules?: [ 
        {
          cacheTtl?: long(name='CacheTtl', description='The expiration time of the page cache. Unit: seconds.', example='86400'),
          mode?: string(name='Mode', description='The cache mode. Valid values:

*   **standard**: The standard cache mode is used.
*   **aggressive**: The enhanced cache mode is used.
*   **bypass**: No data is cached.', example='standard'),
          name?: string(name='Name', description='The name of the rule.', example='c1'),
          uri?: string(name='Uri', description='The path to the cached page.', example='/blog/'),
        }
      ](name='CustomRules', description='An array that consists of custom caching rules.'),
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyundoc.com'),
      enable?: int32(name='Enable', description='The status of the Static Page Caching policy. Valid values:

*   **1**: enabled
*   **0**: disabled', example='1'),
      mode?: string(name='Mode', description='The cache mode. Valid values:

*   **standard**: The standard cache mode is used.
*   **aggressive**: The enhanced cache mode is used.
*   **bypass**: No data is cached.', example='bypass'),
    }
  ](name='DomainCacheConfigs', description='An array that consists of Static Page Caching configurations.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
}

model DescribeWebCacheConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeWebCacheConfigsResponseBody(name='body'),
}

/**
  * You can call the DescribeWebCacheConfigs operation to query the Static Page Caching configurations of websites. The configurations include cache modes and custom caching rules.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeWebCacheConfigs(request: DescribeWebCacheConfigsRequest): DescribeWebCacheConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeWebCacheConfigs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeWebCcProtectSwitchRequest {
  regionId?: string(name='RegionId', position='Host'),
  domains: [ string ](name='Domains', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeWebCcProtectSwitchResponseBody = {
  protectSwitchList?: [ 
    {
      aiMode?: string(name='AiMode', description='The mode of the Intelligent Protection policy. Valid values:

*   **watch**: the Warning mode
*   **defense**: the Defense mode', example='defense'),
      aiRuleEnable?: int32(name='AiRuleEnable', description='The status of the Intelligent Protection policy. Valid values:

*   **0**: disabled
*   **1**: enabled', example='1'),
      aiTemplate?: string(name='AiTemplate', description='The level of the Intelligent Protection policy. Valid values:

*   **level30**: the Low level
*   **level60**: the Normal level
*   **level90**: the Strict level', example='level60'),
      blackWhiteListEnable?: int32(name='BlackWhiteListEnable', description='The status of the Black Lists and White Lists (Domain Names) policy. Valid values:

*   **0**: disabled
*   **1**: enabled', example='1'),
      ccCustomRuleEnable?: int32(name='CcCustomRuleEnable', description='The status of the Custom Rule switch for the Frequency Control policy. Valid values:

*   **0**: disabled
*   **1**: enabled', example='0'),
      ccEnable?: int32(name='CcEnable', description='The status of the Frequency Control policy. Valid values:

*   **0**: disabled
*   **1**: enabled', example='1'),
      ccTemplate?: string(name='CcTemplate', description='The mode of the Frequency Control policy. Valid values:

*   **default**: Normal
*   **gf_under_attack**: Emergency
*   **gf_sos_verify**: Strict
*   **gf_sos_enhance**: Super Strict', example='default'),
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
      preciseRuleEnable?: int32(name='PreciseRuleEnable', description='The status of the Accurate Access Control policy. Valid values:

*   **0**: disabled
*   **1**: enabled', example='0'),
      regionBlockEnable?: int32(name='RegionBlockEnable', description='The status of the Location Blacklist (Domain Names) policy. Valid values:

*   **0**: disabled
*   **1**: enabled', example='0'),
    }
  ](name='ProtectSwitchList', description='The status of each protection policy for a website.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3ADD9EED-CA4B-488C-BC82-01B0B899363D'),
}

model DescribeWebCcProtectSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeWebCcProtectSwitchResponseBody(name='body'),
}

async function describeWebCcProtectSwitch(request: DescribeWebCcProtectSwitchRequest): DescribeWebCcProtectSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeWebCcProtectSwitch', 'POST', '/', 'json', false, 'json', request);
}

model DescribeWebCustomPortsRequest {
  regionId?: string(name='RegionId', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeWebCustomPortsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
  webCustomPorts?: [ 
    {
      proxyPorts?: [ string ](name='ProxyPorts', description='An array that consists of supported custom ports.'),
      proxyType?: string(name='ProxyType', description='The type of the protocol. Valid values:

*   **http**
*   **https**', example='http'),
    }
  ](name='WebCustomPorts', description='An array consisting of information about supported custom ports that are used by a website.'),
}

model DescribeWebCustomPortsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeWebCustomPortsResponseBody(name='body'),
}

async function describeWebCustomPorts(request: DescribeWebCustomPortsRequest): DescribeWebCustomPortsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeWebCustomPorts', 'POST', '/', 'json', false, 'json', request);
}

model DescribeWebInstanceRelationsRequest {
  regionId?: string(name='RegionId', position='Host'),
  domains: [ string ](name='Domains', description='The domain names of the website. list

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeWebInstanceRelationsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0222382B-5FE5-4FF7-BC9B-97EE31D58818'),
  webInstanceRelations?: [ 
    {
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
      instanceDetails?: [ 
        {
          eipList?: [ string ](name='EipList', description='The IP addresses of the instance.'),
          functionVersion?: string(name='FunctionVersion', description='The function plan of the instance. Valid values:

*   **default**: Standard function plan
*   **enhance**: Enhanced function plan', example='enhance'),
          instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-0pp163pd****'),
        }
      ](name='InstanceDetails', description='The information about the instance to which a website service is added.'),
    }
  ](name='WebInstanceRelations', description='The information about the instances to which a website service is added.'),
}

model DescribeWebInstanceRelationsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeWebInstanceRelationsResponseBody(name='body'),
}

async function describeWebInstanceRelations(request: DescribeWebInstanceRelationsRequest): DescribeWebInstanceRelationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeWebInstanceRelations', 'POST', '/', 'json', false, 'json', request);
}

model DescribeWebPreciseAccessRuleRequest {
  regionId?: string(name='RegionId', position='Host'),
  domains: [ string ](name='Domains', description='An array that consists of the domain names of websites.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DescribeWebPreciseAccessRuleResponseBody = {
  preciseAccessConfigList?: [ 
    {
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
      ruleList?: [ 
        {
          action?: string(name='Action', description='The action triggered if the rule is matched. Valid values:

*   **accept**: allows the requests that match the rule.
*   **block**: blocks the requests that match the rule.
*   **challenge**: implements Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) verification for the requests that match the rule.', example='accept'),
          conditionList?: [ 
            {
              content?: string(name='Content', description='The match content.', example='1.1.1.1'),
              field?: string(name='Field', description='The match field.', example='ip'),
              headerName?: string(name='HeaderName', description='The custom HTTP header.

> This parameter takes effect only when **Field** is set to **header**.', example='null'),
              matchMethod?: string(name='MatchMethod', description='The logical operator.', example='belong'),
            }
          ](name='ConditionList', description='The match conditions.'),
          expires?: long(name='Expires', description='The validity period of the rule. Unit: seconds. This parameter takes effect only when **action** of a rule is **block**. Access requests that match the rule are blocked within the specified validity period of the rule. **0** indicates that the rule takes effect all the time.', example='0'),
          name?: string(name='Name', description='The name of the rule.', example='testrule'),
          owner?: string(name='Owner', description='The source of the rule. Valid values:

*   **manual**: manually created. This is the default value.
*   **auto**: automatically generated.', example='manual'),
        }
      ](name='RuleList', description='An array that consists of the rules.'),
    }
  ](name='PreciseAccessConfigList', description='An array consisting of the configuration of the accurate access control rule that is created for the website.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='209EEFBF-B0C7-441E-8C28-D0945A57A638'),
}

model DescribeWebPreciseAccessRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeWebPreciseAccessRuleResponseBody(name='body'),
}

async function describeWebPreciseAccessRule(request: DescribeWebPreciseAccessRuleRequest): DescribeWebPreciseAccessRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeWebPreciseAccessRule', 'POST', '/', 'json', false, 'json', request);
}

model DescribeWebRulesRequest {
  regionId?: string(name='RegionId', position='Host'),
  cname?: string(name='Cname', description='The CNAME to query.', example='kzmk7b8tt351****.aliyunddos1014****', minLength=3, maxLength=128, position='Query'),
  domain?: string(name='Domain', description='The domain name of the website that you want to query.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query the domain names for which forwarding rules are configured.', example='example.com', position='Query'),
  instanceIds?: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances to query.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Default value: **1**.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries to return on each page.', example='10', position='Query'),
  queryDomainPattern?: string(name='QueryDomainPattern', description='The match mode. Valid values:

*   **fuzzy**: fuzzy match. This is the default value.
*   **exact**: exact match.', example='exact', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
}

model DescribeWebRulesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0F5B72DD-96F4-423A-B12B-A5151DD746B8'),
  totalCount?: long(name='TotalCount', description='The total number of forwarding rules.', example='1'),
  webRules?: [ 
    {
      blackList?: [ string ](name='BlackList', description='An array that consists of the IP addresses in the blacklist for the domain name.'),
      ccEnabled?: boolean(name='CcEnabled', description='Indicates whether the Frequency Control policy is enabled. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
      ccRuleEnabled?: boolean(name='CcRuleEnabled', description='Indicates whether the Custom Rule switch of the Frequency Control policy is turned on. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
      ccTemplate?: string(name='CcTemplate', description='The mode of the Frequency Control policy. Valid values:

*   **default**: the Normal mode
*   **gf_under_attack**: the Emergency mode
*   **gf_sos_verify**: the Strict mode
*   **gf_sos_verify**: the Super Strict mode', example='default'),
      certName?: string(name='CertName', description='The name of the certificate.', example='testcert'),
      cname?: string(name='Cname', description='The CNAME provided by the Anti-DDoS Pro or Anti-DDoS Premium instance to which the domain name is added.', example='kzmk7b8tt351****.aliyunddos1014****'),
      customCiphers?: [ string ](name='CustomCiphers', description='An array that consists of custom cipher suites.'),
      domain?: string(name='Domain', description='The domain name of the website.', example='example.com'),
      gmCert?: {
        certId?: string(name='CertId', description='The ID of the SM certificate.', example='725****'),
        gmEnable?: long(name='GmEnable', description='Indicates whether Enable SM Certificate-based Verification is turned on.

*   0: no
*   1: yes', example='1'),
        gmOnly?: long(name='GmOnly', description='Indicates whether Allow Access Only from SM Certificates-based Clients is turned on.

*   0: no
*   1: yes', example='1'),
      }(name='GmCert', description='The SM certificate settings.'),
      http2Enable?: boolean(name='Http2Enable', description='Indicates whether Enable HTTP/2 is turned on. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
      http2HttpsEnable?: boolean(name='Http2HttpsEnable', description='Indicates whether Enable HTTPS Routing is turned on. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
      https2HttpEnable?: boolean(name='Https2HttpEnable', description='Indicates whether Enable HTTP is turned on. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
      ocspEnabled?: boolean(name='OcspEnabled', description='Indicates whether the Online Certificate Status Protocol (OCSP) feature is enabled. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
      policyMode?: string(name='PolicyMode', description='The scheduling algorithm for back-to-origin traffic. Valid values:

*   **ip_hash**: the IP hash algorithm. This algorithm is used to redirect the requests from the same IP address to the same origin server.
*   **rr**: the round-robin algorithm. This algorithm is used to redirect requests to origin servers in turn.
*   **least_time**: the least response time algorithm. This algorithm is used to minimize the latency when requests are forwarded from Anti-DDoS Pro or Anti-DDoS Premium instances to origin servers based on the intelligent DNS resolution feature.', example='ip_hash'),
      proxyEnabled?: boolean(name='ProxyEnabled', description='Indicates whether the forwarding rule is enabled. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
      proxyTypes?: [ 
        {
          proxyPorts?: [ string ](name='ProxyPorts', description='An array that consists of ports.'),
          proxyType?: string(name='ProxyType', description='The type of the protocol. Valid values:

*   **http**
*   **https**
*   **websocket**
*   **websockets**', example='https'),
        }
      ](name='ProxyTypes', description='An array that consists of the details of the protocol type and port number.'),
      punishReason?: int32(name='PunishReason', description='The reason why the domain name is invalid. Valid values:

*   **1**: No ICP filing is completed for the domain name.
*   **2**: The business for which you registered the domain name does not meet regulatory requirements.

If the two reasons are both involved, the value **2** is returned.', example='1'),
      punishStatus?: boolean(name='PunishStatus', description='Indicates whether the domain name is invalid. Valid values:

*   **true**: The domain name is invalid. You can view the specific reasons from the **PunishReason** parameter.
*   **false**: The domain name is valid.', example='true'),
      realServers?: [ 
        {
          realServer?: string(name='RealServer', description='The address of the origin server.', example='192.0.XX.XX'),
          rsType?: int32(name='RsType', description='The type of the origin server address. Valid values:

*   **0**: IP address
*   **1**: domain name The domain name of the origin server is returned if you deploy proxies, such as Web Application Firewall (WAF), between the origin server and the instance. In this case, the address of the proxy, such as the CNAME provided by WAF, is returned.', example='0'),
        }
      ](name='RealServers', description='An array that consists of the details of the origin server address.'),
      ssl13Enabled?: boolean(name='Ssl13Enabled', description='Indicates whether TLS 1.3 is supported. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
      sslCiphers?: string(name='SslCiphers', description='The type of the cipher suite. Valid values:

*   **default**: custom cipher suite
*   **all**: all cipher suites, which contain strong and weak cipher suites
*   **strong**: strong cipher suites', example='default'),
      sslProtocols?: string(name='SslProtocols', description='The version of the Transport Layer Security (TLS) protocol. Valid values:

*   **tls1.0**: TLS 1.0 or later
*   **tls1.1**: TLS 1.1 or later
*   **tls1.2**: TLS 1.2 or later', example='tls1.1'),
      whiteList?: [ string ](name='WhiteList', description='An array that consists of the IP addresses in the whitelist for the domain name.'),
    }
  ](name='WebRules', description='An array that consists of the configurations of the forwarding rule.'),
}

model DescribeWebRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeWebRulesResponseBody(name='body'),
}

/**
  * You can call the DescribeWebRules operation to query the configurations of the forwarding rules that you create for a website by page. The configurations include the protocol type, origin server address, HTTPS configuration, and IP address blacklist.
  * Before you call this operation, you must have created forwarding rules by calling the [CreateWebRule](~~157463~~) operation.
  * ### Limits
  * You can call this operation up to 50 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function describeWebRules(request: DescribeWebRulesRequest): DescribeWebRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeWebRules', 'POST', '/', 'json', false, 'json', request);
}

model DetachSceneDefenseObjectRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  objectType?: string(name='ObjectType', description='The type of the object. Set the value to **Domain**, which indicates a domain name.', example='Domain', position='Query'),
  objects: string(name='Objects', description='The protection asset that you want to remove from a policy. Separate multiple protection assets with commas (,).', example='www.aliyun.com', position='Query'),
  policyId: string(name='PolicyId', description='The ID of the policy.

> You can call the [DescribeSceneDefensePolicies](~~159382~~) operation to query the IDs of all policies.', example='321a-fd31-df51-****', position='Query'),
}

model DetachSceneDefenseObjectResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model DetachSceneDefenseObjectResponse = {
  headers: map[string]string(name='headers'),
  body: DetachSceneDefenseObjectResponseBody(name='body'),
}

async function detachSceneDefenseObject(request: DetachSceneDefenseObjectRequest): DetachSceneDefenseObjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachSceneDefenseObject', 'POST', '/', 'json', false, 'json', request);
}

model DisableSceneDefensePolicyRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  policyId: string(name='PolicyId', description='The ID of the policy that you want to disable.

> You can call the [DescribeSceneDefensePolicies](~~159382~~) operation to query the IDs of all policies.', example='321a-fd31-df51-****', position='Query'),
}

model DisableSceneDefensePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model DisableSceneDefensePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DisableSceneDefensePolicyResponseBody(name='body'),
}

async function disableSceneDefensePolicy(request: DisableSceneDefensePolicyRequest): DisableSceneDefensePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableSceneDefensePolicy', 'POST', '/', 'json', false, 'json', request);
}

model DisableWebAccessLogConfigRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DisableWebAccessLogConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model DisableWebAccessLogConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DisableWebAccessLogConfigResponseBody(name='body'),
}

async function disableWebAccessLogConfig(request: DisableWebAccessLogConfigRequest): DisableWebAccessLogConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableWebAccessLogConfig', 'POST', '/', 'json', false, 'json', request);
}

model DisableWebCCRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DisableWebCCResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DisableWebCCResponse = {
  headers: map[string]string(name='headers'),
  body: DisableWebCCResponseBody(name='body'),
}

async function disableWebCC(request: DisableWebCCRequest): DisableWebCCResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableWebCC', 'POST', '/', 'json', false, 'json', request);
}

model DisableWebCCRuleRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model DisableWebCCRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DisableWebCCRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DisableWebCCRuleResponseBody(name='body'),
}

async function disableWebCCRule(request: DisableWebCCRuleRequest): DisableWebCCRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableWebCCRule', 'POST', '/', 'json', false, 'json', request);
}

model EmptyAutoCcBlacklistRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
}

model EmptyAutoCcBlacklistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model EmptyAutoCcBlacklistResponse = {
  headers: map[string]string(name='headers'),
  body: EmptyAutoCcBlacklistResponseBody(name='body'),
}

async function emptyAutoCcBlacklist(request: EmptyAutoCcBlacklistRequest): EmptyAutoCcBlacklistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EmptyAutoCcBlacklist', 'POST', '/', 'json', false, 'json', request);
}

model EmptyAutoCcWhitelistRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
}

model EmptyAutoCcWhitelistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model EmptyAutoCcWhitelistResponse = {
  headers: map[string]string(name='headers'),
  body: EmptyAutoCcWhitelistResponseBody(name='body'),
}

async function emptyAutoCcWhitelist(request: EmptyAutoCcWhitelistRequest): EmptyAutoCcWhitelistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EmptyAutoCcWhitelist', 'POST', '/', 'json', false, 'json', request);
}

model EmptySlsLogstoreRequest {
  regionId?: string(name='RegionId', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model EmptySlsLogstoreResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model EmptySlsLogstoreResponse = {
  headers: map[string]string(name='headers'),
  body: EmptySlsLogstoreResponseBody(name='body'),
}

async function emptySlsLogstore(request: EmptySlsLogstoreRequest): EmptySlsLogstoreResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EmptySlsLogstore', 'POST', '/', 'json', false, 'json', request);
}

model EnableSceneDefensePolicyRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  policyId: string(name='PolicyId', description='The ID of the policy that you want to enable.

> You can call the [DescribeSceneDefensePolicies](~~159382~~) operation to query the IDs of all policies.', example='321a-fd31-df51-****', position='Query'),
}

model EnableSceneDefensePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model EnableSceneDefensePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: EnableSceneDefensePolicyResponseBody(name='body'),
}

async function enableSceneDefensePolicy(request: EnableSceneDefensePolicyRequest): EnableSceneDefensePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableSceneDefensePolicy', 'POST', '/', 'json', false, 'json', request);
}

model EnableWebAccessLogConfigRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model EnableWebAccessLogConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model EnableWebAccessLogConfigResponse = {
  headers: map[string]string(name='headers'),
  body: EnableWebAccessLogConfigResponseBody(name='body'),
}

async function enableWebAccessLogConfig(request: EnableWebAccessLogConfigRequest): EnableWebAccessLogConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableWebAccessLogConfig', 'POST', '/', 'json', false, 'json', request);
}

model EnableWebCCRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model EnableWebCCResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model EnableWebCCResponse = {
  headers: map[string]string(name='headers'),
  body: EnableWebCCResponseBody(name='body'),
}

async function enableWebCC(request: EnableWebCCRequest): EnableWebCCResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableWebCC', 'POST', '/', 'json', false, 'json', request);
}

model EnableWebCCRuleRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model EnableWebCCRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model EnableWebCCRuleResponse = {
  headers: map[string]string(name='headers'),
  body: EnableWebCCRuleResponseBody(name='body'),
}

async function enableWebCCRule(request: EnableWebCCRuleRequest): EnableWebCCRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableWebCCRule', 'POST', '/', 'json', false, 'json', request);
}

model ModifyBizBandWidthModeRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', position='Query'),
  mode: string(name='Mode', position='Query'),
}

model ModifyBizBandWidthModeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBizBandWidthModeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBizBandWidthModeResponseBody(name='body'),
}

async function modifyBizBandWidthMode(request: ModifyBizBandWidthModeRequest): ModifyBizBandWidthModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBizBandWidthMode', 'POST', '/', 'json', false, 'json', request);
}

model ModifyBlackholeStatusRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  blackholeStatus: string(name='BlackholeStatus', description='The action that you want to perform on the instance. Set the value to **undo**, which indicates that you want to deactivate blackhole filtering.', example='undo', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
}

model ModifyBlackholeStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model ModifyBlackholeStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBlackholeStatusResponseBody(name='body'),
}

async function modifyBlackholeStatus(request: ModifyBlackholeStatusRequest): ModifyBlackholeStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBlackholeStatus', 'POST', '/', 'json', false, 'json', request);
}

model ModifyBlockStatusRequest {
  regionId?: string(name='RegionId', position='Host'),
  duration?: int32(name='Duration', description='The blocking period. Valid values: **15** to **43200**. Unit: minutes.

> If you set **Status** to **do**, you must also specify this parameter.', example='60', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the Anti-DDoS Pro instance to manage.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  lines: [ string ](name='Lines', description='An array consisting of the Internet service provider (ISP) lines from which traffic is blocked.', example='ct', position='Query'),
  status: string(name='Status', description='Specifies the status of the Diversion from Origin Server policy. Valid values:

*   **do**: enables the policy.
*   **undo**: disables the policy.', example='do', position='Query'),
}

model ModifyBlockStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model ModifyBlockStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBlockStatusResponseBody(name='body'),
}

/**
  * > This operation is suitable only for Anti-DDoS Pro.
  *
 */
async function modifyBlockStatus(request: ModifyBlockStatusRequest): ModifyBlockStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBlockStatus', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCnameReuseRequest {
  regionId?: string(name='RegionId', position='Host'),
  cname?: string(name='Cname', description='The CNAME record that you want to reuse for the website.', example='4o6ep6q217k9****.aliyunddos0004.com', position='Query'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  enable: int32(name='Enable', description='Specifies whether to enable CNAME reuse. Valid values:

*   **1**: enables CNAME reuse.
*   **2**: disables CNAME reuse.', example='1', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model ModifyCnameReuseResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyCnameReuseResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCnameReuseResponseBody(name='body'),
}

/**
  * > This operation is suitable only for Anti-DDoS Premium.
  *
 */
async function modifyCnameReuse(request: ModifyCnameReuseRequest): ModifyCnameReuseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCnameReuse', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDomainResourceRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name that is added to the Anti-DDoS Pro or Anti-DDoS Premium instance.', example='www.example.com', position='Query'),
  httpsExt?: string(name='HttpsExt', description='The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:

*   **Http2https**: specifies whether to turn on Enforce HTTPS Routing. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enforce HTTPS Routing is turned off. The value 1 indicates that Enforce HTTPS Routing is turned on. The default value is 0.

    If your website supports both HTTP and HTTPS, this feature meets your business requirements. If you enable this feature, all HTTP requests to access the website are redirected to HTTPS requests on the standard port 443.

*   **Https2http**: specifies whether to turn on Enable HTTP. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP is turned off. The value 1 indicates that Enable HTTP is turned on. The default value is 0.

    If your website does not support HTTPS, this feature meets your business requirements If this feature is enabled, all HTTPS requests are redirected to HTTP requests and forwarded to origin servers. This feature can redirect WebSockets requests to WebSocket requests. Requests are redirected over the standard port 80.

*   **Http2**: specifies whether to turn on Enable HTTP/2. This field is optional. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on. The default value is 0.

    After you turn on the switch, HTTP/2 is used.', example='{"Http2":1,"Http2https":1,"Https2http":1}', position='Query'),
  instanceIds: [ string ](name='InstanceIds', description='An array consisting of the IDs of instances that you want to associate.', position='Query'),
  proxyTypes: [ 
    {
      proxyPorts: [ int32 ](name='ProxyPorts', description='An array that consists of port numbers.'),
      proxyType?: string(name='ProxyType', description='The type of the protocol. Valid values:

*   **http**
*   **https**
*   **websocket**
*   **websockets**', example='https'),
    }
  ](name='ProxyTypes', description='An array that consists of the details of the protocol type and port number.', position='Query'),
  realServers: [ string ](name='RealServers', description='An array that consists of the addresses of origin servers.', position='Query'),
  rsType: int32(name='RsType', description='The address type of the origin server. Valid values:

*   **0**: IP address

*   **1**: domain name

    If you deploy proxies, such as a Web Application Firewall (WAF) instance, between the origin server and the Anti-DDoS Pro or Anti-DDoS Premium instance, set the value to 1. If you use the domain name, you must enter the address of the proxy, such as the CNAME of WAF.', example='0', position='Query'),
}

model ModifyDomainResourceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='39499F01-19D9-4EA4-A0E9-C6014BA5CDBE'),
}

model ModifyDomainResourceResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDomainResourceResponseBody(name='body'),
}

async function modifyDomainResource(request: ModifyDomainResourceRequest): ModifyDomainResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDomainResource', 'POST', '/', 'json', false, 'json', request);
}

model ModifyElasticBandWidthRequest {
  regionId?: string(name='RegionId', position='Host'),
  elasticBandwidth: int32(name='ElasticBandwidth', description='The new burstable protection bandwidth that you want to use. Unit: Gbit/s.

> You can call the [DescribeElasticBandwidthSpec](~~91502~~) operation to query the available burstable protection bandwidth of the instance.', example='50', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

>  The instance must be in a normal state. You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
}

model ModifyElasticBandWidthResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyElasticBandWidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyElasticBandWidthResponseBody(name='body'),
}

/**
  * > This operation is suitable only for Anti-DDoS Pro.
  *
 */
async function modifyElasticBandWidth(request: ModifyElasticBandWidthRequest): ModifyElasticBandWidthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyElasticBandWidth', 'POST', '/', 'json', false, 'json', request);
}

model ModifyElasticBizBandWidthRequest {
  regionId?: string(name='RegionId', position='Host'),
  elasticBizBandwidth: int32(name='ElasticBizBandwidth', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  mode?: string(name='Mode', position='Query'),
}

model ModifyElasticBizBandWidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyElasticBizBandWidthResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyElasticBizBandWidthResponseBody(name='body'),
}

async function modifyElasticBizBandWidth(request: ModifyElasticBizBandWidthRequest): ModifyElasticBizBandWidthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyElasticBizBandWidth', 'POST', '/', 'json', false, 'json', request);
}

model ModifyFullLogTtlRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  ttl: int32(name='Ttl', description='The log storage duration of a website. Valid values: **30** to **180**. Unit: days.', example='30', position='Query'),
}

model ModifyFullLogTtlResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyFullLogTtlResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFullLogTtlResponseBody(name='body'),
}

async function modifyFullLogTtl(request: ModifyFullLogTtlRequest): ModifyFullLogTtlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyFullLogTtl', 'POST', '/', 'json', false, 'json', request);
}

model ModifyHeadersRequest {
  regionId?: string(name='RegionId', position='Host'),
  customHeaders: string(name='CustomHeaders', position='Query'),
  domain: string(name='Domain', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
}

model ModifyHeadersResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHeadersResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHeadersResponseBody(name='body'),
}

async function modifyHeaders(request: ModifyHeadersRequest): ModifyHeadersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyHeaders', 'POST', '/', 'json', false, 'json', request);
}

model ModifyHealthCheckConfigRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  forwardProtocol: string(name='ForwardProtocol', description='The forwarding protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp', position='Query'),
  frontendPort: int32(name='FrontendPort', description='The forwarding port.', example='8080', position='Query'),
  healthCheck: string(name='HealthCheck', description='The details of the health check configuration. This parameter is a JSON string. The string contains the following fields:

*   **Type**: the protocol type. This field is required and must be of the STRING type. Valid values: **tcp** (Layer 4) and **http** (Layer 7).

*   **Domain**: the domain name, which must be of the STRING type.

    **

    **Note**This parameter is returned only when the Layer 7 health check configuration is queried.

*   **Uri**: the check path, which must be of the STRING type.

    **

    **Note**This parameter is returned only when the Layer 7 health check configuration is queried.

*   **Timeout**: the response timeout period, which must be of the INTEGER type. Valid values: **1** to **30**. Unit: seconds.

*   **Port**: the port on which you want to perform the health check, which must be of the INTEGER type.

*   **Interval**: the health check interval, which must be of the INTEGER type. Valid values: **1** to **30**. Unit: seconds.

*   **Up**: the number of consecutive successful health checks that must occur before declaring a port healthy, which must be of the INTEGER type. Valid values: **1** to **10**.

*   **Down**: the number of consecutive failed health checks that must occur before declaring a port unhealthy, which must be of the INTEGER type. Valid values: **1** to **10**.', example='{"Type":"tcp","Timeout":10,"Port":8080,"Interval":10,"Up":10,"Down":40}', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
}

model ModifyHealthCheckConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyHealthCheckConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHealthCheckConfigResponseBody(name='body'),
}

async function modifyHealthCheckConfig(request: ModifyHealthCheckConfigRequest): ModifyHealthCheckConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyHealthCheckConfig', 'POST', '/', 'json', false, 'json', request);
}

model ModifyHttp2EnableRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name, and the domain name must be associated with an instance that uses the Enhanced function plan. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  enable: int32(name='Enable', description='Specifies whether to enable HTTP/2. Valid values:

*   **0**: disables HTTP/2.
*   **1**: enables HTTP/2.', example='1', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model ModifyHttp2EnableResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model ModifyHttp2EnableResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHttp2EnableResponseBody(name='body'),
}

/**
  * > This operation is suitable only for Anti-DDoS Pro.
  *
 */
async function modifyHttp2Enable(request: ModifyHttp2EnableRequest): ModifyHttp2EnableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyHttp2Enable', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceRemarkRequest {
  regionId?: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  remark: string(name='Remark', description='The description of the instance.

The value can contain letters, digits, and some special characters, such as`, . + - * / _` The value can be up to 500 characters in length.', example='new-remark', position='Query'),
}

model ModifyInstanceRemarkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7EFA2BA6-9C0A-4410-B735-FC337EB634A1'),
}

model ModifyInstanceRemarkResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceRemarkResponseBody(name='body'),
}

async function modifyInstanceRemark(request: ModifyInstanceRemarkRequest): ModifyInstanceRemarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceRemark', 'POST', '/', 'json', false, 'json', request);
}

model ModifyNetworkRuleAttributeRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  config: string(name='Config', description='The session persistence settings of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:

*   **PersistenceTimeout**: The timeout period of session persistence. This field is required and must be of the integer type. Valid values: **30** to **3600**. Unit: seconds. Default value: **0**. A value of 0 indicates that session persistence is disabled.', example='{"PersistenceTimeout":900}', position='Query'),
  forwardProtocol: string(name='ForwardProtocol', description='The forwarding protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp', position='Query'),
  frontendPort: int32(name='FrontendPort', description='The forwarding port.', example='8080', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
}

model ModifyNetworkRuleAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyNetworkRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyNetworkRuleAttributeResponseBody(name='body'),
}

async function modifyNetworkRuleAttribute(request: ModifyNetworkRuleAttributeRequest): ModifyNetworkRuleAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyNetworkRuleAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyOcspStatusRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', position='Query'),
  enable: int32(name='Enable', position='Query'),
}

model ModifyOcspStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyOcspStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyOcspStatusResponseBody(name='body'),
}

async function modifyOcspStatus(request: ModifyOcspStatusRequest): ModifyOcspStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyOcspStatus', 'POST', '/', 'json', false, 'json', request);
}

model ModifyPortRequest {
  regionId?: string(name='RegionId', position='Host'),
  backendPort: string(name='BackendPort', description='The port of the origin server. Valid values: **0** to **65535**.', example='55', position='Query'),
  frontendPort: string(name='FrontendPort', description='The forwarding port. Valid values: **0** to **65535**.', example='55', position='Query'),
  frontendProtocol: string(name='FrontendProtocol', description='The type of the protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp', position='Query'),
  instanceId: string(name='InstanceId', description='The ID of the Anti-DDoS Pro or Anti-DDoS Premium instance to which the port forwarding rule belongs.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-st21zbyq****', position='Query'),
  realServers: [ string ](name='RealServers', description='An array that consists of the IP addresses of origin servers.', position='Query'),
}

model ModifyPortResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='39499F01-19D9-4EA4-A0E9-C6014BA5CDBE'),
}

model ModifyPortResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPortResponseBody(name='body'),
}

/**
  * You can call the ModifyPort operation by using Terraform. For more information about Terraform, see [What is Terraform?](~~95820~~).
  *
 */
async function modifyPort(request: ModifyPortRequest): ModifyPortResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPort', 'POST', '/', 'json', false, 'json', request);
}

model ModifyPortAutoCcStatusRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  mode: string(name='Mode', description='The mode of the Intelligent Protection policy. Valid values:

*   **normal**
*   **loose**
*   **strict**', example='normal', position='Query'),
  switch: string(name='Switch', description='Specifies the status of the Intelligent Protection policy. Valid values:

*   **on**: enables the policy.
*   **off**: disables the policy.', example='on', position='Query'),
}

model ModifyPortAutoCcStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyPortAutoCcStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPortAutoCcStatusResponseBody(name='body'),
}

async function modifyPortAutoCcStatus(request: ModifyPortAutoCcStatusRequest): ModifyPortAutoCcStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPortAutoCcStatus', 'POST', '/', 'json', false, 'json', request);
}

model ModifySceneDefensePolicyRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  endTime: long(name='EndTime', description='The end time of the policy. The value is a UNIX timestamp. Unit: milliseconds.', example='1586016000000', position='Query'),
  name: string(name='Name', description='The name of the policy.', example='testpolicy', position='Query'),
  policyId: string(name='PolicyId', description='The ID of the policy that you want to modify.

> You can call the [DescribeSceneDefensePolicies](~~159382~~) operation to query the IDs of all policies.', example='321a-fd31-df51-****', position='Query'),
  startTime: long(name='StartTime', description='The start time of the policy. The value is a UNIX timestamp. Unit: milliseconds.', example='1585670400000', position='Query'),
  template: string(name='Template', description='The template of the policy. Valid values:

*   **promotion**: important activity
*   **bypass**: all traffic forwarded', example='promotion', position='Query'),
}

model ModifySceneDefensePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model ModifySceneDefensePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySceneDefensePolicyResponseBody(name='body'),
}

async function modifySceneDefensePolicy(request: ModifySceneDefensePolicyRequest): ModifySceneDefensePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySceneDefensePolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifySchedulerRuleRequest {
  regionId?: string(name='RegionId', position='Host'),
  param?: string(name='Param', description='The details of the CDN interaction rule. This parameter is a JSON string. The string contains the following fields:

*   **ParamType**: the type of the scheduling rule. This field is required and must be of the string type. Set the value to **cdn**. This indicates that you want to modify a CDN interaction rule.

*   **ParamData**: the values of parameters that you want to modify for the CDN interaction rule. This field is required and must be of the map type. The ParamData parameter contains the following parameters:

    *   **Domain**: the accelerated domain in CDN. This parameter is required and must be of the string type.
    *   **Cname**: the CNAME that is assigned to the accelerated domain. This parameter is required and must be of the string type.
    *   **AccessQps**: the queries per second (QPS) threshold that is used to switch service traffic to Anti-DDoS Pro or Anti-DDoS Premium. This parameter is required and must be of the integer type.
    *   **UpstreamQps**: the QPS threshold that is used to switch service traffic to CDN. This parameter is optional and must be of the integer type.', example='{"ParamType":"cdn","ParamData":"Domain":"example.aliyundoc.com","Cname":"demo.aliyundoc.com","AccessQps":100,"UpstreamQps":100}}', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  ruleName: string(name='RuleName', description='The name of the rule that you want to modify.', example='testrule', position='Query'),
  ruleType: int32(name='RuleType', description='The type of the rule. Valid values:

*   **2**: tiered protection
*   **3**: network acceleration
*   **5**: Alibaba Cloud CDN (CDN) interaction
*   **6**: cloud service interaction', example='2', position='Query'),
  rules: string(name='Rules', description='The details of the scheduling rule. This parameter is a JSON string. The string contains the following fields:

*   **Type**: the address type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type. Valid values:

    *   **A**: IP address
    *   **CNAME**: domain name

*   **Value**: the address of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type.

*   **Priority**: the priority of the scheduling rule. This field is required and must be of the integer type. Valid values: **0** to **100**. A larger value indicates a higher priority.

*   **ValueType**: the type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the integer type. Valid values:

    *   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
    *   **2**: the IP address of the interaction resource in the tiered protection scenario
    *   **3**: the IP address that is used to accelerate access in the network acceleration scenario
    *   **5**: the domain name that is configured in Alibaba Cloud CDN (CDN) in the CDN interaction scenario
    *   **6** the IP address of the interaction resource in the cloud service interaction scenario

*   **RegionId**: the region where the interaction resource is deployed. This parameter must be specified when **ValueType** is set to **2**. The value must be of the string type.', example='[{"Type":"A", "Value":"1.1.XX.XX", "Priority":80,"ValueType":2, "RegionId":"cn-hangzhou" },{"Type":"A", "Value":"203.199.XX.XX", "Priority":80,"ValueType":1}]', position='Query'),
}

model ModifySchedulerRuleResponseBody = {
  cname?: string(name='Cname', description='The CNAME that is assigned by Sec-Traffic Manager for the scheduling rule.

> To enable the scheduling rule, you must map the domain name of the service to the CNAME.', example='48k7b372gpl4****.aliyunddos0001.com'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='FFC77501-BDF8-4BC8-9BF5-B295FBC3189B'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='testrule'),
}

model ModifySchedulerRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySchedulerRuleResponseBody(name='body'),
}

async function modifySchedulerRule(request: ModifySchedulerRuleRequest): ModifySchedulerRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySchedulerRule', 'POST', '/', 'json', false, 'json', request);
}

model ModifyTlsConfigRequest {
  regionId?: string(name='RegionId', position='Host'),
  config: string(name='Config', description='The details of the TLS policy. The value is a JSON string that contains the following fields:

*   **ssl_protocols**: the version of TLS. This field is required. Data type: string. Valid values:

    *   **tls1.0**: TLS 1.0 and later
    *   **tls1.1**: TLS 1.1 and later
    *   **tls1.2**: TLS 1.2 and later

*   **ssl_ciphers**: the type of the cipher suite. This field is required. Data type: string. Valid values:

    *   **all**: all cipher suites, which include strong and weak cipher suites
    *   **improved**: enhanced cipher suites
    *   **strong**: strong cipher suites
    *   **default**: default cipher suites, which include only strong cipher suites', example='{"ssl_protocols":"tls1.0","ssl_ciphers":"all"}', position='Query'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='example.aliyundoc.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model ModifyTlsConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model ModifyTlsConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyTlsConfigResponseBody(name='body'),
}

async function modifyTlsConfig(request: ModifyTlsConfigRequest): ModifyTlsConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyTlsConfig', 'POST', '/', 'json', false, 'json', request);
}

model ModifyWebAIProtectModeRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  config: string(name='Config', description='The details of the Intelligent Protection policy. This parameter is a JSON string. The string contains the following fields:

*   **AiTemplate**: the level of the Intelligent Protection policy. This field is required and must be of the STRING type. Valid values:

    *   **level30**: the Low level
    *   **level60**: the Normal level
    *   **level90**: the Strict level

*   **AiMode**: the mode of the Intelligent Protection policy. This field is required and must be of the string type. Valid values:

    *   **watch**: the Warning mode
    *   **defense**: the Defense mode', example='{"AiTemplate":"level60","AiMode":"defense"}', position='Query'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model ModifyWebAIProtectModeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebAIProtectModeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWebAIProtectModeResponseBody(name='body'),
}

async function modifyWebAIProtectMode(request: ModifyWebAIProtectModeRequest): ModifyWebAIProtectModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyWebAIProtectMode', 'POST', '/', 'json', false, 'json', request);
}

model ModifyWebAIProtectSwitchRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  config: string(name='Config', description='The details of the Intelligent Protection policy. This parameter is a JSON string. The string contains the following fields:

*   **AiRuleEnable**: the status of the Intelligent Protection policy. This field is required and must be of the integer type. Valid values:

    *   **0**: disabled
    *   **1**: enabled', example='{"AiRuleEnable": 1}', position='Query'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model ModifyWebAIProtectSwitchResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebAIProtectSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWebAIProtectSwitchResponseBody(name='body'),
}

async function modifyWebAIProtectSwitch(request: ModifyWebAIProtectSwitchRequest): ModifyWebAIProtectSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyWebAIProtectSwitch', 'POST', '/', 'json', false, 'json', request);
}

model ModifyWebAccessModeRequest {
  regionId?: string(name='RegionId', position='Host'),
  accessMode: int32(name='AccessMode', description='The mode in which a website service is added to Anti-DDoS Pro or Anti-DDoS Premium. Valid values:

*   **0**: A record mode
*   **1**: anti-DDoS mode
*   **2**: origin redundancy mode', example='2', position='Query'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
}

model ModifyWebAccessModeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebAccessModeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWebAccessModeResponseBody(name='body'),
}

async function modifyWebAccessMode(request: ModifyWebAccessModeRequest): ModifyWebAccessModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyWebAccessMode', 'POST', '/', 'json', false, 'json', request);
}

model ModifyWebAreaBlockRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name whose configurations you want to modify.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  regions?: [ string ](name='Regions', description='The regions from which you block requests.

> If you do not configure this parameter, the Blocked Regions (Domain Names) policy is disabled.', example='CN-SHANGHAI', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](~~94485~~).', example='rg-acfm2pz25js****', position='Query'),
}

model ModifyWebAreaBlockResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5AA2BD65-E289-4E91-9DD9-3E1FB2140D17'),
}

model ModifyWebAreaBlockResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWebAreaBlockResponseBody(name='body'),
}

async function modifyWebAreaBlock(request: ModifyWebAreaBlockRequest): ModifyWebAreaBlockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyWebAreaBlock', 'POST', '/', 'json', false, 'json', request);
}

model ModifyWebAreaBlockSwitchRequest {
  regionId?: string(name='RegionId', position='Host'),
  config: string(name='Config', description='Specifies whether to enable or disable the Location Blacklist (Domain Names) policy for a domain name. The value is a string that consists of a JSON struct. The JSON struct contains the following parameters:

*   **RegionblockEnable**: the status of the Location Blacklist (Domain Names) policy. This parameter is required and must be of the INTEGER type. Valid values:

    *   **1**: enables the policy.
    *   **0**: disables the policy.', example='{"RegionblockEnable": 1}', position='Query'),
  domain: string(name='Domain', description='The domain name for which you want to enable or disable the Location Blacklist policy.

> You can call the [DescribeDomains](~~91724~~) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.', example='www.aliyundoc.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
}

model ModifyWebAreaBlockSwitchResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
}

model ModifyWebAreaBlockSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWebAreaBlockSwitchResponseBody(name='body'),
}

/**
  * You can call the ModifyWebAreaBlockSwitch operation to enable or disable the Location Blacklist (Domain Names) policy for a domain name.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function modifyWebAreaBlockSwitch(request: ModifyWebAreaBlockSwitchRequest): ModifyWebAreaBlockSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyWebAreaBlockSwitch', 'POST', '/', 'json', false, 'json', request);
}

model ModifyWebCCRuleRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  act: string(name='Act', description='The blocking type. Valid values:

*   **close**: blocks the request.
*   **captcha**: enables captcha verification.', example='close', position='Query'),
  count: int32(name='Count', description='The number of requests that are allowed from an individual IP address. Valid values: **2** to **2000**.', example='3', position='Query'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  interval: int32(name='Interval', description='The detection interval. Valid values: **5** to **10800**. Unit: seconds.', example='30', position='Query'),
  mode: string(name='Mode', description='The match mode. Valid values:

*   **prefix**: prefix match
*   **match**: exact match', example='prefix', position='Query'),
  name: string(name='Name', description='The name of the rule.', example='testrule', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  ttl: int32(name='Ttl', description='The blocking duration. Valid values: **1** to **1440**. Unit: minutes.', example='10', position='Query'),
  uri: string(name='Uri', description='The check path.', example='/abc', position='Query'),
}

model ModifyWebCCRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebCCRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWebCCRuleResponseBody(name='body'),
}

async function modifyWebCCRule(request: ModifyWebCCRuleRequest): ModifyWebCCRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyWebCCRule', 'POST', '/', 'json', false, 'json', request);
}

model ModifyWebCacheCustomRuleRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name, and the domain name must be associated with an instance that uses the Enhanced function plan. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
  rules: string(name='Rules', description='The details of the custom rule. This parameter is a JSON string. The string contains the following fields:

*   **Name**: the name of the rule. This field is required and must be of the string type.

*   **Uri**: the path to the cached page. This field is required and must be of the STRING type.

*   **Mode**: the cache mode. This field is required and must be of the STRING type. Valid values:

    *   **standard**: uses the standard mode.
    *   **aggressive**: uses the enhanced mode.
    *   **bypass**: No data is cached.

*   **CacheTtl**: the expiration time of the page cache. This field is required and must be of the INTEGER type. Unit: seconds.', example='[{"Name": "test","Uri": "/a","Mode": "standard","CacheTtl": 3600}]', position='Query'),
}

model ModifyWebCacheCustomRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebCacheCustomRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWebCacheCustomRuleResponseBody(name='body'),
}

async function modifyWebCacheCustomRule(request: ModifyWebCacheCustomRuleRequest): ModifyWebCacheCustomRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyWebCacheCustomRule', 'POST', '/', 'json', false, 'json', request);
}

model ModifyWebCacheModeRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name, and the domain name must be associated with an instance that uses the Enhanced function plan. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  mode: string(name='Mode', description='The cache mode of the Static Page Caching policy. Valid values:

*   **standard**: uses the standard cache mode.
*   **aggressive**: uses the enhanced cache mode.
*   **bypass**: caches no data.', example='standard', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model ModifyWebCacheModeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebCacheModeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWebCacheModeResponseBody(name='body'),
}

async function modifyWebCacheMode(request: ModifyWebCacheModeRequest): ModifyWebCacheModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyWebCacheMode', 'POST', '/', 'json', false, 'json', request);
}

model ModifyWebCacheSwitchRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name for which you want to configure the Static Page Caching policy.

> You can call the [DescribeDomains](~~91724~~) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.', example='www.aliyundoc.com', position='Query'),
  enable: int32(name='Enable', description='Specifies whether to enable or disable the Static Page Caching policy for a website. Valid values:

*   **1**: enables the policy.
*   **0**: disables the policy.', example='1', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
}

model ModifyWebCacheSwitchResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
}

model ModifyWebCacheSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWebCacheSwitchResponseBody(name='body'),
}

/**
  * You can call the ModifyWebCacheSwitch operation to enable or disable the Static Page Caching policy for a website.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function modifyWebCacheSwitch(request: ModifyWebCacheSwitchRequest): ModifyWebCacheSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyWebCacheSwitch', 'POST', '/', 'json', false, 'json', request);
}

model ModifyWebIpSetSwitchRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  config: string(name='Config', description='The details of the Black Lists and White Lists (Domain Names) policy. This parameter is a JSON string. The string contains the following fields:

*   **Bwlist_Enable**: the status of the Black Lists and White Lists (Domain Names) policy. This field is required and must be of the integer type. Valid values:

    *   **0**: disabled
    *   **1**: enabled', example='{"BwlistEnable":1}', position='Query'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model ModifyWebIpSetSwitchResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebIpSetSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWebIpSetSwitchResponseBody(name='body'),
}

async function modifyWebIpSetSwitch(request: ModifyWebIpSetSwitchRequest): ModifyWebIpSetSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyWebIpSetSwitch', 'POST', '/', 'json', false, 'json', request);
}

model ModifyWebPreciseAccessRuleRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='example.aliyundoc.com', position='Query'),
  expires?: int32(name='Expires', description='The validity period of the rule. Unit: seconds. This parameter takes effect only when **action** of a rule is **block**. Access requests that match the rule are blocked within the specified validity period of the rule. If you do not specify this parameter, this rule takes effect all the time.', example='600', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='rg-acfm2pz25js****', position='Query'),
  rules: string(name='Rules', description='The settings of the accurate access control rule. This parameter is a JSON string. The following list describes the fields in the value of the parameter:

*   **action**: the action that is performed if the rule is matched. This field is required and must be of the string type. Valid values:

    *   **accept**: allows the requests that match the rule.
    *   **block**: blocks the requests that match the rule.
    *   **challenge**: implements a CAPTCHA for the requests that match the rule.

*   **name**: the name of the rule. This field is required and must be of the string type.

*   **condition**: the match conditions. This field is required and must be of the map type. A match condition contains the following parameters.

    **

    **Note**The AND logical operator is used to define the relationship among multiple match conditions.

    *   **field**: the match field. This parameter is required and must be of the string type.

    *   **match_method**: the logical relation. This parameter is required and must be of the string type.

        **

        **Note**For information about the mappings between the **field** and **match_method** parameters, see the Mappings between the field and match_method parameters table in this topic.

    *   **content**: the match content. This parameter is required and must be of the string type.

*   **header_name**: the HTTP header. This parameter is optional and must be of the string type. This parameter takes effect only when **field** is **header**.', example='[{"action":"block","name":"testrule","condition":[{"field":"uri","match_method":"contain","content":"/test/123"}]}]', position='Query'),
}

model ModifyWebPreciseAccessRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F908E959-ADA8-4D7B-8A05-FF2F67F50964'),
}

model ModifyWebPreciseAccessRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWebPreciseAccessRuleResponseBody(name='body'),
}

async function modifyWebPreciseAccessRule(request: ModifyWebPreciseAccessRuleRequest): ModifyWebPreciseAccessRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyWebPreciseAccessRule', 'POST', '/', 'json', false, 'json', request);
}

model ModifyWebPreciseAccessSwitchRequest {
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Host'),
  config: string(name='Config', description='The configuration of the Accurate Access Control policy. This parameter is a JSON string. The string contains the following fields:

*   **PreciseRuleEnable**: the status of the Accurate Access Control policy. This field is required and must be of the INTEGER type. Valid values:

    *   **0**: disables the policy.
    *   **1**: enables the policy.', example='{"PreciseRuleEnable":0}', position='Query'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.', example='www.aliyun.com', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default', position='Query'),
}

model ModifyWebPreciseAccessSwitchResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebPreciseAccessSwitchResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWebPreciseAccessSwitchResponseBody(name='body'),
}

async function modifyWebPreciseAccessSwitch(request: ModifyWebPreciseAccessSwitchRequest): ModifyWebPreciseAccessSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyWebPreciseAccessSwitch', 'POST', '/', 'json', false, 'json', request);
}

model ModifyWebRuleRequest {
  regionId?: string(name='RegionId', position='Host'),
  domain: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query the domain names for which forwarding rules are configured.', example='www.aliyun.com', position='Query'),
  httpsExt?: string(name='HttpsExt', description='The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:

*   **Http2https**: specifies whether to turn on Enforce HTTPS Routing. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enforce HTTPS Routing is turned off. The value 1 indicates that Enforce HTTPS Routing is turned on. The default value is 0.

    If your website supports both HTTP and HTTPS, this feature meets your business requirements. If you enable this feature, all HTTP requests to access the website are redirected to HTTPS requests on the standard port 443.

*   **Https2http**: specifies whether to turn on Enable HTTP. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP is turned off. The value 1 indicates that Enable HTTP is turned on. The default value is 0.

    If your website does not support HTTPS, this feature meets your business requirements If this feature is enabled, all HTTPS requests are redirected to HTTP requests and forwarded to origin servers. This feature can redirect WebSockets requests to WebSocket requests. Requests are redirected over the standard port 80.

*   **Http2**: specifies whether to turn on Enable HTTP/2. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on. The default value is 0.

    After you turn on Enable HTTP/2, the protocol type is HTTP/2.', example='{"Http2":1,"Http2https":1,"Https2http":1}', position='Query'),
  instanceIds?: [ string ](name='InstanceIds', description='An array consisting of the IDs of the instances that you want to associate. You can associate up to 100 instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
  proxyTypes: string(name='ProxyTypes', description='The protocol of the forwarding rule. The value is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that contains the following fields:

*   **ProxyType**: the protocol type. This field is required and must be a string. Valid values: **http**, **https**, **websocket**, and **websockets**.
*   **ProxyPort**: the port number. This field is required and must be an integer.', example='[{"ProxyType":"https","ProxyPorts":[443]}]', position='Query'),
  realServers: [ string ](name='RealServers', description='An array that consists of the addresses of origin servers.', example='1.xxx.xxx.1', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](~~94485~~).', example='rg-acfm2pz25js****', position='Query'),
  rsType: int32(name='RsType', description='The address type of the origin server. Valid values:

*   **0**: IP address
*   **1**: domain name The domain name of the origin server is returned if you deploy proxies, such as Web Application Firewall (WAF), between the origin server and the instance. In this case, the address of the proxy, such as the CNAME provided by WAF, is returned.', example='0', position='Query'),
}

model ModifyWebRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB3261D2-7D1B-4ADA-9E98-A200B2CDA2DC'),
}

model ModifyWebRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWebRuleResponseBody(name='body'),
}

async function modifyWebRule(request: ModifyWebRuleRequest): ModifyWebRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyWebRule', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseInstanceRequest {
  regionId: string(name='RegionId', position='Host'),
  instanceId: string(name='InstanceId', description='The ID of the instance that you want to release.

> You can release only expired instances. You can call the [DescribeInstances](~~91478~~) operation to query the IDs and expiration status of all instances.', example='ddoscoo-cn-mp91j1ao****', position='Query'),
}

model ReleaseInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='06FFAF5F-CD3E-4886-A849-AAB40DFF6515'),
}

model ReleaseInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseInstanceResponseBody(name='body'),
}

/**
  * If an Anti-DDoS Pro or Anti-DDoS Premium instance expires, DDoS mitigation stops. The instance stops forwarding service traffic seven days after it expires.
  * *   We recommend that you renew your instance before it expires. This eliminates the impacts on service protection and traffic forwarding. You can call the [DescribeInstances](~~91478~~) operation to query the expiration time of all instances. If you want to renew your instance, log on to the [Anti-DDoS Pro](https://yundun.console.aliyun.com/?p=ddoscoo) console.
  * *   If you do not plan to renew your instance, switch the service traffic back to the origin sever before your instance expires. To switch the traffic back, change the service IP address to the IP address of the origin server or modify the CNAME to stop forwarding service traffic to Anti-DDoS Pro or Anti-DDoS Premium. This prevents service interruptions caused by the expiration.
  * You can call this operation to release an instance after the instance expires.
  * > Before you release an instance, make sure that the service traffic is switched to the origin server.
  *
 */
async function releaseInstance(request: ReleaseInstanceRequest): ReleaseInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseInstance', 'POST', '/', 'json', false, 'json', request);
}

model SwitchSchedulerRuleRequest {
  ruleName: string(name='RuleName', description='The name of the scheduling rule to manage.

> You can call the [DescribeSchedulerRules](~~157481~~) operation to query the names of all scheduling rules.', example='testrule', position='Query'),
  ruleType: int32(name='RuleType', description='The type of the scheduling rule. Valid values:

*   **2**: tiered protection rule
*   **3**: network acceleration rule
*   **5**: Alibaba Cloud CDN (CDN) interaction rule
*   **6**: cloud service interaction rule', example='6', position='Query'),
  switchData: string(name='SwitchData', description='The configuration that is used to switch service traffic. This parameter is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that includes the following parameters:

*   **Value**: required. The IP address of the associated resource. Data type: string.

*   **State**: required. The operation type. Data type: integer. Valid values:

    *   **0**: switches service traffic from the associated resource to your Anti-DDoS Pro or Anti-DDoS Premium instance for scrubbing.
    *   **1**: switches service traffic back to the associated cloud resource.

*   **Interval**: optional. The waiting time that is required before the service traffic is switched back. Unit: minutes. Data type: integer. Usage notes:

    *   If the **State** parameter is set to **0**, you must set this parameter to \\*\\*-1\\*\\*. Otherwise, the call fails.
    *   If the **State** parameter is set to **1**, you do not need to set this parameter.', example='[{"Value":"39.104.XX.XX","State":0,"Interval":-1}]', position='Query'),
}

model SwitchSchedulerRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='7E3C301F-84BB-50E4-9DB9-2937B2429C1E'),
}

model SwitchSchedulerRuleResponse = {
  headers: map[string]string(name='headers'),
  body: SwitchSchedulerRuleResponseBody(name='body'),
}

/**
  * You can call the SwitchSchedulerRule operation to modify the resources to which service traffic is switched for a scheduling rule. For example, you can switch service traffic to an Anti-DDoS Pro or Anti-DDoS Premium instance for scrubbing or switch the service traffic back to the associated cloud resources.
  * Before you call this operation, you must have created a scheduling rule by calling the [CreateSchedulerRule](~~157479~~) operation.
  * ### Limits
  * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
  *
 */
async function switchSchedulerRule(request: SwitchSchedulerRuleRequest): SwitchSchedulerRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SwitchSchedulerRule', 'POST', '/', 'json', false, 'json', request);
}

