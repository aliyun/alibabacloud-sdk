/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ddoscoo', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddAutoCcBlacklistRequest {
  blacklist?: string(name='Blacklist'),
  expireTime?: int32(name='ExpireTime'),
  instanceId?: string(name='InstanceId'),
}

model AddAutoCcBlacklistResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddAutoCcBlacklistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddAutoCcBlacklistResponseBody(name='body'),
}

async function addAutoCcBlacklistWithOptions(request: AddAutoCcBlacklistRequest, runtime: Util.RuntimeOptions): AddAutoCcBlacklistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blacklist)) {
    query['Blacklist'] = request.blacklist;
  }
  if (!Util.isUnset(request.expireTime)) {
    query['ExpireTime'] = request.expireTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddAutoCcBlacklist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAutoCcBlacklist(request: AddAutoCcBlacklistRequest): AddAutoCcBlacklistResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAutoCcBlacklistWithOptions(request, runtime);
}

model AddAutoCcWhitelistRequest {
  expireTime?: int32(name='ExpireTime'),
  instanceId?: string(name='InstanceId'),
  whitelist?: string(name='Whitelist'),
}

model AddAutoCcWhitelistResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddAutoCcWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddAutoCcWhitelistResponseBody(name='body'),
}

async function addAutoCcWhitelistWithOptions(request: AddAutoCcWhitelistRequest, runtime: Util.RuntimeOptions): AddAutoCcWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.expireTime)) {
    query['ExpireTime'] = request.expireTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.whitelist)) {
    query['Whitelist'] = request.whitelist;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddAutoCcWhitelist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAutoCcWhitelist(request: AddAutoCcWhitelistRequest): AddAutoCcWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAutoCcWhitelistWithOptions(request, runtime);
}

model AssociateWebCertRequest {
  cert?: string(name='Cert'),
  certId?: int32(name='CertId'),
  certName?: string(name='CertName'),
  domain?: string(name='Domain'),
  key?: string(name='Key'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model AssociateWebCertResponseBody = {
  requestId?: string(name='RequestId'),
}

model AssociateWebCertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateWebCertResponseBody(name='body'),
}

async function associateWebCertWithOptions(request: AssociateWebCertRequest, runtime: Util.RuntimeOptions): AssociateWebCertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cert)) {
    query['Cert'] = request.cert;
  }
  if (!Util.isUnset(request.certId)) {
    query['CertId'] = request.certId;
  }
  if (!Util.isUnset(request.certName)) {
    query['CertName'] = request.certName;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateWebCert',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateWebCert(request: AssociateWebCertRequest): AssociateWebCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateWebCertWithOptions(request, runtime);
}

model AttachSceneDefenseObjectRequest {
  objectType?: string(name='ObjectType'),
  objects?: string(name='Objects'),
  policyId?: string(name='PolicyId'),
}

model AttachSceneDefenseObjectResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AttachSceneDefenseObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachSceneDefenseObjectResponseBody(name='body'),
}

async function attachSceneDefenseObjectWithOptions(request: AttachSceneDefenseObjectRequest, runtime: Util.RuntimeOptions): AttachSceneDefenseObjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.objectType)) {
    query['ObjectType'] = request.objectType;
  }
  if (!Util.isUnset(request.objects)) {
    query['Objects'] = request.objects;
  }
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachSceneDefenseObject',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachSceneDefenseObject(request: AttachSceneDefenseObjectRequest): AttachSceneDefenseObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachSceneDefenseObjectWithOptions(request, runtime);
}

model ConfigL7RsPolicyRequest {
  domain?: string(name='Domain'),
  policy?: string(name='Policy'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ConfigL7RsPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigL7RsPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfigL7RsPolicyResponseBody(name='body'),
}

async function configL7RsPolicyWithOptions(request: ConfigL7RsPolicyRequest, runtime: Util.RuntimeOptions): ConfigL7RsPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.policy)) {
    query['Policy'] = request.policy;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigL7RsPolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configL7RsPolicy(request: ConfigL7RsPolicyRequest): ConfigL7RsPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return configL7RsPolicyWithOptions(request, runtime);
}

model ConfigLayer4RemarkRequest {
  listeners?: string(name='Listeners'),
}

model ConfigLayer4RemarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigLayer4RemarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfigLayer4RemarkResponseBody(name='body'),
}

async function configLayer4RemarkWithOptions(request: ConfigLayer4RemarkRequest, runtime: Util.RuntimeOptions): ConfigLayer4RemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listeners)) {
    query['Listeners'] = request.listeners;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigLayer4Remark',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configLayer4Remark(request: ConfigLayer4RemarkRequest): ConfigLayer4RemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return configLayer4RemarkWithOptions(request, runtime);
}

model ConfigLayer4RuleBakModeRequest {
  bakMode?: string(name='BakMode'),
  listeners?: string(name='Listeners'),
}

model ConfigLayer4RuleBakModeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigLayer4RuleBakModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfigLayer4RuleBakModeResponseBody(name='body'),
}

async function configLayer4RuleBakModeWithOptions(request: ConfigLayer4RuleBakModeRequest, runtime: Util.RuntimeOptions): ConfigLayer4RuleBakModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bakMode)) {
    query['BakMode'] = request.bakMode;
  }
  if (!Util.isUnset(request.listeners)) {
    query['Listeners'] = request.listeners;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigLayer4RuleBakMode',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configLayer4RuleBakMode(request: ConfigLayer4RuleBakModeRequest): ConfigLayer4RuleBakModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return configLayer4RuleBakModeWithOptions(request, runtime);
}

model ConfigLayer4RulePolicyRequest {
  listeners?: string(name='Listeners'),
}

model ConfigLayer4RulePolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigLayer4RulePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfigLayer4RulePolicyResponseBody(name='body'),
}

async function configLayer4RulePolicyWithOptions(request: ConfigLayer4RulePolicyRequest, runtime: Util.RuntimeOptions): ConfigLayer4RulePolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listeners)) {
    query['Listeners'] = request.listeners;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigLayer4RulePolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configLayer4RulePolicy(request: ConfigLayer4RulePolicyRequest): ConfigLayer4RulePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return configLayer4RulePolicyWithOptions(request, runtime);
}

model ConfigNetworkRegionBlockRequest {
  config?: string(name='Config'),
  instanceId?: string(name='InstanceId'),
}

model ConfigNetworkRegionBlockResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigNetworkRegionBlockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfigNetworkRegionBlockResponseBody(name='body'),
}

async function configNetworkRegionBlockWithOptions(request: ConfigNetworkRegionBlockRequest, runtime: Util.RuntimeOptions): ConfigNetworkRegionBlockResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigNetworkRegionBlock',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configNetworkRegionBlock(request: ConfigNetworkRegionBlockRequest): ConfigNetworkRegionBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return configNetworkRegionBlockWithOptions(request, runtime);
}

model ConfigNetworkRulesRequest {
  networkRules?: string(name='NetworkRules'),
}

model ConfigNetworkRulesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigNetworkRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfigNetworkRulesResponseBody(name='body'),
}

async function configNetworkRulesWithOptions(request: ConfigNetworkRulesRequest, runtime: Util.RuntimeOptions): ConfigNetworkRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.networkRules)) {
    query['NetworkRules'] = request.networkRules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigNetworkRules',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configNetworkRules(request: ConfigNetworkRulesRequest): ConfigNetworkRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return configNetworkRulesWithOptions(request, runtime);
}

model ConfigUdpReflectRequest {
  config?: string(name='Config'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model ConfigUdpReflectResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigUdpReflectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfigUdpReflectResponseBody(name='body'),
}

async function configUdpReflectWithOptions(request: ConfigUdpReflectRequest, runtime: Util.RuntimeOptions): ConfigUdpReflectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigUdpReflect',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configUdpReflect(request: ConfigUdpReflectRequest): ConfigUdpReflectResponse {
  var runtime = new Util.RuntimeOptions{};
  return configUdpReflectWithOptions(request, runtime);
}

model ConfigWebCCTemplateRequest {
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
  template?: string(name='Template'),
}

model ConfigWebCCTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigWebCCTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfigWebCCTemplateResponseBody(name='body'),
}

async function configWebCCTemplateWithOptions(request: ConfigWebCCTemplateRequest, runtime: Util.RuntimeOptions): ConfigWebCCTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.template)) {
    query['Template'] = request.template;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigWebCCTemplate',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configWebCCTemplate(request: ConfigWebCCTemplateRequest): ConfigWebCCTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return configWebCCTemplateWithOptions(request, runtime);
}

model ConfigWebIpSetRequest {
  blackList?: [ string ](name='BlackList'),
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
  whiteList?: [ string ](name='WhiteList'),
}

model ConfigWebIpSetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfigWebIpSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfigWebIpSetResponseBody(name='body'),
}

async function configWebIpSetWithOptions(request: ConfigWebIpSetRequest, runtime: Util.RuntimeOptions): ConfigWebIpSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blackList)) {
    query['BlackList'] = request.blackList;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.whiteList)) {
    query['WhiteList'] = request.whiteList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigWebIpSet',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configWebIpSet(request: ConfigWebIpSetRequest): ConfigWebIpSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return configWebIpSetWithOptions(request, runtime);
}

model CreateAsyncTaskRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
  taskParams?: string(name='TaskParams'),
  taskType?: int32(name='TaskType'),
}

model CreateAsyncTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateAsyncTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAsyncTaskResponseBody(name='body'),
}

async function createAsyncTaskWithOptions(request: CreateAsyncTaskRequest, runtime: Util.RuntimeOptions): CreateAsyncTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.taskParams)) {
    query['TaskParams'] = request.taskParams;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAsyncTask',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAsyncTask(request: CreateAsyncTaskRequest): CreateAsyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAsyncTaskWithOptions(request, runtime);
}

model CreateDomainResourceRequest {
  domain?: string(name='Domain'),
  httpsExt?: string(name='HttpsExt'),
  instanceIds?: [ string ](name='InstanceIds'),
  proxyTypes?: [ 
    {
      proxyPorts?: [ int32 ](name='ProxyPorts'),
      proxyType?: string(name='ProxyType'),
    }
  ](name='ProxyTypes'),
  realServers?: [ string ](name='RealServers'),
  rsType?: int32(name='RsType'),
}

model CreateDomainResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateDomainResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDomainResourceResponseBody(name='body'),
}

async function createDomainResourceWithOptions(request: CreateDomainResourceRequest, runtime: Util.RuntimeOptions): CreateDomainResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.httpsExt)) {
    query['HttpsExt'] = request.httpsExt;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.proxyTypes)) {
    query['ProxyTypes'] = request.proxyTypes;
  }
  if (!Util.isUnset(request.realServers)) {
    query['RealServers'] = request.realServers;
  }
  if (!Util.isUnset(request.rsType)) {
    query['RsType'] = request.rsType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDomainResource',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDomainResource(request: CreateDomainResourceRequest): CreateDomainResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDomainResourceWithOptions(request, runtime);
}

model CreateNetworkRulesRequest {
  networkRules?: string(name='NetworkRules'),
}

model CreateNetworkRulesResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateNetworkRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNetworkRulesResponseBody(name='body'),
}

async function createNetworkRulesWithOptions(request: CreateNetworkRulesRequest, runtime: Util.RuntimeOptions): CreateNetworkRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.networkRules)) {
    query['NetworkRules'] = request.networkRules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNetworkRules',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNetworkRules(request: CreateNetworkRulesRequest): CreateNetworkRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNetworkRulesWithOptions(request, runtime);
}

model CreatePortRequest {
  backendPort?: string(name='BackendPort'),
  frontendPort?: string(name='FrontendPort'),
  frontendProtocol?: string(name='FrontendProtocol'),
  instanceId?: string(name='InstanceId'),
  realServers?: [ string ](name='RealServers'),
}

model CreatePortResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreatePortResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePortResponseBody(name='body'),
}

async function createPortWithOptions(request: CreatePortRequest, runtime: Util.RuntimeOptions): CreatePortResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backendPort)) {
    query['BackendPort'] = request.backendPort;
  }
  if (!Util.isUnset(request.frontendPort)) {
    query['FrontendPort'] = request.frontendPort;
  }
  if (!Util.isUnset(request.frontendProtocol)) {
    query['FrontendProtocol'] = request.frontendProtocol;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.realServers)) {
    query['RealServers'] = request.realServers;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePort',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPort(request: CreatePortRequest): CreatePortResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPortWithOptions(request, runtime);
}

model CreateSceneDefensePolicyRequest {
  endTime?: long(name='EndTime'),
  name?: string(name='Name'),
  startTime?: long(name='StartTime'),
  template?: string(name='Template'),
}

model CreateSceneDefensePolicyResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSceneDefensePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSceneDefensePolicyResponseBody(name='body'),
}

async function createSceneDefensePolicyWithOptions(request: CreateSceneDefensePolicyRequest, runtime: Util.RuntimeOptions): CreateSceneDefensePolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.template)) {
    query['Template'] = request.template;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSceneDefensePolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSceneDefensePolicy(request: CreateSceneDefensePolicyRequest): CreateSceneDefensePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSceneDefensePolicyWithOptions(request, runtime);
}

model CreateSchedulerRuleRequest {
  param?: string(name='Param'),
  resourceGroupId?: string(name='ResourceGroupId'),
  ruleName?: string(name='RuleName'),
  ruleType?: int32(name='RuleType'),
  rules?: string(name='Rules'),
}

model CreateSchedulerRuleResponseBody = {
  cname?: string(name='Cname'),
  requestId?: string(name='RequestId'),
  ruleName?: string(name='RuleName'),
}

model CreateSchedulerRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSchedulerRuleResponseBody(name='body'),
}

async function createSchedulerRuleWithOptions(request: CreateSchedulerRuleRequest, runtime: Util.RuntimeOptions): CreateSchedulerRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.param)) {
    query['Param'] = request.param;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.rules)) {
    query['Rules'] = request.rules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSchedulerRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSchedulerRule(request: CreateSchedulerRuleRequest): CreateSchedulerRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSchedulerRuleWithOptions(request, runtime);
}

model CreateTagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceIds?: [ string ](name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
}

model CreateTagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTagResourcesResponseBody(name='body'),
}

async function createTagResourcesWithOptions(request: CreateTagResourcesRequest, runtime: Util.RuntimeOptions): CreateTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTagResources',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTagResources(request: CreateTagResourcesRequest): CreateTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTagResourcesWithOptions(request, runtime);
}

model CreateWebCCRuleRequest {
  act?: string(name='Act'),
  count?: int32(name='Count'),
  domain?: string(name='Domain'),
  interval?: int32(name='Interval'),
  mode?: string(name='Mode'),
  name?: string(name='Name'),
  resourceGroupId?: string(name='ResourceGroupId'),
  ttl?: int32(name='Ttl'),
  uri?: string(name='Uri'),
}

model CreateWebCCRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateWebCCRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateWebCCRuleResponseBody(name='body'),
}

async function createWebCCRuleWithOptions(request: CreateWebCCRuleRequest, runtime: Util.RuntimeOptions): CreateWebCCRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.act)) {
    query['Act'] = request.act;
  }
  if (!Util.isUnset(request.count)) {
    query['Count'] = request.count;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.ttl)) {
    query['Ttl'] = request.ttl;
  }
  if (!Util.isUnset(request.uri)) {
    query['Uri'] = request.uri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateWebCCRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createWebCCRule(request: CreateWebCCRuleRequest): CreateWebCCRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWebCCRuleWithOptions(request, runtime);
}

model CreateWebRuleRequest {
  defenseId?: string(name='DefenseId'),
  domain?: string(name='Domain'),
  httpsExt?: string(name='HttpsExt'),
  instanceIds?: [ string ](name='InstanceIds'),
  resourceGroupId?: string(name='ResourceGroupId'),
  rsType?: int32(name='RsType'),
  rules?: string(name='Rules'),
}

model CreateWebRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateWebRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateWebRuleResponseBody(name='body'),
}

async function createWebRuleWithOptions(request: CreateWebRuleRequest, runtime: Util.RuntimeOptions): CreateWebRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defenseId)) {
    query['DefenseId'] = request.defenseId;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.httpsExt)) {
    query['HttpsExt'] = request.httpsExt;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.rsType)) {
    query['RsType'] = request.rsType;
  }
  if (!Util.isUnset(request.rules)) {
    query['Rules'] = request.rules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateWebRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createWebRule(request: CreateWebRuleRequest): CreateWebRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWebRuleWithOptions(request, runtime);
}

model DeleteAsyncTaskRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
  taskId?: int32(name='TaskId'),
}

model DeleteAsyncTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAsyncTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAsyncTaskResponseBody(name='body'),
}

async function deleteAsyncTaskWithOptions(request: DeleteAsyncTaskRequest, runtime: Util.RuntimeOptions): DeleteAsyncTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAsyncTask',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAsyncTask(request: DeleteAsyncTaskRequest): DeleteAsyncTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAsyncTaskWithOptions(request, runtime);
}

model DeleteAutoCcBlacklistRequest {
  blacklist?: string(name='Blacklist'),
  instanceId?: string(name='InstanceId'),
}

model DeleteAutoCcBlacklistResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAutoCcBlacklistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAutoCcBlacklistResponseBody(name='body'),
}

async function deleteAutoCcBlacklistWithOptions(request: DeleteAutoCcBlacklistRequest, runtime: Util.RuntimeOptions): DeleteAutoCcBlacklistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blacklist)) {
    query['Blacklist'] = request.blacklist;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAutoCcBlacklist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAutoCcBlacklist(request: DeleteAutoCcBlacklistRequest): DeleteAutoCcBlacklistResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAutoCcBlacklistWithOptions(request, runtime);
}

model DeleteAutoCcWhitelistRequest {
  instanceId?: string(name='InstanceId'),
  whitelist?: string(name='Whitelist'),
}

model DeleteAutoCcWhitelistResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAutoCcWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAutoCcWhitelistResponseBody(name='body'),
}

async function deleteAutoCcWhitelistWithOptions(request: DeleteAutoCcWhitelistRequest, runtime: Util.RuntimeOptions): DeleteAutoCcWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.whitelist)) {
    query['Whitelist'] = request.whitelist;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAutoCcWhitelist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAutoCcWhitelist(request: DeleteAutoCcWhitelistRequest): DeleteAutoCcWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAutoCcWhitelistWithOptions(request, runtime);
}

model DeleteDomainResourceRequest {
  domain?: string(name='Domain'),
}

model DeleteDomainResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDomainResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDomainResourceResponseBody(name='body'),
}

async function deleteDomainResourceWithOptions(request: DeleteDomainResourceRequest, runtime: Util.RuntimeOptions): DeleteDomainResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomainResource',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDomainResource(request: DeleteDomainResourceRequest): DeleteDomainResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainResourceWithOptions(request, runtime);
}

model DeleteNetworkRuleRequest {
  networkRule?: string(name='NetworkRule'),
}

model DeleteNetworkRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteNetworkRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNetworkRuleResponseBody(name='body'),
}

async function deleteNetworkRuleWithOptions(request: DeleteNetworkRuleRequest, runtime: Util.RuntimeOptions): DeleteNetworkRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.networkRule)) {
    query['NetworkRule'] = request.networkRule;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNetworkRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNetworkRule(request: DeleteNetworkRuleRequest): DeleteNetworkRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNetworkRuleWithOptions(request, runtime);
}

model DeletePortRequest {
  backendPort?: string(name='BackendPort'),
  frontendPort?: string(name='FrontendPort'),
  frontendProtocol?: string(name='FrontendProtocol'),
  instanceId?: string(name='InstanceId'),
  realServers?: [ string ](name='RealServers'),
}

model DeletePortResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePortResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePortResponseBody(name='body'),
}

async function deletePortWithOptions(request: DeletePortRequest, runtime: Util.RuntimeOptions): DeletePortResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backendPort)) {
    query['BackendPort'] = request.backendPort;
  }
  if (!Util.isUnset(request.frontendPort)) {
    query['FrontendPort'] = request.frontendPort;
  }
  if (!Util.isUnset(request.frontendProtocol)) {
    query['FrontendProtocol'] = request.frontendProtocol;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.realServers)) {
    query['RealServers'] = request.realServers;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePort',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePort(request: DeletePortRequest): DeletePortResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePortWithOptions(request, runtime);
}

model DeleteSceneDefensePolicyRequest {
  policyId?: string(name='PolicyId'),
}

model DeleteSceneDefensePolicyResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSceneDefensePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSceneDefensePolicyResponseBody(name='body'),
}

async function deleteSceneDefensePolicyWithOptions(request: DeleteSceneDefensePolicyRequest, runtime: Util.RuntimeOptions): DeleteSceneDefensePolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSceneDefensePolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSceneDefensePolicy(request: DeleteSceneDefensePolicyRequest): DeleteSceneDefensePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSceneDefensePolicyWithOptions(request, runtime);
}

model DeleteSchedulerRuleRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
  ruleName?: string(name='RuleName'),
}

model DeleteSchedulerRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSchedulerRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSchedulerRuleResponseBody(name='body'),
}

async function deleteSchedulerRuleWithOptions(request: DeleteSchedulerRuleRequest, runtime: Util.RuntimeOptions): DeleteSchedulerRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSchedulerRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSchedulerRule(request: DeleteSchedulerRuleRequest): DeleteSchedulerRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSchedulerRuleWithOptions(request, runtime);
}

model DeleteTagResourcesRequest {
  all?: boolean(name='All'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceIds?: [ string ](name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model DeleteTagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTagResourcesResponseBody(name='body'),
}

async function deleteTagResourcesWithOptions(request: DeleteTagResourcesRequest, runtime: Util.RuntimeOptions): DeleteTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTagResources',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTagResources(request: DeleteTagResourcesRequest): DeleteTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTagResourcesWithOptions(request, runtime);
}

model DeleteWebCCRuleRequest {
  domain?: string(name='Domain'),
  name?: string(name='Name'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DeleteWebCCRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteWebCCRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWebCCRuleResponseBody(name='body'),
}

async function deleteWebCCRuleWithOptions(request: DeleteWebCCRuleRequest, runtime: Util.RuntimeOptions): DeleteWebCCRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWebCCRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWebCCRule(request: DeleteWebCCRuleRequest): DeleteWebCCRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWebCCRuleWithOptions(request, runtime);
}

model DeleteWebCacheCustomRuleRequest {
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
  ruleNames?: [ string ](name='RuleNames'),
}

model DeleteWebCacheCustomRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteWebCacheCustomRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWebCacheCustomRuleResponseBody(name='body'),
}

async function deleteWebCacheCustomRuleWithOptions(request: DeleteWebCacheCustomRuleRequest, runtime: Util.RuntimeOptions): DeleteWebCacheCustomRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.ruleNames)) {
    query['RuleNames'] = request.ruleNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWebCacheCustomRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWebCacheCustomRule(request: DeleteWebCacheCustomRuleRequest): DeleteWebCacheCustomRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWebCacheCustomRuleWithOptions(request, runtime);
}

model DeleteWebPreciseAccessRuleRequest {
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
  ruleNames?: [ string ](name='RuleNames'),
}

model DeleteWebPreciseAccessRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteWebPreciseAccessRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWebPreciseAccessRuleResponseBody(name='body'),
}

async function deleteWebPreciseAccessRuleWithOptions(request: DeleteWebPreciseAccessRuleRequest, runtime: Util.RuntimeOptions): DeleteWebPreciseAccessRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.ruleNames)) {
    query['RuleNames'] = request.ruleNames;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWebPreciseAccessRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWebPreciseAccessRule(request: DeleteWebPreciseAccessRuleRequest): DeleteWebPreciseAccessRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWebPreciseAccessRuleWithOptions(request, runtime);
}

model DeleteWebRuleRequest {
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DeleteWebRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteWebRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWebRuleResponseBody(name='body'),
}

async function deleteWebRuleWithOptions(request: DeleteWebRuleRequest, runtime: Util.RuntimeOptions): DeleteWebRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWebRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWebRule(request: DeleteWebRuleRequest): DeleteWebRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWebRuleWithOptions(request, runtime);
}

model DescribeAsyncTasksRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeAsyncTasksResponseBody = {
  asyncTasks?: [ 
    {
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
      taskId?: long(name='TaskId'),
      taskParams?: string(name='TaskParams'),
      taskResult?: string(name='TaskResult'),
      taskStatus?: int32(name='TaskStatus'),
      taskType?: int32(name='TaskType'),
    }
  ](name='AsyncTasks'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAsyncTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAsyncTasksResponseBody(name='body'),
}

async function describeAsyncTasksWithOptions(request: DescribeAsyncTasksRequest, runtime: Util.RuntimeOptions): DescribeAsyncTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAsyncTasks',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAsyncTasks(request: DescribeAsyncTasksRequest): DescribeAsyncTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAsyncTasksWithOptions(request, runtime);
}

model DescribeAttackAnalysisMaxQpsRequest {
  endTime?: long(name='EndTime'),
  startTime?: long(name='StartTime'),
}

model DescribeAttackAnalysisMaxQpsResponseBody = {
  qps?: long(name='Qps'),
  requestId?: string(name='RequestId'),
}

model DescribeAttackAnalysisMaxQpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAttackAnalysisMaxQpsResponseBody(name='body'),
}

async function describeAttackAnalysisMaxQpsWithOptions(request: DescribeAttackAnalysisMaxQpsRequest, runtime: Util.RuntimeOptions): DescribeAttackAnalysisMaxQpsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAttackAnalysisMaxQps',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAttackAnalysisMaxQps(request: DescribeAttackAnalysisMaxQpsRequest): DescribeAttackAnalysisMaxQpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAttackAnalysisMaxQpsWithOptions(request, runtime);
}

model DescribeAutoCcBlacklistRequest {
  instanceId?: string(name='InstanceId'),
  keyWord?: string(name='KeyWord'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeAutoCcBlacklistResponseBody = {
  autoCcBlacklist?: [ 
    {
      destIp?: string(name='DestIp'),
      endTime?: long(name='EndTime'),
      sourceIp?: string(name='SourceIp'),
      type?: string(name='Type'),
    }
  ](name='AutoCcBlacklist'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeAutoCcBlacklistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAutoCcBlacklistResponseBody(name='body'),
}

async function describeAutoCcBlacklistWithOptions(request: DescribeAutoCcBlacklistRequest, runtime: Util.RuntimeOptions): DescribeAutoCcBlacklistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAutoCcBlacklist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAutoCcBlacklist(request: DescribeAutoCcBlacklistRequest): DescribeAutoCcBlacklistResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAutoCcBlacklistWithOptions(request, runtime);
}

model DescribeAutoCcListCountRequest {
  instanceId?: string(name='InstanceId'),
  queryType?: string(name='QueryType'),
}

model DescribeAutoCcListCountResponseBody = {
  blackCount?: int32(name='BlackCount'),
  requestId?: string(name='RequestId'),
  whiteCount?: int32(name='WhiteCount'),
}

model DescribeAutoCcListCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAutoCcListCountResponseBody(name='body'),
}

async function describeAutoCcListCountWithOptions(request: DescribeAutoCcListCountRequest, runtime: Util.RuntimeOptions): DescribeAutoCcListCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.queryType)) {
    query['QueryType'] = request.queryType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAutoCcListCount',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAutoCcListCount(request: DescribeAutoCcListCountRequest): DescribeAutoCcListCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAutoCcListCountWithOptions(request, runtime);
}

model DescribeAutoCcWhitelistRequest {
  instanceId?: string(name='InstanceId'),
  keyWord?: string(name='KeyWord'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeAutoCcWhitelistResponseBody = {
  autoCcWhitelist?: [ 
    {
      destIp?: string(name='DestIp'),
      endTime?: long(name='EndTime'),
      sourceIp?: string(name='SourceIp'),
      type?: string(name='Type'),
    }
  ](name='AutoCcWhitelist'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeAutoCcWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAutoCcWhitelistResponseBody(name='body'),
}

async function describeAutoCcWhitelistWithOptions(request: DescribeAutoCcWhitelistRequest, runtime: Util.RuntimeOptions): DescribeAutoCcWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAutoCcWhitelist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAutoCcWhitelist(request: DescribeAutoCcWhitelistRequest): DescribeAutoCcWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAutoCcWhitelistWithOptions(request, runtime);
}

model DescribeBackSourceCidrRequest {
  line?: string(name='Line'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeBackSourceCidrResponseBody = {
  cidrs?: [ string ](name='Cidrs'),
  requestId?: string(name='RequestId'),
}

model DescribeBackSourceCidrResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackSourceCidrResponseBody(name='body'),
}

async function describeBackSourceCidrWithOptions(request: DescribeBackSourceCidrRequest, runtime: Util.RuntimeOptions): DescribeBackSourceCidrResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.line)) {
    query['Line'] = request.line;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackSourceCidr',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackSourceCidr(request: DescribeBackSourceCidrRequest): DescribeBackSourceCidrResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackSourceCidrWithOptions(request, runtime);
}

model DescribeBlackholeStatusRequest {
  instanceIds?: [ string ](name='InstanceIds'),
}

model DescribeBlackholeStatusResponseBody = {
  blackholeStatus?: [ 
    {
      blackStatus?: string(name='BlackStatus'),
      endTime?: long(name='EndTime'),
      ip?: string(name='Ip'),
      startTime?: long(name='StartTime'),
    }
  ](name='BlackholeStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeBlackholeStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBlackholeStatusResponseBody(name='body'),
}

async function describeBlackholeStatusWithOptions(request: DescribeBlackholeStatusRequest, runtime: Util.RuntimeOptions): DescribeBlackholeStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBlackholeStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBlackholeStatus(request: DescribeBlackholeStatusRequest): DescribeBlackholeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBlackholeStatusWithOptions(request, runtime);
}

model DescribeBlockStatusRequest {
  instanceIds?: [ string ](name='InstanceIds'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeBlockStatusResponseBody = {
  requestId?: string(name='RequestId'),
  statusList?: [ 
    {
      blockStatusList?: [ 
        {
          blockStatus?: string(name='BlockStatus'),
          endTime?: long(name='EndTime'),
          line?: string(name='Line'),
          startTime?: long(name='StartTime'),
        }
      ](name='BlockStatusList'),
      ip?: string(name='Ip'),
    }
  ](name='StatusList'),
}

model DescribeBlockStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBlockStatusResponseBody(name='body'),
}

async function describeBlockStatusWithOptions(request: DescribeBlockStatusRequest, runtime: Util.RuntimeOptions): DescribeBlockStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBlockStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBlockStatus(request: DescribeBlockStatusRequest): DescribeBlockStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBlockStatusWithOptions(request, runtime);
}

model DescribeCertsRequest {
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeCertsResponseBody = {
  certs?: [ 
    {
      common?: string(name='Common'),
      domainRelated?: boolean(name='DomainRelated'),
      endDate?: string(name='EndDate'),
      id?: int32(name='Id'),
      issuer?: string(name='Issuer'),
      name?: string(name='Name'),
      startDate?: string(name='StartDate'),
    }
  ](name='Certs'),
  requestId?: string(name='RequestId'),
}

model DescribeCertsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCertsResponseBody(name='body'),
}

async function describeCertsWithOptions(request: DescribeCertsRequest, runtime: Util.RuntimeOptions): DescribeCertsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCerts',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCerts(request: DescribeCertsRequest): DescribeCertsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCertsWithOptions(request, runtime);
}

model DescribeCnameReusesRequest {
  domains?: [ string ](name='Domains'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeCnameReusesResponseBody = {
  cnameReuses?: [ 
    {
      cname?: string(name='Cname'),
      domain?: string(name='Domain'),
      enable?: int32(name='Enable'),
    }
  ](name='CnameReuses'),
  requestId?: string(name='RequestId'),
}

model DescribeCnameReusesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCnameReusesResponseBody(name='body'),
}

async function describeCnameReusesWithOptions(request: DescribeCnameReusesRequest, runtime: Util.RuntimeOptions): DescribeCnameReusesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domains)) {
    query['Domains'] = request.domains;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCnameReuses',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCnameReuses(request: DescribeCnameReusesRequest): DescribeCnameReusesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCnameReusesWithOptions(request, runtime);
}

model DescribeDDoSEventsRequest {
  endTime?: long(name='EndTime'),
  instanceIds?: [ string ](name='InstanceIds'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribeDDoSEventsResponseBody = {
  DDoSEvents?: [ 
    {
      bps?: long(name='Bps'),
      endTime?: long(name='EndTime'),
      eventType?: string(name='EventType'),
      ip?: string(name='Ip'),
      port?: string(name='Port'),
      pps?: long(name='Pps'),
      region?: string(name='Region'),
      startTime?: long(name='StartTime'),
    }
  ](name='DDoSEvents'),
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
}

model DescribeDDoSEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDDoSEventsResponseBody(name='body'),
}

async function describeDDoSEventsWithOptions(request: DescribeDDoSEventsRequest, runtime: Util.RuntimeOptions): DescribeDDoSEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDDoSEvents',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDDoSEvents(request: DescribeDDoSEventsRequest): DescribeDDoSEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDDoSEventsWithOptions(request, runtime);
}

model DescribeDDosAllEventListRequest {
  endTime?: long(name='EndTime'),
  eventType?: string(name='EventType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime'),
}

model DescribeDDosAllEventListResponseBody = {
  attackEvents?: [ 
    {
      area?: string(name='Area'),
      endTime?: long(name='EndTime'),
      eventType?: string(name='EventType'),
      ip?: string(name='Ip'),
      mbps?: long(name='Mbps'),
      port?: string(name='Port'),
      pps?: long(name='Pps'),
      startTime?: long(name='StartTime'),
    }
  ](name='AttackEvents'),
  requestId?: string(name='RequestId'),
  total?: long(name='Total'),
}

model DescribeDDosAllEventListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDDosAllEventListResponseBody(name='body'),
}

async function describeDDosAllEventListWithOptions(request: DescribeDDosAllEventListRequest, runtime: Util.RuntimeOptions): DescribeDDosAllEventListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDDosAllEventList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDDosAllEventList(request: DescribeDDosAllEventListRequest): DescribeDDosAllEventListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDDosAllEventListWithOptions(request, runtime);
}

model DescribeDDosEventAreaRequest {
  eventType?: string(name='EventType'),
  ip?: string(name='Ip'),
  startTime?: long(name='StartTime'),
}

model DescribeDDosEventAreaResponseBody = {
  areas?: [ 
    {
      area?: string(name='Area'),
      inPkts?: long(name='InPkts'),
    }
  ](name='Areas'),
  requestId?: string(name='RequestId'),
}

model DescribeDDosEventAreaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDDosEventAreaResponseBody(name='body'),
}

async function describeDDosEventAreaWithOptions(request: DescribeDDosEventAreaRequest, runtime: Util.RuntimeOptions): DescribeDDosEventAreaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDDosEventArea',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDDosEventArea(request: DescribeDDosEventAreaRequest): DescribeDDosEventAreaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDDosEventAreaWithOptions(request, runtime);
}

model DescribeDDosEventAttackTypeRequest {
  eventType?: string(name='EventType'),
  ip?: string(name='Ip'),
  startTime?: long(name='StartTime'),
}

model DescribeDDosEventAttackTypeResponseBody = {
  attackTypes?: [ 
    {
      attackType?: string(name='AttackType'),
      inPkts?: long(name='InPkts'),
    }
  ](name='AttackTypes'),
  requestId?: string(name='RequestId'),
}

model DescribeDDosEventAttackTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDDosEventAttackTypeResponseBody(name='body'),
}

async function describeDDosEventAttackTypeWithOptions(request: DescribeDDosEventAttackTypeRequest, runtime: Util.RuntimeOptions): DescribeDDosEventAttackTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDDosEventAttackType',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDDosEventAttackType(request: DescribeDDosEventAttackTypeRequest): DescribeDDosEventAttackTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDDosEventAttackTypeWithOptions(request, runtime);
}

model DescribeDDosEventIspRequest {
  eventType?: string(name='EventType'),
  ip?: string(name='Ip'),
  startTime?: long(name='StartTime'),
}

model DescribeDDosEventIspResponseBody = {
  isps?: [ 
    {
      inPkts?: long(name='InPkts'),
      isp?: string(name='Isp'),
    }
  ](name='Isps'),
  requestId?: string(name='RequestId'),
}

model DescribeDDosEventIspResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDDosEventIspResponseBody(name='body'),
}

async function describeDDosEventIspWithOptions(request: DescribeDDosEventIspRequest, runtime: Util.RuntimeOptions): DescribeDDosEventIspResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDDosEventIsp',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDDosEventIsp(request: DescribeDDosEventIspRequest): DescribeDDosEventIspResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDDosEventIspWithOptions(request, runtime);
}

model DescribeDDosEventMaxRequest {
  endTime?: long(name='EndTime'),
  startTime?: long(name='StartTime'),
}

model DescribeDDosEventMaxResponseBody = {
  cps?: long(name='Cps'),
  mbps?: long(name='Mbps'),
  qps?: long(name='Qps'),
  requestId?: string(name='RequestId'),
}

model DescribeDDosEventMaxResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDDosEventMaxResponseBody(name='body'),
}

async function describeDDosEventMaxWithOptions(request: DescribeDDosEventMaxRequest, runtime: Util.RuntimeOptions): DescribeDDosEventMaxResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDDosEventMax',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDDosEventMax(request: DescribeDDosEventMaxRequest): DescribeDDosEventMaxResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDDosEventMaxWithOptions(request, runtime);
}

model DescribeDDosEventSrcIpRequest {
  eventType?: string(name='EventType'),
  ip?: string(name='Ip'),
  range?: long(name='Range'),
  startTime?: long(name='StartTime'),
}

model DescribeDDosEventSrcIpResponseBody = {
  ips?: [ 
    {
      areaId?: string(name='AreaId'),
      isp?: string(name='Isp'),
      srcIp?: string(name='SrcIp'),
    }
  ](name='Ips'),
  requestId?: string(name='RequestId'),
}

model DescribeDDosEventSrcIpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDDosEventSrcIpResponseBody(name='body'),
}

async function describeDDosEventSrcIpWithOptions(request: DescribeDDosEventSrcIpRequest, runtime: Util.RuntimeOptions): DescribeDDosEventSrcIpResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.range)) {
    query['Range'] = request.range;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDDosEventSrcIp',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDDosEventSrcIp(request: DescribeDDosEventSrcIpRequest): DescribeDDosEventSrcIpResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDDosEventSrcIpWithOptions(request, runtime);
}

model DescribeDefenseCountStatisticsRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeDefenseCountStatisticsResponseBody = {
  defenseCountStatistics?: {
    defenseCountTotalUsageOfCurrentMonth?: int32(name='DefenseCountTotalUsageOfCurrentMonth'),
    flowPackCountRemain?: int32(name='FlowPackCountRemain'),
    maxUsableDefenseCountCurrentMonth?: int32(name='MaxUsableDefenseCountCurrentMonth'),
    secHighSpeedCountRemain?: int32(name='SecHighSpeedCountRemain'),
  }(name='DefenseCountStatistics'),
  requestId?: string(name='RequestId'),
}

model DescribeDefenseCountStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDefenseCountStatisticsResponseBody(name='body'),
}

async function describeDefenseCountStatisticsWithOptions(request: DescribeDefenseCountStatisticsRequest, runtime: Util.RuntimeOptions): DescribeDefenseCountStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDefenseCountStatistics',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDefenseCountStatistics(request: DescribeDefenseCountStatisticsRequest): DescribeDefenseCountStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDefenseCountStatisticsWithOptions(request, runtime);
}

model DescribeDefenseRecordsRequest {
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribeDefenseRecordsResponseBody = {
  defenseRecords?: [ 
    {
      attackPeak?: long(name='AttackPeak'),
      endTime?: long(name='EndTime'),
      eventCount?: int32(name='EventCount'),
      instanceId?: string(name='InstanceId'),
      startTime?: long(name='StartTime'),
      status?: int32(name='Status'),
    }
  ](name='DefenseRecords'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDefenseRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDefenseRecordsResponseBody(name='body'),
}

async function describeDefenseRecordsWithOptions(request: DescribeDefenseRecordsRequest, runtime: Util.RuntimeOptions): DescribeDefenseRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDefenseRecords',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDefenseRecords(request: DescribeDefenseRecordsRequest): DescribeDefenseRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDefenseRecordsWithOptions(request, runtime);
}

model DescribeDomainAttackEventsRequest {
  domain?: string(name='Domain'),
  endTime?: long(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribeDomainAttackEventsResponseBody = {
  domainAttackEvents?: [ 
    {
      domain?: string(name='Domain'),
      endTime?: long(name='EndTime'),
      maxQps?: long(name='MaxQps'),
      startTime?: long(name='StartTime'),
    }
  ](name='DomainAttackEvents'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDomainAttackEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainAttackEventsResponseBody(name='body'),
}

async function describeDomainAttackEventsWithOptions(request: DescribeDomainAttackEventsRequest, runtime: Util.RuntimeOptions): DescribeDomainAttackEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainAttackEvents',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainAttackEvents(request: DescribeDomainAttackEventsRequest): DescribeDomainAttackEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainAttackEventsWithOptions(request, runtime);
}

model DescribeDomainOverviewRequest {
  domain?: string(name='Domain'),
  endTime?: long(name='EndTime'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribeDomainOverviewResponseBody = {
  maxHttp?: long(name='MaxHttp'),
  maxHttps?: long(name='MaxHttps'),
  requestId?: string(name='RequestId'),
}

model DescribeDomainOverviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainOverviewResponseBody(name='body'),
}

async function describeDomainOverviewWithOptions(request: DescribeDomainOverviewRequest, runtime: Util.RuntimeOptions): DescribeDomainOverviewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainOverview',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainOverview(request: DescribeDomainOverviewRequest): DescribeDomainOverviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainOverviewWithOptions(request, runtime);
}

model DescribeDomainQPSListRequest {
  domain?: string(name='Domain'),
  endTime?: long(name='EndTime'),
  interval?: long(name='Interval'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribeDomainQPSListResponseBody = {
  domainQPSList?: [ 
    {
      attackQps?: long(name='AttackQps'),
      cacheHits?: long(name='CacheHits'),
      index?: long(name='Index'),
      maxAttackQps?: long(name='MaxAttackQps'),
      maxNormalQps?: long(name='MaxNormalQps'),
      maxQps?: long(name='MaxQps'),
      time?: long(name='Time'),
      totalCount?: long(name='TotalCount'),
      totalQps?: long(name='TotalQps'),
    }
  ](name='DomainQPSList'),
  requestId?: string(name='RequestId'),
}

model DescribeDomainQPSListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainQPSListResponseBody(name='body'),
}

async function describeDomainQPSListWithOptions(request: DescribeDomainQPSListRequest, runtime: Util.RuntimeOptions): DescribeDomainQPSListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainQPSList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainQPSList(request: DescribeDomainQPSListRequest): DescribeDomainQPSListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainQPSListWithOptions(request, runtime);
}

model DescribeDomainQpsWithCacheRequest {
  domain?: string(name='Domain'),
  endTime?: long(name='EndTime'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribeDomainQpsWithCacheResponseBody = {
  blocks?: [ string ](name='Blocks'),
  cacheHits?: [ string ](name='CacheHits'),
  ccBlockQps?: [ string ](name='CcBlockQps'),
  ccJsQps?: [ string ](name='CcJsQps'),
  interval?: int32(name='Interval'),
  ipBlockQps?: [ string ](name='IpBlockQps'),
  preciseBlocks?: [ string ](name='PreciseBlocks'),
  preciseJsQps?: [ string ](name='PreciseJsQps'),
  regionBlocks?: [ string ](name='RegionBlocks'),
  requestId?: string(name='RequestId'),
  startTime?: long(name='StartTime'),
  totals?: [ string ](name='Totals'),
}

model DescribeDomainQpsWithCacheResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainQpsWithCacheResponseBody(name='body'),
}

async function describeDomainQpsWithCacheWithOptions(request: DescribeDomainQpsWithCacheRequest, runtime: Util.RuntimeOptions): DescribeDomainQpsWithCacheResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainQpsWithCache',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainQpsWithCache(request: DescribeDomainQpsWithCacheRequest): DescribeDomainQpsWithCacheResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainQpsWithCacheWithOptions(request, runtime);
}

model DescribeDomainResourceRequest {
  domain?: string(name='Domain'),
  instanceIds?: [ string ](name='InstanceIds'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  queryDomainPattern?: string(name='QueryDomainPattern'),
}

model DescribeDomainResourceResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  webRules?: [ 
    {
      blackList?: [ string ](name='BlackList'),
      ccEnabled?: boolean(name='CcEnabled'),
      ccRuleEnabled?: boolean(name='CcRuleEnabled'),
      ccTemplate?: string(name='CcTemplate'),
      certName?: string(name='CertName'),
      cname?: string(name='Cname'),
      customCiphers?: [ string ](name='CustomCiphers'),
      domain?: string(name='Domain'),
      http2Enable?: boolean(name='Http2Enable'),
      http2HttpsEnable?: boolean(name='Http2HttpsEnable'),
      https2HttpEnable?: boolean(name='Https2HttpEnable'),
      httpsExt?: string(name='HttpsExt'),
      instanceIds?: [ string ](name='InstanceIds'),
      policyMode?: string(name='PolicyMode'),
      proxyEnabled?: boolean(name='ProxyEnabled'),
      proxyTypes?: [ 
        {
          proxyPorts?: [ string ](name='ProxyPorts'),
          proxyType?: string(name='ProxyType'),
        }
      ](name='ProxyTypes'),
      punishReason?: int32(name='PunishReason'),
      punishStatus?: boolean(name='PunishStatus'),
      realServers?: [ string ](name='RealServers'),
      rsType?: int32(name='RsType'),
      ssl13Enabled?: boolean(name='Ssl13Enabled'),
      sslCiphers?: string(name='SslCiphers'),
      sslProtocols?: string(name='SslProtocols'),
      whiteList?: [ string ](name='WhiteList'),
    }
  ](name='WebRules'),
}

model DescribeDomainResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainResourceResponseBody(name='body'),
}

async function describeDomainResourceWithOptions(request: DescribeDomainResourceRequest, runtime: Util.RuntimeOptions): DescribeDomainResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryDomainPattern)) {
    query['QueryDomainPattern'] = request.queryDomainPattern;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainResource',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainResource(request: DescribeDomainResourceRequest): DescribeDomainResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainResourceWithOptions(request, runtime);
}

model DescribeDomainStatusCodeCountRequest {
  domain?: string(name='Domain'),
  endTime?: long(name='EndTime'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribeDomainStatusCodeCountResponseBody = {
  requestId?: string(name='RequestId'),
  status200?: long(name='Status200'),
  status2XX?: long(name='Status2XX'),
  status3XX?: long(name='Status3XX'),
  status403?: long(name='Status403'),
  status404?: long(name='Status404'),
  status405?: long(name='Status405'),
  status4XX?: long(name='Status4XX'),
  status501?: long(name='Status501'),
  status502?: long(name='Status502'),
  status503?: long(name='Status503'),
  status504?: long(name='Status504'),
  status5XX?: long(name='Status5XX'),
}

model DescribeDomainStatusCodeCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainStatusCodeCountResponseBody(name='body'),
}

async function describeDomainStatusCodeCountWithOptions(request: DescribeDomainStatusCodeCountRequest, runtime: Util.RuntimeOptions): DescribeDomainStatusCodeCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainStatusCodeCount',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainStatusCodeCount(request: DescribeDomainStatusCodeCountRequest): DescribeDomainStatusCodeCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainStatusCodeCountWithOptions(request, runtime);
}

model DescribeDomainStatusCodeListRequest {
  domain?: string(name='Domain'),
  endTime?: long(name='EndTime'),
  interval?: long(name='Interval'),
  queryType?: string(name='QueryType'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribeDomainStatusCodeListResponseBody = {
  requestId?: string(name='RequestId'),
  statusCodeList?: [ 
    {
      index?: int32(name='Index'),
      status200?: long(name='Status200'),
      status2XX?: long(name='Status2XX'),
      status3XX?: long(name='Status3XX'),
      status403?: long(name='Status403'),
      status404?: long(name='Status404'),
      status405?: long(name='Status405'),
      status4XX?: long(name='Status4XX'),
      status501?: long(name='Status501'),
      status502?: long(name='Status502'),
      status503?: long(name='Status503'),
      status504?: long(name='Status504'),
      status5XX?: long(name='Status5XX'),
      time?: long(name='Time'),
    }
  ](name='StatusCodeList'),
}

model DescribeDomainStatusCodeListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainStatusCodeListResponseBody(name='body'),
}

async function describeDomainStatusCodeListWithOptions(request: DescribeDomainStatusCodeListRequest, runtime: Util.RuntimeOptions): DescribeDomainStatusCodeListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.queryType)) {
    query['QueryType'] = request.queryType;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainStatusCodeList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainStatusCodeList(request: DescribeDomainStatusCodeListRequest): DescribeDomainStatusCodeListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainStatusCodeListWithOptions(request, runtime);
}

model DescribeDomainTopAttackListRequest {
  endTime?: long(name='EndTime'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribeDomainTopAttackListResponseBody = {
  attackList?: [ 
    {
      attack?: long(name='Attack'),
      count?: long(name='Count'),
      domain?: string(name='Domain'),
    }
  ](name='AttackList'),
  requestId?: string(name='RequestId'),
}

model DescribeDomainTopAttackListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainTopAttackListResponseBody(name='body'),
}

async function describeDomainTopAttackListWithOptions(request: DescribeDomainTopAttackListRequest, runtime: Util.RuntimeOptions): DescribeDomainTopAttackListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainTopAttackList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainTopAttackList(request: DescribeDomainTopAttackListRequest): DescribeDomainTopAttackListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainTopAttackListWithOptions(request, runtime);
}

model DescribeDomainViewSourceCountriesRequest {
  domain?: string(name='Domain'),
  endTime?: long(name='EndTime'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribeDomainViewSourceCountriesResponseBody = {
  requestId?: string(name='RequestId'),
  sourceCountrys?: [ 
    {
      count?: long(name='Count'),
      countryId?: string(name='CountryId'),
    }
  ](name='SourceCountrys'),
}

model DescribeDomainViewSourceCountriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainViewSourceCountriesResponseBody(name='body'),
}

async function describeDomainViewSourceCountriesWithOptions(request: DescribeDomainViewSourceCountriesRequest, runtime: Util.RuntimeOptions): DescribeDomainViewSourceCountriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainViewSourceCountries',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainViewSourceCountries(request: DescribeDomainViewSourceCountriesRequest): DescribeDomainViewSourceCountriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainViewSourceCountriesWithOptions(request, runtime);
}

model DescribeDomainViewSourceProvincesRequest {
  domain?: string(name='Domain'),
  endTime?: long(name='EndTime'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribeDomainViewSourceProvincesResponseBody = {
  requestId?: string(name='RequestId'),
  sourceProvinces?: [ 
    {
      count?: long(name='Count'),
      provinceId?: string(name='ProvinceId'),
    }
  ](name='SourceProvinces'),
}

model DescribeDomainViewSourceProvincesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainViewSourceProvincesResponseBody(name='body'),
}

async function describeDomainViewSourceProvincesWithOptions(request: DescribeDomainViewSourceProvincesRequest, runtime: Util.RuntimeOptions): DescribeDomainViewSourceProvincesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainViewSourceProvinces',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainViewSourceProvinces(request: DescribeDomainViewSourceProvincesRequest): DescribeDomainViewSourceProvincesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainViewSourceProvincesWithOptions(request, runtime);
}

model DescribeDomainViewTopCostTimeRequest {
  domain?: string(name='Domain'),
  endTime?: long(name='EndTime'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
  top?: int32(name='Top'),
}

model DescribeDomainViewTopCostTimeResponseBody = {
  requestId?: string(name='RequestId'),
  urlList?: [ 
    {
      costTime?: float(name='CostTime'),
      domain?: string(name='Domain'),
      url?: string(name='Url'),
    }
  ](name='UrlList'),
}

model DescribeDomainViewTopCostTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainViewTopCostTimeResponseBody(name='body'),
}

async function describeDomainViewTopCostTimeWithOptions(request: DescribeDomainViewTopCostTimeRequest, runtime: Util.RuntimeOptions): DescribeDomainViewTopCostTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.top)) {
    query['Top'] = request.top;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainViewTopCostTime',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainViewTopCostTime(request: DescribeDomainViewTopCostTimeRequest): DescribeDomainViewTopCostTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainViewTopCostTimeWithOptions(request, runtime);
}

model DescribeDomainViewTopUrlRequest {
  domain?: string(name='Domain'),
  endTime?: long(name='EndTime'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
  top?: int32(name='Top'),
}

model DescribeDomainViewTopUrlResponseBody = {
  requestId?: string(name='RequestId'),
  urlList?: [ 
    {
      count?: long(name='Count'),
      domain?: string(name='Domain'),
      url?: string(name='Url'),
    }
  ](name='UrlList'),
}

model DescribeDomainViewTopUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainViewTopUrlResponseBody(name='body'),
}

async function describeDomainViewTopUrlWithOptions(request: DescribeDomainViewTopUrlRequest, runtime: Util.RuntimeOptions): DescribeDomainViewTopUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.top)) {
    query['Top'] = request.top;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomainViewTopUrl',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomainViewTopUrl(request: DescribeDomainViewTopUrlRequest): DescribeDomainViewTopUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainViewTopUrlWithOptions(request, runtime);
}

model DescribeDomainsRequest {
  instanceIds?: [ string ](name='InstanceIds'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeDomainsResponseBody = {
  domains?: [ string ](name='Domains'),
  requestId?: string(name='RequestId'),
}

model DescribeDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDomainsResponseBody(name='body'),
}

async function describeDomainsWithOptions(request: DescribeDomainsRequest, runtime: Util.RuntimeOptions): DescribeDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDomains',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDomains(request: DescribeDomainsRequest): DescribeDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDomainsWithOptions(request, runtime);
}

model DescribeElasticBandwidthSpecRequest {
  instanceId?: string(name='InstanceId'),
}

model DescribeElasticBandwidthSpecResponseBody = {
  elasticBandwidthSpec?: [ string ](name='ElasticBandwidthSpec'),
  requestId?: string(name='RequestId'),
}

model DescribeElasticBandwidthSpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeElasticBandwidthSpecResponseBody(name='body'),
}

async function describeElasticBandwidthSpecWithOptions(request: DescribeElasticBandwidthSpecRequest, runtime: Util.RuntimeOptions): DescribeElasticBandwidthSpecResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeElasticBandwidthSpec',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeElasticBandwidthSpec(request: DescribeElasticBandwidthSpecRequest): DescribeElasticBandwidthSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeElasticBandwidthSpecWithOptions(request, runtime);
}

model DescribeHealthCheckListRequest {
  networkRules?: string(name='NetworkRules'),
}

model DescribeHealthCheckListResponseBody = {
  healthCheckList?: [ 
    {
      frontendPort?: int32(name='FrontendPort'),
      healthCheck?: {
        domain?: string(name='Domain'),
        down?: int32(name='Down'),
        interval?: int32(name='Interval'),
        port?: int32(name='Port'),
        timeout?: int32(name='Timeout'),
        type?: string(name='Type'),
        up?: int32(name='Up'),
        uri?: string(name='Uri'),
      }(name='HealthCheck'),
      instanceId?: string(name='InstanceId'),
      protocol?: string(name='Protocol'),
    }
  ](name='HealthCheckList'),
  requestId?: string(name='RequestId'),
}

model DescribeHealthCheckListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHealthCheckListResponseBody(name='body'),
}

async function describeHealthCheckListWithOptions(request: DescribeHealthCheckListRequest, runtime: Util.RuntimeOptions): DescribeHealthCheckListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.networkRules)) {
    query['NetworkRules'] = request.networkRules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHealthCheckList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHealthCheckList(request: DescribeHealthCheckListRequest): DescribeHealthCheckListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHealthCheckListWithOptions(request, runtime);
}

model DescribeHealthCheckStatusRequest {
  networkRules?: string(name='NetworkRules'),
}

model DescribeHealthCheckStatusResponseBody = {
  healthCheckStatus?: [ 
    {
      frontendPort?: int32(name='FrontendPort'),
      instanceId?: string(name='InstanceId'),
      protocol?: string(name='Protocol'),
      realServerStatusList?: [ 
        {
          address?: string(name='Address'),
          status?: string(name='Status'),
        }
      ](name='RealServerStatusList'),
      status?: string(name='Status'),
    }
  ](name='HealthCheckStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeHealthCheckStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHealthCheckStatusResponseBody(name='body'),
}

async function describeHealthCheckStatusWithOptions(request: DescribeHealthCheckStatusRequest, runtime: Util.RuntimeOptions): DescribeHealthCheckStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.networkRules)) {
    query['NetworkRules'] = request.networkRules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHealthCheckStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHealthCheckStatus(request: DescribeHealthCheckStatusRequest): DescribeHealthCheckStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHealthCheckStatusWithOptions(request, runtime);
}

model DescribeInstanceDetailsRequest {
  instanceIds?: [ string ](name='InstanceIds'),
}

model DescribeInstanceDetailsResponseBody = {
  instanceDetails?: [ 
    {
      eipInfos?: [ 
        {
          eip?: string(name='Eip'),
          ipMode?: string(name='IpMode'),
          ipVersion?: string(name='IpVersion'),
          status?: string(name='Status'),
        }
      ](name='EipInfos'),
      instanceId?: string(name='InstanceId'),
      line?: string(name='Line'),
    }
  ](name='InstanceDetails'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceDetailsResponseBody(name='body'),
}

async function describeInstanceDetailsWithOptions(request: DescribeInstanceDetailsRequest, runtime: Util.RuntimeOptions): DescribeInstanceDetailsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceDetails',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceDetails(request: DescribeInstanceDetailsRequest): DescribeInstanceDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceDetailsWithOptions(request, runtime);
}

model DescribeInstanceIdsRequest {
  edition?: int32(name='Edition'),
  instanceIds?: [ string ](name='InstanceIds'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeInstanceIdsResponseBody = {
  instanceIds?: [ 
    {
      edition?: int32(name='Edition'),
      instanceId?: string(name='InstanceId'),
      ipMode?: string(name='IpMode'),
      ipVersion?: string(name='IpVersion'),
      remark?: string(name='Remark'),
    }
  ](name='InstanceIds'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceIdsResponseBody(name='body'),
}

async function describeInstanceIdsWithOptions(request: DescribeInstanceIdsRequest, runtime: Util.RuntimeOptions): DescribeInstanceIdsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.edition)) {
    query['Edition'] = request.edition;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceIds',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceIds(request: DescribeInstanceIdsRequest): DescribeInstanceIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceIdsWithOptions(request, runtime);
}

model DescribeInstanceSpecsRequest {
  instanceIds?: [ string ](name='InstanceIds'),
}

model DescribeInstanceSpecsResponseBody = {
  instanceSpecs?: [ 
    {
      bandwidthMbps?: int32(name='BandwidthMbps'),
      baseBandwidth?: int32(name='BaseBandwidth'),
      defenseCount?: int32(name='DefenseCount'),
      domainLimit?: int32(name='DomainLimit'),
      elasticBandwidth?: int32(name='ElasticBandwidth'),
      elasticBw?: int32(name='ElasticBw'),
      functionVersion?: string(name='FunctionVersion'),
      instanceId?: string(name='InstanceId'),
      portLimit?: int32(name='PortLimit'),
      qpsLimit?: int32(name='QpsLimit'),
      siteLimit?: int32(name='SiteLimit'),
    }
  ](name='InstanceSpecs'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceSpecsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceSpecsResponseBody(name='body'),
}

async function describeInstanceSpecsWithOptions(request: DescribeInstanceSpecsRequest, runtime: Util.RuntimeOptions): DescribeInstanceSpecsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceSpecs',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceSpecs(request: DescribeInstanceSpecsRequest): DescribeInstanceSpecsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceSpecsWithOptions(request, runtime);
}

model DescribeInstanceStatisticsRequest {
  instanceIds?: [ string ](name='InstanceIds'),
}

model DescribeInstanceStatisticsResponseBody = {
  instanceStatistics?: [ 
    {
      defenseCountUsage?: int32(name='DefenseCountUsage'),
      domainUsage?: int32(name='DomainUsage'),
      instanceId?: string(name='InstanceId'),
      portUsage?: int32(name='PortUsage'),
      siteUsage?: int32(name='SiteUsage'),
    }
  ](name='InstanceStatistics'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceStatisticsResponseBody(name='body'),
}

async function describeInstanceStatisticsWithOptions(request: DescribeInstanceStatisticsRequest, runtime: Util.RuntimeOptions): DescribeInstanceStatisticsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceStatistics',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceStatistics(request: DescribeInstanceStatisticsRequest): DescribeInstanceStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceStatisticsWithOptions(request, runtime);
}

model DescribeInstanceStatusRequest {
  instanceId?: string(name='InstanceId'),
  productType?: int32(name='ProductType'),
}

model DescribeInstanceStatusResponseBody = {
  instanceId?: string(name='InstanceId'),
  instanceStatus?: int32(name='InstanceStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceStatusResponseBody(name='body'),
}

async function describeInstanceStatusWithOptions(request: DescribeInstanceStatusRequest, runtime: Util.RuntimeOptions): DescribeInstanceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceStatus(request: DescribeInstanceStatusRequest): DescribeInstanceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceStatusWithOptions(request, runtime);
}

model DescribeInstancesRequest {
  edition?: int32(name='Edition'),
  enabled?: int32(name='Enabled'),
  expireEndTime?: long(name='ExpireEndTime'),
  expireStartTime?: long(name='ExpireStartTime'),
  instanceIds?: [ string ](name='InstanceIds'),
  ip?: string(name='Ip'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  remark?: string(name='Remark'),
  resourceGroupId?: string(name='ResourceGroupId'),
  status?: [ int32 ](name='Status'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model DescribeInstancesResponseBody = {
  instances?: [ 
    {
      createTime?: long(name='CreateTime'),
      debtStatus?: int32(name='DebtStatus'),
      edition?: int32(name='Edition'),
      enabled?: int32(name='Enabled'),
      expireTime?: long(name='ExpireTime'),
      instanceId?: string(name='InstanceId'),
      ipMode?: string(name='IpMode'),
      ipVersion?: string(name='IpVersion'),
      remark?: string(name='Remark'),
      status?: int32(name='Status'),
    }
  ](name='Instances'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstancesResponseBody(name='body'),
}

async function describeInstancesWithOptions(request: DescribeInstancesRequest, runtime: Util.RuntimeOptions): DescribeInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.edition)) {
    query['Edition'] = request.edition;
  }
  if (!Util.isUnset(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!Util.isUnset(request.expireEndTime)) {
    query['ExpireEndTime'] = request.expireEndTime;
  }
  if (!Util.isUnset(request.expireStartTime)) {
    query['ExpireStartTime'] = request.expireStartTime;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstances',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstances(request: DescribeInstancesRequest): DescribeInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstancesWithOptions(request, runtime);
}

model DescribeL7RsPolicyRequest {
  domain?: string(name='Domain'),
  realServers?: [ string ](name='RealServers'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeL7RsPolicyResponseBody = {
  attributes?: [ 
    {
      attribute?: {
        weight?: int32(name='Weight'),
      }(name='Attribute'),
      realServer?: string(name='RealServer'),
      rsType?: int32(name='RsType'),
    }
  ](name='Attributes'),
  proxyMode?: string(name='ProxyMode'),
  requestId?: string(name='RequestId'),
}

model DescribeL7RsPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeL7RsPolicyResponseBody(name='body'),
}

async function describeL7RsPolicyWithOptions(request: DescribeL7RsPolicyRequest, runtime: Util.RuntimeOptions): DescribeL7RsPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.realServers)) {
    query['RealServers'] = request.realServers;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeL7RsPolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeL7RsPolicy(request: DescribeL7RsPolicyRequest): DescribeL7RsPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeL7RsPolicyWithOptions(request, runtime);
}

model DescribeLayer4RulePolicyRequest {
  listeners?: string(name='Listeners'),
}

model DescribeLayer4RulePolicyResponseBody = {
  backendPort?: int32(name='BackendPort'),
  bakMode?: string(name='BakMode'),
  currentIndex?: int32(name='CurrentIndex'),
  forwardProtocol?: string(name='ForwardProtocol'),
  frontendPort?: int32(name='FrontendPort'),
  instanceId?: string(name='InstanceId'),
  priRealServers?: [ 
    {
      currentIndex?: int32(name='CurrentIndex'),
      eip?: string(name='Eip'),
      frontendPort?: int32(name='FrontendPort'),
      instanceId?: string(name='InstanceId'),
      protocol?: string(name='Protocol'),
      realServer?: string(name='RealServer'),
    }
  ](name='PriRealServers'),
  requestId?: string(name='RequestId'),
  secRealServers?: [ 
    {
      currentIndex?: int32(name='CurrentIndex'),
      eip?: string(name='Eip'),
      frontendPort?: int32(name='FrontendPort'),
      instanceId?: string(name='InstanceId'),
      protocol?: string(name='Protocol'),
      realServer?: string(name='RealServer'),
    }
  ](name='SecRealServers'),
}

model DescribeLayer4RulePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLayer4RulePolicyResponseBody(name='body'),
}

async function describeLayer4RulePolicyWithOptions(request: DescribeLayer4RulePolicyRequest, runtime: Util.RuntimeOptions): DescribeLayer4RulePolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.listeners)) {
    query['Listeners'] = request.listeners;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLayer4RulePolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLayer4RulePolicy(request: DescribeLayer4RulePolicyRequest): DescribeLayer4RulePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLayer4RulePolicyWithOptions(request, runtime);
}

model DescribeLogStoreExistStatusRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeLogStoreExistStatusResponseBody = {
  existStatus?: boolean(name='ExistStatus'),
  requestId?: string(name='RequestId'),
}

model DescribeLogStoreExistStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLogStoreExistStatusResponseBody(name='body'),
}

async function describeLogStoreExistStatusWithOptions(request: DescribeLogStoreExistStatusRequest, runtime: Util.RuntimeOptions): DescribeLogStoreExistStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogStoreExistStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLogStoreExistStatus(request: DescribeLogStoreExistStatusRequest): DescribeLogStoreExistStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogStoreExistStatusWithOptions(request, runtime);
}

model DescribeNetworkRegionBlockRequest {
  instanceId?: string(name='InstanceId'),
}

model DescribeNetworkRegionBlockResponseBody = {
  config?: {
    countries?: [ string ](name='Countries'),
    provinces?: [ string ](name='Provinces'),
    regionBlockSwitch?: string(name='RegionBlockSwitch'),
  }(name='Config'),
  requestId?: string(name='RequestId'),
}

model DescribeNetworkRegionBlockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNetworkRegionBlockResponseBody(name='body'),
}

async function describeNetworkRegionBlockWithOptions(request: DescribeNetworkRegionBlockRequest, runtime: Util.RuntimeOptions): DescribeNetworkRegionBlockResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNetworkRegionBlock',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNetworkRegionBlock(request: DescribeNetworkRegionBlockRequest): DescribeNetworkRegionBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworkRegionBlockWithOptions(request, runtime);
}

model DescribeNetworkRuleAttributesRequest {
  networkRules?: string(name='NetworkRules'),
}

model DescribeNetworkRuleAttributesResponseBody = {
  networkRuleAttributes?: [ 
    {
      config?: {
        cc?: {
          sblack?: [ 
            {
              cnt?: int32(name='Cnt'),
              during?: int32(name='During'),
              expires?: int32(name='Expires'),
              type?: int32(name='Type'),
            }
          ](name='Sblack'),
        }(name='Cc'),
        nodataConn?: string(name='NodataConn'),
        payloadLen?: {
          max?: int32(name='Max'),
          min?: int32(name='Min'),
        }(name='PayloadLen'),
        persistenceTimeout?: int32(name='PersistenceTimeout'),
        sla?: {
          cps?: int32(name='Cps'),
          cpsEnable?: int32(name='CpsEnable'),
          maxconn?: int32(name='Maxconn'),
          maxconnEnable?: int32(name='MaxconnEnable'),
        }(name='Sla'),
        slimit?: {
          bps?: long(name='Bps'),
          cps?: int32(name='Cps'),
          cpsEnable?: int32(name='CpsEnable'),
          cpsMode?: int32(name='CpsMode'),
          maxconn?: int32(name='Maxconn'),
          maxconnEnable?: int32(name='MaxconnEnable'),
          pps?: long(name='Pps'),
        }(name='Slimit'),
        synproxy?: string(name='Synproxy'),
      }(name='Config'),
      frontendPort?: int32(name='FrontendPort'),
      instanceId?: string(name='InstanceId'),
      protocol?: string(name='Protocol'),
    }
  ](name='NetworkRuleAttributes'),
  requestId?: string(name='RequestId'),
}

model DescribeNetworkRuleAttributesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNetworkRuleAttributesResponseBody(name='body'),
}

async function describeNetworkRuleAttributesWithOptions(request: DescribeNetworkRuleAttributesRequest, runtime: Util.RuntimeOptions): DescribeNetworkRuleAttributesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.networkRules)) {
    query['NetworkRules'] = request.networkRules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNetworkRuleAttributes',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNetworkRuleAttributes(request: DescribeNetworkRuleAttributesRequest): DescribeNetworkRuleAttributesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworkRuleAttributesWithOptions(request, runtime);
}

model DescribeNetworkRulesRequest {
  forwardProtocol?: string(name='ForwardProtocol'),
  frontendPort?: int32(name='FrontendPort'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeNetworkRulesResponseBody = {
  networkRules?: [ 
    {
      backendPort?: int32(name='BackendPort'),
      frontendPort?: int32(name='FrontendPort'),
      instanceId?: string(name='InstanceId'),
      isAutoCreate?: boolean(name='IsAutoCreate'),
      protocol?: string(name='Protocol'),
      realServers?: [ string ](name='RealServers'),
    }
  ](name='NetworkRules'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeNetworkRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNetworkRulesResponseBody(name='body'),
}

async function describeNetworkRulesWithOptions(request: DescribeNetworkRulesRequest, runtime: Util.RuntimeOptions): DescribeNetworkRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.forwardProtocol)) {
    query['ForwardProtocol'] = request.forwardProtocol;
  }
  if (!Util.isUnset(request.frontendPort)) {
    query['FrontendPort'] = request.frontendPort;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNetworkRules',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNetworkRules(request: DescribeNetworkRulesRequest): DescribeNetworkRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNetworkRulesWithOptions(request, runtime);
}

model DescribeOpEntitiesRequest {
  endTime?: long(name='EndTime'),
  entityObject?: string(name='EntityObject'),
  entityType?: int32(name='EntityType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribeOpEntitiesResponseBody = {
  opEntities?: [ 
    {
      entityObject?: string(name='EntityObject'),
      entityType?: int32(name='EntityType'),
      gmtCreate?: long(name='GmtCreate'),
      opAccount?: string(name='OpAccount'),
      opAction?: int32(name='OpAction'),
      opDesc?: string(name='OpDesc'),
    }
  ](name='OpEntities'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeOpEntitiesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOpEntitiesResponseBody(name='body'),
}

async function describeOpEntitiesWithOptions(request: DescribeOpEntitiesRequest, runtime: Util.RuntimeOptions): DescribeOpEntitiesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.entityObject)) {
    query['EntityObject'] = request.entityObject;
  }
  if (!Util.isUnset(request.entityType)) {
    query['EntityType'] = request.entityType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOpEntities',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOpEntities(request: DescribeOpEntitiesRequest): DescribeOpEntitiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOpEntitiesWithOptions(request, runtime);
}

model DescribePortRequest {
  frontendPort?: int32(name='FrontendPort'),
  frontendProtocol?: string(name='FrontendProtocol'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribePortResponseBody = {
  networkRules?: [ 
    {
      backendPort?: int32(name='BackendPort'),
      frontendPort?: int32(name='FrontendPort'),
      frontendProtocol?: string(name='FrontendProtocol'),
      instanceId?: string(name='InstanceId'),
      isAutoCreate?: boolean(name='IsAutoCreate'),
      realServers?: [ string ](name='RealServers'),
    }
  ](name='NetworkRules'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribePortResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePortResponseBody(name='body'),
}

async function describePortWithOptions(request: DescribePortRequest, runtime: Util.RuntimeOptions): DescribePortResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.frontendPort)) {
    query['FrontendPort'] = request.frontendPort;
  }
  if (!Util.isUnset(request.frontendProtocol)) {
    query['FrontendProtocol'] = request.frontendProtocol;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePort',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePort(request: DescribePortRequest): DescribePortResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePortWithOptions(request, runtime);
}

model DescribePortAttackMaxFlowRequest {
  endTime?: long(name='EndTime'),
  instanceIds?: [ string ](name='InstanceIds'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribePortAttackMaxFlowResponseBody = {
  bps?: long(name='Bps'),
  pps?: long(name='Pps'),
  requestId?: string(name='RequestId'),
}

model DescribePortAttackMaxFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePortAttackMaxFlowResponseBody(name='body'),
}

async function describePortAttackMaxFlowWithOptions(request: DescribePortAttackMaxFlowRequest, runtime: Util.RuntimeOptions): DescribePortAttackMaxFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePortAttackMaxFlow',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePortAttackMaxFlow(request: DescribePortAttackMaxFlowRequest): DescribePortAttackMaxFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePortAttackMaxFlowWithOptions(request, runtime);
}

model DescribePortAutoCcStatusRequest {
  instanceIds?: [ string ](name='InstanceIds'),
}

model DescribePortAutoCcStatusResponseBody = {
  portAutoCcStatus?: [ 
    {
      mode?: string(name='Mode'),
      switch?: string(name='Switch'),
      webMode?: string(name='WebMode'),
      webSwitch?: string(name='WebSwitch'),
    }
  ](name='PortAutoCcStatus'),
  requestId?: string(name='RequestId'),
}

model DescribePortAutoCcStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePortAutoCcStatusResponseBody(name='body'),
}

async function describePortAutoCcStatusWithOptions(request: DescribePortAutoCcStatusRequest, runtime: Util.RuntimeOptions): DescribePortAutoCcStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePortAutoCcStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePortAutoCcStatus(request: DescribePortAutoCcStatusRequest): DescribePortAutoCcStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePortAutoCcStatusWithOptions(request, runtime);
}

model DescribePortConnsCountRequest {
  endTime?: long(name='EndTime'),
  instanceIds?: [ string ](name='InstanceIds'),
  port?: string(name='Port'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribePortConnsCountResponseBody = {
  actConns?: long(name='ActConns'),
  conns?: long(name='Conns'),
  cps?: long(name='Cps'),
  inActConns?: long(name='InActConns'),
  requestId?: string(name='RequestId'),
}

model DescribePortConnsCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePortConnsCountResponseBody(name='body'),
}

async function describePortConnsCountWithOptions(request: DescribePortConnsCountRequest, runtime: Util.RuntimeOptions): DescribePortConnsCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePortConnsCount',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePortConnsCount(request: DescribePortConnsCountRequest): DescribePortConnsCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePortConnsCountWithOptions(request, runtime);
}

model DescribePortConnsListRequest {
  endTime?: long(name='EndTime'),
  instanceIds?: [ string ](name='InstanceIds'),
  interval?: int32(name='Interval'),
  port?: string(name='Port'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribePortConnsListResponseBody = {
  connsList?: [ 
    {
      actConns?: long(name='ActConns'),
      conns?: long(name='Conns'),
      cps?: long(name='Cps'),
      inActConns?: long(name='InActConns'),
      index?: long(name='Index'),
    }
  ](name='ConnsList'),
  requestId?: string(name='RequestId'),
}

model DescribePortConnsListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePortConnsListResponseBody(name='body'),
}

async function describePortConnsListWithOptions(request: DescribePortConnsListRequest, runtime: Util.RuntimeOptions): DescribePortConnsListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePortConnsList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePortConnsList(request: DescribePortConnsListRequest): DescribePortConnsListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePortConnsListWithOptions(request, runtime);
}

model DescribePortFlowListRequest {
  endTime?: long(name='EndTime'),
  instanceIds?: [ string ](name='InstanceIds'),
  interval?: int32(name='Interval'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribePortFlowListResponseBody = {
  portFlowList?: [ 
    {
      attackBps?: long(name='AttackBps'),
      attackPps?: long(name='AttackPps'),
      inBps?: long(name='InBps'),
      inPps?: long(name='InPps'),
      index?: long(name='Index'),
      outBps?: long(name='OutBps'),
      outPps?: long(name='OutPps'),
      region?: string(name='Region'),
      time?: long(name='Time'),
    }
  ](name='PortFlowList'),
  requestId?: string(name='RequestId'),
}

model DescribePortFlowListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePortFlowListResponseBody(name='body'),
}

async function describePortFlowListWithOptions(request: DescribePortFlowListRequest, runtime: Util.RuntimeOptions): DescribePortFlowListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePortFlowList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePortFlowList(request: DescribePortFlowListRequest): DescribePortFlowListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePortFlowListWithOptions(request, runtime);
}

model DescribePortMaxConnsRequest {
  endTime?: long(name='EndTime'),
  instanceIds?: [ string ](name='InstanceIds'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribePortMaxConnsResponseBody = {
  portMaxConns?: [ 
    {
      cps?: long(name='Cps'),
      ip?: string(name='Ip'),
      port?: string(name='Port'),
    }
  ](name='PortMaxConns'),
  requestId?: string(name='RequestId'),
}

model DescribePortMaxConnsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePortMaxConnsResponseBody(name='body'),
}

async function describePortMaxConnsWithOptions(request: DescribePortMaxConnsRequest, runtime: Util.RuntimeOptions): DescribePortMaxConnsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePortMaxConns',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePortMaxConns(request: DescribePortMaxConnsRequest): DescribePortMaxConnsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePortMaxConnsWithOptions(request, runtime);
}

model DescribePortViewSourceCountriesRequest {
  endTime?: long(name='EndTime'),
  instanceIds?: [ string ](name='InstanceIds'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribePortViewSourceCountriesResponseBody = {
  requestId?: string(name='RequestId'),
  sourceCountrys?: [ 
    {
      count?: long(name='Count'),
      countryId?: string(name='CountryId'),
    }
  ](name='SourceCountrys'),
}

model DescribePortViewSourceCountriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePortViewSourceCountriesResponseBody(name='body'),
}

async function describePortViewSourceCountriesWithOptions(request: DescribePortViewSourceCountriesRequest, runtime: Util.RuntimeOptions): DescribePortViewSourceCountriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePortViewSourceCountries',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePortViewSourceCountries(request: DescribePortViewSourceCountriesRequest): DescribePortViewSourceCountriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePortViewSourceCountriesWithOptions(request, runtime);
}

model DescribePortViewSourceIspsRequest {
  endTime?: long(name='EndTime'),
  instanceIds?: [ string ](name='InstanceIds'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribePortViewSourceIspsResponseBody = {
  isps?: [ 
    {
      count?: long(name='Count'),
      ispId?: string(name='IspId'),
    }
  ](name='Isps'),
  requestId?: string(name='RequestId'),
}

model DescribePortViewSourceIspsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePortViewSourceIspsResponseBody(name='body'),
}

async function describePortViewSourceIspsWithOptions(request: DescribePortViewSourceIspsRequest, runtime: Util.RuntimeOptions): DescribePortViewSourceIspsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePortViewSourceIsps',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePortViewSourceIsps(request: DescribePortViewSourceIspsRequest): DescribePortViewSourceIspsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePortViewSourceIspsWithOptions(request, runtime);
}

model DescribePortViewSourceProvincesRequest {
  endTime?: long(name='EndTime'),
  instanceIds?: [ string ](name='InstanceIds'),
  resourceGroupId?: string(name='ResourceGroupId'),
  startTime?: long(name='StartTime'),
}

model DescribePortViewSourceProvincesResponseBody = {
  requestId?: string(name='RequestId'),
  sourceProvinces?: [ 
    {
      count?: long(name='Count'),
      provinceId?: string(name='ProvinceId'),
    }
  ](name='SourceProvinces'),
}

model DescribePortViewSourceProvincesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePortViewSourceProvincesResponseBody(name='body'),
}

async function describePortViewSourceProvincesWithOptions(request: DescribePortViewSourceProvincesRequest, runtime: Util.RuntimeOptions): DescribePortViewSourceProvincesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePortViewSourceProvinces',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePortViewSourceProvinces(request: DescribePortViewSourceProvincesRequest): DescribePortViewSourceProvincesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePortViewSourceProvincesWithOptions(request, runtime);
}

model DescribeSceneDefenseObjectsRequest {
  policyId?: string(name='PolicyId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeSceneDefenseObjectsResponseBody = {
  objects?: [ 
    {
      domain?: string(name='Domain'),
      policyId?: string(name='PolicyId'),
      vip?: string(name='Vip'),
    }
  ](name='Objects'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeSceneDefenseObjectsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSceneDefenseObjectsResponseBody(name='body'),
}

async function describeSceneDefenseObjectsWithOptions(request: DescribeSceneDefenseObjectsRequest, runtime: Util.RuntimeOptions): DescribeSceneDefenseObjectsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSceneDefenseObjects',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSceneDefenseObjects(request: DescribeSceneDefenseObjectsRequest): DescribeSceneDefenseObjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSceneDefenseObjectsWithOptions(request, runtime);
}

model DescribeSceneDefensePoliciesRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
  status?: string(name='Status'),
  template?: string(name='Template'),
}

model DescribeSceneDefensePoliciesResponseBody = {
  policies?: [ 
    {
      done?: int32(name='Done'),
      endTime?: long(name='EndTime'),
      name?: string(name='Name'),
      objectCount?: int32(name='ObjectCount'),
      policyId?: string(name='PolicyId'),
      runtimePolicies?: [ 
        {
          newValue?: string(name='NewValue'),
          policyType?: int32(name='PolicyType'),
          status?: int32(name='Status'),
          oldValue?: string(name='oldValue'),
        }
      ](name='RuntimePolicies'),
      startTime?: long(name='StartTime'),
      status?: int32(name='Status'),
      template?: string(name='Template'),
    }
  ](name='Policies'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeSceneDefensePoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSceneDefensePoliciesResponseBody(name='body'),
}

async function describeSceneDefensePoliciesWithOptions(request: DescribeSceneDefensePoliciesRequest, runtime: Util.RuntimeOptions): DescribeSceneDefensePoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.template)) {
    query['Template'] = request.template;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSceneDefensePolicies',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSceneDefensePolicies(request: DescribeSceneDefensePoliciesRequest): DescribeSceneDefensePoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSceneDefensePoliciesWithOptions(request, runtime);
}

model DescribeSchedulerRulesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  ruleName?: string(name='RuleName'),
}

model DescribeSchedulerRulesResponseBody = {
  requestId?: string(name='RequestId'),
  schedulerRules?: [ 
    {
      cname?: string(name='Cname'),
      param?: {
        paramData?: {
          cloudInstanceId?: string(name='CloudInstanceId'),
        }(name='ParamData'),
        paramType?: string(name='ParamType'),
      }(name='Param'),
      ruleName?: string(name='RuleName'),
      ruleType?: string(name='RuleType'),
      rules?: [ 
        {
          priority?: int32(name='Priority'),
          regionId?: string(name='RegionId'),
          restoreDelay?: int32(name='RestoreDelay'),
          status?: int32(name='Status'),
          type?: string(name='Type'),
          value?: string(name='Value'),
          valueType?: int32(name='ValueType'),
        }
      ](name='Rules'),
    }
  ](name='SchedulerRules'),
  totalCount?: string(name='TotalCount'),
}

model DescribeSchedulerRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSchedulerRulesResponseBody(name='body'),
}

async function describeSchedulerRulesWithOptions(request: DescribeSchedulerRulesRequest, runtime: Util.RuntimeOptions): DescribeSchedulerRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSchedulerRules',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSchedulerRules(request: DescribeSchedulerRulesRequest): DescribeSchedulerRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSchedulerRulesWithOptions(request, runtime);
}

model DescribeSlsAuthStatusRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeSlsAuthStatusResponseBody = {
  requestId?: string(name='RequestId'),
  slsAuthStatus?: boolean(name='SlsAuthStatus'),
}

model DescribeSlsAuthStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSlsAuthStatusResponseBody(name='body'),
}

async function describeSlsAuthStatusWithOptions(request: DescribeSlsAuthStatusRequest, runtime: Util.RuntimeOptions): DescribeSlsAuthStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSlsAuthStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSlsAuthStatus(request: DescribeSlsAuthStatusRequest): DescribeSlsAuthStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlsAuthStatusWithOptions(request, runtime);
}

model DescribeSlsLogstoreInfoRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeSlsLogstoreInfoResponseBody = {
  logStore?: string(name='LogStore'),
  project?: string(name='Project'),
  quota?: long(name='Quota'),
  requestId?: string(name='RequestId'),
  ttl?: int32(name='Ttl'),
  used?: long(name='Used'),
}

model DescribeSlsLogstoreInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSlsLogstoreInfoResponseBody(name='body'),
}

async function describeSlsLogstoreInfoWithOptions(request: DescribeSlsLogstoreInfoRequest, runtime: Util.RuntimeOptions): DescribeSlsLogstoreInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSlsLogstoreInfo',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSlsLogstoreInfo(request: DescribeSlsLogstoreInfoRequest): DescribeSlsLogstoreInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlsLogstoreInfoWithOptions(request, runtime);
}

model DescribeSlsOpenStatusRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeSlsOpenStatusResponseBody = {
  requestId?: string(name='RequestId'),
  slsOpenStatus?: boolean(name='SlsOpenStatus'),
}

model DescribeSlsOpenStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSlsOpenStatusResponseBody(name='body'),
}

async function describeSlsOpenStatusWithOptions(request: DescribeSlsOpenStatusRequest, runtime: Util.RuntimeOptions): DescribeSlsOpenStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSlsOpenStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSlsOpenStatus(request: DescribeSlsOpenStatusRequest): DescribeSlsOpenStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlsOpenStatusWithOptions(request, runtime);
}

model DescribeStsGrantStatusRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
  role?: string(name='Role'),
}

model DescribeStsGrantStatusResponseBody = {
  requestId?: string(name='RequestId'),
  stsGrant?: {
    status?: int32(name='Status'),
  }(name='StsGrant'),
}

model DescribeStsGrantStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeStsGrantStatusResponseBody(name='body'),
}

async function describeStsGrantStatusWithOptions(request: DescribeStsGrantStatusRequest, runtime: Util.RuntimeOptions): DescribeStsGrantStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.role)) {
    query['Role'] = request.role;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeStsGrantStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeStsGrantStatus(request: DescribeStsGrantStatusRequest): DescribeStsGrantStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeStsGrantStatusWithOptions(request, runtime);
}

model DescribeSystemLogRequest {
  endTime?: long(name='EndTime'),
  entityObject?: string(name='EntityObject'),
  entityType?: int32(name='EntityType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: long(name='StartTime'),
}

model DescribeSystemLogResponseBody = {
  requestId?: string(name='RequestId'),
  systemLog?: [ 
    {
      entityObject?: string(name='EntityObject'),
      entityType?: int32(name='EntityType'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      opAccount?: string(name='OpAccount'),
      opAction?: int32(name='OpAction'),
      opDesc?: string(name='OpDesc'),
      status?: int32(name='Status'),
    }
  ](name='SystemLog'),
  total?: long(name='Total'),
}

model DescribeSystemLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSystemLogResponseBody(name='body'),
}

async function describeSystemLogWithOptions(request: DescribeSystemLogRequest, runtime: Util.RuntimeOptions): DescribeSystemLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.entityObject)) {
    query['EntityObject'] = request.entityObject;
  }
  if (!Util.isUnset(request.entityType)) {
    query['EntityType'] = request.entityType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSystemLog',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSystemLog(request: DescribeSystemLogRequest): DescribeSystemLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSystemLogWithOptions(request, runtime);
}

model DescribeTagKeysRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceType?: string(name='ResourceType'),
}

model DescribeTagKeysResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  tagKeys?: [ 
    {
      tagCount?: int32(name='TagCount'),
      tagKey?: string(name='TagKey'),
    }
  ](name='TagKeys'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeTagKeysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTagKeysResponseBody(name='body'),
}

async function describeTagKeysWithOptions(request: DescribeTagKeysRequest, runtime: Util.RuntimeOptions): DescribeTagKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTagKeys',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTagKeys(request: DescribeTagKeysRequest): DescribeTagKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagKeysWithOptions(request, runtime);
}

model DescribeTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceIds?: [ string ](name='ResourceIds'),
  resourceType?: string(name='ResourceType'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
}

model DescribeTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model DescribeTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTagResourcesResponseBody(name='body'),
}

async function describeTagResourcesWithOptions(request: DescribeTagResourcesRequest, runtime: Util.RuntimeOptions): DescribeTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTagResources',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTagResources(request: DescribeTagResourcesRequest): DescribeTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagResourcesWithOptions(request, runtime);
}

model DescribeUdpReflectRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model DescribeUdpReflectResponseBody = {
  requestId?: string(name='RequestId'),
  udpSports?: [ string ](name='UdpSports'),
}

model DescribeUdpReflectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUdpReflectResponseBody(name='body'),
}

async function describeUdpReflectWithOptions(request: DescribeUdpReflectRequest, runtime: Util.RuntimeOptions): DescribeUdpReflectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUdpReflect',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUdpReflect(request: DescribeUdpReflectRequest): DescribeUdpReflectResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUdpReflectWithOptions(request, runtime);
}

model DescribeUnBlackholeCountRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeUnBlackholeCountResponseBody = {
  remainCount?: int32(name='RemainCount'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeUnBlackholeCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUnBlackholeCountResponseBody(name='body'),
}

async function describeUnBlackholeCountWithOptions(request: DescribeUnBlackholeCountRequest, runtime: Util.RuntimeOptions): DescribeUnBlackholeCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUnBlackholeCount',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUnBlackholeCount(request: DescribeUnBlackholeCountRequest): DescribeUnBlackholeCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUnBlackholeCountWithOptions(request, runtime);
}

model DescribeUnBlockCountRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeUnBlockCountResponseBody = {
  remainCount?: int32(name='RemainCount'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeUnBlockCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUnBlockCountResponseBody(name='body'),
}

async function describeUnBlockCountWithOptions(request: DescribeUnBlockCountRequest, runtime: Util.RuntimeOptions): DescribeUnBlockCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUnBlockCount',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUnBlockCount(request: DescribeUnBlockCountRequest): DescribeUnBlockCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUnBlockCountWithOptions(request, runtime);
}

model DescribeWebAccessLogDispatchStatusRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeWebAccessLogDispatchStatusResponseBody = {
  requestId?: string(name='RequestId'),
  slsConfigStatus?: [ 
    {
      domain?: string(name='Domain'),
      enable?: boolean(name='Enable'),
    }
  ](name='SlsConfigStatus'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeWebAccessLogDispatchStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebAccessLogDispatchStatusResponseBody(name='body'),
}

async function describeWebAccessLogDispatchStatusWithOptions(request: DescribeWebAccessLogDispatchStatusRequest, runtime: Util.RuntimeOptions): DescribeWebAccessLogDispatchStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebAccessLogDispatchStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebAccessLogDispatchStatus(request: DescribeWebAccessLogDispatchStatusRequest): DescribeWebAccessLogDispatchStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebAccessLogDispatchStatusWithOptions(request, runtime);
}

model DescribeWebAccessLogEmptyCountRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeWebAccessLogEmptyCountResponseBody = {
  availableCount?: int32(name='AvailableCount'),
  requestId?: string(name='RequestId'),
}

model DescribeWebAccessLogEmptyCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebAccessLogEmptyCountResponseBody(name='body'),
}

async function describeWebAccessLogEmptyCountWithOptions(request: DescribeWebAccessLogEmptyCountRequest, runtime: Util.RuntimeOptions): DescribeWebAccessLogEmptyCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebAccessLogEmptyCount',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebAccessLogEmptyCount(request: DescribeWebAccessLogEmptyCountRequest): DescribeWebAccessLogEmptyCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebAccessLogEmptyCountWithOptions(request, runtime);
}

model DescribeWebAccessLogStatusRequest {
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeWebAccessLogStatusResponseBody = {
  requestId?: string(name='RequestId'),
  slsLogstore?: string(name='SlsLogstore'),
  slsProject?: string(name='SlsProject'),
  slsStatus?: boolean(name='SlsStatus'),
}

model DescribeWebAccessLogStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebAccessLogStatusResponseBody(name='body'),
}

async function describeWebAccessLogStatusWithOptions(request: DescribeWebAccessLogStatusRequest, runtime: Util.RuntimeOptions): DescribeWebAccessLogStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebAccessLogStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebAccessLogStatus(request: DescribeWebAccessLogStatusRequest): DescribeWebAccessLogStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebAccessLogStatusWithOptions(request, runtime);
}

model DescribeWebAccessModeRequest {
  domains?: [ string ](name='Domains'),
}

model DescribeWebAccessModeResponseBody = {
  domainModes?: [ 
    {
      accessMode?: int32(name='AccessMode'),
      domain?: string(name='Domain'),
    }
  ](name='DomainModes'),
  requestId?: string(name='RequestId'),
}

model DescribeWebAccessModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebAccessModeResponseBody(name='body'),
}

async function describeWebAccessModeWithOptions(request: DescribeWebAccessModeRequest, runtime: Util.RuntimeOptions): DescribeWebAccessModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domains)) {
    query['Domains'] = request.domains;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebAccessMode',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebAccessMode(request: DescribeWebAccessModeRequest): DescribeWebAccessModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebAccessModeWithOptions(request, runtime);
}

model DescribeWebAreaBlockConfigsRequest {
  domains?: [ string ](name='Domains'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeWebAreaBlockConfigsResponseBody = {
  areaBlockConfigs?: [ 
    {
      domain?: string(name='Domain'),
      regionList?: [ 
        {
          block?: int32(name='Block'),
          region?: string(name='Region'),
        }
      ](name='RegionList'),
    }
  ](name='AreaBlockConfigs'),
  requestId?: string(name='RequestId'),
}

model DescribeWebAreaBlockConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebAreaBlockConfigsResponseBody(name='body'),
}

async function describeWebAreaBlockConfigsWithOptions(request: DescribeWebAreaBlockConfigsRequest, runtime: Util.RuntimeOptions): DescribeWebAreaBlockConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domains)) {
    query['Domains'] = request.domains;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebAreaBlockConfigs',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebAreaBlockConfigs(request: DescribeWebAreaBlockConfigsRequest): DescribeWebAreaBlockConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebAreaBlockConfigsWithOptions(request, runtime);
}

model DescribeWebCCRulesRequest {
  domain?: string(name='Domain'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeWebCCRulesResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  webCCRules?: [ 
    {
      act?: string(name='Act'),
      count?: int32(name='Count'),
      interval?: int32(name='Interval'),
      mode?: string(name='Mode'),
      name?: string(name='Name'),
      ttl?: int32(name='Ttl'),
      uri?: string(name='Uri'),
    }
  ](name='WebCCRules'),
}

model DescribeWebCCRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebCCRulesResponseBody(name='body'),
}

async function describeWebCCRulesWithOptions(request: DescribeWebCCRulesRequest, runtime: Util.RuntimeOptions): DescribeWebCCRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebCCRules',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebCCRules(request: DescribeWebCCRulesRequest): DescribeWebCCRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebCCRulesWithOptions(request, runtime);
}

model DescribeWebCacheConfigsRequest {
  domains?: [ string ](name='Domains'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeWebCacheConfigsResponseBody = {
  domainCacheConfigs?: [ 
    {
      customRules?: [ 
        {
          cacheTtl?: long(name='CacheTtl'),
          mode?: string(name='Mode'),
          name?: string(name='Name'),
          uri?: string(name='Uri'),
        }
      ](name='CustomRules'),
      domain?: string(name='Domain'),
      enable?: int32(name='Enable'),
      mode?: string(name='Mode'),
    }
  ](name='DomainCacheConfigs'),
  requestId?: string(name='RequestId'),
}

model DescribeWebCacheConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebCacheConfigsResponseBody(name='body'),
}

async function describeWebCacheConfigsWithOptions(request: DescribeWebCacheConfigsRequest, runtime: Util.RuntimeOptions): DescribeWebCacheConfigsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domains)) {
    query['Domains'] = request.domains;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebCacheConfigs',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebCacheConfigs(request: DescribeWebCacheConfigsRequest): DescribeWebCacheConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebCacheConfigsWithOptions(request, runtime);
}

model DescribeWebCcProtectSwitchRequest {
  domains?: [ string ](name='Domains'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeWebCcProtectSwitchResponseBody = {
  protectSwitchList?: [ 
    {
      aiMode?: string(name='AiMode'),
      aiRuleEnable?: int32(name='AiRuleEnable'),
      aiTemplate?: string(name='AiTemplate'),
      blackWhiteListEnable?: int32(name='BlackWhiteListEnable'),
      ccCustomRuleEnable?: int32(name='CcCustomRuleEnable'),
      ccEnable?: int32(name='CcEnable'),
      ccTemplate?: string(name='CcTemplate'),
      domain?: string(name='Domain'),
      preciseRuleEnable?: int32(name='PreciseRuleEnable'),
      regionBlockEnable?: int32(name='RegionBlockEnable'),
    }
  ](name='ProtectSwitchList'),
  requestId?: string(name='RequestId'),
}

model DescribeWebCcProtectSwitchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebCcProtectSwitchResponseBody(name='body'),
}

async function describeWebCcProtectSwitchWithOptions(request: DescribeWebCcProtectSwitchRequest, runtime: Util.RuntimeOptions): DescribeWebCcProtectSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domains)) {
    query['Domains'] = request.domains;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebCcProtectSwitch',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebCcProtectSwitch(request: DescribeWebCcProtectSwitchRequest): DescribeWebCcProtectSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebCcProtectSwitchWithOptions(request, runtime);
}

model DescribeWebCustomPortsRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeWebCustomPortsResponseBody = {
  requestId?: string(name='RequestId'),
  webCustomPorts?: [ 
    {
      proxyPorts?: [ string ](name='ProxyPorts'),
      proxyType?: string(name='ProxyType'),
    }
  ](name='WebCustomPorts'),
}

model DescribeWebCustomPortsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebCustomPortsResponseBody(name='body'),
}

async function describeWebCustomPortsWithOptions(request: DescribeWebCustomPortsRequest, runtime: Util.RuntimeOptions): DescribeWebCustomPortsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebCustomPorts',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebCustomPorts(request: DescribeWebCustomPortsRequest): DescribeWebCustomPortsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebCustomPortsWithOptions(request, runtime);
}

model DescribeWebInstanceRelationsRequest {
  domains?: [ string ](name='Domains'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeWebInstanceRelationsResponseBody = {
  requestId?: string(name='RequestId'),
  webInstanceRelations?: [ 
    {
      domain?: string(name='Domain'),
      instanceDetails?: [ 
        {
          eipList?: [ string ](name='EipList'),
          functionVersion?: string(name='FunctionVersion'),
          instanceId?: string(name='InstanceId'),
        }
      ](name='InstanceDetails'),
    }
  ](name='WebInstanceRelations'),
}

model DescribeWebInstanceRelationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebInstanceRelationsResponseBody(name='body'),
}

async function describeWebInstanceRelationsWithOptions(request: DescribeWebInstanceRelationsRequest, runtime: Util.RuntimeOptions): DescribeWebInstanceRelationsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domains)) {
    query['Domains'] = request.domains;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebInstanceRelations',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebInstanceRelations(request: DescribeWebInstanceRelationsRequest): DescribeWebInstanceRelationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebInstanceRelationsWithOptions(request, runtime);
}

model DescribeWebPreciseAccessRuleRequest {
  domains?: [ string ](name='Domains'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeWebPreciseAccessRuleResponseBody = {
  preciseAccessConfigList?: [ 
    {
      domain?: string(name='Domain'),
      ruleList?: [ 
        {
          action?: string(name='Action'),
          conditionList?: [ 
            {
              content?: string(name='Content'),
              field?: string(name='Field'),
              headerName?: string(name='HeaderName'),
              matchMethod?: string(name='MatchMethod'),
            }
          ](name='ConditionList'),
          expires?: long(name='Expires'),
          name?: string(name='Name'),
          owner?: string(name='Owner'),
        }
      ](name='RuleList'),
    }
  ](name='PreciseAccessConfigList'),
  requestId?: string(name='RequestId'),
}

model DescribeWebPreciseAccessRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebPreciseAccessRuleResponseBody(name='body'),
}

async function describeWebPreciseAccessRuleWithOptions(request: DescribeWebPreciseAccessRuleRequest, runtime: Util.RuntimeOptions): DescribeWebPreciseAccessRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domains)) {
    query['Domains'] = request.domains;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebPreciseAccessRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebPreciseAccessRule(request: DescribeWebPreciseAccessRuleRequest): DescribeWebPreciseAccessRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebPreciseAccessRuleWithOptions(request, runtime);
}

model DescribeWebRulesRequest {
  cname?: string(name='Cname'),
  domain?: string(name='Domain'),
  instanceIds?: [ string ](name='InstanceIds'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  queryDomainPattern?: string(name='QueryDomainPattern'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeWebRulesResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  webRules?: [ 
    {
      blackList?: [ string ](name='BlackList'),
      ccEnabled?: boolean(name='CcEnabled'),
      ccRuleEnabled?: boolean(name='CcRuleEnabled'),
      ccTemplate?: string(name='CcTemplate'),
      certName?: string(name='CertName'),
      cname?: string(name='Cname'),
      customCiphers?: [ string ](name='CustomCiphers'),
      domain?: string(name='Domain'),
      gmCert?: {
        certId?: string(name='CertId'),
        gmEnable?: long(name='GmEnable'),
        gmOnly?: long(name='GmOnly'),
      }(name='GmCert'),
      http2Enable?: boolean(name='Http2Enable'),
      http2HttpsEnable?: boolean(name='Http2HttpsEnable'),
      https2HttpEnable?: boolean(name='Https2HttpEnable'),
      ocspEnabled?: boolean(name='OcspEnabled'),
      policyMode?: string(name='PolicyMode'),
      proxyEnabled?: boolean(name='ProxyEnabled'),
      proxyTypes?: [ 
        {
          proxyPorts?: [ string ](name='ProxyPorts'),
          proxyType?: string(name='ProxyType'),
        }
      ](name='ProxyTypes'),
      punishReason?: int32(name='PunishReason'),
      punishStatus?: boolean(name='PunishStatus'),
      realServers?: [ 
        {
          realServer?: string(name='RealServer'),
          rsType?: int32(name='RsType'),
        }
      ](name='RealServers'),
      ssl13Enabled?: boolean(name='Ssl13Enabled'),
      sslCiphers?: string(name='SslCiphers'),
      sslProtocols?: string(name='SslProtocols'),
      whiteList?: [ string ](name='WhiteList'),
    }
  ](name='WebRules'),
}

model DescribeWebRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebRulesResponseBody(name='body'),
}

async function describeWebRulesWithOptions(request: DescribeWebRulesRequest, runtime: Util.RuntimeOptions): DescribeWebRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cname)) {
    query['Cname'] = request.cname;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryDomainPattern)) {
    query['QueryDomainPattern'] = request.queryDomainPattern;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebRules',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebRules(request: DescribeWebRulesRequest): DescribeWebRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebRulesWithOptions(request, runtime);
}

model DetachSceneDefenseObjectRequest {
  objectType?: string(name='ObjectType'),
  objects?: string(name='Objects'),
  policyId?: string(name='PolicyId'),
}

model DetachSceneDefenseObjectResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DetachSceneDefenseObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachSceneDefenseObjectResponseBody(name='body'),
}

async function detachSceneDefenseObjectWithOptions(request: DetachSceneDefenseObjectRequest, runtime: Util.RuntimeOptions): DetachSceneDefenseObjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.objectType)) {
    query['ObjectType'] = request.objectType;
  }
  if (!Util.isUnset(request.objects)) {
    query['Objects'] = request.objects;
  }
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachSceneDefenseObject',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachSceneDefenseObject(request: DetachSceneDefenseObjectRequest): DetachSceneDefenseObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachSceneDefenseObjectWithOptions(request, runtime);
}

model DisableSceneDefensePolicyRequest {
  policyId?: string(name='PolicyId'),
}

model DisableSceneDefensePolicyResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableSceneDefensePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableSceneDefensePolicyResponseBody(name='body'),
}

async function disableSceneDefensePolicyWithOptions(request: DisableSceneDefensePolicyRequest, runtime: Util.RuntimeOptions): DisableSceneDefensePolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableSceneDefensePolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableSceneDefensePolicy(request: DisableSceneDefensePolicyRequest): DisableSceneDefensePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableSceneDefensePolicyWithOptions(request, runtime);
}

model DisableWebAccessLogConfigRequest {
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DisableWebAccessLogConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableWebAccessLogConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableWebAccessLogConfigResponseBody(name='body'),
}

async function disableWebAccessLogConfigWithOptions(request: DisableWebAccessLogConfigRequest, runtime: Util.RuntimeOptions): DisableWebAccessLogConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableWebAccessLogConfig',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableWebAccessLogConfig(request: DisableWebAccessLogConfigRequest): DisableWebAccessLogConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableWebAccessLogConfigWithOptions(request, runtime);
}

model DisableWebCCRequest {
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DisableWebCCResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableWebCCResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableWebCCResponseBody(name='body'),
}

async function disableWebCCWithOptions(request: DisableWebCCRequest, runtime: Util.RuntimeOptions): DisableWebCCResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableWebCC',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableWebCC(request: DisableWebCCRequest): DisableWebCCResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableWebCCWithOptions(request, runtime);
}

model DisableWebCCRuleRequest {
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DisableWebCCRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableWebCCRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableWebCCRuleResponseBody(name='body'),
}

async function disableWebCCRuleWithOptions(request: DisableWebCCRuleRequest, runtime: Util.RuntimeOptions): DisableWebCCRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableWebCCRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableWebCCRule(request: DisableWebCCRuleRequest): DisableWebCCRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableWebCCRuleWithOptions(request, runtime);
}

model EmptyAutoCcBlacklistRequest {
  instanceId?: string(name='InstanceId'),
}

model EmptyAutoCcBlacklistResponseBody = {
  requestId?: string(name='RequestId'),
}

model EmptyAutoCcBlacklistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EmptyAutoCcBlacklistResponseBody(name='body'),
}

async function emptyAutoCcBlacklistWithOptions(request: EmptyAutoCcBlacklistRequest, runtime: Util.RuntimeOptions): EmptyAutoCcBlacklistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EmptyAutoCcBlacklist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function emptyAutoCcBlacklist(request: EmptyAutoCcBlacklistRequest): EmptyAutoCcBlacklistResponse {
  var runtime = new Util.RuntimeOptions{};
  return emptyAutoCcBlacklistWithOptions(request, runtime);
}

model EmptyAutoCcWhitelistRequest {
  instanceId?: string(name='InstanceId'),
}

model EmptyAutoCcWhitelistResponseBody = {
  requestId?: string(name='RequestId'),
}

model EmptyAutoCcWhitelistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EmptyAutoCcWhitelistResponseBody(name='body'),
}

async function emptyAutoCcWhitelistWithOptions(request: EmptyAutoCcWhitelistRequest, runtime: Util.RuntimeOptions): EmptyAutoCcWhitelistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EmptyAutoCcWhitelist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function emptyAutoCcWhitelist(request: EmptyAutoCcWhitelistRequest): EmptyAutoCcWhitelistResponse {
  var runtime = new Util.RuntimeOptions{};
  return emptyAutoCcWhitelistWithOptions(request, runtime);
}

model EmptySlsLogstoreRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
}

model EmptySlsLogstoreResponseBody = {
  requestId?: string(name='RequestId'),
}

model EmptySlsLogstoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EmptySlsLogstoreResponseBody(name='body'),
}

async function emptySlsLogstoreWithOptions(request: EmptySlsLogstoreRequest, runtime: Util.RuntimeOptions): EmptySlsLogstoreResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EmptySlsLogstore',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function emptySlsLogstore(request: EmptySlsLogstoreRequest): EmptySlsLogstoreResponse {
  var runtime = new Util.RuntimeOptions{};
  return emptySlsLogstoreWithOptions(request, runtime);
}

model EnableSceneDefensePolicyRequest {
  policyId?: string(name='PolicyId'),
}

model EnableSceneDefensePolicyResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableSceneDefensePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableSceneDefensePolicyResponseBody(name='body'),
}

async function enableSceneDefensePolicyWithOptions(request: EnableSceneDefensePolicyRequest, runtime: Util.RuntimeOptions): EnableSceneDefensePolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableSceneDefensePolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableSceneDefensePolicy(request: EnableSceneDefensePolicyRequest): EnableSceneDefensePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableSceneDefensePolicyWithOptions(request, runtime);
}

model EnableWebAccessLogConfigRequest {
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model EnableWebAccessLogConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableWebAccessLogConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableWebAccessLogConfigResponseBody(name='body'),
}

async function enableWebAccessLogConfigWithOptions(request: EnableWebAccessLogConfigRequest, runtime: Util.RuntimeOptions): EnableWebAccessLogConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableWebAccessLogConfig',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableWebAccessLogConfig(request: EnableWebAccessLogConfigRequest): EnableWebAccessLogConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableWebAccessLogConfigWithOptions(request, runtime);
}

model EnableWebCCRequest {
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model EnableWebCCResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableWebCCResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableWebCCResponseBody(name='body'),
}

async function enableWebCCWithOptions(request: EnableWebCCRequest, runtime: Util.RuntimeOptions): EnableWebCCResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableWebCC',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableWebCC(request: EnableWebCCRequest): EnableWebCCResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableWebCCWithOptions(request, runtime);
}

model EnableWebCCRuleRequest {
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model EnableWebCCRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableWebCCRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableWebCCRuleResponseBody(name='body'),
}

async function enableWebCCRuleWithOptions(request: EnableWebCCRuleRequest, runtime: Util.RuntimeOptions): EnableWebCCRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableWebCCRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableWebCCRule(request: EnableWebCCRuleRequest): EnableWebCCRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableWebCCRuleWithOptions(request, runtime);
}

model ModifyBlackholeStatusRequest {
  blackholeStatus?: string(name='BlackholeStatus'),
  instanceId?: string(name='InstanceId'),
}

model ModifyBlackholeStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBlackholeStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyBlackholeStatusResponseBody(name='body'),
}

async function modifyBlackholeStatusWithOptions(request: ModifyBlackholeStatusRequest, runtime: Util.RuntimeOptions): ModifyBlackholeStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.blackholeStatus)) {
    query['BlackholeStatus'] = request.blackholeStatus;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBlackholeStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyBlackholeStatus(request: ModifyBlackholeStatusRequest): ModifyBlackholeStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBlackholeStatusWithOptions(request, runtime);
}

model ModifyBlockStatusRequest {
  duration?: int32(name='Duration'),
  instanceId?: string(name='InstanceId'),
  lines?: [ string ](name='Lines'),
  status?: string(name='Status'),
}

model ModifyBlockStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyBlockStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyBlockStatusResponseBody(name='body'),
}

async function modifyBlockStatusWithOptions(request: ModifyBlockStatusRequest, runtime: Util.RuntimeOptions): ModifyBlockStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lines)) {
    query['Lines'] = request.lines;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBlockStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyBlockStatus(request: ModifyBlockStatusRequest): ModifyBlockStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBlockStatusWithOptions(request, runtime);
}

model ModifyCnameReuseRequest {
  cname?: string(name='Cname'),
  domain?: string(name='Domain'),
  enable?: int32(name='Enable'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ModifyCnameReuseResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyCnameReuseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyCnameReuseResponseBody(name='body'),
}

async function modifyCnameReuseWithOptions(request: ModifyCnameReuseRequest, runtime: Util.RuntimeOptions): ModifyCnameReuseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cname)) {
    query['Cname'] = request.cname;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCnameReuse',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyCnameReuse(request: ModifyCnameReuseRequest): ModifyCnameReuseResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCnameReuseWithOptions(request, runtime);
}

model ModifyDomainResourceRequest {
  domain?: string(name='Domain'),
  httpsExt?: string(name='HttpsExt'),
  instanceIds?: [ string ](name='InstanceIds'),
  proxyTypes?: [ 
    {
      proxyPorts?: [ int32 ](name='ProxyPorts'),
      proxyType?: string(name='ProxyType'),
    }
  ](name='ProxyTypes'),
  realServers?: [ string ](name='RealServers'),
  rsType?: int32(name='RsType'),
}

model ModifyDomainResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDomainResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDomainResourceResponseBody(name='body'),
}

async function modifyDomainResourceWithOptions(request: ModifyDomainResourceRequest, runtime: Util.RuntimeOptions): ModifyDomainResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.httpsExt)) {
    query['HttpsExt'] = request.httpsExt;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.proxyTypes)) {
    query['ProxyTypes'] = request.proxyTypes;
  }
  if (!Util.isUnset(request.realServers)) {
    query['RealServers'] = request.realServers;
  }
  if (!Util.isUnset(request.rsType)) {
    query['RsType'] = request.rsType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDomainResource',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDomainResource(request: ModifyDomainResourceRequest): ModifyDomainResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDomainResourceWithOptions(request, runtime);
}

model ModifyElasticBandWidthRequest {
  elasticBandwidth?: int32(name='ElasticBandwidth'),
  instanceId?: string(name='InstanceId'),
}

model ModifyElasticBandWidthResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyElasticBandWidthResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyElasticBandWidthResponseBody(name='body'),
}

async function modifyElasticBandWidthWithOptions(request: ModifyElasticBandWidthRequest, runtime: Util.RuntimeOptions): ModifyElasticBandWidthResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.elasticBandwidth)) {
    query['ElasticBandwidth'] = request.elasticBandwidth;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyElasticBandWidth',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyElasticBandWidth(request: ModifyElasticBandWidthRequest): ModifyElasticBandWidthResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyElasticBandWidthWithOptions(request, runtime);
}

model ModifyFullLogTtlRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
  ttl?: int32(name='Ttl'),
}

model ModifyFullLogTtlResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyFullLogTtlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyFullLogTtlResponseBody(name='body'),
}

async function modifyFullLogTtlWithOptions(request: ModifyFullLogTtlRequest, runtime: Util.RuntimeOptions): ModifyFullLogTtlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.ttl)) {
    query['Ttl'] = request.ttl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFullLogTtl',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyFullLogTtl(request: ModifyFullLogTtlRequest): ModifyFullLogTtlResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFullLogTtlWithOptions(request, runtime);
}

model ModifyHealthCheckConfigRequest {
  forwardProtocol?: string(name='ForwardProtocol'),
  frontendPort?: int32(name='FrontendPort'),
  healthCheck?: string(name='HealthCheck'),
  instanceId?: string(name='InstanceId'),
}

model ModifyHealthCheckConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHealthCheckConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyHealthCheckConfigResponseBody(name='body'),
}

async function modifyHealthCheckConfigWithOptions(request: ModifyHealthCheckConfigRequest, runtime: Util.RuntimeOptions): ModifyHealthCheckConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.forwardProtocol)) {
    query['ForwardProtocol'] = request.forwardProtocol;
  }
  if (!Util.isUnset(request.frontendPort)) {
    query['FrontendPort'] = request.frontendPort;
  }
  if (!Util.isUnset(request.healthCheck)) {
    query['HealthCheck'] = request.healthCheck;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHealthCheckConfig',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHealthCheckConfig(request: ModifyHealthCheckConfigRequest): ModifyHealthCheckConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHealthCheckConfigWithOptions(request, runtime);
}

model ModifyHttp2EnableRequest {
  domain?: string(name='Domain'),
  enable?: int32(name='Enable'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ModifyHttp2EnableResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHttp2EnableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyHttp2EnableResponseBody(name='body'),
}

async function modifyHttp2EnableWithOptions(request: ModifyHttp2EnableRequest, runtime: Util.RuntimeOptions): ModifyHttp2EnableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHttp2Enable',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHttp2Enable(request: ModifyHttp2EnableRequest): ModifyHttp2EnableResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHttp2EnableWithOptions(request, runtime);
}

model ModifyInstanceRemarkRequest {
  instanceId?: string(name='InstanceId'),
  remark?: string(name='Remark'),
}

model ModifyInstanceRemarkResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceRemarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceRemarkResponseBody(name='body'),
}

async function modifyInstanceRemarkWithOptions(request: ModifyInstanceRemarkRequest, runtime: Util.RuntimeOptions): ModifyInstanceRemarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceRemark',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceRemark(request: ModifyInstanceRemarkRequest): ModifyInstanceRemarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceRemarkWithOptions(request, runtime);
}

model ModifyNetworkRuleAttributeRequest {
  config?: string(name='Config'),
  forwardProtocol?: string(name='ForwardProtocol'),
  frontendPort?: int32(name='FrontendPort'),
  instanceId?: string(name='InstanceId'),
}

model ModifyNetworkRuleAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyNetworkRuleAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyNetworkRuleAttributeResponseBody(name='body'),
}

async function modifyNetworkRuleAttributeWithOptions(request: ModifyNetworkRuleAttributeRequest, runtime: Util.RuntimeOptions): ModifyNetworkRuleAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.forwardProtocol)) {
    query['ForwardProtocol'] = request.forwardProtocol;
  }
  if (!Util.isUnset(request.frontendPort)) {
    query['FrontendPort'] = request.frontendPort;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyNetworkRuleAttribute',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyNetworkRuleAttribute(request: ModifyNetworkRuleAttributeRequest): ModifyNetworkRuleAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyNetworkRuleAttributeWithOptions(request, runtime);
}

model ModifyPortRequest {
  backendPort?: string(name='BackendPort'),
  frontendPort?: string(name='FrontendPort'),
  frontendProtocol?: string(name='FrontendProtocol'),
  instanceId?: string(name='InstanceId'),
  realServers?: [ string ](name='RealServers'),
}

model ModifyPortResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyPortResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyPortResponseBody(name='body'),
}

async function modifyPortWithOptions(request: ModifyPortRequest, runtime: Util.RuntimeOptions): ModifyPortResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backendPort)) {
    query['BackendPort'] = request.backendPort;
  }
  if (!Util.isUnset(request.frontendPort)) {
    query['FrontendPort'] = request.frontendPort;
  }
  if (!Util.isUnset(request.frontendProtocol)) {
    query['FrontendProtocol'] = request.frontendProtocol;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.realServers)) {
    query['RealServers'] = request.realServers;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPort',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyPort(request: ModifyPortRequest): ModifyPortResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPortWithOptions(request, runtime);
}

model ModifyPortAutoCcStatusRequest {
  instanceId?: string(name='InstanceId'),
  mode?: string(name='Mode'),
  switch?: string(name='Switch'),
}

model ModifyPortAutoCcStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyPortAutoCcStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyPortAutoCcStatusResponseBody(name='body'),
}

async function modifyPortAutoCcStatusWithOptions(request: ModifyPortAutoCcStatusRequest, runtime: Util.RuntimeOptions): ModifyPortAutoCcStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.switch)) {
    query['Switch'] = request.switch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPortAutoCcStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyPortAutoCcStatus(request: ModifyPortAutoCcStatusRequest): ModifyPortAutoCcStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPortAutoCcStatusWithOptions(request, runtime);
}

model ModifySceneDefensePolicyRequest {
  endTime?: long(name='EndTime'),
  name?: string(name='Name'),
  policyId?: string(name='PolicyId'),
  startTime?: long(name='StartTime'),
  template?: string(name='Template'),
}

model ModifySceneDefensePolicyResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifySceneDefensePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySceneDefensePolicyResponseBody(name='body'),
}

async function modifySceneDefensePolicyWithOptions(request: ModifySceneDefensePolicyRequest, runtime: Util.RuntimeOptions): ModifySceneDefensePolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.template)) {
    query['Template'] = request.template;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySceneDefensePolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySceneDefensePolicy(request: ModifySceneDefensePolicyRequest): ModifySceneDefensePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySceneDefensePolicyWithOptions(request, runtime);
}

model ModifySchedulerRuleRequest {
  param?: string(name='Param'),
  resourceGroupId?: string(name='ResourceGroupId'),
  ruleName?: string(name='RuleName'),
  ruleType?: int32(name='RuleType'),
  rules?: string(name='Rules'),
}

model ModifySchedulerRuleResponseBody = {
  cname?: string(name='Cname'),
  requestId?: string(name='RequestId'),
  ruleName?: string(name='RuleName'),
}

model ModifySchedulerRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySchedulerRuleResponseBody(name='body'),
}

async function modifySchedulerRuleWithOptions(request: ModifySchedulerRuleRequest, runtime: Util.RuntimeOptions): ModifySchedulerRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.param)) {
    query['Param'] = request.param;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.rules)) {
    query['Rules'] = request.rules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySchedulerRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySchedulerRule(request: ModifySchedulerRuleRequest): ModifySchedulerRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySchedulerRuleWithOptions(request, runtime);
}

model ModifyTlsConfigRequest {
  config?: string(name='Config'),
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ModifyTlsConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyTlsConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyTlsConfigResponseBody(name='body'),
}

async function modifyTlsConfigWithOptions(request: ModifyTlsConfigRequest, runtime: Util.RuntimeOptions): ModifyTlsConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyTlsConfig',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyTlsConfig(request: ModifyTlsConfigRequest): ModifyTlsConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyTlsConfigWithOptions(request, runtime);
}

model ModifyWebAIProtectModeRequest {
  config?: string(name='Config'),
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ModifyWebAIProtectModeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebAIProtectModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebAIProtectModeResponseBody(name='body'),
}

async function modifyWebAIProtectModeWithOptions(request: ModifyWebAIProtectModeRequest, runtime: Util.RuntimeOptions): ModifyWebAIProtectModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebAIProtectMode',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebAIProtectMode(request: ModifyWebAIProtectModeRequest): ModifyWebAIProtectModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebAIProtectModeWithOptions(request, runtime);
}

model ModifyWebAIProtectSwitchRequest {
  config?: string(name='Config'),
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ModifyWebAIProtectSwitchResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebAIProtectSwitchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebAIProtectSwitchResponseBody(name='body'),
}

async function modifyWebAIProtectSwitchWithOptions(request: ModifyWebAIProtectSwitchRequest, runtime: Util.RuntimeOptions): ModifyWebAIProtectSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebAIProtectSwitch',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebAIProtectSwitch(request: ModifyWebAIProtectSwitchRequest): ModifyWebAIProtectSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebAIProtectSwitchWithOptions(request, runtime);
}

model ModifyWebAccessModeRequest {
  accessMode?: int32(name='AccessMode'),
  domain?: string(name='Domain'),
}

model ModifyWebAccessModeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebAccessModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebAccessModeResponseBody(name='body'),
}

async function modifyWebAccessModeWithOptions(request: ModifyWebAccessModeRequest, runtime: Util.RuntimeOptions): ModifyWebAccessModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessMode)) {
    query['AccessMode'] = request.accessMode;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebAccessMode',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebAccessMode(request: ModifyWebAccessModeRequest): ModifyWebAccessModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebAccessModeWithOptions(request, runtime);
}

model ModifyWebAreaBlockRequest {
  domain?: string(name='Domain'),
  regions?: [ string ](name='Regions'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ModifyWebAreaBlockResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebAreaBlockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebAreaBlockResponseBody(name='body'),
}

async function modifyWebAreaBlockWithOptions(request: ModifyWebAreaBlockRequest, runtime: Util.RuntimeOptions): ModifyWebAreaBlockResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.regions)) {
    query['Regions'] = request.regions;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebAreaBlock',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebAreaBlock(request: ModifyWebAreaBlockRequest): ModifyWebAreaBlockResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebAreaBlockWithOptions(request, runtime);
}

model ModifyWebAreaBlockSwitchRequest {
  config?: string(name='Config'),
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ModifyWebAreaBlockSwitchResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebAreaBlockSwitchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebAreaBlockSwitchResponseBody(name='body'),
}

async function modifyWebAreaBlockSwitchWithOptions(request: ModifyWebAreaBlockSwitchRequest, runtime: Util.RuntimeOptions): ModifyWebAreaBlockSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebAreaBlockSwitch',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebAreaBlockSwitch(request: ModifyWebAreaBlockSwitchRequest): ModifyWebAreaBlockSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebAreaBlockSwitchWithOptions(request, runtime);
}

model ModifyWebCCRuleRequest {
  act?: string(name='Act'),
  count?: int32(name='Count'),
  domain?: string(name='Domain'),
  interval?: int32(name='Interval'),
  mode?: string(name='Mode'),
  name?: string(name='Name'),
  resourceGroupId?: string(name='ResourceGroupId'),
  ttl?: int32(name='Ttl'),
  uri?: string(name='Uri'),
}

model ModifyWebCCRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebCCRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebCCRuleResponseBody(name='body'),
}

async function modifyWebCCRuleWithOptions(request: ModifyWebCCRuleRequest, runtime: Util.RuntimeOptions): ModifyWebCCRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.act)) {
    query['Act'] = request.act;
  }
  if (!Util.isUnset(request.count)) {
    query['Count'] = request.count;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.ttl)) {
    query['Ttl'] = request.ttl;
  }
  if (!Util.isUnset(request.uri)) {
    query['Uri'] = request.uri;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebCCRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebCCRule(request: ModifyWebCCRuleRequest): ModifyWebCCRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebCCRuleWithOptions(request, runtime);
}

model ModifyWebCacheCustomRuleRequest {
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
  rules?: string(name='Rules'),
}

model ModifyWebCacheCustomRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebCacheCustomRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebCacheCustomRuleResponseBody(name='body'),
}

async function modifyWebCacheCustomRuleWithOptions(request: ModifyWebCacheCustomRuleRequest, runtime: Util.RuntimeOptions): ModifyWebCacheCustomRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.rules)) {
    query['Rules'] = request.rules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebCacheCustomRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebCacheCustomRule(request: ModifyWebCacheCustomRuleRequest): ModifyWebCacheCustomRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebCacheCustomRuleWithOptions(request, runtime);
}

model ModifyWebCacheModeRequest {
  domain?: string(name='Domain'),
  mode?: string(name='Mode'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ModifyWebCacheModeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebCacheModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebCacheModeResponseBody(name='body'),
}

async function modifyWebCacheModeWithOptions(request: ModifyWebCacheModeRequest, runtime: Util.RuntimeOptions): ModifyWebCacheModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebCacheMode',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebCacheMode(request: ModifyWebCacheModeRequest): ModifyWebCacheModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebCacheModeWithOptions(request, runtime);
}

model ModifyWebCacheSwitchRequest {
  domain?: string(name='Domain'),
  enable?: int32(name='Enable'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ModifyWebCacheSwitchResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebCacheSwitchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebCacheSwitchResponseBody(name='body'),
}

async function modifyWebCacheSwitchWithOptions(request: ModifyWebCacheSwitchRequest, runtime: Util.RuntimeOptions): ModifyWebCacheSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebCacheSwitch',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebCacheSwitch(request: ModifyWebCacheSwitchRequest): ModifyWebCacheSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebCacheSwitchWithOptions(request, runtime);
}

model ModifyWebIpSetSwitchRequest {
  config?: string(name='Config'),
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ModifyWebIpSetSwitchResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebIpSetSwitchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebIpSetSwitchResponseBody(name='body'),
}

async function modifyWebIpSetSwitchWithOptions(request: ModifyWebIpSetSwitchRequest, runtime: Util.RuntimeOptions): ModifyWebIpSetSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebIpSetSwitch',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebIpSetSwitch(request: ModifyWebIpSetSwitchRequest): ModifyWebIpSetSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebIpSetSwitchWithOptions(request, runtime);
}

model ModifyWebPreciseAccessRuleRequest {
  domain?: string(name='Domain'),
  expires?: int32(name='Expires'),
  resourceGroupId?: string(name='ResourceGroupId'),
  rules?: string(name='Rules'),
}

model ModifyWebPreciseAccessRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebPreciseAccessRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebPreciseAccessRuleResponseBody(name='body'),
}

async function modifyWebPreciseAccessRuleWithOptions(request: ModifyWebPreciseAccessRuleRequest, runtime: Util.RuntimeOptions): ModifyWebPreciseAccessRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.expires)) {
    query['Expires'] = request.expires;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.rules)) {
    query['Rules'] = request.rules;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebPreciseAccessRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebPreciseAccessRule(request: ModifyWebPreciseAccessRuleRequest): ModifyWebPreciseAccessRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebPreciseAccessRuleWithOptions(request, runtime);
}

model ModifyWebPreciseAccessSwitchRequest {
  config?: string(name='Config'),
  domain?: string(name='Domain'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ModifyWebPreciseAccessSwitchResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebPreciseAccessSwitchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebPreciseAccessSwitchResponseBody(name='body'),
}

async function modifyWebPreciseAccessSwitchWithOptions(request: ModifyWebPreciseAccessSwitchRequest, runtime: Util.RuntimeOptions): ModifyWebPreciseAccessSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebPreciseAccessSwitch',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebPreciseAccessSwitch(request: ModifyWebPreciseAccessSwitchRequest): ModifyWebPreciseAccessSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebPreciseAccessSwitchWithOptions(request, runtime);
}

model ModifyWebRuleRequest {
  domain?: string(name='Domain'),
  httpsExt?: string(name='HttpsExt'),
  instanceIds?: [ string ](name='InstanceIds'),
  proxyTypes?: string(name='ProxyTypes'),
  realServers?: [ string ](name='RealServers'),
  resourceGroupId?: string(name='ResourceGroupId'),
  rsType?: int32(name='RsType'),
}

model ModifyWebRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyWebRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebRuleResponseBody(name='body'),
}

async function modifyWebRuleWithOptions(request: ModifyWebRuleRequest, runtime: Util.RuntimeOptions): ModifyWebRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.httpsExt)) {
    query['HttpsExt'] = request.httpsExt;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.proxyTypes)) {
    query['ProxyTypes'] = request.proxyTypes;
  }
  if (!Util.isUnset(request.realServers)) {
    query['RealServers'] = request.realServers;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.rsType)) {
    query['RsType'] = request.rsType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebRule(request: ModifyWebRuleRequest): ModifyWebRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebRuleWithOptions(request, runtime);
}

model ReleaseInstanceRequest {
  instanceId?: string(name='InstanceId'),
}

model ReleaseInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseInstanceResponseBody(name='body'),
}

async function releaseInstanceWithOptions(request: ReleaseInstanceRequest, runtime: Util.RuntimeOptions): ReleaseInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseInstance',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseInstance(request: ReleaseInstanceRequest): ReleaseInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseInstanceWithOptions(request, runtime);
}

model SwitchSchedulerRuleRequest {
  ruleName?: string(name='RuleName'),
  ruleType?: int32(name='RuleType'),
  switchData?: string(name='SwitchData'),
}

model SwitchSchedulerRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model SwitchSchedulerRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SwitchSchedulerRuleResponseBody(name='body'),
}

async function switchSchedulerRuleWithOptions(request: SwitchSchedulerRuleRequest, runtime: Util.RuntimeOptions): SwitchSchedulerRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.switchData)) {
    query['SwitchData'] = request.switchData;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchSchedulerRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function switchSchedulerRule(request: SwitchSchedulerRuleRequest): SwitchSchedulerRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchSchedulerRuleWithOptions(request, runtime);
}

