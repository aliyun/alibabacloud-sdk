/**
 *
 */
import OpenApi;
import OpenApi.OpenApiUtil;

extends OpenApi;


init(config: OpenApiUtil.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ddoscoo', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!$isNull(endpoint)) {
    return endpoint;
  }
  
  if (!$isNull(endpointMap) && !$isNull(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddAutoCcBlacklistRequest {
  blacklist?: string(name='Blacklist', description='The IP addresses that you want to manage. This parameter is a JSON string. The string contains the following field:

*   **src**: the IP address. This field is required and must be of the STRING type.

>  You can manually add up to 2,000 IP addresses to the IP address blacklist. Separate multiple IP addresses with spaces or line breaks.

This parameter is required.', example='[{"src":"198.51.XX.XX"},{"src":"198.52.XX.XX"}]'),
  expireTime?: int32(name='ExpireTime', description='This parameter is required.', example='300'),
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
}

model AddAutoCcBlacklistResponseBody = {
  requestId?: string(name='RequestId', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model AddAutoCcBlacklistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddAutoCcBlacklistResponseBody(name='body'),
}

/**
 * @param request AddAutoCcBlacklistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddAutoCcBlacklistResponse
 */
async function addAutoCcBlacklistWithOptions(request: AddAutoCcBlacklistRequest, runtime: $RuntimeOptions): AddAutoCcBlacklistResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.blacklist)) {
    query['Blacklist'] = request.blacklist;
  }
  if (!$isNull(request.expireTime)) {
    query['ExpireTime'] = request.expireTime;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'AddAutoCcBlacklist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request AddAutoCcBlacklistRequest
 * @return AddAutoCcBlacklistResponse
 */
async function addAutoCcBlacklist(request: AddAutoCcBlacklistRequest): AddAutoCcBlacklistResponse {
  var runtime = new $RuntimeOptions{};
  return addAutoCcBlacklistWithOptions(request, runtime);
}

model AddAutoCcWhitelistRequest {
  expireTime?: int32(name='ExpireTime', description='This parameter is deprecated.

> This parameter indicates the validity period of the IP address blacklist. By default, the traffic from the IP addresses that you add to the whitelist is always allowed. You do not need to set this parameter.', example='0'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  whitelist?: string(name='Whitelist', description='The configuration of the IP addresses that you want to add to the whitelist. The value is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that contains the following fields:

*   **src**: the IP address that you want to add. This parameter is required. Data type: string.

This parameter is required.', example='[{"src":"192.XX.XX.1"},{"src":"192.XX.XX.2"}]'),
}

model AddAutoCcWhitelistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='AB5025DA-5C52-5207-B6AC-3F198758B678'),
}

model AddAutoCcWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddAutoCcWhitelistResponseBody(name='body'),
}

/**
 * @summary Adds IP addresses to the IP address whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @description You can call the AddAutoCcWhitelist operation to add IP addresses to the whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance. This way, the Anti-DDoS Pro or Anti-DDoS Premium instance allows traffic from the IP addresses.
 * By default, the traffic from the IP addresses that you add to the whitelist is always allowed. If you no longer use the whitelist, you can call the [EmptyAutoCcWhitelist](https://help.aliyun.com/document_detail/157505.html) operation to remove the IP addresses from the whitelist.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request AddAutoCcWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddAutoCcWhitelistResponse
 */
async function addAutoCcWhitelistWithOptions(request: AddAutoCcWhitelistRequest, runtime: $RuntimeOptions): AddAutoCcWhitelistResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.expireTime)) {
    query['ExpireTime'] = request.expireTime;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.whitelist)) {
    query['Whitelist'] = request.whitelist;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'AddAutoCcWhitelist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds IP addresses to the IP address whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @description You can call the AddAutoCcWhitelist operation to add IP addresses to the whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance. This way, the Anti-DDoS Pro or Anti-DDoS Premium instance allows traffic from the IP addresses.
 * By default, the traffic from the IP addresses that you add to the whitelist is always allowed. If you no longer use the whitelist, you can call the [EmptyAutoCcWhitelist](https://help.aliyun.com/document_detail/157505.html) operation to remove the IP addresses from the whitelist.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request AddAutoCcWhitelistRequest
 * @return AddAutoCcWhitelistResponse
 */
async function addAutoCcWhitelist(request: AddAutoCcWhitelistRequest): AddAutoCcWhitelistResponse {
  var runtime = new $RuntimeOptions{};
  return addAutoCcWhitelistWithOptions(request, runtime);
}

model AssociateWebCertRequest {
  cert?: string(name='Cert'),
  certId?: int32(name='CertId'),
  certIdentifier?: string(name='CertIdentifier', description='The globally unique ID of the certificate. The value is in the "Certificate ID-cn-hangzhou" format. For example, if the ID of the certificate is 123, the value of the CertIdentifier parameter is 123-cn-hangzhou.

>  You can specify only one of this parameter and the CertId parameter.', example='9430680-cn-hangzhou'),
  certName?: string(name='CertName'),
  certRegion?: string(name='CertRegion', description='The region of the certificate. Valid values: **cn-hangzhou** and **ap-southeast-1**. Default value: **cn-hangzhou**.', example='cn-hangzhou'),
  domain?: string(name='Domain', description='This parameter is required.'),
  key?: string(name='Key'),
}

model AssociateWebCertResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='40F11005-A75C-4644-95F2-52A4E7D43E91'),
}

model AssociateWebCertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AssociateWebCertResponseBody(name='body'),
}

/**
 * @summary Associates an SSL certificate with the forwarding rule of a website.
 *
 * @param request AssociateWebCertRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateWebCertResponse
 */
async function associateWebCertWithOptions(request: AssociateWebCertRequest, runtime: $RuntimeOptions): AssociateWebCertResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.cert)) {
    body['Cert'] = request.cert;
  }
  if (!$isNull(request.certId)) {
    body['CertId'] = request.certId;
  }
  if (!$isNull(request.certIdentifier)) {
    body['CertIdentifier'] = request.certIdentifier;
  }
  if (!$isNull(request.certName)) {
    body['CertName'] = request.certName;
  }
  if (!$isNull(request.certRegion)) {
    body['CertRegion'] = request.certRegion;
  }
  if (!$isNull(request.domain)) {
    body['Domain'] = request.domain;
  }
  if (!$isNull(request.key)) {
    body['Key'] = request.key;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'AssociateWebCert',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Associates an SSL certificate with the forwarding rule of a website.
 *
 * @param request AssociateWebCertRequest
 * @return AssociateWebCertResponse
 */
async function associateWebCert(request: AssociateWebCertRequest): AssociateWebCertResponse {
  var runtime = new $RuntimeOptions{};
  return associateWebCertWithOptions(request, runtime);
}

model AttachSceneDefenseObjectRequest {
  objectType?: string(name='ObjectType', description='The type of the object. Set the value to **Domain**, which indicates a domain name.

This parameter is required.', example='Domain'),
  objects?: string(name='Objects', description='The object that you want to add to the policy. Separate multiple objects with commas (,).

This parameter is required.', example='www.aliyun.com'),
  policyId?: string(name='PolicyId', description='The ID of the policy.

> You can call the [DescribeSceneDefensePolicies](https://help.aliyun.com/document_detail/159382.html) operation to query the IDs of all policies.

This parameter is required.', example='321a-fd31-df51-****'),
}

model AttachSceneDefenseObjectResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model AttachSceneDefenseObjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AttachSceneDefenseObjectResponseBody(name='body'),
}

/**
 * @summary Adds an object to a scenario-specific custom policy for protection.
 *
 * @param request AttachSceneDefenseObjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachSceneDefenseObjectResponse
 */
async function attachSceneDefenseObjectWithOptions(request: AttachSceneDefenseObjectRequest, runtime: $RuntimeOptions): AttachSceneDefenseObjectResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.objectType)) {
    query['ObjectType'] = request.objectType;
  }
  if (!$isNull(request.objects)) {
    query['Objects'] = request.objects;
  }
  if (!$isNull(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'AttachSceneDefenseObject',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds an object to a scenario-specific custom policy for protection.
 *
 * @param request AttachSceneDefenseObjectRequest
 * @return AttachSceneDefenseObjectResponse
 */
async function attachSceneDefenseObject(request: AttachSceneDefenseObjectRequest): AttachSceneDefenseObjectResponse {
  var runtime = new $RuntimeOptions{};
  return attachSceneDefenseObjectWithOptions(request, runtime);
}

model ConfigDomainSecurityProfileRequest {
  cluster?: string(name='Cluster', description='This parameter is unavailable.'),
  config?: string(name='Config', description='The configurations for the global mitigation policy feature. The configurations include the following fields:

*   **global_rule_mode**: optional. The mode for the global mitigation policy feature. Data type: string. Valid values:

    *   **weak**: loose.
    *   **default**: normal.
    *   **hard**: strict.

*   **global_rule_enable**: optional. Specifies whether to enable the global mitigation policy feature. Data type: string. Valid values:

    *   **0**: disabled.
    *   **1**: enabled.

This parameter is required.', example='{\\\\"global_rule_mode\\\\":\\\\"hard\\\\"}'),
  domain?: string(name='Domain', description='The domain name of the website.

>  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='live.abcde.com'),
}

model ConfigDomainSecurityProfileResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9728769F-9466-534E-BE12-CAB29A675828'),
}

model ConfigDomainSecurityProfileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigDomainSecurityProfileResponseBody(name='body'),
}

/**
 * @summary Configures the global mitigation policy feature, including the feature status and settings.
 *
 * @param request ConfigDomainSecurityProfileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigDomainSecurityProfileResponse
 */
async function configDomainSecurityProfileWithOptions(request: ConfigDomainSecurityProfileRequest, runtime: $RuntimeOptions): ConfigDomainSecurityProfileResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.cluster)) {
    query['Cluster'] = request.cluster;
  }
  if (!$isNull(request.config)) {
    query['Config'] = request.config;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ConfigDomainSecurityProfile',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures the global mitigation policy feature, including the feature status and settings.
 *
 * @param request ConfigDomainSecurityProfileRequest
 * @return ConfigDomainSecurityProfileResponse
 */
async function configDomainSecurityProfile(request: ConfigDomainSecurityProfileRequest): ConfigDomainSecurityProfileResponse {
  var runtime = new $RuntimeOptions{};
  return configDomainSecurityProfileWithOptions(request, runtime);
}

model ConfigL7GlobalRuleRequest {
  domain?: string(name='Domain', description='This parameter is required.', example='example.com'),
  ruleAttr?: string(name='RuleAttr', description='This parameter is required.', example='[{\\\\"RuleId\\\\":\\\\"global_01\\\\",\\\\"Action\\\\":\\\\"block\\\\",\\\\"Enabled\\\\":0}]'),
}

model ConfigL7GlobalRuleResponseBody = {
  requestId?: string(name='RequestId', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model ConfigL7GlobalRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigL7GlobalRuleResponseBody(name='body'),
}

/**
 * @summary 配置全局模板规则
 *
 * @param request ConfigL7GlobalRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigL7GlobalRuleResponse
 */
async function configL7GlobalRuleWithOptions(request: ConfigL7GlobalRuleRequest, runtime: $RuntimeOptions): ConfigL7GlobalRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.ruleAttr)) {
    query['RuleAttr'] = request.ruleAttr;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ConfigL7GlobalRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 配置全局模板规则
 *
 * @param request ConfigL7GlobalRuleRequest
 * @return ConfigL7GlobalRuleResponse
 */
async function configL7GlobalRule(request: ConfigL7GlobalRuleRequest): ConfigL7GlobalRuleResponse {
  var runtime = new $RuntimeOptions{};
  return configL7GlobalRuleWithOptions(request, runtime);
}

model ConfigL7RsPolicyRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query the domain names for which forwarding rules are configured.

This parameter is required.', example='www.aliyun.com'),
  policy?: string(name='Policy', description='The back-to-origin policy. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:

*   **ProxyMode**: The load balancing algorithm for back-to-origin traffic. This field is required and must be a string. Valid values:

    *   **ip_hash**: the IP hash algorithm. This algorithm is used to redirect requests from the same IP address to the same origin server.
    *   **rr**: the round-robin algorithm. This algorithm is used to redirect requests to origin servers in turn. If you use this algorithm, you can specify a weight for each server based on server performance.
    *   **least_time**: the least response time algorithm. This algorithm is used to minimize the latency when requests are forwarded from the instance to origin servers based on the intelligent DNS resolution feature.

*   **Attributes**: the parameters for back-to-origin processing. This field is optional and must be a JSON array. Each element in the array contains the following fields:

    *   **RealServer**: the address of the origin server. This field is optional and must be a string.

    *   **Attribute**: the parameter for back-to-origin processing. This field is optional and must be a JSON object. Valid values:

        *   **Weight**: the weight of the server. This field is optional and must be an integer. This field takes effect only when **ProxyMode** is set to **rr**. Valid values: **1** to **100**. Default value: **100**. An origin server with a higher weight receives more requests.
        *   **ConnectTimeout**: the timeout period for new connections. This field is optional and must be an integer. Valid values: **1** to **10**. Unit: seconds. Default value: **5**.
        *   **FailTimeout**: the period after which a connection is considered to have failed. This field is optional and must be an integer. Valid values: **1** to **3600**. Unit: seconds. Default value: **10**.
        *   **MaxFails**: the maximum number of failures allowed. This field is related to health checks. This field is optional and must be an integer. Valid values: **1** to **10**. Unit: seconds. Default value: **3**.
        *   **Mode**: the primary/secondary attribute flag. This parameter is optional and must be a string. Valid values: **active** (primary) and **backup** (secondary).
        *   **ReadTimeout**: the read timeout period. This field is optional and must be an integer. Valid values: **10** to **300**. Unit: seconds. Default value: **120**.
        *   **SendTimeout**: the write timeout period. This field is optional and must be an integer. Valid values: **10** to **300**. Unit: seconds. Default value: **120**.

This parameter is required.', example='{"ProxyMode":"rr","Attributes":[{"RealServer":"1.***.***.1","Attribute":{"Weight":100}},{"RealServer":"2.***.***.2","Attribute":{"Weight":100}}]}'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).', example='rg-acfm2pz25js****'),
  upstreamRetry?: int32(name='UpstreamRetry', description='The retry switch. Valid values:

*   **1**: on
*   **0**: off', example='1'),
}

model ConfigL7RsPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ConfigL7RsPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigL7RsPolicyResponseBody(name='body'),
}

/**
 * @summary Configures a back-to-origin policy for the forwarding rule of a website.
 *
 * @description If multiple origin servers are configured for a website that is added to Anti-DDoS Pro or Anti-DDoS Premium, you can modify the load balancing algorithms for back-to-origin traffic based on back-to-origin policies. The IP hash algorithm is used by default. You can change the algorithm to the round-robin or least response time algorithm. For more information, see the description of the **Policy** parameter in the "Request parameters" section of this topic.
 *
 * @param request ConfigL7RsPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigL7RsPolicyResponse
 */
async function configL7RsPolicyWithOptions(request: ConfigL7RsPolicyRequest, runtime: $RuntimeOptions): ConfigL7RsPolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.policy)) {
    query['Policy'] = request.policy;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.upstreamRetry)) {
    query['UpstreamRetry'] = request.upstreamRetry;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ConfigL7RsPolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures a back-to-origin policy for the forwarding rule of a website.
 *
 * @description If multiple origin servers are configured for a website that is added to Anti-DDoS Pro or Anti-DDoS Premium, you can modify the load balancing algorithms for back-to-origin traffic based on back-to-origin policies. The IP hash algorithm is used by default. You can change the algorithm to the round-robin or least response time algorithm. For more information, see the description of the **Policy** parameter in the "Request parameters" section of this topic.
 *
 * @param request ConfigL7RsPolicyRequest
 * @return ConfigL7RsPolicyResponse
 */
async function configL7RsPolicy(request: ConfigL7RsPolicyRequest): ConfigL7RsPolicyResponse {
  var runtime = new $RuntimeOptions{};
  return configL7RsPolicyWithOptions(request, runtime);
}

model ConfigL7UsKeepaliveRequest {
  domain?: string(name='Domain', description='The domain name of the website.

>  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='www.aliyun.com'),
  upstreamKeepalive?: string(name='UpstreamKeepalive', description='The settings for back-to-origin persistent connections. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:

*   **enabled**: the switch for back-to-origin persistent connections. This field is required, and the value is of the Boolean type.
*   **keepalive_requests**: the number of requests that reuse a persistent connection. This field is required, and the value is of the integer type.
*   **keepalive_timeout**: the timeout period for an idle persistent connection. This field is required, and the value is of the integer type.

This parameter is required.', example='{"enabled": true, "keepalive_requests": 1000,"keepalive_timeout": 30}'),
}

model ConfigL7UsKeepaliveResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6D48AED0-41DB-5D9B-B484-3B6AAD312AD1'),
}

model ConfigL7UsKeepaliveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigL7UsKeepaliveResponseBody(name='body'),
}

/**
 * @summary Configures the settings for back-to-origin persistent connections for a domain name.
 *
 * @param request ConfigL7UsKeepaliveRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigL7UsKeepaliveResponse
 */
async function configL7UsKeepaliveWithOptions(request: ConfigL7UsKeepaliveRequest, runtime: $RuntimeOptions): ConfigL7UsKeepaliveResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.upstreamKeepalive)) {
    query['UpstreamKeepalive'] = request.upstreamKeepalive;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ConfigL7UsKeepalive',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures the settings for back-to-origin persistent connections for a domain name.
 *
 * @param request ConfigL7UsKeepaliveRequest
 * @return ConfigL7UsKeepaliveResponse
 */
async function configL7UsKeepalive(request: ConfigL7UsKeepaliveRequest): ConfigL7UsKeepaliveResponse {
  var runtime = new $RuntimeOptions{};
  return configL7UsKeepaliveWithOptions(request, runtime);
}

model ConfigLayer4RealLimitRequest {
  instanceId?: string(name='InstanceId', description='The ID of the Anti-DDoS Pro or Anti-DDoS Premium instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-XXXXX'),
  limitValue?: long(name='LimitValue', description='Specifies the threshold of the clean bandwidth. Valid values: 0 to 15360. The value 0 indicates that rate limiting is never triggered. Unit: Mbit/s

This parameter is required.', example='0'),
}

model ConfigLayer4RealLimitResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CFCF71BD-680E-5A20-8847-174CEC62E67D'),
}

model ConfigLayer4RealLimitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigLayer4RealLimitResponseBody(name='body'),
}

/**
 * @summary Specifies a threshold for the clean bandwidth of an Anti-DDoS Pro or Anti-DDoS premium instance. If the threshold is reached, rate limiting is triggered.
 *
 * @param request ConfigLayer4RealLimitRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigLayer4RealLimitResponse
 */
async function configLayer4RealLimitWithOptions(request: ConfigLayer4RealLimitRequest, runtime: $RuntimeOptions): ConfigLayer4RealLimitResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.limitValue)) {
    query['LimitValue'] = request.limitValue;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ConfigLayer4RealLimit',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Specifies a threshold for the clean bandwidth of an Anti-DDoS Pro or Anti-DDoS premium instance. If the threshold is reached, rate limiting is triggered.
 *
 * @param request ConfigLayer4RealLimitRequest
 * @return ConfigLayer4RealLimitResponse
 */
async function configLayer4RealLimit(request: ConfigLayer4RealLimitRequest): ConfigLayer4RealLimitResponse {
  var runtime = new $RuntimeOptions{};
  return configLayer4RealLimitWithOptions(request, runtime);
}

model ConfigLayer4RemarkRequest {
  listeners?: string(name='Listeners', description='The port forwarding rule that you want to manage.

This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can perform this operation only on one port forwarding rule at a time.

> You can call the [DescribeNetworkRules](https://help.aliyun.com/document_detail/157484.html) to query existing port forwarding rules.

Each port forwarding rule contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
*   **Remark**: the remarks of the port forwarding rule. This field is required and must be of the STRING type. The value can contain letters, digits, and some special characters, such as `, . + - * / _`. The value can be up to 200 characters in length.

This parameter is required.', example='[{\\\\"InstanceId\\\\":\\\\"ddosDip-sg-4hr2b3l****\\\\",\\\\"FrontendPort\\\\":2020,\\\\"Protocol\\\\":\\\\"udp\\\\",\\\\"Remark\\\\":\\\\"test\\\\"}]'),
}

model ConfigLayer4RemarkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6E46CC51-36BE-1100-B14C-DAF8381B8F73'),
}

model ConfigLayer4RemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigLayer4RemarkResponseBody(name='body'),
}

/**
 * @summary Adds a description to a port forwarding rule.
 *
 * @param request ConfigLayer4RemarkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigLayer4RemarkResponse
 */
async function configLayer4RemarkWithOptions(request: ConfigLayer4RemarkRequest, runtime: $RuntimeOptions): ConfigLayer4RemarkResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.listeners)) {
    query['Listeners'] = request.listeners;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ConfigLayer4Remark',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds a description to a port forwarding rule.
 *
 * @param request ConfigLayer4RemarkRequest
 * @return ConfigLayer4RemarkResponse
 */
async function configLayer4Remark(request: ConfigLayer4RemarkRequest): ConfigLayer4RemarkResponse {
  var runtime = new $RuntimeOptions{};
  return configLayer4RemarkWithOptions(request, runtime);
}

model ConfigLayer4RuleBakModeRequest {
  bakMode?: string(name='BakMode', description='The mode that you want to use to forward service traffic. Valid values:

*   **0**: the default mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the origin IP address that you specified when you created the port forwarding rule. You can call the [CreateNetworkRules](https://help.aliyun.com/document_detail/157482.html) operation to create a port forwarding rule.
*   **1**: the origin redundancy mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary or secondary origin servers. You can call the [ConfigLayer4RulePolicy](https://help.aliyun.com/document_detail/312684.html) operation to configure IP addresses.

This parameter is required.', example='1'),
  listeners?: string(name='Listeners', description='The port forwarding rule that you want to manage.

This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can perform this operation only on one port forwarding rule at a time.

> You can call the [DescribeNetworkRules](https://help.aliyun.com/document_detail/157484.html) to query existing port forwarding rules.

Each port forwarding rule contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.

This parameter is required.', example='[{\\\\"InstanceId\\\\":\\\\"ddosDip-sg-4hr2b3l****\\\\",\\\\"FrontendPort\\\\":2020,\\\\"Protocol\\\\":\\\\"udp\\\\"}]'),
}

model ConfigLayer4RuleBakModeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CC042262-15A3-4A49-ADF0-130968EA47BC'),
}

model ConfigLayer4RuleBakModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigLayer4RuleBakModeResponseBody(name='body'),
}

/**
 * @summary Enables or disables the origin redundancy mode for a port forwarding rule.
 *
 * @param request ConfigLayer4RuleBakModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigLayer4RuleBakModeResponse
 */
async function configLayer4RuleBakModeWithOptions(request: ConfigLayer4RuleBakModeRequest, runtime: $RuntimeOptions): ConfigLayer4RuleBakModeResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.bakMode)) {
    query['BakMode'] = request.bakMode;
  }
  if (!$isNull(request.listeners)) {
    query['Listeners'] = request.listeners;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ConfigLayer4RuleBakMode',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables the origin redundancy mode for a port forwarding rule.
 *
 * @param request ConfigLayer4RuleBakModeRequest
 * @return ConfigLayer4RuleBakModeResponse
 */
async function configLayer4RuleBakMode(request: ConfigLayer4RuleBakModeRequest): ConfigLayer4RuleBakModeResponse {
  var runtime = new $RuntimeOptions{};
  return configLayer4RuleBakModeWithOptions(request, runtime);
}

model ConfigLayer4RulePolicyRequest {
  listeners?: string(name='Listeners', description='The port forwarding rule that you want to manage.

This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can perform this operation only on one port forwarding rule at a time.

> You can call the [DescribeNetworkRules](https://help.aliyun.com/document_detail/157484.html) to query existing port forwarding rules.

Each port forwarding rule contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.

*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.

*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.

*   **BackendPort**: the port of the origin server. This field is required and must be of the INTEGER type.

*   **PriRealServers**: the IP addresses of the primary origin server. This field is required and must be a JSON array. Each element in a JSON array indicates an IP address of the primary origin server. You can configure a maximum of 20 IP addresses.

    Each element in the JSON array contains the following field:

    *   **RealServer**: the IP address of the primary origin server. This field is required and must be of the STRING type.

*   **SecRealServers**: the IP addresses of the secondary origin server. This field is required and must be a JSON array. Each element in a JSON array indicates an IP address of the secondary origin server. You can configure a maximum of 20 IP addresses.

    Each element in the JSON array contains the following field:

    *   **RealServer**: the IP address of the secondary origin server. This field is required and must be of the STRING type.

*   **CurrentRsIndex**: the origin server that you want to use to receive service traffic. This field is required and must be of the INTEGER type. Valid values:

    *   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
    *   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.

This parameter is required.', example='[{\\\\"InstanceId\\\\":\\\\"ddosDip-sg-4hr2b3l****\\\\",\\\\"Protocol\\\\":\\\\"udp\\\\",\\\\"FrontendPort\\\\":2020,\\\\"BackendPort\\\\":2022,\\\\"PriRealServers\\\\":[{\\\\"RealServer\\\\":\\\\"192.0.2.1\\\\"},{\\\\"RealServer\\\\":\\\\"192.0.2.2\\\\"}],\\\\"SecRealServers\\\\":[{\\\\"RealServer\\\\":\\\\"192.0.2.3\\\\"},{\\\\"RealServer\\\\":\\\\"192.0.2.4\\\\"}],\\\\"CurrentRsIndex\\\\":1}]'),
}

model ConfigLayer4RulePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CC042262-15A3-4A49-ADF0-130968EA47BC'),
}

model ConfigLayer4RulePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigLayer4RulePolicyResponseBody(name='body'),
}

/**
 * @summary Configures the IP addresses of the primary and secondary origin servers for a port forwarding rule.
 *
 * @param request ConfigLayer4RulePolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigLayer4RulePolicyResponse
 */
async function configLayer4RulePolicyWithOptions(request: ConfigLayer4RulePolicyRequest, runtime: $RuntimeOptions): ConfigLayer4RulePolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.listeners)) {
    query['Listeners'] = request.listeners;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ConfigLayer4RulePolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures the IP addresses of the primary and secondary origin servers for a port forwarding rule.
 *
 * @param request ConfigLayer4RulePolicyRequest
 * @return ConfigLayer4RulePolicyResponse
 */
async function configLayer4RulePolicy(request: ConfigLayer4RulePolicyRequest): ConfigLayer4RulePolicyResponse {
  var runtime = new $RuntimeOptions{};
  return configLayer4RulePolicyWithOptions(request, runtime);
}

model ConfigNetworkRegionBlockRequest {
  config?: string(name='Config', description='The details of the configurations of blocked locations. This parameter is a JSON string. The value consists of the following fields:

*   **RegionBlockSwitch**: the status of the location blacklist feature. This field is required and must be of the string type. Valid values:

    *   **on**
    *   **off**

*   **Countries**: the codes of the countries and areas from which you want to block requests. This field is optional and must be of the array type.

    **

    **Note** For more information about the codes of countries and areas, see [Location parameters](https://help.aliyun.com/document_detail/167926.html).

*   **Provinces**: the codes of the administrative regions in China from which you want to block requests. This field is optional and must be of the array type.

    **

    **Note** For more information about the codes of administrative regions in China, see [Location parameters](https://help.aliyun.com/document_detail/167926.html).

    For example, `[11,12]` specifies Beijing and Tianjin.

This parameter is required.', example='{"RegionBlockSwitch":"off","Countries":[],"Provinces":[11,12,13,14,15,21,22,23,31,32,33,34,35,36,37,41,42,43,44,45,46,50,51,52,53,54,61,62,63,64,65,71,81,82]}'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
}

model ConfigNetworkRegionBlockResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model ConfigNetworkRegionBlockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigNetworkRegionBlockResponseBody(name='body'),
}

/**
 * @summary Configures blocked locations for an Anti-DDoS Proxy instance.
 *
 * @param request ConfigNetworkRegionBlockRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigNetworkRegionBlockResponse
 */
async function configNetworkRegionBlockWithOptions(request: ConfigNetworkRegionBlockRequest, runtime: $RuntimeOptions): ConfigNetworkRegionBlockResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.config)) {
    query['Config'] = request.config;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ConfigNetworkRegionBlock',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures blocked locations for an Anti-DDoS Proxy instance.
 *
 * @param request ConfigNetworkRegionBlockRequest
 * @return ConfigNetworkRegionBlockResponse
 */
async function configNetworkRegionBlock(request: ConfigNetworkRegionBlockRequest): ConfigNetworkRegionBlockResponse {
  var runtime = new $RuntimeOptions{};
  return configNetworkRegionBlockWithOptions(request, runtime);
}

model ConfigNetworkRulesRequest {
  networkRules?: string(name='NetworkRules', description='The details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
*   **BackendPort**: the port of the origin server. This field is required and must be of the INTEGER type.
*   **RealServers**: the IP addresses of the origin server. This field is required and must be a JSON array. You can specify up to 20 IP addresses.

> You can modify only the value of **RealServers** when you modify a port forwarding rule.

This parameter is required.', example='[{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080,"BackendPort":8080,"RealServers":["1.1.1.1","2.2.2.2","3.3.3.3"]}]'),
}

model ConfigNetworkRulesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CC042262-15A3-4A49-ADF0-130968EA47BC'),
}

model ConfigNetworkRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigNetworkRulesResponseBody(name='body'),
}

/**
 * @summary Modifies the IP addresses of the origin server that is configured in a port forwarding rule.
 *
 * @param request ConfigNetworkRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigNetworkRulesResponse
 */
async function configNetworkRulesWithOptions(request: ConfigNetworkRulesRequest, runtime: $RuntimeOptions): ConfigNetworkRulesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.networkRules)) {
    query['NetworkRules'] = request.networkRules;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ConfigNetworkRules',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the IP addresses of the origin server that is configured in a port forwarding rule.
 *
 * @param request ConfigNetworkRulesRequest
 * @return ConfigNetworkRulesResponse
 */
async function configNetworkRules(request: ConfigNetworkRulesRequest): ConfigNetworkRulesResponse {
  var runtime = new $RuntimeOptions{};
  return configNetworkRulesWithOptions(request, runtime);
}

model ConfigUdpReflectRequest {
  config?: string(name='Config', description='The configuration of the filtering policy for UDP reflection attacks.

The value is a string that consists of a JSON struct. The JSON struct contains the following field:

*   **UdpSports**: the source ports of the UDP traffic that you want to block. This field is required and must be of the ARRAY type. Example: `[17,19]`.

    We recommend that you block the following source ports of UDP traffic:

    *   UDP 17: QOTD reflection attacks
    *   UDP 19: CharGEN reflection attacks
    *   UDP 69: TFTP reflection attacks
    *   UDP 111: Portmap reflection attacks
    *   UDP 123: NTP reflection attacks
    *   UDP 137: NetBIOS reflection attacks
    *   UDP 161: SNMPv2 reflection attacks
    *   UDP 389: CLDAP reflection attacks
    *   UDP 1194: OpenVPN reflection attacks
    *   UDP 1900: SSDP reflection attacks
    *   UDP 3389: RDP reflection attacks
    *   UDP 11211: memcached reflection attacks

This parameter is required.', example='{\\\\"UdpSports\\\\":[17,19]}'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-i7m25564****'),
  regionId?: string(name='RegionId', description='The region ID of the Anti-DDoS Proxy instance. Valid values:

*   **cn-hangzhou**: indicates an Anti-DDoS Proxy (Chinese Mainland) instance. This is the default value.
*   **ap-southeast-1**: indicates an Anti-DDoS Proxy (Outside Chinese Mainland) instance.', example='cn-hangzhou'),
}

model ConfigUdpReflectResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='9EC62E89-BD30-4FCD-9CB8-FA53865FF0D7'),
}

model ConfigUdpReflectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigUdpReflectResponseBody(name='body'),
}

/**
 * @summary Adds the filtering policies for UDP reflection attacks on an Anti-DDoS Pro or Anti-DDoS Premium instance to filter out the source ports of UDP traffic.
 *
 * @description You can call this operation to configure filtering policies to filter out UDP traffic from specific ports. This helps defend against UDP reflection attacks.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ConfigUdpReflectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigUdpReflectResponse
 */
async function configUdpReflectWithOptions(request: ConfigUdpReflectRequest, runtime: $RuntimeOptions): ConfigUdpReflectResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.config)) {
    query['Config'] = request.config;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ConfigUdpReflect',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds the filtering policies for UDP reflection attacks on an Anti-DDoS Pro or Anti-DDoS Premium instance to filter out the source ports of UDP traffic.
 *
 * @description You can call this operation to configure filtering policies to filter out UDP traffic from specific ports. This helps defend against UDP reflection attacks.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ConfigUdpReflectRequest
 * @return ConfigUdpReflectResponse
 */
async function configUdpReflect(request: ConfigUdpReflectRequest): ConfigUdpReflectResponse {
  var runtime = new $RuntimeOptions{};
  return configUdpReflectWithOptions(request, runtime);
}

model ConfigWebCCRuleV2Request {
  domain?: string(name='Domain', description='This parameter is required.', example='www.example.com'),
  expires?: long(name='Expires', example='600'),
  ruleList?: string(name='RuleList', description='The frequency control rule. This parameter is a JSON string that contains the following fields:

*   **action**: the action that is performed if the rule is matched. This field is required and must be of the string type. Valid values:

    *   **block**: The requests that match the rule are blocked.
    *   **challenge**: Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) verification for the requests that match the rule is implemented.
    *   **watch**: The requests that match the rule are recorded in logs and allowed.

*   **name**: the name of the rule. This field is required and must be of the string type.

*   **condition**: the match conditions. This field is required and must be of the map type. This field contains the following parameters:

    **

    **Note** The AND logical operator is used to evaluate multiple match conditions.

    *   **field**: the match field. This field is required and must be of the string type.

    *   **match_method**: the logical relation. This field is required and must be of the string type.

        **

        **Note** For information about the mappings between the **field** and **match_method** parameters, see the "Mappings between the field and match_method parameters" section of this topic.

    *   **header_name**: the name of the custom HTTP header. This field is optional and must be of the string type.

        **

        **Note** This field is required only when **field** is set to **header**.

    *   **content**: the match content. This field is required and must be of the string type.

*   **ratelimit**: the frequency control field. This field is optional and must be of the string type. The frequency can be measured based on IP addresses or custom headers. This field contains the following parameters:

    *   **interval**: the statistical duration. Unit: seconds. This field is required and must be of the integer type.
    *   **ttl**: the period during which the specified action is performed. Unit: seconds. This field is required and must be of the integer type.
    *   **threshold**: the threshold. This field is required and must be of the integer type.
    *   **subkey**: the name of the field. This field is optional and must be of the string type. This field is required only when target is set to header.
    *   **target**: the statistical source. This field is required and must be of the string type. Valid values: ip and header.

*   **status_code**: the frequency control field. This field is optional and must be of the string type. Frequency control can be performed based on the quantity or percentage of status codes. This field contains the following parameters:

    *   **enabled**: specifies whether to enable status code statistics. This field is required and must be of the Boolean type.
    *   **code**: the status code. This field is required and must be of the integer type. Valid values: **100** to **599**.
    *   **use_ratio**: specifies whether to use a ratio. This field is required and must be of the Boolean type. To use a ratio, set this field to true.
    *   **ratio_threshold**: the ratio of the status code. This field is optional and must be of the integer type. If a ratio is used, the action specified in the rule is performed only when the ratio of the status code reaches **ratio_threshold**. Valid values: **1** to **100**.
    *   **count_threshold**: the quantity of the status code. This field is optional and must be of the integer type. If a ratio is not used, the action specified in the rule is performed only when the quantity of the status code reaches **count_threshold**. Valid values: **2** to **50000**.

*   **statistics**: specifies whether deduplication is used for statistics. This field is optional and must be of the string type. By default, deduplication is not used for statistics. This field contains the following parameters:

    *   **mode**: specifies whether deduplication is used for status code statistics. This field is required and must be of the string type. Valid values:

        *   **count**: Deduplication is not used for statistics.
        *   **distinct**: Deduplication is used for statistics.

    *   **field**: the statistical source. This field is required and must be of the string type. Valid values: ip, header, and uri.

    *   **header_name**: the name of the header. This field is optional and must be of the string type. This field is required only when field is set to header.

This parameter is required.', example='[{"action":"block","name":"trdsss","ratelimit":{"interval":60,"ttl":300,"threshold":70,"target":"ip"},"condition":[{"field":"ip","match_method":"belong","content":"1.1.1.1"}]}]'),
}

model ConfigWebCCRuleV2ResponseBody = {
  requestId?: string(name='RequestId', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ConfigWebCCRuleV2Response = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigWebCCRuleV2ResponseBody(name='body'),
}

/**
 * @summary 配置新版基于匹配条件的cc规则
 *
 * @param request ConfigWebCCRuleV2Request
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigWebCCRuleV2Response
 */
async function configWebCCRuleV2WithOptions(request: ConfigWebCCRuleV2Request, runtime: $RuntimeOptions): ConfigWebCCRuleV2Response {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.expires)) {
    query['Expires'] = request.expires;
  }
  if (!$isNull(request.ruleList)) {
    query['RuleList'] = request.ruleList;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ConfigWebCCRuleV2',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 配置新版基于匹配条件的cc规则
 *
 * @param request ConfigWebCCRuleV2Request
 * @return ConfigWebCCRuleV2Response
 */
async function configWebCCRuleV2(request: ConfigWebCCRuleV2Request): ConfigWebCCRuleV2Response {
  var runtime = new $RuntimeOptions{};
  return configWebCCRuleV2WithOptions(request, runtime);
}

model ConfigWebCCTemplateRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  template?: string(name='Template', description='The mode of the Frequency Control policy. Valid values:

*   **default**: Normal
*   **gf_under_attack**: Emergency
*   **gf_sos_verify**: Strict
*   **gf_sos_enhance**: Super Strict

This parameter is required.', example='default'),
}

model ConfigWebCCTemplateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ConfigWebCCTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigWebCCTemplateResponseBody(name='body'),
}

/**
 * @summary Configures the mode of the Frequency Control policy for a website.
 *
 * @param request ConfigWebCCTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigWebCCTemplateResponse
 */
async function configWebCCTemplateWithOptions(request: ConfigWebCCTemplateRequest, runtime: $RuntimeOptions): ConfigWebCCTemplateResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.template)) {
    query['Template'] = request.template;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ConfigWebCCTemplate',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures the mode of the Frequency Control policy for a website.
 *
 * @param request ConfigWebCCTemplateRequest
 * @return ConfigWebCCTemplateResponse
 */
async function configWebCCTemplate(request: ConfigWebCCTemplateRequest): ConfigWebCCTemplateResponse {
  var runtime = new $RuntimeOptions{};
  return configWebCCTemplateWithOptions(request, runtime);
}

model ConfigWebIpSetRequest {
  blackList?: [ string ](name='BlackList', description='The IP addresses and CIDR blocks in the blacklist. You can add up to 200 IP addresses or CIDR blocks to the blacklist.', example='1.1.1.1'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  whiteList?: [ string ](name='WhiteList', description='The IP addresses and CIDR blocks in the whitelist. You can add up to 200 IP addresses or CIDR blocks to the whitelist.', example='2.2.2.2/24'),
}

model ConfigWebIpSetResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ConfigWebIpSetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigWebIpSetResponseBody(name='body'),
}

/**
 * @summary Configures the IP address whitelist and blacklist for a website.
 *
 * @param request ConfigWebIpSetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigWebIpSetResponse
 */
async function configWebIpSetWithOptions(request: ConfigWebIpSetRequest, runtime: $RuntimeOptions): ConfigWebIpSetResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.blackList)) {
    query['BlackList'] = request.blackList;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.whiteList)) {
    query['WhiteList'] = request.whiteList;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ConfigWebIpSet',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures the IP address whitelist and blacklist for a website.
 *
 * @param request ConfigWebIpSetRequest
 * @return ConfigWebIpSetResponse
 */
async function configWebIpSet(request: ConfigWebIpSetRequest): ConfigWebIpSetResponse {
  var runtime = new $RuntimeOptions{};
  return configWebIpSetWithOptions(request, runtime);
}

model CreateAsyncTaskRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  taskParams?: string(name='TaskParams', description='The details of the asynchronous export task. The value is a JSON string. The field in the value varies with **TaskType**.

If **TaskType** is set to **1**, **3**, **4**, **5**, or **6**, the following filed is returned:

*   **instanceId**: the ID of the instance. This field is required and must be of the STRING type.

If **TaskType** is set to **2**, the following field is returned:

*   **domain**: the domain name of the website, which must be of the STRING type. If you do not specify this field, the forwarding rules of all websites are exported.

This parameter is required.', example='{"instanceId": "ddoscoo-cn-mp91j1ao****"}'),
  taskType?: int32(name='TaskType', description='The type of the asynchronous export task that you want to create. Valid values:

*   **1**: the task to export the port forwarding rules of an instance
*   **2**: the task to export the forwarding rules of a website protected by an instance
*   **3**: the task to export the session persistence and health check settings of an instance
*   **4**: the task to export the anti-DDoS mitigation policies of an instance
*   **5**: the task to download the blacklist for destination IP addresses of an instance
*   **6**: the task to download the whitelist for destination IP addresses of an instance

This parameter is required.', example='5'),
}

model CreateAsyncTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model CreateAsyncTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAsyncTaskResponseBody(name='body'),
}

/**
 * @summary Creates an asynchronous export task to export forwarding rules for websites, port forwarding rules, session persistence and health check settings, DDoS mitigation policies, the IP address blacklist, or the IP address whitelist.
 *
 * @param request CreateAsyncTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAsyncTaskResponse
 */
async function createAsyncTaskWithOptions(request: CreateAsyncTaskRequest, runtime: $RuntimeOptions): CreateAsyncTaskResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.taskParams)) {
    query['TaskParams'] = request.taskParams;
  }
  if (!$isNull(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateAsyncTask',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates an asynchronous export task to export forwarding rules for websites, port forwarding rules, session persistence and health check settings, DDoS mitigation policies, the IP address blacklist, or the IP address whitelist.
 *
 * @param request CreateAsyncTaskRequest
 * @return CreateAsyncTaskResponse
 */
async function createAsyncTask(request: CreateAsyncTaskRequest): CreateAsyncTaskResponse {
  var runtime = new $RuntimeOptions{};
  return createAsyncTaskWithOptions(request, runtime);
}

model CreateDomainResourceRequest {
  domain?: string(name='Domain', description='The domain name of the website that you want to add to the Anti-DDoS Pro or Anti-DDoS Premium instance.

This parameter is required.', example='www.example.com'),
  httpsExt?: string(name='HttpsExt', description='The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:

*   **Http2https**: specifies whether to turn on Enforce HTTPS Routing. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enforce HTTPS Routing is turned off. The value 1 indicates that Enforce HTTPS Routing is turned on. The default value is 0.

    If your website supports both HTTP and HTTPS, this feature meets your business requirements. If you enable this feature, all HTTP requests to access the website are redirected to HTTPS requests on the standard port 443.

*   **Https2http**: specifies whether to turn on Enable HTTP. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP is turned off. The value 1 indicates that Enable HTTP is turned on. The default value is 0.

    If your website does not support HTTPS, this feature meets your business requirements If this feature is enabled, all HTTPS requests are redirected to HTTP requests and forwarded to origin servers. This feature can redirect WebSockets requests to WebSocket requests. Requests are redirected over the standard port 80.

*   **Http2**: specifies whether to turn on Enable HTTP/2. This field is optional. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on. The default value is 0.

    After you turn on the switch, HTTP/2 is used.', example='{"Http2":1,"Http2https":1,"Https2http":1}'),
  instanceIds?: [ string ](name='InstanceIds', description='An array consisting of the IDs of instances that you want to associate.

This parameter is required.'),
  proxyTypes?: [ 
    {
      proxyPorts?: [ int32 ](name='ProxyPorts', description='The port numbers.

This parameter is required.'),
      proxyType?: string(name='ProxyType', description='The type of the protocol. Valid values:

*   **http**
*   **https**
*   **websocket**
*   **websockets**', example='http'),
    }
  ](name='ProxyTypes', description='The details about the protocol type and port number.

This parameter is required.'),
  realServers?: [ string ](name='RealServers', description='An array that consists of the addresses of origin servers.

This parameter is required.'),
  rsType?: int32(name='RsType', description='The address type of the origin server. Valid values:

*   **0**: IP address.

*   **1**: domain name.

    This parameter is suitable for scenarios in which another proxy service, such as Web Application Firewall (WAF), is deployed between the origin server and Anti-DDoS Proxy. The address is the redirection address of the proxy service, such as the CNAME of WAF.

This parameter is required.', example='0'),
}

model CreateDomainResourceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='39499F01-19D9-4EA4-A0E9-C6014BA5CDBE'),
}

model CreateDomainResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDomainResourceResponseBody(name='body'),
}

/**
 * @summary Creates a forwarding rule for a website.
 *
 * @param request CreateDomainResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDomainResourceResponse
 */
async function createDomainResourceWithOptions(request: CreateDomainResourceRequest, runtime: $RuntimeOptions): CreateDomainResourceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.httpsExt)) {
    query['HttpsExt'] = request.httpsExt;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.proxyTypes)) {
    query['ProxyTypes'] = request.proxyTypes;
  }
  if (!$isNull(request.realServers)) {
    query['RealServers'] = request.realServers;
  }
  if (!$isNull(request.rsType)) {
    query['RsType'] = request.rsType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDomainResource',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a forwarding rule for a website.
 *
 * @param request CreateDomainResourceRequest
 * @return CreateDomainResourceResponse
 */
async function createDomainResource(request: CreateDomainResourceRequest): CreateDomainResourceResponse {
  var runtime = new $RuntimeOptions{};
  return createDomainResourceWithOptions(request, runtime);
}

model CreateNetworkRulesRequest {
  networkRules?: string(name='NetworkRules', description='The details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
*   **BackendPort**: the port of the origin server. This field is required and must be of the INTEGER type.
*   **RealServers**: the IP addresses of the origin server. This field is required and must be a JSON array. You can specify up to 20 IP addresses.

This parameter is required.', example='[{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080,"BackendPort":8080,"RealServers":["1.1.1.1","2.2.2.2"]}]'),
}

model CreateNetworkRulesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='ADCA45A5-D15C-4B7D-9F81-138B0B36D0BD'),
}

model CreateNetworkRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateNetworkRulesResponseBody(name='body'),
}

/**
 * @summary Creates a port forwarding rule.
 *
 * @param request CreateNetworkRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNetworkRulesResponse
 */
async function createNetworkRulesWithOptions(request: CreateNetworkRulesRequest, runtime: $RuntimeOptions): CreateNetworkRulesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.networkRules)) {
    query['NetworkRules'] = request.networkRules;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateNetworkRules',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a port forwarding rule.
 *
 * @param request CreateNetworkRulesRequest
 * @return CreateNetworkRulesResponse
 */
async function createNetworkRules(request: CreateNetworkRulesRequest): CreateNetworkRulesResponse {
  var runtime = new $RuntimeOptions{};
  return createNetworkRulesWithOptions(request, runtime);
}

model CreatePortRequest {
  backendPort?: string(name='BackendPort', description='The port of the origin server. Valid values: **0** to **65535**.', example='55'),
  frontendPort?: string(name='FrontendPort', description='The forwarding port. Valid values: **0** to **65535**.

This parameter is required.', example='55'),
  frontendProtocol?: string(name='FrontendProtocol', description='The type of the forwarding protocol. Valid values:

*   **tcp**
*   **udp**

This parameter is required.', example='tcp'),
  instanceId?: string(name='InstanceId', description='The ID of the Anti-DDoS Pro or Anti-DDoS Premium instance to which the port forwarding rule belongs.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-st21zbyq****'),
  proxyEnable?: long(name='ProxyEnable'),
  realServers?: [ string ](name='RealServers', description='An array that consists of the IP addresses of origin servers.

This parameter is required.'),
}

model CreatePortResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4787A9A6-8230-4B4A-8211-AFBF7C416B4D'),
}

model CreatePortResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePortResponseBody(name='body'),
}

/**
 * @summary Creates a port forwarding rule.
 *
 * @description You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
 *
 * @param request CreatePortRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePortResponse
 */
async function createPortWithOptions(request: CreatePortRequest, runtime: $RuntimeOptions): CreatePortResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.backendPort)) {
    query['BackendPort'] = request.backendPort;
  }
  if (!$isNull(request.frontendPort)) {
    query['FrontendPort'] = request.frontendPort;
  }
  if (!$isNull(request.frontendProtocol)) {
    query['FrontendProtocol'] = request.frontendProtocol;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.proxyEnable)) {
    query['ProxyEnable'] = request.proxyEnable;
  }
  if (!$isNull(request.realServers)) {
    query['RealServers'] = request.realServers;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreatePort',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a port forwarding rule.
 *
 * @description You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
 *
 * @param request CreatePortRequest
 * @return CreatePortResponse
 */
async function createPort(request: CreatePortRequest): CreatePortResponse {
  var runtime = new $RuntimeOptions{};
  return createPortWithOptions(request, runtime);
}

model CreateSceneDefensePolicyRequest {
  endTime?: long(name='EndTime', description='The end time of the policy. This value is a UNIX timestamp. Units: milliseconds.

This parameter is required.', example='1586016000000'),
  name?: string(name='Name', description='The name of the policy.

This parameter is required.', example='testpolicy'),
  startTime?: long(name='StartTime', description='The start time of the policy. This value is a UNIX timestamp. Units: milliseconds.

This parameter is required.', example='1585670400000'),
  template?: string(name='Template', description='The template of the policy. Valid values:

*   **promotion**: important activity.
*   **bypass**: all traffic forwarded.

This parameter is required.', example='promotion'),
}

model CreateSceneDefensePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model CreateSceneDefensePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSceneDefensePolicyResponseBody(name='body'),
}

/**
 * @summary Creates a scenario-specific custom policy.
 *
 * @param request CreateSceneDefensePolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSceneDefensePolicyResponse
 */
async function createSceneDefensePolicyWithOptions(request: CreateSceneDefensePolicyRequest, runtime: $RuntimeOptions): CreateSceneDefensePolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!$isNull(request.template)) {
    query['Template'] = request.template;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateSceneDefensePolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a scenario-specific custom policy.
 *
 * @param request CreateSceneDefensePolicyRequest
 * @return CreateSceneDefensePolicyResponse
 */
async function createSceneDefensePolicy(request: CreateSceneDefensePolicyRequest): CreateSceneDefensePolicyResponse {
  var runtime = new $RuntimeOptions{};
  return createSceneDefensePolicyWithOptions(request, runtime);
}

model CreateSchedulerRuleRequest {
  param?: string(name='Param', description='The details of the CDN interaction rule. This parameter is a JSON string. The following list describes the fields in the value of the parameter:

*   **ParamType**: the type of the scheduling rule. This field is required and must be of the string type. Set the value to **cdn**. This indicates that you want to modify a CDN interaction rule.

*   **ParamData**: the values of parameters that you want to modify for the CDN interaction rule. This field is required and must be of the map type. ParamData contains the following parameters:

    *   **Domain**: the accelerated domain in CDN. This parameter is required and must be of the string type.
    *   **Cname**: the CNAME that is assigned to the accelerated domain. This parameter is required and must be of the string type.
    *   **AccessQps**: the queries per second (QPS) threshold that is used to switch service traffic to Anti-DDoS Pro or Anti-DDoS Premium. This parameter is required and must be of the integer type.
    *   **UpstreamQps**: the QPS threshold that is used to switch service traffic to CDN. This parameter is optional and must be of the integer type.', example='{"ParamType":"cdn","ParamData":{"Domain":"example.aliyundoc.com","Cname":"demo.aliyundoc.com","AccessQps":100,"UpstreamQps":100}}'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  ruleName?: string(name='RuleName', description='The name of the rule.

This parameter is required.', example='testrule'),
  ruleType?: int32(name='RuleType', description='The type of the rule. Valid values:

*   **2**: tiered protection
*   **3**: network acceleration
*   **5**: Alibaba Cloud CDN (CDN) interaction
*   **6**: cloud service interaction
*   **8**: secure acceleration

This parameter is required.', example='2'),
  rules?: string(name='Rules', description='The details of the scheduling rule. This parameter is a JSON string. The following list describes the fields in the value of the parameter:

*   **Type**: the address type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type. Valid values:

    *   **A**: IP address
    *   **CNAME**: domain name

*   **Value**: the address of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type.

*   **Priority**: the priority of the scheduling rule. This field is required and must be of the integer type. Valid values: **0** to **100**. A larger value indicates a higher priority.

*   **ValueType**: the type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the integer type. Valid values:

    *   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
    *   **2**: the IP address of the interaction resource in the tiered protection scenario
    *   **3**: the IP address that is used to accelerate access in the network acceleration scenario
    *   **5**: the domain name that is configured in Alibaba Cloud CDN (CDN) in the CDN interaction scenario
    *   **6** the IP address of the interaction resource in the cloud service interaction scenario

*   **RegionId**: the region where the interaction resource is deployed. This parameter must be specified when **ValueType** is set to **2**. The value must be of the string type.

This parameter is required.', example='[{"Type":"A", "Value":"1.1.XX.XX", "Priority":80,"ValueType":2, "RegionId":"cn-hangzhou" },{"Type":"A", "Value":"203.199.XX.XX", "Priority":80,"ValueType":1}]'),
}

model CreateSchedulerRuleResponseBody = {
  cname?: string(name='Cname', description='The CNAME that is assigned by Sec-Traffic Manager for the scheduling rule.

> To enable the scheduling rule, you must map the domain name of the service to the CNAME.', example='48k7b372gpl4****.aliyunddos0001.com'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8DFB602D-1AAC-46C4-90F2-C84086E7A6E4'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='testrule'),
}

model CreateSchedulerRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSchedulerRuleResponseBody(name='body'),
}

/**
 * @summary Creates a scheduling rule for Sec-Traffic Manager.
 *
 * @param request CreateSchedulerRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSchedulerRuleResponse
 */
async function createSchedulerRuleWithOptions(request: CreateSchedulerRuleRequest, runtime: $RuntimeOptions): CreateSchedulerRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.param)) {
    query['Param'] = request.param;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!$isNull(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!$isNull(request.rules)) {
    query['Rules'] = request.rules;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateSchedulerRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a scheduling rule for Sec-Traffic Manager.
 *
 * @param request CreateSchedulerRuleRequest
 * @return CreateSchedulerRuleResponse
 */
async function createSchedulerRule(request: CreateSchedulerRuleRequest): CreateSchedulerRuleResponse {
  var runtime = new $RuntimeOptions{};
  return createSchedulerRuleWithOptions(request, runtime);
}

model CreateTagResourcesRequest {
  regionId?: string(name='RegionId', description='The region ID of the Anti-DDoS Proxy instance.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not specify this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
  resourceIds?: [ string ](name='ResourceIds', description='The IDs of the Anti-DDoS Proxy instances to which you want to add tags.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  resourceType?: string(name='ResourceType', description='The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.

This parameter is required.', example='INSTANCE'),
  tags?: [ 
    {
      key?: string(name='Key', description='The key of the tag to add.', example='testkey'),
      value?: string(name='Value', description='The value of the tag to add.', example='testvalue'),
    }
  ](name='Tags', description='An array that consists of the tags to add.'),
}

model CreateTagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model CreateTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateTagResourcesResponseBody(name='body'),
}

/**
 * @summary Adds tags to multiple Anti-DDoS Proxy instances at a time.
 *
 * @description You can call the CreateTagResources operation to add tags to multiple Anti-DDoS Proxy instances at a time.
 * ### [](#qps-)Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request CreateTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTagResourcesResponse
 */
async function createTagResourcesWithOptions(request: CreateTagResourcesRequest, runtime: $RuntimeOptions): CreateTagResourcesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateTagResources',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Adds tags to multiple Anti-DDoS Proxy instances at a time.
 *
 * @description You can call the CreateTagResources operation to add tags to multiple Anti-DDoS Proxy instances at a time.
 * ### [](#qps-)Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request CreateTagResourcesRequest
 * @return CreateTagResourcesResponse
 */
async function createTagResources(request: CreateTagResourcesRequest): CreateTagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return createTagResourcesWithOptions(request, runtime);
}

model CreateWebCCRuleRequest {
  act?: string(name='Act', description='The action on the requests that trigger the custom frequency control rule. Valid values:

*   **close**: blocks the requests.
*   **captcha**: triggers Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) verification for the requests.

This parameter is required.', example='close'),
  count?: int32(name='Count', description='This parameter is required.', example='60'),
  domain?: string(name='Domain', description='The domain name of the website.

>  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  interval?: int32(name='Interval', description='This parameter is required.', example='20'),
  mode?: string(name='Mode', description='The matching mode. Valid values:

*   **prefix**: prefix match.
*   **match**: exact match.

>  If the **URI** of the check path contains parameters, you must set this parameter to **prefix**.

This parameter is required.', example='prefix'),
  name?: string(name='Name', description='The name of the rule. The name can be up to 128 characters in length and contain letters, digits, and underscores (_).

This parameter is required.', example='testrule'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the Anti-DDoS Proxy instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).', example='rg-acfm2pz25js****'),
  ttl?: int32(name='Ttl', description='The blocking duration. Valid values: **60** to **86400**. Unit: seconds.

This parameter is required.', example='60'),
  uri?: string(name='Uri', description='The check path.

>  The URI cannot be modified. The domain name of the website, the check path, and the rule name uniquely identify a rule.

This parameter is required.', example='/abc/a.php'),
}

model CreateWebCCRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model CreateWebCCRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateWebCCRuleResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI CreateWebCCRule is deprecated, please use ddoscoo::2020-01-01::ConfigWebCCRuleV2 instead.
 *
 * @summary Creates a custom frequency control rule for a website.
 *
 * @param request CreateWebCCRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateWebCCRuleResponse
 */
// Deprecated
async function createWebCCRuleWithOptions(request: CreateWebCCRuleRequest, runtime: $RuntimeOptions): CreateWebCCRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.act)) {
    query['Act'] = request.act;
  }
  if (!$isNull(request.count)) {
    query['Count'] = request.count;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!$isNull(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.ttl)) {
    query['Ttl'] = request.ttl;
  }
  if (!$isNull(request.uri)) {
    query['Uri'] = request.uri;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateWebCCRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI CreateWebCCRule is deprecated, please use ddoscoo::2020-01-01::ConfigWebCCRuleV2 instead.
 *
 * @summary Creates a custom frequency control rule for a website.
 *
 * @param request CreateWebCCRuleRequest
 * @return CreateWebCCRuleResponse
 */
// Deprecated
async function createWebCCRule(request: CreateWebCCRuleRequest): CreateWebCCRuleResponse {
  var runtime = new $RuntimeOptions{};
  return createWebCCRuleWithOptions(request, runtime);
}

model CreateWebRuleRequest {
  defenseId?: string(name='DefenseId', description='The ID of the associated defense. This parameter applies to scenarios in which other cloud services, such as Object Storage Service (OSS), are integrated with Anti-DDoS Pro or Anti-DDoS Premium.

> This parameter is in internal preview. Do not use this parameter.

For example, if you integrate OSS with Anti-DDoS Pro or Anti-DDoS Premium, Anti-DDoS Pro or Anti-DDoS Premium allocates an IP address pool for the OSS production account. Each IP address corresponds to a unique defense ID. A defense ID is a CNAME, which is automatically resolved to the IP address of the required Anti-DDoS Pro or Anti-DDoS Premium instance. A defense ID can be resolved to the same IP address to facilitate scheduling.

> You can specify only one of the following parameters: **InstanceIds** and **DefenseId**.', example='testid'),
  domain?: string(name='Domain', description='The domain name of the website that you want to add to the instance.

This parameter is required.', example='example.aliyundoc.com'),
  httpsExt?: string(name='HttpsExt', description='The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:

*   **Http2https**: specifies whether to turn on Enforce HTTPS Routing. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enforce HTTPS Routing is turned off. The value 1 indicates that Enforce HTTPS Routing is turned on. The default value is 0.

    If your website supports both HTTP and HTTPS, this feature meets your business requirements. If you enable this feature, all HTTP requests to access the website are redirected to HTTPS requests on the standard port 443.

*   **Https2http**: specifies whether to turn on Enable HTTP. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP is turned off. The value 1 indicates that Enable HTTP is turned on. The default value is 0.

    If your website does not support HTTPS, this feature meets your business requirements If this feature is enabled, all HTTPS requests are redirected to HTTP requests and forwarded to origin servers. This feature can redirect WebSockets requests to WebSocket requests. Requests are redirected over the standard port 80.

*   **Http2**: specifies whether to turn on Enable HTTP/2. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on. The default value is 0.

    After you turn on Enable HTTP/2, the protocol type is HTTP/2.', example='{"Http2":1,"Http2https":1,"Https2http":1}'),
  instanceIds?: [ string ](name='InstanceIds', description='An array consisting of the IDs of instances that you want to associate.', example='ddoscoo-cn-mp91j1ao****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).', example='rg-acfm2pz25js****'),
  rsType?: int32(name='RsType', description='The address type of the origin server. Valid values:

*   **0**: IP address
*   **1**: domain name The domain name of the origin server is returned if you deploy proxies, such as Web Application Firewall (WAF), between the origin server and the instance. In this case, the address of the proxy, such as the CNAME provided by WAF, is returned.

This parameter is required.', example='0'),
  rules?: string(name='Rules', description='The details of the forwarding rule. The value is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that contains the following fields:

*   **ProxyRules**: the information about the origin server. The information includes the port number and IP address. This field is required and must be a JSON array. Each element in a JSON array is a JSON struct that contains the following fields:

    *   **ProxyPort**: the port number. This field is required and must be an integer.
    *   **RealServers**: the IP address. This field is required and must be a string array.

*   **ProxyType**: the protocol type. This field is required and must be a string. Valid values: **http**, **https**, **websocket**, and **websockets**.

This parameter is required.', example='[{"ProxyRules":[{"ProxyPort":443,"RealServers":["192.1.XX.XX"]}],"ProxyType":"https"}]'),
}

model CreateWebRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9EC62E89-BD30-4FCD-9CB8-FA53865FF0D7'),
}

model CreateWebRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateWebRuleResponseBody(name='body'),
}

/**
 * @summary Creates a forwarding rule for a website.
 *
 * @param request CreateWebRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateWebRuleResponse
 */
async function createWebRuleWithOptions(request: CreateWebRuleRequest, runtime: $RuntimeOptions): CreateWebRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.defenseId)) {
    query['DefenseId'] = request.defenseId;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.httpsExt)) {
    query['HttpsExt'] = request.httpsExt;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.rsType)) {
    query['RsType'] = request.rsType;
  }
  if (!$isNull(request.rules)) {
    query['Rules'] = request.rules;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateWebRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates a forwarding rule for a website.
 *
 * @param request CreateWebRuleRequest
 * @return CreateWebRuleResponse
 */
async function createWebRule(request: CreateWebRuleRequest): CreateWebRuleResponse {
  var runtime = new $RuntimeOptions{};
  return createWebRuleWithOptions(request, runtime);
}

model DeleteAsyncTaskRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  taskId?: int32(name='TaskId', description='The ID of the task that you want to delete.

>  You can call the [DescribeAsyncTasks](~~DescribeAsyncTasks~~) operation to query the IDs of all asynchronous export tasks.

This parameter is required.', example='1'),
}

model DeleteAsyncTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DeleteAsyncTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAsyncTaskResponseBody(name='body'),
}

/**
 * @summary Deletes an asynchronous export task.
 *
 * @param request DeleteAsyncTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAsyncTaskResponse
 */
async function deleteAsyncTaskWithOptions(request: DeleteAsyncTaskRequest, runtime: $RuntimeOptions): DeleteAsyncTaskResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteAsyncTask',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes an asynchronous export task.
 *
 * @param request DeleteAsyncTaskRequest
 * @return DeleteAsyncTaskResponse
 */
async function deleteAsyncTask(request: DeleteAsyncTaskRequest): DeleteAsyncTaskResponse {
  var runtime = new $RuntimeOptions{};
  return deleteAsyncTaskWithOptions(request, runtime);
}

model DeleteAutoCcBlacklistRequest {
  blacklist?: string(name='Blacklist', description='The IP addresses that you want to manage. This parameter is a JSON string. The string contains the following fields:

*   **src**: the IP address. This field is required and must be of the STRING type.

This parameter is required.', example='[{"src":"198.51.XX.XX"},{"src":"198.52.XX.XX"}]'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  queryType?: string(name='QueryType'),
}

model DeleteAutoCcBlacklistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DeleteAutoCcBlacklistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAutoCcBlacklistResponseBody(name='body'),
}

/**
 * @summary Removes IP addresses from the IP address blacklist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request DeleteAutoCcBlacklistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAutoCcBlacklistResponse
 */
async function deleteAutoCcBlacklistWithOptions(request: DeleteAutoCcBlacklistRequest, runtime: $RuntimeOptions): DeleteAutoCcBlacklistResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.blacklist)) {
    query['Blacklist'] = request.blacklist;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.queryType)) {
    query['QueryType'] = request.queryType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteAutoCcBlacklist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Removes IP addresses from the IP address blacklist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request DeleteAutoCcBlacklistRequest
 * @return DeleteAutoCcBlacklistResponse
 */
async function deleteAutoCcBlacklist(request: DeleteAutoCcBlacklistRequest): DeleteAutoCcBlacklistResponse {
  var runtime = new $RuntimeOptions{};
  return deleteAutoCcBlacklistWithOptions(request, runtime);
}

model DeleteAutoCcWhitelistRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  whitelist?: string(name='Whitelist', description='The IP addresses that you want to manage. This parameter is a JSON string. This parameter is a JSON string. The string contains the following field:

*   **src**: the IP address. This field is required and must be of the string type.

This parameter is required.', example='[{"src":"1.1.1.1"},{"src":"2.2.2.2"}]'),
}

model DeleteAutoCcWhitelistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DeleteAutoCcWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAutoCcWhitelistResponseBody(name='body'),
}

/**
 * @summary Removes IP addresses from the IP address whitelist of an Anti-DDoS Proxy instance.
 *
 * @param request DeleteAutoCcWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAutoCcWhitelistResponse
 */
async function deleteAutoCcWhitelistWithOptions(request: DeleteAutoCcWhitelistRequest, runtime: $RuntimeOptions): DeleteAutoCcWhitelistResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.whitelist)) {
    query['Whitelist'] = request.whitelist;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteAutoCcWhitelist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Removes IP addresses from the IP address whitelist of an Anti-DDoS Proxy instance.
 *
 * @param request DeleteAutoCcWhitelistRequest
 * @return DeleteAutoCcWhitelistResponse
 */
async function deleteAutoCcWhitelist(request: DeleteAutoCcWhitelistRequest): DeleteAutoCcWhitelistResponse {
  var runtime = new $RuntimeOptions{};
  return deleteAutoCcWhitelistWithOptions(request, runtime);
}

model DeleteDomainResourceRequest {
  domain?: string(name='Domain', description='The domain name for which the forwarding rule is configured.

This parameter is required.', example='www.example.com'),
}

model DeleteDomainResourceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='39499F01-19D9-4EA4-A0E9-C6014BA5CDBE'),
}

model DeleteDomainResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDomainResourceResponseBody(name='body'),
}

/**
 * @summary Deletes a specified forwarding rule of a website.
 *
 * @param request DeleteDomainResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDomainResourceResponse
 */
async function deleteDomainResourceWithOptions(request: DeleteDomainResourceRequest, runtime: $RuntimeOptions): DeleteDomainResourceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteDomainResource',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a specified forwarding rule of a website.
 *
 * @param request DeleteDomainResourceRequest
 * @return DeleteDomainResourceResponse
 */
async function deleteDomainResource(request: DeleteDomainResourceRequest): DeleteDomainResourceResponse {
  var runtime = new $RuntimeOptions{};
  return deleteDomainResourceWithOptions(request, runtime);
}

model DeleteNetworkRuleRequest {
  networkRule?: string(name='NetworkRule', description='An array that consists of the information about the port forwarding rule. This parameter is a JSON string. The string contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.

This parameter is required.', example='[{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080}]'),
}

model DeleteNetworkRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='49AD2F34-694A-4024-9B0E-DDCFC59CCC13'),
}

model DeleteNetworkRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteNetworkRuleResponseBody(name='body'),
}

/**
 * @summary Deletes a port forwarding rule. You can delete only one port forwarding rule at a time.
 *
 * @param request DeleteNetworkRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNetworkRuleResponse
 */
async function deleteNetworkRuleWithOptions(request: DeleteNetworkRuleRequest, runtime: $RuntimeOptions): DeleteNetworkRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.networkRule)) {
    query['NetworkRule'] = request.networkRule;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteNetworkRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a port forwarding rule. You can delete only one port forwarding rule at a time.
 *
 * @param request DeleteNetworkRuleRequest
 * @return DeleteNetworkRuleResponse
 */
async function deleteNetworkRule(request: DeleteNetworkRuleRequest): DeleteNetworkRuleResponse {
  var runtime = new $RuntimeOptions{};
  return deleteNetworkRuleWithOptions(request, runtime);
}

model DeletePortRequest {
  backendPort?: string(name='BackendPort', description='The port of the origin server. Valid values: **0** to **65535**.', example='55'),
  frontendPort?: string(name='FrontendPort', description='The forwarding port. Valid values: **0** to **65535**.

This parameter is required.', example='55'),
  frontendProtocol?: string(name='FrontendProtocol', description='The type of the forwarding protocol. Valid values:

*   **tcp**
*   **udp**

This parameter is required.', example='tcp'),
  instanceId?: string(name='InstanceId', description='The ID of the Anti-DDoS Pro or Anti-DDoS Premium instance to which the port forwarding rule belongs.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-st21zbyq****'),
  realServers?: [ string ](name='RealServers', description='An array that consists of the IP addresses of origin servers.'),
}

model DeletePortResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='39499F01-19D9-4EA4-A0E9-C6014BA5CDBE'),
}

model DeletePortResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePortResponseBody(name='body'),
}

/**
 * @summary Deletes the specified port forwarding rule.
 *
 * @description After you delete a port forwarding rule, the Anti-DDoS Pro or Anti-DDoS Premium instance no longer forwards service traffic on the Layer 4 port. Before you delete a specific port forwarding rule, make sure that the service traffic destined for the Layer 4 port is redirected to the origin server. This can prevent negative impacts on your services.
 * > You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
 *
 * @param request DeletePortRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePortResponse
 */
async function deletePortWithOptions(request: DeletePortRequest, runtime: $RuntimeOptions): DeletePortResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.backendPort)) {
    query['BackendPort'] = request.backendPort;
  }
  if (!$isNull(request.frontendPort)) {
    query['FrontendPort'] = request.frontendPort;
  }
  if (!$isNull(request.frontendProtocol)) {
    query['FrontendProtocol'] = request.frontendProtocol;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.realServers)) {
    query['RealServers'] = request.realServers;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeletePort',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes the specified port forwarding rule.
 *
 * @description After you delete a port forwarding rule, the Anti-DDoS Pro or Anti-DDoS Premium instance no longer forwards service traffic on the Layer 4 port. Before you delete a specific port forwarding rule, make sure that the service traffic destined for the Layer 4 port is redirected to the origin server. This can prevent negative impacts on your services.
 * > You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
 *
 * @param request DeletePortRequest
 * @return DeletePortResponse
 */
async function deletePort(request: DeletePortRequest): DeletePortResponse {
  var runtime = new $RuntimeOptions{};
  return deletePortWithOptions(request, runtime);
}

model DeleteSceneDefensePolicyRequest {
  policyId?: string(name='PolicyId', description='The ID of the policy that you want to delete.

> You can call the [DescribeSceneDefensePolicies](https://help.aliyun.com/document_detail/159382.html) operation to query the IDs of all policies.

This parameter is required.', example='321a-fd31-df51-****'),
}

model DeleteSceneDefensePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model DeleteSceneDefensePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSceneDefensePolicyResponseBody(name='body'),
}

/**
 * @summary Deletes a scenario-specific custom policy.
 *
 * @param request DeleteSceneDefensePolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSceneDefensePolicyResponse
 */
async function deleteSceneDefensePolicyWithOptions(request: DeleteSceneDefensePolicyRequest, runtime: $RuntimeOptions): DeleteSceneDefensePolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteSceneDefensePolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a scenario-specific custom policy.
 *
 * @param request DeleteSceneDefensePolicyRequest
 * @return DeleteSceneDefensePolicyResponse
 */
async function deleteSceneDefensePolicy(request: DeleteSceneDefensePolicyRequest): DeleteSceneDefensePolicyResponse {
  var runtime = new $RuntimeOptions{};
  return deleteSceneDefensePolicyWithOptions(request, runtime);
}

model DeleteSchedulerRuleRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  ruleName?: string(name='RuleName', description='The name of the scheduling rule that you want to delete.

This parameter is required.', example='testrule'),
}

model DeleteSchedulerRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DeleteSchedulerRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSchedulerRuleResponseBody(name='body'),
}

/**
 * @summary Deletes a scheduling rule of Sec-Traffic Manager.
 *
 * @param request DeleteSchedulerRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSchedulerRuleResponse
 */
async function deleteSchedulerRuleWithOptions(request: DeleteSchedulerRuleRequest, runtime: $RuntimeOptions): DeleteSchedulerRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteSchedulerRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a scheduling rule of Sec-Traffic Manager.
 *
 * @param request DeleteSchedulerRuleRequest
 * @return DeleteSchedulerRuleResponse
 */
async function deleteSchedulerRule(request: DeleteSchedulerRuleRequest): DeleteSchedulerRuleResponse {
  var runtime = new $RuntimeOptions{};
  return deleteSchedulerRuleWithOptions(request, runtime);
}

model DeleteTagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags from the specified resource. Valid values:

*   **true**: yes.
*   **false** no. This is the default value.', example='false'),
  regionId?: string(name='RegionId', description='The region ID of the instance. Set the value to **cn-hangzhou**, which indicates an Anti-DDoS Proxy (Chinese Mainland) instance.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
  resourceIds?: [ string ](name='ResourceIds', description='An array consisting of the IDs of instances from which you want to remove tags.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  resourceType?: string(name='ResourceType', description='The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.

This parameter is required.', example='INSTANCE'),
  tagKey?: [ string ](name='TagKey', description='An array consisting of the keys of the tags that you want to remove.', example='testkey'),
}

model DeleteTagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
}

model DeleteTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteTagResourcesResponseBody(name='body'),
}

/**
 * @summary Removes tags from Anti-DDoS Proxy (Chinese Mainland) instances.
 *
 * @description You can call the DeleteTagResources operation to remove tags from Anti-DDoS Proxy (Chinese Mainland) instances.
 * >  Only Anti-DDoS Proxy (Chinese Mainland) supports tags.
 * ### [](#qps-)QPS limits
 * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DeleteTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTagResourcesResponse
 */
async function deleteTagResourcesWithOptions(request: DeleteTagResourcesRequest, runtime: $RuntimeOptions): DeleteTagResourcesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.all)) {
    query['All'] = request.all;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteTagResources',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Removes tags from Anti-DDoS Proxy (Chinese Mainland) instances.
 *
 * @description You can call the DeleteTagResources operation to remove tags from Anti-DDoS Proxy (Chinese Mainland) instances.
 * >  Only Anti-DDoS Proxy (Chinese Mainland) supports tags.
 * ### [](#qps-)QPS limits
 * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DeleteTagResourcesRequest
 * @return DeleteTagResourcesResponse
 */
async function deleteTagResources(request: DeleteTagResourcesRequest): DeleteTagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return deleteTagResourcesWithOptions(request, runtime);
}

model DeleteWebCCRuleRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  name?: string(name='Name', description='The name of the custom frequency control rule that you want to delete.

This parameter is required.', example='wq'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DeleteWebCCRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DeleteWebCCRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWebCCRuleResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DeleteWebCCRule is deprecated, please use ddoscoo::2020-01-01::DeleteWebCCRuleV2 instead.
 *
 * @summary Deletes a custom frequency control rule of a website.
 *
 * @param request DeleteWebCCRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteWebCCRuleResponse
 */
// Deprecated
async function deleteWebCCRuleWithOptions(request: DeleteWebCCRuleRequest, runtime: $RuntimeOptions): DeleteWebCCRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteWebCCRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI DeleteWebCCRule is deprecated, please use ddoscoo::2020-01-01::DeleteWebCCRuleV2 instead.
 *
 * @summary Deletes a custom frequency control rule of a website.
 *
 * @param request DeleteWebCCRuleRequest
 * @return DeleteWebCCRuleResponse
 */
// Deprecated
async function deleteWebCCRule(request: DeleteWebCCRuleRequest): DeleteWebCCRuleResponse {
  var runtime = new $RuntimeOptions{};
  return deleteWebCCRuleWithOptions(request, runtime);
}

model DeleteWebCCRuleV2Request {
  domain?: string(name='Domain', description='The domain name of the website.

>  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.example.com'),
  owner?: string(name='Owner', description='The source of the rule. Valid values:

*   **manual** (default): manually created.
*   **clover**: automatically created. Specify this value when you want to delete intelligent protection rules.', example='manual'),
  ruleNames?: string(name='RuleNames', description='The names of the rules that you want to delete.', example='[\\\\"trdsss\\\\"]'),
}

model DeleteWebCCRuleV2ResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6D48AED0-41DB-5D9B-B484-3B6AAD312AD1'),
}

model DeleteWebCCRuleV2Response = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWebCCRuleV2ResponseBody(name='body'),
}

/**
 * @summary Deletes custom frequency control rules of a website.
 *
 * @param request DeleteWebCCRuleV2Request
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteWebCCRuleV2Response
 */
async function deleteWebCCRuleV2WithOptions(request: DeleteWebCCRuleV2Request, runtime: $RuntimeOptions): DeleteWebCCRuleV2Response {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.owner)) {
    query['Owner'] = request.owner;
  }
  if (!$isNull(request.ruleNames)) {
    query['RuleNames'] = request.ruleNames;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteWebCCRuleV2',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes custom frequency control rules of a website.
 *
 * @param request DeleteWebCCRuleV2Request
 * @return DeleteWebCCRuleV2Response
 */
async function deleteWebCCRuleV2(request: DeleteWebCCRuleV2Request): DeleteWebCCRuleV2Response {
  var runtime = new $RuntimeOptions{};
  return deleteWebCCRuleV2WithOptions(request, runtime);
}

model DeleteWebCacheCustomRuleRequest {
  domain?: string(name='Domain', description='The domain name for which you want to delete the custom rules of the Static Page Caching policy.

> You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.

This parameter is required.', example='www.aliyundoc.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
  ruleNames?: [ string ](name='RuleNames', description='An array consisting of the names of the rules that you want to delete.

This parameter is required.', example='test'),
}

model DeleteWebCacheCustomRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
}

model DeleteWebCacheCustomRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWebCacheCustomRuleResponseBody(name='body'),
}

/**
 * @summary Deletes the custom rules of the Static Page Caching policy for a website.
 *
 * @description You can call the DeleteWebCacheCustomRule operation to delete the custom rules of the Static Page Caching policy for a website.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DeleteWebCacheCustomRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteWebCacheCustomRuleResponse
 */
async function deleteWebCacheCustomRuleWithOptions(request: DeleteWebCacheCustomRuleRequest, runtime: $RuntimeOptions): DeleteWebCacheCustomRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.ruleNames)) {
    query['RuleNames'] = request.ruleNames;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteWebCacheCustomRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes the custom rules of the Static Page Caching policy for a website.
 *
 * @description You can call the DeleteWebCacheCustomRule operation to delete the custom rules of the Static Page Caching policy for a website.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DeleteWebCacheCustomRuleRequest
 * @return DeleteWebCacheCustomRuleResponse
 */
async function deleteWebCacheCustomRule(request: DeleteWebCacheCustomRuleRequest): DeleteWebCacheCustomRuleResponse {
  var runtime = new $RuntimeOptions{};
  return deleteWebCacheCustomRuleWithOptions(request, runtime);
}

model DeleteWebPreciseAccessRuleRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  ruleNames?: [ string ](name='RuleNames', description='An array that consists of the names of rules to delete.

This parameter is required.', example='testrule'),
}

model DeleteWebPreciseAccessRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DeleteWebPreciseAccessRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWebPreciseAccessRuleResponseBody(name='body'),
}

/**
 * @summary Deletes the accurate access control rules that are created for a website.
 *
 * @param request DeleteWebPreciseAccessRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteWebPreciseAccessRuleResponse
 */
async function deleteWebPreciseAccessRuleWithOptions(request: DeleteWebPreciseAccessRuleRequest, runtime: $RuntimeOptions): DeleteWebPreciseAccessRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.ruleNames)) {
    query['RuleNames'] = request.ruleNames;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteWebPreciseAccessRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes the accurate access control rules that are created for a website.
 *
 * @param request DeleteWebPreciseAccessRuleRequest
 * @return DeleteWebPreciseAccessRuleResponse
 */
async function deleteWebPreciseAccessRule(request: DeleteWebPreciseAccessRuleRequest): DeleteWebPreciseAccessRuleResponse {
  var runtime = new $RuntimeOptions{};
  return deleteWebPreciseAccessRuleWithOptions(request, runtime);
}

model DeleteWebRuleRequest {
  domain?: string(name='Domain', description='The domain name of the website from which you want to delete the forwarding rule.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query the domain names for which forwarding rules are configured.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).', example='rg-acfm2pz25js****'),
}

model DeleteWebRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='9EC62E89-BD30-4FCD-9CB8-FA53865FF0D7'),
}

model DeleteWebRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWebRuleResponseBody(name='body'),
}

/**
 * @summary Deletes a forwarding rule of a website.
 *
 * @param request DeleteWebRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteWebRuleResponse
 */
async function deleteWebRuleWithOptions(request: DeleteWebRuleRequest, runtime: $RuntimeOptions): DeleteWebRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteWebRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deletes a forwarding rule of a website.
 *
 * @param request DeleteWebRuleRequest
 * @return DeleteWebRuleResponse
 */
async function deleteWebRule(request: DeleteWebRuleRequest): DeleteWebRuleResponse {
  var runtime = new $RuntimeOptions{};
  return deleteWebRuleWithOptions(request, runtime);
}

model DescribeAsyncTasksRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='10'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
}

model DescribeAsyncTasksResponseBody = {
  asyncTasks?: [ 
    {
      endTime?: long(name='EndTime', description='The end time of the task. This value is a UNIX timestamp. Unit: milliseconds.', example='157927362000'),
      startTime?: long(name='StartTime', description='The start time of the task. The value is a UNIX timestamp. Unit: milliseconds.', example='156927362000'),
      taskId?: long(name='TaskId', description='The ID of the job.', example='1'),
      taskParams?: string(name='TaskParams', description='The task parameter. The value is a JSON string. The returned field in the value varies based on the value of **TaskType**.

If **TaskType** is set to **1**, **3**, **4**, **5**, or **6**, the following filed is returned:

*   **instanceId**: the ID of the instance. Data type: string.

If **TaskType** is set to **2**, the following field is returned:

*   **domain**: the domain name of the website. Data type: string.', example='{"instanceId": "ddoscoo-cn-mp91j1ao****"}'),
      taskResult?: string(name='TaskResult', description='The execution result of the task. The value is a JSON string. The returned fields in the value vary based on the value of **TaskType**.

If **TaskType** is set to **1**, **3**, **4**, **5**, or **6**, the following fields are returned:

*   **instanceId**: the ID of the instance. Data type: string.
*   **url**: the URL to download the exported file from Object Storage Service (OSS). Data type: string.

If **TaskType** is set to **2**, the following fields are returned:

*   **domain**: the domain name of the website. Data type: string.
*   **url**: the URL to download the exported file from OSS. Data type: string.', example='{"instanceId": "ddoscoo-cn-mp91j1ao****","url": "https://****.oss-cn-beijing.aliyuncs.com/heap.bin?Expires=1584785140&OSSAccessKeyId=TMP.3KfzD82FyRJevJdEkRX6JEFHhbvRBBb75PZJnyJmksA2QkMm47xFAFDgMhEV8Nm6Vxr8xExMfiy9LsUFAcLcTBrN3r****&Signature=Sj8BNcsxJLE8l5qm4cjNlDt8gv****"}'),
      taskStatus?: int32(name='TaskStatus', description='The status of the task. Valid values:

*   **0**: indicates that the task is being initialized.
*   **1**: indicates that the task is in progress.
*   **2**: indicates that the task is successful.
*   **3**: indicates that the task failed.', example='2'),
      taskType?: int32(name='TaskType', description='The type of the task. Valid values:

*   **1**: the task to export the port forwarding rules of an instance
*   **2**: the task to export the forwarding rules of a website protected by an instance
*   **3**: the task to export the sessions and health check settings of an instance
*   **4**: the task to export the mitigation policies of an instance
*   **5**: the task to download the blacklist for destination IP addresses of an instance
*   **6**: the task to download the whitelist for destination IP addresses of an instance', example='5'),
    }
  ](name='AsyncTasks', description='An array that consists of the details of the asynchronous export tasks.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
  totalCount?: int32(name='TotalCount', description='The total number of asynchronous export tasks that are returned.', example='1'),
}

model DescribeAsyncTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAsyncTasksResponseBody(name='body'),
}

/**
 * @summary Queries the details of asynchronous export tasks, such as the IDs, start time, end time, status, parameters, and results.
 *
 * @description You can call the DescribeAsyncTasks operation to query the details of asynchronous export tasks, such as the IDs, start time, end time, status, parameters, and results.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeAsyncTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAsyncTasksResponse
 */
async function describeAsyncTasksWithOptions(request: DescribeAsyncTasksRequest, runtime: $RuntimeOptions): DescribeAsyncTasksResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeAsyncTasks',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of asynchronous export tasks, such as the IDs, start time, end time, status, parameters, and results.
 *
 * @description You can call the DescribeAsyncTasks operation to query the details of asynchronous export tasks, such as the IDs, start time, end time, status, parameters, and results.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeAsyncTasksRequest
 * @return DescribeAsyncTasksResponse
 */
async function describeAsyncTasks(request: DescribeAsyncTasksRequest): DescribeAsyncTasksResponse {
  var runtime = new $RuntimeOptions{};
  return describeAsyncTasksWithOptions(request, runtime);
}

model DescribeAttackAnalysisMaxQpsRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

This parameter is required.', example='1619798400'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

This parameter is required.', example='1622476799'),
}

model DescribeAttackAnalysisMaxQpsResponseBody = {
  qps?: long(name='Qps', description='The peak queries per second (QPS) of DDoS attacks. Units: QPS.', example='41652'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='8DFB602D-1AAC-46C4-90F2-C84086E7A6E4'),
}

model DescribeAttackAnalysisMaxQpsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAttackAnalysisMaxQpsResponseBody(name='body'),
}

/**
 * @summary Queries the peak QPS of DDoS attacks within the specific period of time.
 *
 * @param request DescribeAttackAnalysisMaxQpsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAttackAnalysisMaxQpsResponse
 */
async function describeAttackAnalysisMaxQpsWithOptions(request: DescribeAttackAnalysisMaxQpsRequest, runtime: $RuntimeOptions): DescribeAttackAnalysisMaxQpsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeAttackAnalysisMaxQps',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the peak QPS of DDoS attacks within the specific period of time.
 *
 * @param request DescribeAttackAnalysisMaxQpsRequest
 * @return DescribeAttackAnalysisMaxQpsResponse
 */
async function describeAttackAnalysisMaxQps(request: DescribeAttackAnalysisMaxQpsRequest): DescribeAttackAnalysisMaxQpsResponse {
  var runtime = new $RuntimeOptions{};
  return describeAttackAnalysisMaxQpsWithOptions(request, runtime);
}

model DescribeAutoCcBlacklistRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  keyWord?: string(name='KeyWord', description='The keyword for the query. This keyword is used to specify the prefix of the source IP address that you want to query.

> The keyword must be greater than three characters in length.', example='138'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='10'),
  queryType?: string(name='QueryType'),
}

model DescribeAutoCcBlacklistResponseBody = {
  autoCcBlacklist?: [ 
    {
      destIp?: string(name='DestIp', description='The IP address of the instance.', example='192.0.XX.XX'),
      endTime?: long(name='EndTime', description='The validity period of the IP address in the blacklist. The value is a UNIX timestamp. Unit: seconds.', example='1584093569'),
      sourceIp?: string(name='SourceIp', description='The IP address in the blacklist.', example='47.100.XX.XX'),
      type?: string(name='Type', description='The mode of how the IP address is added to the blacklist. Valid values:

*   **manual**: manually added
*   **auto**: automatically added', example='manual'),
    }
  ](name='AutoCcBlacklist', description='An array that consists of the details of the IP addresses in the blacklist of the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='E78C8472-0B15-42D5-AF22-A32A78818AB2'),
  totalCount?: long(name='TotalCount', description='The total number of returned IP addresses in the blacklist.', example='2'),
}

model DescribeAutoCcBlacklistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAutoCcBlacklistResponseBody(name='body'),
}

/**
 * @summary Queries IP addresses in the IP address blacklist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request DescribeAutoCcBlacklistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAutoCcBlacklistResponse
 */
async function describeAutoCcBlacklistWithOptions(request: DescribeAutoCcBlacklistRequest, runtime: $RuntimeOptions): DescribeAutoCcBlacklistResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.queryType)) {
    query['QueryType'] = request.queryType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeAutoCcBlacklist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries IP addresses in the IP address blacklist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request DescribeAutoCcBlacklistRequest
 * @return DescribeAutoCcBlacklistResponse
 */
async function describeAutoCcBlacklist(request: DescribeAutoCcBlacklistRequest): DescribeAutoCcBlacklistResponse {
  var runtime = new $RuntimeOptions{};
  return describeAutoCcBlacklistWithOptions(request, runtime);
}

model DescribeAutoCcListCountRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the **DescribeInstanceIds** operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  queryType?: string(name='QueryType', description='The mode of how an IP address is added to the whitelist or blacklist. Valid values:

*   **manual**: manually added
*   **auto**: automatically added', example='manual'),
}

model DescribeAutoCcListCountResponseBody = {
  blackCount?: int32(name='BlackCount', description='The total number of IP addresses in the blacklist.', example='0'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5AC3785F-C789-4622-87A4-F58BE7F6B184'),
  whiteCount?: int32(name='WhiteCount', description='The total number of IP addresses in the whitelist.', example='2'),
}

model DescribeAutoCcListCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAutoCcListCountResponseBody(name='body'),
}

/**
 * @summary Queries the numbers of IP addresses in the IP address whitelist and IP address blacklist of an Anti-DDoS Proxy instance.
 *
 * @param request DescribeAutoCcListCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAutoCcListCountResponse
 */
async function describeAutoCcListCountWithOptions(request: DescribeAutoCcListCountRequest, runtime: $RuntimeOptions): DescribeAutoCcListCountResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.queryType)) {
    query['QueryType'] = request.queryType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeAutoCcListCount',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the numbers of IP addresses in the IP address whitelist and IP address blacklist of an Anti-DDoS Proxy instance.
 *
 * @param request DescribeAutoCcListCountRequest
 * @return DescribeAutoCcListCountResponse
 */
async function describeAutoCcListCount(request: DescribeAutoCcListCountRequest): DescribeAutoCcListCountResponse {
  var runtime = new $RuntimeOptions{};
  return describeAutoCcListCountWithOptions(request, runtime);
}

model DescribeAutoCcWhitelistRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  keyWord?: string(name='KeyWord', description='The keyword for the query. This keyword is used to specify the prefix of the source IP address that you want to query.

> The keyword must be greater than three characters in length.', example='138'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='10'),
}

model DescribeAutoCcWhitelistResponseBody = {
  autoCcWhitelist?: [ 
    {
      destIp?: string(name='DestIp', description='The IP address of the instance.', example='203.***.***.117'),
      endTime?: long(name='EndTime', description='The validity period of the IP address in the whitelist. Unit: seconds. **0** indicates that the IP address in the whitelist never expires.', example='0'),
      sourceIp?: string(name='SourceIp', description='The IP addresses that is contained in the IP address whitelist.', example='2.2.2.2'),
      type?: string(name='Type', description='The mode of how an IP address is added to the whitelist. Valid values:

*   **manual**: manually added
*   **auto**: automatically added', example='manual'),
    }
  ](name='AutoCcWhitelist', description='An array that consists of details of the IP address in the whitelist of the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F09D085E-5E0F-4FF2-B32E-F4A644049162'),
  totalCount?: long(name='TotalCount', description='The total number of returned IP addresses in the whitelist.', example='2'),
}

model DescribeAutoCcWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAutoCcWhitelistResponseBody(name='body'),
}

/**
 * @summary Queries IP addresses in the IP address whitelist of an Anti-DDoS Proxy instance.
 *
 * @param request DescribeAutoCcWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAutoCcWhitelistResponse
 */
async function describeAutoCcWhitelistWithOptions(request: DescribeAutoCcWhitelistRequest, runtime: $RuntimeOptions): DescribeAutoCcWhitelistResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeAutoCcWhitelist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries IP addresses in the IP address whitelist of an Anti-DDoS Proxy instance.
 *
 * @param request DescribeAutoCcWhitelistRequest
 * @return DescribeAutoCcWhitelistResponse
 */
async function describeAutoCcWhitelist(request: DescribeAutoCcWhitelistRequest): DescribeAutoCcWhitelistResponse {
  var runtime = new $RuntimeOptions{};
  return describeAutoCcWhitelistWithOptions(request, runtime);
}

model DescribeBackSourceCidrRequest {
  ipVersion?: string(name='IpVersion', description='The IP version of the back-to-origin CIDR blocks.

*   **Ipv4**
*   **Ipv6**', example='IPv4'),
  line?: string(name='Line', description='The Internet service provider (ISP) line that you want to query.', example='coop-line-001'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
}

model DescribeBackSourceCidrResponseBody = {
  cidrs?: [ string ](name='Cidrs', description='An array that consists of the back-to-origin CIDR blocks of the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DescribeBackSourceCidrResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackSourceCidrResponseBody(name='body'),
}

/**
 * @summary Queries the back-to-origin CIDR blocks of Anti-DDoS Proxy.
 *
 * @param request DescribeBackSourceCidrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackSourceCidrResponse
 */
async function describeBackSourceCidrWithOptions(request: DescribeBackSourceCidrRequest, runtime: $RuntimeOptions): DescribeBackSourceCidrResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.ipVersion)) {
    query['IpVersion'] = request.ipVersion;
  }
  if (!$isNull(request.line)) {
    query['Line'] = request.line;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeBackSourceCidr',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the back-to-origin CIDR blocks of Anti-DDoS Proxy.
 *
 * @param request DescribeBackSourceCidrRequest
 * @return DescribeBackSourceCidrResponse
 */
async function describeBackSourceCidr(request: DescribeBackSourceCidrRequest): DescribeBackSourceCidrResponse {
  var runtime = new $RuntimeOptions{};
  return describeBackSourceCidrWithOptions(request, runtime);
}

model DescribeBlackholeStatusRequest {
  instanceIds?: [ string ](name='InstanceIds', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
}

model DescribeBlackholeStatusResponseBody = {
  blackholeStatus?: [ 
    {
      blackStatus?: string(name='BlackStatus', description='Indicates whether blackhole filtering is triggered for the instance. Valid values:

*   **blackhole**: yes
*   **normal**: no', example='blackhole'),
      endTime?: long(name='EndTime', description='The end time of blackhole filtering. The value is a UNIX timestamp. Unit: seconds.', example='1540196323'),
      ip?: string(name='Ip', description='The IP address of the instance.', example='203.***.***.132'),
      startTime?: long(name='StartTime', description='The start time of blackhole filtering. The value is a UNIX timestamp. Unit: seconds.', example='1540195323'),
    }
  ](name='BlackholeStatus', description='An array that consists of the blackhole filtering status of the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DescribeBlackholeStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBlackholeStatusResponseBody(name='body'),
}

/**
 * @summary Queries the blackhole filtering status of one or more Anti-DDoS Pro or Anti-DDoS Premium instances.
 *
 * @param request DescribeBlackholeStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBlackholeStatusResponse
 */
async function describeBlackholeStatusWithOptions(request: DescribeBlackholeStatusRequest, runtime: $RuntimeOptions): DescribeBlackholeStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeBlackholeStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the blackhole filtering status of one or more Anti-DDoS Pro or Anti-DDoS Premium instances.
 *
 * @param request DescribeBlackholeStatusRequest
 * @return DescribeBlackholeStatusResponse
 */
async function describeBlackholeStatus(request: DescribeBlackholeStatusRequest): DescribeBlackholeStatusResponse {
  var runtime = new $RuntimeOptions{};
  return describeBlackholeStatusWithOptions(request, runtime);
}

model DescribeBlockStatusRequest {
  instanceIds?: [ string ](name='InstanceIds', description='An array consisting of information about the IDs of the instances that you want to query.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
}

model DescribeBlockStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  statusList?: [ 
    {
      blockStatusList?: [ 
        {
          blockStatus?: string(name='BlockStatus', description='The blocking status of the network traffic. Valid values:

*   **areablock**: Network traffic is blocked.
*   **normal**: Network traffic is not blocked.', example='areablock'),
          endTime?: long(name='EndTime', description='The end time of the blocking. This value is a UNIX timestamp. Unit: seconds.', example='1540196323'),
          line?: string(name='Line', description='The Internet service provider (ISP) line from which the traffic is blocked. Valid values:

*   **ct**: China Telecom (International)
*   **cut**: China Unicom (International)', example='cut'),
          startTime?: long(name='StartTime', description='The start time of the blocking. This value is a UNIX timestamp. Unit: seconds.', example='1540195323'),
        }
      ](name='BlockStatusList', description='An array that consists of details of the Diversion from Origin Server configuration.'),
      ip?: string(name='Ip', description='The IP address of the instance.', example='203.XX.XX.88'),
    }
  ](name='StatusList', description='An array that consists of details of the Diversion from Origin Server configurations of the instance.'),
}

model DescribeBlockStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBlockStatusResponseBody(name='body'),
}

/**
 * @summary Queries the Diversion from Origin Server configurations of one or more Anti-DDoS Proxy (Chinese Mainland) instances.
 *
 * @description You can call this operation to query the Diversion from Origin Server configurations of one or more Anti-DDoS Proxy (Chinese Mainland) instances.
 * >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
 * ### [](#qps-)QPS limits
 * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeBlockStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBlockStatusResponse
 */
async function describeBlockStatusWithOptions(request: DescribeBlockStatusRequest, runtime: $RuntimeOptions): DescribeBlockStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeBlockStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the Diversion from Origin Server configurations of one or more Anti-DDoS Proxy (Chinese Mainland) instances.
 *
 * @description You can call this operation to query the Diversion from Origin Server configurations of one or more Anti-DDoS Proxy (Chinese Mainland) instances.
 * >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
 * ### [](#qps-)QPS limits
 * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeBlockStatusRequest
 * @return DescribeBlockStatusResponse
 */
async function describeBlockStatus(request: DescribeBlockStatusRequest): DescribeBlockStatusResponse {
  var runtime = new $RuntimeOptions{};
  return describeBlockStatusWithOptions(request, runtime);
}

model DescribeCertsRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DescribeCertsResponseBody = {
  certs?: [ 
    {
      certIdentifier?: string(name='CertIdentifier', description='The global certificate ID, which is in the certificate ID-cn-hangzhou format. If the ID of the certificate is 123, CertIdentifier is 123-cn-hangzhou.', example='126345-ap-southeast-1'),
      common?: string(name='Common', description='The domain name that is associated with the certificate.', example='www.aliyun.com'),
      domainRelated?: boolean(name='DomainRelated', description='Indicates whether the certificate is associated with the domain name. Valid values:

*   **true**
*   **false**', example='true'),
      endDate?: string(name='EndDate', description='The expiration date of the certificate. The value is a string.', example='2021-09-12'),
      id?: int32(name='Id', description='The certificate ID.', example='81'),
      issuer?: string(name='Issuer', description='The certificate authority (CA) that issued the certificate.', example='Symantec'),
      name?: string(name='Name', description='The name of the certificate.', example='testcert'),
      startDate?: string(name='StartDate', description='The issuance date of the certificate. The value is a string.', example='2019-09-12'),
    }
  ](name='Certs', description='The certificate information about the website.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DescribeCertsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCertsResponseBody(name='body'),
}

/**
 * @summary Queries information about all certificates that can be associated with the current domain name instead of the certificate currently in use.
 *
 * @description This operation is used to query all applicable certificates of a domain name that you want to add to Anti-DDoS Proxy. Multiple certificates may be queried for a domain name. You can use an exact domain name to query exact-domain certificates or wildcard-domain certificates.
 * >  If you want to query the certificate that is in use for the current domain name, you can call the [DescribeWebRules](https://help.aliyun.com/document_detail/473610.html) operation to obtain the values of the CertName and CertRegion parameters. Then, you can call the [ListUserCertificateOrder](https://help.aliyun.com/document_detail/411733.html) operation of Certificate Management Service to query the ID and other details of the certificate by using the value of the CertName parameter.
 *
 * @param request DescribeCertsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCertsResponse
 */
async function describeCertsWithOptions(request: DescribeCertsRequest, runtime: $RuntimeOptions): DescribeCertsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeCerts',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about all certificates that can be associated with the current domain name instead of the certificate currently in use.
 *
 * @description This operation is used to query all applicable certificates of a domain name that you want to add to Anti-DDoS Proxy. Multiple certificates may be queried for a domain name. You can use an exact domain name to query exact-domain certificates or wildcard-domain certificates.
 * >  If you want to query the certificate that is in use for the current domain name, you can call the [DescribeWebRules](https://help.aliyun.com/document_detail/473610.html) operation to obtain the values of the CertName and CertRegion parameters. Then, you can call the [ListUserCertificateOrder](https://help.aliyun.com/document_detail/411733.html) operation of Certificate Management Service to query the ID and other details of the certificate by using the value of the CertName parameter.
 *
 * @param request DescribeCertsRequest
 * @return DescribeCertsResponse
 */
async function describeCerts(request: DescribeCertsRequest): DescribeCertsResponse {
  var runtime = new $RuntimeOptions{};
  return describeCertsWithOptions(request, runtime);
}

model DescribeCnameReusesRequest {
  domains?: [ string ](name='Domains', description='The domain names of the websites. You can specify the domain names of up to 200 websites.

>  A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', example='default'),
}

model DescribeCnameReusesResponseBody = {
  cnameReuses?: [ 
    {
      cname?: string(name='Cname', example='4o6ep6q217k9****.aliyunddos0004.com'),
      domain?: string(name='Domain', example='www.aliyun.com'),
      enable?: int32(name='Enable', example='1'),
    }
  ](name='CnameReuses'),
  requestId?: string(name='RequestId', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DescribeCnameReusesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCnameReusesResponseBody(name='body'),
}

/**
 * @param request DescribeCnameReusesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCnameReusesResponse
 */
async function describeCnameReusesWithOptions(request: DescribeCnameReusesRequest, runtime: $RuntimeOptions): DescribeCnameReusesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domains)) {
    query['Domains'] = request.domains;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeCnameReuses',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request DescribeCnameReusesRequest
 * @return DescribeCnameReusesResponse
 */
async function describeCnameReuses(request: DescribeCnameReusesRequest): DescribeCnameReusesResponse {
  var runtime = new $RuntimeOptions{};
  return describeCnameReusesWithOptions(request, runtime);
}

model DescribeDDoSEventsRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200'),
  instanceIds?: [ string ](name='InstanceIds', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='10'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribeDDoSEventsResponseBody = {
  DDoSEvents?: [ 
    {
      bps?: long(name='Bps', description='The bandwidth of attack traffic. Unit: bit/s.', example='0'),
      endTime?: long(name='EndTime', description='The time when the DDoS attack stopped. The value is a UNIX timestamp. Unit: seconds.', example='1583933330'),
      eventType?: string(name='EventType', description='The type of the attack event. Valid values:

*   **defense**: traffic scrubbing events
*   **blackhole**: blackhole filtering events', example='blackhole'),
      ip?: string(name='Ip', description='The attacked IP address.', example='203.***.***.132'),
      port?: string(name='Port', description='The attacked port.', example='80'),
      pps?: long(name='Pps', description='The packet forwarding rate of attack traffic. Unit: packets per second (pps).', example='0'),
      region?: string(name='Region', description='The region from which the attack was launched. Valid values:

*   **cn**: a region in the Chinese mainland
*   **alb-ap-northeast-1-gf-x**: Japan (Tokyo)
*   **alb-ap-southeast-gf-x**: Singapore
*   **alb-cn-hongkong-gf-x**: Hong Kong (China)
*   **alb-eu-central-1-gf-x**: Germany (Frankfurt)
*   **alb-us-west-1-gf-x**: US (Silicon Valley)

> The values except **cn** are returned only when **RegionId** is set to **ap-southeast-1**.', example='cn'),
      startTime?: long(name='StartTime', description='The time when the DDoS attack started. The value is a UNIX timestamp. Unit: seconds.', example='1583933277'),
    }
  ](name='DDoSEvents', description='The DDoS attack events.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0CA72AF5-1795-4350-8C77-50A448A2F334'),
  total?: long(name='Total', description='The total number of returned attack events.', example='1'),
}

model DescribeDDoSEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDDoSEventsResponseBody(name='body'),
}

/**
 * @summary Queries the attack events launched against one or more Anti-DDoS Proxy instances.
 *
 * @param request DescribeDDoSEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDDoSEventsResponse
 */
async function describeDDoSEventsWithOptions(request: DescribeDDoSEventsRequest, runtime: $RuntimeOptions): DescribeDDoSEventsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDDoSEvents',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the attack events launched against one or more Anti-DDoS Proxy instances.
 *
 * @param request DescribeDDoSEventsRequest
 * @return DescribeDDoSEventsResponse
 */
async function describeDDoSEvents(request: DescribeDDoSEventsRequest): DescribeDDoSEventsResponse {
  var runtime = new $RuntimeOptions{};
  return describeDDoSEventsWithOptions(request, runtime);
}

model DescribeDDosAllEventListRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The DDoS attack events occur before **EndTime** are queried. This value is a UNIX timestamp. Unit: seconds.

This parameter is required.', example='1640966399'),
  eventType?: string(name='EventType', description='The type of the DDoS attack events you want to query. Valid values:

*   **web-cc**: resource exhaustion attacks
*   **cc**: connection flood attacks
*   **defense**: DDoS attacks that trigger traffic scrubbing
*   **blackhole**: DDoS attacks that trigger blackhole filtering

If you want to query multiple types of DDoS attack events, separate them with commas (,).

If you do not configure this parameter, DDoS attack events of all types are queried.', example='defense'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='10'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The DDoS attack events occur after **StartTime** are queried. This value is a UNIX timestamp. Unit: seconds.

This parameter is required.', example='1609430400'),
}

model DescribeDDosAllEventListResponseBody = {
  attackEvents?: [ 
    {
      area?: string(name='Area', description='The source location or region from which the attack was initiated. Valid values:

*   **cn**: Chinese mainland
*   **alb-cn-hongkong-gf-2**: China (Hongkong)
*   **alb-us-west-1-gf-2**: US (Silicon Valley)
*   **alb-ap-northeast-1-gf-1**: Japan (Tokyo)
*   **alb-ap-southeast-gf-1**: Singapore
*   **alb-eu-central-1-gf-1**: Germany (Frankfurt)
*   **alb-eu-central-1-gf-1** or **selb-eu-west-1-gf-1a**: UK (London)
*   **alb-us-east-gf-1**: US (Virginia)
*   **CT-yundi**: China (Hongkong) This value is returned only for Anti-DDoS Premium instances of the Secure Chinese Mainland Acceleration (Sec-CMA) mitigation plan.', example='cn'),
      endTime?: long(name='EndTime', description='The time when the DDoS attack stopped. This value is a UNIX timestamp. Unit: seconds.', example='1634546030'),
      eventType?: string(name='EventType', description='The type of the DDoS attack event. Valid values:

*   **web-cc**: resource exhaustion attacks
*   **cc**: connection flood attacks
*   **defense**: DDoS attacks that trigger traffic scrubbing
*   **blackhole**: DDoS attacks that trigger blackhole filtering', example='cc'),
      ip?: string(name='Ip', description='The attacked object. The attacked object varies based on the attack event type. The following list describes different attacked objects of different attack event types:

*   If **EventType** is set to **web-cc**, the value of this parameter indicates the domain name of the attacked website.
*   If **EventType** is set to **cc**, the value of this parameter indicates the IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.
*   If **EventType** is set to **defense** or **blackhole**, the value of this parameter indicates the IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.', example='203.107.XX.XX'),
      mbps?: long(name='Mbps', description='The peak bandwidth of the attack traffic. Unit: Mbit/s.', example='101899'),
      port?: string(name='Port', description='The attacked port.

> If **EventType** is set to **web-cc**, this parameter is not returned.', example='80'),
      pps?: long(name='Pps', description='The peak packet forwarding rate of attack traffic. Unit: packets per second (pps).', example='9664270'),
      startTime?: long(name='StartTime', description='The time when the DDoS attack started. This value is a UNIX timestamp. Unit: seconds.', example='1634543764'),
    }
  ](name='AttackEvents', description='The DDoS attack events.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25D83ED5-28CB-5683-9CF7-AECE521F3005'),
  total?: long(name='Total', description='The total number of DDoS attack events.', example='1'),
}

model DescribeDDosAllEventListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDDosAllEventListResponseBody(name='body'),
}

/**
 * @summary Queries DDoS attack events.
 *
 * @description You can call the DescribeDDosAllEventList operation to query DDoS attack events within a specific time range by page. The information about a DDoS attack event includes the start time and end time of the attack, attack event type, attacked object, peak bandwidth of attack traffic, and peak packet forwarding rate.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeDDosAllEventListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDDosAllEventListResponse
 */
async function describeDDosAllEventListWithOptions(request: DescribeDDosAllEventListRequest, runtime: $RuntimeOptions): DescribeDDosAllEventListResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDDosAllEventList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries DDoS attack events.
 *
 * @description You can call the DescribeDDosAllEventList operation to query DDoS attack events within a specific time range by page. The information about a DDoS attack event includes the start time and end time of the attack, attack event type, attacked object, peak bandwidth of attack traffic, and peak packet forwarding rate.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeDDosAllEventListRequest
 * @return DescribeDDosAllEventListResponse
 */
async function describeDDosAllEventList(request: DescribeDDosAllEventListRequest): DescribeDDosAllEventListResponse {
  var runtime = new $RuntimeOptions{};
  return describeDDosAllEventListWithOptions(request, runtime);
}

model DescribeDDosEventAreaRequest {
  eventType?: string(name='EventType', description='The type of the attack event that you want to query. Valid values:

*   **defense**: attack events that trigger traffic scrubbing
*   **blackhole**: attack events that trigger blackhole filtering

This parameter is required.', example='defense'),
  ip?: string(name='Ip', description='The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.

This parameter is required.', example='203.***.***.199'),
  range?: long(name='Range'),
  startTime?: long(name='StartTime', description='The UNIX timestamp when the query starts. Unit: seconds.

> You can call the [DescribeDDosAllEventList](https://help.aliyun.com/document_detail/188604.html) operation to query the beginning time of all attack events.

This parameter is required.', example='1598948471'),
}

model DescribeDDosEventAreaResponseBody = {
  areas?: [ 
    {
      area?: string(name='Area', description='The code or ID of the source region. For more information, see [Codes of administrative regions in China and codes of countries and areas](https://help.aliyun.com/document_detail/167926.html). For example, **110000** indicates Beijing, China, and **us** indicates the United States.', example='110000'),
      inPkts?: long(name='InPkts', description='The number of request packets that were sent from the source region.', example='228'),
    }
  ](name='Areas', description='The information about the source region from which the volumetric attack was initiated.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='11710C9F-BC5E-481A-BEC5-C6D8FBFCA827'),
}

model DescribeDDosEventAreaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDDosEventAreaResponseBody(name='body'),
}

/**
 * @summary Queries the source region from which a volumetric attack is initiated.
 *
 * @description > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventAreaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDDosEventAreaResponse
 */
async function describeDDosEventAreaWithOptions(request: DescribeDDosEventAreaRequest, runtime: $RuntimeOptions): DescribeDDosEventAreaResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!$isNull(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!$isNull(request.range)) {
    query['Range'] = request.range;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDDosEventArea',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the source region from which a volumetric attack is initiated.
 *
 * @description > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventAreaRequest
 * @return DescribeDDosEventAreaResponse
 */
async function describeDDosEventArea(request: DescribeDDosEventAreaRequest): DescribeDDosEventAreaResponse {
  var runtime = new $RuntimeOptions{};
  return describeDDosEventAreaWithOptions(request, runtime);
}

model DescribeDDosEventAttackTypeRequest {
  eventType?: string(name='EventType', description='The type of the attack event that you want to query. Valid values:

*   **defense**: attack events that trigger traffic scrubbing
*   **blackhole**: attack events that trigger blackhole filtering

This parameter is required.', example='defense'),
  ip?: string(name='Ip', description='The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.

This parameter is required.', example='203.***.***.199'),
  startTime?: long(name='StartTime', description='The UNIX timestamp when the query starts. Unit: seconds.

> You can call the [DescribeDDosAllEventList](https://help.aliyun.com/document_detail/188604.html) operation to query the beginning time of all attack events.

This parameter is required.', example='1598948471'),
}

model DescribeDDosEventAttackTypeResponseBody = {
  attackTypes?: [ 
    {
      attackType?: string(name='AttackType', description='The type of the attack Valid values:

*   **QOTD-Reflect-Flood**: QOTD reflection attacks
*   **CharGEN-Reflect-Flood**: CHARGEN reflection attacks
*   **DNS-Reflect-Flood**: DNS reflection attacks
*   **TFTP-Reflect-Flood**: TFTP reflection attacks
*   **Portmap-Reflect-Flood**: Portmap reflection attacks
*   **NTP-Reflect-Flood**: NTP reflection attacks
*   **NetBIOS-Reflect-Flood**: NetBIOS reflection attacks
*   **SNMPv2-Reflect-Flood**: SNMPv2 reflection attacks
*   **CLDAP-Reflect-Flood**: CLDAP reflection attacks
*   **Ripv1-Reflect-Flood**: RIPv1 reflection attacks
*   **OpenVPN-Reflect-Flood**: OpenVPN reflection attacks
*   **SSDP-Reflect-Flood**: SSDP reflection attacks
*   **NetAssistant-Reflect-Flood**: NetAssistant reflection attacks
*   **WSDiscovery-Reflect-Flood**: WS-Discovery reflection attacks
*   **Kad-Reflect-Flood**: Kad reflection attacks
*   **mDNS-Reflect-Flood**: mDNS reflection attacks
*   **10001-Reflect-Flood**: reflection attacks over port 10001
*   **Memcached-Reflect-Flood**: Memcached reflection attacks
*   **QNP-Reflect-Flood**: QNP reflection attacks
*   **DVR-Reflect-Flood**: DVR reflection attacks
*   **CoAP-Reflect-Flood**: CoAP reflection attacks
*   **ADDP-Reflect-Flood**: ADDP reflection attacks
*   **Tcp-Syn**: TCP SYN flood attacks
*   **Tcp-Fin**: TCP FIN flood attacks
*   **Tcp-Ack**: TCP ACK flood attacks
*   **Tcp-Rst**: TCP RST flood attacks
*   **Tcp-Pushack**: TCP PSH-ACK flood attacks
*   **Tcp-Synack**: TCP SYN-ACK flood attacks
*   **Udp-None**: UDP attacks
*   **Udp-Ssh**: UDP-based SSH attacks
*   **Udp-Dns**: UDP-based DNS attacks
*   **Udp-Http**: UDP-based HTTP attacks
*   **Udp-Https**: UDP-based HTTPS attacks
*   **Udp-Ntp**: UDP-based NTP attacks
*   **Udp-Ldap**: UDP-based LDAP attacks
*   **Udp-Ssdp**: UDP-based SSDP attacks
*   **Udp-Memcached**: Memcached UDP reflection attacks
*   **Tcp-Other**: other TCP attacks
*   **Icmp**: ICMP flood attacks
*   **Igmp**: IGMP flood attacks
*   **Ipv6**: IPv6 attacks', example='Tcp-Syn'),
      inPkts?: long(name='InPkts', description='The number of request packets of the attack type.', example='145902'),
    }
  ](name='AttackTypes', description='The information about the attack types.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6F644A6E-40E7-483F-9DBB-CC27E16BB555'),
}

model DescribeDDosEventAttackTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDDosEventAttackTypeResponseBody(name='body'),
}

/**
 * @summary Queries the attack type details of a volumetric attack.
 *
 * @description > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventAttackTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDDosEventAttackTypeResponse
 */
async function describeDDosEventAttackTypeWithOptions(request: DescribeDDosEventAttackTypeRequest, runtime: $RuntimeOptions): DescribeDDosEventAttackTypeResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!$isNull(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDDosEventAttackType',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the attack type details of a volumetric attack.
 *
 * @description > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventAttackTypeRequest
 * @return DescribeDDosEventAttackTypeResponse
 */
async function describeDDosEventAttackType(request: DescribeDDosEventAttackTypeRequest): DescribeDDosEventAttackTypeResponse {
  var runtime = new $RuntimeOptions{};
  return describeDDosEventAttackTypeWithOptions(request, runtime);
}

model DescribeDDosEventIspRequest {
  eventType?: string(name='EventType', description='The type of the attack event that you want to query. Valid values:

*   **defense**: attack events that trigger traffic scrubbing
*   **blackhole**: attack events that trigger blackhole filtering

This parameter is required.', example='defense'),
  ip?: string(name='Ip', description='The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.

This parameter is required.', example='203.***.***.199'),
  range?: long(name='Range'),
  startTime?: long(name='StartTime', description='The UNIX timestamp when the query starts. Unit: seconds.

> You can call the [DescribeDDosAllEventList](https://help.aliyun.com/document_detail/188604.html) operation to query the beginning time of all attack events.

This parameter is required.', example='1598948471'),
}

model DescribeDDosEventIspResponseBody = {
  isps?: [ 
    {
      inPkts?: long(name='InPkts', description='The number of request packets that were sent from the ISP.', example='230'),
      isp?: string(name='Isp', description='The code of the ISP. Valid values:

*   **100017**: China Telecom
*   **100026**: China Unicom
*   **100025**: China Mobile
*   **100027**: China Education and Research Network
*   **100020**: China Mobile Tietong
*   **1000143**: Dr.Peng Telecom & Media Group
*   **100080**: Beijing Gehua CATV Network
*   **1000139**: National Radio and Television Administration
*   **100023**: Oriental Cable Network
*   **100063**: Founder Broadband
*   **1000337**: China Internet Exchange
*   **100021**: 21Vianet Group
*   **1000333**: Wasu Media Holding
*   **100093**: Wangsu Science & Technology
*   **1000401**: Tencent
*   **100099**: Baidu
*   **1000323**: Alibaba Cloud
*   **100098**: Alibaba', example='1000323'),
    }
  ](name='Isps', description='The ISPs for the volumetric attack.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C4A3BCD1-4A32-4342-941A-4745AE69508C'),
}

model DescribeDDosEventIspResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDDosEventIspResponseBody(name='body'),
}

/**
 * @summary Queries the Internet service provider (ISP) information about a volumetric attack.
 *
 * @description > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventIspRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDDosEventIspResponse
 */
async function describeDDosEventIspWithOptions(request: DescribeDDosEventIspRequest, runtime: $RuntimeOptions): DescribeDDosEventIspResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!$isNull(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!$isNull(request.range)) {
    query['Range'] = request.range;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDDosEventIsp',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the Internet service provider (ISP) information about a volumetric attack.
 *
 * @description > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventIspRequest
 * @return DescribeDDosEventIspResponse
 */
async function describeDDosEventIsp(request: DescribeDDosEventIspRequest): DescribeDDosEventIspResponse {
  var runtime = new $RuntimeOptions{};
  return describeDDosEventIspWithOptions(request, runtime);
}

model DescribeDDosEventMaxRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

This parameter is required.', example='1604073600'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

This parameter is required.', example='1598889600'),
}

model DescribeDDosEventMaxResponseBody = {
  cps?: long(name='Cps', description='The peak of connection flood attacks. Unit: connections per seconds (CPS).', example='1302'),
  mbps?: long(name='Mbps', description='The peak of volumetric attacks. Unit: Mbit/s.', example='6809'),
  qps?: long(name='Qps', description='The peak of resource exhaustion attacks. Unit: queries per second (QPS).', example='26314'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5AE2FC86-C840-41AE-9F1A-3A2747C7C1DF'),
}

model DescribeDDosEventMaxResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDDosEventMaxResponseBody(name='body'),
}

/**
 * @summary Queries the peaks of volumetric attacks (bit/s), connection flood attacks (CPS), and resource exhaustion attacks on websites (QPS).
 *
 * @param request DescribeDDosEventMaxRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDDosEventMaxResponse
 */
async function describeDDosEventMaxWithOptions(request: DescribeDDosEventMaxRequest, runtime: $RuntimeOptions): DescribeDDosEventMaxResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDDosEventMax',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the peaks of volumetric attacks (bit/s), connection flood attacks (CPS), and resource exhaustion attacks on websites (QPS).
 *
 * @param request DescribeDDosEventMaxRequest
 * @return DescribeDDosEventMaxResponse
 */
async function describeDDosEventMax(request: DescribeDDosEventMaxRequest): DescribeDDosEventMaxResponse {
  var runtime = new $RuntimeOptions{};
  return describeDDosEventMaxWithOptions(request, runtime);
}

model DescribeDDosEventSrcIpRequest {
  eventType?: string(name='EventType', description='The type of the attack event that you want to query. Valid values:

*   **defense**: attack events that trigger traffic scrubbing
*   **blackhole**: attack events that trigger blackhole filtering

This parameter is required.', example='defense'),
  ip?: string(name='Ip', description='The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.

This parameter is required.', example='203.***.***.199'),
  range?: long(name='Range', description='The number of source IP addresses that you want to return. The source IP addresses are returned in descending order of attack traffic. By default, the top **five** source IP addresses are returned.

This parameter is required.', example='2'),
  startTime?: long(name='StartTime', description='The UNIX timestamp when the query starts. Unit: seconds.

> You can call the [DescribeDDosAllEventList](https://help.aliyun.com/document_detail/188604.html) operation to query the beginning time of all attack events.

This parameter is required.', example='1598948471'),
}

model DescribeDDosEventSrcIpResponseBody = {
  ips?: [ 
    {
      areaId?: string(name='AreaId', description='The code or ID of the source region. For more information, see [Codes of administrative regions in China and codes of countries and areas](https://help.aliyun.com/document_detail/167926.html). For example, **110000** indicates Beijing, China, and **us** indicates the United States.', example='110000'),
      isp?: string(name='Isp', description='The Internet service provider (ISP) for the volumetric attack. Valid values:

*   **100017**: China Telecom
*   **100026**: China Unicom
*   **100025**: China Mobile
*   **100027**: China Education and Research Network
*   **100020**: China Mobile Tietong
*   **1000143**: Dr.Peng Telecom & Media Group
*   **100080**: Beijing Gehua CATV Network
*   **1000139**: National Radio and Television Administration
*   **100023**: Oriental Cable Network
*   **100063**: Founder Broadband
*   **1000337**: China Internet Exchange
*   **100021**: 21Vianet Group
*   **1000333**: Wasu Media Holding
*   **100093**: Wangsu Science & Technology
*   **1000401**: Tencent
*   **100099**: Baidu
*   **1000323**: Alibaba Cloud
*   **100098**: Alibaba', example='100026'),
      srcIp?: string(name='SrcIp', description='The source IP address of the volumetric attack.', example='218.***.***.24'),
    }
  ](name='Ips', description='An array that consists of information about the source IP address of the volumetric attack.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='38A0224E-FDBC-4733-A362-B391827FC1E9'),
}

model DescribeDDosEventSrcIpResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDDosEventSrcIpResponseBody(name='body'),
}

/**
 * @summary Queries the source IP address from which a volumetric attack is initiated.
 *
 * @description > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventSrcIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDDosEventSrcIpResponse
 */
async function describeDDosEventSrcIpWithOptions(request: DescribeDDosEventSrcIpRequest, runtime: $RuntimeOptions): DescribeDDosEventSrcIpResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!$isNull(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!$isNull(request.range)) {
    query['Range'] = request.range;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDDosEventSrcIp',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the source IP address from which a volumetric attack is initiated.
 *
 * @description > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventSrcIpRequest
 * @return DescribeDDosEventSrcIpResponse
 */
async function describeDDosEventSrcIp(request: DescribeDDosEventSrcIpRequest): DescribeDDosEventSrcIpResponse {
  var runtime = new $RuntimeOptions{};
  return describeDDosEventSrcIpWithOptions(request, runtime);
}

model DescribeDefenseCountStatisticsRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
}

model DescribeDefenseCountStatisticsResponseBody = {
  defenseCountStatistics?: {
    defenseCountTotalUsageOfCurrentMonth?: int32(name='DefenseCountTotalUsageOfCurrentMonth', description='The number of advanced mitigation sessions that are used within the current calendar month.', example='0'),
    flowPackCountRemain?: int32(name='FlowPackCountRemain', description='The number of available global advanced mitigation sessions for the Insurance mitigation plan.', example='0'),
    maxUsableDefenseCountCurrentMonth?: int32(name='MaxUsableDefenseCountCurrentMonth', description='The maximum number of advanced mitigation sessions available for the current calendar month. The advanced mitigation sessions include the advanced mitigation sessions that are provided free of charge and the global advanced mitigation sessions that you purchase.', example='20'),
    secHighSpeedCountRemain?: int32(name='SecHighSpeedCountRemain', description='The number of available global advanced mitigation sessions for the Secure Chinese Mainland Acceleration (Sec-CMA) mitigation plan.', example='0'),
  }(name='DefenseCountStatistics', description='The statistics on the number of advanced mitigation sessions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='310A41FD-0990-5610-92E0-A6A55D7C6444'),
}

model DescribeDefenseCountStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDefenseCountStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on advanced mitigation sessions of an Anti-DDoS Proxy (Outside Chinese Mainland) instance.
 *
 * @description You can call the DescribeDefenseCountStatistics operation to query the information about advanced mitigation sessions of an Anti-DDoS Proxy (Outside Chinese Mainland) instance. For example, you can query the number of advanced mitigation sessions that are used within the current calendar month and the number of remaining advanced mitigation sessions.
 * >  This operation is suitable only for Anti-DDoS Proxy (Outside Chinese Mainland).
 * ### [](#qps-)QPS limits
 * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeDefenseCountStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDefenseCountStatisticsResponse
 */
async function describeDefenseCountStatisticsWithOptions(request: DescribeDefenseCountStatisticsRequest, runtime: $RuntimeOptions): DescribeDefenseCountStatisticsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDefenseCountStatistics',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics on advanced mitigation sessions of an Anti-DDoS Proxy (Outside Chinese Mainland) instance.
 *
 * @description You can call the DescribeDefenseCountStatistics operation to query the information about advanced mitigation sessions of an Anti-DDoS Proxy (Outside Chinese Mainland) instance. For example, you can query the number of advanced mitigation sessions that are used within the current calendar month and the number of remaining advanced mitigation sessions.
 * >  This operation is suitable only for Anti-DDoS Proxy (Outside Chinese Mainland).
 * ### [](#qps-)QPS limits
 * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeDefenseCountStatisticsRequest
 * @return DescribeDefenseCountStatisticsResponse
 */
async function describeDefenseCountStatistics(request: DescribeDefenseCountStatisticsRequest): DescribeDefenseCountStatisticsResponse {
  var runtime = new $RuntimeOptions{};
  return describeDefenseCountStatisticsWithOptions(request, runtime);
}

model DescribeDefenseRecordsRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. This value is a UNIX timestamp. Units: miliseconds.

> The time must be in the latest 90 days.

This parameter is required.', example='1583683200000'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: **50**.

This parameter is required.', example='10'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. This value is a UNIX timestamp. Units: miliseconds.

> The time must be in the latest 90 days.

This parameter is required.', example='1582992000000'),
}

model DescribeDefenseRecordsResponseBody = {
  defenseRecords?: [ 
    {
      attackPeak?: long(name='AttackPeak', description='The peak attack traffic. Unit: bit/s.', example='6584186000'),
      endTime?: long(name='EndTime', description='The end time of the advanced mitigation session. This value is a UNIX timestamp. Units: miliseconds.', example='1583683200000'),
      eventCount?: int32(name='EventCount', description='The number of attacks.', example='2'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-mp91j1ao****'),
      startTime?: long(name='StartTime', description='The start time of the advanced mitigation session. This value is a UNIX timestamp. Units: miliseconds.', example='1582992000000'),
      status?: int32(name='Status', description='The status of the advanced mitigation session. Valid values:

*   **0**: The advanced mitigation session is being used.
*   **1**: The advanced mitigation session is used.', example='0'),
    }
  ](name='DefenseRecords', description='An array that consists of details of the log of an advanced mitigation session.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
  totalCount?: long(name='TotalCount', description='The total number of advanced mitigation sessions.', example='1'),
}

model DescribeDefenseRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDefenseRecordsResponseBody(name='body'),
}

/**
 * @summary Queries the advanced mitigation logs of an Anti-DDoS Proxy (Outside Chinese Mainland) instance.
 *
 * @description > This operation is suitable only for Anti-DDoS Premium.
 *
 * @param request DescribeDefenseRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDefenseRecordsResponse
 */
async function describeDefenseRecordsWithOptions(request: DescribeDefenseRecordsRequest, runtime: $RuntimeOptions): DescribeDefenseRecordsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDefenseRecords',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the advanced mitigation logs of an Anti-DDoS Proxy (Outside Chinese Mainland) instance.
 *
 * @description > This operation is suitable only for Anti-DDoS Premium.
 *
 * @param request DescribeDefenseRecordsRequest
 * @return DescribeDefenseRecordsResponse
 */
async function describeDefenseRecords(request: DescribeDefenseRecordsRequest): DescribeDefenseRecordsResponse {
  var runtime = new $RuntimeOptions{};
  return describeDefenseRecordsWithOptions(request, runtime);
}

model DescribeDestinationPortEventRequest {
  eventType?: string(name='EventType', description='The type of the attack event that you want to query. Valid values:

*   **defense**: attack events that trigger traffic scrubbing.
*   **blackhole**: attack events that trigger blackhole filtering.

This parameter is required.', example='defense'),
  ip?: string(name='Ip', description='The IP address of the attacker.

This parameter is required.', example='203.107.XX.XX'),
  range?: long(name='Range', description='The number of destination ports to return. The ports are sorted in descending order of the number of received request packets. By default, the first **10** ports are returned.

This parameter is required.', example='2'),
  region?: string(name='Region', description='The region in which your service is deployed. Valid values:

*   **cn**: a region in the Chinese mainland.
*   **cn-hongkong**: a region outside the Chinese mainland.

This parameter is required.', example='cn'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1720059000'),
}

model DescribeDestinationPortEventResponseBody = {
  portList?: [ 
    {
      dstPort?: string(name='DstPort', description='The destination port.', example='80'),
      inPkts?: long(name='InPkts', description='The number of request packets received by the destination port.', example='8760950'),
    }
  ](name='PortList', description='The ports.'),
  requestId?: string(name='RequestId', description='The request ID.', example='9E7F6B2C-03F2-462F-9076-B782CF0DD502'),
}

model DescribeDestinationPortEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDestinationPortEventResponseBody(name='body'),
}

/**
 * @summary Queries the number of request packets received by the destination ports of the attacked IP address that is protected by Anti-DDoS Proxy.
 *
 * @param request DescribeDestinationPortEventRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDestinationPortEventResponse
 */
async function describeDestinationPortEventWithOptions(request: DescribeDestinationPortEventRequest, runtime: $RuntimeOptions): DescribeDestinationPortEventResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.eventType)) {
    query['EventType'] = request.eventType;
  }
  if (!$isNull(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!$isNull(request.range)) {
    query['Range'] = request.range;
  }
  if (!$isNull(request.region)) {
    query['Region'] = request.region;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDestinationPortEvent',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the number of request packets received by the destination ports of the attacked IP address that is protected by Anti-DDoS Proxy.
 *
 * @param request DescribeDestinationPortEventRequest
 * @return DescribeDestinationPortEventResponse
 */
async function describeDestinationPortEvent(request: DescribeDestinationPortEventRequest): DescribeDestinationPortEventResponse {
  var runtime = new $RuntimeOptions{};
  return describeDestinationPortEventWithOptions(request, runtime);
}

model DescribeDomainAttackEventsRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='www.aliyun.com'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1583683200'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='10'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribeDomainAttackEventsResponseBody = {
  domainAttackEvents?: [ 
    {
      domain?: string(name='Domain', description='The attacked domain name.', example='www.aliyun.com'),
      endTime?: long(name='EndTime', description='The time when the DDoS attack stopped. The value is a UNIX timestamp. Unit: seconds.', example='1560320160'),
      maxQps?: long(name='MaxQps', description='The peak attack QPS.', example='1000'),
      startTime?: long(name='StartTime', description='The time when the DDoS attack started. The value is a UNIX timestamp. Unit: seconds.', example='1560312900'),
    }
  ](name='DomainAttackEvents', description='An array that consists of the details of the DDoS attack event.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  totalCount?: long(name='TotalCount', description='The total number of returned DDoS attack events.', example='1'),
}

model DescribeDomainAttackEventsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainAttackEventsResponseBody(name='body'),
}

/**
 * @summary Queries the attack events launched against a website.
 *
 * @param request DescribeDomainAttackEventsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainAttackEventsResponse
 */
async function describeDomainAttackEventsWithOptions(request: DescribeDomainAttackEventsRequest, runtime: $RuntimeOptions): DescribeDomainAttackEventsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainAttackEvents',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the attack events launched against a website.
 *
 * @param request DescribeDomainAttackEventsRequest
 * @return DescribeDomainAttackEventsResponse
 */
async function describeDomainAttackEvents(request: DescribeDomainAttackEventsRequest): DescribeDomainAttackEventsResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainAttackEventsWithOptions(request, runtime);
}

model DescribeDomainBpsRequest {
  domain?: string(name='Domain', description='The domain name of the website.

>  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='www.example.com'),
  endTime?: long(name='EndTime', description='The end of the time range to query. This value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1722339300'),
  interval?: long(name='Interval', description='The interval for returning data. Unit: seconds. Valid values are 300, 3600, and 86400. If the time span between StartTime and EndTime is less than 3 days, valid values are 300, 3600, and 86400. If the time span between StartTime and EndTime is from 3 to 30 days, valid values are 3600 and 86400. If the time span between StartTime and EndTime is 31 days or longer, the valid value is 86400. If you leave this parameter empty or specify an invalid value, the default value is used.

This parameter is required.', example='600'),
  region?: string(name='Region', description='The region in which your service is deployed. Valid values:

*   **cn**: a region in the Chinese mainland.
*   **cn-hongkong**: a region outside the Chinese mainland.

This parameter is required.', example='cn'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. This value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1719211800'),
}

model DescribeDomainBpsResponseBody = {
  domainBps?: [ 
    {
      inBps?: long(name='InBps', description='The inbound bandwidth. Unit: bit/s.', example='0'),
      index?: long(name='Index', description='The index number of the returned data.', example='1'),
      outBps?: long(name='OutBps', description='The outbound bandwidth. Unit: bit/s.', example='0'),
    }
  ](name='DomainBps', description='The bandwidths.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DescribeDomainBpsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainBpsResponseBody(name='body'),
}

/**
 * @summary Queries the bandwidths of a website.
 *
 * @param request DescribeDomainBpsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainBpsResponse
 */
async function describeDomainBpsWithOptions(request: DescribeDomainBpsRequest, runtime: $RuntimeOptions): DescribeDomainBpsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!$isNull(request.region)) {
    query['Region'] = request.region;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainBps',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the bandwidths of a website.
 *
 * @param request DescribeDomainBpsRequest
 * @return DescribeDomainBpsResponse
 */
async function describeDomainBps(request: DescribeDomainBpsRequest): DescribeDomainBpsResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainBpsWithOptions(request, runtime);
}

model DescribeDomainH2FingerprintRequest {
  domain?: string(name='Domain', description='The domain name of the website.

>  You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query the domain names of all websites that are protected by Anti-DDoS Proxy.', example='example.aliyundoc.com'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1726318200'),
  limit?: long(name='Limit', description='The maximum number of entries to return.

This parameter is required.', example='20'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1716435180'),
}

model DescribeDomainH2FingerprintResponseBody = {
  domainH2Fp?: [ 
    {
      domain?: string(name='Domain', description='The domain name of the website.', example='example.aliyundoc.com'),
      h2Fingerprint?: string(name='H2Fingerprint', description='The HTTP/2 fingerprint.', example='532501bc316d02c8b1a007db76f2c796'),
      pv?: long(name='Pv', description='The page views.', example='471755'),
    }
  ](name='DomainH2Fp', description='The information about top N HTTP/2 fingerprints.'),
  requestId?: string(name='RequestId', description='The request ID.', example='112777CC-2AD6-46FC-A263-00B931406FCD'),
}

model DescribeDomainH2FingerprintResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainH2FingerprintResponseBody(name='body'),
}

/**
 * @summary Queries the information about HTTP/2 fingerprints of a website.
 *
 * @param request DescribeDomainH2FingerprintRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainH2FingerprintResponse
 */
async function describeDomainH2FingerprintWithOptions(request: DescribeDomainH2FingerprintRequest, runtime: $RuntimeOptions): DescribeDomainH2FingerprintResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainH2Fingerprint',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about HTTP/2 fingerprints of a website.
 *
 * @param request DescribeDomainH2FingerprintRequest
 * @return DescribeDomainH2FingerprintResponse
 */
async function describeDomainH2Fingerprint(request: DescribeDomainH2FingerprintRequest): DescribeDomainH2FingerprintResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainH2FingerprintWithOptions(request, runtime);
}

model DescribeDomainOverviewRequest {
  domain?: string(name='Domain', description='The domain name of the website that you want to query. If you leave this parameter unspecified, the statistics on all domain names are queried.

> The domain name must be added to Anti-DDoS Pro or Anti-DDoS Premium. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.', example='example.aliyundoc.com'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds. If you leave this parameter unspecified, the current system time is used as the end time.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1623427200'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).', example='rg-acfm2pz25js****'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1619798400'),
}

model DescribeDomainOverviewResponseBody = {
  maxHttp?: long(name='MaxHttp', description='The peak queries per second (QPS) during HTTP traffic scrubbing. Unit: QPS.', example='41652'),
  maxHttps?: long(name='MaxHttps', description='The peak QPS during HTTPS traffic scrubbing. Unit: QPS.', example='0'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DescribeDomainOverviewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainOverviewResponseBody(name='body'),
}

/**
 * @summary Queries the attack overview of a website, such as the peak HTTP and HTTPS traffic.
 *
 * @param request DescribeDomainOverviewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainOverviewResponse
 */
async function describeDomainOverviewWithOptions(request: DescribeDomainOverviewRequest, runtime: $RuntimeOptions): DescribeDomainOverviewResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainOverview',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the attack overview of a website, such as the peak HTTP and HTTPS traffic.
 *
 * @param request DescribeDomainOverviewRequest
 * @return DescribeDomainOverviewResponse
 */
async function describeDomainOverview(request: DescribeDomainOverviewRequest): DescribeDomainOverviewResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainOverviewWithOptions(request, runtime);
}

model DescribeDomainQPSListRequest {
  domain?: string(name='Domain', description='The domain name of the website. If you do not specify this parameter, the statistics on the QPS of all domain names are queried.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='www.aliyun.com'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1583683200'),
  interval?: long(name='Interval', description='The interval for returning data. Unit: seconds.

This parameter is required.', example='1000'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribeDomainQPSListResponseBody = {
  domainQPSList?: [ 
    {
      attackQps?: long(name='AttackQps', description='The attack QPS.', example='1'),
      cacheHits?: long(name='CacheHits', description='The number of cache hits.', example='0'),
      index?: long(name='Index', description='The index number of the returned data.', example='0'),
      maxAttackQps?: long(name='MaxAttackQps', description='The peak attack QPS.', example='37'),
      maxNormalQps?: long(name='MaxNormalQps', description='The peak of normal QPS.', example='93'),
      maxQps?: long(name='MaxQps', description='The peak of total QPS.', example='130'),
      time?: long(name='Time', description='The time when the data was collected. The value is a UNIX timestamp. Unit: seconds.', example='1582992000'),
      totalCount?: long(name='TotalCount', description='The total number of requests.', example='20008'),
      totalQps?: long(name='TotalQps', description='The total QPS.', example='1'),
    }
  ](name='DomainQPSList', description='An array that consists of the statistics on the QPS of the website.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='327F2ABB-104D-437A-AAB5-D633E29A8C51'),
}

model DescribeDomainQPSListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainQPSListResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on the queries per second (QPS) of a website.
 *
 * @param request DescribeDomainQPSListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainQPSListResponse
 */
async function describeDomainQPSListWithOptions(request: DescribeDomainQPSListRequest, runtime: $RuntimeOptions): DescribeDomainQPSListResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainQPSList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics on the queries per second (QPS) of a website.
 *
 * @param request DescribeDomainQPSListRequest
 * @return DescribeDomainQPSListResponse
 */
async function describeDomainQPSList(request: DescribeDomainQPSListRequest): DescribeDomainQPSListResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainQPSListWithOptions(request, runtime);
}

model DescribeDomainResourceRequest {
  domain?: string(name='Domain', description='The domain name of the website that you want to query.', example='www.example.com'),
  instanceIds?: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances to query.'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  queryDomainPattern?: string(name='QueryDomainPattern', description='The match mode. Valid values:

*   **fuzzy**: fuzzy match. This is the default value.
*   **exact**: exact match.', example='fuzzy'),
}

model DescribeDomainResourceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='39499F01-19D9-4EA4-A0E9-C6014BA5CDBE'),
  totalCount?: long(name='TotalCount', description='The total number of forwarding rules.', example='1'),
  webRules?: [ 
    {
      blackList?: [ string ](name='BlackList', description='The IP addresses that are included in the blacklist of the domain name.'),
      ccEnabled?: boolean(name='CcEnabled', description='Indicates whether Frequency Control is enabled. Valid values:

*   **true**
*   **false**', example='true'),
      ccRuleEnabled?: boolean(name='CcRuleEnabled', description='Indicates whether the Custom Rules switch of Frequency Control is turned on. Valid values:

*   **true**
*   **false**', example='true'),
      ccTemplate?: string(name='CcTemplate', description='The mode of Frequency Control. Valid values:

*   **default**: the Normal mode
*   **gf_under_attack**: the Emergency mode
*   **gf_sos_verify**: the Strict mode
*   **gf_sos_verify**: the Super Strict mode', example='default'),
      certName?: string(name='CertName', description='The name of the SSL certificate used by the domain name.', example='49944XX.pem'),
      cname?: string(name='Cname', description='The CNAME provided by the instance to which the domain name is added.', example='0ekb69x3j9wvXXXX.aliyunddosXXXX.com'),
      customCiphers?: [ string ](name='CustomCiphers', description='The custom cipher suites.'),
      domain?: string(name='Domain', description='The domain name of the website.', example='www.example.com'),
      http2Enable?: boolean(name='Http2Enable', description='Indicates whether Enable HTTP/2 is turned on. Valid values:

*   **true**
*   **false**', example='false'),
      http2HttpsEnable?: boolean(name='Http2HttpsEnable', description='Indicates whether Enable HTTPS Redirection is turned on. Valid values:

*   **true**
*   **false**', example='false'),
      https2HttpEnable?: boolean(name='Https2HttpEnable', description='Indicates whether Enable HTTP Redirection of Back-to-origin Requests is turned on. Valid values:

*   **true**
*   **false**', example='false'),
      httpsExt?: string(name='HttpsExt', description='The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:

*   **Http2https**: indicates whether Enable HTTPS Redirection is turned on. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTPS Redirection is turned on. The value 1 indicates that Enable HTTPS Redirection is turned off.
*   **Https2http**: indicates whether Enable HTTP Redirection of Back-to-origin Requests is turned on. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that the feature is turned on. The value 1 indicates that the feature is turned off.
*   **Http2**: indicates whether Enable HTTP/2 is turned on. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on.', example='{"Https2http":0,"Http2":0,"Http2https":0}'),
      instanceIds?: [ string ](name='InstanceIds', description='The IDs of the instances to which the domain name is added.'),
      ocspEnabled?: boolean(name='OcspEnabled', description='Indicates whether the Online Certificate Status Protocol (OCSP) feature is turned on. Valid values:

*   **true**
*   **false**', example='false'),
      policyMode?: string(name='PolicyMode', description='The scheduling algorithm for back-to-origin traffic. Valid values:

*   **ip_hash**: the IP hash algorithm. This algorithm is used to redirect the requests from the same IP address to the same origin server.
*   **rr**: the round-robin algorithm. This algorithm is used to redirect requests to origin servers in turn.
*   **least_time**: the least response time algorithm. This algorithm is used to minimize the latency when requests are forwarded from the instance to origin servers based on the intelligent DNS resolution feature.', example='ip_hash'),
      proxyEnabled?: boolean(name='ProxyEnabled', description='Indicates whether the instance forwards the traffic that is destined for the website. Valid values:

*   **true**
*   **false**', example='true'),
      proxyTypes?: [ 
        {
          proxyPorts?: [ string ](name='ProxyPorts', description='The port numbers.'),
          proxyType?: string(name='ProxyType', description='The type of the protocol. Valid values:

*   **http**
*   **https**
*   **websocket**
*   **websockets**', example='http'),
        }
      ](name='ProxyTypes', description='The details about the protocol type and port number.'),
      punishReason?: int32(name='PunishReason', description='The reason why the domain name is invalid. Valid values:

*   **1**: No Content Provider (ICP) filing is completed for the domain name.
*   **2**: The business for which you registered the domain name does not meet regulatory requirements.

If the two reasons are both involved, the value **2** is returned.', example='1'),
      punishStatus?: boolean(name='PunishStatus', description='Indicates whether the domain name is invalid. Valid values:

*   **true**: The domain name is invalid. You can view the specific reasons from the **PunishReason** parameter.
*   **false**: The domain name is valid.', example='false'),
      realServers?: [ string ](name='RealServers', description='The addresses of origin servers.'),
      rsType?: int32(name='RsType', description='The address type of the origin server. Valid values:

*   **0**: IP address
*   **1**: domain name', example='0'),
      ssl13Enabled?: boolean(name='Ssl13Enabled', description='Indicates whether TLS 1.3 is supported. Valid values:

*   **true**
*   **false**', example='false'),
      sslCiphers?: string(name='SslCiphers', description='The type of the cipher suite. Valid values:

*   **default**: custom cipher suite
*   **all**: all cipher suites
*   **strong**: strong cipher suites', example='default'),
      sslProtocols?: string(name='SslProtocols', description='The version of the TLS protocol. Valid values:

*   **tls1.0**: TLS 1.0 or later
*   **tls1.1**: TLS 1.1 or later
*   **tls1.2**: TLS 1.2 or later', example='tls1.0'),
      whiteList?: [ string ](name='WhiteList', description='The IP addresses that are included in the whitelist of the domain name.'),
    }
  ](name='WebRules', description='The configurations of the forwarding rule.'),
}

model DescribeDomainResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainResourceResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of a forwarding rule.
 *
 * @description You can call the DescribeDomainResource operation to query the configurations of the forwarding rules that you create for a website by page. The configurations include the domain name-related configurations, protocol-related configurations, HTTPS-related configurations, and configurations that are used to mitigate HTTP flood attacks.
 * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
 * ### Limits
 * You can call this operation up to 50 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeDomainResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainResourceResponse
 */
async function describeDomainResourceWithOptions(request: DescribeDomainResourceRequest, runtime: $RuntimeOptions): DescribeDomainResourceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.queryDomainPattern)) {
    query['QueryDomainPattern'] = request.queryDomainPattern;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainResource',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of a forwarding rule.
 *
 * @description You can call the DescribeDomainResource operation to query the configurations of the forwarding rules that you create for a website by page. The configurations include the domain name-related configurations, protocol-related configurations, HTTPS-related configurations, and configurations that are used to mitigate HTTP flood attacks.
 * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
 * ### Limits
 * You can call this operation up to 50 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeDomainResourceRequest
 * @return DescribeDomainResourceResponse
 */
async function describeDomainResource(request: DescribeDomainResourceRequest): DescribeDomainResourceResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainResourceWithOptions(request, runtime);
}

model DescribeDomainSecurityProfileRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='example.aliyundoc.com'),
}

model DescribeDomainSecurityProfileResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.'),
  result?: [ 
    {
      globalEnable?: boolean(name='GlobalEnable', description='Indicates whether the global mitigation policy is enabled. Valid values:

*   **true**
*   **false**', example='true'),
      globalMode?: string(name='GlobalMode', description='The mode of the global mitigation policy. Valid values:

*   **weak**: the Low mode
*   **default**: the Normal mode
*   **hard**: the Strict mode', example='default'),
    }
  ](name='Result', description='The returned results.'),
}

model DescribeDomainSecurityProfileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainSecurityProfileResponseBody(name='body'),
}

/**
 * @summary Queries the global mitigation policy for a domain name.
 *
 * @param request DescribeDomainSecurityProfileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainSecurityProfileResponse
 */
async function describeDomainSecurityProfileWithOptions(request: DescribeDomainSecurityProfileRequest, runtime: $RuntimeOptions): DescribeDomainSecurityProfileResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainSecurityProfile',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the global mitigation policy for a domain name.
 *
 * @param request DescribeDomainSecurityProfileRequest
 * @return DescribeDomainSecurityProfileResponse
 */
async function describeDomainSecurityProfile(request: DescribeDomainSecurityProfileRequest): DescribeDomainSecurityProfileResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainSecurityProfileWithOptions(request, runtime);
}

model DescribeDomainStatusCodeCountRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='www.aliyun.com'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1583683200'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribeDomainStatusCodeCountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  status200?: long(name='Status200', description='The number of 200 status codes within the specified period of time.', example='951159'),
  status2XX?: long(name='Status2XX', description='The number of 2xx status codes within the specified period of time.', example='951472'),
  status3XX?: long(name='Status3XX', description='The number of 3xx status codes within the specified period of time.', example='133209'),
  status403?: long(name='Status403', description='The number of 403 status codes within the specified period of time.', example='0'),
  status404?: long(name='Status404', description='The number of 404 status codes within the specified period of time.', example='897'),
  status405?: long(name='Status405', description='The number of 405 status codes within the specified period of time.', example='0'),
  status410?: long(name='Status410'),
  status499?: long(name='Status499'),
  status4XX?: long(name='Status4XX', description='The number of 4xx status codes within the specified period of time.', example='5653'),
  status501?: long(name='Status501', description='The number of 501 status codes within the specified period of time.', example='0'),
  status502?: long(name='Status502', description='The number of 502 status codes within the specified period of time.', example='0'),
  status503?: long(name='Status503', description='The number of 503 status codes within the specified period of time.', example='0'),
  status504?: long(name='Status504', description='The number of 504 status codes within the specified period of time.', example='0'),
  status5XX?: long(name='Status5XX', description='The number of 5xx status codes within the specified period of time.', example='14'),
}

model DescribeDomainStatusCodeCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainStatusCodeCountResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on HTTP status codes of a website within a specified period of time.
 *
 * @param request DescribeDomainStatusCodeCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainStatusCodeCountResponse
 */
async function describeDomainStatusCodeCountWithOptions(request: DescribeDomainStatusCodeCountRequest, runtime: $RuntimeOptions): DescribeDomainStatusCodeCountResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainStatusCodeCount',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics on HTTP status codes of a website within a specified period of time.
 *
 * @param request DescribeDomainStatusCodeCountRequest
 * @return DescribeDomainStatusCodeCountResponse
 */
async function describeDomainStatusCodeCount(request: DescribeDomainStatusCodeCountRequest): DescribeDomainStatusCodeCountResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainStatusCodeCountWithOptions(request, runtime);
}

model DescribeDomainStatusCodeListRequest {
  domain?: string(name='Domain', description='The domain name of the website. If you do not specify this parameter, the statistics on response status codes of all domain names are queried.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='www.aliyun.com'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200'),
  interval?: long(name='Interval', description='The interval for returning data. Unit: seconds.

This parameter is required.', example='1000'),
  queryType?: string(name='QueryType', description='The source of the statistics. Valid values:

*   **gf**: Anti-DDoS Pro or Anti-DDoS Premium
*   **upstrem**: origin server

This parameter is required.', example='gf'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The start time of the event. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribeDomainStatusCodeListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='3B63C0DD-8AC5-44B2-95D6-064CA9296B9C'),
  statusCodeList?: [ 
    {
      index?: int32(name='Index', description='The index number of the returned data.', example='0'),
      status200?: long(name='Status200', description='The number of 200 status codes.', example='15520'),
      status2XX?: long(name='Status2XX', description='The number of 2xx status codes.', example='15520'),
      status3XX?: long(name='Status3XX', description='The number of 3xx status codes.', example='0'),
      status403?: long(name='Status403', description='The number of 403 status codes.', example='0'),
      status404?: long(name='Status404', description='The number of 404 status codes.', example='0'),
      status405?: long(name='Status405', description='The number of 405 status codes.', example='0'),
      status410?: long(name='Status410'),
      status499?: long(name='Status499'),
      status4XX?: long(name='Status4XX', description='The number of 4xx status codes.', example='4486'),
      status501?: long(name='Status501', description='The number of 501 status codes.', example='0'),
      status502?: long(name='Status502', description='The number of 502 status codes.', example='0'),
      status503?: long(name='Status503', description='The number of 503 status codes.', example='0'),
      status504?: long(name='Status504', description='The number of 504 status codes.', example='0'),
      status5XX?: long(name='Status5XX', description='The number of 5xx status codes.', example='0'),
      time?: long(name='Time', description='The time when the data was collected. The value is a UNIX timestamp. Unit: seconds.', example='1582992000'),
    }
  ](name='StatusCodeList', description='The statistics on response status codes.'),
}

model DescribeDomainStatusCodeListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainStatusCodeListResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on HTTP status codes of a website.
 *
 * @param request DescribeDomainStatusCodeListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainStatusCodeListResponse
 */
async function describeDomainStatusCodeListWithOptions(request: DescribeDomainStatusCodeListRequest, runtime: $RuntimeOptions): DescribeDomainStatusCodeListResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!$isNull(request.queryType)) {
    query['QueryType'] = request.queryType;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainStatusCodeList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics on HTTP status codes of a website.
 *
 * @param request DescribeDomainStatusCodeListRequest
 * @return DescribeDomainStatusCodeListResponse
 */
async function describeDomainStatusCodeList(request: DescribeDomainStatusCodeListRequest): DescribeDomainStatusCodeListResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainStatusCodeListWithOptions(request, runtime);
}

model DescribeDomainTopAttackListRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1583683200'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribeDomainTopAttackListResponseBody = {
  attackList?: [ 
    {
      attack?: long(name='Attack', description='The attack QPS. Unit: QPS', example='0'),
      count?: long(name='Count', description='The number of all QPS, which includes normal and attack QPS. Unit: QPS.', example='294'),
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
    }
  ](name='AttackList', description='The peak QPS of the website.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DescribeDomainTopAttackListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainTopAttackListResponseBody(name='body'),
}

/**
 * @summary Queries the peak queries per second (QPS) information about a website, such as the attack QPS and total QPS, within a specific period of time.
 *
 * @param request DescribeDomainTopAttackListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainTopAttackListResponse
 */
async function describeDomainTopAttackListWithOptions(request: DescribeDomainTopAttackListRequest, runtime: $RuntimeOptions): DescribeDomainTopAttackListResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainTopAttackList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the peak queries per second (QPS) information about a website, such as the attack QPS and total QPS, within a specific period of time.
 *
 * @param request DescribeDomainTopAttackListRequest
 * @return DescribeDomainTopAttackListResponse
 */
async function describeDomainTopAttackList(request: DescribeDomainTopAttackListRequest): DescribeDomainTopAttackListResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainTopAttackListWithOptions(request, runtime);
}

model DescribeDomainTopFingerprintRequest {
  domain?: string(name='Domain', description='The domain name of the website.

>  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='example.aliyundoc.com'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1723552200'),
  interval?: long(name='Interval', description='The interval for returning data. Unit: seconds.

This parameter is required.', example='60'),
  limit?: long(name='Limit', description='The maximum number of entries to return.

This parameter is required.', example='10'),
  region?: string(name='Region', description='The region in which your service is deployed. Valid values:

*   **cn**: a region in the Chinese mainland.
*   **cn-hongkong**: a region outside the Chinese mainland.

This parameter is required.', example='cn'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1719211800'),
}

model DescribeDomainTopFingerprintResponseBody = {
  domainTopFp?: [ 
    {
      domain?: string(name='Domain', description='The domain name of the website.', example='example.aliyundoc.com'),
      fingerprinting?: string(name='Fingerprinting', description='The fingerprint of the client.', example='8a374c9724582b14a4cfa58c8c9fb2bc'),
      pv?: long(name='Pv', description='The page views.', example='22121'),
    }
  ](name='DomainTopFp', description='The information about the fingerprints of the clients.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DescribeDomainTopFingerprintResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainTopFingerprintResponseBody(name='body'),
}

/**
 * @summary Queries the information about the fingerprints of top N clients that access a website.
 *
 * @param request DescribeDomainTopFingerprintRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainTopFingerprintResponse
 */
async function describeDomainTopFingerprintWithOptions(request: DescribeDomainTopFingerprintRequest, runtime: $RuntimeOptions): DescribeDomainTopFingerprintResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!$isNull(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!$isNull(request.region)) {
    query['Region'] = request.region;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainTopFingerprint',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the fingerprints of top N clients that access a website.
 *
 * @param request DescribeDomainTopFingerprintRequest
 * @return DescribeDomainTopFingerprintResponse
 */
async function describeDomainTopFingerprint(request: DescribeDomainTopFingerprintRequest): DescribeDomainTopFingerprintResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainTopFingerprintWithOptions(request, runtime);
}

model DescribeDomainTopHttpMethodRequest {
  domain?: string(name='Domain', description='The domain name of the website.

>  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='example.aliyundoc.com'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1722339300'),
  limit?: long(name='Limit', description='The maximum number of entries to return.

This parameter is required.', example='20'),
  region?: string(name='Region', description='The region in which your service is deployed. Valid values:

*   **cn**: a region in the Chinese mainland.
*   **cn-hongkong**: a region outside the Chinese mainland.

This parameter is required.', example='cn'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1712449710'),
}

model DescribeDomainTopHttpMethodResponseBody = {
  domainTopMethod?: [ 
    {
      domain?: string(name='Domain', description='The domain name of the website.', example='example.aliyundoc.com'),
      httpMethod?: string(name='HttpMethod', description='The HTTP method.', example='GET'),
      pv?: long(name='Pv', description='The page views.', example='22121'),
    }
  ](name='DomainTopMethod', description='The information about top HTTP methods.'),
  requestId?: string(name='RequestId', description='The request ID.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model DescribeDomainTopHttpMethodResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainTopHttpMethodResponseBody(name='body'),
}

/**
 * @summary Queries the information about top N HTTP methods of a website.
 *
 * @param request DescribeDomainTopHttpMethodRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainTopHttpMethodResponse
 */
async function describeDomainTopHttpMethodWithOptions(request: DescribeDomainTopHttpMethodRequest, runtime: $RuntimeOptions): DescribeDomainTopHttpMethodResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!$isNull(request.region)) {
    query['Region'] = request.region;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainTopHttpMethod',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about top N HTTP methods of a website.
 *
 * @param request DescribeDomainTopHttpMethodRequest
 * @return DescribeDomainTopHttpMethodResponse
 */
async function describeDomainTopHttpMethod(request: DescribeDomainTopHttpMethodRequest): DescribeDomainTopHttpMethodResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainTopHttpMethodWithOptions(request, runtime);
}

model DescribeDomainTopRefererRequest {
  domain?: string(name='Domain', description='The domain name of the website.

>  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='example.aliyundoc.com'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1721561100'),
  limit?: long(name='Limit', description='The maximum number of entries to return.

This parameter is required.', example='10'),
  region?: string(name='Region', description='The region in which your service is deployed. Valid values:

*   **cn**: a region in the Chinese mainland.
*   **cn-hongkong**: a region outside the Chinese mainland.

This parameter is required.', example='cn'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1701991920'),
}

model DescribeDomainTopRefererResponseBody = {
  domainTopReferer?: [ 
    {
      domain?: string(name='Domain', description='The domain name of the website.', example='example.aliyundoc.com'),
      pv?: long(name='Pv', description='The page views.', example='257031'),
      referer?: string(name='Referer', description='The Base64-encoded referer.', example='aHR0cHM6Ly9zZXJ2aWNld2VjaGF0LmNvbS93eGY3ZDc5YWY0YzU4ZDH3NTEvNC9wYWdlLWZyYW1lLmh0bWw='),
    }
  ](name='DomainTopReferer', description='The information about top referers.'),
  requestId?: string(name='RequestId', description='The request ID.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model DescribeDomainTopRefererResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainTopRefererResponseBody(name='body'),
}

/**
 * @summary Queries the information about top N referers of a website.
 *
 * @param request DescribeDomainTopRefererRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainTopRefererResponse
 */
async function describeDomainTopRefererWithOptions(request: DescribeDomainTopRefererRequest, runtime: $RuntimeOptions): DescribeDomainTopRefererResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!$isNull(request.region)) {
    query['Region'] = request.region;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainTopReferer',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about top N referers of a website.
 *
 * @param request DescribeDomainTopRefererRequest
 * @return DescribeDomainTopRefererResponse
 */
async function describeDomainTopReferer(request: DescribeDomainTopRefererRequest): DescribeDomainTopRefererResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainTopRefererWithOptions(request, runtime);
}

model DescribeDomainTopUserAgentRequest {
  domain?: string(name='Domain', description='The domain name of the website.

>  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='www.example.com'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1708352700'),
  limit?: long(name='Limit', description='The maximum number of entries to return.

This parameter is required.', example='20'),
  region?: string(name='Region', description='The region in which your service is deployed. Valid values:

*   **cn**: a region in the Chinese mainland.
*   **cn-hongkong**: a region outside the Chinese mainland.

This parameter is required.', example='cn'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1609430400'),
}

model DescribeDomainTopUserAgentResponseBody = {
  domainTopUa?: [ 
    {
      domain?: string(name='Domain', description='The domain name of the website.', example='www.example.com'),
      pv?: long(name='Pv', description='The page views.', example='22121'),
      userAgent?: string(name='UserAgent', description='The Base64-encoded user agent.', example='TW96aWxsYS81LjAgKFgxMTsgTGludXggeDg2XzY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvOTYuMC40NjY0LjExMCACYWZhcmkvNTM3LjM2'),
    }
  ](name='DomainTopUa', description='The information about the user agents.'),
  requestId?: string(name='RequestId', description='The request ID.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model DescribeDomainTopUserAgentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainTopUserAgentResponseBody(name='body'),
}

/**
 * @summary Queries the information about top user agents of a website.
 *
 * @param request DescribeDomainTopUserAgentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainTopUserAgentResponse
 */
async function describeDomainTopUserAgentWithOptions(request: DescribeDomainTopUserAgentRequest, runtime: $RuntimeOptions): DescribeDomainTopUserAgentResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!$isNull(request.region)) {
    query['Region'] = request.region;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainTopUserAgent',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about top user agents of a website.
 *
 * @param request DescribeDomainTopUserAgentRequest
 * @return DescribeDomainTopUserAgentResponse
 */
async function describeDomainTopUserAgent(request: DescribeDomainTopUserAgentRequest): DescribeDomainTopUserAgentResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainTopUserAgentWithOptions(request, runtime);
}

model DescribeDomainViewSourceCountriesRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='www.aliyun.com'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1583683200'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribeDomainViewSourceCountriesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  sourceCountrys?: [ 
    {
      count?: long(name='Count', description='The total number of requests.', example='3390671'),
      countryId?: string(name='CountryId', description='The abbreviation of the country or area. For more information, see the **Codes of countries and areas** section of the [Codes of administrative regions in China and codes of countries and areas](https://help.aliyun.com/document_detail/167926.html) topic. For example, **cn** indicates China, and **us** indicates the United States.', example='cn'),
    }
  ](name='SourceCountrys', description='An array consisting of the country or area from which the requests are sent.'),
}

model DescribeDomainViewSourceCountriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainViewSourceCountriesResponseBody(name='body'),
}

/**
 * @summary Queries the areas and countries from which requests are sent to a website within a specified period of time.
 *
 * @param request DescribeDomainViewSourceCountriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainViewSourceCountriesResponse
 */
async function describeDomainViewSourceCountriesWithOptions(request: DescribeDomainViewSourceCountriesRequest, runtime: $RuntimeOptions): DescribeDomainViewSourceCountriesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainViewSourceCountries',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the areas and countries from which requests are sent to a website within a specified period of time.
 *
 * @param request DescribeDomainViewSourceCountriesRequest
 * @return DescribeDomainViewSourceCountriesResponse
 */
async function describeDomainViewSourceCountries(request: DescribeDomainViewSourceCountriesRequest): DescribeDomainViewSourceCountriesResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainViewSourceCountriesWithOptions(request, runtime);
}

model DescribeDomainViewSourceProvincesRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='www.aliyun.com'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1583683200'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribeDomainViewSourceProvincesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  sourceProvinces?: [ 
    {
      count?: long(name='Count', description='The total number of requests.', example='3390671'),
      provinceId?: string(name='ProvinceId', description='The ID of the region inside China. For more information, see the **Codes of administrative regions in China** section of the [Codes of administrative regions in China and codes of countries and areas](https://help.aliyun.com/document_detail/167926.html) topic. For example, **110000** indicates Beijing, and **120000** indicates Tianjin.', example='440000'),
    }
  ](name='SourceProvinces', description='An array consisting of the details of the administrative region in China from which the requests are sent.'),
}

model DescribeDomainViewSourceProvincesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainViewSourceProvincesResponseBody(name='body'),
}

/**
 * @summary Queries the administrative regions in China from which requests are sent to a website within a specified period of time.
 *
 * @param request DescribeDomainViewSourceProvincesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainViewSourceProvincesResponse
 */
async function describeDomainViewSourceProvincesWithOptions(request: DescribeDomainViewSourceProvincesRequest, runtime: $RuntimeOptions): DescribeDomainViewSourceProvincesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainViewSourceProvinces',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the administrative regions in China from which requests are sent to a website within a specified period of time.
 *
 * @param request DescribeDomainViewSourceProvincesRequest
 * @return DescribeDomainViewSourceProvincesResponse
 */
async function describeDomainViewSourceProvinces(request: DescribeDomainViewSourceProvincesRequest): DescribeDomainViewSourceProvincesResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainViewSourceProvincesWithOptions(request, runtime);
}

model DescribeDomainViewTopCostTimeRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='www.aliyun.com'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1583683200'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
  top?: int32(name='Top', description='The number of URLs to query. Valid values: **1** to **100**.

This parameter is required.', example='5'),
}

model DescribeDomainViewTopCostTimeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  urlList?: [ 
    {
      costTime?: float(name='CostTime', description='The response duration. Unit: milliseconds.', example='3000'),
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
      url?: string(name='Url', description='The URL that is Base64-encoded.', example='Lw=='),
    }
  ](name='UrlList', description='The URLs which require the longest time to respond to requests.'),
}

model DescribeDomainViewTopCostTimeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainViewTopCostTimeResponseBody(name='body'),
}

/**
 * @summary Queries the top N URLs that require the longest time to respond to requests within a specified period of time.
 *
 * @param request DescribeDomainViewTopCostTimeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainViewTopCostTimeResponse
 */
async function describeDomainViewTopCostTimeWithOptions(request: DescribeDomainViewTopCostTimeRequest, runtime: $RuntimeOptions): DescribeDomainViewTopCostTimeResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!$isNull(request.top)) {
    query['Top'] = request.top;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainViewTopCostTime',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the top N URLs that require the longest time to respond to requests within a specified period of time.
 *
 * @param request DescribeDomainViewTopCostTimeRequest
 * @return DescribeDomainViewTopCostTimeResponse
 */
async function describeDomainViewTopCostTime(request: DescribeDomainViewTopCostTimeRequest): DescribeDomainViewTopCostTimeResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainViewTopCostTimeWithOptions(request, runtime);
}

model DescribeDomainViewTopUrlRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='www.aliyun.com'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1583683200'),
  inerval?: long(name='Inerval'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
  top?: int32(name='Top', description='The number of URLs to query. Valid values: **1** to **100**.

This parameter is required.', example='5'),
}

model DescribeDomainViewTopUrlResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  urlList?: [ 
    {
      count?: long(name='Count', description='The total number of requests.', example='3390671'),
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
      url?: string(name='Url', description='The URL that is Base64-encoded.', example='Lw=='),
    }
  ](name='UrlList', description='An array consisting of the URLs that receive the most requests.'),
}

model DescribeDomainViewTopUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainViewTopUrlResponseBody(name='body'),
}

/**
 * @summary Queries the top N URLs that receive the most requests within a specified period of time.
 *
 * @param request DescribeDomainViewTopUrlRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainViewTopUrlResponse
 */
async function describeDomainViewTopUrlWithOptions(request: DescribeDomainViewTopUrlRequest, runtime: $RuntimeOptions): DescribeDomainViewTopUrlResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.inerval)) {
    query['Inerval'] = request.inerval;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!$isNull(request.top)) {
    query['Top'] = request.top;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomainViewTopUrl',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the top N URLs that receive the most requests within a specified period of time.
 *
 * @param request DescribeDomainViewTopUrlRequest
 * @return DescribeDomainViewTopUrlResponse
 */
async function describeDomainViewTopUrl(request: DescribeDomainViewTopUrlRequest): DescribeDomainViewTopUrlResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainViewTopUrlWithOptions(request, runtime);
}

model DescribeDomainsRequest {
  instanceIds?: [ string ](name='InstanceIds', description='The ID of the instance that you want to query.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.', example='ddoscoo-cn-mp91j1ao****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).', example='rg-acfm2pz25js****'),
}

model DescribeDomainsResponseBody = {
  domains?: [ string ](name='Domains', description='An array consisting of details of the domain name for which the forwarding rules are configured.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F908E959-ADA8-4D7B-8A05-FF2F67F50964'),
}

model DescribeDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainsResponseBody(name='body'),
}

/**
 * @summary Queries domain names for which forwarding rules are created.
 *
 * @param request DescribeDomainsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainsResponse
 */
async function describeDomainsWithOptions(request: DescribeDomainsRequest, runtime: $RuntimeOptions): DescribeDomainsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDomains',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries domain names for which forwarding rules are created.
 *
 * @param request DescribeDomainsRequest
 * @return DescribeDomainsResponse
 */
async function describeDomains(request: DescribeDomainsRequest): DescribeDomainsResponse {
  var runtime = new $RuntimeOptions{};
  return describeDomainsWithOptions(request, runtime);
}

model DescribeElasticBandwidthSpecRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
}

model DescribeElasticBandwidthSpecResponseBody = {
  elasticBandwidthSpec?: [ string ](name='ElasticBandwidthSpec', description='An array that consists of the available burstable protection bandwidths. Unit: Gbit/s.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DescribeElasticBandwidthSpecResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeElasticBandwidthSpecResponseBody(name='body'),
}

/**
 * @summary Queries the available burstable protection bandwidths of an Anti-DDoS Proxy (Chinese Mainland) instance.
 *
 * @description >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
 *
 * @param request DescribeElasticBandwidthSpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeElasticBandwidthSpecResponse
 */
async function describeElasticBandwidthSpecWithOptions(request: DescribeElasticBandwidthSpecRequest, runtime: $RuntimeOptions): DescribeElasticBandwidthSpecResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeElasticBandwidthSpec',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the available burstable protection bandwidths of an Anti-DDoS Proxy (Chinese Mainland) instance.
 *
 * @description >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
 *
 * @param request DescribeElasticBandwidthSpecRequest
 * @return DescribeElasticBandwidthSpecResponse
 */
async function describeElasticBandwidthSpec(request: DescribeElasticBandwidthSpecRequest): DescribeElasticBandwidthSpecResponse {
  var runtime = new $RuntimeOptions{};
  return describeElasticBandwidthSpecWithOptions(request, runtime);
}

model DescribeElasticQpsRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1684339200'),
  interval?: string(name='Interval', description='The sampling interval. Unit: seconds. The value must be a multiple of 60. Default value: 60. Unit: seconds. The query result varies depending on the sampling interval.', example='60'),
  ip?: string(name='Ip', description='The IP address of the Anti-DDoS Proxy instance to query.', example='203.107.XX.XX'),
  region?: string(name='Region', description='The type of the service. Valid values:

*   **cn**: Anti-DDoS Proxy (Chinese Mainland)
*   **cn-hongkong**: Anti-DDoS Proxy (Outside Chinese Mainland)

This parameter is required.', example='cn'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1684252800'),
}

model DescribeElasticQpsResponseBody = {
  elasticQps?: [ 
    {
      index?: long(name='Index', description='The index number of the returned data.', example='1'),
      maxNormalQps?: long(name='MaxNormalQps', description='The peak QPS of the normal service.', example='23'),
      maxQps?: long(name='MaxQps', description='The peak inbound QPS.', example='100'),
      pv?: long(name='Pv', description='The total number of requests during the step size period.', example='15104'),
      status2?: long(name='Status2', description='The total number of HTTP 2xx status codes during the step size period.', example='455'),
      status3?: long(name='Status3', description='The total number of HTTP 3xx status codes during the step size period.', example='100'),
      status4?: long(name='Status4', description='The total number of HTTP 4xx status codes during the step size period.', example='34'),
      status5?: long(name='Status5', description='The total number of HTTP 5xx status codes during the step size period.', example='0'),
      ups?: long(name='Ups', description='The total number of origin requests during the step size period.', example='1223'),
    }
  ](name='ElasticQps', description='The information about the burstable QPS.'),
  requestId?: string(name='RequestId', description='The request ID, which is used to locate and troubleshoot issues.', example='2E7F7F7B-39A8-5D92-BAB4-D89D9DCE7D4F'),
}

model DescribeElasticQpsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeElasticQpsResponseBody(name='body'),
}

/**
 * @summary Queries the line chart of the bills for the burstable QPS of an Anti-DDoS Proxy instance.
 *
 * @param request DescribeElasticQpsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeElasticQpsResponse
 */
async function describeElasticQpsWithOptions(request: DescribeElasticQpsRequest, runtime: $RuntimeOptions): DescribeElasticQpsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!$isNull(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!$isNull(request.region)) {
    query['Region'] = request.region;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeElasticQps',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the line chart of the bills for the burstable QPS of an Anti-DDoS Proxy instance.
 *
 * @param request DescribeElasticQpsRequest
 * @return DescribeElasticQpsResponse
 */
async function describeElasticQps(request: DescribeElasticQpsRequest): DescribeElasticQpsResponse {
  var runtime = new $RuntimeOptions{};
  return describeElasticQpsWithOptions(request, runtime);
}

model DescribeElasticQpsRecordRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a timestamp. Unit: milliseconds.

This parameter is required.', example='1688140799999'),
  ip?: string(name='Ip', description='The IP address of the Anti-DDoS Proxy instance to query.

This parameter is required.', example='203.107.XX.XX'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a timestamp. Unit: milliseconds.

This parameter is required.', example='1684252800000'),
}

model DescribeElasticQpsRecordResponseBody = {
  elasticQpsList?: [ 
    {
      date?: long(name='Date', description='The timestamp. Unit: milliseconds.', example='1688140799999'),
      instanceId?: string(name='InstanceId', description='The ID of the Anti-DDoS Proxy instance.', example='ddoscoo-cn-7e225i41****'),
      ip?: string(name='Ip', description='The IP address of the Anti-DDoS Proxy instance.', example='203.***.***.199'),
      opsElasticQps?: long(name='OpsElasticQps', description='The burstable QPS value. A value of 0 indicates that the burstable QPS feature is not enabled.', example='300000'),
      opsQps?: long(name='OpsQps', description='The service QPS (active).', example='1345'),
      originQps?: long(name='OriginQps', description='The service QPS (purchased).', example='1345'),
      qps?: long(name='Qps', description='The daily peak 95th percentile QPS.', example='4367'),
      qpsPeak?: long(name='QpsPeak', description='The daily peak traffic.', example='122'),
      status?: long(name='Status', description='Indicates whether the instance has expired or is released. Valid values:

*   **1**: The instance runs as expected.
*   **2**: The instance has expired.
*   **4**: The instance is released.', example='1'),
    }
  ](name='ElasticQpsList', description='The QPS information about the instance.'),
  requestId?: string(name='RequestId', description='The request ID, which is used to locate and troubleshoot issues.', example='F68B34E2-570C-508D-95FD-DFB6611D518F'),
}

model DescribeElasticQpsRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeElasticQpsRecordResponseBody(name='body'),
}

/**
 * @summary Queries the burstable QPS details of an Anti-DDoS Proxy instance.
 *
 * @param request DescribeElasticQpsRecordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeElasticQpsRecordResponse
 */
async function describeElasticQpsRecordWithOptions(request: DescribeElasticQpsRecordRequest, runtime: $RuntimeOptions): DescribeElasticQpsRecordResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeElasticQpsRecord',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the burstable QPS details of an Anti-DDoS Proxy instance.
 *
 * @param request DescribeElasticQpsRecordRequest
 * @return DescribeElasticQpsRecordResponse
 */
async function describeElasticQpsRecord(request: DescribeElasticQpsRecordRequest): DescribeElasticQpsRecordResponse {
  var runtime = new $RuntimeOptions{};
  return describeElasticQpsRecordWithOptions(request, runtime);
}

model DescribeHeadersRequest {
  domain?: string(name='Domain', description='The domain name that you want to query.

> You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.

This parameter is required.', example='example.aliyundoc.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='rg-aek3cmuvpia****'),
}

model DescribeHeadersResponseBody = {
  customHeader?: {
    domain?: string(name='Domain', description='The domain name of the website.', example='example.aliyundoc.com'),
    headers?: string(name='Headers', description='The header of the response.', example='{"X-Forwarded-ClientSrcPort":"","header1":"hLeLele"}'),
  }(name='CustomHeader', description='The information about the custom header.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='48BC7BA5-69BE-5C31-A080-AFF2431AE48D'),
}

model DescribeHeadersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHeadersResponseBody(name='body'),
}

/**
 * @summary Queries the custom header that is specified for a domain name.
 *
 * @param request DescribeHeadersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHeadersResponse
 */
async function describeHeadersWithOptions(request: DescribeHeadersRequest, runtime: $RuntimeOptions): DescribeHeadersResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeHeaders',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the custom header that is specified for a domain name.
 *
 * @param request DescribeHeadersRequest
 * @return DescribeHeadersResponse
 */
async function describeHeaders(request: DescribeHeadersRequest): DescribeHeadersResponse {
  var runtime = new $RuntimeOptions{};
  return describeHeadersWithOptions(request, runtime);
}

model DescribeHealthCheckListRequest {
  networkRules?: string(name='NetworkRules', description='The information about the port forwarding rule. This parameter is a JSON string. The string contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.

This parameter is required.', example='[{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080}]'),
}

model DescribeHealthCheckListResponseBody = {
  healthCheckList?: [ 
    {
      frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='8080'),
      healthCheck?: {
        domain?: string(name='Domain', description='The domain name.

>  This parameter is returned only when the Layer 7 health check configuration is queried.', example='www.aliyun.com'),
        down?: int32(name='Down', description='The number of consecutive failed health checks that must occur before a port is declared unhealthy. Valid values: **1** to **10**.', example='3'),
        interval?: int32(name='Interval', description='The interval at which checks are performed. Valid values: **1** to **30**. Unit: seconds.', example='15'),
        port?: int32(name='Port', description='The port that was checked.', example='8080'),
        timeout?: int32(name='Timeout', description='The response timeout period. Valid values: **1** to **30**. Unit: seconds.', example='5'),
        type?: string(name='Type', description='The type of the protocol. Valid values:

*   **tcp**: The Layer 4 health check configuration was queried.
*   **http**: The Layer 7 health check configuration was queried.', example='tcp'),
        up?: int32(name='Up', description='The number of consecutive successful health checks that must occur before a port is declared healthy. Valid values: **1** to **10**.', example='3'),
        uri?: string(name='Uri', description='The check path.

>  This parameter is returned only when the Layer 7 health check configuration is queried.', example='/abc'),
      }(name='HealthCheck', description='The health check configuration.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-mp91j1ao****'),
      protocol?: string(name='Protocol', description='The forwarding protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp'),
    }
  ](name='HealthCheckList', description='An array that consists of information about the health check configuration.'),
  requestId?: string(name='RequestId', description='The request ID.', example='83B4AF42-E8EE-4DC9-BD73-87B7733A36F9'),
}

model DescribeHealthCheckListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHealthCheckListResponseBody(name='body'),
}

/**
 * @summary Queries the Layer 4 or Layer 7 health check configurations of a port forwarding rule.
 *
 * @param request DescribeHealthCheckListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHealthCheckListResponse
 */
async function describeHealthCheckListWithOptions(request: DescribeHealthCheckListRequest, runtime: $RuntimeOptions): DescribeHealthCheckListResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.networkRules)) {
    query['NetworkRules'] = request.networkRules;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeHealthCheckList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the Layer 4 or Layer 7 health check configurations of a port forwarding rule.
 *
 * @param request DescribeHealthCheckListRequest
 * @return DescribeHealthCheckListResponse
 */
async function describeHealthCheckList(request: DescribeHealthCheckListRequest): DescribeHealthCheckListResponse {
  var runtime = new $RuntimeOptions{};
  return describeHealthCheckListWithOptions(request, runtime);
}

model DescribeHealthCheckStatusRequest {
  networkRules?: string(name='NetworkRules', description='An array that consists of the details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.

This parameter is required.', example='[{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080}]'),
}

model DescribeHealthCheckStatusResponseBody = {
  healthCheckStatus?: [ 
    {
      frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='8080'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-mp91j1ao****'),
      protocol?: string(name='Protocol', description='The forwarding protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp'),
      realServerStatusList?: [ 
        {
          address?: string(name='Address', description='The IP address of the origin server.', example='192.0.XX.XX'),
          status?: string(name='Status', description='The health state of the IP address. Valid values:

*   **normal**: healthy
*   **abnormal**: unhealthy', example='abnormal'),
        }
      ](name='RealServerStatusList', description='An array that consists of the health states of the IP addresses of the origin server.'),
      status?: string(name='Status', description='The health status of the origin server. Valid values:

*   **normal**: healthy
*   **abnormal**: unhealthy', example='normal'),
    }
  ](name='HealthCheckStatus', description='An array that consists of the details of the health status of the origin server.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='DE9FF9E1-569C-4B6C-AB6A-0F6D927BB27C'),
}

model DescribeHealthCheckStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHealthCheckStatusResponseBody(name='body'),
}

/**
 * @summary Queries the health status of an origin server.
 *
 * @param request DescribeHealthCheckStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeHealthCheckStatusResponse
 */
async function describeHealthCheckStatusWithOptions(request: DescribeHealthCheckStatusRequest, runtime: $RuntimeOptions): DescribeHealthCheckStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.networkRules)) {
    query['NetworkRules'] = request.networkRules;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeHealthCheckStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the health status of an origin server.
 *
 * @param request DescribeHealthCheckStatusRequest
 * @return DescribeHealthCheckStatusResponse
 */
async function describeHealthCheckStatus(request: DescribeHealthCheckStatusRequest): DescribeHealthCheckStatusResponse {
  var runtime = new $RuntimeOptions{};
  return describeHealthCheckStatusWithOptions(request, runtime);
}

model DescribeInstanceDetailsRequest {
  instanceIds?: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances to query.

This parameter is required.'),
}

model DescribeInstanceDetailsResponseBody = {
  instanceDetails?: [ 
    {
      eipInfos?: [ 
        {
          certConfigured?: boolean(name='CertConfigured', description='Indicates whether a custom certificate is configured.', example='true'),
          eip?: string(name='Eip', description='The IP address of the instance.', example='203.117.XX.XX'),
          functionVersion?: string(name='FunctionVersion', description='The type of the instance.', example='default'),
          ipMode?: string(name='IpMode', description='The IP address-based forwarding mode of the instance. Valid values:

*   **fnat**: Requests from IPv4 addresses are forwarded to origin servers that use IPv4 addresses and requests from IPv6 addresses are forwarded to origin servers that use IPv6 addresses.
*   **v6tov4**: All requests are forwarded to origin servers that use IPv4 addresses.', example='fnat'),
          ipVersion?: string(name='IpVersion', description='The IP version of the protocol. Valid values:

*   **Ipv4**: IPv4
*   **Ipv6**: IPv6', example='Ipv4'),
          ssl13Enabled?: boolean(name='Ssl13Enabled', description='Indicates whether the TLS 1.3 version is supported.', example='false'),
          status?: string(name='Status', description='The status of the instance. Valid values:

*   **normal**: indicates that the instance is normal.
*   **expired**: indicates that the instance expired.
*   **defense**: indicates that traffic scrubbing is performed on the asset that is protected by the instance.
*   **blackhole**: indicates that blackhole filtering is triggered for the asset that is protected by the instance.
*   **punished**: indicates that the instance is in penalty.', example='normal'),
          tlsVersion?: string(name='TlsVersion', description='The Transport Layer Security (TLS) version that is configured.', example='tls1.2'),
        }
      ](name='EipInfos', description='The IP address information about the Anti-DDoS Proxy instance.'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-zvp2eibz****'),
      line?: string(name='Line', description='The protection line of the instance.', example='coop-line-001'),
    }
  ](name='InstanceDetails', description='The IP address and ISP line information about the Anti-DDoS Proxy instance.'),
  requestId?: string(name='RequestId', description='The request ID.', example='3C814429-21A5-4673-827E-FDD19DC75681'),
}

model DescribeInstanceDetailsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstanceDetailsResponseBody(name='body'),
}

/**
 * @summary Queries the IP addresses and Internet service provider (ISP) lines of Anti-DDoS Pro or Anti-DDoS Premium instances.
 *
 * @description You can call the DescribeInstanceDetails operation to query the information about the IP addresses and ISP lines of the instances. The information includes the IP address, status, and protection line.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeInstanceDetailsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceDetailsResponse
 */
async function describeInstanceDetailsWithOptions(request: DescribeInstanceDetailsRequest, runtime: $RuntimeOptions): DescribeInstanceDetailsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeInstanceDetails',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the IP addresses and Internet service provider (ISP) lines of Anti-DDoS Pro or Anti-DDoS Premium instances.
 *
 * @description You can call the DescribeInstanceDetails operation to query the information about the IP addresses and ISP lines of the instances. The information includes the IP address, status, and protection line.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeInstanceDetailsRequest
 * @return DescribeInstanceDetailsResponse
 */
async function describeInstanceDetails(request: DescribeInstanceDetailsRequest): DescribeInstanceDetailsResponse {
  var runtime = new $RuntimeOptions{};
  return describeInstanceDetailsWithOptions(request, runtime);
}

model DescribeInstanceExtRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

>  You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.', example='ddoscoo-cn-i7m25564****'),
  pageNumber?: string(name='PageNumber', description='The number of the page. For example, to query the returned results on the first page, set the value to **1**.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page.', example='10'),
}

model DescribeInstanceExtResponseBody = {
  instanceExtSpecs?: [ 
    {
      functionVersion?: long(name='FunctionVersion', description='The function plan. Valid values:

*   **0**: Standard
*   **1**: Enhanced', example='0'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-i7m25564****'),
      normalBandwidth?: long(name='NormalBandwidth', description='The clean bandwidth. Unit: Mbit/s.', example='100'),
      productPlan?: long(name='ProductPlan', description='The type of the instance. Valid values:

*   **0**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Insurance mitigation plan
*   **1**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Unlimited mitigation plan
*   **2**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Chinese Mainland Acceleration (CMA) mitigation plan
*   **3**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Secure Chinese Mainland Acceleration (Sec-CMA) mitigation plan
*   **9**: Anti-DDoS Proxy (Chinese Mainland) instance of the Profession mitigation plan', example='0'),
      servicePartner?: string(name='ServicePartner', description='The Internet service provider (ISP) line of the Anti-DDoS Proxy (Chinese Mainland) instance.', example='coop-line-001'),
    }
  ](name='InstanceExtSpecs', description='The extended information about the Anti-DDoS Proxy instance.'),
  requestId?: string(name='RequestId', description='The request ID.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
  totalCount?: long(name='TotalCount', description='The total number of queried instances.', example='10'),
}

model DescribeInstanceExtResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstanceExtResponseBody(name='body'),
}

/**
 * @summary Queries the information about Anti-DDoS Pro and Anti-DDoS Premium instances.
 *
 * @param request DescribeInstanceExtRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceExtResponse
 */
async function describeInstanceExtWithOptions(request: DescribeInstanceExtRequest, runtime: $RuntimeOptions): DescribeInstanceExtResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeInstanceExt',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about Anti-DDoS Pro and Anti-DDoS Premium instances.
 *
 * @param request DescribeInstanceExtRequest
 * @return DescribeInstanceExtResponse
 */
async function describeInstanceExt(request: DescribeInstanceExtRequest): DescribeInstanceExtResponse {
  var runtime = new $RuntimeOptions{};
  return describeInstanceExtWithOptions(request, runtime);
}

model DescribeInstanceIdsRequest {
  edition?: int32(name='Edition', description='The type of the instance to query. Valid values:

*   **0**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Insurance mitigation plan
*   **1**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Unlimited mitigation plan
*   **2**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Chinese Mainland Acceleration (CMA) mitigation plan
*   **3**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Secure Chinese Mainland Acceleration (Sec-CMA) mitigation plan
*   **9**: Anti-DDoS Proxy (Chinese Mainland) instance of the Profession mitigation plan', example='9'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of instances to query.', example='ddoscoo-cn-mp91j1ao****'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-acfm2pz25js****'),
}

model DescribeInstanceIdsResponseBody = {
  instanceIds?: [ 
    {
      edition?: int32(name='Edition', description='The type of the instance. Valid values:

*   **0**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Insurance mitigation plan
*   **1**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Unlimited mitigation plan
*   **2**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the CMA mitigation plan
*   **3**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Sec-CMA mitigation plan
*   **9**: Anti-DDoS Proxy (Chinese Mainland) instance of the Profession mitigation plan', example='9'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-zvp2eibz****'),
      ipMode?: string(name='IpMode', description='The IP address-based forwarding mode of the instance. Valid values:

*   **fnat**: Requests from IPv4 addresses are forwarded to origin servers that use IPv4 addresses and requests from IPv6 addresses are forwarded to origin servers that use IPv6 addresses.
*   **v6tov4**: All requests are forwarded to origin servers that use IPv4 addresses.', example='fnat'),
      ipVersion?: string(name='IpVersion', description='The IP version of the instance. Valid values:

*   **Ipv4**
*   **Ipv6**', example='Ipv4'),
      remark?: string(name='Remark', description='The description of the instance.', example='test'),
    }
  ](name='InstanceIds', description='The ID, type, description, and IP version of the instance.'),
  requestId?: string(name='RequestId', example='310A41FD-0990-5610-92E0-A6A55D7C6444'),
}

model DescribeInstanceIdsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstanceIdsResponseBody(name='body'),
}

/**
 * @summary The description of the instance.
 *
 * @param request DescribeInstanceIdsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceIdsResponse
 */
async function describeInstanceIdsWithOptions(request: DescribeInstanceIdsRequest, runtime: $RuntimeOptions): DescribeInstanceIdsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.edition)) {
    query['Edition'] = request.edition;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeInstanceIds',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary The description of the instance.
 *
 * @param request DescribeInstanceIdsRequest
 * @return DescribeInstanceIdsResponse
 */
async function describeInstanceIds(request: DescribeInstanceIdsRequest): DescribeInstanceIdsResponse {
  var runtime = new $RuntimeOptions{};
  return describeInstanceIdsWithOptions(request, runtime);
}

model DescribeInstanceSpecsRequest {
  instanceIds?: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances to query.

This parameter is required.'),
}

model DescribeInstanceSpecsResponseBody = {
  instanceSpecs?: [ 
    {
      bandwidthMbps?: int32(name='BandwidthMbps', description='The clean bandwidth. Unit: Mbit/s.', example='100'),
      baseBandwidth?: int32(name='BaseBandwidth', description='The basic protection bandwidth. Unit: Gbit/s.', example='30'),
      connLimit?: long(name='ConnLimit', description='The specification of concurrent connections of the instance.', example='100000'),
      cpsLimit?: long(name='CpsLimit', description='The specification of new connections of the instance.', example='5000'),
      defenseCount?: int32(name='DefenseCount', description='The number of available advanced mitigation sessions for this month. **-1**: unlimited

>  This parameter is returned only when the request parameter **RegionId** is set to **ap-southeast-1**. If RegionId is set to ap-southeast-1, the specifications of Anti-DDoS Proxy (Outside Chinese Mainland) instances are queried.', example='2'),
      domainLimit?: int32(name='DomainLimit', description='The number of domain names that can be protected by the instance.', example='50'),
      elasticBandwidth?: int32(name='ElasticBandwidth', description='The burstable protection bandwidth. Unit: Gbit/s.', example='30'),
      elasticBw?: int32(name='ElasticBw', description='The burstable clean bandwidth. Unit: Mbit/s.', example='300'),
      elasticBwModel?: string(name='ElasticBwModel', description='The metering method of the burstable clean bandwidth. Valid values:

*   **day**: the metering method of daily 95th percentile
*   **month**: the metering method of monthly 95th percentile', example='day'),
      elasticQps?: long(name='ElasticQps', description='The burstable QPS. Unit: QPS', example='10'),
      elasticQpsMode?: string(name='ElasticQpsMode', description='The metering method of the burstable QPS. Valid values:

*   **day**: the metering method of daily 95th percentile
*   **month**: the metering method of monthly 95th percentile', example='day'),
      functionVersion?: string(name='FunctionVersion', description='The function plan of the instance. Valid values:

*   **default**: Standard
*   **enhance**: Enhanced
*   **cnhk**: Chinese Mainland Acceleration (CMA)
*   **cnhk_default**: Secure Chinese Mainland Acceleration (Sec-CMA) standard
*   **cnhk_enhance**: Sec-CMA enhanced', example='default'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-zvp2eibz****'),
      portLimit?: int32(name='PortLimit', description='The number of ports that can be protected by the instance.', example='50'),
      qpsLimit?: int32(name='QpsLimit', description='The clean QPS.', example='3000'),
      realLimitBw?: long(name='RealLimitBw', description='The threshold of the clean bandwidth. Valid values: 0 to 15360. The value 0 indicates that rate limiting is never triggered. Unit: Mbit/s', example='0'),
      siteLimit?: int32(name='SiteLimit', description='The number of sites that can be protected by the instance.', example='5'),
    }
  ](name='InstanceSpecs', description='The details of the specifications of the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='4E3A9B5F-5DDB-593D-A1E6-F1F451DB5E0B'),
}

model DescribeInstanceSpecsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstanceSpecsResponseBody(name='body'),
}

/**
 * @summary Queries the specifications of Anti-DDoS Pro or Anti-DDoS Premium instances.
 *
 * @description You can call the DescribeInstanceSpecs operation to query the specifications of multiple Anti-DDoS Pro or Anti-DDoS Premium instances at a time. The specifications include the clean bandwidth, protection bandwidth, function plan, and the numbers of domain names and ports that can be protected.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeInstanceSpecsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceSpecsResponse
 */
async function describeInstanceSpecsWithOptions(request: DescribeInstanceSpecsRequest, runtime: $RuntimeOptions): DescribeInstanceSpecsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeInstanceSpecs',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the specifications of Anti-DDoS Pro or Anti-DDoS Premium instances.
 *
 * @description You can call the DescribeInstanceSpecs operation to query the specifications of multiple Anti-DDoS Pro or Anti-DDoS Premium instances at a time. The specifications include the clean bandwidth, protection bandwidth, function plan, and the numbers of domain names and ports that can be protected.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeInstanceSpecsRequest
 * @return DescribeInstanceSpecsResponse
 */
async function describeInstanceSpecs(request: DescribeInstanceSpecsRequest): DescribeInstanceSpecsResponse {
  var runtime = new $RuntimeOptions{};
  return describeInstanceSpecsWithOptions(request, runtime);
}

model DescribeInstanceStatisticsRequest {
  instanceIds?: [ string ](name='InstanceIds', description='The ID of the instance that you want to query.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
}

model DescribeInstanceStatisticsResponseBody = {
  instanceStatistics?: [ 
    {
      defenseCountUsage?: int32(name='DefenseCountUsage', description='The number of advanced mitigation sessions that are used in this month.

>  This parameter is returned only if Anti-DDoS Proxy (Outside Chinese Mainland) instances are queried.', example='1'),
      domainUsage?: int32(name='DomainUsage', description='The number of domain names that are protected by the instance.', example='1'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-mp91j1ao****'),
      portUsage?: int32(name='PortUsage', description='The number of ports that are protected by the instance.', example='2'),
      siteUsage?: int32(name='SiteUsage', description='The number of websites that are protected by the instance.', example='1'),
    }
  ](name='InstanceStatistics', description='The statistics on the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='642319A9-D1F2-4459-A447-E57CFC599FDE'),
}

model DescribeInstanceStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstanceStatisticsResponseBody(name='body'),
}

/**
 * @summary Queries the statistics on one or more Anti-DDoS Proxy instances, such as the numbers of protected domain names and ports.
 *
 * @param request DescribeInstanceStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceStatisticsResponse
 */
async function describeInstanceStatisticsWithOptions(request: DescribeInstanceStatisticsRequest, runtime: $RuntimeOptions): DescribeInstanceStatisticsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeInstanceStatistics',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the statistics on one or more Anti-DDoS Proxy instances, such as the numbers of protected domain names and ports.
 *
 * @param request DescribeInstanceStatisticsRequest
 * @return DescribeInstanceStatisticsResponse
 */
async function describeInstanceStatistics(request: DescribeInstanceStatisticsRequest): DescribeInstanceStatisticsResponse {
  var runtime = new $RuntimeOptions{};
  return describeInstanceStatisticsWithOptions(request, runtime);
}

model DescribeInstanceStatusRequest {
  instanceId?: string(name='InstanceId', description='The ID of the Anti-DDoS Proxy instance to query.

>  You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all Anti-DDoS Proxy (Chinese Mainland) or Anti-DDoS Proxy (Outside Chinese Mainland) instances.

This parameter is required.', example='ddoscoo-cn-6ja1y6p5****'),
  productType?: int32(name='ProductType', description='The type of the Anti-DDoS Proxy instance to query. Valid values:

*   **1**: an Anti-DDoS Proxy (Chinese Mainland) instance
*   **2**: an Anti-DDoS Proxy (Outside Chinese Mainland) instance

This parameter is required.', example='1'),
}

model DescribeInstanceStatusResponseBody = {
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-6ja1y6p5****'),
  instanceStatus?: int32(name='InstanceStatus', description='The status of the instance. Valid values:

*   **1**: normal
*   **2**: expired
*   **3**: overdue
*   **4**: released', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='112777CC-2AD6-46FC-A263-00B931406FCD'),
}

model DescribeInstanceStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstanceStatusResponseBody(name='body'),
}

/**
 * @summary Queries the status of a specified Anti-DDoS Proxy instance.
 *
 * @param request DescribeInstanceStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceStatusResponse
 */
async function describeInstanceStatusWithOptions(request: DescribeInstanceStatusRequest, runtime: $RuntimeOptions): DescribeInstanceStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.productType)) {
    query['ProductType'] = request.productType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeInstanceStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the status of a specified Anti-DDoS Proxy instance.
 *
 * @param request DescribeInstanceStatusRequest
 * @return DescribeInstanceStatusResponse
 */
async function describeInstanceStatus(request: DescribeInstanceStatusRequest): DescribeInstanceStatusResponse {
  var runtime = new $RuntimeOptions{};
  return describeInstanceStatusWithOptions(request, runtime);
}

model DescribeInstancesRequest {
  edition?: int32(name='Edition', description='The mitigation plan of the instance to query. Valid values:

*   **0**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Insurance mitigation plan
*   **1**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Unlimited mitigation plan
*   **2**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Chinese Mainland Acceleration (CMA) mitigation plan
*   **9**: Anti-DDoS Proxy (Chinese Mainland) instance of the Profession mitigation plan', example='9'),
  enabled?: int32(name='Enabled', description='The traffic forwarding status of the instance to query. Valid values:

*   **0**: The instance no longer forwards service traffic.
*   **1**: The instance forwards service traffic as expected.', example='1'),
  expireEndTime?: long(name='ExpireEndTime', description='The end of the time range to query. Instances whose expiration time is earlier than the point in time are queried. This value is a UNIX timestamp. Unit: milliseconds.', example='1640361700000'),
  expireStartTime?: long(name='ExpireStartTime', description='The beginning of the time range to query. Instances whose expiration time is later than the point in time are queried. This value is a UNIX timestamp. Unit: milliseconds.', example='1640361500000'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the instances to query. You can specify up to 200 instance IDs.'),
  ip?: string(name='Ip', description='The IP address of the instance to query.', example='203.107.XX.XX'),
  pageNumber?: string(name='PageNumber', description='The number of the page to return.

This parameter is required.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='10'),
  remark?: string(name='Remark', description='The remarks of the instance to query. Fuzzy match is supported.', example='doc-test'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not specify this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
  status?: [ int32 ](name='Status', description='The states of the instances to query. You can specify up to two states.'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag that is added to the instance to query. You can specify up to 200 tag keys. When you specify tags, take note of the following rules:

*   Each tag consists of a key (**Key**) and a value (**Value**), which are separated with a comma (,).
*   Separate multiple tags with commas (,).

>  The tag key (**Key**) and tag value (**Value**) must be specified in pairs.', example='test-key'),
      value?: string(name='Value', description='The value of the tag that is added to the instance to query. You can specify up to 200 tag values. When you specify tags, take note of the following rules:

*   Each tag consists of a key (**Key**) and a value (**Value**), which are separated with a comma (,).
*   Separate multiple tags with commas (,).

>  The tag key (**Key**) and tag value (**Value**) must be specified in pairs.', example='test-value'),
    }
  ](name='Tag', description='The tags that are added to the instances to query.'),
}

model DescribeInstancesResponseBody = {
  instances?: [ 
    {
      createTime?: long(name='CreateTime', description='The time when the instance was created. The value is a UNIX timestamp. Unit: milliseconds.', example='1637751953000'),
      debtStatus?: int32(name='DebtStatus', description='The overdue status of the instance. The value is fixed as **0**, which indicates that your Alibaba Cloud account does not have overdue payments. The instance supports only the subscription billing method.', example='0'),
      edition?: int32(name='Edition', description='The mitigation plan of the instance. Valid values:

*   **0**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Insurance mitigation plan
*   **1**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Unlimited mitigation plan
*   **2**: Anti-DDoS Proxy (Outside Chinese Mainland) instance of the Chinese Mainland Acceleration (CMA) mitigation plan
*   **9**: Anti-DDoS Proxy (Chinese Mainland) instance of the Profession mitigation plan', example='9'),
      enabled?: int32(name='Enabled', description='The traffic forwarding status of the instance. Valid values:

*   **0**: The instance no longer forwards service traffic.
*   **1**: The instance forwards service traffic as expected.', example='1'),
      expireTime?: long(name='ExpireTime', description='The time when the instance expires. The value is a UNIX timestamp. Unit: milliseconds.', example='1640361600000'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-7pp2g9ed****'),
      ip?: string(name='Ip', description='The IP address of the instance.', example='203.199.XX.XX'),
      ipMode?: string(name='IpMode', description='The IP address-based forwarding mode of the instance. Valid values:

*   **fnat**: Requests from IPv4 addresses are forwarded to origin servers that use IPv4 addresses and requests from IPv6 addresses are forwarded to origin servers that use IPv6 addresses.
*   **v6tov4**: All requests are forwarded to origin servers that use IPv4 addresses.', example='fnat'),
      ipVersion?: string(name='IpVersion', description='The IP version of the instance. Valid values:

*   **Ipv4**
*   **Ipv6**', example='Ipv4'),
      isFirstOpenBw?: long(name='IsFirstOpenBw', description='Indicates whether the metering method of the 95th percentile burstable clean bandwidth is enabled for the instance. Valid values:

*   0: no
*   1: yes', example='0'),
      isFirstOpenQps?: long(name='IsFirstOpenQps', description='Indicates whether the metering method of the 95th percentile burstable QPS is enabled for the instance. Valid values:

*   0: no
*   1: yes', example='0'),
      remark?: string(name='Remark', description='The remarks of the instance.', example='doc-test'),
      status?: int32(name='Status', description='The status of the instance. Valid values:

*   **1**: normal
*   **2**: expired', example='1'),
    }
  ](name='Instances', description='The details about the instances.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='A0AF40CC-814A-5A86-AEAA-6F19E88B8A39'),
  totalCount?: long(name='TotalCount', description='The total number of the instances.', example='1'),
}

model DescribeInstancesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeInstancesResponseBody(name='body'),
}

/**
 * @summary 查询实例列表
 *
 * @description You can call the DescribeInstances operation to query the details of Anti-DDoS Pro or Anti-DDoS Premium instances within the Alibaba Cloud account by page. The details include the ID, mitigation plan, expiration time, and forwarding status.
 *
 * @param request DescribeInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstancesResponse
 */
async function describeInstancesWithOptions(request: DescribeInstancesRequest, runtime: $RuntimeOptions): DescribeInstancesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.edition)) {
    query['Edition'] = request.edition;
  }
  if (!$isNull(request.enabled)) {
    query['Enabled'] = request.enabled;
  }
  if (!$isNull(request.expireEndTime)) {
    query['ExpireEndTime'] = request.expireEndTime;
  }
  if (!$isNull(request.expireStartTime)) {
    query['ExpireStartTime'] = request.expireStartTime;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.status)) {
    query['Status'] = request.status;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeInstances',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 查询实例列表
 *
 * @description You can call the DescribeInstances operation to query the details of Anti-DDoS Pro or Anti-DDoS Premium instances within the Alibaba Cloud account by page. The details include the ID, mitigation plan, expiration time, and forwarding status.
 *
 * @param request DescribeInstancesRequest
 * @return DescribeInstancesResponse
 */
async function describeInstances(request: DescribeInstancesRequest): DescribeInstancesResponse {
  var runtime = new $RuntimeOptions{};
  return describeInstancesWithOptions(request, runtime);
}

model DescribeL7GlobalRuleRequest {
  domain?: string(name='Domain', description='This parameter is required.', example='example.com'),
  lang?: string(name='Lang', example='zh'),
}

model DescribeL7GlobalRuleResponseBody = {
  globalRules?: [ 
    {
      action?: string(name='Action', example='watch'),
      actionDefault?: string(name='ActionDefault', example='watch'),
      description?: string(name='Description'),
      enabled?: long(name='Enabled', example='1'),
      ruleId?: string(name='RuleId', example='global_1'),
      ruleName?: string(name='RuleName'),
    }
  ](name='GlobalRules'),
  requestId?: string(name='RequestId', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model DescribeL7GlobalRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeL7GlobalRuleResponseBody(name='body'),
}

/**
 * @summary 展示全局模板规则
 *
 * @param request DescribeL7GlobalRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeL7GlobalRuleResponse
 */
async function describeL7GlobalRuleWithOptions(request: DescribeL7GlobalRuleRequest, runtime: $RuntimeOptions): DescribeL7GlobalRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.lang)) {
    query['Lang'] = request.lang;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeL7GlobalRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 展示全局模板规则
 *
 * @param request DescribeL7GlobalRuleRequest
 * @return DescribeL7GlobalRuleResponse
 */
async function describeL7GlobalRule(request: DescribeL7GlobalRuleRequest): DescribeL7GlobalRuleResponse {
  var runtime = new $RuntimeOptions{};
  return describeL7GlobalRuleWithOptions(request, runtime);
}

model DescribeL7RsPolicyRequest {
  domain?: string(name='Domain', description='The domain name of the website to query.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query the domain names for which forwarding rules are configured.

This parameter is required.', example='example.com'),
  realServers?: [ string ](name='RealServers', description='An array that consists of N addresses of origin servers to query. The maximum value of N is 200. You can specify up to 200 addresses.', example='1.***.***.1'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).', example='rg-acfm2pz25js****'),
}

model DescribeL7RsPolicyResponseBody = {
  attributes?: [ 
    {
      attribute?: {
        connectTimeout?: int32(name='ConnectTimeout', description='The timeout period for a new connection. Valid values: **1** to **10**. Unit: seconds. Default value: **5**.', example='5'),
        failTimeout?: int32(name='FailTimeout', description='The expiration time of a connection, in seconds. If the number of failures at the origin server exceeds the **MaxFails** value, the address of the origin server is set to down and the expiration time is **FailTimeout**. The final value is the maximum value of **ConnectTimeout** and **FailTimeout**. Valid values: **1** to **3600**. Unit: seconds. Default value: **10**.', example='10'),
        maxFails?: int32(name='MaxFails', description='The maximum number of failures. This parameter is related to health check. Valid values: **1** to **10**. Unit: seconds. Default value: **3**.', example='3'),
        mode?: string(name='Mode', description='The primary/secondary flag. Valid values:

*   **active**: primary
*   **backup**: secondary', example='active'),
        readTimeout?: int32(name='ReadTimeout', description='The timeout period for a read connection. Valid values: **10** to **300**. Unit: seconds. Default value: **120**.', example='120'),
        sendTimeout?: int32(name='SendTimeout', description='The timeout period for a write connection. Valid values: **10** to **300**. Unit: seconds. Default value: **120**.', example='120'),
        weight?: int32(name='Weight', description='The weight of the origin server. This parameter takes effect only if the value of **ProxyMode** is **rr** or **ip_hash**.****

Valid values: **1** to **100**. Default value: **100**. A server with a higher weight receives more requests.', example='100'),
      }(name='Attribute', description='The parameters for back-to-origin settings.'),
      realServer?: string(name='RealServer', description='The address of the origin server.', example='1.***.***.1'),
      rsType?: int32(name='RsType', description='The address type of the origin server. Valid values:

*   **0**: IP address
*   **1**: domain name', example='0'),
    }
  ](name='Attributes', description='The details about the parameters for back-to-origin settings.'),
  proxyMode?: string(name='ProxyMode', description='The scheduling algorithm for back-to-origin traffic. Valid values:

*   **ip_hash**: the IP hash algorithm. This algorithm is used to redirect the requests from the same IP address to the same origin server.
*   **rr**: the round-robin algorithm. This algorithm is used to redirect requests to origin servers in turn.
*   **least_time**: the least response time algorithm. This algorithm is used to minimize the latency when requests are forwarded from Anti-DDoS Pro or Anti-DDoS Premium instances to origin servers based on the intelligent DNS resolution feature.', example='rr'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9E7F6B2C-03F2-462F-9076-B782CF0DD502'),
  rsAttrRwTimeoutMax?: long(name='RsAttrRwTimeoutMax', description='The timeout period for a read or write connection.', example='300'),
  upstreamRetry?: int32(name='UpstreamRetry', description='The back-to-origin retry switch. Valid values:

*   **1**: on
*   **0**: off', example='1'),
}

model DescribeL7RsPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeL7RsPolicyResponseBody(name='body'),
}

/**
 * @summary Queries the back-to-origin policies for the forwarding rule of a website.
 *
 * @param request DescribeL7RsPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeL7RsPolicyResponse
 */
async function describeL7RsPolicyWithOptions(request: DescribeL7RsPolicyRequest, runtime: $RuntimeOptions): DescribeL7RsPolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.realServers)) {
    query['RealServers'] = request.realServers;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeL7RsPolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the back-to-origin policies for the forwarding rule of a website.
 *
 * @param request DescribeL7RsPolicyRequest
 * @return DescribeL7RsPolicyResponse
 */
async function describeL7RsPolicy(request: DescribeL7RsPolicyRequest): DescribeL7RsPolicyResponse {
  var runtime = new $RuntimeOptions{};
  return describeL7RsPolicyWithOptions(request, runtime);
}

model DescribeL7UsKeepaliveRequest {
  domain?: string(name='Domain', description='The domain name of the website.

>  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.', example='www.aliyun.com'),
}

model DescribeL7UsKeepaliveResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='39499F01-19D9-4EA4-A0E9-C6014BA5CDBE'),
  rsKeepalive?: {
    enabled?: boolean(name='Enabled', description='Indicates whether Back-to-origin Persistent Connections is turned on. Valid values:

*   **true**
*   **false**', example='true'),
    keepaliveRequests?: long(name='KeepaliveRequests', description='The number of requests that reuse persistent connections.', example='1000'),
    keepaliveTimeout?: long(name='KeepaliveTimeout', description='The timeout period of idle persistent connections.', example='30'),
  }(name='RsKeepalive', description='The value of the Back-to-origin Persistent Connections parameter.'),
}

model DescribeL7UsKeepaliveResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeL7UsKeepaliveResponseBody(name='body'),
}

/**
 * @summary Queries the configuration of back-to-origin persistent connections of a domain name.
 *
 * @param request DescribeL7UsKeepaliveRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeL7UsKeepaliveResponse
 */
async function describeL7UsKeepaliveWithOptions(request: DescribeL7UsKeepaliveRequest, runtime: $RuntimeOptions): DescribeL7UsKeepaliveResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeL7UsKeepalive',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configuration of back-to-origin persistent connections of a domain name.
 *
 * @param request DescribeL7UsKeepaliveRequest
 * @return DescribeL7UsKeepaliveResponse
 */
async function describeL7UsKeepalive(request: DescribeL7UsKeepaliveRequest): DescribeL7UsKeepaliveResponse {
  var runtime = new $RuntimeOptions{};
  return describeL7UsKeepaliveWithOptions(request, runtime);
}

model DescribeLayer4RulePolicyRequest {
  listeners?: string(name='Listeners', description='The port forwarding rule that you want to query.

This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can query only one port forwarding rule at a time.

> You can call the [DescribeNetworkRules](https://help.aliyun.com/document_detail/157484.html) to query existing port forwarding rules.

Each port forwarding rule contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the string type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the string type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the integer type.

This parameter is required.', example='[{\\\\"InstanceId\\\\":\\\\"ddosDip-sg-4hr2b3l****\\\\",\\\\"FrontendPort\\\\":2020,\\\\"Protocol\\\\":\\\\"udp\\\\"}]'),
}

model DescribeLayer4RulePolicyResponseBody = {
  backendPort?: int32(name='BackendPort', description='The port of the origin server.', example='2022'),
  bakMode?: string(name='BakMode', description='The mode that is used to forward service traffic. Valid values:

*   0: the default mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the origin IP address that you specified when you created the port forwarding rule. You can call the [CreateNetworkRules](https://help.aliyun.com/document_detail/157482.html) operation to create a port forwarding rule.
*   1: the origin redundancy mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary or secondary origin servers. You can call the [ConfigLayer4RulePolicy](https://help.aliyun.com/document_detail/312684.html) operation to configure IP addresses.', example='1'),
  currentIndex?: int32(name='CurrentIndex', description='The origin server that is used to receive service traffic. Valid values:

*   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
*   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.', example='1'),
  forwardProtocol?: string(name='ForwardProtocol', description='The type of the protocol.', example='udp'),
  frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='2020'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddosDip-sg-4hr2b3l****'),
  priRealServers?: [ 
    {
      currentIndex?: int32(name='CurrentIndex', description='The origin server that is used to receive service traffic. Valid values:

*   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
*   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.', example='1'),
      eip?: string(name='Eip', description='The IP address of the instance.', example='203.107.XX.XX'),
      frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='2020'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddosDip-sg-4hr2b3l****'),
      protocol?: string(name='Protocol', description='The type of the protocol.', example='udp'),
      realServer?: string(name='RealServer', description='The IP address of the primary origin server.', example='192.0.2.1'),
    }
  ](name='PriRealServers', description='An array that consists of the information about the primary origin server, including the IP addresses, forwarding protocol, and forwarding port.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6E46CC51-36BE-1100-B14C-DAF8381B8F73'),
  secRealServers?: [ 
    {
      currentIndex?: int32(name='CurrentIndex', description='The origin server that is used to receive service traffic. Valid values:

*   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
*   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.', example='1'),
      eip?: string(name='Eip', description='The IP address of the instance.', example='203.107.XX.XX'),
      frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='2020'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddosDip-sg-4hr2b3l****'),
      protocol?: string(name='Protocol', description='The type of the protocol.', example='udp'),
      realServer?: string(name='RealServer', description='The IP address of the secondary origin server.', example='192.0.2.3'),
    }
  ](name='SecRealServers', description='An array that consists of the information about the secondary origin server, including the IP addresses, forwarding protocol, and forwarding port.'),
}

model DescribeLayer4RulePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLayer4RulePolicyResponseBody(name='body'),
}

/**
 * @summary Queries the back-to-origin settings of a port forwarding rule.
 *
 * @param request DescribeLayer4RulePolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLayer4RulePolicyResponse
 */
async function describeLayer4RulePolicyWithOptions(request: DescribeLayer4RulePolicyRequest, runtime: $RuntimeOptions): DescribeLayer4RulePolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.listeners)) {
    query['Listeners'] = request.listeners;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeLayer4RulePolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the back-to-origin settings of a port forwarding rule.
 *
 * @param request DescribeLayer4RulePolicyRequest
 * @return DescribeLayer4RulePolicyResponse
 */
async function describeLayer4RulePolicy(request: DescribeLayer4RulePolicyRequest): DescribeLayer4RulePolicyResponse {
  var runtime = new $RuntimeOptions{};
  return describeLayer4RulePolicyWithOptions(request, runtime);
}

model DescribeLogStoreExistStatusRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DescribeLogStoreExistStatusResponseBody = {
  existStatus?: boolean(name='ExistStatus', description='Indicates whether a Logstore is created for Anti-DDoS Pro or Anti-DDoS Premium. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model DescribeLogStoreExistStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLogStoreExistStatusResponseBody(name='body'),
}

/**
 * @summary Checks whether a Logstore is created for Anti-DDoS Proxy.
 *
 * @param request DescribeLogStoreExistStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLogStoreExistStatusResponse
 */
async function describeLogStoreExistStatusWithOptions(request: DescribeLogStoreExistStatusRequest, runtime: $RuntimeOptions): DescribeLogStoreExistStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeLogStoreExistStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Checks whether a Logstore is created for Anti-DDoS Proxy.
 *
 * @param request DescribeLogStoreExistStatusRequest
 * @return DescribeLogStoreExistStatusResponse
 */
async function describeLogStoreExistStatus(request: DescribeLogStoreExistStatusRequest): DescribeLogStoreExistStatusResponse {
  var runtime = new $RuntimeOptions{};
  return describeLogStoreExistStatusWithOptions(request, runtime);
}

model DescribeNetworkRegionBlockRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
}

model DescribeNetworkRegionBlockResponseBody = {
  config?: {
    countries?: [ long ](name='Countries', description='The codes of the countries or areas from which the requests are blocked.'),
    provinces?: [ long ](name='Provinces', description='The codes of the administrative regions in China from which the requests are blocked.'),
    regionBlockSwitch?: string(name='RegionBlockSwitch', description='The status of the Location Blacklist policy. Valid values:

*   **on**: enabled
*   **off**: disabled', example='on'),
  }(name='Config', description='The configuration of blocked locations.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DescribeNetworkRegionBlockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeNetworkRegionBlockResponseBody(name='body'),
}

/**
 * @summary Queries the blocked locations that are configured for an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request DescribeNetworkRegionBlockRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNetworkRegionBlockResponse
 */
async function describeNetworkRegionBlockWithOptions(request: DescribeNetworkRegionBlockRequest, runtime: $RuntimeOptions): DescribeNetworkRegionBlockResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeNetworkRegionBlock',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the blocked locations that are configured for an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request DescribeNetworkRegionBlockRequest
 * @return DescribeNetworkRegionBlockResponse
 */
async function describeNetworkRegionBlock(request: DescribeNetworkRegionBlockRequest): DescribeNetworkRegionBlockResponse {
  var runtime = new $RuntimeOptions{};
  return describeNetworkRegionBlockWithOptions(request, runtime);
}

model DescribeNetworkRuleAttributesRequest {
  networkRules?: string(name='NetworkRules', description='The details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:

*   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
*   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
*   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.

This parameter is required.', example='[{"InstanceId":"ddoscoo-cn-mp91j1ao****","Protocol":"tcp","FrontendPort":8080}]'),
}

model DescribeNetworkRuleAttributesResponseBody = {
  networkRuleAttributes?: [ 
    {
      config?: {
        cc?: {
          sblack?: [ 
            {
              cnt?: int32(name='Cnt', description='The threshold that the number of connections initiated from a source IP address can exceed the limit. Set the value to **5**. If the number of connections initiated from a source IP address exceeds the limit five times during the check, the source IP address is added to the blacklist.', example='5'),
              during?: int32(name='During', description='The interval at which checks are performed. Set the value to **60**. Unit: seconds.', example='60'),
              expires?: int32(name='Expires', description='The validity period of the IP address in the blacklist. Valid values: **60** to **604800**. Unit: seconds.', example='600'),
              type?: int32(name='Type', description='The type of the limit that causes a source IP address to be added to the blacklist. Valid values:

*   **1**: Source New Connection Rate Limit
*   **2**: Source Concurrent Connection Rate Limit
*   **3**: PPS Limit for Source
*   **4**: Bandwidth Limit for Source', example='1'),
            }
          ](name='Sblack', description='The protection policy that a source IP address is added to the blacklist when the number of connections initiated from the IP address frequently exceeds the limit.'),
        }(name='Cc', description='The protection policy applied when the number of connections initiated from a source IP address frequently exceeds the limit.'),
        nodataConn?: string(name='NodataConn', description='The status of the Empty Connection switch. Valid values:

*   **on**: The switch is turned on.
*   **off**: The switch is turned off.', example='off'),
        payloadLen?: {
          max?: int32(name='Max', description='The maximum length of a packet. Valid values: **0** to **6000**. Unit: bytes.', example='6000'),
          min?: int32(name='Min', description='The minimum length of a packet. Valid values: **0** to **6000**. Unit: bytes.', example='0'),
        }(name='PayloadLen', description='The settings of the Packet Length Limit policy.'),
        persistenceTimeout?: int32(name='PersistenceTimeout', description='The timeout period of session persistence. Valid values: **30** to **3600**. Unit: seconds. Default value: **0**, which indicates that session persistence is disabled.', example='0'),
        sla?: {
          cps?: int32(name='Cps', description='The maximum number of new connections per second that can be established over the port of the destination instance. Valid values: **100** to **100000**.', example='100000'),
          cpsEnable?: int32(name='CpsEnable', description='The status of the Destination New Connection Rate Limit switch. Valid values:

*   **0**: The switch is turned off.
*   **1**: The switch is turned on.', example='1'),
          maxconn?: int32(name='Maxconn', description='The maximum number of concurrent connections that can be established over the port of the destination instance. Valid values: **1000** to **1000000**.', example='1000000'),
          maxconnEnable?: int32(name='MaxconnEnable', description='The status of the Destination Concurrent Connection Rate Limit switch. Valid values:

*   **0**: The switch is turned off.
*   **1**: The switch is turned on.', example='0'),
        }(name='Sla', description='The settings of the Speed Limit for Destination policy.'),
        slimit?: {
          bps?: long(name='Bps', description='The bandwidth limit for a source IP address. Valid values: **1024** to **268435456**. Unit: bytes/s. Default value: **0**, which indicates that the bandwidth for a source IP address is unlimited.', example='0'),
          cps?: int32(name='Cps', description='The maximum number of new connections per second that can be initiated from a source IP address. Valid values: **1** to **500000**.', example='0'),
          cpsEnable?: int32(name='CpsEnable', description='The status of the Source New Connection Rate Limit switch. Valid values:

*   **0**: The switch is turned off.
*   **1**: The switch is turned on.', example='0'),
          cpsMode?: int32(name='CpsMode', description='The mode of the Source New Connection Rate Limit switch. Valid values:

*   **1**: the manual mode
*   **2**: the automatic mode', example='1'),
          maxconn?: int32(name='Maxconn', description='The maximum number of concurrent connections initiated from a source IP address. Valid values: **1** to **500000**.', example='0'),
          maxconnEnable?: int32(name='MaxconnEnable', description='The status of the Source Concurrent Connection Rate Limit switch. Valid values:

*   **0**: The switch is turned off.
*   **1**: The switch is turned on.', example='0'),
          pps?: long(name='Pps', description='The packets per second (pps) limit for a source IP address. Valid values: **1** to **100000**. Unit: packets/s. Default value: **0**, which indicates that the pps for a source IP address is unlimited.', example='0'),
        }(name='Slimit', description='The settings of the Speed Limit for Source policy.'),
        synproxy?: string(name='Synproxy', description='The status of the False Source switch. Valid values:

*   **on**: The switch is turned on.
*   **off**: The switch is turned off.', example='off'),
      }(name='Config', description='The mitigation settings of the port forwarding rule.'),
      frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='8080'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-mp91j1ao****'),
      protocol?: string(name='Protocol', description='The forwarding protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp'),
    }
  ](name='NetworkRuleAttributes', description='An array that consists of the mitigation settings of the port forwarding rule for a non-website service. The mitigation settings include session persistence and DDoS mitigation policies.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F9F2F77D-307C-4F15-8D02-AB5957EEBF97'),
}

model DescribeNetworkRuleAttributesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeNetworkRuleAttributesResponseBody(name='body'),
}

/**
 * @summary Queries the mitigation settings of the port forwarding rule for a non-website service. The mitigation settings include session persistence and DDoS mitigation policies.
 *
 * @param request DescribeNetworkRuleAttributesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNetworkRuleAttributesResponse
 */
async function describeNetworkRuleAttributesWithOptions(request: DescribeNetworkRuleAttributesRequest, runtime: $RuntimeOptions): DescribeNetworkRuleAttributesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.networkRules)) {
    query['NetworkRules'] = request.networkRules;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeNetworkRuleAttributes',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the mitigation settings of the port forwarding rule for a non-website service. The mitigation settings include session persistence and DDoS mitigation policies.
 *
 * @param request DescribeNetworkRuleAttributesRequest
 * @return DescribeNetworkRuleAttributesResponse
 */
async function describeNetworkRuleAttributes(request: DescribeNetworkRuleAttributesRequest): DescribeNetworkRuleAttributesResponse {
  var runtime = new $RuntimeOptions{};
  return describeNetworkRuleAttributesWithOptions(request, runtime);
}

model DescribeNetworkRulesRequest {
  forwardProtocol?: string(name='ForwardProtocol', description='The forwarding protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp'),
  frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='80'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='10'),
}

model DescribeNetworkRulesResponseBody = {
  networkRules?: [ 
    {
      backendPort?: int32(name='BackendPort', description='The port of the origin server.', example='80'),
      frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='80'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-mp91j1ao****'),
      isAutoCreate?: boolean(name='IsAutoCreate', description='Indicates whether the port forwarding rule is automatically created. Valid values:

*   **true**
*   **false**', example='true'),
      payloadRuleEnable?: long(name='PayloadRuleEnable', description='Indicates whether the payload filtering rule is enabled. Valid values:

*   1: enabled.
*   0: disabled.', example='1'),
      protocol?: string(name='Protocol', description='The forwarding protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp'),
      proxyEnable?: long(name='ProxyEnable', description='Indicates whether the traffic diversion switch is on. Valid values:

*   0: on.
*   1: off.', example='0'),
      proxyStatus?: string(name='ProxyStatus', description='The status of traffic diversion. Valid values:

*   on: Traffic diversion takes effect.
*   off: Traffic diversion does not take effect.', example='on'),
      realServers?: [ string ](name='RealServers', description='The IP addresses of origin servers.'),
      remark?: string(name='Remark', description='The remarks of the port forwarding rule.', example='Test'),
    }
  ](name='NetworkRules', description='The details of the port forwarding rules.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='8597F235-FA5E-4FC7-BAD9-E4C0B01BC771'),
  totalCount?: long(name='TotalCount', description='The total number of returned port forwarding rules.', example='1'),
}

model DescribeNetworkRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeNetworkRulesResponseBody(name='body'),
}

/**
 * @summary Queries port forwarding rules.
 *
 * @param request DescribeNetworkRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNetworkRulesResponse
 */
async function describeNetworkRulesWithOptions(request: DescribeNetworkRulesRequest, runtime: $RuntimeOptions): DescribeNetworkRulesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.forwardProtocol)) {
    query['ForwardProtocol'] = request.forwardProtocol;
  }
  if (!$isNull(request.frontendPort)) {
    query['FrontendPort'] = request.frontendPort;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeNetworkRules',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries port forwarding rules.
 *
 * @param request DescribeNetworkRulesRequest
 * @return DescribeNetworkRulesResponse
 */
async function describeNetworkRules(request: DescribeNetworkRulesRequest): DescribeNetworkRulesResponse {
  var runtime = new $RuntimeOptions{};
  return describeNetworkRulesWithOptions(request, runtime);
}

model DescribeOpEntitiesRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.

> The time must be in the latest 30 days.

This parameter is required.', example='1583683200000'),
  entityObject?: string(name='EntityObject', description='The operation object that you want to query.', example='203.***.***.132'),
  entityType?: int32(name='EntityType', description='The type of the operation object that you want to query. Valid values:

*   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
*   **2**: Anti-DDoS plans
*   **3**: ECS instances
*   **4**: all logs', example='1'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Maximum value: **50**.

This parameter is required.', example='10'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.

> The time must be in the latest 30 days.

This parameter is required.', example='1582992000000'),
}

model DescribeOpEntitiesResponseBody = {
  opEntities?: [ 
    {
      entityObject?: string(name='EntityObject', description='The operation object.', example='203.***.***.132'),
      entityType?: int32(name='EntityType', description='The type of the operation object. Valid values:

*   **1**: the IP address of the Anti-DDoS Proxy instance.
*   **2**: Anti-DDoS plans.
*   **3**: ECS instances.
*   **4**: all logs.', example='1'),
      gmtCreate?: long(name='GmtCreate', description='The time when the operation was performed. The value is a UNIX timestamp. Units: milliseconds.', example='1584451769000'),
      opAccount?: string(name='OpAccount', description='The ID of the Alibaba Cloud account that is used to perform the operation.', example='128965410602****'),
      opAction?: int32(name='OpAction', description='The type of the operation. Valid values:

*   **1**: configuring burstable protection bandwidth.
*   **5**: using Anti-DDoS plans.
*   **8**: changing the IP addresses of ECS instances.
*   **9**: deactivating blackhole filtering.
*   **10**: configuring the near-origin traffic diversion feature.
*   **11**: clearing all logs.
*   **12**: downgrading the specifications of the Anti-DDoS Proxy instance. If the instance expires or the account has overdue payments, this operation is performed to downgrade the burstable protection bandwidth.
*   **13**: restoring the specifications of the Anti-DDoS Proxy instance. If the instance is renewed or you have paid the overdue payments within your account, this operation is performed to restore the burstable protection bandwidth.', example='9'),
      opDesc?: string(name='OpDesc', description='The details of the operation. This parameter is a JSON string. The string contains the following fields:

*   **newEntity**: the values of the parameters after the operation. This field is of the string type.
*   **oldEntity**: the values of the parameters before the operation. This field is of the string type.

Both **newEntity** and **oldEntity** are JSON strings. The returned parameters vary based on **OpAction**.

If the value of **OpAction** is **1**, **12**, or **13**, the following parameter is returned:

*   **elasticBandwidth**: the burstable protection bandwidth. This parameter is of the integer type. Unit: Gbit/s.

    Example: `{"newEntity":{"elasticBandwidth":300},"oldEntity":{"elasticBandwidth":300}}`

If the value of **OpAction** is **5**, the following parameters are returned:

*   **bandwidth**: the burstable protection bandwidth. The parameter is of the integer type. Unit: Gbit/s.

*   **count**: the number of Anti-DDoS plans. This parameter is of the integer type.

*   **deductCount**: the number of used Anti-DDoS plans. This parameter is of the integer type.

*   **expireTime**: the expiration time of the Anti-DDoS plans. This parameter is of the long type. The value is a UNIX timestamp. Units: milliseconds.

*   **instanceId**: the ID of the Anti-DDoS Proxy instance. This parameter is of the string type.

*   **peakFlow**: the peak throughput on the Anti-DDoS Proxy instance. This parameter is of the integer type. Unit: bit/s.

    Example: `{"newEntity":{"bandwidth":100,"count":4,"deductCount":1,"expireTime":1616299196000,"instanceId":"ddoscoo-cn-v641kpmq****","peakFlow":751427000}}`

If the value of **OpAction** is **8**, the following parameter is returned:

*   **instanceId**: the IDs of the ECS instances whose IP addresses are changed. This parameter is of the string type.

    Example: `{"newEntity":{"instanceId":"i-wz9h6nc313zptbqn****"}}`

If the value of **OpAction** is **9**, the following parameter is returned:

*   **actionMethod**: the operation method. This parameter is of the string type. Valid value: **undo**, which indicates that you deactivated blackhole filtering.

    Example: `{"newEntity":{"actionMethod":"undo"}}`

If the value of **OpAction** is **10**, the following parameters are returned:

*   **actionMethod**: the operation method. This parameter is of the string type. Valid values:

    *   **do**: The near-origin traffic diversion feature is enabled.
    *   **undo**: The near-origin traffic diversion feature is disabled.

*   **lines**: the Internet service provider (ISP) line from which the traffic is blocked. This parameter is of the array type. Valid values:

    *   **ct**: China Telecom (International).
    *   **cut**: China Unicom (International).

    Example: `{"newEntity":{"actionMethod":"undo","lines":["ct"]}}`

If the value of **OpAction** is **11**, no parameter is returned, and the description is empty.', example='{"newEntity":{"actionMethod":"undo"}}'),
    }
  ](name='OpEntities', description='The operation records.'),
  requestId?: string(name='RequestId', description='The request ID.', example='FB24D70C-71F5-4000-8CD8-22CDA0C53CD1'),
  totalCount?: long(name='TotalCount', description='The total number of returned operation records.', example='1'),
}

model DescribeOpEntitiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOpEntitiesResponseBody(name='body'),
}

/**
 * @summary Queries the operation logs of Anti-DDoS Proxy (Chinese Mainland).
 *
 * @description >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
 * You can query operations performed on Anti-DDoS Proxy (Chinese Mainland), such as configuring the burstable protection bandwidth, deactivating blackhole filtering, configuring the near-origin traffic diversion feature, using Anti-DDoS plans, changing the IP addresses of Elastic Compute Service (ECS) instances, and clearing all logs.
 *
 * @param request DescribeOpEntitiesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOpEntitiesResponse
 */
async function describeOpEntitiesWithOptions(request: DescribeOpEntitiesRequest, runtime: $RuntimeOptions): DescribeOpEntitiesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.entityObject)) {
    query['EntityObject'] = request.entityObject;
  }
  if (!$isNull(request.entityType)) {
    query['EntityType'] = request.entityType;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeOpEntities',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the operation logs of Anti-DDoS Proxy (Chinese Mainland).
 *
 * @description >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
 * You can query operations performed on Anti-DDoS Proxy (Chinese Mainland), such as configuring the burstable protection bandwidth, deactivating blackhole filtering, configuring the near-origin traffic diversion feature, using Anti-DDoS plans, changing the IP addresses of Elastic Compute Service (ECS) instances, and clearing all logs.
 *
 * @param request DescribeOpEntitiesRequest
 * @return DescribeOpEntitiesResponse
 */
async function describeOpEntities(request: DescribeOpEntitiesRequest): DescribeOpEntitiesResponse {
  var runtime = new $RuntimeOptions{};
  return describeOpEntitiesWithOptions(request, runtime);
}

model DescribePortRequest {
  frontendPort?: int32(name='FrontendPort', description='The forwarding port to query. Valid values: **0** to **65535**.', example='55'),
  frontendProtocol?: string(name='FrontendProtocol', description='The type of the forwarding protocol to query. Valid values:

*   **tcp**
*   **udp**', example='tcp'),
  instanceId?: string(name='InstanceId', description='The ID of the instance to query.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-7e225i41****'),
  pageNumber?: int32(name='PageNumber', description='The page number. For example, if you want to obtain results on the first page, set the value to **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
}

model DescribePortResponseBody = {
  networkRules?: [ 
    {
      backendPort?: int32(name='BackendPort', description='The port of the origin server.', example='55'),
      frontendPort?: int32(name='FrontendPort', description='The forwarding port.', example='55'),
      frontendProtocol?: string(name='FrontendProtocol', description='The type of the protocol. Valid values:

*   **tcp**
*   **udp**', example='tcp'),
      instanceId?: string(name='InstanceId', description='The ID of the instance to which the port forwarding rule is applied.', example='ddoscoo-cn-7e225i41****'),
      isAutoCreate?: boolean(name='IsAutoCreate', description='Indicates whether the port forwarding rule is automatically created by the instance. Valid values:

*   **true**: yes
*   **false**: no', example='false'),
      realServers?: [ string ](name='RealServers', description='An array that consists of IP addresses of origin servers.'),
    }
  ](name='NetworkRules', description='An array that consists of port forwarding rules.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='39499F01-19D9-4EA4-A0E9-C6014BA5CDBE'),
  totalCount?: long(name='TotalCount', description='The number of port forwarding rules returned.', example='1'),
}

model DescribePortResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePortResponseBody(name='body'),
}

/**
 * @summary Queries the port forwarding rules that are created for an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @description You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
 *
 * @param request DescribePortRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePortResponse
 */
async function describePortWithOptions(request: DescribePortRequest, runtime: $RuntimeOptions): DescribePortResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.frontendPort)) {
    query['FrontendPort'] = request.frontendPort;
  }
  if (!$isNull(request.frontendProtocol)) {
    query['FrontendProtocol'] = request.frontendProtocol;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribePort',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the port forwarding rules that are created for an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @description You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
 *
 * @param request DescribePortRequest
 * @return DescribePortResponse
 */
async function describePort(request: DescribePortRequest): DescribePortResponse {
  var runtime = new $RuntimeOptions{};
  return describePortWithOptions(request, runtime);
}

model DescribePortAttackMaxFlowRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. This value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1583683200'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the Anti-DDoS Proxy instances to query.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. This value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribePortAttackMaxFlowResponseBody = {
  bps?: long(name='Bps', description='The peak bandwidth of attack traffic. Unit: bit/s.', example='149559'),
  pps?: long(name='Pps', description='The peak packet rate of attack traffic . Unit: packets per second (pps).', example='23'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DescribePortAttackMaxFlowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePortAttackMaxFlowResponseBody(name='body'),
}

/**
 * @summary Queries the peak attack traffic bandwidth and peak attack traffic packet rates of one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specified period of time.
 *
 * @description You can call this operation to query the peak bandwidth and peak packet rate of attack traffic on one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribePortAttackMaxFlowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePortAttackMaxFlowResponse
 */
async function describePortAttackMaxFlowWithOptions(request: DescribePortAttackMaxFlowRequest, runtime: $RuntimeOptions): DescribePortAttackMaxFlowResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribePortAttackMaxFlow',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the peak attack traffic bandwidth and peak attack traffic packet rates of one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specified period of time.
 *
 * @description You can call this operation to query the peak bandwidth and peak packet rate of attack traffic on one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribePortAttackMaxFlowRequest
 * @return DescribePortAttackMaxFlowResponse
 */
async function describePortAttackMaxFlow(request: DescribePortAttackMaxFlowRequest): DescribePortAttackMaxFlowResponse {
  var runtime = new $RuntimeOptions{};
  return describePortAttackMaxFlowWithOptions(request, runtime);
}

model DescribePortAutoCcStatusRequest {
  instanceIds?: [ string ](name='InstanceIds', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
}

model DescribePortAutoCcStatusResponseBody = {
  portAutoCcStatus?: [ 
    {
      mode?: string(name='Mode', description='The mode of the Intelligent Protection policy. Valid values:

*   **normal**
*   **loose**
*   **strict**', example='normal'),
      switch?: string(name='Switch', description='The status of the Intelligent Protection policy. Valid values:

*   **on**: enabled
*   **off**: disabled', example='on'),
      webMode?: string(name='WebMode', description='The protection mode for ports 80 and 443. Valid values:

*   **normal**
*   **loose**
*   **strict**', example='normal'),
      webSwitch?: string(name='WebSwitch', description='The status of the Intelligent Protection policy for ports 80 and 443. Valid values:

*   **on**: enabled
*   **off**: disabled', example='off'),
    }
  ](name='PortAutoCcStatus', description='An array that consists of the configurations of the Intelligent Protection policy.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BC3C6403-F248-4125-B2C9-8733ED94EA85'),
}

model DescribePortAutoCcStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePortAutoCcStatusResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of the Intelligent Protection policy for non-website services.
 *
 * @param request DescribePortAutoCcStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePortAutoCcStatusResponse
 */
async function describePortAutoCcStatusWithOptions(request: DescribePortAutoCcStatusRequest, runtime: $RuntimeOptions): DescribePortAutoCcStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribePortAutoCcStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of the Intelligent Protection policy for non-website services.
 *
 * @param request DescribePortAutoCcStatusRequest
 * @return DescribePortAutoCcStatusResponse
 */
async function describePortAutoCcStatus(request: DescribePortAutoCcStatusRequest): DescribePortAutoCcStatusResponse {
  var runtime = new $RuntimeOptions{};
  return describePortAutoCcStatusWithOptions(request, runtime);
}

model DescribePortCcAttackTopIPRequest {
  ip?: string(name='Ip', description='The IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance to query.

This parameter is required.', example='203.107.XX.XX'),
  limit?: long(name='Limit', description='The maximum number of entries to return.', example='10'),
  port?: string(name='Port', description='The attacked port.

This parameter is required.', example='6663'),
  startTimestamp?: long(name='StartTimestamp', description='The beginning of the time range to query. Unit: seconds.

This parameter is required.', example='1678017453'),
}

model DescribePortCcAttackTopIPResponseBody = {
  requestId?: string(name='RequestId', description='The request ID, which is used to locate and troubleshoot issues.', example='24F36D81-5E2D-52E5-9DB6-A3ED23CF271A'),
  topIp?: [ 
    {
      areaId?: string(name='AreaId', description='The code of the location from which the attack is initiated. For more information, see [Codes of administrative regions in China and codes of countries and areas](https://help.aliyun.com/document_detail/167926.html). For example, **110000** indicates Beijing, China, and **us** indicates the United States.', example='cn-shanghai'),
      pv?: long(name='Pv', description='The number of attacks from the IP address.', example='33971'),
      srcIp?: string(name='SrcIp', description='The source IP address of the attack.', example='172.18.XX.XX'),
    }
  ](name='TopIp', description='The top IP addresses from which most attacks are initiated.'),
}

model DescribePortCcAttackTopIPResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePortCcAttackTopIPResponseBody(name='body'),
}

/**
 * @summary Queries the top source IP addresses of the volumetric attack events for the Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request DescribePortCcAttackTopIPRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePortCcAttackTopIPResponse
 */
async function describePortCcAttackTopIPWithOptions(request: DescribePortCcAttackTopIPRequest, runtime: $RuntimeOptions): DescribePortCcAttackTopIPResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!$isNull(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!$isNull(request.port)) {
    query['Port'] = request.port;
  }
  if (!$isNull(request.startTimestamp)) {
    query['StartTimestamp'] = request.startTimestamp;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribePortCcAttackTopIP',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the top source IP addresses of the volumetric attack events for the Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request DescribePortCcAttackTopIPRequest
 * @return DescribePortCcAttackTopIPResponse
 */
async function describePortCcAttackTopIP(request: DescribePortCcAttackTopIPRequest): DescribePortCcAttackTopIPResponse {
  var runtime = new $RuntimeOptions{};
  return describePortCcAttackTopIPWithOptions(request, runtime);
}

model DescribePortConnsCountRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1583683200'),
  instanceIds?: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  port?: string(name='Port', description='The number of port that you want to query. If you do not specify this parameter, all ports are queried.', example='80'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribePortConnsCountResponseBody = {
  actConns?: long(name='ActConns', description='The number of active connections.', example='159'),
  conns?: long(name='Conns', description='The number of concurrent connections.', example='46340'),
  cps?: long(name='Cps', description='The number of new connections.', example='0'),
  inActConns?: long(name='InActConns', description='The number of inactive connections.', example='121'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='48859E14-A9FB-4100-99FF-AAB75CA46776'),
}

model DescribePortConnsCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePortConnsCountResponseBody(name='body'),
}

/**
 * @summary The statistics on the connections established over the ports of one or more Anti-DDoS Pro or Anti-DDoS Premium instances are queried.
 *
 * @param request DescribePortConnsCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePortConnsCountResponse
 */
async function describePortConnsCountWithOptions(request: DescribePortConnsCountRequest, runtime: $RuntimeOptions): DescribePortConnsCountResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.port)) {
    query['Port'] = request.port;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribePortConnsCount',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary The statistics on the connections established over the ports of one or more Anti-DDoS Pro or Anti-DDoS Premium instances are queried.
 *
 * @param request DescribePortConnsCountRequest
 * @return DescribePortConnsCountResponse
 */
async function describePortConnsCount(request: DescribePortConnsCountRequest): DescribePortConnsCountResponse {
  var runtime = new $RuntimeOptions{};
  return describePortConnsCountWithOptions(request, runtime);
}

model DescribePortConnsListRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1583683200'),
  instanceIds?: [ string ](name='InstanceIds', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  interval?: int32(name='Interval', description='The interval for returning data. Unit: seconds.

This parameter is required.', example='1000'),
  port?: string(name='Port', description='The number of port that you want to query. If you do not specify this parameter, all ports are queried.', example='80'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribePortConnsListResponseBody = {
  connsList?: [ 
    {
      actConns?: long(name='ActConns', description='The number of active connections.', example='3'),
      conns?: long(name='Conns', description='>  This parameter is in internal preview. Do not use this parameter.', example='8'),
      cps?: long(name='Cps', description='The number of new connections.', example='0'),
      inActConns?: long(name='InActConns', description='The number of inactive connections.', example='2'),
      index?: long(name='Index', description='The index number of the returned data.', example='16506'),
    }
  ](name='ConnsList', description='Details about the connections established over the port.'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='6D48AED0-41DB-5D9B-B484-3B6AAD312AD1'),
}

model DescribePortConnsListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePortConnsListResponseBody(name='body'),
}

/**
 * @summary Queries the connections established over the ports of one or more Anti-DDoS Proxy instances.
 *
 * @param request DescribePortConnsListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePortConnsListResponse
 */
async function describePortConnsListWithOptions(request: DescribePortConnsListRequest, runtime: $RuntimeOptions): DescribePortConnsListResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!$isNull(request.port)) {
    query['Port'] = request.port;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribePortConnsList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the connections established over the ports of one or more Anti-DDoS Proxy instances.
 *
 * @param request DescribePortConnsListRequest
 * @return DescribePortConnsListResponse
 */
async function describePortConnsList(request: DescribePortConnsListRequest): DescribePortConnsListResponse {
  var runtime = new $RuntimeOptions{};
  return describePortConnsListWithOptions(request, runtime);
}

model DescribePortFlowListRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

**

**This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1583683200'),
  instanceIds?: [ string ](name='InstanceIds', description='An array that consists of the IDs of instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  interval?: int32(name='Interval', description='The interval for returning data. Unit: seconds. The interval that you can specify varies based on the time range to query. The time range to query is determined by the values of **StartTime** and **EndTime**.

*   If the time range to query is no greater than 1 hour, we recommend that you specify the interval from 60 seconds to the time range to query.
*   If the time range to query is greater than 1 hour but no greater than 6 hours, we recommend that you specify the interval from 600 seconds to the time range to query.
*   If the time range to query is greater than 6 hours but no greater than 24 hours, we recommend that you specify the interval from 1,800 seconds to the time range to query.
*   If the time range to query is greater than 24 hours but no greater than 7 days, we recommend that you specify the interval from 3,600 seconds to the time range to query.
*   If the time range to query is greater than 7 days but no greater than 15 days, we recommend that you specify the interval from 14,400 seconds to the time range to query.
*   If the time range to query is greater than 15 days, we recommend that you specify the interval from 43,200 seconds to the time range to query.

This parameter is required.', example='1000'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).', example='rg-acfm2pz25js****'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

**

**This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribePortFlowListResponseBody = {
  portFlowList?: [ 
    {
      attackBps?: long(name='AttackBps', description='The bandwidth of attack traffic. Unit: bit/s.', example='0'),
      attackPps?: long(name='AttackPps', description='The packet forwarding rate of attack traffic. Unit: pps.', example='0'),
      inBps?: long(name='InBps', description='The inbound bandwidth. Unit: bit/s.', example='2176000'),
      inPps?: long(name='InPps', description='The packet forwarding rate of inbound traffic. Unit: packets per second.', example='2934'),
      index?: long(name='Index', description='The index number of the returned data.', example='0'),
      outBps?: long(name='OutBps', description='The outbound bandwidth. Unit: bit/s.', example='4389'),
      outPps?: long(name='OutPps', description='The packet forwarding rate of outbound traffic. Unit: packets per second (pps).', example='5'),
      region?: string(name='Region', description='The source region of the traffic. Valid values:

*   **cn**: mainland China
*   **alb-ap-northeast-1-gf-x**: Japan (Tokyo)
*   **alb-ap-southeast-gf-x**: Singapore
*   **alb-cn-hongkong-gf-x**: Hong Kong (China)
*   **alb-eu-central-1-gf-x**: Germany (Frankfurt)
*   **alb-us-west-1-gf-x**: US (Silicon Valley)

> The values except **cn** are returned only when **RegionId** is set to **ap-southeast-1**.', example='cn'),
      slaBpsDropBps?: long(name='SlaBpsDropBps'),
      slaBpsDropPps?: long(name='SlaBpsDropPps'),
      slaConnDropBps?: long(name='SlaConnDropBps'),
      slaConnDropPps?: long(name='SlaConnDropPps'),
      slaCpsDropBps?: long(name='SlaCpsDropBps'),
      slaCpsDropPps?: long(name='SlaCpsDropPps'),
      slaPpsDropBps?: long(name='SlaPpsDropBps'),
      slaPpsDropPps?: long(name='SlaPpsDropPps'),
      time?: long(name='Time', description='The time when the data was collected. The value is a UNIX timestamp. Unit: seconds.', example='1582992000'),
    }
  ](name='PortFlowList', description='The returned traffic data.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='FFC77501-BDF8-4BC8-9BF5-B295FBC3189B'),
}

model DescribePortFlowListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePortFlowListResponseBody(name='body'),
}

/**
 * @summary Queries the traffic data of one or more Anti-DDoS Pro or Anti-DDoS Premium instances.
 *
 * @param request DescribePortFlowListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePortFlowListResponse
 */
async function describePortFlowListWithOptions(request: DescribePortFlowListRequest, runtime: $RuntimeOptions): DescribePortFlowListResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribePortFlowList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the traffic data of one or more Anti-DDoS Pro or Anti-DDoS Premium instances.
 *
 * @param request DescribePortFlowListRequest
 * @return DescribePortFlowListResponse
 */
async function describePortFlowList(request: DescribePortFlowListRequest): DescribePortFlowListResponse {
  var runtime = new $RuntimeOptions{};
  return describePortFlowListWithOptions(request, runtime);
}

model DescribePortMaxConnsRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1583683200'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the Anti-DDoS Proxy instances.

>  You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all Anti-DDoS Proxy instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribePortMaxConnsResponseBody = {
  portMaxConns?: [ 
    {
      cps?: long(name='Cps', description='The maximum number of connections per second (CPS).', example='100'),
      ip?: string(name='Ip', description='The IP address of the instance.', example='203.***.***.117'),
      port?: string(name='Port', description='The port of the instance.', example='80'),
    }
  ](name='PortMaxConns', description='The details of the maximum number of connections that can be established over a port of the instance.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='08F79110-2AF5-4FA7-998E-7C5E75EACF9C'),
}

model DescribePortMaxConnsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePortMaxConnsResponseBody(name='body'),
}

/**
 * @summary Queries the maximum number of connections that can be established over the ports of one or more Anti-DDoS Proxy instances.
 *
 * @param request DescribePortMaxConnsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePortMaxConnsResponse
 */
async function describePortMaxConnsWithOptions(request: DescribePortMaxConnsRequest, runtime: $RuntimeOptions): DescribePortMaxConnsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribePortMaxConns',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the maximum number of connections that can be established over the ports of one or more Anti-DDoS Proxy instances.
 *
 * @param request DescribePortMaxConnsRequest
 * @return DescribePortMaxConnsResponse
 */
async function describePortMaxConns(request: DescribePortMaxConnsRequest): DescribePortMaxConnsResponse {
  var runtime = new $RuntimeOptions{};
  return describePortMaxConnsWithOptions(request, runtime);
}

model DescribePortViewSourceCountriesRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1583683200'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the Anti-DDoS Proxy instances to query.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the Anti-DDoS Proxy instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).', example='rg-acfm2pz25js****'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribePortViewSourceCountriesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  sourceCountrys?: [ 
    {
      count?: long(name='Count', description='The number of requests.', example='3390671'),
      countryId?: string(name='CountryId', description='The abbreviation of the country or area. For example, **cn** indicates China and **us** indicates the United States.

> For more information, see [Location parameters](https://help.aliyun.com/document_detail/167926.html).', example='cn'),
    }
  ](name='SourceCountrys', description='The details about the country or area from which the requests are sent.'),
}

model DescribePortViewSourceCountriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePortViewSourceCountriesResponseBody(name='body'),
}

/**
 * @summary Queries the areas and countries from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within the specified period of time.
 *
 * @param request DescribePortViewSourceCountriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePortViewSourceCountriesResponse
 */
async function describePortViewSourceCountriesWithOptions(request: DescribePortViewSourceCountriesRequest, runtime: $RuntimeOptions): DescribePortViewSourceCountriesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribePortViewSourceCountries',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the areas and countries from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within the specified period of time.
 *
 * @param request DescribePortViewSourceCountriesRequest
 * @return DescribePortViewSourceCountriesResponse
 */
async function describePortViewSourceCountries(request: DescribePortViewSourceCountriesRequest): DescribePortViewSourceCountriesResponse {
  var runtime = new $RuntimeOptions{};
  return describePortViewSourceCountriesWithOptions(request, runtime);
}

model DescribePortViewSourceIspsRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. This value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1583683200'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the Anti-DDoS Proxy instances to query.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the Anti-DDoS Proxy instance belongs in Resource Management.

If you do not specify this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. This value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribePortViewSourceIspsResponseBody = {
  isps?: [ 
    {
      count?: long(name='Count', description='The total number of requests that are sent from the ISP.

> This parameter does not indicate the accurate number of requests. You can use this parameter to calculate the proportion of requests from different ISPs.', example='3390671'),
      ispId?: string(name='IspId', description='The ID of the ISP. For more information, see the ISP codes table.', example='100017'),
    }
  ](name='Isps', description='An array that consists of the details of the ISP.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model DescribePortViewSourceIspsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePortViewSourceIspsResponseBody(name='body'),
}

/**
 * @summary Queries the Internet service providers (ISPs) from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within the specified period of time.
 *
 * @description You can call the DescribePortViewSourceIsps operation to query the ISPs from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
 * > The data returned for this operation cannot reflect the actual traffic volume because Layer 4 identity authentication algorithms are updated for Anti-DDoS Pro and Anti-DDoS Premium. You can call this operation to calculate only the proportion of requests sent from different ISPs. If you want to query the request traffic volume, we recommend that you call the [DescribePortFlowList](https://help.aliyun.com/document_detail/157460.html) operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribePortViewSourceIspsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePortViewSourceIspsResponse
 */
async function describePortViewSourceIspsWithOptions(request: DescribePortViewSourceIspsRequest, runtime: $RuntimeOptions): DescribePortViewSourceIspsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribePortViewSourceIsps',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the Internet service providers (ISPs) from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within the specified period of time.
 *
 * @description You can call the DescribePortViewSourceIsps operation to query the ISPs from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
 * > The data returned for this operation cannot reflect the actual traffic volume because Layer 4 identity authentication algorithms are updated for Anti-DDoS Pro and Anti-DDoS Premium. You can call this operation to calculate only the proportion of requests sent from different ISPs. If you want to query the request traffic volume, we recommend that you call the [DescribePortFlowList](https://help.aliyun.com/document_detail/157460.html) operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribePortViewSourceIspsRequest
 * @return DescribePortViewSourceIspsResponse
 */
async function describePortViewSourceIsps(request: DescribePortViewSourceIspsRequest): DescribePortViewSourceIspsResponse {
  var runtime = new $RuntimeOptions{};
  return describePortViewSourceIspsWithOptions(request, runtime);
}

model DescribePortViewSourceProvincesRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds. If you do not configure this parameter, the current system time is used as the end time.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.', example='1583683200'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the Anti-DDoS Proxy instances to query.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the Anti-DDoS Proxy instance belongs in Resource Management. This parameter is empty by default, which indicates that the Anti-DDoS Origin instance belongs to the default resource group.

For information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).', example='rg-acfm2pz25js****'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1582992000'),
}

model DescribePortViewSourceProvincesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  sourceProvinces?: [ 
    {
      count?: long(name='Count', description='The total number of requests that are sent from the ISP.

> This parameter does not indicate the accurate number of requests. You can use this parameter to calculate the proportion of requests from different administrative regions in China.', example='3390671'),
      provinceId?: string(name='ProvinceId', description='The ID of the administrative region in China from which the requests are sent. For example, **110000** indicates Beijing, and **120000** indicates Tianjin.

> For more information, see [Location parameters](https://help.aliyun.com/document_detail/167926.html).', example='440000'),
    }
  ](name='SourceProvinces', description='The details of the administrative region in China from which the requests are sent.'),
}

model DescribePortViewSourceProvincesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribePortViewSourceProvincesResponseBody(name='body'),
}

/**
 * @summary Queries the administrative regions in China from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specified period of time.
 *
 * @param request DescribePortViewSourceProvincesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePortViewSourceProvincesResponse
 */
async function describePortViewSourceProvincesWithOptions(request: DescribePortViewSourceProvincesRequest, runtime: $RuntimeOptions): DescribePortViewSourceProvincesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribePortViewSourceProvinces',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the administrative regions in China from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specified period of time.
 *
 * @param request DescribePortViewSourceProvincesRequest
 * @return DescribePortViewSourceProvincesResponse
 */
async function describePortViewSourceProvinces(request: DescribePortViewSourceProvincesRequest): DescribePortViewSourceProvincesResponse {
  var runtime = new $RuntimeOptions{};
  return describePortViewSourceProvincesWithOptions(request, runtime);
}

model DescribeSceneDefenseObjectsRequest {
  policyId?: string(name='PolicyId', description='The ID of the policy that you want to query.

> You can call the [DescribeSceneDefensePolicies](https://help.aliyun.com/document_detail/159382.html) operation to query the IDs of all policies.

This parameter is required.', example='47e07ebd-0ba5-4afc-957b-59d15b90****'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
}

model DescribeSceneDefenseObjectsResponseBody = {
  objects?: [ 
    {
      domain?: string(name='Domain', description='The domain name that is protected by the policy.', example='www.aliyundoc.com'),
      policyId?: string(name='PolicyId', description='The ID of the policy.', example='47e07ebd-0ba5-4afc-957b-59d15b90****'),
      vip?: string(name='Vip', description='The IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance that is protected by the policy.', example='203.XX.XX.119'),
    }
  ](name='Objects', description='The information about the protected assets.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='FE07E73F-F19E-4A51-B62F-AC59E3B962D8'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model DescribeSceneDefenseObjectsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSceneDefenseObjectsResponseBody(name='body'),
}

/**
 * @summary Queries the protected objects of a scenario-specific custom policy.
 *
 * @description You can call the DescribeSceneDefenseObjects operation to query the protected objects of a scenario-specific custom policy.
 * Before you call this operation, make sure that you have created a scenario-specific custom policy by calling the [CreateSceneDefensePolicy](https://help.aliyun.com/document_detail/159779.html) operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeSceneDefenseObjectsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSceneDefenseObjectsResponse
 */
async function describeSceneDefenseObjectsWithOptions(request: DescribeSceneDefenseObjectsRequest, runtime: $RuntimeOptions): DescribeSceneDefenseObjectsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeSceneDefenseObjects',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the protected objects of a scenario-specific custom policy.
 *
 * @description You can call the DescribeSceneDefenseObjects operation to query the protected objects of a scenario-specific custom policy.
 * Before you call this operation, make sure that you have created a scenario-specific custom policy by calling the [CreateSceneDefensePolicy](https://help.aliyun.com/document_detail/159779.html) operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeSceneDefenseObjectsRequest
 * @return DescribeSceneDefenseObjectsResponse
 */
async function describeSceneDefenseObjects(request: DescribeSceneDefenseObjectsRequest): DescribeSceneDefenseObjectsResponse {
  var runtime = new $RuntimeOptions{};
  return describeSceneDefenseObjectsWithOptions(request, runtime);
}

model DescribeSceneDefensePoliciesRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
  status?: string(name='Status', description='The status of the policy. Valid values:

*   **0**: disabled
*   **1**: pending enabling
*   **2**: enabled
*   **3**: expired', example='1'),
  template?: string(name='Template', description='The type of the template that is used to create the policy. Valid values:

*   **promotion**: the Important Activity template
*   **bypass**: the Forward All template', example='promotion'),
}

model DescribeSceneDefensePoliciesResponseBody = {
  policies?: [ 
    {
      done?: int32(name='Done', description='The execution status of the policy. Valid values:

*   **1**: not executed or execution completed
*   **0**: being executed
*   **-1**: execution failed', example='1'),
      endTime?: long(name='EndTime', description='The time at which the policy expires. The value is a UNIX timestamp. Unit: milliseconds.', example='1586016000000'),
      name?: string(name='Name', description='The name of the policy.', example='testpolicy'),
      objectCount?: int32(name='ObjectCount', description='The number of objects that are protected by the policy.', example='1'),
      policyId?: string(name='PolicyId', description='The ID of the policy.', example='321a-fd31-df51-****'),
      runtimePolicies?: [ 
        {
          newValue?: string(name='NewValue', description='The protection rule that is applied when the policy takes effect.

If you set **PolicyType** to **1**, the value is **{"cc_rule_enable": false }**. The value indicates that the Frequency Control policy is disabled.

If you set **PolicyType** to **2**, the value is **{"ai_rule_enable": 0}**. The value indicates that the Intelligent Protection policy is disabled.', example='{"cc_rule_enable": false }'),
          policyType?: int32(name='PolicyType', description='The protection policy whose status is changed when the policy takes effect. Valid values:

*   **1**: indicates that the Frequency Control policy is changed.
*   **2**: indicates that the Intelligent Protection policy is changed.', example='1'),
          status?: int32(name='Status', description='The running status of the policy. Valid values:

*   **0**: The policy has not been issued or is restored.
*   **1**: The policy is pending.
*   **2**: The policy is being restored.
*   **3**: The policy takes effect.
*   **4**: The policy fails to take effect.
*   **5**:The policy fails to be restored.
*   **6**: The configurations of the protected objects for the policy does not exist because the configurations may be deleted.', example='3'),
          oldValue?: string(name='oldValue', description='The protection rule that is applied before the policy takes effect.

If you set **PolicyType** to **1**, the value is **{"cc_rule_enable": true}**. The value indicates that the Frequency Control policy is enabled.

If you set **PolicyType** to **2**, the value is **{"ai_rule_enable": 1}**. The value indicates that the Intelligent Protection policy is enabled.', example='{"cc_rule_enable": true}'),
        }
      ](name='RuntimePolicies', description='The running rules of the policy.'),
      startTime?: long(name='StartTime', description='The time at which the policy takes effect. The value is a UNIX timestamp. Unit: milliseconds.', example='1585670400000'),
      status?: int32(name='Status', description='The status of the policy. Valid values:

*   **0**: disabled
*   **1**: pending enabling
*   **2**: enabled
*   **3**: expired', example='1'),
      template?: string(name='Template', description='The type of the template that is used to create the policy. Valid values:

*   **promotion**: the Important Activity template
*   **bypass**: the Forward All template', example='promotion'),
    }
  ](name='Policies', description='An array that consists of the configurations of the scenario-specific custom policy.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model DescribeSceneDefensePoliciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSceneDefensePoliciesResponseBody(name='body'),
}

/**
 * @summary Queries the configurations of a scenario-specific custom policy.
 *
 * @description You can call the DescribeSceneDefensePolicies operation to query the configurations of a scenario-specific custom policy that is created. For example, you can query the status, protected objects, and protection rules of the policy.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeSceneDefensePoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSceneDefensePoliciesResponse
 */
async function describeSceneDefensePoliciesWithOptions(request: DescribeSceneDefensePoliciesRequest, runtime: $RuntimeOptions): DescribeSceneDefensePoliciesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.status)) {
    query['Status'] = request.status;
  }
  if (!$isNull(request.template)) {
    query['Template'] = request.template;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeSceneDefensePolicies',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the configurations of a scenario-specific custom policy.
 *
 * @description You can call the DescribeSceneDefensePolicies operation to query the configurations of a scenario-specific custom policy that is created. For example, you can query the status, protected objects, and protection rules of the policy.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeSceneDefensePoliciesRequest
 * @return DescribeSceneDefensePoliciesResponse
 */
async function describeSceneDefensePolicies(request: DescribeSceneDefensePoliciesRequest): DescribeSceneDefensePoliciesResponse {
  var runtime = new $RuntimeOptions{};
  return describeSceneDefensePoliciesWithOptions(request, runtime);
}

model DescribeSchedulerRulesRequest {
  pageNumber?: int32(name='PageNumber', example='1'),
  pageSize?: int32(name='PageSize', description='This parameter is required.', example='10'),
  resourceGroupId?: string(name='ResourceGroupId', example='default'),
  ruleName?: string(name='RuleName', example='testrule'),
}

model DescribeSchedulerRulesResponseBody = {
  requestId?: string(name='RequestId', example='11C55595-1757-4B17-9ACE-4ACB68C2D989'),
  schedulerRules?: [ 
    {
      cname?: string(name='Cname', example='4eru5229a843****.aliyunddos0001.com'),
      param?: {
        paramData?: {
          cloudInstanceId?: string(name='CloudInstanceId', example='ga-bp1htlajy5509rc99****'),
        }(name='ParamData'),
        paramType?: string(name='ParamType', example='GA'),
      }(name='Param'),
      ruleName?: string(name='RuleName', example='doctest'),
      ruleType?: string(name='RuleType'),
      rules?: [ 
        {
          line?: string(name='Line'),
          priority?: int32(name='Priority', example='100'),
          regionId?: string(name='RegionId', example='1'),
          restoreDelay?: int32(name='RestoreDelay', example='60'),
          status?: int32(name='Status', example='0'),
          type?: string(name='Type', example='A'),
          value?: string(name='Value', example='203.***.***.39'),
          valueType?: int32(name='ValueType', example='1'),
        }
      ](name='Rules'),
    }
  ](name='SchedulerRules'),
  totalCount?: string(name='TotalCount', example='1'),
}

model DescribeSchedulerRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSchedulerRulesResponseBody(name='body'),
}

/**
 * @param request DescribeSchedulerRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSchedulerRulesResponse
 */
async function describeSchedulerRulesWithOptions(request: DescribeSchedulerRulesRequest, runtime: $RuntimeOptions): DescribeSchedulerRulesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeSchedulerRules',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request DescribeSchedulerRulesRequest
 * @return DescribeSchedulerRulesResponse
 */
async function describeSchedulerRules(request: DescribeSchedulerRulesRequest): DescribeSchedulerRulesResponse {
  var runtime = new $RuntimeOptions{};
  return describeSchedulerRulesWithOptions(request, runtime);
}

model DescribeSlaEventListRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='3289457398'),
  ip?: string(name='Ip', description='The IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance.', example='203.107.XX.XX'),
  page?: long(name='Page', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='10'),
  region?: string(name='Region', description='The type of the service Valid values:

*   **cn**: Anti-DDoS Pro
*   **cn-hongkong**: Anti-DDoS Premium

This parameter is required.', example='cn'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='3289457398'),
}

model DescribeSlaEventListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
  slaEvent?: [ 
    {
      endTime?: long(name='EndTime', description='The end of the time range. Unit: seconds.', example='1671886740'),
      ip?: string(name='Ip', description='The IP address of the instance.', example='203.107.XX.XX'),
      region?: string(name='Region', description='The region to which the destination IP address belongs. Valid values:

*   **cn**: a region in the Chinese mainland
*   **cn-hongkong**: China (Hong Kong)', example='cn'),
      startTime?: long(name='StartTime', description='The beginning of the time range. Unit: seconds.', example='1678080840'),
    }
  ](name='SlaEvent', description='The destination rate limit events.'),
  total?: long(name='Total', description='The total number of entries returned.', example='10'),
}

model DescribeSlaEventListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSlaEventListResponseBody(name='body'),
}

/**
 * @summary Queries the destination rate limit events.
 *
 * @param request DescribeSlaEventListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSlaEventListResponse
 */
async function describeSlaEventListWithOptions(request: DescribeSlaEventListRequest, runtime: $RuntimeOptions): DescribeSlaEventListResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!$isNull(request.page)) {
    query['Page'] = request.page;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.region)) {
    query['Region'] = request.region;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeSlaEventList',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the destination rate limit events.
 *
 * @param request DescribeSlaEventListRequest
 * @return DescribeSlaEventListResponse
 */
async function describeSlaEventList(request: DescribeSlaEventListRequest): DescribeSlaEventListResponse {
  var runtime = new $RuntimeOptions{};
  return describeSlaEventListWithOptions(request, runtime);
}

model DescribeSlsAuthStatusRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DescribeSlsAuthStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
  slsAuthStatus?: boolean(name='SlsAuthStatus', description='Indicates whether Anti-DDoS Pro or Anti-DDoS Premium is authorized to access Log Service. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model DescribeSlsAuthStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSlsAuthStatusResponseBody(name='body'),
}

/**
 * @summary Queries whether Anti-DDoS Proxy is authorized to access Simple Log Service.
 *
 * @param request DescribeSlsAuthStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSlsAuthStatusResponse
 */
async function describeSlsAuthStatusWithOptions(request: DescribeSlsAuthStatusRequest, runtime: $RuntimeOptions): DescribeSlsAuthStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeSlsAuthStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries whether Anti-DDoS Proxy is authorized to access Simple Log Service.
 *
 * @param request DescribeSlsAuthStatusRequest
 * @return DescribeSlsAuthStatusResponse
 */
async function describeSlsAuthStatus(request: DescribeSlsAuthStatusRequest): DescribeSlsAuthStatusResponse {
  var runtime = new $RuntimeOptions{};
  return describeSlsAuthStatusWithOptions(request, runtime);
}

model DescribeSlsLogstoreInfoRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DescribeSlsLogstoreInfoResponseBody = {
  logStore?: string(name='LogStore', description='The Logstore of the Anti-DDoS Pro or Anti-DDoS Premium instance.', example='ddoscoo-logstore'),
  project?: string(name='Project', description='The Logstore project of the Anti-DDoS Pro or Anti-DDoS Premium instance.', example='ddoscoo-project-181071506993****-cn-hangzhou'),
  quota?: long(name='Quota', description='The available log storage capacity. Unit: bytes.', example='3298534883328'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
  ttl?: int32(name='Ttl', description='The log storage duration. Unit: days.', example='180'),
  used?: long(name='Used', description='The used log storage capacity. Unit: bytes.

> The statistics on Log Service are delayed for about two hours.', example='0'),
}

model DescribeSlsLogstoreInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSlsLogstoreInfoResponseBody(name='body'),
}

/**
 * @summary Queries information about the Logstore of the Anti-DDoS Proxy instance, such as the log storage capacity and log storage duration.
 *
 * @param request DescribeSlsLogstoreInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSlsLogstoreInfoResponse
 */
async function describeSlsLogstoreInfoWithOptions(request: DescribeSlsLogstoreInfoRequest, runtime: $RuntimeOptions): DescribeSlsLogstoreInfoResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeSlsLogstoreInfo',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries information about the Logstore of the Anti-DDoS Proxy instance, such as the log storage capacity and log storage duration.
 *
 * @param request DescribeSlsLogstoreInfoRequest
 * @return DescribeSlsLogstoreInfoResponse
 */
async function describeSlsLogstoreInfo(request: DescribeSlsLogstoreInfoRequest): DescribeSlsLogstoreInfoResponse {
  var runtime = new $RuntimeOptions{};
  return describeSlsLogstoreInfoWithOptions(request, runtime);
}

model DescribeSlsOpenStatusRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DescribeSlsOpenStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
  slsOpenStatus?: boolean(name='SlsOpenStatus', description='Indicates whether Log Service is activated. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model DescribeSlsOpenStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSlsOpenStatusResponseBody(name='body'),
}

/**
 * @summary Checks whether Simple Log Service is activated.
 *
 * @param request DescribeSlsOpenStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSlsOpenStatusResponse
 */
async function describeSlsOpenStatusWithOptions(request: DescribeSlsOpenStatusRequest, runtime: $RuntimeOptions): DescribeSlsOpenStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeSlsOpenStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Checks whether Simple Log Service is activated.
 *
 * @param request DescribeSlsOpenStatusRequest
 * @return DescribeSlsOpenStatusResponse
 */
async function describeSlsOpenStatus(request: DescribeSlsOpenStatusRequest): DescribeSlsOpenStatusResponse {
  var runtime = new $RuntimeOptions{};
  return describeSlsOpenStatusWithOptions(request, runtime);
}

model DescribeStsGrantStatusRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
  role?: string(name='Role', description='The name of the RAM role to query. Set the value to **AliyunDDoSCOODefaultRole**, which indicates the default role of Anti-DDoS Pro or Anti-DDoS Premium.

> Anti-DDoS Pro or Anti-DDoS Premium uses the default role to access other cloud services.

This parameter is required.', example='AliyunDDoSCOODefaultRole'),
}

model DescribeStsGrantStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
  stsGrant?: {
    status?: int32(name='Status', description='The authorization status. Valid values:

*   **0**: Anti-DDoS Pro or Anti-DDoS Premium is not authorized to access other cloud services.
*   **1**: Anti-DDoS Pro or Anti-DDoS Premium is authorized to access other cloud services.', example='1'),
  }(name='StsGrant', description='The authorization status of Anti-DDoS Pro or Anti-DDoS Premium.'),
}

model DescribeStsGrantStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeStsGrantStatusResponseBody(name='body'),
}

/**
 * @summary Queries whether Anti-DDoS Pro or Anti-DDoS Premium is authorized to access other cloud services.
 *
 * @description You can call the DescribeStsGrantStatus operation to query whether Anti-DDoS Pro or Anti-DDoS Premium of the current Alibaba Cloud account is authorized to access other cloud services.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeStsGrantStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeStsGrantStatusResponse
 */
async function describeStsGrantStatusWithOptions(request: DescribeStsGrantStatusRequest, runtime: $RuntimeOptions): DescribeStsGrantStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.role)) {
    query['Role'] = request.role;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeStsGrantStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries whether Anti-DDoS Pro or Anti-DDoS Premium is authorized to access other cloud services.
 *
 * @description You can call the DescribeStsGrantStatus operation to query whether Anti-DDoS Pro or Anti-DDoS Premium of the current Alibaba Cloud account is authorized to access other cloud services.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeStsGrantStatusRequest
 * @return DescribeStsGrantStatusResponse
 */
async function describeStsGrantStatus(request: DescribeStsGrantStatusRequest): DescribeStsGrantStatusResponse {
  var runtime = new $RuntimeOptions{};
  return describeStsGrantStatusWithOptions(request, runtime);
}

model DescribeSystemLogRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The bills of the burstable clean bandwidth that are issued before this point in time are queried. The value is a UNIX timestamp. Unit: milliseconds.

This parameter is required.', example='1640966400000'),
  entityObject?: string(name='EntityObject', description='The IP address of the instance.

> You can call the [DescribeInstanceDetails](https://help.aliyun.com/document_detail/91490.html) operation to query the IP addresses of all instances.', example='203.107.XX.XX'),
  entityType?: int32(name='EntityType', description='The type of the system log. Set the value to **20**, which indicates the billing logs for the burstable clean bandwidth.

> You must specify this parameter. Otherwise, the call fails.', example='20'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

This parameter is required.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='10'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The bills of the burstable clean bandwidth that are issued after this point in time are queried. The value is a UNIX timestamp. Unit: milliseconds.

This parameter is required.', example='1609430400000'),
}

model DescribeSystemLogResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='8BC3A33A-F832-58DB-952F-7682A25AD14C'),
  systemLog?: [ 
    {
      entityObject?: string(name='EntityObject', description='The IP address of the instance.', example='203.107.XX.XX'),
      entityType?: int32(name='EntityType', description='The type of the system log. The value is fixed as **20**, which indicates the billing logs for burstable clean bandwidth.', example='20'),
      gmtCreate?: long(name='GmtCreate', description='The time when the bill was generated. The value is a UNIX timestamp. Unit: milliseconds.', example='1631793531000'),
      gmtModified?: long(name='GmtModified', description='The time when the bill was last modified. The value is a UNIX timestamp. Unit: milliseconds.', example='1635425407000'),
      opAccount?: string(name='OpAccount', description='The ID of the Alibaba Cloud account to which the bill belongs.', example='171986973287****'),
      opAction?: int32(name='OpAction', description='The operation type. The value is fixed as **100**, which indicates the billing logs for the burstable clean bandwidth that you increased.', example='100'),
      opDesc?: string(name='OpDesc', description='The details of the bill. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:

*   **newEntity**: the bill record, which contains the following fields. Data type: object.

    *   **billValue**: the usage of the burstable clean bandwidth within a month. Unit: Mbit/s. Data type: integer.
    *   **instanceId**: the ID of the instance. Data type: string.
    *   **ip**: the IP address of the instance. Data type: string.
    *   **maxBw**: the peak service traffic (monthly 95th percentile bandwidth) within a month. Unit: Mbit/s. Data type: string.
    *   **month**: the month in which the bill of the previous calendar month is issued. This value is a UNIX timestamp. Unit: milliseconds. Data type: long.
    *   **overBandwidth**: the peak service traffic minus the clean bandwidth of the instance. Unit: Mbit/s. Data type: integer.
    *   **peakTime**: the time in point of the peak service traffic that is measured for billing. This value is a UNIX timestamp. Unit: seconds. Data type: long.
    *   **startTimestamp**: the beginning of the time range for the peak service traffic range. This value is a UNIX timestamp. Unit: seconds. Data type: long.', example='{"newEntity":{"billValue":"60","instanceId":"ddoscoo-cn-zz121ogz****","ip":"203.107.XX.XX","maxBw":"300","month":1627747200000,"overBandwidth":"120","peakTime":1629871200,"startTimestamp":1629871200}}'),
      status?: int32(name='Status', description='The status of the bill. Valid values:

*   **0**: to be billed
*   **1**: billed
*   **2**: terminated', example='1'),
    }
  ](name='SystemLog', description='An array that consists of details of the billing logs for the burstable clean bandwidth.'),
  total?: long(name='Total', description='The total number of billing logs for the burstable clean bandwidth.', example='1'),
}

model DescribeSystemLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSystemLogResponseBody(name='body'),
}

/**
 * @summary Queries the details of the bills for the burstable clean bandwidth.
 *
 * @description You can call the DescribeSystemLog operation to query the system logs of Anti-DDoS Pro or Anti-DDoS Premium. The system logs contain only billing logs for the burstable clean bandwidth.
 * If you have enabled the burstable clean bandwidth feature, you can call this operation to query the details of the bills of the burstable clean bandwidth.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeSystemLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSystemLogResponse
 */
async function describeSystemLogWithOptions(request: DescribeSystemLogRequest, runtime: $RuntimeOptions): DescribeSystemLogResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.entityObject)) {
    query['EntityObject'] = request.entityObject;
  }
  if (!$isNull(request.entityType)) {
    query['EntityType'] = request.entityType;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeSystemLog',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the details of the bills for the burstable clean bandwidth.
 *
 * @description You can call the DescribeSystemLog operation to query the system logs of Anti-DDoS Pro or Anti-DDoS Premium. The system logs contain only billing logs for the burstable clean bandwidth.
 * If you have enabled the burstable clean bandwidth feature, you can call this operation to query the details of the bills of the burstable clean bandwidth.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeSystemLogRequest
 * @return DescribeSystemLogResponse
 */
async function describeSystemLog(request: DescribeSystemLogRequest): DescribeSystemLogResponse {
  var runtime = new $RuntimeOptions{};
  return describeSystemLogWithOptions(request, runtime);
}

model DescribeTagKeysRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**.', example='10'),
  regionId?: string(name='RegionId', description='The region ID of the instance. Set the value to **cn-hangzhou**, which indicates an Anti-DDoS Proxy (Chinese Mainland) instance.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
  resourceType?: string(name='ResourceType', description='The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.

This parameter is required.', example='INSTANCE'),
}

model DescribeTagKeysResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned on each page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
  tagKeys?: [ 
    {
      tagCount?: int32(name='TagCount', description='The number of Anti-DDoS Proxy (Chinese Mainland) instances to which the tag key is added.', example='2'),
      tagKey?: string(name='TagKey', description='The tag key.', example='aa1'),
    }
  ](name='TagKeys', description='The details about the tag keys.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeTagKeysResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTagKeysResponseBody(name='body'),
}

/**
 * @summary Queries all tag keys and the number of Anti-DDoS Proxy (Chinese Mainland) instances to which each tag key is added.
 *
 * @description You can call this operation to query all tag keys and the number of Anti-DDoS Proxy (Chinese Mainland) instances to which each tag key is added by page.
 * >  Only Anti-DDoS Proxy (Chinese Mainland) supports tags.
 * ### [](#qps-)QPS limits
 * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeTagKeysRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTagKeysResponse
 */
async function describeTagKeysWithOptions(request: DescribeTagKeysRequest, runtime: $RuntimeOptions): DescribeTagKeysResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeTagKeys',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries all tag keys and the number of Anti-DDoS Proxy (Chinese Mainland) instances to which each tag key is added.
 *
 * @description You can call this operation to query all tag keys and the number of Anti-DDoS Proxy (Chinese Mainland) instances to which each tag key is added by page.
 * >  Only Anti-DDoS Proxy (Chinese Mainland) supports tags.
 * ### [](#qps-)QPS limits
 * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeTagKeysRequest
 * @return DescribeTagKeysResponse
 */
async function describeTagKeys(request: DescribeTagKeysRequest): DescribeTagKeysResponse {
  var runtime = new $RuntimeOptions{};
  return describeTagKeysWithOptions(request, runtime);
}

model DescribeTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The query token. Set the value to the value of **NextToken** that is returned in the last call.

> You do not need to configure this parameter if you call this operation for the first time.', example='RGuYpqDdKhzXb8C3.D1BwQgc1tMBsoxdGiEKHHUUCf****'),
  regionId?: string(name='RegionId', description='The region ID of the instance. Set the value to **cn-hangzhou**, which indicates an Anti-DDoS Proxy (Chinese Mainland) instance.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
  resourceIds?: [ string ](name='ResourceIds', description='The IDs of the Anti-DDoS Proxy (Chinese Mainland) instances that you want to query.', example='ddoscoo-cn-mp91j1ao****'),
  resourceType?: string(name='ResourceType', description='The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.

This parameter is required.', example='INSTANCE'),
  tags?: [ 
    {
      key?: string(name='Key', description='The key of the tag that you want to query.

> 

*   You must specify at least one of the **ResourceIds.N** and **Tags.N.Key** parameters.

*   You can call the [DescribeTagKeys](https://help.aliyun.com/document_detail/159785.html) operation to query all tag keys.', example='testkey'),
      value?: string(name='Value', description='The value of the tag that you want to query.', example='testvalue'),
    }
  ](name='Tags', description='An array consisting of tags that you want to query. Each tag consists of a tag **key** and a tag **value**.'),
}

model DescribeTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='The query token that is returned in this call.', example='RGuYpqDdKhzXb8C3.D1BwQgc1tMBsoxdGiEKHHUUCf****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='36E698F7-48A4-48D0-9554-0BB4BAAB99B3'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId', description='The ID of the Anti-DDoS Proxy (Chinese Mainland) instance.', example='ddoscoo-cn-zz121ogz****'),
      resourceType?: string(name='ResourceType', description='The resource type. The value is fixed as **INSTANCE**, which indicates an Anti-DDoS Proxy instance.', example='INSTANCE'),
      tagKey?: string(name='TagKey', description='The key of the tag that is added to the Anti-DDoS Proxy (Chinese Mainland) instance.', example='testvalue'),
      tagValue?: string(name='TagValue', description='The value of the tag that is added to the Anti-DDoS Proxy (Chinese Mainland) instance.', example='testkey'),
    }
  ](name='TagResource')
  }(name='TagResources', description='The tags that are added to the Anti-DDoS Proxy (Chinese Mainland) instance.'),
}

model DescribeTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTagResourcesResponseBody(name='body'),
}

/**
 * @summary Queries the information about the tags that are added to an Anti-DDoS Proxy (Chinese Mainland) instance.
 *
 * @description You can call the DescribeTagResources operation to query the information about the tags that are added to an Anti-DDoS Proxy (Chinese Mainland) instance.
 * >  Only Anti-DDoS Proxy (Chinese Mainland) supports tags.
 * ### [](#qps-)QPS limits
 * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTagResourcesResponse
 */
async function describeTagResourcesWithOptions(request: DescribeTagResourcesRequest, runtime: $RuntimeOptions): DescribeTagResourcesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeTagResources',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the tags that are added to an Anti-DDoS Proxy (Chinese Mainland) instance.
 *
 * @description You can call the DescribeTagResources operation to query the information about the tags that are added to an Anti-DDoS Proxy (Chinese Mainland) instance.
 * >  Only Anti-DDoS Proxy (Chinese Mainland) supports tags.
 * ### [](#qps-)QPS limits
 * You can call this operation up to 10 times per second per account. If the number of calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeTagResourcesRequest
 * @return DescribeTagResourcesResponse
 */
async function describeTagResources(request: DescribeTagResourcesRequest): DescribeTagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return describeTagResourcesWithOptions(request, runtime);
}

model DescribeTotalAttackMaxFlowRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1659697200'),
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the Anti-DDoS Proxy instances. Separate multiple instance IDs with commas (,). Example: InstanceIds.1, InstanceIds.2, InstanceIds.3.

This parameter is required.'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. If you do not configure this parameter, the instance belongs to the default resource group.', example='default'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

> This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1669240800'),
}

model DescribeTotalAttackMaxFlowResponseBody = {
  bps?: long(name='Bps', description='The peak bandwidth of attack traffic. Unit: bit/s.', example='0'),
  pps?: long(name='Pps', description='The peak packet rate of attack traffic. Unit: packets per second (pps).', example='0'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='9173A3CB-C40B-559B-96B7-2373830BD06A'),
}

model DescribeTotalAttackMaxFlowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTotalAttackMaxFlowResponseBody(name='body'),
}

/**
 * @summary Queries the peak bandwidth and peak packet rates of attack traffic on one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
 *
 * @param request DescribeTotalAttackMaxFlowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTotalAttackMaxFlowResponse
 */
async function describeTotalAttackMaxFlowWithOptions(request: DescribeTotalAttackMaxFlowRequest, runtime: $RuntimeOptions): DescribeTotalAttackMaxFlowResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeTotalAttackMaxFlow',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the peak bandwidth and peak packet rates of attack traffic on one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
 *
 * @param request DescribeTotalAttackMaxFlowRequest
 * @return DescribeTotalAttackMaxFlowResponse
 */
async function describeTotalAttackMaxFlow(request: DescribeTotalAttackMaxFlowRequest): DescribeTotalAttackMaxFlowResponse {
  var runtime = new $RuntimeOptions{};
  return describeTotalAttackMaxFlowWithOptions(request, runtime);
}

model DescribeUdpReflectRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance to query.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-i7m25564****'),
  regionId?: string(name='RegionId', description='The region ID of the instance. Valid values:

*   **cn-hangzhou**: indicates an Anti-DDoS Proxy (Chinese Mainland) instance. This is the default value.
*   **ap-southeast-1**: indicates an Anti-DDoS Proxy (Outside Chinese Mainland) instance.', example='cn-hangzhou'),
}

model DescribeUdpReflectResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F97A8766-FB4D-411A-9CD5-2CFF701B592F'),
  udpSports?: [ string ](name='UdpSports', description='An array consisting of the source ports of the UDP traffic that are filtered out by the filtering policies for UDP reflection attacks.'),
}

model DescribeUdpReflectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUdpReflectResponseBody(name='body'),
}

/**
 * @summary Queries the source ports of UDP traffic that are filtered out by the filtering policies for UDP reflection attacks on an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request DescribeUdpReflectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUdpReflectResponse
 */
async function describeUdpReflectWithOptions(request: DescribeUdpReflectRequest, runtime: $RuntimeOptions): DescribeUdpReflectResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeUdpReflect',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the source ports of UDP traffic that are filtered out by the filtering policies for UDP reflection attacks on an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request DescribeUdpReflectRequest
 * @return DescribeUdpReflectResponse
 */
async function describeUdpReflect(request: DescribeUdpReflectRequest): DescribeUdpReflectResponse {
  var runtime = new $RuntimeOptions{};
  return describeUdpReflectWithOptions(request, runtime);
}

model DescribeUnBlackholeCountRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DescribeUnBlackholeCountResponseBody = {
  remainCount?: int32(name='RemainCount', description='The remaining quota that you can deactivate blackhole filtering.', example='5'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='232929FA-40B6-4C53-9476-EE335ABA44CD'),
  totalCount?: int32(name='TotalCount', description='The total quota that you can deactivate blackhole filtering.', example='5'),
}

model DescribeUnBlackholeCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUnBlackholeCountResponseBody(name='body'),
}

/**
 * @summary Queries the total quota and remaining quota for blackhole filtering deactivation.
 *
 * @param request DescribeUnBlackholeCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUnBlackholeCountResponse
 */
async function describeUnBlackholeCountWithOptions(request: DescribeUnBlackholeCountRequest, runtime: $RuntimeOptions): DescribeUnBlackholeCountResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeUnBlackholeCount',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the total quota and remaining quota for blackhole filtering deactivation.
 *
 * @param request DescribeUnBlackholeCountRequest
 * @return DescribeUnBlackholeCountResponse
 */
async function describeUnBlackholeCount(request: DescribeUnBlackholeCountRequest): DescribeUnBlackholeCountResponse {
  var runtime = new $RuntimeOptions{};
  return describeUnBlackholeCountWithOptions(request, runtime);
}

model DescribeUnBlockCountRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DescribeUnBlockCountResponseBody = {
  remainCount?: int32(name='RemainCount', description='The remaining number of times that you can enable the near-origin traffic diversion feature.', example='7'),
  requestId?: string(name='RequestId', description='The request ID.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
  totalCount?: int32(name='TotalCount', description='The total number of times that you can enable the near-origin traffic diversion feature.', example='10'),
}

model DescribeUnBlockCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUnBlockCountResponseBody(name='body'),
}

/**
 * @summary Queries the total number and the remaining number of times that you can enable the near-origin traffic diversion feature.
 *
 * @description >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
 *
 * @param request DescribeUnBlockCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUnBlockCountResponse
 */
async function describeUnBlockCountWithOptions(request: DescribeUnBlockCountRequest, runtime: $RuntimeOptions): DescribeUnBlockCountResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeUnBlockCount',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the total number and the remaining number of times that you can enable the near-origin traffic diversion feature.
 *
 * @description >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
 *
 * @param request DescribeUnBlockCountRequest
 * @return DescribeUnBlockCountResponse
 */
async function describeUnBlockCount(request: DescribeUnBlockCountRequest): DescribeUnBlockCountResponse {
  var runtime = new $RuntimeOptions{};
  return describeUnBlockCountWithOptions(request, runtime);
}

model DescribeWebAccessLogDispatchStatusRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **10**.', example='10'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
}

model DescribeWebAccessLogDispatchStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
  slsConfigStatus?: [ 
    {
      domain?: string(name='Domain', description='The domain name.', example='www.aliyundoc.com'),
      enable?: boolean(name='Enable', description='Indicates whether the log analysis feature is enabled. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
    }
  ](name='SlsConfigStatus', description='Indicates whether the log analysis feature is enabled for domain names.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeWebAccessLogDispatchStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebAccessLogDispatchStatusResponseBody(name='body'),
}

/**
 * @summary Checks whether the log analysis feature is enabled for all domain names.
 *
 * @description You can call the DescribeWebAccessLogDispatchStatus operation to check whether the log analysis feature is enabled for all domain names that are added to your Anti-DDoS Pro or Anti-DDoS Premium instance.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeWebAccessLogDispatchStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebAccessLogDispatchStatusResponse
 */
async function describeWebAccessLogDispatchStatusWithOptions(request: DescribeWebAccessLogDispatchStatusRequest, runtime: $RuntimeOptions): DescribeWebAccessLogDispatchStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeWebAccessLogDispatchStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Checks whether the log analysis feature is enabled for all domain names.
 *
 * @description You can call the DescribeWebAccessLogDispatchStatus operation to check whether the log analysis feature is enabled for all domain names that are added to your Anti-DDoS Pro or Anti-DDoS Premium instance.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeWebAccessLogDispatchStatusRequest
 * @return DescribeWebAccessLogDispatchStatusResponse
 */
async function describeWebAccessLogDispatchStatus(request: DescribeWebAccessLogDispatchStatusRequest): DescribeWebAccessLogDispatchStatusResponse {
  var runtime = new $RuntimeOptions{};
  return describeWebAccessLogDispatchStatusWithOptions(request, runtime);
}

model DescribeWebAccessLogEmptyCountRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DescribeWebAccessLogEmptyCountResponseBody = {
  availableCount?: int32(name='AvailableCount', description='The remaining quota that you can clear the Logstore.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model DescribeWebAccessLogEmptyCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebAccessLogEmptyCountResponseBody(name='body'),
}

/**
 * @summary Queries the remaining quota that allows you to clear the Logstore.
 *
 * @param request DescribeWebAccessLogEmptyCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebAccessLogEmptyCountResponse
 */
async function describeWebAccessLogEmptyCountWithOptions(request: DescribeWebAccessLogEmptyCountRequest, runtime: $RuntimeOptions): DescribeWebAccessLogEmptyCountResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeWebAccessLogEmptyCount',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the remaining quota that allows you to clear the Logstore.
 *
 * @param request DescribeWebAccessLogEmptyCountRequest
 * @return DescribeWebAccessLogEmptyCountResponse
 */
async function describeWebAccessLogEmptyCount(request: DescribeWebAccessLogEmptyCountRequest): DescribeWebAccessLogEmptyCountResponse {
  var runtime = new $RuntimeOptions{};
  return describeWebAccessLogEmptyCountWithOptions(request, runtime);
}

model DescribeWebAccessLogStatusRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DescribeWebAccessLogStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
  slsLogstore?: string(name='SlsLogstore', description='The Logstore of the instance.', example='ddoscoo-logstore'),
  slsProject?: string(name='SlsProject', description='The Log Service project of the instance.', example='ddoscoo-project-128965410602****-cn-hangzhou'),
  slsStatus?: boolean(name='SlsStatus', description='Indicates whether the Log Analysis feature is enabled for the website. Valid values:

*   **true**: enabled
*   **false**: disabled', example='true'),
}

model DescribeWebAccessLogStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebAccessLogStatusResponseBody(name='body'),
}

/**
 * @summary Queries the information about the log analysis feature for a website, such as the feature status and the Simple Log Service project and Logstore that are used.
 *
 * @param request DescribeWebAccessLogStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebAccessLogStatusResponse
 */
async function describeWebAccessLogStatusWithOptions(request: DescribeWebAccessLogStatusRequest, runtime: $RuntimeOptions): DescribeWebAccessLogStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeWebAccessLogStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about the log analysis feature for a website, such as the feature status and the Simple Log Service project and Logstore that are used.
 *
 * @param request DescribeWebAccessLogStatusRequest
 * @return DescribeWebAccessLogStatusResponse
 */
async function describeWebAccessLogStatus(request: DescribeWebAccessLogStatusRequest): DescribeWebAccessLogStatusResponse {
  var runtime = new $RuntimeOptions{};
  return describeWebAccessLogStatusWithOptions(request, runtime);
}

model DescribeWebAccessModeRequest {
  domains?: [ string ](name='Domains', description='The domain name of the website.

> A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
}

model DescribeWebAccessModeResponseBody = {
  domainModes?: [ 
    {
      accessMode?: int32(name='AccessMode', description='The mode in which the website service is added. Valid values:

*   **0**: A record
*   **1**: anti-DDoS mode
*   **2**: origin redundancy mode', example='0'),
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
    }
  ](name='DomainModes', description='An array consisting of the modes in which the website service is added.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DescribeWebAccessModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebAccessModeResponseBody(name='body'),
}

/**
 * @summary Queries the mode in which a website service is added to Anti-DDoS Pro or Anti-DDoS Premium.
 *
 * @param request DescribeWebAccessModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebAccessModeResponse
 */
async function describeWebAccessModeWithOptions(request: DescribeWebAccessModeRequest, runtime: $RuntimeOptions): DescribeWebAccessModeResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domains)) {
    query['Domains'] = request.domains;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeWebAccessMode',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the mode in which a website service is added to Anti-DDoS Pro or Anti-DDoS Premium.
 *
 * @param request DescribeWebAccessModeRequest
 * @return DescribeWebAccessModeResponse
 */
async function describeWebAccessMode(request: DescribeWebAccessModeRequest): DescribeWebAccessModeResponse {
  var runtime = new $RuntimeOptions{};
  return describeWebAccessModeWithOptions(request, runtime);
}

model DescribeWebAreaBlockConfigsRequest {
  domains?: [ string ](name='Domains', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DescribeWebAreaBlockConfigsResponseBody = {
  areaBlockConfigs?: [ 
    {
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
      regionList?: [ 
        {
          block?: int32(name='Block', description='Indicates whether the location is blocked. Valid values:

*   **0**: yes
*   **1**: no', example='0'),
          region?: string(name='Region', description='The name of the location.', example='CN-SHANGHAI'),
        }
      ](name='RegionList', description='The configuration of the blocked locations.'),
    }
  ](name='AreaBlockConfigs', description='An array that consists of the configurations of the Location Blacklist (Domain Names) policy.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DescribeWebAreaBlockConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebAreaBlockConfigsResponseBody(name='body'),
}

/**
 * @summary Queries the Location Blacklist (Domain Names) configurations for websites.
 *
 * @param request DescribeWebAreaBlockConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebAreaBlockConfigsResponse
 */
async function describeWebAreaBlockConfigsWithOptions(request: DescribeWebAreaBlockConfigsRequest, runtime: $RuntimeOptions): DescribeWebAreaBlockConfigsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domains)) {
    query['Domains'] = request.domains;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeWebAreaBlockConfigs',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the Location Blacklist (Domain Names) configurations for websites.
 *
 * @param request DescribeWebAreaBlockConfigsRequest
 * @return DescribeWebAreaBlockConfigsResponse
 */
async function describeWebAreaBlockConfigs(request: DescribeWebAreaBlockConfigsRequest): DescribeWebAreaBlockConfigsResponse {
  var runtime = new $RuntimeOptions{};
  return describeWebAreaBlockConfigsWithOptions(request, runtime);
}

model DescribeWebCCRulesRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries to return on each page.

This parameter is required.', example='10'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DescribeWebCCRulesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='EAED912D-909E-45F0-AF74-AC0CCDCAE314'),
  totalCount?: long(name='TotalCount', description='The total number of custom frequency control rules.', example='1'),
  webCCRules?: [ 
    {
      act?: string(name='Act', description='The action triggered if the rule is matched. Valid values:

*   **close**: The requests that match the rule are blocked.
*   **captcha**: Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) verification for the requests that match the rule is implemented.', example='close'),
      count?: int32(name='Count', description='The number of requests that are allowed from a single IP address. Valid values: **2** to **2000**.', example='3'),
      interval?: int32(name='Interval', description='The check interval. Valid values: **5** to **10800**. Unit: seconds.', example='5'),
      mode?: string(name='Mode', description='The match mode. Valid values:

*   **prefix**: prefix match.
*   **match**: exact match.', example='prefix'),
      name?: string(name='Name', description='The name of the rule.', example='wq'),
      ttl?: int32(name='Ttl', description='The validity period. Valid values: **1** to **1440**. Unit: minutes.', example='60'),
      uri?: string(name='Uri', description='The check path.', example='/hello'),
    }
  ](name='WebCCRules', description='The custom frequency control rule.'),
}

model DescribeWebCCRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebCCRulesResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DescribeWebCCRules is deprecated, please use ddoscoo::2020-01-01::ConfigWebCCRuleV2 instead.
 *
 * @summary Queries the custom frequency control rules that are created for a website.
 *
 * @param request DescribeWebCCRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebCCRulesResponse
 */
// Deprecated
async function describeWebCCRulesWithOptions(request: DescribeWebCCRulesRequest, runtime: $RuntimeOptions): DescribeWebCCRulesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeWebCCRules',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI DescribeWebCCRules is deprecated, please use ddoscoo::2020-01-01::ConfigWebCCRuleV2 instead.
 *
 * @summary Queries the custom frequency control rules that are created for a website.
 *
 * @param request DescribeWebCCRulesRequest
 * @return DescribeWebCCRulesResponse
 */
// Deprecated
async function describeWebCCRules(request: DescribeWebCCRulesRequest): DescribeWebCCRulesResponse {
  var runtime = new $RuntimeOptions{};
  return describeWebCCRulesWithOptions(request, runtime);
}

model DescribeWebCCRulesV2Request {
  domain?: string(name='Domain', description='The domain name of the website that you want to add to the Anti-DDoS Proxy instance for protection.', example='example.com'),
  offset?: string(name='Offset', description='The number of entries that you want the system to skip before the system returns entries. Default value: **0**.', example='0'),
  owner?: string(name='Owner', description='The method used to create the rule. Valid values:

*   **manual** (default): manually created.
*   **clover**: automatically created.', example='manual'),
  pageSize?: string(name='PageSize', description='The number of entries per page. Maximum value: **20**. Default value: **20**.', example='20'),
}

model DescribeWebCCRulesV2ResponseBody = {
  domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
  requestId?: string(name='RequestId', description='The request ID.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
  totalCount?: string(name='TotalCount', description='The total number of returned custom frequency control rules.', example='12'),
  webCCRules?: [ 
    {
      expires?: long(name='Expires', description='The validity period of the rule. Unit: seconds. If the Action parameter is set to block, the system blocks the requests that match the rule within the validity period of the rule. The value 0 indicates that the rule is permanently valid.', example='0'),
      name?: string(name='Name', description='The name of the rule.', example='wq'),
      owner?: string(name='Owner', description='The method used to create the rule. Valid values:

*   **manual** (default): manually created.
*   **clover**: automatically created.', example='manual'),
      ruleDetail?: {
        action?: string(name='Action', description='The action triggered if the rule is matched. Valid values:

*   **accept**: The requests that match the rule are allowed.
*   **block**: The requests that match the rule are blocked.
*   **challenge**: Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) verification for the requests that match the rule is implemented.
*   **watch**: The requests that match the rule are recorded in logs and allowed.', example='block'),
        condition?: [ 
          {
            content?: string(name='Content', description='The match content.', example='192.0.XX.XX'),
            contentList?: string(name='ContentList', description='The match content when the match method is Equals to One of Multiple Values.', example='["2","3","ad"]'),
            field?: string(name='Field', description='The match field.', example='ip'),
            headerName?: string(name='HeaderName', description='The custom HTTP request header.

>  This parameter takes effect only when **Field** is set to **header**.', example='null'),
            matchMethod?: string(name='MatchMethod', description='The match method.', example='belong'),
          }
        ](name='Condition', description='The match conditions.'),
        count?: int32(name='Count', description='The parameter is deprecated.'),
        interval?: int32(name='Interval', description='The parameter is deprecated.', example='60'),
        mode?: string(name='Mode', description='The parameter is deprecated.'),
        name?: string(name='Name', description='The name of the rule.', example='ccauto14'),
        rateLimit?: {
          interval?: int32(name='Interval', description='The statistical period. Unit: seconds.', example='60'),
          subKey?: string(name='SubKey', description='The name of the field. This parameter is required only when the Target parameter is set to header.', example='action'),
          target?: string(name='Target', description='The statistical method. Valid values:

*   **ip**
*   **header**', example='ip'),
          threshold?: int32(name='Threshold', description='The trigger threshold.', example='20'),
          ttl?: int32(name='Ttl', description='The blocking duration. Unit: seconds.', example='15'),
        }(name='RateLimit', description='The frequency statistics.'),
        statistics?: {
          field?: string(name='Field', description='The statistical method. Valid values:

*   **ip**
*   **header**
*   **uri**', example='uri'),
          headerName?: string(name='HeaderName', description='The name of the header. This parameter is required only when the Field parameter is set to header.', example='hello'),
          mode?: string(name='Mode', description='Indicates whether the system collects statistics after deduplication. Valid values:

*   **count**: The system collects statistics before deduplication.
*   **distinct**: The system collects statistics after deduplication.', example='count'),
        }(name='Statistics', description='The statistics after deduplication. By default, the system collects statistics before deduplication.'),
        statusCode?: {
          code?: int32(name='Code', description='The status code. Valid values: **100** to **599**.

*   **200**: The request was successful.
*   Other codes: The request failed.', example='200'),
          countThreshold?: int32(name='CountThreshold', description='If a ratio is not used, the handling action is triggered only when the number of requests of the corresponding status code reaches the value of **CountThreshold**. Valid values: **2** to **50000**.', example='10'),
          enabled?: boolean(name='Enabled', description='Indicates whether the status code is enabled. Valid values:

*   **true**
*   **false**', example='true'),
          ratioThreshold?: int32(name='RatioThreshold', description='If a ratio is used, the handling action is triggered only when the number of requests of the corresponding status code reaches the value of **RatioThreshold**. Valid values: **1** to **100**.', example='10'),
          useRatio?: boolean(name='UseRatio', description='Indicates whether to use a ratio.

*   **true**
*   **false**', example='true'),
        }(name='StatusCode', description='The status codes.'),
        ttl?: int32(name='Ttl', description='The parameter is deprecated.', example='300'),
        uri?: string(name='Uri', description='The parameter is deprecated.', example='/p3shijihao'),
      }(name='RuleDetail', description='The details of the rule.'),
    }
  ](name='WebCCRules', description='The custom frequency control rules.'),
}

model DescribeWebCCRulesV2Response = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebCCRulesV2ResponseBody(name='body'),
}

/**
 * @summary Queries the custom frequency control rules that are created for a website.
 *
 * @param request DescribeWebCCRulesV2Request
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebCCRulesV2Response
 */
async function describeWebCCRulesV2WithOptions(request: DescribeWebCCRulesV2Request, runtime: $RuntimeOptions): DescribeWebCCRulesV2Response {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.offset)) {
    query['Offset'] = request.offset;
  }
  if (!$isNull(request.owner)) {
    query['Owner'] = request.owner;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeWebCCRulesV2',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the custom frequency control rules that are created for a website.
 *
 * @param request DescribeWebCCRulesV2Request
 * @return DescribeWebCCRulesV2Response
 */
async function describeWebCCRulesV2(request: DescribeWebCCRulesV2Request): DescribeWebCCRulesV2Response {
  var runtime = new $RuntimeOptions{};
  return describeWebCCRulesV2WithOptions(request, runtime);
}

model DescribeWebCacheConfigsRequest {
  domains?: [ string ](name='Domains', description='An array consisting of domain names for which you want to query the Static Page Caching configurations.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
}

model DescribeWebCacheConfigsResponseBody = {
  domainCacheConfigs?: [ 
    {
      customRules?: [ 
        {
          cacheTtl?: long(name='CacheTtl', description='The expiration time of the page cache. Unit: seconds.', example='86400'),
          mode?: string(name='Mode', description='The cache mode. Valid values:

*   **standard**: The standard cache mode is used.
*   **aggressive**: The enhanced cache mode is used.
*   **bypass**: No data is cached.', example='standard'),
          name?: string(name='Name', description='The name of the rule.', example='c1'),
          uri?: string(name='Uri', description='The path to the cached page.', example='/blog/'),
        }
      ](name='CustomRules', description='An array that consists of custom caching rules.'),
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyundoc.com'),
      enable?: int32(name='Enable', description='The status of the Static Page Caching policy. Valid values:

*   **1**: enabled
*   **0**: disabled', example='1'),
      mode?: string(name='Mode', description='The cache mode. Valid values:

*   **standard**: The standard cache mode is used.
*   **aggressive**: The enhanced cache mode is used.
*   **bypass**: No data is cached.', example='bypass'),
    }
  ](name='DomainCacheConfigs', description='An array that consists of Static Page Caching configurations.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
}

model DescribeWebCacheConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebCacheConfigsResponseBody(name='body'),
}

/**
 * @summary Queries the Static Page Caching configuration of websites.
 *
 * @description You can call the DescribeWebCacheConfigs operation to query the Static Page Caching configurations of websites. The configurations include cache modes and custom caching rules.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeWebCacheConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebCacheConfigsResponse
 */
async function describeWebCacheConfigsWithOptions(request: DescribeWebCacheConfigsRequest, runtime: $RuntimeOptions): DescribeWebCacheConfigsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domains)) {
    query['Domains'] = request.domains;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeWebCacheConfigs',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the Static Page Caching configuration of websites.
 *
 * @description You can call the DescribeWebCacheConfigs operation to query the Static Page Caching configurations of websites. The configurations include cache modes and custom caching rules.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeWebCacheConfigsRequest
 * @return DescribeWebCacheConfigsResponse
 */
async function describeWebCacheConfigs(request: DescribeWebCacheConfigsRequest): DescribeWebCacheConfigsResponse {
  var runtime = new $RuntimeOptions{};
  return describeWebCacheConfigsWithOptions(request, runtime);
}

model DescribeWebCcProtectSwitchRequest {
  domains?: [ string ](name='Domains', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DescribeWebCcProtectSwitchResponseBody = {
  protectSwitchList?: [ 
    {
      aiMode?: string(name='AiMode', description='The mode of Intelligent Protection. Valid values:

*   **watch**: Warning
*   **defense**: Defense', example='defense'),
      aiRuleEnable?: int32(name='AiRuleEnable', description='The status of Intelligent Protection. Valid values:

*   **0**: turned off
*   **1:** turned on', example='1'),
      aiTemplate?: string(name='AiTemplate', description='The level of Intelligent Protection. Valid values:

*   **level30**: Loose
*   **level60**: Normal
*   **level90**: Strict', example='level60'),
      blackWhiteListEnable?: int32(name='BlackWhiteListEnable', description='The status of Blacklist/Whitelist (Domain Names). Valid values:

*   **0**: turned off
*   **1:** turned on', example='1'),
      ccCustomRuleEnable?: int32(name='CcCustomRuleEnable', description='The status of the Custom Rules switch for Frequency Control. Valid values:

*   **0**: turned off
*   **1:** turned on', example='0'),
      ccEnable?: int32(name='CcEnable', description='The status of Frequency Control. Valid values:

*   **0**: turned off
*   **1:** turned on', example='1'),
      ccGlobalSwitch?: string(name='CcGlobalSwitch'),
      ccTemplate?: string(name='CcTemplate', description='The mode of Frequency Control. Valid values:

*   **default**: Normal
*   **gf_under_attack**: Emergency
*   **gf_sos_verify**: Strict
*   **gf_sos_enhance**: Super Strict', example='default'),
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
      preciseRuleEnable?: int32(name='PreciseRuleEnable', description='The status of Accurate Access Control. Valid values:

*   **0**: turned off
*   **1:** turned on', example='0'),
      regionBlockEnable?: int32(name='RegionBlockEnable', description='The status of Location Blacklist (Domain Names). Valid values:

*   **0**: turned off
*   **1:** turned on', example='0'),
    }
  ](name='ProtectSwitchList', description='The status of each mitigation policy for the website.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3ADD9EED-CA4B-488C-BC82-01B0B899363D'),
}

model DescribeWebCcProtectSwitchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebCcProtectSwitchResponseBody(name='body'),
}

/**
 * @summary Queries the status of each mitigation policy for a website.
 *
 * @param request DescribeWebCcProtectSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebCcProtectSwitchResponse
 */
async function describeWebCcProtectSwitchWithOptions(request: DescribeWebCcProtectSwitchRequest, runtime: $RuntimeOptions): DescribeWebCcProtectSwitchResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domains)) {
    query['Domains'] = request.domains;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeWebCcProtectSwitch',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the status of each mitigation policy for a website.
 *
 * @param request DescribeWebCcProtectSwitchRequest
 * @return DescribeWebCcProtectSwitchResponse
 */
async function describeWebCcProtectSwitch(request: DescribeWebCcProtectSwitchRequest): DescribeWebCcProtectSwitchResponse {
  var runtime = new $RuntimeOptions{};
  return describeWebCcProtectSwitchWithOptions(request, runtime);
}

model DescribeWebCustomPortsRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DescribeWebCustomPortsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
  webCustomPorts?: [ 
    {
      proxyPorts?: [ string ](name='ProxyPorts', description='An array that consists of supported custom ports.'),
      proxyType?: string(name='ProxyType', description='The type of the protocol. Valid values:

*   **http**
*   **https**', example='http'),
    }
  ](name='WebCustomPorts', description='An array consisting of information about supported custom ports that are used by a website.'),
}

model DescribeWebCustomPortsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebCustomPortsResponseBody(name='body'),
}

/**
 * @summary Queries the supported custom ports of a website.
 *
 * @param request DescribeWebCustomPortsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebCustomPortsResponse
 */
async function describeWebCustomPortsWithOptions(request: DescribeWebCustomPortsRequest, runtime: $RuntimeOptions): DescribeWebCustomPortsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeWebCustomPorts',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the supported custom ports of a website.
 *
 * @param request DescribeWebCustomPortsRequest
 * @return DescribeWebCustomPortsResponse
 */
async function describeWebCustomPorts(request: DescribeWebCustomPortsRequest): DescribeWebCustomPortsResponse {
  var runtime = new $RuntimeOptions{};
  return describeWebCustomPortsWithOptions(request, runtime);
}

model DescribeWebInstanceRelationsRequest {
  domains?: [ string ](name='Domains', description='The domain names of the website.

>  A forwarding rule must be configured for the domain names. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DescribeWebInstanceRelationsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0222382B-5FE5-4FF7-BC9B-97EE31D58818'),
  webInstanceRelations?: [ 
    {
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
      instanceDetails?: [ 
        {
          eipList?: [ string ](name='EipList', description='The IP addresses of the instance.'),
          functionVersion?: string(name='FunctionVersion', description='The function plan of the instance. Valid values:

*   **default**: Standard function plan
*   **enhance**: Enhanced function plan', example='enhance'),
          instanceId?: string(name='InstanceId', description='The ID of the instance.', example='ddoscoo-cn-0pp163pd****'),
        }
      ](name='InstanceDetails', description='The information about the instance to which a website service is added.'),
    }
  ](name='WebInstanceRelations', description='The information about the instances to which a website service is added.'),
}

model DescribeWebInstanceRelationsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebInstanceRelationsResponseBody(name='body'),
}

/**
 * @summary Queries the information about Anti-DDoS Pro or Anti-DDoS Premium instances to which a website service is added.
 *
 * @param request DescribeWebInstanceRelationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebInstanceRelationsResponse
 */
async function describeWebInstanceRelationsWithOptions(request: DescribeWebInstanceRelationsRequest, runtime: $RuntimeOptions): DescribeWebInstanceRelationsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domains)) {
    query['Domains'] = request.domains;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeWebInstanceRelations',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the information about Anti-DDoS Pro or Anti-DDoS Premium instances to which a website service is added.
 *
 * @param request DescribeWebInstanceRelationsRequest
 * @return DescribeWebInstanceRelationsResponse
 */
async function describeWebInstanceRelations(request: DescribeWebInstanceRelationsRequest): DescribeWebInstanceRelationsResponse {
  var runtime = new $RuntimeOptions{};
  return describeWebInstanceRelationsWithOptions(request, runtime);
}

model DescribeWebPreciseAccessRuleRequest {
  domains?: [ string ](name='Domains', description='An array that consists of the domain names of websites.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DescribeWebPreciseAccessRuleResponseBody = {
  preciseAccessConfigList?: [ 
    {
      domain?: string(name='Domain', description='The domain name of the website.', example='www.aliyun.com'),
      ruleList?: [ 
        {
          action?: string(name='Action', description='The action triggered if the rule is matched. Valid values:

*   **accept**: The requests that match the rule are allowed.
*   **block**: The requests that match the rule are blocked.
*   **challenge**: Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) verification for the requests that match the rule is implemented.', example='accept'),
          conditionList?: [ 
            {
              content?: string(name='Content', description='The match content.', example='1.1.1.1'),
              contentList?: [ string ](name='ContentList'),
              field?: string(name='Field', description='The match field.', example='ip'),
              headerName?: string(name='HeaderName', description='The custom HTTP request header.

>  This parameter takes effect only when **Field** is set to **header**.', example='null'),
              matchMethod?: string(name='MatchMethod', description='The logical operator.', example='belong'),
            }
          ](name='ConditionList', description='The match conditions.'),
          expires?: long(name='Expires', description='The validity period of the rule. Unit: seconds. This parameter takes effect only when **action** of a rule is **block**. Access requests that match the rule are blocked within the specified validity period of the rule. The value **0** indicates that the whitelist takes effect all the time.', example='0'),
          name?: string(name='Name', description='The name of the scheduling rule.', example='testrule'),
          owner?: string(name='Owner', description='The source of the rule. Valid values:

*   **manual** (default): manually created.
*   **auto**: automatically generated.', example='manual'),
        }
      ](name='RuleList', description='The scheduling rules.'),
    }
  ](name='PreciseAccessConfigList', description='The configuration of the accurate access control rule that is created for the website.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='209EEFBF-B0C7-441E-8C28-D0945A57A638'),
}

model DescribeWebPreciseAccessRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebPreciseAccessRuleResponseBody(name='body'),
}

/**
 * @summary Queries the accurate access control rules that are created for websites.
 *
 * @param request DescribeWebPreciseAccessRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebPreciseAccessRuleResponse
 */
async function describeWebPreciseAccessRuleWithOptions(request: DescribeWebPreciseAccessRuleRequest, runtime: $RuntimeOptions): DescribeWebPreciseAccessRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domains)) {
    query['Domains'] = request.domains;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeWebPreciseAccessRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the accurate access control rules that are created for websites.
 *
 * @param request DescribeWebPreciseAccessRuleRequest
 * @return DescribeWebPreciseAccessRuleResponse
 */
async function describeWebPreciseAccessRule(request: DescribeWebPreciseAccessRuleRequest): DescribeWebPreciseAccessRuleResponse {
  var runtime = new $RuntimeOptions{};
  return describeWebPreciseAccessRuleWithOptions(request, runtime);
}

model DescribeWebReportTopIpRequest {
  domain?: string(name='Domain', description='The domain name of the website.

>  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query the domain names for which forwarding rules are configured.', example='app.bmjqxvb.cn'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1687228200'),
  interval?: int32(name='Interval', description='The interval at which data is collected. Unit: seconds. Valid values are 300, 3600, and 86400.

*   If the time span between StartTime and EndTime is less than 3 days (3 days excluded), valid values are 300, 3600, and 86400.
*   If the time span between StartTime and EndTime is from 3 to 31 days (31 days excluded), valid values are 3600 and 86400.
*   If the time span between StartTime and EndTime is 31 days or longer, the valid value is 86400.

This parameter is required.', example='300'),
  queryType?: string(name='QueryType', description='The source of the statistics. Valid values:

*   **visit**: indicates all IP addresses.
*   **block**: indicates blocked IP addresses.

This parameter is required.', example='block'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

>  This UNIX timestamp must indicate a point in time that is accurate to the minute.

This parameter is required.', example='1680424200'),
  top?: int32(name='Top', description='The maximum number of entries to return.', example='5'),
}

model DescribeWebReportTopIpResponseBody = {
  dataList?: [ 
    {
      areaId?: string(name='AreaId', description='The ID of the location.', example='90998690'),
      count?: long(name='Count', description='The number of entries returned.', example='5'),
      isp?: string(name='Isp', description='The Internet service provider (ISP) for the attack. Valid values:

*   **100017**: China Telecom
*   **100026**: China Unicom
*   **100025**: China Mobile
*   **100027**: China Education and Research Network
*   **100020**: China Mobile Tietong
*   **1000143**: Dr.Peng Telecom & Media Group
*   **100080**: Beijing Gehua CATV Network
*   **1000139**: National Radio and Television Administration
*   **100023**: Oriental Cable Network
*   **100063**: Founder Broadband
*   **1000337**: China Internet Exchange
*   **100021**: 21Vianet Group
*   **1000333**: Wasu Media Holding
*   **100093**: Wangsu Science & Technology
*   **1000401**: Tencent
*   **100099**: Baidu
*   **1000323**: Alibaba Cloud
*   **100098**: Alibaba', example='100017'),
      sourceIp?: string(name='SourceIp', description='The source IP address.', example='117.186.XX.XX'),
    }
  ](name='DataList', description='The information about the IP addresses.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D21BE0C4-8E83-5E32-86C6-AA6BE9B1B5BD'),
}

model DescribeWebReportTopIpResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebReportTopIpResponseBody(name='body'),
}

/**
 * @summary Queries the top source IP addresses of the web resource exhaustion attacks for the Anti-DDoS Proxy instance.
 *
 * @param request DescribeWebReportTopIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebReportTopIpResponse
 */
async function describeWebReportTopIpWithOptions(request: DescribeWebReportTopIpRequest, runtime: $RuntimeOptions): DescribeWebReportTopIpResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!$isNull(request.queryType)) {
    query['QueryType'] = request.queryType;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!$isNull(request.top)) {
    query['Top'] = request.top;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeWebReportTopIp',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Queries the top source IP addresses of the web resource exhaustion attacks for the Anti-DDoS Proxy instance.
 *
 * @param request DescribeWebReportTopIpRequest
 * @return DescribeWebReportTopIpResponse
 */
async function describeWebReportTopIp(request: DescribeWebReportTopIpRequest): DescribeWebReportTopIpResponse {
  var runtime = new $RuntimeOptions{};
  return describeWebReportTopIpWithOptions(request, runtime);
}

model DescribeWebRulesRequest {
  cname?: string(name='Cname', description='The CNAME address to query.', example='kzmk7b8tt351****.aliyunddos1014****'),
  domain?: string(name='Domain', description='The domain name of the website to query.

> The domain must have been configured with website business forwarding rules. You can call [DescribeDomains](~~DescribeDomains~~) to query all domains that have been configured with website business forwarding rules.', example='example.com'),
  instanceIds?: [ string ](name='InstanceIds', description='The list of DDoS protection instance IDs to query.', example='ddoscoo-cn-mp91j1ao****'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **1** to **10**.', example='10'),
  queryDomainPattern?: string(name='QueryDomainPattern', description='The query matching pattern. Values:
- **fuzzy** (default): Indicates fuzzy query.
- **exact**: Indicates exact query.', example='exact'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID of the DDoS protection instance in the resource management service.

Not setting this parameter indicates the default resource group.', example='rg-acfm2pz25js****'),
}

model DescribeWebRulesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F5B72DD-96F4-423A-B12B-A5151DD746B8'),
  totalCount?: long(name='TotalCount', description='The total number of queried website business forwarding rules.', example='1'),
  webRules?: [ 
    {
      blackList?: [ string ](name='BlackList', description='The IP addresses in the blacklist for the domain name.'),
      ccEnabled?: boolean(name='CcEnabled', description='Indicates whether the Frequency Control policy is enabled. Valid values:

*   **true**
*   **false**', example='true'),
      ccRuleEnabled?: boolean(name='CcRuleEnabled', description='Indicates whether the Custom Rule switch of the Frequency Control policy is turned on. Valid values:

*   **true**
*   **false**', example='false'),
      ccTemplate?: string(name='CcTemplate', description='The mode of the Frequency Control policy. Valid values:

*   **default**: the Normal mode
*   **gf_under_attack**: the Emergency mode
*   **gf_sos_verify**: the Strict mode
*   **gf_sos_verify**: the Super Strict mode', example='default'),
      certName?: string(name='CertName', description='The name of the SSL certificate.', example='testcert'),
      certRegion?: string(name='CertRegion', description='The region where the certificate is used. Valid values:

*   cn-hangzhou (default): the Chinese mainland
*   ap-southeast-1: outside the Chinese mainland', example='cn-hangzhou'),
      cname?: string(name='Cname', description='The CNAME provided by the Anti-DDoS Pro or Anti-DDoS Premium instance to which the domain name is added.', example='kzmk7b8tt351****.aliyunddos1014****'),
      customCiphers?: [ string ](name='CustomCiphers', description='The custom cipher suites.'),
      domain?: string(name='Domain', description='The domain name of the website.', example='example.com'),
      gmCert?: {
        certId?: string(name='CertId', description='The ID of the SM certificate.', example='725****'),
        gmEnable?: long(name='GmEnable', description='Indicates whether Enable SM Certificate-based Verification is turned on.

*   0: no
*   1: yes', example='1'),
        gmOnly?: long(name='GmOnly', description='Indicates whether Allow Access Only from SM Certificates-based Clients is turned on.

*   0: no
*   1: yes', example='1'),
      }(name='GmCert', description='The SM certificate settings.'),
      http2Enable?: boolean(name='Http2Enable', description='Indicates whether Enable HTTP/2 is turned on. Valid values:

*   **true**
*   **false**', example='true'),
      http2HttpsEnable?: boolean(name='Http2HttpsEnable', description='Indicates whether Enable HTTPS Redirection was turned on. Valid values:

*   **true**
*   **false**', example='true'),
      https2HttpEnable?: boolean(name='Https2HttpEnable', description='Indicates whether Enable HTTP Redirection of Back-to-origin Requests is turned on. Valid values:

*   **true**
*   **false**', example='true'),
      ocspEnabled?: boolean(name='OcspEnabled', description='Indicates whether the Online Certificate Status Protocol (OCSP) feature is enabled. Valid values:

*   **true**
*   **false**', example='false'),
      policyMode?: string(name='PolicyMode', description='The load balancing algorithm for back-to-origin traffic. Valid values:

*   **ip_hash**: the IP hash algorithm. This algorithm is used to redirect the requests from the same IP address to the same origin server.
*   **rr**: the round-robin algorithm. This algorithm is used to redirect requests to origin servers in turn.
*   **least_time**: the least response time algorithm. This algorithm is used to minimize the latency when requests are forwarded from Anti-DDoS Pro or Anti-DDoS Premium instances to origin servers based on the intelligent DNS resolution feature.', example='ip_hash'),
      proxyEnabled?: boolean(name='ProxyEnabled', description='Indicates whether the forwarding rule is enabled. Valid values:

*   **true**
*   **false**', example='true'),
      proxyTypes?: [ 
        {
          proxyPorts?: [ string ](name='ProxyPorts', description='The ports.'),
          proxyType?: string(name='ProxyType', description='The type of the protocol. Valid values:

*   **http**
*   **https**
*   **websocket**
*   **websockets**', example='https'),
        }
      ](name='ProxyTypes', description='The details of the protocol type and port number.'),
      punishReason?: int32(name='PunishReason', description='The reason why the domain name is invalid. Valid values:

*   **1**: No Content Provider (ICP) filing is completed for the domain name.
*   **2**: The business for which you registered the domain name does not meet regulatory requirements.

If the two reasons are both involved, the value **2** is returned.', example='1'),
      punishStatus?: boolean(name='PunishStatus', description='Indicates whether the domain name is invalid. Valid values:

*   **true**: You can view the specific reasons from the **PunishReason** parameter.
*   **false**', example='true'),
      realServers?: [ 
        {
          realServer?: string(name='RealServer', description='The address of the origin server.', example='192.0.XX.XX'),
          rsType?: int32(name='RsType', description='The type of the origin server address. Valid values:

*   **0**: IP address
*   **1**: domain name The domain name of the origin server is returned if you deploy proxies, such as Web Application Firewall (WAF), between the origin server and the instance. In this case, the address of the proxy, such as the CNAME provided by WAF, is returned.', example='0'),
        }
      ](name='RealServers', description='The details of the origin server address.'),
      ssl13Enabled?: boolean(name='Ssl13Enabled', description='Indicates whether TLS 1.3 is supported. Valid values:

*   **true**
*   **false**', example='false'),
      sslCiphers?: string(name='SslCiphers', description='The type of the cipher suite. Valid values:

*   **default**: custom cipher suites
*   **all**: all cipher suites, which contain strong and weak cipher suites
*   **strong**: strong cipher suites', example='default'),
      sslProtocols?: string(name='SslProtocols', description='The version of the Transport Layer Security (TLS) protocol. Valid values:

*   **tls1.0**: TLS 1.0 or later
*   **tls1.1**: TLS 1.1 or later
*   **tls1.2**: TLS 1.2 or later', example='tls1.1'),
      userCertName?: string(name='UserCertName', description='The name of the certificate uploaded by the user to the certificate center.', example='test'),
      whiteList?: [ string ](name='WhiteList', description='The IP addresses in the whitelist for the domain name.'),
    }
  ](name='WebRules', description='The configurations of the forwarding rule.'),
}

model DescribeWebRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeWebRulesResponseBody(name='body'),
}

/**
 * @summary Query Configuration of Website Business Forwarding Rules.
 *
 * @description This interface is used for paginated querying of the configurations of website business forwarding rules you have created, such as forwarding protocol types, source server addresses, HTTPS configurations, IP blacklist configurations, and more.
 * Before calling this interface, you must have already called [CreateWebRule](~~CreateWebRule~~) to create website business forwarding rules.
 * ### QPS Limit
 * The per-user QPS limit for this interface is 50 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business; please use it reasonably.
 *
 * @param request DescribeWebRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebRulesResponse
 */
async function describeWebRulesWithOptions(request: DescribeWebRulesRequest, runtime: $RuntimeOptions): DescribeWebRulesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.cname)) {
    query['Cname'] = request.cname;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.queryDomainPattern)) {
    query['QueryDomainPattern'] = request.queryDomainPattern;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeWebRules',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Query Configuration of Website Business Forwarding Rules.
 *
 * @description This interface is used for paginated querying of the configurations of website business forwarding rules you have created, such as forwarding protocol types, source server addresses, HTTPS configurations, IP blacklist configurations, and more.
 * Before calling this interface, you must have already called [CreateWebRule](~~CreateWebRule~~) to create website business forwarding rules.
 * ### QPS Limit
 * The per-user QPS limit for this interface is 50 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business; please use it reasonably.
 *
 * @param request DescribeWebRulesRequest
 * @return DescribeWebRulesResponse
 */
async function describeWebRules(request: DescribeWebRulesRequest): DescribeWebRulesResponse {
  var runtime = new $RuntimeOptions{};
  return describeWebRulesWithOptions(request, runtime);
}

model DetachSceneDefenseObjectRequest {
  objectType?: string(name='ObjectType', description='The type of the object. Set the value to **Domain**, which indicates a domain name.', example='Domain'),
  objects?: string(name='Objects', description='The protection asset that you want to remove from a policy. Separate multiple protection assets with commas (,).

This parameter is required.', example='www.aliyun.com'),
  policyId?: string(name='PolicyId', description='The ID of the policy.

> You can call the [DescribeSceneDefensePolicies](https://help.aliyun.com/document_detail/159382.html) operation to query the IDs of all policies.

This parameter is required.', example='321a-fd31-df51-****'),
}

model DetachSceneDefenseObjectResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model DetachSceneDefenseObjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DetachSceneDefenseObjectResponseBody(name='body'),
}

/**
 * @summary Removes a protected object from a scenario-specific custom policy.
 *
 * @param request DetachSceneDefenseObjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachSceneDefenseObjectResponse
 */
async function detachSceneDefenseObjectWithOptions(request: DetachSceneDefenseObjectRequest, runtime: $RuntimeOptions): DetachSceneDefenseObjectResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.objectType)) {
    query['ObjectType'] = request.objectType;
  }
  if (!$isNull(request.objects)) {
    query['Objects'] = request.objects;
  }
  if (!$isNull(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DetachSceneDefenseObject',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Removes a protected object from a scenario-specific custom policy.
 *
 * @param request DetachSceneDefenseObjectRequest
 * @return DetachSceneDefenseObjectResponse
 */
async function detachSceneDefenseObject(request: DetachSceneDefenseObjectRequest): DetachSceneDefenseObjectResponse {
  var runtime = new $RuntimeOptions{};
  return detachSceneDefenseObjectWithOptions(request, runtime);
}

model DisableSceneDefensePolicyRequest {
  policyId?: string(name='PolicyId', description='The ID of the policy that you want to disable.

> You can call the [DescribeSceneDefensePolicies](https://help.aliyun.com/document_detail/159382.html) operation to query the IDs of all policies.

This parameter is required.', example='321a-fd31-df51-****'),
}

model DisableSceneDefensePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model DisableSceneDefensePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableSceneDefensePolicyResponseBody(name='body'),
}

/**
 * @summary Disables a scenario-specific custom policy.
 *
 * @param request DisableSceneDefensePolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableSceneDefensePolicyResponse
 */
async function disableSceneDefensePolicyWithOptions(request: DisableSceneDefensePolicyRequest, runtime: $RuntimeOptions): DisableSceneDefensePolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DisableSceneDefensePolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Disables a scenario-specific custom policy.
 *
 * @param request DisableSceneDefensePolicyRequest
 * @return DisableSceneDefensePolicyResponse
 */
async function disableSceneDefensePolicy(request: DisableSceneDefensePolicyRequest): DisableSceneDefensePolicyResponse {
  var runtime = new $RuntimeOptions{};
  return disableSceneDefensePolicyWithOptions(request, runtime);
}

model DisableWebAccessLogConfigRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DisableWebAccessLogConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model DisableWebAccessLogConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableWebAccessLogConfigResponseBody(name='body'),
}

/**
 * @summary Disables the log analysis feature for a website.
 *
 * @param request DisableWebAccessLogConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableWebAccessLogConfigResponse
 */
async function disableWebAccessLogConfigWithOptions(request: DisableWebAccessLogConfigRequest, runtime: $RuntimeOptions): DisableWebAccessLogConfigResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DisableWebAccessLogConfig',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Disables the log analysis feature for a website.
 *
 * @param request DisableWebAccessLogConfigRequest
 * @return DisableWebAccessLogConfigResponse
 */
async function disableWebAccessLogConfig(request: DisableWebAccessLogConfigRequest): DisableWebAccessLogConfigResponse {
  var runtime = new $RuntimeOptions{};
  return disableWebAccessLogConfigWithOptions(request, runtime);
}

model DisableWebCCRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DisableWebCCResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DisableWebCCResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableWebCCResponseBody(name='body'),
}

/**
 * @summary Disables frequency control for a website.
 *
 * @param request DisableWebCCRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableWebCCResponse
 */
async function disableWebCCWithOptions(request: DisableWebCCRequest, runtime: $RuntimeOptions): DisableWebCCResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DisableWebCC',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Disables frequency control for a website.
 *
 * @param request DisableWebCCRequest
 * @return DisableWebCCResponse
 */
async function disableWebCC(request: DisableWebCCRequest): DisableWebCCResponse {
  var runtime = new $RuntimeOptions{};
  return disableWebCCWithOptions(request, runtime);
}

model DisableWebCCRuleRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model DisableWebCCRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model DisableWebCCRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableWebCCRuleResponseBody(name='body'),
}

/**
 * @summary Disables custom frequency control rules for a website.
 *
 * @param request DisableWebCCRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableWebCCRuleResponse
 */
async function disableWebCCRuleWithOptions(request: DisableWebCCRuleRequest, runtime: $RuntimeOptions): DisableWebCCRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DisableWebCCRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Disables custom frequency control rules for a website.
 *
 * @param request DisableWebCCRuleRequest
 * @return DisableWebCCRuleResponse
 */
async function disableWebCCRule(request: DisableWebCCRuleRequest): DisableWebCCRuleResponse {
  var runtime = new $RuntimeOptions{};
  return disableWebCCRuleWithOptions(request, runtime);
}

model EmptyAutoCcBlacklistRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
}

model EmptyAutoCcBlacklistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model EmptyAutoCcBlacklistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EmptyAutoCcBlacklistResponseBody(name='body'),
}

/**
 * @summary Clears the IP address blacklist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request EmptyAutoCcBlacklistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EmptyAutoCcBlacklistResponse
 */
async function emptyAutoCcBlacklistWithOptions(request: EmptyAutoCcBlacklistRequest, runtime: $RuntimeOptions): EmptyAutoCcBlacklistResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'EmptyAutoCcBlacklist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Clears the IP address blacklist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request EmptyAutoCcBlacklistRequest
 * @return EmptyAutoCcBlacklistResponse
 */
async function emptyAutoCcBlacklist(request: EmptyAutoCcBlacklistRequest): EmptyAutoCcBlacklistResponse {
  var runtime = new $RuntimeOptions{};
  return emptyAutoCcBlacklistWithOptions(request, runtime);
}

model EmptyAutoCcWhitelistRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
}

model EmptyAutoCcWhitelistResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model EmptyAutoCcWhitelistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EmptyAutoCcWhitelistResponseBody(name='body'),
}

/**
 * @summary Clears the IP address whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request EmptyAutoCcWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EmptyAutoCcWhitelistResponse
 */
async function emptyAutoCcWhitelistWithOptions(request: EmptyAutoCcWhitelistRequest, runtime: $RuntimeOptions): EmptyAutoCcWhitelistResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'EmptyAutoCcWhitelist',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Clears the IP address whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request EmptyAutoCcWhitelistRequest
 * @return EmptyAutoCcWhitelistResponse
 */
async function emptyAutoCcWhitelist(request: EmptyAutoCcWhitelistRequest): EmptyAutoCcWhitelistResponse {
  var runtime = new $RuntimeOptions{};
  return emptyAutoCcWhitelistWithOptions(request, runtime);
}

model EmptySlsLogstoreRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model EmptySlsLogstoreResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model EmptySlsLogstoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EmptySlsLogstoreResponseBody(name='body'),
}

/**
 * @summary Clears the Logstore of Anti-DDoS Pro or Anti-DDoS Premium.
 *
 * @param request EmptySlsLogstoreRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EmptySlsLogstoreResponse
 */
async function emptySlsLogstoreWithOptions(request: EmptySlsLogstoreRequest, runtime: $RuntimeOptions): EmptySlsLogstoreResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'EmptySlsLogstore',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Clears the Logstore of Anti-DDoS Pro or Anti-DDoS Premium.
 *
 * @param request EmptySlsLogstoreRequest
 * @return EmptySlsLogstoreResponse
 */
async function emptySlsLogstore(request: EmptySlsLogstoreRequest): EmptySlsLogstoreResponse {
  var runtime = new $RuntimeOptions{};
  return emptySlsLogstoreWithOptions(request, runtime);
}

model EnableSceneDefensePolicyRequest {
  policyId?: string(name='PolicyId', description='The ID of the policy that you want to enable.

> You can call the [DescribeSceneDefensePolicies](https://help.aliyun.com/document_detail/159382.html) operation to query the IDs of all policies.

This parameter is required.', example='321a-fd31-df51-****'),
}

model EnableSceneDefensePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model EnableSceneDefensePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableSceneDefensePolicyResponseBody(name='body'),
}

/**
 * @summary Enables a scenario-specific custom policy.
 *
 * @param request EnableSceneDefensePolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableSceneDefensePolicyResponse
 */
async function enableSceneDefensePolicyWithOptions(request: EnableSceneDefensePolicyRequest, runtime: $RuntimeOptions): EnableSceneDefensePolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'EnableSceneDefensePolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables a scenario-specific custom policy.
 *
 * @param request EnableSceneDefensePolicyRequest
 * @return EnableSceneDefensePolicyResponse
 */
async function enableSceneDefensePolicy(request: EnableSceneDefensePolicyRequest): EnableSceneDefensePolicyResponse {
  var runtime = new $RuntimeOptions{};
  return enableSceneDefensePolicyWithOptions(request, runtime);
}

model EnableWebAccessLogConfigRequest {
  domain?: string(name='Domain', description='The domain name of the website.

>  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/474212.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model EnableWebAccessLogConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model EnableWebAccessLogConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableWebAccessLogConfigResponseBody(name='body'),
}

/**
 * @summary Enables the log analysis feature for a website.
 *
 * @param request EnableWebAccessLogConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableWebAccessLogConfigResponse
 */
async function enableWebAccessLogConfigWithOptions(request: EnableWebAccessLogConfigRequest, runtime: $RuntimeOptions): EnableWebAccessLogConfigResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'EnableWebAccessLogConfig',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables the log analysis feature for a website.
 *
 * @param request EnableWebAccessLogConfigRequest
 * @return EnableWebAccessLogConfigResponse
 */
async function enableWebAccessLogConfig(request: EnableWebAccessLogConfigRequest): EnableWebAccessLogConfigResponse {
  var runtime = new $RuntimeOptions{};
  return enableWebAccessLogConfigWithOptions(request, runtime);
}

model EnableWebCCRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model EnableWebCCResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model EnableWebCCResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableWebCCResponseBody(name='body'),
}

/**
 * @summary Enables the Frequency Control policy for a website.
 *
 * @param request EnableWebCCRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableWebCCResponse
 */
async function enableWebCCWithOptions(request: EnableWebCCRequest, runtime: $RuntimeOptions): EnableWebCCResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'EnableWebCC',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables the Frequency Control policy for a website.
 *
 * @param request EnableWebCCRequest
 * @return EnableWebCCResponse
 */
async function enableWebCC(request: EnableWebCCRequest): EnableWebCCResponse {
  var runtime = new $RuntimeOptions{};
  return enableWebCCWithOptions(request, runtime);
}

model EnableWebCCRuleRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model EnableWebCCRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model EnableWebCCRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableWebCCRuleResponseBody(name='body'),
}

/**
 * @summary Enables custom frequency control rules for a website.
 *
 * @param request EnableWebCCRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableWebCCRuleResponse
 */
async function enableWebCCRuleWithOptions(request: EnableWebCCRuleRequest, runtime: $RuntimeOptions): EnableWebCCRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'EnableWebCCRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables custom frequency control rules for a website.
 *
 * @param request EnableWebCCRuleRequest
 * @return EnableWebCCRuleResponse
 */
async function enableWebCCRule(request: EnableWebCCRuleRequest): EnableWebCCRuleResponse {
  var runtime = new $RuntimeOptions{};
  return enableWebCCRuleWithOptions(request, runtime);
}

model ModifyBizBandWidthModeRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-zvp2ay9b****'),
  mode?: string(name='Mode', description='The metering method of the burstable clean bandwidth feature. Valid values:

*   **month**: the metering method of monthly 95th percentile
*   **day**: the metering method of daily 95th percentile

This parameter is required.', example='month'),
}

model ModifyBizBandWidthModeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='CF33B4C3-196E-4015-AADD-5CAD00057B80'),
}

model ModifyBizBandWidthModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyBizBandWidthModeResponseBody(name='body'),
}

/**
 * @summary Switches between the metering methods of the burstable clean bandwidth feature.
 *
 * @description You can switch between the metering methods of the burstable clean bandwidth feature. The new metering method takes effect from 00:00 on the first day of the next month. You can change the metering method up to three times each calendar month. The most recent metering method that you select takes effect in the next month. You cannot change the metering method on the last day of each calendar month.
 *
 * @param request ModifyBizBandWidthModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBizBandWidthModeResponse
 */
async function modifyBizBandWidthModeWithOptions(request: ModifyBizBandWidthModeRequest, runtime: $RuntimeOptions): ModifyBizBandWidthModeResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.mode)) {
    query['Mode'] = request.mode;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyBizBandWidthMode',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Switches between the metering methods of the burstable clean bandwidth feature.
 *
 * @description You can switch between the metering methods of the burstable clean bandwidth feature. The new metering method takes effect from 00:00 on the first day of the next month. You can change the metering method up to three times each calendar month. The most recent metering method that you select takes effect in the next month. You cannot change the metering method on the last day of each calendar month.
 *
 * @param request ModifyBizBandWidthModeRequest
 * @return ModifyBizBandWidthModeResponse
 */
async function modifyBizBandWidthMode(request: ModifyBizBandWidthModeRequest): ModifyBizBandWidthModeResponse {
  var runtime = new $RuntimeOptions{};
  return modifyBizBandWidthModeWithOptions(request, runtime);
}

model ModifyBlackholeStatusRequest {
  blackholeStatus?: string(name='BlackholeStatus', description='The action that you want to perform on the instance. Set the value to **undo**, which indicates that you want to deactivate blackhole filtering.

This parameter is required.', example='undo'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
}

model ModifyBlackholeStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model ModifyBlackholeStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyBlackholeStatusResponseBody(name='body'),
}

/**
 * @summary Deactivates blackhole filtering that is triggered on an instance.
 *
 * @param request ModifyBlackholeStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBlackholeStatusResponse
 */
async function modifyBlackholeStatusWithOptions(request: ModifyBlackholeStatusRequest, runtime: $RuntimeOptions): ModifyBlackholeStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.blackholeStatus)) {
    query['BlackholeStatus'] = request.blackholeStatus;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyBlackholeStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Deactivates blackhole filtering that is triggered on an instance.
 *
 * @param request ModifyBlackholeStatusRequest
 * @return ModifyBlackholeStatusResponse
 */
async function modifyBlackholeStatus(request: ModifyBlackholeStatusRequest): ModifyBlackholeStatusResponse {
  var runtime = new $RuntimeOptions{};
  return modifyBlackholeStatusWithOptions(request, runtime);
}

model ModifyBlockStatusRequest {
  duration?: int32(name='Duration', description='The blocking period. Valid values: **15** to **43200**. Unit: minutes.

> If you set **Status** to **do**, you must also specify this parameter.', example='60'),
  instanceId?: string(name='InstanceId', description='The ID of the Anti-DDoS Proxy (Chinese Mainland) instance to manage.

>  You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all Anti-DDoS Proxy instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  lines?: [ string ](name='Lines', description='An array consisting of the Internet service provider (ISP) lines from which traffic is blocked.

This parameter is required.', example='ct'),
  status?: string(name='Status', description='Specifies the status of the Diversion from Origin Server policy. Valid values:

*   **do**: enables the policy.
*   **undo**: disables the policy.

This parameter is required.', example='do'),
}

model ModifyBlockStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model ModifyBlockStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyBlockStatusResponseBody(name='body'),
}

/**
 * @summary Modifies the Diversion from Origin Server configuration of an Anti-DDoS Proxy (Chinese Mainland) instance.
 *
 * @description >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
 *
 * @param request ModifyBlockStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBlockStatusResponse
 */
async function modifyBlockStatusWithOptions(request: ModifyBlockStatusRequest, runtime: $RuntimeOptions): ModifyBlockStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.lines)) {
    query['Lines'] = request.lines;
  }
  if (!$isNull(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyBlockStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the Diversion from Origin Server configuration of an Anti-DDoS Proxy (Chinese Mainland) instance.
 *
 * @description >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
 *
 * @param request ModifyBlockStatusRequest
 * @return ModifyBlockStatusResponse
 */
async function modifyBlockStatus(request: ModifyBlockStatusRequest): ModifyBlockStatusResponse {
  var runtime = new $RuntimeOptions{};
  return modifyBlockStatusWithOptions(request, runtime);
}

model ModifyCnameReuseRequest {
  cname?: string(name='Cname', description='The CNAME record that you want to reuse for the website.', example='4o6ep6q217k9****.aliyunddos0004.com'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  enable?: int32(name='Enable', description='Specifies whether to enable CNAME reuse. Valid values:

*   **0:** disabled
*   **1:** enabled

This parameter is required.', example='1'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model ModifyCnameReuseResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyCnameReuseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyCnameReuseResponseBody(name='body'),
}

/**
 * @summary Enables or disables CNAME reuse for a website.
 *
 * @description > This operation is suitable only for Anti-DDoS Premium.
 *
 * @param request ModifyCnameReuseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCnameReuseResponse
 */
async function modifyCnameReuseWithOptions(request: ModifyCnameReuseRequest, runtime: $RuntimeOptions): ModifyCnameReuseResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.cname)) {
    query['Cname'] = request.cname;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyCnameReuse',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables CNAME reuse for a website.
 *
 * @description > This operation is suitable only for Anti-DDoS Premium.
 *
 * @param request ModifyCnameReuseRequest
 * @return ModifyCnameReuseResponse
 */
async function modifyCnameReuse(request: ModifyCnameReuseRequest): ModifyCnameReuseResponse {
  var runtime = new $RuntimeOptions{};
  return modifyCnameReuseWithOptions(request, runtime);
}

model ModifyDomainResourceRequest {
  domain?: string(name='Domain', description='The domain name that is added to the Anti-DDoS Pro or Anti-DDoS Premium instance.

This parameter is required.', example='www.example.com'),
  httpsExt?: string(name='HttpsExt', description='The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:

*   **Http2https**: specifies whether to turn on Enforce HTTPS Routing. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enforce HTTPS Routing is turned off. The value 1 indicates that Enforce HTTPS Routing is turned on. The default value is 0.

    If your website supports both HTTP and HTTPS, this feature meets your business requirements. If you enable this feature, all HTTP requests to access the website are redirected to HTTPS requests on the standard port 443.

*   **Https2http**: specifies whether to turn on Enable HTTP. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP is turned off. The value 1 indicates that Enable HTTP is turned on. The default value is 0.

    If your website does not support HTTPS, this feature meets your business requirements If this feature is enabled, all HTTPS requests are redirected to HTTP requests and forwarded to origin servers. This feature can redirect WebSockets requests to WebSocket requests. Requests are redirected over the standard port 80.

*   **Http2**: specifies whether to turn on Enable HTTP/2. This field is optional. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on. The default value is 0.

    After you turn on the switch, HTTP/2 is used.', example='{"Http2":1,"Http2https":1,"Https2http":1}'),
  instanceIds?: [ string ](name='InstanceIds', description='An array consisting of the IDs of instances that you want to associate.

This parameter is required.'),
  proxyTypes?: [ 
    {
      proxyPorts?: [ int32 ](name='ProxyPorts', description='The port numbers.

This parameter is required.'),
      proxyType?: string(name='ProxyType', description='The type of the protocol. Valid values:

*   **http**
*   **https**
*   **websocket**
*   **websockets**', example='https'),
    }
  ](name='ProxyTypes', description='The details about the protocol type and port number.

This parameter is required.'),
  realServers?: [ string ](name='RealServers', description='An array that consists of the addresses of origin servers.

This parameter is required.'),
  rsType?: int32(name='RsType', description='The address type of the origin server. Valid values:

*   **0**: IP address

*   **1**: domain name

    If you deploy proxies, such as a Web Application Firewall (WAF) instance, between the origin server and the Anti-DDoS Pro or Anti-DDoS Premium instance, set the value to 1. If you use the domain name, you must enter the address of the proxy, such as the CNAME of WAF.

This parameter is required.', example='0'),
}

model ModifyDomainResourceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='39499F01-19D9-4EA4-A0E9-C6014BA5CDBE'),
}

model ModifyDomainResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDomainResourceResponseBody(name='body'),
}

/**
 * @summary Modifies the forwarding rule of a website.
 *
 * @param request ModifyDomainResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDomainResourceResponse
 */
async function modifyDomainResourceWithOptions(request: ModifyDomainResourceRequest, runtime: $RuntimeOptions): ModifyDomainResourceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.httpsExt)) {
    query['HttpsExt'] = request.httpsExt;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.proxyTypes)) {
    query['ProxyTypes'] = request.proxyTypes;
  }
  if (!$isNull(request.realServers)) {
    query['RealServers'] = request.realServers;
  }
  if (!$isNull(request.rsType)) {
    query['RsType'] = request.rsType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyDomainResource',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the forwarding rule of a website.
 *
 * @param request ModifyDomainResourceRequest
 * @return ModifyDomainResourceResponse
 */
async function modifyDomainResource(request: ModifyDomainResourceRequest): ModifyDomainResourceResponse {
  var runtime = new $RuntimeOptions{};
  return modifyDomainResourceWithOptions(request, runtime);
}

model ModifyElasticBandWidthRequest {
  elasticBandwidth?: int32(name='ElasticBandwidth', description='The new burstable protection bandwidth that you want to use. Unit: Gbit/s.

> You can call the [DescribeElasticBandwidthSpec](https://help.aliyun.com/document_detail/91502.html) operation to query the available burstable protection bandwidth of the instance.

This parameter is required.', example='50'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

>  The instance must be in a normal state. You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
}

model ModifyElasticBandWidthResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyElasticBandWidthResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyElasticBandWidthResponseBody(name='body'),
}

/**
 * @summary Modifies the burstable protection bandwidth of a specified Anti-DDoS Proxy (Chinese Mainland) instance.
 *
 * @description >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
 *
 * @param request ModifyElasticBandWidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyElasticBandWidthResponse
 */
async function modifyElasticBandWidthWithOptions(request: ModifyElasticBandWidthRequest, runtime: $RuntimeOptions): ModifyElasticBandWidthResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.elasticBandwidth)) {
    query['ElasticBandwidth'] = request.elasticBandwidth;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyElasticBandWidth',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the burstable protection bandwidth of a specified Anti-DDoS Proxy (Chinese Mainland) instance.
 *
 * @description >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
 *
 * @param request ModifyElasticBandWidthRequest
 * @return ModifyElasticBandWidthResponse
 */
async function modifyElasticBandWidth(request: ModifyElasticBandWidthRequest): ModifyElasticBandWidthResponse {
  var runtime = new $RuntimeOptions{};
  return modifyElasticBandWidthWithOptions(request, runtime);
}

model ModifyElasticBizBandWidthRequest {
  elasticBizBandwidth?: int32(name='ElasticBizBandwidth', description='The burstable clean bandwidth. Unit: Mbit/s. The burstable clean bandwidth cannot exceed nine times the clean bandwidth of your Anti-DDoS Pro or Anti-DDoS Premium instance, and the sum of the clean bandwidth and the burstable clean bandwidth cannot exceed the maximum clean bandwidth that is supported by your instance. The value 0 indicates that the burstable clean bandwidth feature is disabled. You can disable the burstable clean bandwidth feature once a month.

This parameter is required.', example='0'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-tl32morr****'),
  mode?: string(name='Mode', description='The metering method of the burstable clean bandwidth feature. Valid values:

*   **month**: the metering method of monthly 95th percentile
*   **day**: the metering method of daily 95th percentile', example='month'),
}

model ModifyElasticBizBandWidthResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C566BA3A-192F-5D32-8A33-21422F975145'),
}

model ModifyElasticBizBandWidthResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyElasticBizBandWidthResponseBody(name='body'),
}

/**
 * @summary Modifies the burstable clean bandwidth for an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @description Before you call this operation, make sure that you have fully understood the billing method and [pricing](https://help.aliyun.com/document_detail/283754.html) of the burstable clean bandwidth feature. After you call this operation for the first time, the modification immediately takes effect.
 *
 * @param request ModifyElasticBizBandWidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyElasticBizBandWidthResponse
 */
async function modifyElasticBizBandWidthWithOptions(request: ModifyElasticBizBandWidthRequest, runtime: $RuntimeOptions): ModifyElasticBizBandWidthResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.elasticBizBandwidth)) {
    query['ElasticBizBandwidth'] = request.elasticBizBandwidth;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.mode)) {
    query['Mode'] = request.mode;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyElasticBizBandWidth',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the burstable clean bandwidth for an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @description Before you call this operation, make sure that you have fully understood the billing method and [pricing](https://help.aliyun.com/document_detail/283754.html) of the burstable clean bandwidth feature. After you call this operation for the first time, the modification immediately takes effect.
 *
 * @param request ModifyElasticBizBandWidthRequest
 * @return ModifyElasticBizBandWidthResponse
 */
async function modifyElasticBizBandWidth(request: ModifyElasticBizBandWidthRequest): ModifyElasticBizBandWidthResponse {
  var runtime = new $RuntimeOptions{};
  return modifyElasticBizBandWidthWithOptions(request, runtime);
}

model ModifyElasticBizQpsRequest {
  instanceId?: string(name='InstanceId', description='The ID of the Anti-DDoS Proxy instance.

>  You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  mode?: string(name='Mode', description='The metering method for the burstable QPS. Valid values:

*   **month**: monthly 95th percentile
*   **day**: daily 95th percentile QPS

This parameter is required.', example='month'),
  opsElasticQps?: long(name='OpsElasticQps', description='The burstable QPS value.

>  The default value is 300,000 for the Chinese mainland and 150,000 for regions outside the Chinese mainland.', example='300000'),
}

model ModifyElasticBizQpsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID, which is used to locate and troubleshoot issues.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyElasticBizQpsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyElasticBizQpsResponseBody(name='body'),
}

/**
 * @summary Configures the burstable QPS and mode of an Anti-DDoS Proxy instance.
 *
 * @description You can enable burstable QPS only for IPv4 instances.
 *
 * @param request ModifyElasticBizQpsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyElasticBizQpsResponse
 */
async function modifyElasticBizQpsWithOptions(request: ModifyElasticBizQpsRequest, runtime: $RuntimeOptions): ModifyElasticBizQpsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!$isNull(request.opsElasticQps)) {
    query['OpsElasticQps'] = request.opsElasticQps;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyElasticBizQps',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Configures the burstable QPS and mode of an Anti-DDoS Proxy instance.
 *
 * @description You can enable burstable QPS only for IPv4 instances.
 *
 * @param request ModifyElasticBizQpsRequest
 * @return ModifyElasticBizQpsResponse
 */
async function modifyElasticBizQps(request: ModifyElasticBizQpsRequest): ModifyElasticBizQpsResponse {
  var runtime = new $RuntimeOptions{};
  return modifyElasticBizQpsWithOptions(request, runtime);
}

model ModifyFullLogTtlRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  ttl?: int32(name='Ttl', description='The log storage duration of a website. Valid values: **7** to **180**. Unit: days.

This parameter is required.', example='30'),
}

model ModifyFullLogTtlResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyFullLogTtlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyFullLogTtlResponseBody(name='body'),
}

/**
 * @summary Modifies the log storage duration for Anti-DDoS Proxy.
 *
 * @param request ModifyFullLogTtlRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyFullLogTtlResponse
 */
async function modifyFullLogTtlWithOptions(request: ModifyFullLogTtlRequest, runtime: $RuntimeOptions): ModifyFullLogTtlResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.ttl)) {
    query['Ttl'] = request.ttl;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyFullLogTtl',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the log storage duration for Anti-DDoS Proxy.
 *
 * @param request ModifyFullLogTtlRequest
 * @return ModifyFullLogTtlResponse
 */
async function modifyFullLogTtl(request: ModifyFullLogTtlRequest): ModifyFullLogTtlResponse {
  var runtime = new $RuntimeOptions{};
  return modifyFullLogTtlWithOptions(request, runtime);
}

model ModifyHeadersRequest {
  customHeaders?: string(name='CustomHeaders', description='The key-value pair of the custom header. The key specifies the header name, and the value specifies the header value. You can specify up to five key-value pairs. The key-value pairs can be up to 200 characters in length.

Take note of the following items:

*   Do not use the following default HTTP headers:

    *   X-Forwarded-ClientSrcPort: This header is used to obtain the source ports of clients that access Anti-DDoS Proxy (a Layer 7 proxy).
    *   X-Forwarded-ProxyPort: This header is used to obtain the ports of listeners that access Anti-DDoS Proxy (a Layer 7 proxy).
    *   X-Forwarded-For: This header is used to obtain the IP addresses of clients that access Anti-DDoS Proxy (a Layer 7 proxy).

*   Do not use standard HTTP headers or specific widely used custom HTTP headers. The standard HTTP headers include Host, User-Agent, Connection, and Upgrade, and the widely used custom HTTP headers include X-Real-IP, X-True-IP, X-Client-IP, Web-Server-Type, WL-Proxy-Client-IP, eEagleEye-RpcID, EagleEye-TraceID, X-Forwarded-Cluster, and X-Forwarded-Proto. If the preceding headers are used, the original content of the headers is overwritten.

>  If you specify a key of X-Forwarded-ClientSrcPort, the system obtains the originating ports of clients that access Anti-DDoS Proxy (a Layer 7 proxy). In this case, the value is an empty string.

This parameter is required.', example='{\\\\"X-Forwarded-ClientSrcPort\\\\":\\\\"\\\\"}'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='example.aliyundoc.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.

> 

*   You can query resource group IDs in the Anti-DDoS Pro or Anti-DDoS Premium console or by calling the [ListResourceGroups](https://help.aliyun.com/document_detail/158855.html) operation. For more information, see [View basic information of a resource group](https://help.aliyun.com/document_detail/151181.html).

*   Before you modify the resource group to which an instance belongs, you can call the [ListResources](https://help.aliyun.com/document_detail/158866.html) operation to view the current resource group of the instance.', example='rg-acfmz6jbof5****'),
}

model ModifyHeadersResponseBody = {
  requestId?: string(name='RequestId', description='The unique ID of the request, which is used to locate and troubleshoot issues.', example='DC38A1D3-C042-5670-8394-8F6B1FA97B5E'),
}

model ModifyHeadersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyHeadersResponseBody(name='body'),
}

/**
 * @summary Modifies the custom header of a domain name that is added to an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request ModifyHeadersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyHeadersResponse
 */
async function modifyHeadersWithOptions(request: ModifyHeadersRequest, runtime: $RuntimeOptions): ModifyHeadersResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.customHeaders)) {
    query['CustomHeaders'] = request.customHeaders;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyHeaders',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the custom header of a domain name that is added to an Anti-DDoS Pro or Anti-DDoS Premium instance.
 *
 * @param request ModifyHeadersRequest
 * @return ModifyHeadersResponse
 */
async function modifyHeaders(request: ModifyHeadersRequest): ModifyHeadersResponse {
  var runtime = new $RuntimeOptions{};
  return modifyHeadersWithOptions(request, runtime);
}

model ModifyHealthCheckConfigRequest {
  forwardProtocol?: string(name='ForwardProtocol', description='The forwarding protocol. Valid values:

*   **tcp**
*   **udp**

This parameter is required.', example='tcp'),
  frontendPort?: int32(name='FrontendPort', description='The forwarding port.

This parameter is required.', example='8080'),
  healthCheck?: string(name='HealthCheck', description='The details of the health check configuration. This parameter is a JSON string. The string contains the following fields:

*   **Type**: the protocol type. This field is required and must be of the STRING type. Valid values: **tcp** (Layer 4) and **http** (Layer 7).

*   **Domain**: the domain name, which must be of the STRING type.

    **

    **Note**This parameter is returned only when the Layer 7 health check configuration is queried.

*   **Uri**: the check path, which must be of the STRING type.

    **

    **Note**This parameter is returned only when the Layer 7 health check configuration is queried.

*   **Timeout**: the response timeout period, which must be of the INTEGER type. Valid values: **1** to **30**. Unit: seconds.

*   **Port**: the port on which you want to perform the health check, which must be of the INTEGER type.

*   **Interval**: the health check interval, which must be of the INTEGER type. Valid values: **1** to **30**. Unit: seconds.

*   **Up**: the number of consecutive successful health checks that must occur before declaring a port healthy, which must be of the INTEGER type. Valid values: **1** to **10**.

*   **Down**: the number of consecutive failed health checks that must occur before declaring a port unhealthy, which must be of the INTEGER type. Valid values: **1** to **10**.

This parameter is required.', example='{"Type":"tcp","Timeout":10,"Port":8080,"Interval":10,"Up":10,"Down":40}'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
}

model ModifyHealthCheckConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyHealthCheckConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyHealthCheckConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the Layer 4 or Layer 7 health check configuration of a port forwarding rule.
 *
 * @param request ModifyHealthCheckConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyHealthCheckConfigResponse
 */
async function modifyHealthCheckConfigWithOptions(request: ModifyHealthCheckConfigRequest, runtime: $RuntimeOptions): ModifyHealthCheckConfigResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.forwardProtocol)) {
    query['ForwardProtocol'] = request.forwardProtocol;
  }
  if (!$isNull(request.frontendPort)) {
    query['FrontendPort'] = request.frontendPort;
  }
  if (!$isNull(request.healthCheck)) {
    query['HealthCheck'] = request.healthCheck;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyHealthCheckConfig',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the Layer 4 or Layer 7 health check configuration of a port forwarding rule.
 *
 * @param request ModifyHealthCheckConfigRequest
 * @return ModifyHealthCheckConfigResponse
 */
async function modifyHealthCheckConfig(request: ModifyHealthCheckConfigRequest): ModifyHealthCheckConfigResponse {
  var runtime = new $RuntimeOptions{};
  return modifyHealthCheckConfigWithOptions(request, runtime);
}

model ModifyHttp2EnableRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name, and the domain name must be associated with an instance that uses the Enhanced function plan. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  enable?: int32(name='Enable', description='Specifies whether to enable HTTP/2. Valid values:

*   **0**: disables HTTP/2.
*   **1**: enables HTTP/2.

This parameter is required.', example='1'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model ModifyHttp2EnableResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model ModifyHttp2EnableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyHttp2EnableResponseBody(name='body'),
}

/**
 * @summary Enables or disables HTTP/2 for the forwarding rule of a website.
 *
 * @description >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
 *
 * @param request ModifyHttp2EnableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyHttp2EnableResponse
 */
async function modifyHttp2EnableWithOptions(request: ModifyHttp2EnableRequest, runtime: $RuntimeOptions): ModifyHttp2EnableResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyHttp2Enable',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables HTTP/2 for the forwarding rule of a website.
 *
 * @description >  This operation is suitable only for Anti-DDoS Proxy (Chinese Mainland).
 *
 * @param request ModifyHttp2EnableRequest
 * @return ModifyHttp2EnableResponse
 */
async function modifyHttp2Enable(request: ModifyHttp2EnableRequest): ModifyHttp2EnableResponse {
  var runtime = new $RuntimeOptions{};
  return modifyHttp2EnableWithOptions(request, runtime);
}

model ModifyInstanceRequest {
  addressType?: string(name='AddressType', description='Address type. Values:
- **Ipv4**: IPv4.
- **Ipv6**: IPv6.', example='Ipv4'),
  bandwidth?: string(name='Bandwidth', description='Elastic protection bandwidth (Mainland China). Unit: Gbps.', example='30'),
  baseBandwidth?: string(name='BaseBandwidth', description='Guaranteed protection bandwidth (Mainland China). Unit: Gbps.', example='30'),
  domainCount?: string(name='DomainCount', description='Number of protected domains.', example='50'),
  editionSale?: string(name='EditionSale', description='Protection package (Mainland China). Values:

- **coop**: Indicates the DDoS High Defense (Mainland China) Professional Edition.
- **advance**: Indicates the DDoS High Defense (Mainland China) Professional Edition.', example='coop'),
  functionVersion?: string(name='FunctionVersion', description='Function version, with values:

- **0**: Standard function.
- **1**: Enhanced function.', example='0'),
  instanceId?: string(name='InstanceId', description='The ID of the DDoS High Defense instance.
> You can call [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) to query the ID information of all DDoS High Defense instances.

This parameter is required.', example='ddoscoo-cn-6ja1y6p5****'),
  modifyType?: string(name='ModifyType', description='Adjustment type, with values
- UPGRADE: Upgrade.
- DOWNGRADE: Downgrade.

This parameter is required.', example='Upgrade'),
  normalBandwidth?: string(name='NormalBandwidth', description='Business bandwidth (outside Mainland China). Unit: Mbps.', example='200'),
  normalQps?: string(name='NormalQps', description='Business QPS. Unit: Mbps.', example='100'),
  portCount?: string(name='PortCount', description='Number of protected ports.', example='50'),
  productPlan?: string(name='ProductPlan', description='Protection package (outside Mainland China). Values:

- **0**: Indicates the DDoS High Defense (outside Mainland China) Insurance Edition.
- **1**: Indicates the DDoS High Defense (outside Mainland China) Worry-Free Edition.
- **2**: Indicates the DDoS High Defense (outside Mainland China) Acceleration Line.
- **3**: Indicates the DDoS High Defense (outside Mainland China) Secure Acceleration Line.', example='0'),
  productType?: string(name='ProductType', description='Product type.
Values:

- **ddoscoo**: Indicates that the DDoS High Defense (Mainland China) instance is being adjusted for a China site account.
- **ddoscoo_intl**: Indicates that the DDoS High Defense (Mainland China) instance is being adjusted for an international site account.
- **ddosDip**: Indicates that the DDoS High Defense (outside Mainland China) instance is being adjusted for either a China or international site account.

This parameter is required.', example='ddoscoo'),
  serviceBandwidth?: string(name='ServiceBandwidth', description='Business bandwidth (Mainland China). Unit: Mbps.', example='300'),
  servicePartner?: string(name='ServicePartner', description='Line resources of the instance (Mainland China). Values:

- **coop-line-001**: Indicates the DDoS High Defense (Mainland China) 8-line BGP line.', example='coop-line-001'),
}

model ModifyInstanceResponseBody = {
  orderId?: long(name='OrderId', description='Order ID.', example='242461444340562'),
  requestId?: string(name='RequestId', description='The ID of this request, which is a unique identifier generated by Alibaba Cloud for this request and can be used for troubleshooting and problem localization.', example='0018DF77-7189-5D33-947B-E5B34BFCE07E'),
}

model ModifyInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyInstanceResponseBody(name='body'),
}

/**
 * @summary Instance adjustment, similar to BSS adjustment
 *
 * @param request ModifyInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyInstanceResponse
 */
async function modifyInstanceWithOptions(request: ModifyInstanceRequest, runtime: $RuntimeOptions): ModifyInstanceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.addressType)) {
    query['AddressType'] = request.addressType;
  }
  if (!$isNull(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!$isNull(request.baseBandwidth)) {
    query['BaseBandwidth'] = request.baseBandwidth;
  }
  if (!$isNull(request.domainCount)) {
    query['DomainCount'] = request.domainCount;
  }
  if (!$isNull(request.editionSale)) {
    query['EditionSale'] = request.editionSale;
  }
  if (!$isNull(request.functionVersion)) {
    query['FunctionVersion'] = request.functionVersion;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.modifyType)) {
    query['ModifyType'] = request.modifyType;
  }
  if (!$isNull(request.normalBandwidth)) {
    query['NormalBandwidth'] = request.normalBandwidth;
  }
  if (!$isNull(request.normalQps)) {
    query['NormalQps'] = request.normalQps;
  }
  if (!$isNull(request.portCount)) {
    query['PortCount'] = request.portCount;
  }
  if (!$isNull(request.productPlan)) {
    query['ProductPlan'] = request.productPlan;
  }
  if (!$isNull(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!$isNull(request.serviceBandwidth)) {
    query['ServiceBandwidth'] = request.serviceBandwidth;
  }
  if (!$isNull(request.servicePartner)) {
    query['ServicePartner'] = request.servicePartner;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyInstance',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Instance adjustment, similar to BSS adjustment
 *
 * @param request ModifyInstanceRequest
 * @return ModifyInstanceResponse
 */
async function modifyInstance(request: ModifyInstanceRequest): ModifyInstanceResponse {
  var runtime = new $RuntimeOptions{};
  return modifyInstanceWithOptions(request, runtime);
}

model ModifyInstanceRemarkRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  remark?: string(name='Remark', description='The description of the instance.

The value can contain letters, digits, and some special characters, such as`, . + - * / _` The value can be up to 500 characters in length.

This parameter is required.', example='new-remark'),
}

model ModifyInstanceRemarkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='7EFA2BA6-9C0A-4410-B735-FC337EB634A1'),
}

model ModifyInstanceRemarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyInstanceRemarkResponseBody(name='body'),
}

/**
 * @summary Modifies the description of an Anti-DDoS Proxy instance.
 *
 * @param request ModifyInstanceRemarkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyInstanceRemarkResponse
 */
async function modifyInstanceRemarkWithOptions(request: ModifyInstanceRemarkRequest, runtime: $RuntimeOptions): ModifyInstanceRemarkResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.remark)) {
    query['Remark'] = request.remark;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyInstanceRemark',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the description of an Anti-DDoS Proxy instance.
 *
 * @param request ModifyInstanceRemarkRequest
 * @return ModifyInstanceRemarkResponse
 */
async function modifyInstanceRemark(request: ModifyInstanceRemarkRequest): ModifyInstanceRemarkResponse {
  var runtime = new $RuntimeOptions{};
  return modifyInstanceRemarkWithOptions(request, runtime);
}

model ModifyNetworkRuleAttributeRequest {
  config?: string(name='Config', description='The detailed settings of the port forwarding rule. This parameter is a JSON string and contains the following fields. The detailed settings of a TCP port forwarding rule contain the following fields.

*   **PersistenceTimeout**: the timeout period of session persistence. This field is required and of the integer type. Valid values: **30** to **3600**. Unit: seconds. Default value: **0**, which indicates that session persistence is disabled.
*   **Synproxy**: specifies whether to enable the false source feature in the DDoS mitigation policy. This field is required and of the string type. Valid values: off and on.
*   **NodataConn**: specifies whether to enable the empty connection feature in the DDoS mitigation policy. This field is required and of the string type. Valid values: off and on.
*   **Sla**: the settings of the speed limit for destination feature. This field is required and of the struct type. For more information, see the following description about Sla.
*   **Slimit**: the settings of the rate limit for source feature. This field is required and of the struct type. For more information, see the following description about Slimit.
*   **PayloadLen**: the settings of the packet length limit feature. This field is required and of the struct type. For more information, see the following description about PayloadLen.

Sla contains the following fields:

*   **Cps**: the destination rate limit on new connections in the DDoS mitigation policy. This field is required and of the integer type. Valid values: 100 to 100000.
*   **Maxconn**: the destination rate limit on concurrent connections in the DDoS mitigation policy. This field is required and of the integer type. Valid values: 1000 to 1000000.
*   **CpsEnable**: specifies whether to enable Cps. This field is required and of the integer type. Valid values: 0 and 1. Default value: 1. The value 0 indicates that Cps is disabled, and the value 1 indicates that Cps is enabled.
*   **MaxconnEnable**: specifies whether to enable Maxconn. This field is required and of the integer type. Valid values: 0 and 1. Default value: 1. The value 0 indicates that Maxconn is disabled, and the value 1 indicates that Maxconn is enabled.

Slimit contains the following fields:

*   **Cps**: the source rate limit on new connections in the DDoS mitigation policy. This field is required and of the integer type. Valid values: 1 to 50000.
*   **Maxconn**: the source rate limit on concurrent connections in the DDoS mitigation policy. This field is required and of the integer type. Valid values: 1 to 50000.
*   **CpsEnable**: specifies whether to enable Cps. This field is required and of the integer type. Valid values: 0 and 1. Default value: 1. The value 0 indicates that Cps is disabled, and the value 1 indicates that Cps is enabled.
*   **MaxconnEnable**: specifies whether to enable Maxconn. This field is required and of the integer type. Valid values: 0 and 1. Default value: 1. The value 0 indicates that Maxconn is disabled, and the value 1 indicates that Maxconn is enabled.
*   **CpsMode**: specifies whether to enable the source rate limit on new connections. This field is required and of the integer type. Valid values: 1 and 2. The value 1 indicates that the source rate limit is disabled. The value 2 indicates that the system determines whether to enable the source rate limit.

PayloadLen contains the following fields:

*   **Min**: the minimum packet length in the DDoS mitigation policy. This field is required and of the integer type. Valid values: 0 to 1500.
*   **Max**: the maximum packet length in the DDoS mitigation policy. This field is required and of the integer type. Valid values: 0 to 1500.

This parameter is required.', example='{"PersistenceTimeout":900}'),
  forwardProtocol?: string(name='ForwardProtocol', description='The forwarding protocol. Valid values:

*   **tcp**
*   **udp**

This parameter is required.', example='tcp'),
  frontendPort?: int32(name='FrontendPort', description='The forwarding port.

This parameter is required.', example='8080'),
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
}

model ModifyNetworkRuleAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyNetworkRuleAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyNetworkRuleAttributeResponseBody(name='body'),
}

/**
 * @summary Modifies the session persistence and DDoS mitigation policy settings of a port forwarding rule.
 *
 * @param request ModifyNetworkRuleAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyNetworkRuleAttributeResponse
 */
async function modifyNetworkRuleAttributeWithOptions(request: ModifyNetworkRuleAttributeRequest, runtime: $RuntimeOptions): ModifyNetworkRuleAttributeResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.config)) {
    query['Config'] = request.config;
  }
  if (!$isNull(request.forwardProtocol)) {
    query['ForwardProtocol'] = request.forwardProtocol;
  }
  if (!$isNull(request.frontendPort)) {
    query['FrontendPort'] = request.frontendPort;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyNetworkRuleAttribute',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the session persistence and DDoS mitigation policy settings of a port forwarding rule.
 *
 * @param request ModifyNetworkRuleAttributeRequest
 * @return ModifyNetworkRuleAttributeResponse
 */
async function modifyNetworkRuleAttribute(request: ModifyNetworkRuleAttributeRequest): ModifyNetworkRuleAttributeResponse {
  var runtime = new $RuntimeOptions{};
  return modifyNetworkRuleAttributeWithOptions(request, runtime);
}

model ModifyOcspStatusRequest {
  domain?: string(name='Domain', description='The domain name for which you want to configure the Static Page Caching policy.

> You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.

This parameter is required.', example='click.linktech.cn'),
  enable?: int32(name='Enable', description='Specifies whether to enable the OCSP feature. Valid values:

*   **1**: yes.
*   **0**: no.

This parameter is required.', example='1'),
}

model ModifyOcspStatusResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='D8DDBA8E-8182-5C85-AA41-F17EACFCAE0D'),
}

model ModifyOcspStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyOcspStatusResponseBody(name='body'),
}

/**
 * @summary Specifies whether to enable the Online Certificate Status Protocol (OCSP) feature.
 *
 * @description This feature is available only for a website that supports HTTPS. If HTTPS is selected for Protocol, we recommend that you enable this feature.
 *
 * @param request ModifyOcspStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyOcspStatusResponse
 */
async function modifyOcspStatusWithOptions(request: ModifyOcspStatusRequest, runtime: $RuntimeOptions): ModifyOcspStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.enable)) {
    query['Enable'] = request.enable;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyOcspStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Specifies whether to enable the Online Certificate Status Protocol (OCSP) feature.
 *
 * @description This feature is available only for a website that supports HTTPS. If HTTPS is selected for Protocol, we recommend that you enable this feature.
 *
 * @param request ModifyOcspStatusRequest
 * @return ModifyOcspStatusResponse
 */
async function modifyOcspStatus(request: ModifyOcspStatusRequest): ModifyOcspStatusResponse {
  var runtime = new $RuntimeOptions{};
  return modifyOcspStatusWithOptions(request, runtime);
}

model ModifyPortRequest {
  backendPort?: string(name='BackendPort', description='The port of the origin server. Valid values: **0** to **65535**.

This parameter is required.', example='55'),
  frontendPort?: string(name='FrontendPort', description='The forwarding port. Valid values: **0** to **65535**.

This parameter is required.', example='55'),
  frontendProtocol?: string(name='FrontendProtocol', description='The type of the forwarding protocol. Valid values:

*   **tcp**
*   **udp**

This parameter is required.', example='tcp'),
  instanceId?: string(name='InstanceId', description='The ID of the Anti-DDoS Pro or Anti-DDoS Premium instance to which the port forwarding rule belongs.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-st21zbyq****'),
  proxyEnable?: long(name='ProxyEnable'),
  realServers?: [ string ](name='RealServers', description='An array that consists of the IP addresses of origin servers.

This parameter is required.'),
}

model ModifyPortResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='39499F01-19D9-4EA4-A0E9-C6014BA5CDBE'),
}

model ModifyPortResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyPortResponseBody(name='body'),
}

/**
 * @summary Modifies a port forwarding rule.
 *
 * @description You can call the ModifyPort operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
 *
 * @param request ModifyPortRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPortResponse
 */
async function modifyPortWithOptions(request: ModifyPortRequest, runtime: $RuntimeOptions): ModifyPortResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.backendPort)) {
    query['BackendPort'] = request.backendPort;
  }
  if (!$isNull(request.frontendPort)) {
    query['FrontendPort'] = request.frontendPort;
  }
  if (!$isNull(request.frontendProtocol)) {
    query['FrontendProtocol'] = request.frontendProtocol;
  }
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.proxyEnable)) {
    query['ProxyEnable'] = request.proxyEnable;
  }
  if (!$isNull(request.realServers)) {
    query['RealServers'] = request.realServers;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyPort',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies a port forwarding rule.
 *
 * @description You can call the ModifyPort operation by using Terraform. For more information about Terraform, see [What is Terraform?](https://help.aliyun.com/document_detail/95820.html).
 *
 * @param request ModifyPortRequest
 * @return ModifyPortResponse
 */
async function modifyPort(request: ModifyPortRequest): ModifyPortResponse {
  var runtime = new $RuntimeOptions{};
  return modifyPortWithOptions(request, runtime);
}

model ModifyPortAutoCcStatusRequest {
  instanceId?: string(name='InstanceId', description='The ID of the instance.

> You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
  mode?: string(name='Mode', description='The mode of the Intelligent Protection policy. Valid values:

*   **normal**
*   **loose**
*   **strict**

This parameter is required.', example='normal'),
  switch?: string(name='Switch', description='Specifies the status of the Intelligent Protection policy. Valid values:

*   **on**: enables the policy.
*   **off**: disables the policy.

This parameter is required.', example='on'),
}

model ModifyPortAutoCcStatusResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyPortAutoCcStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyPortAutoCcStatusResponseBody(name='body'),
}

/**
 * @summary Modifies the Intelligent Protection configuration of a non-website service.
 *
 * @param request ModifyPortAutoCcStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPortAutoCcStatusResponse
 */
async function modifyPortAutoCcStatusWithOptions(request: ModifyPortAutoCcStatusRequest, runtime: $RuntimeOptions): ModifyPortAutoCcStatusResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!$isNull(request.switch)) {
    query['Switch'] = request.switch;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyPortAutoCcStatus',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the Intelligent Protection configuration of a non-website service.
 *
 * @param request ModifyPortAutoCcStatusRequest
 * @return ModifyPortAutoCcStatusResponse
 */
async function modifyPortAutoCcStatus(request: ModifyPortAutoCcStatusRequest): ModifyPortAutoCcStatusResponse {
  var runtime = new $RuntimeOptions{};
  return modifyPortAutoCcStatusWithOptions(request, runtime);
}

model ModifyQpsModeRequest {
  instanceId?: string(name='InstanceId', description='The region ID of the Anti-DDoS Pro instance.

>  You can call the [DescribeInstanceIds](https://help.aliyun.com/document_detail/157459.html) operation to query the IDs of all instances.

This parameter is required.', example='ddoscoo-cn-7e225i41****'),
  mode?: string(name='Mode', description='The metering method of QPS. Valid values:

*   **month**: monthly 95th percentile QPS.
*   **day**: daily 95th percentile QPS.

This parameter is required.', example='month'),
}

model ModifyQpsModeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID, which is used to locate and troubleshoot issues.', example='48859E14-A9FB-4100-99FF-AAB75CA46776'),
}

model ModifyQpsModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyQpsModeResponseBody(name='body'),
}

/**
 * @summary Switches between the metering methods of the burstable clean bandwidth feature.
 *
 * @param request ModifyQpsModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyQpsModeResponse
 */
async function modifyQpsModeWithOptions(request: ModifyQpsModeRequest, runtime: $RuntimeOptions): ModifyQpsModeResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!$isNull(request.mode)) {
    query['Mode'] = request.mode;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyQpsMode',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Switches between the metering methods of the burstable clean bandwidth feature.
 *
 * @param request ModifyQpsModeRequest
 * @return ModifyQpsModeResponse
 */
async function modifyQpsMode(request: ModifyQpsModeRequest): ModifyQpsModeResponse {
  var runtime = new $RuntimeOptions{};
  return modifyQpsModeWithOptions(request, runtime);
}

model ModifySceneDefensePolicyRequest {
  endTime?: long(name='EndTime', description='The end time of the policy. The value is a UNIX timestamp. Unit: milliseconds.

This parameter is required.', example='1586016000000'),
  name?: string(name='Name', description='The name of the policy.

This parameter is required.', example='testpolicy'),
  policyId?: string(name='PolicyId', description='The ID of the policy that you want to modify.

> You can call the [DescribeSceneDefensePolicies](https://help.aliyun.com/document_detail/159382.html) operation to query the IDs of all policies.

This parameter is required.', example='321a-fd31-df51-****'),
  startTime?: long(name='StartTime', description='The start time of the policy. The value is a UNIX timestamp. Unit: milliseconds.

This parameter is required.', example='1585670400000'),
  template?: string(name='Template', description='The template of the policy. Valid values:

*   **promotion**: important activity.
*   **bypass**: all traffic forwarded.

This parameter is required.', example='promotion'),
}

model ModifySceneDefensePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F65DF043-E0EB-4796-9467-23DDCDF92C1D'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   **true**: yes
*   **false**: no', example='true'),
}

model ModifySceneDefensePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySceneDefensePolicyResponseBody(name='body'),
}

/**
 * @summary Modifies a scenario-specific custom policy.
 *
 * @param request ModifySceneDefensePolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySceneDefensePolicyResponse
 */
async function modifySceneDefensePolicyWithOptions(request: ModifySceneDefensePolicyRequest, runtime: $RuntimeOptions): ModifySceneDefensePolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.policyId)) {
    query['PolicyId'] = request.policyId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!$isNull(request.template)) {
    query['Template'] = request.template;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifySceneDefensePolicy',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies a scenario-specific custom policy.
 *
 * @param request ModifySceneDefensePolicyRequest
 * @return ModifySceneDefensePolicyResponse
 */
async function modifySceneDefensePolicy(request: ModifySceneDefensePolicyRequest): ModifySceneDefensePolicyResponse {
  var runtime = new $RuntimeOptions{};
  return modifySceneDefensePolicyWithOptions(request, runtime);
}

model ModifySchedulerRuleRequest {
  param?: string(name='Param', description='The details of the CDN interaction rule. This parameter is a JSON string. The string contains the following fields:

*   **ParamType**: the type of the scheduling rule. This field is required and must be of the string type. Set the value to **cdn**. This indicates that you want to modify a CDN interaction rule.

*   **ParamData**: the values of parameters that you want to modify for the CDN interaction rule. This field is required and must be of the map type. The ParamData parameter contains the following parameters:

    *   **Domain**: the accelerated domain in CDN. This parameter is required and must be of the string type.
    *   **Cname**: the CNAME that is assigned to the accelerated domain. This parameter is required and must be of the string type.
    *   **AccessQps**: the queries per second (QPS) threshold that is used to switch service traffic to Anti-DDoS Pro or Anti-DDoS Premium. This parameter is required and must be of the integer type.
    *   **UpstreamQps**: the QPS threshold that is used to switch service traffic to CDN. This parameter is optional and must be of the integer type.', example='{"ParamType":"cdn","ParamData":"Domain":"example.aliyundoc.com","Cname":"demo.aliyundoc.com","AccessQps":100,"UpstreamQps":100}}'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  ruleName?: string(name='RuleName', description='The name of the rule that you want to modify.

This parameter is required.', example='testrule'),
  ruleType?: int32(name='RuleType', description='The type of the scheduling rule. Valid values:

*   **2**: tiered protection
*   **3**: network acceleration
*   **5**: CDN interaction
*   **6**: cloud service interaction
*   **8**: secure acceleration

This parameter is required.', example='2'),
  rules?: string(name='Rules', description='The details of the scheduling rule. This parameter is a JSON string. The following list describes the fields in the value of the parameter:

*   **Type**: the address type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type. Valid values:

    *   **A**: IP address
    *   **CNAME**: domain name

*   **Value**: the address of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type.

*   **Priority**: the priority of the scheduling rule. This field is required and must be of the integer type. Valid values: **0** to **100**. A larger value indicates a higher priority.

*   **ValueType**: the type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the integer type. Valid values:

    *   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
    *   **2**: the IP address of the interaction resource in the tiered protection scenario
    *   **3**: the IP address that is used to accelerate access in the network acceleration scenario
    *   **5**: the domain name that is configured in Alibaba Cloud CDN (CDN) in the CDN interaction scenario
    *   **6** the IP address of the interaction resource in the cloud service interaction scenario
    *   **8**: the IP address of the Secure Chinese Mainland Acceleration (Sec-CMA) instance in the secure acceleration scenario

*   **RegionId**: the region where the interaction resource is deployed. This parameter must be specified when **ValueType** is set to **2**. The value must be of the string type.

This parameter is required.', example='[{"Type":"A", "Value":"1.1.XX.XX", "Priority":80,"ValueType":2, "RegionId":"cn-hangzhou" },{"Type":"A", "Value":"203.199.XX.XX", "Priority":80,"ValueType":1}]'),
}

model ModifySchedulerRuleResponseBody = {
  cname?: string(name='Cname', description='The CNAME that is assigned by Sec-Traffic Manager for the scheduling rule.

> To enable the scheduling rule, you must map the domain name of the service to the CNAME.', example='48k7b372gpl4****.aliyunddos0001.com'),
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='FFC77501-BDF8-4BC8-9BF5-B295FBC3189B'),
  ruleName?: string(name='RuleName', description='The name of the rule.', example='testrule'),
}

model ModifySchedulerRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySchedulerRuleResponseBody(name='body'),
}

/**
 * @summary Modifies the scheduling rule of Sec-Traffic Manager.
 *
 * @param request ModifySchedulerRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySchedulerRuleResponse
 */
async function modifySchedulerRuleWithOptions(request: ModifySchedulerRuleRequest, runtime: $RuntimeOptions): ModifySchedulerRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.param)) {
    query['Param'] = request.param;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!$isNull(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!$isNull(request.rules)) {
    query['Rules'] = request.rules;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifySchedulerRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the scheduling rule of Sec-Traffic Manager.
 *
 * @param request ModifySchedulerRuleRequest
 * @return ModifySchedulerRuleResponse
 */
async function modifySchedulerRule(request: ModifySchedulerRuleRequest): ModifySchedulerRuleResponse {
  var runtime = new $RuntimeOptions{};
  return modifySchedulerRuleWithOptions(request, runtime);
}

model ModifyTlsConfigRequest {
  config?: string(name='Config', description='The details of the TLS policy. The value is a JSON string that contains the following fields:

*   **ssl_protocols**: the version of TLS. This field is required. Data type: string. Valid values:

    *   **tls1.0**: TLS 1.0 and later
    *   **tls1.1**: TLS 1.1 and later
    *   **tls1.2**: TLS 1.2 and later

*   **ssl_ciphers**: the type of the cipher suite. This field is required. Data type: string. Valid values:

    *   **all**: all cipher suites, which include strong and weak cipher suites
    *   **improved**: enhanced cipher suites
    *   **strong**: strong cipher suites
    *   **default**: default cipher suites, which include only strong cipher suites

This parameter is required.', example='{"ssl_protocols":"tls1.0","ssl_ciphers":"all"}'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='example.aliyundoc.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model ModifyTlsConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='C33EB3D5-AF96-43CA-9C7E-37A81BC06A1E'),
}

model ModifyTlsConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyTlsConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the Transport Layer Security (TLS) policy configuration for the forwarding rule of a website.
 *
 * @param request ModifyTlsConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyTlsConfigResponse
 */
async function modifyTlsConfigWithOptions(request: ModifyTlsConfigRequest, runtime: $RuntimeOptions): ModifyTlsConfigResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.config)) {
    query['Config'] = request.config;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyTlsConfig',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the Transport Layer Security (TLS) policy configuration for the forwarding rule of a website.
 *
 * @param request ModifyTlsConfigRequest
 * @return ModifyTlsConfigResponse
 */
async function modifyTlsConfig(request: ModifyTlsConfigRequest): ModifyTlsConfigResponse {
  var runtime = new $RuntimeOptions{};
  return modifyTlsConfigWithOptions(request, runtime);
}

model ModifyWebAIProtectModeRequest {
  config?: string(name='Config', description='The details of the Intelligent Protection policy. This parameter is a JSON string. The string contains the following fields:

*   **AiTemplate**: the level of the Intelligent Protection policy. This field is required and must be of the STRING type. Valid values:

    *   **level30**: the Low level
    *   **level60**: the Normal level
    *   **level90**: the Strict level

*   **AiMode**: the mode of the Intelligent Protection policy. This field is required and must be of the string type. Valid values:

    *   **watch**: the Warning mode
    *   **defense**: the Defense mode

This parameter is required.', example='{"AiTemplate":"level60","AiMode":"defense"}'),
  domain?: string(name='Domain', description='The domain name of the website.

>  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/474212.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model ModifyWebAIProtectModeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebAIProtectModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebAIProtectModeResponseBody(name='body'),
}

/**
 * @summary Changes the mode of the intelligent protection feature for a website.
 *
 * @param request ModifyWebAIProtectModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebAIProtectModeResponse
 */
async function modifyWebAIProtectModeWithOptions(request: ModifyWebAIProtectModeRequest, runtime: $RuntimeOptions): ModifyWebAIProtectModeResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.config)) {
    query['Config'] = request.config;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyWebAIProtectMode',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Changes the mode of the intelligent protection feature for a website.
 *
 * @param request ModifyWebAIProtectModeRequest
 * @return ModifyWebAIProtectModeResponse
 */
async function modifyWebAIProtectMode(request: ModifyWebAIProtectModeRequest): ModifyWebAIProtectModeResponse {
  var runtime = new $RuntimeOptions{};
  return modifyWebAIProtectModeWithOptions(request, runtime);
}

model ModifyWebAIProtectSwitchRequest {
  config?: string(name='Config', description='The details of the Intelligent Protection policy. This parameter is a JSON string. The string contains the following fields:

*   **AiRuleEnable**: the status of the Intelligent Protection policy. This field is required and must be of the integer type. Valid values:

    *   **0**: disabled
    *   **1**: enabled

This parameter is required.', example='{"AiRuleEnable": 1}'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model ModifyWebAIProtectSwitchResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebAIProtectSwitchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebAIProtectSwitchResponseBody(name='body'),
}

/**
 * @summary Enables or disables the Intelligent Protection policy for a website.
 *
 * @param request ModifyWebAIProtectSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebAIProtectSwitchResponse
 */
async function modifyWebAIProtectSwitchWithOptions(request: ModifyWebAIProtectSwitchRequest, runtime: $RuntimeOptions): ModifyWebAIProtectSwitchResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.config)) {
    query['Config'] = request.config;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyWebAIProtectSwitch',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables the Intelligent Protection policy for a website.
 *
 * @param request ModifyWebAIProtectSwitchRequest
 * @return ModifyWebAIProtectSwitchResponse
 */
async function modifyWebAIProtectSwitch(request: ModifyWebAIProtectSwitchRequest): ModifyWebAIProtectSwitchResponse {
  var runtime = new $RuntimeOptions{};
  return modifyWebAIProtectSwitchWithOptions(request, runtime);
}

model ModifyWebAccessModeRequest {
  accessMode?: int32(name='AccessMode', description='The mode in which a website service is added to Anti-DDoS Pro or Anti-DDoS Premium. Valid values:

*   **0**: A record mode
*   **1**: anti-DDoS mode
*   **2**: origin redundancy mode

This parameter is required.', example='2'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
}

model ModifyWebAccessModeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebAccessModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebAccessModeResponseBody(name='body'),
}

/**
 * @summary Changes the mode in which a website service is added to Anti-DDoS Pro or Anti-DDoS Premium.
 *
 * @param request ModifyWebAccessModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebAccessModeResponse
 */
async function modifyWebAccessModeWithOptions(request: ModifyWebAccessModeRequest, runtime: $RuntimeOptions): ModifyWebAccessModeResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessMode)) {
    query['AccessMode'] = request.accessMode;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyWebAccessMode',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Changes the mode in which a website service is added to Anti-DDoS Pro or Anti-DDoS Premium.
 *
 * @param request ModifyWebAccessModeRequest
 * @return ModifyWebAccessModeResponse
 */
async function modifyWebAccessMode(request: ModifyWebAccessModeRequest): ModifyWebAccessModeResponse {
  var runtime = new $RuntimeOptions{};
  return modifyWebAccessModeWithOptions(request, runtime);
}

model ModifyWebAreaBlockRequest {
  domain?: string(name='Domain', description='The domain name whose configurations you want to modify.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  regions?: [ string ](name='Regions', description='The regions from which you block requests.

> If you do not configure this parameter, the Blocked Regions (Domain Names) policy is disabled.', example='CN-SHANGHAI'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).', example='rg-acfm2pz25js****'),
}

model ModifyWebAreaBlockResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5AA2BD65-E289-4E91-9DD9-3E1FB2140D17'),
}

model ModifyWebAreaBlockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebAreaBlockResponseBody(name='body'),
}

/**
 * @summary Modifies the blocked locations that are configured in the Location Blacklist (Domain Names) policy for a website.
 *
 * @param request ModifyWebAreaBlockRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebAreaBlockResponse
 */
async function modifyWebAreaBlockWithOptions(request: ModifyWebAreaBlockRequest, runtime: $RuntimeOptions): ModifyWebAreaBlockResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.regions)) {
    query['Regions'] = request.regions;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyWebAreaBlock',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the blocked locations that are configured in the Location Blacklist (Domain Names) policy for a website.
 *
 * @param request ModifyWebAreaBlockRequest
 * @return ModifyWebAreaBlockResponse
 */
async function modifyWebAreaBlock(request: ModifyWebAreaBlockRequest): ModifyWebAreaBlockResponse {
  var runtime = new $RuntimeOptions{};
  return modifyWebAreaBlockWithOptions(request, runtime);
}

model ModifyWebAreaBlockSwitchRequest {
  config?: string(name='Config', description='Specifies whether to enable or disable the Location Blacklist (Domain Names) policy for a domain name. The value is a string that consists of a JSON struct. The JSON struct contains the following parameters:

*   **RegionblockEnable**: the status of the Location Blacklist (Domain Names) policy. This parameter is required and must be of the INTEGER type. Valid values:

    *   **1**: enables the policy.
    *   **0**: disables the policy.

This parameter is required.', example='{"RegionblockEnable": 1}'),
  domain?: string(name='Domain', description='The domain name for which you want to enable or disable the Location Blacklist policy.

> You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.

This parameter is required.', example='www.aliyundoc.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
}

model ModifyWebAreaBlockSwitchResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
}

model ModifyWebAreaBlockSwitchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebAreaBlockSwitchResponseBody(name='body'),
}

/**
 * @summary Enables or disables the Location Blacklist (Domain Names) policy for a domain name.
 *
 * @description You can call the ModifyWebAreaBlockSwitch operation to enable or disable the Location Blacklist (Domain Names) policy for a domain name.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ModifyWebAreaBlockSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebAreaBlockSwitchResponse
 */
async function modifyWebAreaBlockSwitchWithOptions(request: ModifyWebAreaBlockSwitchRequest, runtime: $RuntimeOptions): ModifyWebAreaBlockSwitchResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.config)) {
    query['Config'] = request.config;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyWebAreaBlockSwitch',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables the Location Blacklist (Domain Names) policy for a domain name.
 *
 * @description You can call the ModifyWebAreaBlockSwitch operation to enable or disable the Location Blacklist (Domain Names) policy for a domain name.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ModifyWebAreaBlockSwitchRequest
 * @return ModifyWebAreaBlockSwitchResponse
 */
async function modifyWebAreaBlockSwitch(request: ModifyWebAreaBlockSwitchRequest): ModifyWebAreaBlockSwitchResponse {
  var runtime = new $RuntimeOptions{};
  return modifyWebAreaBlockSwitchWithOptions(request, runtime);
}

model ModifyWebCCGlobalSwitchRequest {
  ccGlobalSwitch?: string(name='CcGlobalSwitch', description='Specifies whether the HTTP flood mitigation feature is enabled. Valid values:

*   **open**
*   **close**

This parameter is required.', example='open'),
  domain?: string(name='Domain', description='The domain name of the website.

>  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='example.aliyundoc.com'),
}

model ModifyWebCCGlobalSwitchResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5AE2FC86-C840-41AE-9F1A-3A2747C7C1DF'),
}

model ModifyWebCCGlobalSwitchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebCCGlobalSwitchResponseBody(name='body'),
}

/**
 * @summary Enables or disables the HTTP flood mitigation feature for a website.
 *
 * @param request ModifyWebCCGlobalSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebCCGlobalSwitchResponse
 */
async function modifyWebCCGlobalSwitchWithOptions(request: ModifyWebCCGlobalSwitchRequest, runtime: $RuntimeOptions): ModifyWebCCGlobalSwitchResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.ccGlobalSwitch)) {
    query['CcGlobalSwitch'] = request.ccGlobalSwitch;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyWebCCGlobalSwitch',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables the HTTP flood mitigation feature for a website.
 *
 * @param request ModifyWebCCGlobalSwitchRequest
 * @return ModifyWebCCGlobalSwitchResponse
 */
async function modifyWebCCGlobalSwitch(request: ModifyWebCCGlobalSwitchRequest): ModifyWebCCGlobalSwitchResponse {
  var runtime = new $RuntimeOptions{};
  return modifyWebCCGlobalSwitchWithOptions(request, runtime);
}

model ModifyWebCCRuleRequest {
  act?: string(name='Act', description='This parameter is required.', example='close'),
  count?: int32(name='Count', description='This parameter is required.', example='3'),
  domain?: string(name='Domain', description='This parameter is required.', example='www.aliyun.com'),
  interval?: int32(name='Interval', description='This parameter is required.', example='30'),
  mode?: string(name='Mode', description='This parameter is required.', example='prefix'),
  name?: string(name='Name', description='This parameter is required.', example='testrule'),
  resourceGroupId?: string(name='ResourceGroupId', example='default'),
  ttl?: int32(name='Ttl', description='The blocking duration. Valid values: **60** to **86400**. Unit: seconds.

This parameter is required.', example='60'),
  uri?: string(name='Uri', description='The check path.

>  You cannot modify the Uniform Resource Identifier (URI). The domain name of the website, the check path, and the rule name uniquely identify a rule.

This parameter is required.', example='/abc'),
}

model ModifyWebCCRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebCCRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebCCRuleResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI ModifyWebCCRule is deprecated, please use ddoscoo::2020-01-01::ConfigWebCCRuleV2 instead.
 *
 * @summary Modifies the custom frequency control rule of a website.
 *
 * @param request ModifyWebCCRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebCCRuleResponse
 */
// Deprecated
async function modifyWebCCRuleWithOptions(request: ModifyWebCCRuleRequest, runtime: $RuntimeOptions): ModifyWebCCRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.act)) {
    query['Act'] = request.act;
  }
  if (!$isNull(request.count)) {
    query['Count'] = request.count;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.interval)) {
    query['Interval'] = request.interval;
  }
  if (!$isNull(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.ttl)) {
    query['Ttl'] = request.ttl;
  }
  if (!$isNull(request.uri)) {
    query['Uri'] = request.uri;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyWebCCRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @deprecated OpenAPI ModifyWebCCRule is deprecated, please use ddoscoo::2020-01-01::ConfigWebCCRuleV2 instead.
 *
 * @summary Modifies the custom frequency control rule of a website.
 *
 * @param request ModifyWebCCRuleRequest
 * @return ModifyWebCCRuleResponse
 */
// Deprecated
async function modifyWebCCRule(request: ModifyWebCCRuleRequest): ModifyWebCCRuleResponse {
  var runtime = new $RuntimeOptions{};
  return modifyWebCCRuleWithOptions(request, runtime);
}

model ModifyWebCacheCustomRuleRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name, and the domain name must be associated with an instance that uses the Enhanced function plan. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
  rules?: string(name='Rules', description='The details of the custom rule. This parameter is a JSON string. The string contains the following fields:

*   **Name**: the name of the rule. This field is required and must be of the string type.

*   **Uri**: the path to the cached page. This field is required and must be of the STRING type.

*   **Mode**: the cache mode. This field is required and must be of the STRING type. Valid values:

    *   **standard**: uses the standard mode.
    *   **aggressive**: uses the enhanced mode.
    *   **bypass**: No data is cached.

*   **CacheTtl**: the expiration time of the page cache. This field is required and must be of the INTEGER type. Unit: seconds.

This parameter is required.', example='[{"Name": "test","Uri": "/a","Mode": "standard","CacheTtl": 3600}]'),
}

model ModifyWebCacheCustomRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebCacheCustomRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebCacheCustomRuleResponseBody(name='body'),
}

/**
 * @summary Modifies the custom rule of the Static Page Caching policy for a website.
 *
 * @param request ModifyWebCacheCustomRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebCacheCustomRuleResponse
 */
async function modifyWebCacheCustomRuleWithOptions(request: ModifyWebCacheCustomRuleRequest, runtime: $RuntimeOptions): ModifyWebCacheCustomRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.rules)) {
    query['Rules'] = request.rules;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyWebCacheCustomRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the custom rule of the Static Page Caching policy for a website.
 *
 * @param request ModifyWebCacheCustomRuleRequest
 * @return ModifyWebCacheCustomRuleResponse
 */
async function modifyWebCacheCustomRule(request: ModifyWebCacheCustomRuleRequest): ModifyWebCacheCustomRuleResponse {
  var runtime = new $RuntimeOptions{};
  return modifyWebCacheCustomRuleWithOptions(request, runtime);
}

model ModifyWebCacheModeRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name, and the domain name must be associated with an instance that uses the Enhanced function plan. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  mode?: string(name='Mode', description='The cache mode of the Static Page Caching policy. Valid values:

*   **standard**: uses the standard cache mode.
*   **aggressive**: uses the enhanced cache mode.
*   **bypass**: caches no data.

This parameter is required.', example='standard'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model ModifyWebCacheModeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebCacheModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebCacheModeResponseBody(name='body'),
}

/**
 * @summary Changes the cache mode of the Static Page Caching policy for a website.
 *
 * @param request ModifyWebCacheModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebCacheModeResponse
 */
async function modifyWebCacheModeWithOptions(request: ModifyWebCacheModeRequest, runtime: $RuntimeOptions): ModifyWebCacheModeResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyWebCacheMode',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Changes the cache mode of the Static Page Caching policy for a website.
 *
 * @param request ModifyWebCacheModeRequest
 * @return ModifyWebCacheModeResponse
 */
async function modifyWebCacheMode(request: ModifyWebCacheModeRequest): ModifyWebCacheModeResponse {
  var runtime = new $RuntimeOptions{};
  return modifyWebCacheModeWithOptions(request, runtime);
}

model ModifyWebCacheSwitchRequest {
  domain?: string(name='Domain', description='The domain name for which you want to configure the Static Page Caching policy.

> You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.

This parameter is required.', example='www.aliyundoc.com'),
  enable?: int32(name='Enable', description='Specifies whether to enable or disable the Static Page Caching policy for a website. Valid values:

*   **1**: enables the policy.
*   **0**: disables the policy.

This parameter is required.', example='1'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management.

If you do not configure this parameter, the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
}

model ModifyWebCacheSwitchResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6623EA1F-30FB-5BC8-BEC9-74D55F6F08F1'),
}

model ModifyWebCacheSwitchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebCacheSwitchResponseBody(name='body'),
}

/**
 * @summary Enables or disables the Static Page Caching policy for a website.
 *
 * @description You can call the ModifyWebCacheSwitch operation to enable or disable the Static Page Caching policy for a website.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ModifyWebCacheSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebCacheSwitchResponse
 */
async function modifyWebCacheSwitchWithOptions(request: ModifyWebCacheSwitchRequest, runtime: $RuntimeOptions): ModifyWebCacheSwitchResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.enable)) {
    query['Enable'] = request.enable;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyWebCacheSwitch',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables the Static Page Caching policy for a website.
 *
 * @description You can call the ModifyWebCacheSwitch operation to enable or disable the Static Page Caching policy for a website.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ModifyWebCacheSwitchRequest
 * @return ModifyWebCacheSwitchResponse
 */
async function modifyWebCacheSwitch(request: ModifyWebCacheSwitchRequest): ModifyWebCacheSwitchResponse {
  var runtime = new $RuntimeOptions{};
  return modifyWebCacheSwitchWithOptions(request, runtime);
}

model ModifyWebIpSetSwitchRequest {
  config?: string(name='Config', description='The details of the Blacklist/Whitelist (Domain Names) feature. This parameter is a JSON string. The value consists of the following fields:

**bwlist_enable**: the status of the Blacklist/Whitelist (Domain Names) feature. This field is required and must be of the integer type. Valid values:

*   0: turned off
*   1: turned on

This parameter is required.', example='{"BwlistEnable":1}'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model ModifyWebIpSetSwitchResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebIpSetSwitchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebIpSetSwitchResponseBody(name='body'),
}

/**
 * @summary Enables or disables the Black Lists and White Lists (Domain Names) policy for a domain name.
 *
 * @param request ModifyWebIpSetSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebIpSetSwitchResponse
 */
async function modifyWebIpSetSwitchWithOptions(request: ModifyWebIpSetSwitchRequest, runtime: $RuntimeOptions): ModifyWebIpSetSwitchResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.config)) {
    query['Config'] = request.config;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyWebIpSetSwitch',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables the Black Lists and White Lists (Domain Names) policy for a domain name.
 *
 * @param request ModifyWebIpSetSwitchRequest
 * @return ModifyWebIpSetSwitchResponse
 */
async function modifyWebIpSetSwitch(request: ModifyWebIpSetSwitchRequest): ModifyWebIpSetSwitchResponse {
  var runtime = new $RuntimeOptions{};
  return modifyWebIpSetSwitchWithOptions(request, runtime);
}

model ModifyWebPreciseAccessRuleRequest {
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='example.aliyundoc.com'),
  expires?: int32(name='Expires', description='The validity period of the rule. Unit: seconds. This parameter takes effect only when **action** of a rule is **block**. Access requests that match the rule are blocked within the specified validity period of the rule. If you do not specify this parameter, this rule takes effect all the time.', example='600'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='rg-acfm2pz25js****'),
  rules?: string(name='Rules', description='The settings of the accurate access control rule. This parameter is a JSON string. The following list describes the fields in the value of the parameter:

*   **action**: the action that is performed if the rule is matched. This field is required and must be of the string type. Valid values:

    *   **accept**: allows the requests that match the rule.
    *   **block**: blocks the requests that match the rule.
    *   **challenge**: implements a CAPTCHA for the requests that match the rule.

*   **name**: the name of the rule. This field is required and must be of the string type.

*   **condition**: the match conditions. This field is required and must be of the map type. A match condition contains the following parameters.

    **

    **Note**The AND logical operator is used to define the relationship among multiple match conditions.

    *   **field**: the match field. This parameter is required and must be of the string type.

    *   **match_method**: the logical relation. This parameter is required and must be of the string type.

        **

        **Note**For information about the mappings between the **field** and **match_method** parameters, see the Mappings between the field and match_method parameters table in this topic.

    *   **content**: the match content. This parameter is required and must be of the string type.

*   **header_name**: the HTTP header. This parameter is optional and must be of the string type. This parameter takes effect only when **field** is **header**.

This parameter is required.', example='[{"action":"block","name":"testrule","condition":[{"field":"uri","match_method":"contain","content":"/test/123"}]}]'),
}

model ModifyWebPreciseAccessRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request, which is used to locate and troubleshoot issues.', example='F908E959-ADA8-4D7B-8A05-FF2F67F50964'),
}

model ModifyWebPreciseAccessRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebPreciseAccessRuleResponseBody(name='body'),
}

/**
 * @summary Creates or modifies an accurate access control rule of a website.
 *
 * @param request ModifyWebPreciseAccessRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebPreciseAccessRuleResponse
 */
async function modifyWebPreciseAccessRuleWithOptions(request: ModifyWebPreciseAccessRuleRequest, runtime: $RuntimeOptions): ModifyWebPreciseAccessRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.expires)) {
    query['Expires'] = request.expires;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.rules)) {
    query['Rules'] = request.rules;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyWebPreciseAccessRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Creates or modifies an accurate access control rule of a website.
 *
 * @param request ModifyWebPreciseAccessRuleRequest
 * @return ModifyWebPreciseAccessRuleResponse
 */
async function modifyWebPreciseAccessRule(request: ModifyWebPreciseAccessRuleRequest): ModifyWebPreciseAccessRuleResponse {
  var runtime = new $RuntimeOptions{};
  return modifyWebPreciseAccessRuleWithOptions(request, runtime);
}

model ModifyWebPreciseAccessSwitchRequest {
  config?: string(name='Config', description='The configuration of the Accurate Access Control policy. This parameter is a JSON string. The string contains the following fields:

*   **PreciseRuleEnable**: the status of the Accurate Access Control policy. This field is required and must be of the INTEGER type. Valid values:

    *   **0**: disables the policy.
    *   **1**: enables the policy.

This parameter is required.', example='{"PreciseRuleEnable":0}'),
  domain?: string(name='Domain', description='The domain name of the website.

> A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query all domain names.

This parameter is required.', example='www.aliyun.com'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.', example='default'),
}

model ModifyWebPreciseAccessSwitchResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0bcf28g5-d57c-11e7-9bs0-d89d6717dxbc'),
}

model ModifyWebPreciseAccessSwitchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebPreciseAccessSwitchResponseBody(name='body'),
}

/**
 * @summary Enables or disables accurate access control for a website.
 *
 * @param request ModifyWebPreciseAccessSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebPreciseAccessSwitchResponse
 */
async function modifyWebPreciseAccessSwitchWithOptions(request: ModifyWebPreciseAccessSwitchRequest, runtime: $RuntimeOptions): ModifyWebPreciseAccessSwitchResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.config)) {
    query['Config'] = request.config;
  }
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyWebPreciseAccessSwitch',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Enables or disables accurate access control for a website.
 *
 * @param request ModifyWebPreciseAccessSwitchRequest
 * @return ModifyWebPreciseAccessSwitchResponse
 */
async function modifyWebPreciseAccessSwitch(request: ModifyWebPreciseAccessSwitchRequest): ModifyWebPreciseAccessSwitchResponse {
  var runtime = new $RuntimeOptions{};
  return modifyWebPreciseAccessSwitchWithOptions(request, runtime);
}

model ModifyWebRuleRequest {
  domain?: string(name='Domain', description='The domain name of the website.

>  A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](https://help.aliyun.com/document_detail/91724.html) operation to query the domain names for which forwarding rules are configured.

This parameter is required.', example='www.aliyun.com'),
  httpsExt?: string(name='HttpsExt', description='The advanced HTTPS settings. This parameter takes effect only when the value of **ProxyType** includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:

*   **Http2https**: specifies whether to turn on Enforce HTTPS Routing. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enforce HTTPS Routing is turned off. The value 1 indicates that Enforce HTTPS Routing is turned on. The default value is 0.

    If your website supports both HTTP and HTTPS, this feature suits your needs. If you turn on the switch, all HTTP requests are redirected to HTTPS requests on port 443 by default.

*   **Https2http**: specifies whether to turn on Enable HTTP. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP is turned off. The value 1 indicates that Enable HTTP is turned on. The default value is 0.

    If your website does not support HTTPS, this feature suits your needs. If you turn on the switch, all HTTPS requests are redirected to HTTP requests and forwarded to origin servers. The feature can also redirect WebSockets requests to WebSocket requests. All requests are redirected over port 80.

*   **Http2**: specifies whether to turn on Enable HTTP/2. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on. The default value is 0.

    After you turn on the switch, the protocol type is HTTP/2.', example='{"Http2":1,"Http2https":1,"Https2http":1}'),
  instanceIds?: [ string ](name='InstanceIds', example='ddoscoo-cn-mp91j1ao****'),
  proxyTypes?: string(name='ProxyTypes', description='The protocol of the forwarding rule. The value is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that contains the following fields:

*   **ProxyType**: the protocol type. This field is required and must be a string. Valid values: **http**, **https**, **websocket**, and **websockets**.
*   **ProxyPort**: the port number. This field is required and must be an array.

This parameter is required.', example='[{"ProxyType":"https","ProxyPorts":[443]}]'),
  realServers?: [ string ](name='RealServers', description='This parameter is required.', example='1.xxx.xxx.1'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.

For more information about resource groups, see [Create a resource group](https://help.aliyun.com/document_detail/94485.html).', example='rg-acfm2pz25js****'),
  rsType?: int32(name='RsType', description='The address type of the origin server. Valid values:

*   **0**: IP address.
*   **1**: domain name. Use the domain name of the origin server if you deploy proxies, such as Web Application Firewall (WAF), between the origin server and the Anti-DDoS Pro or Anti-DDoS Premium instance. If you use the domain name, you must enter the address of the proxy, such as the CNAME of WAF.

This parameter is required.', example='0'),
}

model ModifyWebRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB3261D2-7D1B-4ADA-9E98-A200B2CDA2DC'),
}

model ModifyWebRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyWebRuleResponseBody(name='body'),
}

/**
 * @summary Modifies the forwarding rule of a website.
 *
 * @description ## Debugging
 * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=ddoscoo\\&api=ModifyWebRule\\&type=RPC\\&version=2020-01-01)
 *
 * @param request ModifyWebRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebRuleResponse
 */
async function modifyWebRuleWithOptions(request: ModifyWebRuleRequest, runtime: $RuntimeOptions): ModifyWebRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!$isNull(request.httpsExt)) {
    query['HttpsExt'] = request.httpsExt;
  }
  if (!$isNull(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!$isNull(request.proxyTypes)) {
    query['ProxyTypes'] = request.proxyTypes;
  }
  if (!$isNull(request.realServers)) {
    query['RealServers'] = request.realServers;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.rsType)) {
    query['RsType'] = request.rsType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyWebRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Modifies the forwarding rule of a website.
 *
 * @description ## Debugging
 * [OpenAPI Explorer automatically calculates the signature value. For your convenience, we recommend that you call this operation in OpenAPI Explorer. OpenAPI Explorer dynamically generates the sample code of the operation for different SDKs.](https://api.aliyun.com/#product=ddoscoo\\&api=ModifyWebRule\\&type=RPC\\&version=2020-01-01)
 *
 * @param request ModifyWebRuleRequest
 * @return ModifyWebRuleResponse
 */
async function modifyWebRule(request: ModifyWebRuleRequest): ModifyWebRuleResponse {
  var runtime = new $RuntimeOptions{};
  return modifyWebRuleWithOptions(request, runtime);
}

model ReleaseInstanceRequest {
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='ddoscoo-cn-mp91j1ao****'),
}

model ReleaseInstanceResponseBody = {
  requestId?: string(name='RequestId', example='06FFAF5F-CD3E-4886-A849-AAB40DFF6515'),
}

model ReleaseInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseInstanceResponseBody(name='body'),
}

/**
 * @summary The ID of the instance that you want to release.
 * > You can release only expired instances. You can call the [DescribeInstances](https://help.aliyun.com/document_detail/91478.html) operation to query the IDs and expiration status of all instances.
 *
 * @description The ID of the request, which is used to locate and troubleshoot issues.
 *
 * @param request ReleaseInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseInstanceResponse
 */
async function releaseInstanceWithOptions(request: ReleaseInstanceRequest, runtime: $RuntimeOptions): ReleaseInstanceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ReleaseInstance',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary The ID of the instance that you want to release.
 * > You can release only expired instances. You can call the [DescribeInstances](https://help.aliyun.com/document_detail/91478.html) operation to query the IDs and expiration status of all instances.
 *
 * @description The ID of the request, which is used to locate and troubleshoot issues.
 *
 * @param request ReleaseInstanceRequest
 * @return ReleaseInstanceResponse
 */
async function releaseInstance(request: ReleaseInstanceRequest): ReleaseInstanceResponse {
  var runtime = new $RuntimeOptions{};
  return releaseInstanceWithOptions(request, runtime);
}

model SwitchSchedulerRuleRequest {
  ruleName?: string(name='RuleName', description='The name of the scheduling rule to manage.

> You can call the [DescribeSchedulerRules](https://help.aliyun.com/document_detail/157481.html) operation to query the names of all scheduling rules.

This parameter is required.', example='testrule'),
  ruleType?: int32(name='RuleType', description='The type of the scheduling rule. Valid values:

*   **2**: tiered protection rule
*   **3**: network acceleration rule
*   **5**: Alibaba Cloud CDN (CDN) interaction rule
*   **6**: cloud service interaction rule

This parameter is required.', example='6'),
  switchData?: string(name='SwitchData', description='The configuration that is used to switch service traffic. This parameter is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that includes the following parameters:

*   **Value**: required. The IP address of the associated resource. Data type: string.

*   **State**: required. The operation type. Data type: integer. Valid values:

    *   **0**: switches service traffic from the associated resource to your Anti-DDoS Pro or Anti-DDoS Premium instance for scrubbing.
    *   **1**: switches service traffic back to the associated cloud resource.

*   **Interval**: optional. The waiting time that is required before the service traffic is switched back. Unit: minutes. Data type: integer. Usage notes:

    *   If the **State** parameter is set to **0**, you must set this parameter to \\\\*\\\\*-1\\\\*\\\\*. Otherwise, the call fails.
    *   If the **State** parameter is set to **1**, you do not need to set this parameter.

This parameter is required.', example='[{"Value":"39.104.XX.XX","State":0,"Interval":-1}]'),
}

model SwitchSchedulerRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='7E3C301F-84BB-50E4-9DB9-2937B2429C1E'),
}

model SwitchSchedulerRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SwitchSchedulerRuleResponseBody(name='body'),
}

/**
 * @summary Switches service traffic to an Anti-DDoS Pro or Anti-DDoS Premium instance for scrubbing or switches service traffic back to the associated cloud resources.
 *
 * @description You can call the SwitchSchedulerRule operation to modify the resources to which service traffic is switched for a scheduling rule. For example, you can switch service traffic to an Anti-DDoS Pro or Anti-DDoS Premium instance for scrubbing or switch the service traffic back to the associated cloud resources.
 * Before you call this operation, you must have created a scheduling rule by calling the [CreateSchedulerRule](https://help.aliyun.com/document_detail/157479.html) operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request SwitchSchedulerRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SwitchSchedulerRuleResponse
 */
async function switchSchedulerRuleWithOptions(request: SwitchSchedulerRuleRequest, runtime: $RuntimeOptions): SwitchSchedulerRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!$isNull(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!$isNull(request.switchData)) {
    query['SwitchData'] = request.switchData;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SwitchSchedulerRule',
    version = '2020-01-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if ($isNull(@signatureVersion) || @signatureVersion != 'v4') {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary Switches service traffic to an Anti-DDoS Pro or Anti-DDoS Premium instance for scrubbing or switches service traffic back to the associated cloud resources.
 *
 * @description You can call the SwitchSchedulerRule operation to modify the resources to which service traffic is switched for a scheduling rule. For example, you can switch service traffic to an Anti-DDoS Pro or Anti-DDoS Premium instance for scrubbing or switch the service traffic back to the associated cloud resources.
 * Before you call this operation, you must have created a scheduling rule by calling the [CreateSchedulerRule](https://help.aliyun.com/document_detail/157479.html) operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request SwitchSchedulerRuleRequest
 * @return SwitchSchedulerRuleResponse
 */
async function switchSchedulerRule(request: SwitchSchedulerRuleRequest): SwitchSchedulerRuleResponse {
  var runtime = new $RuntimeOptions{};
  return switchSchedulerRuleWithOptions(request, runtime);
}

