/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  @endpointMap = {
    cn-qingdao = 'ddi.cn-qingdao.aliyuncs.com',
    cn-chengdu = 'ddi.cn-chengdu.aliyuncs.com',
    cn-zhangjiakou = 'ddi.cn-zhangjiakou.aliyuncs.com',
    cn-huhehaote = 'ddi.cn-huhehaote.aliyuncs.com',
    cn-hongkong = 'ddi.cn-hongkong.aliyuncs.com',
    ap-southeast-2 = 'ddi.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'ddi.ap-southeast-3.aliyuncs.com',
    ap-southeast-5 = 'ddi.ap-southeast-5.aliyuncs.com',
    ap-northeast-1 = 'ddi.ap-northeast-1.aliyuncs.com',
    eu-west-1 = 'ddi.eu-west-1.aliyuncs.com',
    us-east-1 = 'ddi.us-east-1.aliyuncs.com',
    eu-central-1 = 'ddi.eu-central-1.aliyuncs.com',
    me-east-1 = 'ddi.me-east-1.aliyuncs.com',
    ap-south-1 = 'ddi.ap-south-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('ddi', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CloneFlowJobRequest {
  id?: string(name='Id'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model CloneFlowJobResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CloneFlowJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloneFlowJobResponseBody(name='body'),
}

async function cloneFlowJobWithOptions(request: CloneFlowJobRequest, runtime: Util.RuntimeOptions): CloneFlowJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloneFlowJob',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cloneFlowJob(request: CloneFlowJobRequest): CloneFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneFlowJobWithOptions(request, runtime);
}

model CreateClusterV2Request {
  authorizeContent?: string(name='AuthorizeContent'),
  auto?: boolean(name='Auto'),
  autoPayOrder?: boolean(name='AutoPayOrder'),
  bootstrapAction?: [ 
    {
      arg?: string(name='Arg'),
      name?: string(name='Name'),
      path?: string(name='Path'),
    }
  ](name='BootstrapAction'),
  chargeType?: string(name='ChargeType'),
  clickHouseConf?: string(name='ClickHouseConf'),
  clientToken?: string(name='ClientToken'),
  clusterType?: string(name='ClusterType'),
  config?: [ 
    {
      configKey?: string(name='ConfigKey'),
      configValue?: string(name='ConfigValue'),
      encrypt?: string(name='Encrypt'),
      fileName?: string(name='FileName'),
      replace?: string(name='Replace'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='Config'),
  configurations?: string(name='Configurations'),
  depositType?: string(name='DepositType'),
  emrVer?: string(name='EmrVer'),
  enableEas?: boolean(name='EnableEas'),
  enableHighAvailability?: boolean(name='EnableHighAvailability'),
  enableSsh?: boolean(name='EnableSsh'),
  extraAttributes?: string(name='ExtraAttributes'),
  hostComponentInfo?: [ 
    {
      componentNameList?: [ string ](name='ComponentNameList'),
      hostName?: string(name='HostName'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='HostComponentInfo'),
  hostGroup?: [ 
    {
      autoRenew?: boolean(name='AutoRenew'),
      chargeType?: string(name='ChargeType'),
      clusterId?: string(name='ClusterId'),
      comment?: string(name='Comment'),
      createType?: string(name='CreateType'),
      diskCapacity?: int32(name='DiskCapacity'),
      diskCount?: int32(name='DiskCount'),
      diskType?: string(name='DiskType'),
      gpuDriver?: string(name='GpuDriver'),
      hostGroupId?: string(name='HostGroupId'),
      hostGroupName?: string(name='HostGroupName'),
      hostGroupType?: string(name='HostGroupType'),
      instanceType?: string(name='InstanceType'),
      nodeCount?: int32(name='NodeCount'),
      period?: int32(name='Period'),
      sysDiskCapacity?: int32(name='SysDiskCapacity'),
      sysDiskType?: string(name='SysDiskType'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='HostGroup'),
  initCustomHiveMetaDB?: boolean(name='InitCustomHiveMetaDB'),
  instanceGeneration?: string(name='InstanceGeneration'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
  keyPairName?: string(name='KeyPairName'),
  logPath?: string(name='LogPath'),
  machineType?: string(name='MachineType'),
  masterPwd?: string(name='MasterPwd'),
  metaStoreConf?: string(name='MetaStoreConf'),
  metaStoreType?: string(name='MetaStoreType'),
  name?: string(name='Name'),
  netType?: string(name='NetType'),
  period?: int32(name='Period'),
  promotionInfo?: [ 
    {
      productCode?: string(name='ProductCode'),
      promotionOptionCode?: string(name='PromotionOptionCode'),
      promotionOptionNo?: string(name='PromotionOptionNo'),
    }
  ](name='PromotionInfo'),
  regionId?: string(name='RegionId'),
  relatedClusterId?: string(name='RelatedClusterId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityGroupId?: string(name='SecurityGroupId'),
  securityGroupName?: string(name='SecurityGroupName'),
  serviceInfo?: [ 
    {
      serviceName?: string(name='ServiceName'),
      serviceVersion?: string(name='ServiceVersion'),
    }
  ](name='ServiceInfo'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  useCustomHiveMetaDB?: boolean(name='UseCustomHiveMetaDB'),
  useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
  userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
  userInfo?: [ 
    {
      password?: string(name='Password'),
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='UserInfo'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  whiteListType?: string(name='WhiteListType'),
  zoneId?: string(name='ZoneId'),
}

model CreateClusterV2ResponseBody = {
  clusterId?: string(name='ClusterId'),
  coreOrderId?: string(name='CoreOrderId'),
  emrOrderId?: string(name='EmrOrderId'),
  masterOrderId?: string(name='MasterOrderId'),
  requestId?: string(name='RequestId'),
}

model CreateClusterV2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateClusterV2ResponseBody(name='body'),
}

async function createClusterV2WithOptions(request: CreateClusterV2Request, runtime: Util.RuntimeOptions): CreateClusterV2Response {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authorizeContent)) {
    query['AuthorizeContent'] = request.authorizeContent;
  }
  if (!Util.isUnset(request.auto)) {
    query['Auto'] = request.auto;
  }
  if (!Util.isUnset(request.autoPayOrder)) {
    query['AutoPayOrder'] = request.autoPayOrder;
  }
  if (!Util.isUnset(request.bootstrapAction)) {
    query['BootstrapAction'] = request.bootstrapAction;
  }
  if (!Util.isUnset(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!Util.isUnset(request.clickHouseConf)) {
    query['ClickHouseConf'] = request.clickHouseConf;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.configurations)) {
    query['Configurations'] = request.configurations;
  }
  if (!Util.isUnset(request.depositType)) {
    query['DepositType'] = request.depositType;
  }
  if (!Util.isUnset(request.emrVer)) {
    query['EmrVer'] = request.emrVer;
  }
  if (!Util.isUnset(request.enableEas)) {
    query['EnableEas'] = request.enableEas;
  }
  if (!Util.isUnset(request.enableHighAvailability)) {
    query['EnableHighAvailability'] = request.enableHighAvailability;
  }
  if (!Util.isUnset(request.enableSsh)) {
    query['EnableSsh'] = request.enableSsh;
  }
  if (!Util.isUnset(request.extraAttributes)) {
    query['ExtraAttributes'] = request.extraAttributes;
  }
  if (!Util.isUnset(request.hostComponentInfo)) {
    query['HostComponentInfo'] = request.hostComponentInfo;
  }
  if (!Util.isUnset(request.hostGroup)) {
    query['HostGroup'] = request.hostGroup;
  }
  if (!Util.isUnset(request.initCustomHiveMetaDB)) {
    query['InitCustomHiveMetaDB'] = request.initCustomHiveMetaDB;
  }
  if (!Util.isUnset(request.instanceGeneration)) {
    query['InstanceGeneration'] = request.instanceGeneration;
  }
  if (!Util.isUnset(request.isOpenPublicIp)) {
    query['IsOpenPublicIp'] = request.isOpenPublicIp;
  }
  if (!Util.isUnset(request.keyPairName)) {
    query['KeyPairName'] = request.keyPairName;
  }
  if (!Util.isUnset(request.logPath)) {
    query['LogPath'] = request.logPath;
  }
  if (!Util.isUnset(request.machineType)) {
    query['MachineType'] = request.machineType;
  }
  if (!Util.isUnset(request.masterPwd)) {
    query['MasterPwd'] = request.masterPwd;
  }
  if (!Util.isUnset(request.metaStoreConf)) {
    query['MetaStoreConf'] = request.metaStoreConf;
  }
  if (!Util.isUnset(request.metaStoreType)) {
    query['MetaStoreType'] = request.metaStoreType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.promotionInfo)) {
    query['PromotionInfo'] = request.promotionInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.relatedClusterId)) {
    query['RelatedClusterId'] = request.relatedClusterId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.securityGroupName)) {
    query['SecurityGroupName'] = request.securityGroupName;
  }
  if (!Util.isUnset(request.serviceInfo)) {
    query['ServiceInfo'] = request.serviceInfo;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.useCustomHiveMetaDB)) {
    query['UseCustomHiveMetaDB'] = request.useCustomHiveMetaDB;
  }
  if (!Util.isUnset(request.useLocalMetaDb)) {
    query['UseLocalMetaDb'] = request.useLocalMetaDb;
  }
  if (!Util.isUnset(request.userDefinedEmrEcsRole)) {
    query['UserDefinedEmrEcsRole'] = request.userDefinedEmrEcsRole;
  }
  if (!Util.isUnset(request.userInfo)) {
    query['UserInfo'] = request.userInfo;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.whiteListType)) {
    query['WhiteListType'] = request.whiteListType;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateClusterV2',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createClusterV2(request: CreateClusterV2Request): CreateClusterV2Response {
  var runtime = new Util.RuntimeOptions{};
  return createClusterV2WithOptions(request, runtime);
}

model CreateFlowRequest {
  alertConf?: string(name='AlertConf'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
  application?: string(name='Application'),
  clientToken?: string(name='ClientToken'),
  clusterId?: string(name='ClusterId'),
  createCluster?: boolean(name='CreateCluster'),
  cronExpression?: string(name='CronExpression'),
  description?: string(name='Description'),
  endSchedule?: long(name='EndSchedule'),
  hostName?: string(name='HostName'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  parentCategory?: string(name='ParentCategory'),
  parentFlowList?: string(name='ParentFlowList'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  startSchedule?: long(name='StartSchedule'),
}

model CreateFlowResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFlowResponseBody(name='body'),
}

async function createFlowWithOptions(request: CreateFlowRequest, runtime: Util.RuntimeOptions): CreateFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertConf)) {
    query['AlertConf'] = request.alertConf;
  }
  if (!Util.isUnset(request.alertDingDingGroupBizId)) {
    query['AlertDingDingGroupBizId'] = request.alertDingDingGroupBizId;
  }
  if (!Util.isUnset(request.alertUserGroupBizId)) {
    query['AlertUserGroupBizId'] = request.alertUserGroupBizId;
  }
  if (!Util.isUnset(request.application)) {
    query['Application'] = request.application;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.createCluster)) {
    query['CreateCluster'] = request.createCluster;
  }
  if (!Util.isUnset(request.cronExpression)) {
    query['CronExpression'] = request.cronExpression;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endSchedule)) {
    query['EndSchedule'] = request.endSchedule;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.parentCategory)) {
    query['ParentCategory'] = request.parentCategory;
  }
  if (!Util.isUnset(request.parentFlowList)) {
    query['ParentFlowList'] = request.parentFlowList;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startSchedule)) {
    query['StartSchedule'] = request.startSchedule;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlow',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFlow(request: CreateFlowRequest): CreateFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowWithOptions(request, runtime);
}

model CreateFlowCategoryRequest {
  clientToken?: string(name='ClientToken'),
  name?: string(name='Name'),
  parentId?: string(name='ParentId'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
}

model CreateFlowCategoryResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateFlowCategoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFlowCategoryResponseBody(name='body'),
}

async function createFlowCategoryWithOptions(request: CreateFlowCategoryRequest, runtime: Util.RuntimeOptions): CreateFlowCategoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.parentId)) {
    query['ParentId'] = request.parentId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlowCategory',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFlowCategory(request: CreateFlowCategoryRequest): CreateFlowCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowCategoryWithOptions(request, runtime);
}

model CreateFlowJobRequest {
  adhoc?: boolean(name='Adhoc'),
  alertConf?: string(name='AlertConf'),
  clientToken?: string(name='ClientToken'),
  clusterId?: string(name='ClusterId'),
  customVariables?: string(name='CustomVariables'),
  description?: string(name='Description'),
  envConf?: string(name='EnvConf'),
  failAct?: string(name='FailAct'),
  mode?: string(name='Mode'),
  monitorConf?: string(name='MonitorConf'),
  name?: string(name='Name'),
  paramConf?: string(name='ParamConf'),
  params?: string(name='Params'),
  parentCategory?: string(name='ParentCategory'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  resourceList?: [ 
    {
      alias?: string(name='Alias'),
      path?: string(name='Path'),
    }
  ](name='ResourceList'),
  retryPolicy?: string(name='RetryPolicy'),
  runConf?: string(name='RunConf'),
  type?: string(name='Type'),
}

model CreateFlowJobResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateFlowJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFlowJobResponseBody(name='body'),
}

async function createFlowJobWithOptions(request: CreateFlowJobRequest, runtime: Util.RuntimeOptions): CreateFlowJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.adhoc)) {
    query['Adhoc'] = request.adhoc;
  }
  if (!Util.isUnset(request.alertConf)) {
    query['AlertConf'] = request.alertConf;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.customVariables)) {
    query['CustomVariables'] = request.customVariables;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.envConf)) {
    query['EnvConf'] = request.envConf;
  }
  if (!Util.isUnset(request.failAct)) {
    query['FailAct'] = request.failAct;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.monitorConf)) {
    query['MonitorConf'] = request.monitorConf;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.paramConf)) {
    query['ParamConf'] = request.paramConf;
  }
  if (!Util.isUnset(request.params)) {
    query['Params'] = request.params;
  }
  if (!Util.isUnset(request.parentCategory)) {
    query['ParentCategory'] = request.parentCategory;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceList)) {
    query['ResourceList'] = request.resourceList;
  }
  if (!Util.isUnset(request.retryPolicy)) {
    query['RetryPolicy'] = request.retryPolicy;
  }
  if (!Util.isUnset(request.runConf)) {
    query['RunConf'] = request.runConf;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlowJob',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFlowJob(request: CreateFlowJobRequest): CreateFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowJobWithOptions(request, runtime);
}

model CreateFlowProjectRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  name?: string(name='Name'),
  productType?: string(name='ProductType'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model CreateFlowProjectResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFlowProjectResponseBody(name='body'),
}

async function createFlowProjectWithOptions(request: CreateFlowProjectRequest, runtime: Util.RuntimeOptions): CreateFlowProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlowProject',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFlowProject(request: CreateFlowProjectRequest): CreateFlowProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowProjectWithOptions(request, runtime);
}

model CreateFlowProjectUserRequest {
  clientToken?: string(name='ClientToken'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  user?: [ 
    {
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='User'),
}

model CreateFlowProjectUserResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateFlowProjectUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFlowProjectUserResponseBody(name='body'),
}

async function createFlowProjectUserWithOptions(request: CreateFlowProjectUserRequest, runtime: Util.RuntimeOptions): CreateFlowProjectUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.user)) {
    query['User'] = request.user;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFlowProjectUser',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFlowProjectUser(request: CreateFlowProjectUserRequest): CreateFlowProjectUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowProjectUserWithOptions(request, runtime);
}

model DeleteFlowRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model DeleteFlowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFlowResponseBody(name='body'),
}

async function deleteFlowWithOptions(request: DeleteFlowRequest, runtime: Util.RuntimeOptions): DeleteFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlow',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFlow(request: DeleteFlowRequest): DeleteFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowWithOptions(request, runtime);
}

model DeleteFlowCategoryRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model DeleteFlowCategoryResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowCategoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFlowCategoryResponseBody(name='body'),
}

async function deleteFlowCategoryWithOptions(request: DeleteFlowCategoryRequest, runtime: Util.RuntimeOptions): DeleteFlowCategoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlowCategory',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFlowCategory(request: DeleteFlowCategoryRequest): DeleteFlowCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowCategoryWithOptions(request, runtime);
}

model DeleteFlowProjectRequest {
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model DeleteFlowProjectResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFlowProjectResponseBody(name='body'),
}

async function deleteFlowProjectWithOptions(request: DeleteFlowProjectRequest, runtime: Util.RuntimeOptions): DeleteFlowProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlowProject',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFlowProject(request: DeleteFlowProjectRequest): DeleteFlowProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowProjectWithOptions(request, runtime);
}

model DeleteFlowProjectUserRequest {
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  userName?: string(name='UserName'),
}

model DeleteFlowProjectUserResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowProjectUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFlowProjectUserResponseBody(name='body'),
}

async function deleteFlowProjectUserWithOptions(request: DeleteFlowProjectUserRequest, runtime: Util.RuntimeOptions): DeleteFlowProjectUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFlowProjectUser',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFlowProjectUser(request: DeleteFlowProjectUserRequest): DeleteFlowProjectUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowProjectUserWithOptions(request, runtime);
}

model DescribeClusterV2Request {
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeClusterV2ResponseBody = {
  clusterInfo?: {
    accessInfo?: {
      ZKLinks?: {
        ZKLink?: [ 
        {
          link?: string(name='Link'),
          port?: string(name='Port'),
        }
      ](name='ZKLink')
      }(name='ZKLinks'),
    }(name='AccessInfo'),
    autoScalingAllowed?: boolean(name='AutoScalingAllowed'),
    autoScalingByLoadAllowed?: boolean(name='AutoScalingByLoadAllowed'),
    autoScalingEnable?: boolean(name='AutoScalingEnable'),
    autoScalingSpotWithLimitAllowed?: boolean(name='AutoScalingSpotWithLimitAllowed'),
    autoScalingVersion?: string(name='AutoScalingVersion'),
    autoScalingWithGraceAllowed?: boolean(name='AutoScalingWithGraceAllowed'),
    bootstrapActionList?: {
      bootstrapAction?: [ 
      {
        arg?: string(name='Arg'),
        name?: string(name='Name'),
        path?: string(name='Path'),
      }
    ](name='BootstrapAction')
    }(name='BootstrapActionList'),
    bootstrapFailed?: boolean(name='BootstrapFailed'),
    chargeType?: string(name='ChargeType'),
    configurations?: string(name='Configurations'),
    coreNodeInService?: int32(name='CoreNodeInService'),
    coreNodeTotal?: int32(name='CoreNodeTotal'),
    createResource?: string(name='CreateResource'),
    createType?: string(name='CreateType'),
    depositType?: string(name='DepositType'),
    easEnable?: boolean(name='EasEnable'),
    expiredTime?: long(name='ExpiredTime'),
    extraInfo?: string(name='ExtraInfo'),
    failReason?: {
      errorCode?: string(name='ErrorCode'),
      errorMsg?: string(name='ErrorMsg'),
      requestId?: string(name='RequestId'),
    }(name='FailReason'),
    gatewayClusterIds?: string(name='GatewayClusterIds'),
    gatewayClusterInfoList?: {
      gatewayClusterInfo?: [ 
      {
        clusterId?: string(name='ClusterId'),
        clusterName?: string(name='ClusterName'),
        status?: string(name='Status'),
      }
    ](name='GatewayClusterInfo')
    }(name='GatewayClusterInfoList'),
    highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
    hostGroupList?: {
      hostGroup?: [ 
      {
        bandWidth?: string(name='BandWidth'),
        chargeType?: string(name='ChargeType'),
        cpuCore?: int32(name='CpuCore'),
        diskCapacity?: int32(name='DiskCapacity'),
        diskCount?: int32(name='DiskCount'),
        diskType?: string(name='DiskType'),
        hostGroupChangeStatus?: string(name='HostGroupChangeStatus'),
        hostGroupChangeType?: string(name='HostGroupChangeType'),
        hostGroupId?: string(name='HostGroupId'),
        hostGroupName?: string(name='HostGroupName'),
        hostGroupSubType?: string(name='HostGroupSubType'),
        hostGroupType?: string(name='HostGroupType'),
        instanceType?: string(name='InstanceType'),
        lockReason?: string(name='LockReason'),
        lockType?: string(name='LockType'),
        memoryCapacity?: int32(name='MemoryCapacity'),
        nodeCount?: int32(name='NodeCount'),
        nodes?: {
          node?: [ 
          {
            createTime?: string(name='CreateTime'),
            daemonInfos?: {
              daemonInfo?: [ 
              {
                name?: string(name='Name'),
              }
            ](name='DaemonInfo')
            }(name='DaemonInfos'),
            diskInfos?: {
              diskInfo?: [ 
              {
                device?: string(name='Device'),
                diskId?: string(name='DiskId'),
                diskName?: string(name='DiskName'),
                size?: int32(name='Size'),
                type?: string(name='Type'),
              }
            ](name='DiskInfo')
            }(name='DiskInfos'),
            emrExpiredTime?: string(name='EmrExpiredTime'),
            expiredTime?: string(name='ExpiredTime'),
            innerIp?: string(name='InnerIp'),
            instanceId?: string(name='InstanceId'),
            pubIp?: string(name='PubIp'),
            status?: string(name='Status'),
            supportIpV6?: boolean(name='SupportIpV6'),
            zoneId?: string(name='ZoneId'),
          }
        ](name='Node')
        }(name='Nodes'),
        period?: string(name='Period'),
      }
    ](name='HostGroup')
    }(name='HostGroupList'),
    hostPoolInfo?: {
      hpBizId?: string(name='HpBizId'),
      hpName?: string(name='HpName'),
    }(name='HostPoolInfo'),
    id?: string(name='Id'),
    imageId?: string(name='ImageId'),
    instanceGeneration?: string(name='InstanceGeneration'),
    ioOptimized?: boolean(name='IoOptimized'),
    k8sClusterId?: string(name='K8sClusterId'),
    localMetaDb?: boolean(name='LocalMetaDb'),
    logEnable?: boolean(name='LogEnable'),
    logPath?: string(name='LogPath'),
    machineType?: string(name='MachineType'),
    masterNodeInService?: int32(name='MasterNodeInService'),
    masterNodeTotal?: int32(name='MasterNodeTotal'),
    metaStoreType?: string(name='MetaStoreType'),
    name?: string(name='Name'),
    netType?: string(name='NetType'),
    period?: int32(name='Period'),
    regionId?: string(name='RegionId'),
    relateClusterId?: string(name='RelateClusterId'),
    relateClusterInfo?: {
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      status?: string(name='Status'),
    }(name='RelateClusterInfo'),
    resizeDiskEnable?: boolean(name='ResizeDiskEnable'),
    runningTime?: int32(name='RunningTime'),
    securityGroupId?: string(name='SecurityGroupId'),
    securityGroupName?: string(name='SecurityGroupName'),
    showSoftwareInterface?: boolean(name='ShowSoftwareInterface'),
    softwareInfo?: {
      clusterType?: string(name='ClusterType'),
      emrVer?: string(name='EmrVer'),
      softwares?: {
        software?: [ 
        {
          displayName?: string(name='DisplayName'),
          name?: string(name='Name'),
          onlyDisplay?: boolean(name='OnlyDisplay'),
          startTpe?: int32(name='StartTpe'),
          version?: string(name='Version'),
        }
      ](name='Software')
      }(name='Softwares'),
    }(name='SoftwareInfo'),
    startTime?: long(name='StartTime'),
    status?: string(name='Status'),
    stopTime?: long(name='StopTime'),
    taskNodeInService?: int32(name='TaskNodeInService'),
    taskNodeTotal?: int32(name='TaskNodeTotal'),
    userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
    userId?: string(name='UserId'),
    vSwitchId?: string(name='VSwitchId'),
    vpcId?: string(name='VpcId'),
    zoneId?: string(name='ZoneId'),
  }(name='ClusterInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeClusterV2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClusterV2ResponseBody(name='body'),
}

async function describeClusterV2WithOptions(request: DescribeClusterV2Request, runtime: Util.RuntimeOptions): DescribeClusterV2Response {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClusterV2',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClusterV2(request: DescribeClusterV2Request): DescribeClusterV2Response {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterV2WithOptions(request, runtime);
}

model DescribeFlowRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowResponseBody = {
  alertConf?: string(name='AlertConf'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
  application?: string(name='Application'),
  categoryId?: string(name='CategoryId'),
  clusterId?: string(name='ClusterId'),
  createCluster?: boolean(name='CreateCluster'),
  cronExpr?: string(name='CronExpr'),
  description?: string(name='Description'),
  editLockDetail?: string(name='EditLockDetail'),
  endSchedule?: long(name='EndSchedule'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  graph?: string(name='Graph'),
  hostName?: string(name='HostName'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  parentFlowList?: {
    parentFlow?: [ 
    {
      parentFlowId?: string(name='ParentFlowId'),
      parentFlowName?: string(name='ParentFlowName'),
      projectId?: string(name='ProjectId'),
      projectName?: string(name='ProjectName'),
    }
  ](name='ParentFlow')
  }(name='ParentFlowList'),
  periodic?: boolean(name='Periodic'),
  requestId?: string(name='RequestId'),
  startSchedule?: long(name='StartSchedule'),
  status?: string(name='Status'),
  type?: string(name='Type'),
}

model DescribeFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFlowResponseBody(name='body'),
}

async function describeFlowWithOptions(request: DescribeFlowRequest, runtime: Util.RuntimeOptions): DescribeFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlow',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlow(request: DescribeFlowRequest): DescribeFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowWithOptions(request, runtime);
}

model DescribeFlowCategoryTreeRequest {
  categoryId?: string(name='CategoryId'),
  keyword?: string(name='Keyword'),
  mode?: string(name='Mode'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
}

model DescribeFlowCategoryTreeResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeFlowCategoryTreeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFlowCategoryTreeResponseBody(name='body'),
}

async function describeFlowCategoryTreeWithOptions(request: DescribeFlowCategoryTreeRequest, runtime: Util.RuntimeOptions): DescribeFlowCategoryTreeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.categoryId)) {
    query['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowCategoryTree',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowCategoryTree(request: DescribeFlowCategoryTreeRequest): DescribeFlowCategoryTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowCategoryTreeWithOptions(request, runtime);
}

model DescribeFlowJobRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowJobResponseBody = {
  adhoc?: string(name='Adhoc'),
  alertConf?: string(name='AlertConf'),
  categoryId?: string(name='CategoryId'),
  customVariables?: string(name='CustomVariables'),
  description?: string(name='Description'),
  editLockDetail?: string(name='EditLockDetail'),
  envConf?: string(name='EnvConf'),
  failAct?: string(name='FailAct'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  id?: string(name='Id'),
  knoxPassword?: string(name='KnoxPassword'),
  knoxUser?: string(name='KnoxUser'),
  lastInstanceId?: string(name='LastInstanceId'),
  maxRetry?: int32(name='MaxRetry'),
  maxRunningTimeSec?: long(name='MaxRunningTimeSec'),
  mode?: string(name='Mode'),
  monitorConf?: string(name='MonitorConf'),
  name?: string(name='Name'),
  paramConf?: string(name='ParamConf'),
  params?: string(name='Params'),
  requestId?: string(name='RequestId'),
  resourceList?: {
    resource?: [ 
    {
      alias?: string(name='Alias'),
      path?: string(name='Path'),
    }
  ](name='Resource')
  }(name='ResourceList'),
  retryInterval?: long(name='RetryInterval'),
  retryPolicy?: string(name='RetryPolicy'),
  runConf?: string(name='RunConf'),
  type?: string(name='Type'),
}

model DescribeFlowJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFlowJobResponseBody(name='body'),
}

async function describeFlowJobWithOptions(request: DescribeFlowJobRequest, runtime: Util.RuntimeOptions): DescribeFlowJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowJob',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowJob(request: DescribeFlowJobRequest): DescribeFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowJobWithOptions(request, runtime);
}

model DescribeFlowNodeInstanceRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowNodeInstanceResponseBody = {
  adhoc?: boolean(name='Adhoc'),
  clusterId?: string(name='ClusterId'),
  clusterName?: string(name='ClusterName'),
  duration?: long(name='Duration'),
  endTime?: long(name='EndTime'),
  envConf?: string(name='EnvConf'),
  externalChildIds?: string(name='ExternalChildIds'),
  externalId?: string(name='ExternalId'),
  externalInfo?: string(name='ExternalInfo'),
  externalStatus?: string(name='ExternalStatus'),
  externalSubId?: string(name='ExternalSubId'),
  failAct?: string(name='FailAct'),
  flowId?: string(name='FlowId'),
  flowInstanceId?: string(name='FlowInstanceId'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  hostName?: string(name='HostName'),
  id?: string(name='Id'),
  jobId?: string(name='JobId'),
  jobName?: string(name='JobName'),
  jobParams?: string(name='JobParams'),
  jobType?: string(name='JobType'),
  maxRetry?: string(name='MaxRetry'),
  mode?: string(name='Mode'),
  monitorConf?: string(name='MonitorConf'),
  nodeName?: string(name='NodeName'),
  paramConf?: string(name='ParamConf'),
  pending?: boolean(name='Pending'),
  projectId?: string(name='ProjectId'),
  requestId?: string(name='RequestId'),
  retries?: int32(name='Retries'),
  retryInterval?: string(name='RetryInterval'),
  retryPolicy?: string(name='RetryPolicy'),
  runConf?: string(name='RunConf'),
  startTime?: long(name='StartTime'),
  status?: string(name='Status'),
  type?: string(name='Type'),
}

model DescribeFlowNodeInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFlowNodeInstanceResponseBody(name='body'),
}

async function describeFlowNodeInstanceWithOptions(request: DescribeFlowNodeInstanceRequest, runtime: Util.RuntimeOptions): DescribeFlowNodeInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowNodeInstance',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowNodeInstance(request: DescribeFlowNodeInstanceRequest): DescribeFlowNodeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowNodeInstanceWithOptions(request, runtime);
}

model DescribeFlowProjectRequest {
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowProjectResponseBody = {
  description?: string(name='Description'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  userId?: string(name='UserId'),
}

model DescribeFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFlowProjectResponseBody(name='body'),
}

async function describeFlowProjectWithOptions(request: DescribeFlowProjectRequest, runtime: Util.RuntimeOptions): DescribeFlowProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFlowProject',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFlowProject(request: DescribeFlowProjectRequest): DescribeFlowProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowProjectWithOptions(request, runtime);
}

model KillFlowJobRequest {
  jobInstanceId?: string(name='JobInstanceId'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model KillFlowJobResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model KillFlowJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: KillFlowJobResponseBody(name='body'),
}

async function killFlowJobWithOptions(request: KillFlowJobRequest, runtime: Util.RuntimeOptions): KillFlowJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobInstanceId)) {
    query['JobInstanceId'] = request.jobInstanceId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'KillFlowJob',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function killFlowJob(request: KillFlowJobRequest): KillFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return killFlowJobWithOptions(request, runtime);
}

model ListClustersRequest {
  clusterTypeList?: [ string ](name='ClusterTypeList'),
  createType?: string(name='CreateType'),
  defaultStatus?: boolean(name='DefaultStatus'),
  depositType?: string(name='DepositType'),
  expiredTagList?: [ string ](name='ExpiredTagList'),
  isDesc?: boolean(name='IsDesc'),
  machineType?: string(name='MachineType'),
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  statusList?: [ string ](name='StatusList'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListClustersResponseBody = {
  clusters?: {
    clusterInfo?: [ 
    {
      chargeType?: string(name='ChargeType'),
      createResource?: string(name='CreateResource'),
      createTime?: long(name='CreateTime'),
      depositType?: string(name='DepositType'),
      expiredTime?: long(name='ExpiredTime'),
      failReason?: {
        errorCode?: string(name='ErrorCode'),
        errorMsg?: string(name='ErrorMsg'),
        requestId?: string(name='RequestId'),
      }(name='FailReason'),
      hasUncompletedOrder?: boolean(name='HasUncompletedOrder'),
      id?: string(name='Id'),
      k8sClusterId?: string(name='K8sClusterId'),
      machineType?: string(name='MachineType'),
      metaStoreType?: string(name='MetaStoreType'),
      name?: string(name='Name'),
      orderList?: string(name='OrderList'),
      orderTaskInfo?: {
        currentCount?: int32(name='CurrentCount'),
        orderIdList?: string(name='OrderIdList'),
        targetCount?: int32(name='TargetCount'),
      }(name='OrderTaskInfo'),
      period?: int32(name='Period'),
      runningTime?: int32(name='RunningTime'),
      status?: string(name='Status'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
      type?: string(name='Type'),
    }
  ](name='ClusterInfo')
  }(name='Clusters'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClustersResponseBody(name='body'),
}

async function listClustersWithOptions(request: ListClustersRequest, runtime: Util.RuntimeOptions): ListClustersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterTypeList)) {
    query['ClusterTypeList'] = request.clusterTypeList;
  }
  if (!Util.isUnset(request.createType)) {
    query['CreateType'] = request.createType;
  }
  if (!Util.isUnset(request.defaultStatus)) {
    query['DefaultStatus'] = request.defaultStatus;
  }
  if (!Util.isUnset(request.depositType)) {
    query['DepositType'] = request.depositType;
  }
  if (!Util.isUnset(request.expiredTagList)) {
    query['ExpiredTagList'] = request.expiredTagList;
  }
  if (!Util.isUnset(request.isDesc)) {
    query['IsDesc'] = request.isDesc;
  }
  if (!Util.isUnset(request.machineType)) {
    query['MachineType'] = request.machineType;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusters',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClusters(request: ListClustersRequest): ListClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersWithOptions(request, runtime);
}

model ListFlowRequest {
  clusterId?: string(name='ClusterId'),
  id?: string(name='Id'),
  jobId?: string(name='JobId'),
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  periodic?: boolean(name='Periodic'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  status?: string(name='Status'),
}

model ListFlowResponseBody = {
  flow?: {
    flow?: [ 
    {
      alertConf?: string(name='AlertConf'),
      alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
      alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
      categoryId?: string(name='CategoryId'),
      clusterId?: string(name='ClusterId'),
      createCluster?: boolean(name='CreateCluster'),
      cronExpr?: string(name='CronExpr'),
      description?: string(name='Description'),
      endSchedule?: long(name='EndSchedule'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      graph?: string(name='Graph'),
      hostName?: string(name='HostName'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      periodic?: boolean(name='Periodic'),
      projectId?: string(name='ProjectId'),
      startSchedule?: long(name='StartSchedule'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='Flow')
  }(name='Flow'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFlowResponseBody(name='body'),
}

async function listFlowWithOptions(request: ListFlowRequest, runtime: Util.RuntimeOptions): ListFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.periodic)) {
    query['Periodic'] = request.periodic;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFlow',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlow(request: ListFlowRequest): ListFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowWithOptions(request, runtime);
}

model ListFlowJobHistoryRequest {
  id?: string(name='Id'),
  instanceId?: string(name='InstanceId'),
  jobType?: string(name='JobType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  statusList?: [ string ](name='StatusList'),
  timeRange?: string(name='TimeRange'),
}

model ListFlowJobHistoryResponseBody = {
  nodeInstances?: {
    nodeInstance?: [ 
    {
      clusterId?: string(name='ClusterId'),
      endTime?: long(name='EndTime'),
      envConf?: string(name='EnvConf'),
      externalId?: string(name='ExternalId'),
      externalInfo?: string(name='ExternalInfo'),
      externalStatus?: string(name='ExternalStatus'),
      failAct?: string(name='FailAct'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      hostName?: string(name='HostName'),
      id?: string(name='Id'),
      jobId?: string(name='JobId'),
      jobName?: string(name='JobName'),
      jobParams?: string(name='JobParams'),
      jobType?: string(name='JobType'),
      maxRetry?: int32(name='MaxRetry'),
      nodeName?: string(name='NodeName'),
      paramConf?: string(name='ParamConf'),
      projectId?: string(name='ProjectId'),
      retries?: int32(name='Retries'),
      retryInterval?: long(name='RetryInterval'),
      runConf?: string(name='RunConf'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      pending?: boolean(name='pending'),
    }
  ](name='NodeInstance')
  }(name='NodeInstances'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListFlowJobHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFlowJobHistoryResponseBody(name='body'),
}

async function listFlowJobHistoryWithOptions(request: ListFlowJobHistoryRequest, runtime: Util.RuntimeOptions): ListFlowJobHistoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobType)) {
    query['JobType'] = request.jobType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.timeRange)) {
    query['TimeRange'] = request.timeRange;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowJobHistory',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowJobHistory(request: ListFlowJobHistoryRequest): ListFlowJobHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowJobHistoryWithOptions(request, runtime);
}

model ListFlowJobsRequest {
  adhoc?: boolean(name='Adhoc'),
  exactName?: string(name='ExactName'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
}

model ListFlowJobsResponseBody = {
  jobList?: {
    job?: [ 
    {
      adhoc?: string(name='Adhoc'),
      alertConf?: string(name='AlertConf'),
      categoryId?: string(name='CategoryId'),
      customVariables?: string(name='CustomVariables'),
      description?: string(name='Description'),
      envConf?: string(name='EnvConf'),
      failAct?: string(name='FailAct'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      id?: string(name='Id'),
      lastInstanceDetail?: string(name='LastInstanceDetail'),
      maxRetry?: int32(name='MaxRetry'),
      mode?: string(name='Mode'),
      monitorConf?: string(name='MonitorConf'),
      name?: string(name='Name'),
      paramConf?: string(name='ParamConf'),
      params?: string(name='Params'),
      resourceList?: {
        resource?: [ 
        {
          alias?: string(name='Alias'),
          path?: string(name='Path'),
        }
      ](name='Resource')
      }(name='ResourceList'),
      retryInterval?: long(name='RetryInterval'),
      runConf?: string(name='RunConf'),
      type?: string(name='Type'),
    }
  ](name='Job')
  }(name='JobList'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListFlowJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFlowJobsResponseBody(name='body'),
}

async function listFlowJobsWithOptions(request: ListFlowJobsRequest, runtime: Util.RuntimeOptions): ListFlowJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.adhoc)) {
    query['Adhoc'] = request.adhoc;
  }
  if (!Util.isUnset(request.exactName)) {
    query['ExactName'] = request.exactName;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowJobs',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowJobs(request: ListFlowJobsRequest): ListFlowJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowJobsWithOptions(request, runtime);
}

model ListFlowProjectUserRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model ListFlowProjectUserResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
  users?: {
    user?: [ 
    {
      accountUserId?: string(name='AccountUserId'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      ownerId?: string(name='OwnerId'),
      projectId?: string(name='ProjectId'),
      userName?: string(name='UserName'),
    }
  ](name='User')
  }(name='Users'),
}

model ListFlowProjectUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFlowProjectUserResponseBody(name='body'),
}

async function listFlowProjectUserWithOptions(request: ListFlowProjectUserRequest, runtime: Util.RuntimeOptions): ListFlowProjectUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowProjectUser',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowProjectUser(request: ListFlowProjectUserRequest): ListFlowProjectUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowProjectUserWithOptions(request, runtime);
}

model ListFlowProjectsRequest {
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  productType?: string(name='ProductType'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListFlowProjectsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  projects?: {
    project?: [ 
    {
      description?: string(name='Description'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      userId?: string(name='UserId'),
    }
  ](name='Project')
  }(name='Projects'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
}

model ListFlowProjectsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFlowProjectsResponseBody(name='body'),
}

async function listFlowProjectsWithOptions(request: ListFlowProjectsRequest, runtime: Util.RuntimeOptions): ListFlowProjectsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFlowProjects',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFlowProjects(request: ListFlowProjectsRequest): ListFlowProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowProjectsWithOptions(request, runtime);
}

model ModifyFlowForWebRequest {
  alertConf?: string(name='AlertConf'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
  clusterId?: string(name='ClusterId'),
  createCluster?: boolean(name='CreateCluster'),
  cronExpr?: string(name='CronExpr'),
  description?: string(name='Description'),
  endSchedule?: long(name='EndSchedule'),
  graph?: string(name='Graph'),
  hostName?: string(name='HostName'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  parentCategory?: string(name='ParentCategory'),
  parentFlowList?: string(name='ParentFlowList'),
  periodic?: boolean(name='Periodic'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  startSchedule?: long(name='StartSchedule'),
  status?: string(name='Status'),
}

model ModifyFlowForWebResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyFlowForWebResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyFlowForWebResponseBody(name='body'),
}

async function modifyFlowForWebWithOptions(request: ModifyFlowForWebRequest, runtime: Util.RuntimeOptions): ModifyFlowForWebResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertConf)) {
    query['AlertConf'] = request.alertConf;
  }
  if (!Util.isUnset(request.alertDingDingGroupBizId)) {
    query['AlertDingDingGroupBizId'] = request.alertDingDingGroupBizId;
  }
  if (!Util.isUnset(request.alertUserGroupBizId)) {
    query['AlertUserGroupBizId'] = request.alertUserGroupBizId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.createCluster)) {
    query['CreateCluster'] = request.createCluster;
  }
  if (!Util.isUnset(request.cronExpr)) {
    query['CronExpr'] = request.cronExpr;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endSchedule)) {
    query['EndSchedule'] = request.endSchedule;
  }
  if (!Util.isUnset(request.graph)) {
    query['Graph'] = request.graph;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.parentCategory)) {
    query['ParentCategory'] = request.parentCategory;
  }
  if (!Util.isUnset(request.parentFlowList)) {
    query['ParentFlowList'] = request.parentFlowList;
  }
  if (!Util.isUnset(request.periodic)) {
    query['Periodic'] = request.periodic;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startSchedule)) {
    query['StartSchedule'] = request.startSchedule;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFlowForWeb',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyFlowForWeb(request: ModifyFlowForWebRequest): ModifyFlowForWebResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowForWebWithOptions(request, runtime);
}

model ModifyFlowJobRequest {
  alertConf?: string(name='AlertConf'),
  clusterId?: string(name='ClusterId'),
  customVariables?: string(name='CustomVariables'),
  description?: string(name='Description'),
  envConf?: string(name='EnvConf'),
  failAct?: string(name='FailAct'),
  id?: string(name='Id'),
  knoxPassword?: string(name='KnoxPassword'),
  knoxUser?: string(name='KnoxUser'),
  maxRetry?: int32(name='MaxRetry'),
  mode?: string(name='Mode'),
  monitorConf?: string(name='MonitorConf'),
  name?: string(name='Name'),
  paramConf?: string(name='ParamConf'),
  params?: string(name='Params'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  resourceList?: [ 
    {
      alias?: string(name='Alias'),
      path?: string(name='Path'),
    }
  ](name='ResourceList'),
  retryInterval?: long(name='RetryInterval'),
  retryPolicy?: string(name='RetryPolicy'),
  runConf?: string(name='RunConf'),
}

model ModifyFlowJobResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyFlowJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyFlowJobResponseBody(name='body'),
}

async function modifyFlowJobWithOptions(request: ModifyFlowJobRequest, runtime: Util.RuntimeOptions): ModifyFlowJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertConf)) {
    query['AlertConf'] = request.alertConf;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.customVariables)) {
    query['CustomVariables'] = request.customVariables;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.envConf)) {
    query['EnvConf'] = request.envConf;
  }
  if (!Util.isUnset(request.failAct)) {
    query['FailAct'] = request.failAct;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.knoxPassword)) {
    query['KnoxPassword'] = request.knoxPassword;
  }
  if (!Util.isUnset(request.knoxUser)) {
    query['KnoxUser'] = request.knoxUser;
  }
  if (!Util.isUnset(request.maxRetry)) {
    query['MaxRetry'] = request.maxRetry;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.monitorConf)) {
    query['MonitorConf'] = request.monitorConf;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.paramConf)) {
    query['ParamConf'] = request.paramConf;
  }
  if (!Util.isUnset(request.params)) {
    query['Params'] = request.params;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceList)) {
    query['ResourceList'] = request.resourceList;
  }
  if (!Util.isUnset(request.retryInterval)) {
    query['RetryInterval'] = request.retryInterval;
  }
  if (!Util.isUnset(request.retryPolicy)) {
    query['RetryPolicy'] = request.retryPolicy;
  }
  if (!Util.isUnset(request.runConf)) {
    query['RunConf'] = request.runConf;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFlowJob',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyFlowJob(request: ModifyFlowJobRequest): ModifyFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowJobWithOptions(request, runtime);
}

model ModifyFlowProjectRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model ModifyFlowProjectResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyFlowProjectResponseBody(name='body'),
}

async function modifyFlowProjectWithOptions(request: ModifyFlowProjectRequest, runtime: Util.RuntimeOptions): ModifyFlowProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyFlowProject',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyFlowProject(request: ModifyFlowProjectRequest): ModifyFlowProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowProjectWithOptions(request, runtime);
}

model ReleaseClusterRequest {
  forceRelease?: boolean(name='ForceRelease'),
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ReleaseClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseClusterResponseBody(name='body'),
}

async function releaseClusterWithOptions(request: ReleaseClusterRequest, runtime: Util.RuntimeOptions): ReleaseClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.forceRelease)) {
    query['ForceRelease'] = request.forceRelease;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseCluster',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseCluster(request: ReleaseClusterRequest): ReleaseClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseClusterWithOptions(request, runtime);
}

model RerunFlowRequest {
  flowInstanceId?: string(name='FlowInstanceId'),
  projectId?: string(name='ProjectId'),
  reRunFail?: boolean(name='ReRunFail'),
  regionId?: string(name='RegionId'),
}

model RerunFlowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model RerunFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RerunFlowResponseBody(name='body'),
}

async function rerunFlowWithOptions(request: RerunFlowRequest, runtime: Util.RuntimeOptions): RerunFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.flowInstanceId)) {
    query['FlowInstanceId'] = request.flowInstanceId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.reRunFail)) {
    query['ReRunFail'] = request.reRunFail;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RerunFlow',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rerunFlow(request: RerunFlowRequest): RerunFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return rerunFlowWithOptions(request, runtime);
}

model ResumeFlowRequest {
  flowInstanceId?: string(name='FlowInstanceId'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model ResumeFlowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ResumeFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResumeFlowResponseBody(name='body'),
}

async function resumeFlowWithOptions(request: ResumeFlowRequest, runtime: Util.RuntimeOptions): ResumeFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.flowInstanceId)) {
    query['FlowInstanceId'] = request.flowInstanceId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResumeFlow',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resumeFlow(request: ResumeFlowRequest): ResumeFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeFlowWithOptions(request, runtime);
}

model SubmitFlowRequest {
  conf?: string(name='Conf'),
  flowId?: string(name='FlowId'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model SubmitFlowResponseBody = {
  data?: string(name='Data'),
  id?: string(name='Id'),
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
}

model SubmitFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitFlowResponseBody(name='body'),
}

async function submitFlowWithOptions(request: SubmitFlowRequest, runtime: Util.RuntimeOptions): SubmitFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.conf)) {
    query['Conf'] = request.conf;
  }
  if (!Util.isUnset(request.flowId)) {
    query['FlowId'] = request.flowId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitFlow',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitFlow(request: SubmitFlowRequest): SubmitFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFlowWithOptions(request, runtime);
}

model SubmitFlowJobRequest {
  clusterId?: string(name='ClusterId'),
  conf?: string(name='Conf'),
  hostName?: string(name='HostName'),
  jobId?: string(name='JobId'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model SubmitFlowJobResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model SubmitFlowJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitFlowJobResponseBody(name='body'),
}

async function submitFlowJobWithOptions(request: SubmitFlowJobRequest, runtime: Util.RuntimeOptions): SubmitFlowJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.conf)) {
    query['Conf'] = request.conf;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitFlowJob',
    version = '2020-06-17',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitFlowJob(request: SubmitFlowJobRequest): SubmitFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFlowJobWithOptions(request, runtime);
}

