/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  @endpointMap = {
    cn-qingdao = 'ddi.cn-qingdao.aliyuncs.com',
    cn-chengdu = 'ddi.cn-chengdu.aliyuncs.com',
    cn-zhangjiakou = 'ddi.cn-zhangjiakou.aliyuncs.com',
    cn-huhehaote = 'ddi.cn-huhehaote.aliyuncs.com',
    cn-hongkong = 'ddi.cn-hongkong.aliyuncs.com',
    ap-southeast-2 = 'ddi.ap-southeast-2.aliyuncs.com',
    ap-southeast-3 = 'ddi.ap-southeast-3.aliyuncs.com',
    ap-southeast-5 = 'ddi.ap-southeast-5.aliyuncs.com',
    ap-northeast-1 = 'ddi.ap-northeast-1.aliyuncs.com',
    eu-west-1 = 'ddi.eu-west-1.aliyuncs.com',
    us-east-1 = 'ddi.us-east-1.aliyuncs.com',
    eu-central-1 = 'ddi.eu-central-1.aliyuncs.com',
    me-east-1 = 'ddi.me-east-1.aliyuncs.com',
    ap-south-1 = 'ddi.ap-south-1.aliyuncs.com',
  };
  checkConfig(config);
  @endpoint = getEndpoint('ddi', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CreateFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  startSchedule?: long(name='StartSchedule'),
  endSchedule?: long(name='EndSchedule'),
  cronExpression?: string(name='CronExpression'),
  createCluster?: boolean(name='CreateCluster'),
  clusterId?: string(name='ClusterId'),
  hostName?: string(name='HostName'),
  namespace?: string(name='Namespace'),
  application?: string(name='Application'),
  alertConf?: string(name='AlertConf'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
  parentFlowList?: string(name='ParentFlowList'),
  parentCategory?: string(name='ParentCategory'),
  clientToken?: string(name='ClientToken'),
}

model CreateFlowResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateFlowResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowResponseBody(name='body'),
}

async function createFlowWithOptions(request: CreateFlowRequest, runtime: Util.RuntimeOptions): CreateFlowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateFlow', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createFlow(request: CreateFlowRequest): CreateFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowWithOptions(request, runtime);
}

model ListUsersRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  type?: string(name='Type'),
}

model ListUsersResponseBody = {
  requestId?: string(name='RequestId'),
  userList?: {
    user?: [ 
    {
      linuxStatus?: string(name='LinuxStatus'),
      k8sStatus?: string(name='K8sStatus'),
      knoxStatus?: string(name='KnoxStatus'),
      groupName?: string(name='GroupName'),
      userId?: string(name='UserId'),
      kerberosStatus?: string(name='KerberosStatus'),
      userName?: string(name='UserName'),
    }
  ](name='User')
  }(name='UserList'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListUsers', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model ModifyFlowProjectRequest {
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
}

model ModifyFlowProjectResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowProjectResponseBody(name='body'),
}

async function modifyFlowProjectWithOptions(request: ModifyFlowProjectRequest, runtime: Util.RuntimeOptions): ModifyFlowProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyFlowProject', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyFlowProject(request: ModifyFlowProjectRequest): ModifyFlowProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowProjectWithOptions(request, runtime);
}

model QueryKnoxUserPasswordRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  userId?: string(name='UserId'),
  ownerId?: string(name='OwnerId'),
  clusterId?: string(name='ClusterId'),
}

model QueryKnoxUserPasswordResponseBody = {
  requestId?: string(name='RequestId'),
  userInfoList?: {
    userInfo?: [ 
    {
      password?: string(name='Password'),
      userName?: string(name='UserName'),
      userId?: string(name='UserId'),
    }
  ](name='UserInfo')
  }(name='UserInfoList'),
}

model QueryKnoxUserPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: QueryKnoxUserPasswordResponseBody(name='body'),
}

async function queryKnoxUserPasswordWithOptions(request: QueryKnoxUserPasswordRequest, runtime: Util.RuntimeOptions): QueryKnoxUserPasswordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryKnoxUserPassword', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryKnoxUserPassword(request: QueryKnoxUserPasswordRequest): QueryKnoxUserPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryKnoxUserPasswordWithOptions(request, runtime);
}

model DescribeFlowNodeInstanceLauncherLogRequest {
  start?: int32(name='Start'),
  lines?: int32(name='Lines'),
  offset?: int32(name='Offset'),
  length?: int32(name='Length'),
  reverse?: boolean(name='Reverse'),
  startTime?: long(name='StartTime'),
  endTime?: long(name='EndTime'),
  nodeInstanceId?: string(name='NodeInstanceId'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowNodeInstanceLauncherLogResponseBody = {
  logEnd?: boolean(name='LogEnd'),
  requestId?: string(name='RequestId'),
  logEntrys?: {
    logEntry?: [ 
    {
      content?: string(name='Content'),
    }
  ](name='LogEntry')
  }(name='LogEntrys'),
}

model DescribeFlowNodeInstanceLauncherLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowNodeInstanceLauncherLogResponseBody(name='body'),
}

async function describeFlowNodeInstanceLauncherLogWithOptions(request: DescribeFlowNodeInstanceLauncherLogRequest, runtime: Util.RuntimeOptions): DescribeFlowNodeInstanceLauncherLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeFlowNodeInstanceLauncherLog', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeFlowNodeInstanceLauncherLog(request: DescribeFlowNodeInstanceLauncherLogRequest): DescribeFlowNodeInstanceLauncherLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowNodeInstanceLauncherLogWithOptions(request, runtime);
}

model ListFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  jobId?: string(name='JobId'),
  name?: string(name='Name'),
  id?: string(name='Id'),
  clusterId?: string(name='ClusterId'),
  status?: string(name='Status'),
  periodic?: boolean(name='Periodic'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListFlowResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  total?: int32(name='Total'),
  flow?: {
    flow?: [ 
    {
      status?: string(name='Status'),
      type?: string(name='Type'),
      alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
      periodic?: boolean(name='Periodic'),
      projectId?: string(name='ProjectId'),
      hostName?: string(name='HostName'),
      gmtModified?: long(name='GmtModified'),
      description?: string(name='Description'),
      createCluster?: boolean(name='CreateCluster'),
      startSchedule?: long(name='StartSchedule'),
      endSchedule?: long(name='EndSchedule'),
      graph?: string(name='Graph'),
      alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
      gmtCreate?: long(name='GmtCreate'),
      categoryId?: string(name='CategoryId'),
      cronExpr?: string(name='CronExpr'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      alertConf?: string(name='AlertConf'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='Flow')
  }(name='Flow'),
}

model ListFlowResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowResponseBody(name='body'),
}

async function listFlowWithOptions(request: ListFlowRequest, runtime: Util.RuntimeOptions): ListFlowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlow', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlow(request: ListFlowRequest): ListFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowWithOptions(request, runtime);
}

model UntagResourcesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceType?: string(name='ResourceType', description='资源类型'),
  resourceIds?: [ string ](name='ResourceIds', description='集群ID列表'),
  tagKeys?: [ string ](name='TagKeys', description='解绑的标签键列表'),
  all?: boolean(name='All', description='是否解绑资源的所有标签'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success', description='请求是否成功被处理'),
  code?: string(name='Code', description='响应码'),
  errorCode?: string(name='ErrorCode', description='错误码'),
  message?: string(name='Message', description='响应消息'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UntagResources', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model ListFlowClusterHostRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  clusterId?: string(name='ClusterId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListFlowClusterHostResponseBody = {
  requestId?: string(name='RequestId'),
  hostList?: {
    host?: [ 
    {
      status?: string(name='Status'),
      type?: string(name='Type'),
      serialNumber?: string(name='SerialNumber'),
      privateIp?: string(name='PrivateIp'),
      hostName?: string(name='HostName'),
      instanceType?: string(name='InstanceType'),
      hostId?: string(name='HostId'),
      hostInstanceId?: string(name='HostInstanceId'),
      cpu?: int32(name='Cpu'),
      publicIp?: string(name='PublicIp'),
      memory?: int32(name='Memory'),
      role?: string(name='Role'),
    }
  ](name='Host')
  }(name='HostList'),
}

model ListFlowClusterHostResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowClusterHostResponseBody(name='body'),
}

async function listFlowClusterHostWithOptions(request: ListFlowClusterHostRequest, runtime: Util.RuntimeOptions): ListFlowClusterHostResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlowClusterHost', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlowClusterHost(request: ListFlowClusterHostRequest): ListFlowClusterHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowClusterHostWithOptions(request, runtime);
}

model ListClusterOperationRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
  status?: string(name='Status'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterOperationResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  clusterOperationList?: {
    clusterOperation?: [ 
    {
      status?: string(name='Status'),
      startTime?: string(name='StartTime'),
      comment?: string(name='Comment'),
      operationName?: string(name='OperationName'),
      operationId?: string(name='OperationId'),
      duration?: string(name='Duration'),
      percentage?: string(name='Percentage'),
    }
  ](name='ClusterOperation')
  }(name='ClusterOperationList'),
}

model ListClusterOperationResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterOperationResponseBody(name='body'),
}

async function listClusterOperationWithOptions(request: ListClusterOperationRequest, runtime: Util.RuntimeOptions): ListClusterOperationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListClusterOperation', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusterOperation(request: ListClusterOperationRequest): ListClusterOperationResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterOperationWithOptions(request, runtime);
}

model ListFlowEntitySnapshotRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  limit?: int32(name='Limit'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  currentSize?: int32(name='CurrentSize'),
  pageCount?: int32(name='PageCount'),
  orderField?: string(name='OrderField'),
  orderMode?: string(name='OrderMode'),
  committerId?: string(name='CommitterId'),
  entityType?: string(name='EntityType'),
  entityGroupId?: string(name='EntityGroupId'),
  entityId?: string(name='EntityId'),
  revision?: string(name='Revision'),
}

model ListFlowEntitySnapshotResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  totalCount?: int32(name='TotalCount'),
  items?: {
    item?: [ 
    {
      active?: boolean(name='Active'),
      data?: string(name='Data'),
      entityId?: string(name='EntityId'),
      entityType?: string(name='EntityType'),
      userId?: string(name='UserId'),
      gmtCreate?: long(name='GmtCreate'),
      message?: string(name='Message'),
      entityGroupId?: string(name='EntityGroupId'),
      committerId?: string(name='CommitterId'),
      revision?: string(name='Revision'),
    }
  ](name='Item')
  }(name='Items'),
}

model ListFlowEntitySnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowEntitySnapshotResponseBody(name='body'),
}

async function listFlowEntitySnapshotWithOptions(request: ListFlowEntitySnapshotRequest, runtime: Util.RuntimeOptions): ListFlowEntitySnapshotResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlowEntitySnapshot', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlowEntitySnapshot(request: ListFlowEntitySnapshotRequest): ListFlowEntitySnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowEntitySnapshotWithOptions(request, runtime);
}

model DeleteClusterTemplateRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  bizId?: string(name='BizId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DeleteClusterTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteClusterTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterTemplateResponseBody(name='body'),
}

async function deleteClusterTemplateWithOptions(request: DeleteClusterTemplateRequest, runtime: Util.RuntimeOptions): DeleteClusterTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteClusterTemplate', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteClusterTemplate(request: DeleteClusterTemplateRequest): DeleteClusterTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterTemplateWithOptions(request, runtime);
}

model CancelOrderRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
}

model CancelOrderResponseBody = {
  clusterId?: string(name='clusterId'),
  requestId?: string(name='RequestId'),
}

model CancelOrderResponse = {
  headers: map[string]string(name='headers'),
  body: CancelOrderResponseBody(name='body'),
}

async function cancelOrderWithOptions(request: CancelOrderRequest, runtime: Util.RuntimeOptions): CancelOrderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CancelOrder', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cancelOrder(request: CancelOrderRequest): CancelOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelOrderWithOptions(request, runtime);
}

model CloneFlowJobRequest {
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
}

model CloneFlowJobResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CloneFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: CloneFlowJobResponseBody(name='body'),
}

async function cloneFlowJobWithOptions(request: CloneFlowJobRequest, runtime: Util.RuntimeOptions): CloneFlowJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CloneFlowJob', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cloneFlowJob(request: CloneFlowJobRequest): CloneFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneFlowJobWithOptions(request, runtime);
}

model StartFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  flowInstanceId?: string(name='FlowInstanceId'),
}

model StartFlowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model StartFlowResponse = {
  headers: map[string]string(name='headers'),
  body: StartFlowResponseBody(name='body'),
}

async function startFlowWithOptions(request: StartFlowRequest, runtime: Util.RuntimeOptions): StartFlowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StartFlow', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function startFlow(request: StartFlowRequest): StartFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return startFlowWithOptions(request, runtime);
}

model CreateFlowJobRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  type?: string(name='Type'),
  failAct?: string(name='FailAct'),
  retryPolicy?: string(name='RetryPolicy'),
  params?: string(name='Params'),
  paramConf?: string(name='ParamConf'),
  customVariables?: string(name='CustomVariables'),
  envConf?: string(name='EnvConf'),
  runConf?: string(name='RunConf'),
  monitorConf?: string(name='MonitorConf'),
  mode?: string(name='Mode'),
  parentCategory?: string(name='ParentCategory'),
  adhoc?: boolean(name='Adhoc'),
  clusterId?: string(name='ClusterId'),
  alertConf?: string(name='AlertConf'),
  clientToken?: string(name='ClientToken'),
  resourceList?: [ 
    {
      path?: string(name='Path'),
      alias?: string(name='Alias'),
    }
  ](name='ResourceList'),
}

model CreateFlowJobResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowJobResponseBody(name='body'),
}

async function createFlowJobWithOptions(request: CreateFlowJobRequest, runtime: Util.RuntimeOptions): CreateFlowJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateFlowJob', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createFlowJob(request: CreateFlowJobRequest): CreateFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowJobWithOptions(request, runtime);
}

model DeleteFlowCategoryRequest {
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
}

model DeleteFlowCategoryResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowCategoryResponseBody(name='body'),
}

async function deleteFlowCategoryWithOptions(request: DeleteFlowCategoryRequest, runtime: Util.RuntimeOptions): DeleteFlowCategoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFlowCategory', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFlowCategory(request: DeleteFlowCategoryRequest): DeleteFlowCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowCategoryWithOptions(request, runtime);
}

model DeleteFlowEditLockRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  entityId?: string(name='EntityId'),
}

model DeleteFlowEditLockResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowEditLockResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowEditLockResponseBody(name='body'),
}

async function deleteFlowEditLockWithOptions(request: DeleteFlowEditLockRequest, runtime: Util.RuntimeOptions): DeleteFlowEditLockResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFlowEditLock', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFlowEditLock(request: DeleteFlowEditLockRequest): DeleteFlowEditLockResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowEditLockWithOptions(request, runtime);
}

model ResizeClusterRequest {
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  autoPayOrder?: boolean(name='AutoPayOrder'),
  vswitchId?: string(name='VswitchId'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
  hostComponentInfo?: [ 
    {
      componentNameList?: [ string ](name='ComponentNameList'),
      hostName?: string(name='HostName'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='HostComponentInfo'),
  hostGroup?: [ 
    {
      sysDiskCapacity?: int32(name='SysDiskCapacity'),
      hostGroupType?: string(name='HostGroupType'),
      comment?: string(name='Comment'),
      vswitchId?: int32(name='VswitchId'),
      sysDiskType?: string(name='SysDiskType'),
      autoRenew?: boolean(name='AutoRenew'),
      chargeType?: string(name='ChargeType'),
      diskType?: string(name='DiskType'),
      hostGroupId?: string(name='HostGroupId'),
      instanceType?: string(name='InstanceType'),
      hostKeyPairName?: string(name='HostKeyPairName'),
      diskCount?: int32(name='DiskCount'),
      createType?: string(name='CreateType'),
      period?: int32(name='Period'),
      hostPassword?: string(name='HostPassword'),
      diskCapacity?: int32(name='DiskCapacity'),
      nodeCount?: int32(name='NodeCount'),
      hostGroupName?: string(name='HostGroupName'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='HostGroup'),
  promotionInfo?: [ 
    {
      promotionOptionNo?: string(name='PromotionOptionNo'),
      promotionOptionCode?: string(name='PromotionOptionCode'),
      productCode?: string(name='ProductCode'),
    }
  ](name='PromotionInfo'),
}

model ResizeClusterResponseBody = {
  requestId?: string(name='RequestId'),
  clusterId?: string(name='ClusterId'),
}

model ResizeClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ResizeClusterResponseBody(name='body'),
}

async function resizeClusterWithOptions(request: ResizeClusterRequest, runtime: Util.RuntimeOptions): ResizeClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ResizeCluster', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function resizeCluster(request: ResizeClusterRequest): ResizeClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return resizeClusterWithOptions(request, runtime);
}

model DescribeMetaTablePreviewTaskRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  taskId?: string(name='TaskId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeMetaTablePreviewTaskResponseBody = {
  endTime?: long(name='EndTime'),
  startTime?: long(name='StartTime'),
  requestId?: string(name='RequestId'),
  taskStatus?: string(name='TaskStatus'),
  taskProcess?: int32(name='TaskProcess'),
  executeTime?: long(name='ExecuteTime'),
  taskId?: string(name='TaskId'),
  data?: {
    rows?: {
      row?: [ 
      {
        columns?: {
          column?: [ string ](name='Column')
        }(name='Columns'),
      }
    ](name='Row')
    }(name='Rows'),
    headers?: {
      header?: [ string ](name='Header')
    }(name='Headers'),
  }(name='Data'),
}

model DescribeMetaTablePreviewTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMetaTablePreviewTaskResponseBody(name='body'),
}

async function describeMetaTablePreviewTaskWithOptions(request: DescribeMetaTablePreviewTaskRequest, runtime: Util.RuntimeOptions): DescribeMetaTablePreviewTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeMetaTablePreviewTask', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeMetaTablePreviewTask(request: DescribeMetaTablePreviewTaskRequest): DescribeMetaTablePreviewTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetaTablePreviewTaskWithOptions(request, runtime);
}

model ListClusterServiceConfigHistoryRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
  configVersion?: string(name='ConfigVersion'),
  hostGroupId?: string(name='HostGroupId'),
  hostInstanceId?: string(name='HostInstanceId'),
  configFileName?: string(name='ConfigFileName'),
  configItemKey?: string(name='ConfigItemKey'),
  author?: string(name='Author'),
  comment?: string(name='Comment'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterServiceConfigHistoryResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  configHistoryList?: {
    configHistory?: [ 
    {
      oldValue?: string(name='OldValue'),
      comment?: string(name='Comment'),
      createTime?: long(name='CreateTime'),
      hostName?: string(name='HostName'),
      author?: string(name='Author'),
      configItemName?: string(name='ConfigItemName'),
      hostGroupId?: string(name='HostGroupId'),
      newValue?: string(name='NewValue'),
      hostInstanceId?: string(name='HostInstanceId'),
      configFileName?: string(name='ConfigFileName'),
      applied?: boolean(name='Applied'),
      configVersion?: string(name='ConfigVersion'),
      serviceName?: string(name='ServiceName'),
      hostGroupName?: string(name='HostGroupName'),
    }
  ](name='ConfigHistory')
  }(name='ConfigHistoryList'),
}

model ListClusterServiceConfigHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterServiceConfigHistoryResponseBody(name='body'),
}

async function listClusterServiceConfigHistoryWithOptions(request: ListClusterServiceConfigHistoryRequest, runtime: Util.RuntimeOptions): ListClusterServiceConfigHistoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListClusterServiceConfigHistory', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusterServiceConfigHistory(request: ListClusterServiceConfigHistoryRequest): ListClusterServiceConfigHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterServiceConfigHistoryWithOptions(request, runtime);
}

model ModifyScalingConfigItemRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='resourceGroupId'),
  configItemInformation?: string(name='ConfigItemInformation'),
  configItemType?: string(name='ConfigItemType'),
  configItemBizId?: string(name='ConfigItemBizId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
}

model ModifyScalingConfigItemResponseBody = {
  requestId?: string(name='RequestId', description='requestId'),
  data?: boolean(name='Data', description='data'),
}

model ModifyScalingConfigItemResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyScalingConfigItemResponseBody(name='body'),
}

async function modifyScalingConfigItemWithOptions(request: ModifyScalingConfigItemRequest, runtime: Util.RuntimeOptions): ModifyScalingConfigItemResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyScalingConfigItem', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyScalingConfigItem(request: ModifyScalingConfigItemRequest): ModifyScalingConfigItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyScalingConfigItemWithOptions(request, runtime);
}

model ListFlowClusterAllRequest {
  productType?: string(name='ProductType'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListFlowClusterAllResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  clusters?: {
    clusterInfo?: [ 
    {
      type?: string(name='Type'),
      status?: string(name='Status'),
      runningTime?: int32(name='RunningTime'),
      orderList?: string(name='OrderList'),
      createTime?: long(name='CreateTime'),
      chargeType?: string(name='ChargeType'),
      period?: int32(name='Period'),
      k8sClusterId?: string(name='K8sClusterId'),
      expiredTime?: long(name='ExpiredTime'),
      hasUncompletedOrder?: boolean(name='HasUncompletedOrder'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      createResource?: string(name='CreateResource'),
      orderTaskInfo?: {
        targetCount?: int32(name='TargetCount'),
        currentCount?: int32(name='CurrentCount'),
        orderIdList?: string(name='OrderIdList'),
      }(name='OrderTaskInfo'),
      failReason?: {
        errorMsg?: string(name='ErrorMsg'),
        requestId?: string(name='RequestId'),
        errorCode?: string(name='ErrorCode'),
      }(name='FailReason'),
    }
  ](name='ClusterInfo')
  }(name='Clusters'),
}

model ListFlowClusterAllResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowClusterAllResponseBody(name='body'),
}

async function listFlowClusterAllWithOptions(request: ListFlowClusterAllRequest, runtime: Util.RuntimeOptions): ListFlowClusterAllResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlowClusterAll', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlowClusterAll(request: ListFlowClusterAllRequest): ListFlowClusterAllResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowClusterAllWithOptions(request, runtime);
}

model DescribeScalingGroupRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  hostGroupBizId?: string(name='HostGroupBizId'),
}

model DescribeScalingGroupResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  scalingGroupId?: string(name='ScalingGroupId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  activeStatus?: string(name='ActiveStatus'),
  hostGroupBizId?: string(name='HostGroupBizId'),
  scalingInMode?: string(name='ScalingInMode'),
  scalingMinSize?: long(name='ScalingMinSize'),
  scalingMaxSize?: long(name='ScalingMaxSize'),
  configState?: string(name='ConfigState'),
}

model DescribeScalingGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingGroupResponseBody(name='body'),
}

async function describeScalingGroupWithOptions(request: DescribeScalingGroupRequest, runtime: Util.RuntimeOptions): DescribeScalingGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeScalingGroup', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeScalingGroup(request: DescribeScalingGroupRequest): DescribeScalingGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingGroupWithOptions(request, runtime);
}

model ListScalingGroupRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  limit?: long(name='limit'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  currentSize?: long(name='CurrentSize'),
  pageCount?: long(name='PageCount'),
  orderField?: string(name='OrderField'),
  orderMode?: string(name='OrderMode'),
  clusterBizId?: string(name='ClusterBizId'),
}

model ListScalingGroupResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  totalCount?: long(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  items?: {
    item?: [ 
    {
      scalingGroupId?: string(name='ScalingGroupId'),
      name?: string(name='Name'),
      description?: string(name='Description'),
      activeStatus?: string(name='ActiveStatus'),
      hostGroupBizId?: string(name='HostGroupBizId'),
      scalingInMode?: string(name='ScalingInMode'),
      scalingMinSize?: string(name='ScalingMinSize'),
      scalingMaxSize?: string(name='ScalingMaxSize'),
    }
  ](name='Item')
  }(name='Items'),
}

model ListScalingGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListScalingGroupResponseBody(name='body'),
}

async function listScalingGroupWithOptions(request: ListScalingGroupRequest, runtime: Util.RuntimeOptions): ListScalingGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListScalingGroup', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listScalingGroup(request: ListScalingGroupRequest): ListScalingGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listScalingGroupWithOptions(request, runtime);
}

model ModifyFlowCategoryRequest {
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  parentId?: string(name='ParentId'),
}

model ModifyFlowCategoryResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyFlowCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowCategoryResponseBody(name='body'),
}

async function modifyFlowCategoryWithOptions(request: ModifyFlowCategoryRequest, runtime: Util.RuntimeOptions): ModifyFlowCategoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyFlowCategory', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyFlowCategory(request: ModifyFlowCategoryRequest): ModifyFlowCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowCategoryWithOptions(request, runtime);
}

model ModifyClusterServiceConfigRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
  comment?: string(name='Comment'),
  configParams?: string(name='ConfigParams'),
  customConfigParams?: string(name='CustomConfigParams'),
  groupId?: string(name='GroupId'),
  hostInstanceId?: string(name='HostInstanceId'),
  configType?: string(name='ConfigType'),
  refreshHostConfig?: boolean(name='RefreshHostConfig'),
  gatewayClusterIdList?: [ string ](name='GatewayClusterIdList'),
}

model ModifyClusterServiceConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterServiceConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterServiceConfigResponseBody(name='body'),
}

async function modifyClusterServiceConfigWithOptions(request: ModifyClusterServiceConfigRequest, runtime: Util.RuntimeOptions): ModifyClusterServiceConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyClusterServiceConfig', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyClusterServiceConfig(request: ModifyClusterServiceConfigRequest): ModifyClusterServiceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterServiceConfigWithOptions(request, runtime);
}

model CloneFlowRequest {
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
}

model CloneFlowResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CloneFlowResponse = {
  headers: map[string]string(name='headers'),
  body: CloneFlowResponseBody(name='body'),
}

async function cloneFlowWithOptions(request: CloneFlowRequest, runtime: Util.RuntimeOptions): CloneFlowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CloneFlow', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function cloneFlow(request: CloneFlowRequest): CloneFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneFlowWithOptions(request, runtime);
}

model CreateClusterTemplateRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  templateName?: string(name='TemplateName'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  logPath?: string(name='LogPath'),
  securityGroupId?: string(name='SecurityGroupId'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
  securityGroupName?: string(name='SecurityGroupName'),
  period?: int32(name='Period'),
  renewAuto?: boolean(name='RenewAuto'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  netType?: string(name='NetType'),
  userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
  emrVer?: string(name='EmrVer'),
  clusterType?: string(name='ClusterType'),
  enableHighAvailability?: boolean(name='EnableHighAvailability'),
  useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
  ioOptimizedOption?: boolean(name='IoOptimizedOption'),
  enableSsh?: boolean(name='EnableSsh'),
  instanceGeneration?: string(name='InstanceGeneration'),
  masterPwd?: string(name='MasterPwd'),
  keyPairName?: string(name='KeyPairName'),
  metaStoreType?: string(name='MetaStoreType'),
  metaStoreConf?: string(name='MetaStoreConf'),
  configurations?: string(name='Configurations'),
  enableEas?: boolean(name='EnableEas'),
  depositType?: string(name='DepositType'),
  machineType?: string(name='MachineType'),
  useCustomHiveMetaDb?: boolean(name='UseCustomHiveMetaDb'),
  initCustomHiveMetaDb?: boolean(name='InitCustomHiveMetaDb'),
  resourceGroupId?: string(name='ResourceGroupId'),
  clientToken?: string(name='ClientToken'),
  optionSoftWareList?: [ string ](name='OptionSoftWareList'),
  hostGroup?: [ 
    {
      sysDiskCapacity?: int32(name='SysDiskCapacity'),
      hostGroupType?: string(name='HostGroupType'),
      comment?: string(name='Comment'),
      multiInstanceTypes?: string(name='MultiInstanceTypes'),
      sysDiskType?: string(name='SysDiskType'),
      autoRenew?: boolean(name='AutoRenew'),
      chargeType?: string(name='ChargeType'),
      diskType?: string(name='DiskType'),
      hostGroupId?: string(name='HostGroupId'),
      instanceType?: string(name='InstanceType'),
      diskCount?: int32(name='DiskCount'),
      createType?: string(name='CreateType'),
      period?: int32(name='Period'),
      diskCapacity?: int32(name='DiskCapacity'),
      vSwitchId?: string(name='VSwitchId'),
      nodeCount?: int32(name='NodeCount'),
      hostGroupName?: string(name='HostGroupName'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='HostGroup'),
  bootstrapAction?: [ 
    {
      arg?: string(name='Arg'),
      path?: string(name='Path'),
      name?: string(name='Name'),
    }
  ](name='BootstrapAction'),
  config?: [ 
    {
      configValue?: string(name='ConfigValue'),
      replace?: string(name='Replace'),
      fileName?: string(name='FileName'),
      serviceName?: string(name='ServiceName'),
      configKey?: string(name='ConfigKey'),
      encrypt?: string(name='Encrypt'),
    }
  ](name='Config'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model CreateClusterTemplateResponseBody = {
  clusterTemplateId?: string(name='ClusterTemplateId'),
  requestId?: string(name='RequestId'),
}

model CreateClusterTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterTemplateResponseBody(name='body'),
}

async function createClusterTemplateWithOptions(request: CreateClusterTemplateRequest, runtime: Util.RuntimeOptions): CreateClusterTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateClusterTemplate', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createClusterTemplate(request: CreateClusterTemplateRequest): CreateClusterTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterTemplateWithOptions(request, runtime);
}

model UpdateLibraryInstallTaskStatusRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  taskBizId?: string(name='TaskBizId'),
  status?: string(name='Status'),
}

model UpdateLibraryInstallTaskStatusResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateLibraryInstallTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLibraryInstallTaskStatusResponseBody(name='body'),
}

async function updateLibraryInstallTaskStatusWithOptions(request: UpdateLibraryInstallTaskStatusRequest, runtime: Util.RuntimeOptions): UpdateLibraryInstallTaskStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateLibraryInstallTaskStatus', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateLibraryInstallTaskStatus(request: UpdateLibraryInstallTaskStatusRequest): UpdateLibraryInstallTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLibraryInstallTaskStatusWithOptions(request, runtime);
}

model ListScalingConfigItemRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  limit?: long(name='limit'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  currentSize?: long(name='CurrentSize'),
  pageCount?: long(name='PageCount'),
  orderField?: string(name='OrderField'),
  orderMode?: string(name='OrderMode'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  configItemType?: string(name='ConfigItemType'),
}

model ListScalingConfigItemResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  totalCount?: long(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  items?: {
    items?: [ 
    {
      configItemType?: string(name='ConfigItemType'),
      scalingGroupBizId?: string(name='ScalingGroupBizId'),
      scalingConfigItemBizId?: string(name='ScalingConfigItemBizId'),
      configItemInformation?: string(name='ConfigItemInformation'),
    }
  ](name='items')
  }(name='Items'),
}

model ListScalingConfigItemResponse = {
  headers: map[string]string(name='headers'),
  body: ListScalingConfigItemResponseBody(name='body'),
}

async function listScalingConfigItemWithOptions(request: ListScalingConfigItemRequest, runtime: Util.RuntimeOptions): ListScalingConfigItemResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListScalingConfigItem', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listScalingConfigItem(request: ListScalingConfigItemRequest): ListScalingConfigItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return listScalingConfigItemWithOptions(request, runtime);
}

model ListFlowInstanceRequest {
  id?: string(name='Id'),
  flowId?: string(name='FlowId'),
  flowName?: string(name='FlowName'),
  owner?: string(name='Owner'),
  instanceId?: string(name='InstanceId'),
  timeRange?: string(name='TimeRange'),
  orderBy?: string(name='OrderBy'),
  orderType?: string(name='OrderType'),
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  statusList?: [ string ](name='StatusList'),
}

model ListFlowInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  total?: int32(name='Total'),
  flowInstances?: {
    flowInstance?: [ 
    {
      status?: string(name='Status'),
      owner?: string(name='Owner'),
      projectId?: string(name='ProjectId'),
      flowName?: string(name='FlowName'),
      gmtModified?: long(name='GmtModified'),
      flowId?: string(name='FlowId'),
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
      hasNodeFailed?: boolean(name='HasNodeFailed'),
      gmtCreate?: long(name='GmtCreate'),
      scheduleTime?: long(name='ScheduleTime'),
      duration?: long(name='Duration'),
      id?: string(name='Id'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='FlowInstance')
  }(name='FlowInstances'),
}

model ListFlowInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowInstanceResponseBody(name='body'),
}

async function listFlowInstanceWithOptions(request: ListFlowInstanceRequest, runtime: Util.RuntimeOptions): ListFlowInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlowInstance', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlowInstance(request: ListFlowInstanceRequest): ListFlowInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowInstanceWithOptions(request, runtime);
}

model DescribeScalingMetricsRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostGroupId?: string(name='HostGroupId'),
}

model DescribeScalingMetricsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  metricList?: [ 
    {
      metricName?: string(name='MetricName'),
      unit?: string(name='Unit'),
      displayName?: string(name='DisplayName'),
      minValue?: long(name='MinValue'),
      maxValue?: long(name='MaxValue'),
    }
  ](name='MetricList'),
}

model DescribeScalingMetricsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingMetricsResponseBody(name='body'),
}

async function describeScalingMetricsWithOptions(request: DescribeScalingMetricsRequest, runtime: Util.RuntimeOptions): DescribeScalingMetricsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeScalingMetrics', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeScalingMetrics(request: DescribeScalingMetricsRequest): DescribeScalingMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingMetricsWithOptions(request, runtime);
}

model UntagResourcesSystemTagsRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType', description='资源类型：cluster'),
  tagOwnerUid?: long(name='TagOwnerUid'),
  resourceIds?: [ string ](name='ResourceIds', description='资源ID'),
  tagKeys?: [ string ](name='TagKeys'),
  all?: boolean(name='All'),
}

model UntagResourcesSystemTagsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success', description='请求是否成功被处理'),
  code?: string(name='Code', description='响应码'),
  errorCode?: string(name='ErrorCode', description='错误码'),
  message?: string(name='Message', description='响应消息'),
}

model UntagResourcesSystemTagsResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesSystemTagsResponseBody(name='body'),
}

async function untagResourcesSystemTagsWithOptions(request: UntagResourcesSystemTagsRequest, runtime: Util.RuntimeOptions): UntagResourcesSystemTagsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UntagResourcesSystemTags', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function untagResourcesSystemTags(request: UntagResourcesSystemTagsRequest): UntagResourcesSystemTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesSystemTagsWithOptions(request, runtime);
}

model DescribeFlowProjectRequest {
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowProjectResponseBody = {
  requestId?: string(name='RequestId'),
  description?: string(name='Description'),
  userId?: string(name='UserId'),
  gmtCreate?: long(name='GmtCreate'),
  gmtModified?: long(name='GmtModified'),
  name?: string(name='Name'),
  id?: string(name='Id'),
}

model DescribeFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowProjectResponseBody(name='body'),
}

async function describeFlowProjectWithOptions(request: DescribeFlowProjectRequest, runtime: Util.RuntimeOptions): DescribeFlowProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeFlowProject', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeFlowProject(request: DescribeFlowProjectRequest): DescribeFlowProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowProjectWithOptions(request, runtime);
}

model DeleteSecurityWhiteListRequest {
  clusterId?: string(name='ClusterId'),
  portRange?: string(name='PortRange'),
  whiteIp?: string(name='WhiteIp'),
}

model DeleteSecurityWhiteListResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteSecurityWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSecurityWhiteListResponseBody(name='body'),
}

async function deleteSecurityWhiteListWithOptions(request: DeleteSecurityWhiteListRequest, runtime: Util.RuntimeOptions): DeleteSecurityWhiteListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSecurityWhiteList', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSecurityWhiteList(request: DeleteSecurityWhiteListRequest): DeleteSecurityWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecurityWhiteListWithOptions(request, runtime);
}

model ListScalingActivityRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  limit?: int32(name='Limit'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  currentSize?: int32(name='CurrentSize'),
  pageCount?: int32(name='PageCount'),
  orderField?: string(name='OrderField'),
  orderMode?: string(name='OrderMode'),
  clusterBizId?: string(name='ClusterBizId'),
  hostGroupId?: string(name='HostGroupId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  scalingRuleName?: string(name='ScalingRuleName'),
  hostGroupName?: string(name='HostGroupName'),
  status?: string(name='Status'),
}

model ListScalingActivityResponseBody = {
  requestId?: string(name='RequestId', description='requestId'),
  pageNumber?: long(name='PageNumber', description='pageNumber'),
  pageSize?: long(name='PageSize', description='pageSize'),
  totalCount?: long(name='TotalCount', description='totalCount'),
  nextToken?: long(name='NextToken', description='nextToken'),
  items?: {
    item?: [ 
    {
      bizId?: string(name='BizId', description='bizId'),
      startTime?: long(name='StartTime', description='startTime'),
      endTime?: long(name='EndTime', description='endTime'),
      expectNum?: long(name='ExpectNum'),
      instanceIds?: string(name='InstanceIds', description='instanceIds'),
      totalCapacity?: long(name='TotalCapacity', description='totalCapacity'),
      cause?: string(name='Cause', description='cause'),
      description?: string(name='Description', description='description'),
      transition?: string(name='Transition', description='transition'),
      status?: string(name='Status', description='status'),
      scalingRuleId?: string(name='ScalingRuleId', description='scalingRuleId'),
      scalingRuleName?: string(name='ScalingRuleName', description='scalingRuleName'),
      hostGroupBizId?: string(name='HostGroupBizId', description='hostGroupBizId'),
      hostGroupName?: string(name='HostGroupName', description='hostGroupName'),
    }
  ](name='Item')
  }(name='Items'),
}

model ListScalingActivityResponse = {
  headers: map[string]string(name='headers'),
  body: ListScalingActivityResponseBody(name='body'),
}

async function listScalingActivityWithOptions(request: ListScalingActivityRequest, runtime: Util.RuntimeOptions): ListScalingActivityResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListScalingActivity', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listScalingActivity(request: ListScalingActivityRequest): ListScalingActivityResponse {
  var runtime = new Util.RuntimeOptions{};
  return listScalingActivityWithOptions(request, runtime);
}

model ListTagValuesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceType?: string(name='ResourceType', description='资源组类型'),
  scope?: string(name='Scope'),
  nextToken?: string(name='NextToken'),
  pageSize?: long(name='PageSize'),
  key?: string(name='Key'),
}

model ListTagValuesResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success', description='是否成功响应'),
  paging?: boolean(name='Paging', description='是否分页'),
  data?: [ 
    {
      pageNumber?: long(name='PageNumber'),
      pageSize?: long(name='PageSize'),
      totalCount?: long(name='TotalCount'),
      nextToken?: string(name='NextToken'),
      items?: [ string ](name='Items', description='标签键集合'),
    }
  ](name='Data', description='标签值集合'),
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
}

model ListTagValuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagValuesResponseBody(name='body'),
}

async function listTagValuesWithOptions(request: ListTagValuesRequest, runtime: Util.RuntimeOptions): ListTagValuesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListTagValues', '2020-06-17', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listTagValues(request: ListTagValuesRequest): ListTagValuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagValuesWithOptions(request, runtime);
}

model ListClusterInstalledServiceRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterInstalledServiceResponseBody = {
  requestId?: string(name='RequestId'),
  clusterInstalledServiceList?: {
    clusterInstalledService?: [ 
    {
      serviceEcmVersion?: string(name='ServiceEcmVersion'),
      serviceDisplayName?: string(name='ServiceDisplayName'),
      onlyClient?: boolean(name='OnlyClient'),
      comment?: string(name='Comment'),
      notStartedNum?: int32(name='NotStartedNum'),
      needRestartNum?: int32(name='NeedRestartNum'),
      serviceVersion?: string(name='ServiceVersion'),
      serviceStatus?: string(name='ServiceStatus'),
      serviceName?: string(name='ServiceName'),
      abnormalNum?: int32(name='AbnormalNum'),
      serviceActionList?: {
        serviceAction?: [ 
        {
          displayName?: string(name='DisplayName'),
          actionName?: string(name='ActionName'),
          componentName?: string(name='ComponentName'),
          serviceName?: string(name='ServiceName'),
          command?: string(name='Command'),
        }
      ](name='ServiceAction')
      }(name='ServiceActionList'),
    }
  ](name='ClusterInstalledService')
  }(name='ClusterInstalledServiceList'),
}

model ListClusterInstalledServiceResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterInstalledServiceResponseBody(name='body'),
}

async function listClusterInstalledServiceWithOptions(request: ListClusterInstalledServiceRequest, runtime: Util.RuntimeOptions): ListClusterInstalledServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListClusterInstalledService', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusterInstalledService(request: ListClusterInstalledServiceRequest): ListClusterInstalledServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterInstalledServiceWithOptions(request, runtime);
}

model RunClusterServiceActionRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostIdList?: string(name='HostIdList'),
  serviceName?: string(name='ServiceName'),
  serviceActionName?: string(name='ServiceActionName'),
  customCommand?: string(name='CustomCommand'),
  componentNameList?: string(name='ComponentNameList'),
  comment?: string(name='Comment'),
  isRolling?: boolean(name='IsRolling'),
  executeStrategy?: string(name='ExecuteStrategy'),
  customParams?: string(name='CustomParams'),
  interval?: long(name='Interval'),
  nodeCountPerBatch?: int32(name='NodeCountPerBatch'),
  tolerateFailCount?: int32(name='TolerateFailCount'),
  onlyRestartStaleConfigNodes?: boolean(name='OnlyRestartStaleConfigNodes'),
  turnOnMaintenanceMode?: boolean(name='TurnOnMaintenanceMode'),
  hostGroupIdList?: [ string ](name='HostGroupIdList'),
}

model RunClusterServiceActionResponseBody = {
  requestId?: string(name='RequestId'),
}

model RunClusterServiceActionResponse = {
  headers: map[string]string(name='headers'),
  body: RunClusterServiceActionResponseBody(name='body'),
}

async function runClusterServiceActionWithOptions(request: RunClusterServiceActionRequest, runtime: Util.RuntimeOptions): RunClusterServiceActionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RunClusterServiceAction', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function runClusterServiceAction(request: RunClusterServiceActionRequest): RunClusterServiceActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return runClusterServiceActionWithOptions(request, runtime);
}

model SuspendFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  flowInstanceId?: string(name='FlowInstanceId'),
}

model SuspendFlowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model SuspendFlowResponse = {
  headers: map[string]string(name='headers'),
  body: SuspendFlowResponseBody(name='body'),
}

async function suspendFlowWithOptions(request: SuspendFlowRequest, runtime: Util.RuntimeOptions): SuspendFlowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SuspendFlow', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function suspendFlow(request: SuspendFlowRequest): SuspendFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return suspendFlowWithOptions(request, runtime);
}

model CreateFlowProjectRequest {
  productType?: string(name='ProductType'),
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  resourceGroupId?: string(name='ResourceGroupId'),
  clientToken?: string(name='ClientToken'),
}

model CreateFlowProjectResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowProjectResponseBody(name='body'),
}

async function createFlowProjectWithOptions(request: CreateFlowProjectRequest, runtime: Util.RuntimeOptions): CreateFlowProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateFlowProject', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createFlowProject(request: CreateFlowProjectRequest): CreateFlowProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowProjectWithOptions(request, runtime);
}

model ListFlowNodeInstanceContainerStatusRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  nodeInstanceId?: string(name='NodeInstanceId'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model ListFlowNodeInstanceContainerStatusResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  total?: int32(name='Total'),
  containerStatusList?: {
    containerStatus?: [ 
    {
      status?: string(name='Status'),
      hostName?: string(name='HostName'),
      containerId?: string(name='ContainerId'),
      applicationId?: string(name='ApplicationId'),
    }
  ](name='ContainerStatus')
  }(name='ContainerStatusList'),
}

model ListFlowNodeInstanceContainerStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowNodeInstanceContainerStatusResponseBody(name='body'),
}

async function listFlowNodeInstanceContainerStatusWithOptions(request: ListFlowNodeInstanceContainerStatusRequest, runtime: Util.RuntimeOptions): ListFlowNodeInstanceContainerStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlowNodeInstanceContainerStatus', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlowNodeInstanceContainerStatus(request: ListFlowNodeInstanceContainerStatusRequest): ListFlowNodeInstanceContainerStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowNodeInstanceContainerStatusWithOptions(request, runtime);
}

model ModifyClusterTemplateRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  bizId?: string(name='BizId'),
  templateName?: string(name='TemplateName'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  logPath?: string(name='LogPath'),
  securityGroupId?: string(name='SecurityGroupId'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
  securityGroupName?: string(name='SecurityGroupName'),
  chargeType?: string(name='ChargeType'),
  period?: int32(name='Period'),
  renewAuto?: boolean(name='RenewAuto'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  netType?: string(name='NetType'),
  userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
  emrVer?: string(name='EmrVer'),
  clusterType?: string(name='ClusterType'),
  enableHighAvailability?: boolean(name='EnableHighAvailability'),
  useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
  ioOptimizedOption?: boolean(name='IoOptimizedOption'),
  enableSsh?: boolean(name='EnableSsh'),
  instanceGeneration?: string(name='InstanceGeneration'),
  masterPwd?: string(name='MasterPwd'),
  keyPairName?: string(name='KeyPairName'),
  metaStoreType?: string(name='MetaStoreType'),
  metaStoreConf?: string(name='MetaStoreConf'),
  configurations?: string(name='Configurations'),
  enableEas?: boolean(name='EnableEas'),
  depositType?: string(name='DepositType'),
  machineType?: string(name='MachineType'),
  useCustomHiveMetaDb?: boolean(name='UseCustomHiveMetaDb'),
  initCustomHiveMetaDb?: boolean(name='InitCustomHiveMetaDb'),
  resourceGroupId?: string(name='ResourceGroupId'),
  optionSoftWareList?: [ string ](name='OptionSoftWareList'),
  hostGroup?: [ 
    {
      sysDiskCapacity?: int32(name='SysDiskCapacity'),
      hostGroupType?: string(name='HostGroupType'),
      comment?: string(name='Comment'),
      multiInstanceTypes?: string(name='MultiInstanceTypes'),
      sysDiskType?: string(name='SysDiskType'),
      chargeType?: string(name='ChargeType'),
      diskType?: string(name='DiskType'),
      hostGroupId?: string(name='HostGroupId'),
      instanceType?: string(name='InstanceType'),
      diskCount?: int32(name='DiskCount'),
      createType?: string(name='CreateType'),
      period?: int32(name='Period'),
      diskCapacity?: int32(name='DiskCapacity'),
      vSwitchId?: string(name='VSwitchId'),
      nodeCount?: int32(name='NodeCount'),
      hostGroupName?: string(name='HostGroupName'),
      renewAuto?: boolean(name='RenewAuto'),
      clusterId?: string(name='ClusterId'),
    }
  ](name='HostGroup'),
  bootstrapAction?: [ 
    {
      arg?: string(name='Arg'),
      path?: string(name='Path'),
      name?: string(name='Name'),
    }
  ](name='BootstrapAction'),
  config?: [ 
    {
      configValue?: string(name='ConfigValue'),
      replace?: string(name='Replace'),
      fileName?: string(name='FileName'),
      serviceName?: string(name='ServiceName'),
      configKey?: string(name='ConfigKey'),
      encrypt?: string(name='Encrypt'),
    }
  ](name='Config'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ModifyClusterTemplateResponseBody = {
  clusterTemplateId?: string(name='ClusterTemplateId'),
  requestId?: string(name='RequestId'),
}

model ModifyClusterTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterTemplateResponseBody(name='body'),
}

async function modifyClusterTemplateWithOptions(request: ModifyClusterTemplateRequest, runtime: Util.RuntimeOptions): ModifyClusterTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyClusterTemplate', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyClusterTemplate(request: ModifyClusterTemplateRequest): ModifyClusterTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterTemplateWithOptions(request, runtime);
}

model AddSecurityWhiteListRequest {
  clusterId?: string(name='ClusterId'),
  portRange?: string(name='PortRange'),
  whiteIpList?: [ string ](name='WhiteIpList'),
  description?: string(name='Description'),
}

model AddSecurityWhiteListResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddSecurityWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: AddSecurityWhiteListResponseBody(name='body'),
}

async function addSecurityWhiteListWithOptions(request: AddSecurityWhiteListRequest, runtime: Util.RuntimeOptions): AddSecurityWhiteListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddSecurityWhiteList', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addSecurityWhiteList(request: AddSecurityWhiteListRequest): AddSecurityWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSecurityWhiteListWithOptions(request, runtime);
}

model ListMetaClusterRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sourceType?: string(name='SourceType'),
}

model ListMetaClusterResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  totalCount?: int32(name='TotalCount'),
  items?: {
    item?: [ 
    {
      name?: string(name='Name'),
      id?: string(name='Id'),
      softwareInfo?: {
        clusterType?: string(name='ClusterType'),
        emrVer?: string(name='EmrVer'),
      }(name='SoftwareInfo'),
    }
  ](name='Item')
  }(name='Items'),
}

model ListMetaClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ListMetaClusterResponseBody(name='body'),
}

async function listMetaClusterWithOptions(request: ListMetaClusterRequest, runtime: Util.RuntimeOptions): ListMetaClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListMetaCluster', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listMetaCluster(request: ListMetaClusterRequest): ListMetaClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMetaClusterWithOptions(request, runtime);
}

model ListClusterOperationHostRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  operationId?: string(name='OperationId'),
  status?: string(name='Status'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterOperationHostResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  clusterOperationHostList?: {
    clusterOperationHost?: [ 
    {
      status?: string(name='Status'),
      hostName?: string(name='HostName'),
      percentage?: string(name='Percentage'),
      hostId?: string(name='HostId'),
    }
  ](name='ClusterOperationHost')
  }(name='ClusterOperationHostList'),
}

model ListClusterOperationHostResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterOperationHostResponseBody(name='body'),
}

async function listClusterOperationHostWithOptions(request: ListClusterOperationHostRequest, runtime: Util.RuntimeOptions): ListClusterOperationHostResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListClusterOperationHost', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusterOperationHost(request: ListClusterOperationHostRequest): ListClusterOperationHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterOperationHostWithOptions(request, runtime);
}

model ListClusterTemplatesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  bizId?: string(name='BizId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  productType?: string(name='ProductType'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListClusterTemplatesResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  templateInfoList?: {
    templateInfo?: [ 
    {
      vpcId?: string(name='VpcId'),
      keyPairName?: string(name='KeyPairName'),
      logEnable?: boolean(name='LogEnable'),
      sshEnable?: boolean(name='SshEnable'),
      highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
      securityGroupId?: string(name='SecurityGroupId'),
      userId?: string(name='UserId'),
      isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
      allowNotebook?: boolean(name='AllowNotebook'),
      gmtModified?: long(name='GmtModified'),
      templateName?: string(name='TemplateName'),
      depositType?: string(name='DepositType'),
      securityGroupName?: string(name='SecurityGroupName'),
      createSource?: string(name='CreateSource'),
      instanceGeneration?: string(name='InstanceGeneration'),
      useCustomHiveMetaDb?: boolean(name='UseCustomHiveMetaDb'),
      easEnable?: boolean(name='EasEnable'),
      userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
      metaStoreType?: string(name='MetaStoreType'),
      machineType?: string(name='MachineType'),
      useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
      masterNodeTotal?: int32(name='MasterNodeTotal'),
      initCustomHiveMetaDb?: boolean(name='InitCustomHiveMetaDb'),
      ioOptimized?: boolean(name='IoOptimized'),
      metaStoreConf?: string(name='MetaStoreConf'),
      vSwitchId?: string(name='VSwitchId'),
      configurations?: string(name='Configurations'),
      logPath?: string(name='LogPath'),
      clusterType?: string(name='ClusterType'),
      netType?: string(name='NetType'),
      zoneId?: string(name='ZoneId'),
      gmtCreate?: long(name='GmtCreate'),
      id?: string(name='Id'),
      bootstrapActionList?: {
        bootstrapAction?: [ 
        {
          path?: string(name='Path'),
          name?: string(name='Name'),
          arg?: string(name='Arg'),
        }
      ](name='BootstrapAction')
      }(name='BootstrapActionList'),
      hostGroupList?: {
        hostGroup?: [ 
        {
          sysDiskCapacity?: int32(name='SysDiskCapacity'),
          hostGroupType?: string(name='HostGroupType'),
          multiInstanceTypes?: string(name='MultiInstanceTypes'),
          sysDiskType?: string(name='SysDiskType'),
          chargeType?: string(name='ChargeType'),
          diskType?: string(name='DiskType'),
          hostGroupId?: string(name='HostGroupId'),
          instanceType?: string(name='InstanceType'),
          diskCount?: int32(name='DiskCount'),
          period?: string(name='Period'),
          diskCapacity?: int32(name='DiskCapacity'),
          nodeCount?: int32(name='NodeCount'),
          hostGroupName?: string(name='HostGroupName'),
        }
      ](name='HostGroup')
      }(name='HostGroupList'),
      configList?: {
        config?: [ 
        {
          configValue?: string(name='ConfigValue'),
          replace?: string(name='Replace'),
          fileName?: string(name='FileName'),
          serviceName?: string(name='ServiceName'),
          configKey?: string(name='ConfigKey'),
          encrypt?: string(name='Encrypt'),
        }
      ](name='Config')
      }(name='ConfigList'),
      softwareInfoList?: {
        softwareInfo?: [ string ](name='SoftwareInfo')
      }(name='SoftwareInfoList'),
    }
  ](name='TemplateInfo')
  }(name='TemplateInfoList'),
}

model ListClusterTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterTemplatesResponseBody(name='body'),
}

async function listClusterTemplatesWithOptions(request: ListClusterTemplatesRequest, runtime: Util.RuntimeOptions): ListClusterTemplatesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListClusterTemplates', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusterTemplates(request: ListClusterTemplatesRequest): ListClusterTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterTemplatesWithOptions(request, runtime);
}

model ListClustersRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  createType?: string(name='CreateType'),
  machineType?: string(name='MachineType'),
  isDesc?: boolean(name='IsDesc'),
  depositType?: string(name='DepositType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  defaultStatus?: boolean(name='DefaultStatus'),
  name?: string(name='Name'),
  resourceGroupId?: string(name='ResourceGroupId'),
  clusterTypeList?: [ string ](name='ClusterTypeList'),
  statusList?: [ string ](name='StatusList'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  expiredTagList?: [ string ](name='ExpiredTagList'),
}

model ListClustersResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  clusters?: {
    clusterInfo?: [ 
    {
      type?: string(name='Type'),
      status?: string(name='Status'),
      runningTime?: int32(name='RunningTime'),
      metaStoreType?: string(name='MetaStoreType'),
      machineType?: string(name='MachineType'),
      orderList?: string(name='OrderList'),
      createTime?: long(name='CreateTime'),
      chargeType?: string(name='ChargeType'),
      depositType?: string(name='DepositType'),
      period?: int32(name='Period'),
      k8sClusterId?: string(name='K8sClusterId'),
      expiredTime?: long(name='ExpiredTime'),
      hasUncompletedOrder?: boolean(name='HasUncompletedOrder'),
      name?: string(name='Name'),
      createResource?: string(name='CreateResource'),
      id?: string(name='Id'),
      tags?: {
        tag?: [ 
        {
          tagValue?: string(name='TagValue'),
          tagKey?: string(name='TagKey'),
        }
      ](name='Tag')
      }(name='Tags'),
      orderTaskInfo?: {
        targetCount?: int32(name='TargetCount'),
        currentCount?: int32(name='CurrentCount'),
        orderIdList?: string(name='OrderIdList'),
      }(name='OrderTaskInfo'),
      failReason?: {
        errorMsg?: string(name='ErrorMsg'),
        requestId?: string(name='RequestId'),
        errorCode?: string(name='ErrorCode'),
      }(name='FailReason'),
    }
  ](name='ClusterInfo')
  }(name='Clusters'),
}

model ListClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListClustersResponseBody(name='body'),
}

async function listClustersWithOptions(request: ListClustersRequest, runtime: Util.RuntimeOptions): ListClustersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListClusters', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusters(request: ListClustersRequest): ListClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersWithOptions(request, runtime);
}

model TagResourcesSystemTagsRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType', description='资源类型：cluster'),
  tagOwnerUid?: long(name='TagOwnerUid', description='主账号UID'),
  scope?: string(name='Scope'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags', description='资源标签'),
  resourceIds?: [ string ](name='ResourceIds', description='资源ID'),
}

model TagResourcesSystemTagsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success', description='请求是否成功被处理'),
  code?: string(name='Code', description='响应码'),
  errorCode?: string(name='ErrorCode', description='错误码'),
  message?: string(name='Message', description='响应消息'),
}

model TagResourcesSystemTagsResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesSystemTagsResponseBody(name='body'),
}

async function tagResourcesSystemTagsWithOptions(request: TagResourcesSystemTagsRequest, runtime: Util.RuntimeOptions): TagResourcesSystemTagsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TagResourcesSystemTags', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function tagResourcesSystemTags(request: TagResourcesSystemTagsRequest): TagResourcesSystemTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesSystemTagsWithOptions(request, runtime);
}

model ModifyFlowJobRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  failAct?: string(name='FailAct'),
  retryPolicy?: string(name='RetryPolicy'),
  params?: string(name='Params'),
  paramConf?: string(name='ParamConf'),
  customVariables?: string(name='CustomVariables'),
  envConf?: string(name='EnvConf'),
  runConf?: string(name='RunConf'),
  monitorConf?: string(name='MonitorConf'),
  mode?: string(name='Mode'),
  clusterId?: string(name='ClusterId'),
  alertConf?: string(name='AlertConf'),
  resourceList?: [ 
    {
      path?: string(name='Path'),
      alias?: string(name='Alias'),
    }
  ](name='ResourceList'),
}

model ModifyFlowJobResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowJobResponseBody(name='body'),
}

async function modifyFlowJobWithOptions(request: ModifyFlowJobRequest, runtime: Util.RuntimeOptions): ModifyFlowJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyFlowJob', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyFlowJob(request: ModifyFlowJobRequest): ModifyFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowJobWithOptions(request, runtime);
}

model DeleteFlowRequest {
  id?: string(name='Id'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model DeleteFlowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowResponseBody(name='body'),
}

async function deleteFlowWithOptions(request: DeleteFlowRequest, runtime: Util.RuntimeOptions): DeleteFlowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFlow', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFlow(request: DeleteFlowRequest): DeleteFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowWithOptions(request, runtime);
}

model CreateFlowEditLockRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  entityId?: string(name='EntityId'),
  force?: boolean(name='Force'),
}

model CreateFlowEditLockResponseBody = {
  status?: string(name='Status'),
  requestId?: string(name='RequestId'),
  entityId?: string(name='EntityId'),
  userId?: string(name='UserId'),
  bizId?: string(name='BizId'),
  ownerId?: string(name='OwnerId'),
}

model CreateFlowEditLockResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowEditLockResponseBody(name='body'),
}

async function createFlowEditLockWithOptions(request: CreateFlowEditLockRequest, runtime: Util.RuntimeOptions): CreateFlowEditLockResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateFlowEditLock', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createFlowEditLock(request: CreateFlowEditLockRequest): CreateFlowEditLockResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowEditLockWithOptions(request, runtime);
}

model DescribeFlowNodeInstanceRequest {
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowNodeInstanceResponseBody = {
  status?: string(name='Status'),
  type?: string(name='Type'),
  envConf?: string(name='EnvConf'),
  projectId?: string(name='ProjectId'),
  retryInterval?: string(name='RetryInterval'),
  jobType?: string(name='JobType'),
  mode?: string(name='Mode'),
  externalInfo?: string(name='ExternalInfo'),
  gmtModified?: long(name='GmtModified'),
  externalChildIds?: string(name='ExternalChildIds'),
  monitorConf?: string(name='MonitorConf'),
  externalStatus?: string(name='ExternalStatus'),
  requestId?: string(name='RequestId'),
  jobName?: string(name='JobName'),
  retryPolicy?: string(name='RetryPolicy'),
  adhoc?: boolean(name='Adhoc'),
  externalId?: string(name='ExternalId'),
  pending?: boolean(name='Pending'),
  clusterId?: string(name='ClusterId'),
  maxRetry?: string(name='MaxRetry'),
  failAct?: string(name='FailAct'),
  jobParams?: string(name='JobParams'),
  flowInstanceId?: string(name='FlowInstanceId'),
  paramConf?: string(name='ParamConf'),
  hostName?: string(name='HostName'),
  flowId?: string(name='FlowId'),
  retries?: int32(name='Retries'),
  endTime?: long(name='EndTime'),
  startTime?: long(name='StartTime'),
  runConf?: string(name='RunConf'),
  externalSubId?: string(name='ExternalSubId'),
  nodeName?: string(name='NodeName'),
  jobId?: string(name='JobId'),
  clusterName?: string(name='ClusterName'),
  gmtCreate?: long(name='GmtCreate'),
  duration?: long(name='Duration'),
  id?: string(name='Id'),
}

model DescribeFlowNodeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowNodeInstanceResponseBody(name='body'),
}

async function describeFlowNodeInstanceWithOptions(request: DescribeFlowNodeInstanceRequest, runtime: Util.RuntimeOptions): DescribeFlowNodeInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeFlowNodeInstance', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeFlowNodeInstance(request: DescribeFlowNodeInstanceRequest): DescribeFlowNodeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowNodeInstanceWithOptions(request, runtime);
}

model DetachAndReleaseClusterEniRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  targetClusterId?: string(name='TargetClusterId'),
  vswitchId?: string(name='VswitchId'),
}

model DetachAndReleaseClusterEniResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachAndReleaseClusterEniResponse = {
  headers: map[string]string(name='headers'),
  body: DetachAndReleaseClusterEniResponseBody(name='body'),
}

async function detachAndReleaseClusterEniWithOptions(request: DetachAndReleaseClusterEniRequest, runtime: Util.RuntimeOptions): DetachAndReleaseClusterEniResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DetachAndReleaseClusterEni', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function detachAndReleaseClusterEni(request: DetachAndReleaseClusterEniRequest): DetachAndReleaseClusterEniResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachAndReleaseClusterEniWithOptions(request, runtime);
}

model DescribeScalingGroupInstanceRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  hostGroupBizId?: string(name='HostGroupBizId'),
}

model DescribeScalingGroupInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  hostGroupId?: string(name='HostGroupId'),
  scalingGroupId?: string(name='ScalingGroupId'),
  minSize?: long(name='MinSize'),
  maxSize?: long(name='MaxSize'),
  defaultCooldown?: long(name='DefaultCooldown'),
  activeRuleCategory?: string(name='ActiveRuleCategory'),
  withGrace?: boolean(name='WithGrace'),
  timeoutWithGrace?: long(name='TimeoutWithGrace'),
  multiAvailablePolicy?: string(name='MultiAvailablePolicy'),
  multiAvailablePolicyParam?: string(name='MultiAvailablePolicyParam'),
  scalingConfig?: {
    spotStrategy?: string(name='SpotStrategy'),
    payType?: string(name='PayType'),
    dataDiskCategory?: string(name='DataDiskCategory'),
    dataDiskSize?: long(name='DataDiskSize'),
    dataDiskCount?: long(name='DataDiskCount'),
    sysDiskCategory?: string(name='SysDiskCategory'),
    sysDiskSize?: long(name='SysDiskSize'),
    instanceTypeList?: {
      instanceTypeList?: [ string ](name='instanceTypeList')
    }(name='InstanceTypeList'),
    spotPriceLimits?: {
      spotPriceLimits?: [ 
      {
        instanceType?: string(name='InstanceType'),
        priceLimit?: float(name='PriceLimit'),
      }
    ](name='spotPriceLimits')
    }(name='SpotPriceLimits'),
  }(name='ScalingConfig'),
  scalingRuleList?: {
    scalingRule?: [ 
    {
      ruleCategory?: string(name='RuleCategory'),
      essScalingRuleId?: string(name='EssScalingRuleId'),
      scalingGroupId?: long(name='ScalingGroupId'),
      ruleName?: string(name='RuleName'),
      adjustmentType?: string(name='AdjustmentType'),
      adjustmentValue?: long(name='AdjustmentValue'),
      cooldown?: long(name='Cooldown'),
      status?: string(name='Status'),
      launchTime?: string(name='LaunchTime'),
      launchExpirationTime?: long(name='LaunchExpirationTime'),
      recurrenceType?: string(name='RecurrenceType'),
      recurrenceValue?: string(name='RecurrenceValue'),
      recurrenceEndTime?: string(name='RecurrenceEndTime'),
      withGrace?: boolean(name='WithGrace'),
      timeoutWithGrace?: long(name='TimeoutWithGrace'),
      schedulerTrigger?: {
        launchTime?: long(name='LaunchTime'),
        launchExpirationTime?: long(name='LaunchExpirationTime'),
        recurrenceType?: string(name='RecurrenceType'),
        recurrenceValue?: string(name='RecurrenceValue'),
        recurrenceEndTime?: long(name='RecurrenceEndTime'),
      }(name='SchedulerTrigger'),
      cloudWatchTrigger?: {
        metricName?: string(name='MetricName'),
        period?: long(name='Period'),
        statistics?: string(name='Statistics'),
        comparisonOperator?: string(name='ComparisonOperator'),
        threshold?: string(name='Threshold'),
        evaluationCount?: string(name='EvaluationCount'),
        unit?: string(name='Unit'),
        metricDisplayName?: string(name='MetricDisplayName'),
      }(name='CloudWatchTrigger'),
    }
  ](name='ScalingRule')
  }(name='ScalingRuleList'),
}

model DescribeScalingGroupInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingGroupInstanceResponseBody(name='body'),
}

async function describeScalingGroupInstanceWithOptions(request: DescribeScalingGroupInstanceRequest, runtime: Util.RuntimeOptions): DescribeScalingGroupInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeScalingGroupInstance', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeScalingGroupInstance(request: DescribeScalingGroupInstanceRequest): DescribeScalingGroupInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingGroupInstanceWithOptions(request, runtime);
}

model CreateClusterHostGroupRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostGroupName?: string(name='HostGroupName'),
  hostGroupType?: string(name='HostGroupType'),
  comment?: string(name='Comment'),
  payType?: string(name='PayType'),
  vswitchId?: string(name='VswitchId'),
  securityGroupId?: string(name='SecurityGroupId'),
  hostGroupParams?: string(name='HostGroupParams'),
}

model CreateClusterHostGroupResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  clusterId?: string(name='ClusterId'),
  hostGroupId?: string(name='HostGroupId'),
}

model CreateClusterHostGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateClusterHostGroupResponseBody(name='body'),
}

async function createClusterHostGroupWithOptions(request: CreateClusterHostGroupRequest, runtime: Util.RuntimeOptions): CreateClusterHostGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateClusterHostGroup', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createClusterHostGroup(request: CreateClusterHostGroupRequest): CreateClusterHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterHostGroupWithOptions(request, runtime);
}

model DescribeClusterTemplateRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  bizId?: string(name='BizId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeClusterTemplateResponseBody = {
  requestId?: string(name='RequestId'),
  templateInfo?: {
    vpcId?: string(name='VpcId'),
    keyPairName?: string(name='KeyPairName'),
    logEnable?: boolean(name='LogEnable'),
    sshEnable?: boolean(name='SshEnable'),
    highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
    securityGroupId?: string(name='SecurityGroupId'),
    masterPwd?: string(name='MasterPwd'),
    userId?: string(name='UserId'),
    isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
    allowNotebook?: boolean(name='AllowNotebook'),
    gmtModified?: long(name='GmtModified'),
    templateName?: string(name='TemplateName'),
    depositType?: string(name='DepositType'),
    securityGroupName?: string(name='SecurityGroupName'),
    createSource?: string(name='CreateSource'),
    instanceGeneration?: string(name='InstanceGeneration'),
    useCustomHiveMetaDb?: boolean(name='UseCustomHiveMetaDb'),
    easEnable?: boolean(name='EasEnable'),
    userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
    metaStoreType?: string(name='MetaStoreType'),
    machineType?: string(name='MachineType'),
    useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
    masterNodeTotal?: int32(name='MasterNodeTotal'),
    initCustomHiveMetaDb?: boolean(name='InitCustomHiveMetaDb'),
    ioOptimized?: boolean(name='IoOptimized'),
    metaStoreConf?: string(name='MetaStoreConf'),
    vSwitchId?: string(name='VSwitchId'),
    configurations?: string(name='Configurations'),
    emrVer?: string(name='EmrVer'),
    logPath?: string(name='LogPath'),
    clusterType?: string(name='ClusterType'),
    netType?: string(name='NetType'),
    zoneId?: string(name='ZoneId'),
    gmtCreate?: long(name='GmtCreate'),
    id?: string(name='Id'),
    bootstrapActionList?: {
      bootstrapAction?: [ 
      {
        path?: string(name='Path'),
        name?: string(name='Name'),
        arg?: string(name='Arg'),
      }
    ](name='BootstrapAction')
    }(name='BootstrapActionList'),
    hostGroupList?: {
      hostGroup?: [ 
      {
        sysDiskCapacity?: int32(name='SysDiskCapacity'),
        hostGroupType?: string(name='HostGroupType'),
        multiInstanceTypes?: string(name='MultiInstanceTypes'),
        sysDiskType?: string(name='SysDiskType'),
        chargeType?: string(name='ChargeType'),
        diskType?: string(name='DiskType'),
        hostGroupId?: string(name='HostGroupId'),
        instanceType?: string(name='InstanceType'),
        diskCount?: int32(name='DiskCount'),
        period?: string(name='Period'),
        diskCapacity?: int32(name='DiskCapacity'),
        nodeCount?: int32(name='NodeCount'),
        hostGroupName?: string(name='HostGroupName'),
      }
    ](name='HostGroup')
    }(name='HostGroupList'),
    configList?: {
      config?: [ 
      {
        configValue?: string(name='ConfigValue'),
        replace?: string(name='Replace'),
        fileName?: string(name='FileName'),
        serviceName?: string(name='ServiceName'),
        configKey?: string(name='ConfigKey'),
        encrypt?: string(name='Encrypt'),
      }
    ](name='Config')
    }(name='ConfigList'),
    tags?: {
      tag?: [ 
      {
        tagValue?: string(name='TagValue'),
        tagKey?: string(name='TagKey'),
      }
    ](name='Tag')
    }(name='Tags'),
    softwareInfoList?: {
      softwareInfo?: [ string ](name='SoftwareInfo')
    }(name='SoftwareInfoList'),
  }(name='TemplateInfo'),
}

model DescribeClusterTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterTemplateResponseBody(name='body'),
}

async function describeClusterTemplateWithOptions(request: DescribeClusterTemplateRequest, runtime: Util.RuntimeOptions): DescribeClusterTemplateResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeClusterTemplate', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeClusterTemplate(request: DescribeClusterTemplateRequest): DescribeClusterTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterTemplateWithOptions(request, runtime);
}

model TagResourcesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceType?: string(name='ResourceType', description='资源类型'),
  resourceIds?: [ string ](name='ResourceIds', description='资源ID'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags', description='标签列表'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success', description='请求是否成功被处理'),
  code?: string(name='Code', description='响应码'),
  errorCode?: string(name='ErrorCode', description='错误码'),
  message?: string(name='Message', description='响应消息'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('TagResources', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model CommitFlowEntitySnapshotRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  entityType?: string(name='EntityType'),
  entityId?: string(name='EntityId'),
  message?: string(name='Message'),
}

model CommitFlowEntitySnapshotResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model CommitFlowEntitySnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: CommitFlowEntitySnapshotResponseBody(name='body'),
}

async function commitFlowEntitySnapshotWithOptions(request: CommitFlowEntitySnapshotRequest, runtime: Util.RuntimeOptions): CommitFlowEntitySnapshotResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CommitFlowEntitySnapshot', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function commitFlowEntitySnapshot(request: CommitFlowEntitySnapshotRequest): CommitFlowEntitySnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return commitFlowEntitySnapshotWithOptions(request, runtime);
}

model SubmitFlowJobRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  jobId?: string(name='JobId'),
  clusterId?: string(name='ClusterId'),
  hostName?: string(name='HostName'),
  conf?: string(name='Conf'),
}

model SubmitFlowJobResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model SubmitFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFlowJobResponseBody(name='body'),
}

async function submitFlowJobWithOptions(request: SubmitFlowJobRequest, runtime: Util.RuntimeOptions): SubmitFlowJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitFlowJob', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitFlowJob(request: SubmitFlowJobRequest): SubmitFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFlowJobWithOptions(request, runtime);
}

model ListFlowJobHistoryRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  jobType?: string(name='JobType'),
  instanceId?: string(name='InstanceId'),
  timeRange?: string(name='TimeRange'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  statusList?: [ string ](name='StatusList'),
}

model ListFlowJobHistoryResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  total?: int32(name='Total'),
  nodeInstances?: {
    nodeInstance?: [ 
    {
      type?: string(name='Type'),
      status?: string(name='Status'),
      pending?: boolean(name='pending'),
      envConf?: string(name='EnvConf'),
      retryInterval?: long(name='RetryInterval'),
      projectId?: string(name='ProjectId'),
      jobType?: string(name='JobType'),
      gmtModified?: long(name='GmtModified'),
      externalInfo?: string(name='ExternalInfo'),
      externalStatus?: string(name='ExternalStatus'),
      jobName?: string(name='JobName'),
      externalId?: string(name='ExternalId'),
      maxRetry?: int32(name='MaxRetry'),
      clusterId?: string(name='ClusterId'),
      failAct?: string(name='FailAct'),
      jobParams?: string(name='JobParams'),
      paramConf?: string(name='ParamConf'),
      hostName?: string(name='HostName'),
      retries?: int32(name='Retries'),
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
      runConf?: string(name='RunConf'),
      nodeName?: string(name='NodeName'),
      jobId?: string(name='JobId'),
      gmtCreate?: long(name='GmtCreate'),
      id?: string(name='Id'),
    }
  ](name='NodeInstance')
  }(name='NodeInstances'),
}

model ListFlowJobHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowJobHistoryResponseBody(name='body'),
}

async function listFlowJobHistoryWithOptions(request: ListFlowJobHistoryRequest, runtime: Util.RuntimeOptions): ListFlowJobHistoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlowJobHistory', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlowJobHistory(request: ListFlowJobHistoryRequest): ListFlowJobHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowJobHistoryWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceType?: string(name='ResourceType'),
  resourceIds?: [ string ](name='ResourceIds', description='资源组ID'),
  tags?: [ 
    {
      key?: string(name='Key', description='标签键'),
      value?: string(name='Value', description='标签值'),
    }
  ](name='Tags', description='标签'),
  nextToken?: string(name='NextToken'),
}

model ListTagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success', description='请求是否成功被处理'),
  code?: string(name='Code', description='响应码'),
  errorCode?: string(name='ErrorCode', description='错误码'),
  message?: string(name='Message', description='响应消息'),
  data?: [ 
    {
      tagKey?: string(name='TagKey', description='标签键'),
      tagValue?: string(name='TagValue', description='标签值'),
      resourceType?: string(name='ResourceType', description='资源类型'),
      resourceId?: string(name='ResourceId', description='资源ID'),
    }
  ](name='Data'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListTagResources', '2020-06-17', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListClusterHostComponentRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostInstanceId?: string(name='HostInstanceId'),
  hostName?: string(name='HostName'),
  serviceName?: string(name='ServiceName'),
  componentName?: string(name='ComponentName'),
  componentStatus?: string(name='ComponentStatus'),
  hostRole?: string(name='HostRole'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterHostComponentResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  total?: int32(name='Total'),
  componentList?: {
    component?: [ 
    {
      serialNumber?: string(name='SerialNumber'),
      status?: string(name='Status'),
      serviceDisplayName?: string(name='ServiceDisplayName'),
      privateIp?: string(name='PrivateIp'),
      serverStatus?: string(name='ServerStatus'),
      componentName?: string(name='ComponentName'),
      commissionStatus?: string(name='CommissionStatus'),
      hostName?: string(name='HostName'),
      instanceType?: string(name='InstanceType'),
      needRestart?: boolean(name='NeedRestart'),
      hostId?: string(name='HostId'),
      hostInstanceId?: string(name='HostInstanceId'),
      cpu?: int32(name='Cpu'),
      componentDisplayName?: string(name='ComponentDisplayName'),
      publicIp?: string(name='PublicIp'),
      memory?: int32(name='Memory'),
      role?: string(name='Role'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='Component')
  }(name='ComponentList'),
}

model ListClusterHostComponentResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterHostComponentResponseBody(name='body'),
}

async function listClusterHostComponentWithOptions(request: ListClusterHostComponentRequest, runtime: Util.RuntimeOptions): ListClusterHostComponentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListClusterHostComponent', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusterHostComponent(request: ListClusterHostComponentRequest): ListClusterHostComponentResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterHostComponentWithOptions(request, runtime);
}

model ModifyScalingGroupRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
}

model ModifyScalingGroupResponseBody = {
  requestId?: string(name='RequestId', description='requestId'),
  data?: boolean(name='Data', description='data'),
}

model ModifyScalingGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyScalingGroupResponseBody(name='body'),
}

async function modifyScalingGroupWithOptions(request: ModifyScalingGroupRequest, runtime: Util.RuntimeOptions): ModifyScalingGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyScalingGroup', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyScalingGroup(request: ModifyScalingGroupRequest): ModifyScalingGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyScalingGroupWithOptions(request, runtime);
}

model DescribeFlowProjectClusterSettingRequest {
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
}

model DescribeFlowProjectClusterSettingResponseBody = {
  requestId?: string(name='RequestId'),
  k8sClusterId?: string(name='K8sClusterId'),
  defaultQueue?: string(name='DefaultQueue'),
  projectId?: string(name='ProjectId'),
  gmtCreate?: long(name='GmtCreate'),
  defaultUser?: string(name='DefaultUser'),
  gmtModified?: long(name='GmtModified'),
  clusterId?: string(name='ClusterId'),
  queueList?: {
    queue?: [ string ](name='Queue')
  }(name='QueueList'),
  userList?: {
    user?: [ string ](name='User')
  }(name='UserList'),
  hostList?: {
    host?: [ string ](name='Host')
  }(name='HostList'),
}

model DescribeFlowProjectClusterSettingResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowProjectClusterSettingResponseBody(name='body'),
}

async function describeFlowProjectClusterSettingWithOptions(request: DescribeFlowProjectClusterSettingRequest, runtime: Util.RuntimeOptions): DescribeFlowProjectClusterSettingResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeFlowProjectClusterSetting', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeFlowProjectClusterSetting(request: DescribeFlowProjectClusterSettingRequest): DescribeFlowProjectClusterSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowProjectClusterSettingWithOptions(request, runtime);
}

model ListFlowProjectClusterSettingRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListFlowProjectClusterSettingResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  total?: int32(name='Total'),
  clusterSettings?: {
    clusterSetting?: [ 
    {
      k8sClusterId?: string(name='K8sClusterId'),
      defaultQueue?: string(name='DefaultQueue'),
      projectId?: string(name='ProjectId'),
      gmtCreate?: long(name='GmtCreate'),
      clusterName?: string(name='ClusterName'),
      defaultUser?: string(name='DefaultUser'),
      gmtModified?: long(name='GmtModified'),
      clusterId?: string(name='ClusterId'),
      queueList?: {
        queue?: [ string ](name='Queue')
      }(name='QueueList'),
      userList?: {
        user?: [ string ](name='User')
      }(name='UserList'),
      hostList?: {
        host?: [ string ](name='Host')
      }(name='HostList'),
    }
  ](name='ClusterSetting')
  }(name='ClusterSettings'),
}

model ListFlowProjectClusterSettingResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowProjectClusterSettingResponseBody(name='body'),
}

async function listFlowProjectClusterSettingWithOptions(request: ListFlowProjectClusterSettingRequest, runtime: Util.RuntimeOptions): ListFlowProjectClusterSettingResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlowProjectClusterSetting', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlowProjectClusterSetting(request: ListFlowProjectClusterSettingRequest): ListFlowProjectClusterSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowProjectClusterSettingWithOptions(request, runtime);
}

model SubmitFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  flowId?: string(name='FlowId'),
  conf?: string(name='Conf'),
}

model SubmitFlowResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
  instanceId?: string(name='InstanceId'),
  id?: string(name='Id'),
}

model SubmitFlowResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitFlowResponseBody(name='body'),
}

async function submitFlowWithOptions(request: SubmitFlowRequest, runtime: Util.RuntimeOptions): SubmitFlowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SubmitFlow', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function submitFlow(request: SubmitFlowRequest): SubmitFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitFlowWithOptions(request, runtime);
}

model DescribeScalingCommonConfigRequest {
  resourceOwnerId?: long(name='ResourceOwnerId', description='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeScalingCommonConfigResponseBody = {
  requestId?: string(name='requestId', description='requestId'),
  autoScalingHookHeartbeatDefaultTime?: long(name='AutoScalingHookHeartbeatDefaultTime', description='autoScalingHookHeartbeatDefaultTime'),
  autoScalingCoolDownTime?: long(name='AutoScalingCoolDownTime'),
  autoScalingMNSScalingThreadSleepTime?: long(name='AutoScalingMNSScalingThreadSleepTime'),
  autoScalingGroupMinSizeLimit?: long(name='AutoScalingGroupMinSizeLimit'),
  autoScalingGroupMaxSizeLimit?: long(name='AutoScalingGroupMaxSizeLimit'),
  autoScalingRuleMinDelayLimit?: long(name='AutoScalingRuleMinDelayLimit'),
  autoScalingRuleAlarmDelayLimit?: long(name='AutoScalingRuleAlarmDelayLimit'),
  autoScalingRuleAlarmSilentTime?: long(name='AutoScalingRuleAlarmSilentTime'),
  autoScalingConfigSystemDiskSize?: long(name='AutoScalingConfigSystemDiskSize'),
  autoScalingConfigDecommissionQueryInterval?: long(name='AutoScalingConfigDecommissionQueryInterval'),
}

model DescribeScalingCommonConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingCommonConfigResponseBody(name='body'),
}

async function describeScalingCommonConfigWithOptions(request: DescribeScalingCommonConfigRequest, runtime: Util.RuntimeOptions): DescribeScalingCommonConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeScalingCommonConfig', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeScalingCommonConfig(request: DescribeScalingCommonConfigRequest): DescribeScalingCommonConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingCommonConfigWithOptions(request, runtime);
}

model ResumeFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  flowInstanceId?: string(name='FlowInstanceId'),
}

model ResumeFlowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ResumeFlowResponse = {
  headers: map[string]string(name='headers'),
  body: ResumeFlowResponseBody(name='body'),
}

async function resumeFlowWithOptions(request: ResumeFlowRequest, runtime: Util.RuntimeOptions): ResumeFlowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ResumeFlow', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function resumeFlow(request: ResumeFlowRequest): ResumeFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return resumeFlowWithOptions(request, runtime);
}

model RestoreFlowEntitySnapshotRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  operatorId?: string(name='OperatorId'),
  entityType?: string(name='EntityType'),
  entityId?: string(name='EntityId'),
  revision?: string(name='Revision'),
}

model RestoreFlowEntitySnapshotResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model RestoreFlowEntitySnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: RestoreFlowEntitySnapshotResponseBody(name='body'),
}

async function restoreFlowEntitySnapshotWithOptions(request: RestoreFlowEntitySnapshotRequest, runtime: Util.RuntimeOptions): RestoreFlowEntitySnapshotResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RestoreFlowEntitySnapshot', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function restoreFlowEntitySnapshot(request: RestoreFlowEntitySnapshotRequest): RestoreFlowEntitySnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return restoreFlowEntitySnapshotWithOptions(request, runtime);
}

model CreateLibraryRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clientToken?: string(name='ClientToken'),
  type?: string(name='Type'),
  name?: string(name='Name'),
  libraryVersion?: string(name='LibraryVersion'),
  sourceType?: string(name='SourceType'),
  sourceLocation?: string(name='SourceLocation'),
  scope?: string(name='Scope'),
  properties?: string(name='Properties'),
}

model CreateLibraryResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateLibraryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLibraryResponseBody(name='body'),
}

async function createLibraryWithOptions(request: CreateLibraryRequest, runtime: Util.RuntimeOptions): CreateLibraryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateLibrary', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createLibrary(request: CreateLibraryRequest): CreateLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLibraryWithOptions(request, runtime);
}

model ListVswitchRequest {
  regionId?: string(name='RegionId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
  depositType?: string(name='DepositType'),
  productType?: string(name='ProductType'),
}

model ListVswitchResponseBody = {
  requestId?: string(name='RequestId'),
  vswitchList?: {
    vswitch?: [ 
    {
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      isDefault?: boolean(name='IsDefault'),
      vSwitchId?: string(name='VSwitchId'),
      cidrBlock?: string(name='CidrBlock'),
      description?: string(name='Description'),
      availableIpAddressCount?: string(name='AvailableIpAddressCount'),
      resourceGroupId?: string(name='ResourceGroupId'),
      zoneId?: string(name='ZoneId'),
      vSwitchName?: string(name='VSwitchName'),
    }
  ](name='Vswitch')
  }(name='VswitchList'),
}

model ListVswitchResponse = {
  headers: map[string]string(name='headers'),
  body: ListVswitchResponseBody(name='body'),
}

async function listVswitchWithOptions(request: ListVswitchRequest, runtime: Util.RuntimeOptions): ListVswitchResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVswitch', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVswitch(request: ListVswitchRequest): ListVswitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVswitchWithOptions(request, runtime);
}

model DeleteFlowProjectRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
}

model DeleteFlowProjectResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowProjectResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowProjectResponseBody(name='body'),
}

async function deleteFlowProjectWithOptions(request: DeleteFlowProjectRequest, runtime: Util.RuntimeOptions): DeleteFlowProjectResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFlowProject', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFlowProject(request: DeleteFlowProjectRequest): DeleteFlowProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowProjectWithOptions(request, runtime);
}

model ReleaseClusterRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
  forceRelease?: boolean(name='ForceRelease'),
}

model ReleaseClusterResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseClusterResponseBody(name='body'),
}

async function releaseClusterWithOptions(request: ReleaseClusterRequest, runtime: Util.RuntimeOptions): ReleaseClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ReleaseCluster', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function releaseCluster(request: ReleaseClusterRequest): ReleaseClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseClusterWithOptions(request, runtime);
}

model AddScalingConfigItemRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  configItemType?: string(name='ConfigItemType'),
  configItemInformation?: string(name='ConfigItemInformation'),
}

model AddScalingConfigItemResponseBody = {
  requestId?: string(name='RequestId', description='requestId'),
  data?: string(name='Data', description='data'),
}

model AddScalingConfigItemResponse = {
  headers: map[string]string(name='headers'),
  body: AddScalingConfigItemResponseBody(name='body'),
}

async function addScalingConfigItemWithOptions(request: AddScalingConfigItemRequest, runtime: Util.RuntimeOptions): AddScalingConfigItemResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddScalingConfigItem', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addScalingConfigItem(request: AddScalingConfigItemRequest): AddScalingConfigItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return addScalingConfigItemWithOptions(request, runtime);
}

model ResetUserPasswordRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  type?: string(name='Type'),
  oldPassword?: string(name='OldPassword'),
  password?: string(name='Password'),
  userName?: string(name='UserName'),
}

model ResetUserPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetUserPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: ResetUserPasswordResponseBody(name='body'),
}

async function resetUserPasswordWithOptions(request: ResetUserPasswordRequest, runtime: Util.RuntimeOptions): ResetUserPasswordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ResetUserPassword', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function resetUserPassword(request: ResetUserPasswordRequest): ResetUserPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetUserPasswordWithOptions(request, runtime);
}

model ListFlowClusterAllHostsRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  clusterId?: string(name='ClusterId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListFlowClusterAllHostsResponseBody = {
  requestId?: string(name='RequestId'),
  hostList?: {
    host?: [ 
    {
      status?: string(name='Status'),
      type?: string(name='Type'),
      serialNumber?: string(name='SerialNumber'),
      privateIp?: string(name='PrivateIp'),
      hostName?: string(name='HostName'),
      instanceType?: string(name='InstanceType'),
      hostId?: string(name='HostId'),
      hostInstanceId?: string(name='HostInstanceId'),
      cpu?: int32(name='Cpu'),
      publicIp?: string(name='PublicIp'),
      memory?: int32(name='Memory'),
      role?: string(name='Role'),
    }
  ](name='Host')
  }(name='HostList'),
}

model ListFlowClusterAllHostsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowClusterAllHostsResponseBody(name='body'),
}

async function listFlowClusterAllHostsWithOptions(request: ListFlowClusterAllHostsRequest, runtime: Util.RuntimeOptions): ListFlowClusterAllHostsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlowClusterAllHosts', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlowClusterAllHosts(request: ListFlowClusterAllHostsRequest): ListFlowClusterAllHostsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowClusterAllHostsWithOptions(request, runtime);
}

model DeleteLibrariesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  libraryBizIdList?: [ string ](name='LibraryBizIdList'),
}

model DeleteLibrariesResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteLibrariesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLibrariesResponseBody(name='body'),
}

async function deleteLibrariesWithOptions(request: DeleteLibrariesRequest, runtime: Util.RuntimeOptions): DeleteLibrariesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteLibraries', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteLibraries(request: DeleteLibrariesRequest): DeleteLibrariesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLibrariesWithOptions(request, runtime);
}

model DescribeFlowCategoryTreeRequest {
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
  type?: string(name='Type'),
  mode?: string(name='Mode'),
  keyword?: string(name='Keyword'),
  categoryId?: string(name='CategoryId'),
}

model DescribeFlowCategoryTreeResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeFlowCategoryTreeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowCategoryTreeResponseBody(name='body'),
}

async function describeFlowCategoryTreeWithOptions(request: DescribeFlowCategoryTreeRequest, runtime: Util.RuntimeOptions): DescribeFlowCategoryTreeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeFlowCategoryTree', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeFlowCategoryTree(request: DescribeFlowCategoryTreeRequest): DescribeFlowCategoryTreeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowCategoryTreeWithOptions(request, runtime);
}

model ListDatasourceInstancesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  targetClusterId?: string(name='TargetClusterId'),
  datasourceType?: string(name='DatasourceType'),
}

model ListDatasourceInstancesResponseBody = {
  ddiDatasourceInfoList?: {
    ddiDatasourceInfo?: [ 
    {
      clusterId?: string(name='ClusterId'),
      createTime?: long(name='CreateTime'),
      datasourceId?: string(name='DatasourceId'),
      descreption?: string(name='Descreption'),
      modifyTime?: long(name='ModifyTime'),
      name?: string(name='Name'),
      status?: string(name='Status'),
      type?: string(name='Type'),
      vswitchId?: string(name='VswitchId'),
      privateAddressList?: {
        privateAddressList?: [ string ](name='privateAddressList')
      }(name='PrivateAddressList'),
      securityGroupId?: string(name='SecurityGroupId'),
    }
  ](name='DdiDatasourceInfo')
  }(name='DdiDatasourceInfoList'),
  requestId?: string(name='RequestId'),
}

model ListDatasourceInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDatasourceInstancesResponseBody(name='body'),
}

async function listDatasourceInstancesWithOptions(request: ListDatasourceInstancesRequest, runtime: Util.RuntimeOptions): ListDatasourceInstancesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListDatasourceInstances', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listDatasourceInstances(request: ListDatasourceInstancesRequest): ListDatasourceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDatasourceInstancesWithOptions(request, runtime);
}

model ListFlowNodeSqlResultRequest {
  nodeInstanceId?: string(name='NodeInstanceId'),
  sqlIndex?: int32(name='SqlIndex'),
  offset?: int32(name='Offset'),
  length?: int32(name='Length'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model ListFlowNodeSqlResultResponseBody = {
  end?: boolean(name='End'),
  requestId?: string(name='RequestId'),
  headerList?: {
    header?: [ string ](name='Header')
  }(name='HeaderList'),
  rowList?: {
    row?: [ 
    {
      rowIndex?: int32(name='RowIndex'),
      rowItemList?: {
        rowItem?: [ string ](name='RowItem')
      }(name='RowItemList'),
    }
  ](name='Row')
  }(name='RowList'),
}

model ListFlowNodeSqlResultResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowNodeSqlResultResponseBody(name='body'),
}

async function listFlowNodeSqlResultWithOptions(request: ListFlowNodeSqlResultRequest, runtime: Util.RuntimeOptions): ListFlowNodeSqlResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlowNodeSqlResult', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlowNodeSqlResult(request: ListFlowNodeSqlResultRequest): ListFlowNodeSqlResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowNodeSqlResultWithOptions(request, runtime);
}

model DescribeFlowJobRequest {
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowJobResponseBody = {
  type?: string(name='Type'),
  lastInstanceId?: string(name='LastInstanceId'),
  envConf?: string(name='EnvConf'),
  retryInterval?: long(name='RetryInterval'),
  mode?: string(name='Mode'),
  gmtModified?: long(name='GmtModified'),
  monitorConf?: string(name='MonitorConf'),
  params?: string(name='Params'),
  requestId?: string(name='RequestId'),
  description?: string(name='Description'),
  retryPolicy?: string(name='RetryPolicy'),
  adhoc?: string(name='Adhoc'),
  name?: string(name='Name'),
  maxRetry?: int32(name='MaxRetry'),
  maxRunningTimeSec?: long(name='MaxRunningTimeSec'),
  failAct?: string(name='FailAct'),
  customVariables?: string(name='CustomVariables'),
  editLockDetail?: string(name='EditLockDetail'),
  paramConf?: string(name='ParamConf'),
  runConf?: string(name='RunConf'),
  gmtCreate?: long(name='GmtCreate'),
  categoryId?: string(name='CategoryId'),
  id?: string(name='Id'),
  alertConf?: string(name='AlertConf'),
  resourceList?: {
    resource?: [ 
    {
      path?: string(name='Path'),
      alias?: string(name='Alias'),
    }
  ](name='Resource')
  }(name='ResourceList'),
}

model DescribeFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowJobResponseBody(name='body'),
}

async function describeFlowJobWithOptions(request: DescribeFlowJobRequest, runtime: Util.RuntimeOptions): DescribeFlowJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeFlowJob', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeFlowJob(request: DescribeFlowJobRequest): DescribeFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowJobWithOptions(request, runtime);
}

model DescribeLibraryInstallTaskDetailRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  taskBizId?: string(name='TaskBizId'),
}

model DescribeLibraryInstallTaskDetailResponseBody = {
  libraryBizId?: string(name='LibraryBizId'),
  hostname?: string(name='Hostname'),
  endTime?: long(name='EndTime'),
  startTime?: long(name='StartTime'),
  taskType?: string(name='TaskType'),
  requestId?: string(name='RequestId'),
  taskGroupId?: string(name='TaskGroupId'),
  taskStatus?: string(name='TaskStatus'),
  taskProcess?: int32(name='TaskProcess'),
  executeTime?: long(name='ExecuteTime'),
  clusterBizId?: string(name='ClusterBizId'),
  taskId?: string(name='TaskId'),
  detail?: string(name='Detail'),
}

model DescribeLibraryInstallTaskDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLibraryInstallTaskDetailResponseBody(name='body'),
}

async function describeLibraryInstallTaskDetailWithOptions(request: DescribeLibraryInstallTaskDetailRequest, runtime: Util.RuntimeOptions): DescribeLibraryInstallTaskDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeLibraryInstallTaskDetail', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeLibraryInstallTaskDetail(request: DescribeLibraryInstallTaskDetailRequest): DescribeLibraryInstallTaskDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLibraryInstallTaskDetailWithOptions(request, runtime);
}

model ModifyFlowForWebRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  status?: string(name='Status'),
  description?: string(name='Description'),
  periodic?: boolean(name='Periodic'),
  startSchedule?: long(name='StartSchedule'),
  endSchedule?: long(name='EndSchedule'),
  cronExpr?: string(name='CronExpr'),
  createCluster?: boolean(name='CreateCluster'),
  clusterId?: string(name='ClusterId'),
  hostName?: string(name='HostName'),
  namespace?: string(name='Namespace'),
  graph?: string(name='Graph'),
  alertConf?: string(name='AlertConf'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
  parentFlowList?: string(name='ParentFlowList'),
  parentCategory?: string(name='ParentCategory'),
}

model ModifyFlowForWebResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyFlowForWebResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowForWebResponseBody(name='body'),
}

async function modifyFlowForWebWithOptions(request: ModifyFlowForWebRequest, runtime: Util.RuntimeOptions): ModifyFlowForWebResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyFlowForWeb', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyFlowForWeb(request: ModifyFlowForWebRequest): ModifyFlowForWebResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowForWebWithOptions(request, runtime);
}

model RemoveScalingConfigItemRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  configItemType?: string(name='ConfigItemType'),
  configItemBizId?: string(name='ConfigItemBizId'),
}

model RemoveScalingConfigItemResponseBody = {
  requestId?: string(name='RequestId', description='requestId'),
  data?: boolean(name='Data', description='data'),
}

model RemoveScalingConfigItemResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveScalingConfigItemResponseBody(name='body'),
}

async function removeScalingConfigItemWithOptions(request: RemoveScalingConfigItemRequest, runtime: Util.RuntimeOptions): RemoveScalingConfigItemResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveScalingConfigItem', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeScalingConfigItem(request: RemoveScalingConfigItemRequest): RemoveScalingConfigItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeScalingConfigItemWithOptions(request, runtime);
}

model DescribeSecurityWhiteListRequest {
  clusterId?: string(name='ClusterId'),
}

model DescribeSecurityWhiteListResponseBody = {
  describeSecurityWhiteList?: [ 
    {
      portRange?: string(name='PortRange'),
      whiteIp?: string(name='WhiteIp'),
      description?: string(name='Description'),
      createTime?: string(name='CreateTime'),
    }
  ](name='DescribeSecurityWhiteList'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DescribeSecurityWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityWhiteListResponseBody(name='body'),
}

async function describeSecurityWhiteListWithOptions(request: DescribeSecurityWhiteListRequest, runtime: Util.RuntimeOptions): DescribeSecurityWhiteListResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeSecurityWhiteList', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeSecurityWhiteList(request: DescribeSecurityWhiteListRequest): DescribeSecurityWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityWhiteListWithOptions(request, runtime);
}

model DescribeFlowNodeInstanceContainerLogRequest {
  offset?: int32(name='Offset'),
  length?: int32(name='Length'),
  nodeInstanceId?: string(name='NodeInstanceId'),
  appId?: string(name='AppId'),
  containerId?: string(name='ContainerId'),
  logName?: string(name='LogName'),
  projectId?: string(name='ProjectId'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowNodeInstanceContainerLogResponseBody = {
  logEnd?: boolean(name='LogEnd'),
  requestId?: string(name='RequestId'),
  logEntrys?: {
    logEntry?: [ 
    {
      content?: string(name='Content'),
    }
  ](name='LogEntry')
  }(name='LogEntrys'),
}

model DescribeFlowNodeInstanceContainerLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowNodeInstanceContainerLogResponseBody(name='body'),
}

async function describeFlowNodeInstanceContainerLogWithOptions(request: DescribeFlowNodeInstanceContainerLogRequest, runtime: Util.RuntimeOptions): DescribeFlowNodeInstanceContainerLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeFlowNodeInstanceContainerLog', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeFlowNodeInstanceContainerLog(request: DescribeFlowNodeInstanceContainerLogRequest): DescribeFlowNodeInstanceContainerLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowNodeInstanceContainerLogWithOptions(request, runtime);
}

model RerunFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  flowInstanceId?: string(name='FlowInstanceId'),
  reRunFail?: boolean(name='ReRunFail'),
}

model RerunFlowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model RerunFlowResponse = {
  headers: map[string]string(name='headers'),
  body: RerunFlowResponseBody(name='body'),
}

async function rerunFlowWithOptions(request: RerunFlowRequest, runtime: Util.RuntimeOptions): RerunFlowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RerunFlow', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function rerunFlow(request: RerunFlowRequest): RerunFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return rerunFlowWithOptions(request, runtime);
}

model ListTagKeysRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceType?: string(name='ResourceType', description='资源类型'),
  category?: string(name='Category'),
  scope?: string(name='Scope'),
  nextToken?: string(name='NextToken'),
  pageSize?: long(name='PageSize'),
}

model ListTagKeysResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success', description='是否成功响应'),
  paging?: boolean(name='Paging', description='是否分页'),
  data?: [ 
    {
      pageNumber?: long(name='PageNumber'),
      pageSize?: long(name='PageSize'),
      totalCount?: long(name='TotalCount'),
      nextToken?: string(name='NextToken'),
      items?: [ string ](name='Items', description='标签键集合'),
    }
  ](name='Data', description='标签键集合'),
  code?: string(name='Code'),
  errorCode?: string(name='ErrorCode'),
  message?: string(name='Message'),
}

model ListTagKeysResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagKeysResponseBody(name='body'),
}

async function listTagKeysWithOptions(request: ListTagKeysRequest, runtime: Util.RuntimeOptions): ListTagKeysResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTagKeys', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTagKeys(request: ListTagKeysRequest): ListTagKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagKeysWithOptions(request, runtime);
}

model DescribeClusterOperationHostTaskLogRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  operationId?: string(name='OperationId'),
  hostId?: string(name='HostId'),
  taskId?: string(name='TaskId'),
  status?: string(name='Status'),
}

model DescribeClusterOperationHostTaskLogResponseBody = {
  requestId?: string(name='RequestId'),
  stdout?: string(name='Stdout'),
  stderr?: string(name='Stderr'),
}

model DescribeClusterOperationHostTaskLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterOperationHostTaskLogResponseBody(name='body'),
}

async function describeClusterOperationHostTaskLogWithOptions(request: DescribeClusterOperationHostTaskLogRequest, runtime: Util.RuntimeOptions): DescribeClusterOperationHostTaskLogResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeClusterOperationHostTaskLog', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeClusterOperationHostTaskLog(request: DescribeClusterOperationHostTaskLogRequest): DescribeClusterOperationHostTaskLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterOperationHostTaskLogWithOptions(request, runtime);
}

model KillFlowJobRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  jobInstanceId?: string(name='JobInstanceId'),
}

model KillFlowJobResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model KillFlowJobResponse = {
  headers: map[string]string(name='headers'),
  body: KillFlowJobResponseBody(name='body'),
}

async function killFlowJobWithOptions(request: KillFlowJobRequest, runtime: Util.RuntimeOptions): KillFlowJobResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('KillFlowJob', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function killFlowJob(request: KillFlowJobRequest): KillFlowJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return killFlowJobWithOptions(request, runtime);
}

model UninstallLibrariesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterBizIdList?: [ string ](name='ClusterBizIdList'),
  libraryBizId?: string(name='LibraryBizId'),
}

model UninstallLibrariesResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model UninstallLibrariesResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallLibrariesResponseBody(name='body'),
}

async function uninstallLibrariesWithOptions(request: UninstallLibrariesRequest, runtime: Util.RuntimeOptions): UninstallLibrariesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UninstallLibraries', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function uninstallLibraries(request: UninstallLibrariesRequest): UninstallLibrariesResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallLibrariesWithOptions(request, runtime);
}

model DescribeClusterV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
}

model DescribeClusterV2ResponseBody = {
  requestId?: string(name='RequestId'),
  clusterInfo?: {
    vpcId?: string(name='VpcId'),
    logEnable?: boolean(name='LogEnable'),
    taskNodeInService?: int32(name='TaskNodeInService'),
    autoScalingSpotWithLimitAllowed?: boolean(name='AutoScalingSpotWithLimitAllowed'),
    userId?: string(name='UserId'),
    chargeType?: string(name='ChargeType'),
    stopTime?: long(name='StopTime'),
    depositType?: string(name='DepositType'),
    createType?: string(name='CreateType'),
    relateClusterId?: string(name='RelateClusterId'),
    securityGroupName?: string(name='SecurityGroupName'),
    resizeDiskEnable?: boolean(name='ResizeDiskEnable'),
    imageId?: string(name='ImageId'),
    userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
    metaStoreType?: string(name='MetaStoreType'),
    startTime?: long(name='StartTime'),
    configurations?: string(name='Configurations'),
    logPath?: string(name='LogPath'),
    autoScalingVersion?: string(name='AutoScalingVersion'),
    netType?: string(name='NetType'),
    zoneId?: string(name='ZoneId'),
    createResource?: string(name='CreateResource'),
    status?: string(name='Status'),
    runningTime?: int32(name='RunningTime'),
    highAvailabilityEnable?: boolean(name='HighAvailabilityEnable'),
    securityGroupId?: string(name='SecurityGroupId'),
    autoScalingAllowed?: boolean(name='AutoScalingAllowed'),
    masterNodeInService?: int32(name='MasterNodeInService'),
    autoScalingEnable?: boolean(name='AutoScalingEnable'),
    autoScalingWithGraceAllowed?: boolean(name='AutoScalingWithGraceAllowed'),
    coreNodeInService?: int32(name='CoreNodeInService'),
    showSoftwareInterface?: boolean(name='ShowSoftwareInterface'),
    k8sClusterId?: string(name='K8sClusterId'),
    autoScalingByLoadAllowed?: boolean(name='AutoScalingByLoadAllowed'),
    localMetaDb?: boolean(name='LocalMetaDb'),
    instanceGeneration?: string(name='InstanceGeneration'),
    name?: string(name='Name'),
    easEnable?: boolean(name='EasEnable'),
    machineType?: string(name='MachineType'),
    masterNodeTotal?: int32(name='MasterNodeTotal'),
    regionId?: string(name='RegionId'),
    period?: int32(name='Period'),
    extraInfo?: string(name='ExtraInfo'),
    ioOptimized?: boolean(name='IoOptimized'),
    vSwitchId?: string(name='VSwitchId'),
    expiredTime?: long(name='ExpiredTime'),
    coreNodeTotal?: int32(name='CoreNodeTotal'),
    gatewayClusterIds?: string(name='GatewayClusterIds'),
    bootstrapFailed?: boolean(name='BootstrapFailed'),
    id?: string(name='Id'),
    taskNodeTotal?: int32(name='TaskNodeTotal'),
    gatewayClusterInfoList?: {
      gatewayClusterInfo?: [ 
      {
        clusterName?: string(name='ClusterName'),
        status?: string(name='Status'),
        clusterId?: string(name='ClusterId'),
      }
    ](name='GatewayClusterInfo')
    }(name='GatewayClusterInfoList'),
    hostGroupList?: {
      hostGroup?: [ 
      {
        lockType?: string(name='LockType'),
        hostGroupSubType?: string(name='HostGroupSubType'),
        hostGroupType?: string(name='HostGroupType'),
        hostGroupChangeStatus?: string(name='HostGroupChangeStatus'),
        chargeType?: string(name='ChargeType'),
        lockReason?: string(name='LockReason'),
        diskType?: string(name='DiskType'),
        hostGroupId?: string(name='HostGroupId'),
        bandWidth?: string(name='BandWidth'),
        instanceType?: string(name='InstanceType'),
        diskCount?: int32(name='DiskCount'),
        period?: string(name='Period'),
        diskCapacity?: int32(name='DiskCapacity'),
        cpuCore?: int32(name='CpuCore'),
        memoryCapacity?: int32(name='MemoryCapacity'),
        nodeCount?: int32(name='NodeCount'),
        hostGroupChangeType?: string(name='HostGroupChangeType'),
        hostGroupName?: string(name='HostGroupName'),
        nodes?: {
          node?: [ 
          {
            status?: string(name='Status'),
            supportIpV6?: boolean(name='SupportIpV6'),
            innerIp?: string(name='InnerIp'),
            expiredTime?: string(name='ExpiredTime'),
            createTime?: string(name='CreateTime'),
            zoneId?: string(name='ZoneId'),
            instanceId?: string(name='InstanceId'),
            emrExpiredTime?: string(name='EmrExpiredTime'),
            pubIp?: string(name='PubIp'),
            daemonInfos?: {
              daemonInfo?: [ 
              {
                name?: string(name='Name'),
              }
            ](name='DaemonInfo')
            }(name='DaemonInfos'),
            diskInfos?: {
              diskInfo?: [ 
              {
                type?: string(name='Type'),
                diskId?: string(name='DiskId'),
                size?: int32(name='Size'),
                device?: string(name='Device'),
                diskName?: string(name='DiskName'),
              }
            ](name='DiskInfo')
            }(name='DiskInfos'),
          }
        ](name='Node')
        }(name='Nodes'),
      }
    ](name='HostGroup')
    }(name='HostGroupList'),
    bootstrapActionList?: {
      bootstrapAction?: [ 
      {
        path?: string(name='Path'),
        name?: string(name='Name'),
        arg?: string(name='Arg'),
      }
    ](name='BootstrapAction')
    }(name='BootstrapActionList'),
    relateClusterInfo?: {
      clusterName?: string(name='ClusterName'),
      status?: string(name='Status'),
      clusterId?: string(name='ClusterId'),
    }(name='RelateClusterInfo'),
    hostPoolInfo?: {
      hpName?: string(name='HpName'),
      hpBizId?: string(name='HpBizId'),
    }(name='HostPoolInfo'),
    failReason?: {
      errorMsg?: string(name='ErrorMsg'),
      requestId?: string(name='RequestId'),
      errorCode?: string(name='ErrorCode'),
    }(name='FailReason'),
    softwareInfo?: {
      clusterType?: string(name='ClusterType'),
      emrVer?: string(name='EmrVer'),
      softwares?: {
        software?: [ 
        {
          displayName?: string(name='DisplayName'),
          onlyDisplay?: boolean(name='OnlyDisplay'),
          startTpe?: int32(name='StartTpe'),
          name?: string(name='Name'),
          version?: string(name='Version'),
        }
      ](name='Software')
      }(name='Softwares'),
    }(name='SoftwareInfo'),
    accessInfo?: {
      ZKLinks?: {
        ZKLink?: [ 
        {
          port?: string(name='Port'),
          link?: string(name='Link'),
        }
      ](name='ZKLink')
      }(name='ZKLinks'),
    }(name='AccessInfo'),
  }(name='ClusterInfo'),
}

model DescribeClusterV2Response = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterV2ResponseBody(name='body'),
}

async function describeClusterV2WithOptions(request: DescribeClusterV2Request, runtime: Util.RuntimeOptions): DescribeClusterV2Response {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeClusterV2', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeClusterV2(request: DescribeClusterV2Request): DescribeClusterV2Response {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterV2WithOptions(request, runtime);
}

model DescribeFlowRequest {
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowResponseBody = {
  status?: string(name='Status'),
  type?: string(name='Type'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
  periodic?: boolean(name='Periodic'),
  editLockDetail?: string(name='EditLockDetail'),
  namespace?: string(name='Namespace'),
  hostName?: string(name='HostName'),
  application?: string(name='Application'),
  gmtModified?: long(name='GmtModified'),
  requestId?: string(name='RequestId'),
  description?: string(name='Description'),
  createCluster?: boolean(name='CreateCluster'),
  startSchedule?: long(name='StartSchedule'),
  endSchedule?: long(name='EndSchedule'),
  graph?: string(name='Graph'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
  gmtCreate?: long(name='GmtCreate'),
  categoryId?: string(name='CategoryId'),
  cronExpr?: string(name='CronExpr'),
  name?: string(name='Name'),
  id?: string(name='Id'),
  alertConf?: string(name='AlertConf'),
  clusterId?: string(name='ClusterId'),
  parentFlowList?: {
    parentFlow?: [ 
    {
      parentFlowName?: string(name='ParentFlowName'),
      parentFlowId?: string(name='ParentFlowId'),
      projectName?: string(name='ProjectName'),
      projectId?: string(name='ProjectId'),
    }
  ](name='ParentFlow')
  }(name='ParentFlowList'),
}

model DescribeFlowResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowResponseBody(name='body'),
}

async function describeFlowWithOptions(request: DescribeFlowRequest, runtime: Util.RuntimeOptions): DescribeFlowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeFlow', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeFlow(request: DescribeFlowRequest): DescribeFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowWithOptions(request, runtime);
}

model ListFlowClusterRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListFlowClusterResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  clusters?: {
    clusterInfo?: [ 
    {
      type?: string(name='Type'),
      status?: string(name='Status'),
      runningTime?: int32(name='RunningTime'),
      orderList?: string(name='OrderList'),
      createTime?: long(name='CreateTime'),
      chargeType?: string(name='ChargeType'),
      period?: int32(name='Period'),
      k8sClusterId?: string(name='K8sClusterId'),
      expiredTime?: long(name='ExpiredTime'),
      hasUncompletedOrder?: boolean(name='HasUncompletedOrder'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      createResource?: string(name='CreateResource'),
      orderTaskInfo?: {
        targetCount?: int32(name='TargetCount'),
        currentCount?: int32(name='CurrentCount'),
        orderIdList?: string(name='OrderIdList'),
      }(name='OrderTaskInfo'),
      failReason?: {
        errorMsg?: string(name='ErrorMsg'),
        requestId?: string(name='RequestId'),
        errorCode?: string(name='ErrorCode'),
      }(name='FailReason'),
    }
  ](name='ClusterInfo')
  }(name='Clusters'),
}

model ListFlowClusterResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowClusterResponseBody(name='body'),
}

async function listFlowClusterWithOptions(request: ListFlowClusterRequest, runtime: Util.RuntimeOptions): ListFlowClusterResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlowCluster', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlowCluster(request: ListFlowClusterRequest): ListFlowClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowClusterWithOptions(request, runtime);
}

model ListLdapUsersRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  userNameSearch?: string(name='UserNameSearch'),
}

model ListLdapUsersResponseBody = {
  isAdmin?: boolean(name='IsAdmin'),
  requestId?: string(name='RequestId'),
  userList?: {
    user?: [ 
    {
      userCreateTime?: long(name='UserCreateTime'),
      groupName?: string(name='GroupName'),
      userId?: string(name='UserId'),
      note?: string(name='Note'),
      keytabHex?: string(name='KeytabHex'),
      userName?: string(name='UserName'),
    }
  ](name='User')
  }(name='UserList'),
}

model ListLdapUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListLdapUsersResponseBody(name='body'),
}

async function listLdapUsersWithOptions(request: ListLdapUsersRequest, runtime: Util.RuntimeOptions): ListLdapUsersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListLdapUsers', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listLdapUsers(request: ListLdapUsersRequest): ListLdapUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLdapUsersWithOptions(request, runtime);
}

model DeleteUserRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  userId?: string(name='UserId'),
  type?: string(name='Type'),
}

model DeleteUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteUser', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model CreateFlowProjectClusterSettingRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  clusterId?: string(name='ClusterId'),
  defaultUser?: string(name='DefaultUser'),
  defaultQueue?: string(name='DefaultQueue'),
  clientToken?: string(name='ClientToken'),
  userList?: [ string ](name='UserList'),
  queueList?: [ string ](name='QueueList'),
  hostList?: [ string ](name='HostList'),
}

model CreateFlowProjectClusterSettingResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateFlowProjectClusterSettingResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowProjectClusterSettingResponseBody(name='body'),
}

async function createFlowProjectClusterSettingWithOptions(request: CreateFlowProjectClusterSettingRequest, runtime: Util.RuntimeOptions): CreateFlowProjectClusterSettingResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateFlowProjectClusterSetting', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createFlowProjectClusterSetting(request: CreateFlowProjectClusterSettingRequest): CreateFlowProjectClusterSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowProjectClusterSettingWithOptions(request, runtime);
}

model DescribeFlowInstanceRequest {
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  regionId?: string(name='RegionId'),
}

model DescribeFlowInstanceResponseBody = {
  status?: string(name='Status'),
  projectId?: string(name='ProjectId'),
  namespace?: string(name='Namespace'),
  flowName?: string(name='FlowName'),
  gmtModified?: long(name='GmtModified'),
  flowId?: string(name='FlowId'),
  cronExpression?: string(name='CronExpression'),
  endTime?: long(name='EndTime'),
  startTime?: long(name='StartTime'),
  hasNodeFailed?: boolean(name='HasNodeFailed'),
  requestId?: string(name='RequestId'),
  graph?: string(name='Graph'),
  gmtCreate?: long(name='GmtCreate'),
  scheduleTime?: long(name='ScheduleTime'),
  duration?: long(name='Duration'),
  id?: string(name='Id'),
  clusterId?: string(name='ClusterId'),
  dependencyFlowList?: {
    parentFlow?: [ 
    {
      scheduleKey?: string(name='ScheduleKey'),
      bizDate?: long(name='BizDate'),
      dependencyInstanceId?: string(name='DependencyInstanceId'),
      dependencyFlowId?: string(name='DependencyFlowId'),
      meet?: boolean(name='Meet'),
      flowInstanceId?: string(name='FlowInstanceId'),
      projectId?: string(name='ProjectId'),
      flowId?: string(name='FlowId'),
    }
  ](name='ParentFlow')
  }(name='DependencyFlowList'),
  nodeInstance?: {
    nodeInstance?: [ 
    {
      status?: string(name='Status'),
      type?: string(name='Type'),
      failAct?: string(name='FailAct'),
      projectId?: string(name='ProjectId'),
      retryInterval?: string(name='RetryInterval'),
      jobType?: string(name='JobType'),
      hostName?: string(name='HostName'),
      externalInfo?: string(name='ExternalInfo'),
      gmtModified?: long(name='GmtModified'),
      retries?: int32(name='Retries'),
      endTime?: long(name='EndTime'),
      startTime?: long(name='StartTime'),
      externalStatus?: string(name='ExternalStatus'),
      jobName?: string(name='JobName'),
      nodeName?: string(name='NodeName'),
      jobId?: string(name='JobId'),
      gmtCreate?: long(name='GmtCreate'),
      externalId?: string(name='ExternalId'),
      duration?: long(name='Duration'),
      id?: string(name='Id'),
      pending?: boolean(name='Pending'),
      clusterId?: string(name='ClusterId'),
      maxRetry?: string(name='MaxRetry'),
    }
  ](name='NodeInstance')
  }(name='NodeInstance'),
}

model DescribeFlowInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFlowInstanceResponseBody(name='body'),
}

async function describeFlowInstanceWithOptions(request: DescribeFlowInstanceRequest, runtime: Util.RuntimeOptions): DescribeFlowInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeFlowInstance', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeFlowInstance(request: DescribeFlowInstanceRequest): DescribeFlowInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFlowInstanceWithOptions(request, runtime);
}

model CreateFlowProjectUserRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  clientToken?: string(name='ClientToken'),
  user?: [ 
    {
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='User'),
}

model CreateFlowProjectUserResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateFlowProjectUserResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowProjectUserResponseBody(name='body'),
}

async function createFlowProjectUserWithOptions(request: CreateFlowProjectUserRequest, runtime: Util.RuntimeOptions): CreateFlowProjectUserResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateFlowProjectUser', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createFlowProjectUser(request: CreateFlowProjectUserRequest): CreateFlowProjectUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowProjectUserWithOptions(request, runtime);
}

model CreateFlowCategoryRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  name?: string(name='Name'),
  type?: string(name='Type'),
  parentId?: string(name='ParentId'),
  clientToken?: string(name='ClientToken'),
}

model CreateFlowCategoryResponseBody = {
  id?: string(name='Id'),
  requestId?: string(name='RequestId'),
}

model CreateFlowCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFlowCategoryResponseBody(name='body'),
}

async function createFlowCategoryWithOptions(request: CreateFlowCategoryRequest, runtime: Util.RuntimeOptions): CreateFlowCategoryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateFlowCategory', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createFlowCategory(request: CreateFlowCategoryRequest): CreateFlowCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFlowCategoryWithOptions(request, runtime);
}

model DeleteFlowProjectClusterSettingRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  clusterId?: string(name='ClusterId'),
}

model DeleteFlowProjectClusterSettingResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowProjectClusterSettingResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowProjectClusterSettingResponseBody(name='body'),
}

async function deleteFlowProjectClusterSettingWithOptions(request: DeleteFlowProjectClusterSettingRequest, runtime: Util.RuntimeOptions): DeleteFlowProjectClusterSettingResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFlowProjectClusterSetting', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFlowProjectClusterSetting(request: DeleteFlowProjectClusterSettingRequest): DeleteFlowProjectClusterSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowProjectClusterSettingWithOptions(request, runtime);
}

model ListLibrariesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  limit?: int32(name='Limit'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  currentSize?: int32(name='CurrentSize'),
  pageCount?: int32(name='PageCount'),
  orderField?: string(name='OrderField'),
  orderMode?: string(name='OrderMode'),
  clusterBizId?: string(name='ClusterBizId'),
}

model ListLibrariesResponseBody = {
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  items?: {
    item?: [ 
    {
      type?: string(name='Type'),
      createTime?: long(name='CreateTime'),
      userId?: string(name='UserId'),
      sourceType?: string(name='SourceType'),
      bizId?: string(name='BizId'),
      scope?: string(name='Scope'),
      libraryVersion?: string(name='LibraryVersion'),
      name?: string(name='Name'),
      properties?: string(name='Properties'),
      sourceLocation?: string(name='SourceLocation'),
    }
  ](name='Item')
  }(name='Items'),
}

model ListLibrariesResponse = {
  headers: map[string]string(name='headers'),
  body: ListLibrariesResponseBody(name='body'),
}

async function listLibrariesWithOptions(request: ListLibrariesRequest, runtime: Util.RuntimeOptions): ListLibrariesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListLibraries', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listLibraries(request: ListLibrariesRequest): ListLibrariesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLibrariesWithOptions(request, runtime);
}

model RunScalingActionRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  scalingActionType?: string(name='ScalingActionType'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  actionParam?: string(name='ActionParam'),
}

model RunScalingActionResponseBody = {
  requestId?: string(name='RequestId', description='requestId'),
  data?: string(name='Data', description='data'),
}

model RunScalingActionResponse = {
  headers: map[string]string(name='headers'),
  body: RunScalingActionResponseBody(name='body'),
}

async function runScalingActionWithOptions(request: RunScalingActionRequest, runtime: Util.RuntimeOptions): RunScalingActionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RunScalingAction', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function runScalingAction(request: RunScalingActionRequest): RunScalingActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return runScalingActionWithOptions(request, runtime);
}

model InstallLibrariesRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterBizIdList?: [ string ](name='ClusterBizIdList'),
  libraryBizId?: string(name='LibraryBizId'),
}

model InstallLibrariesResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model InstallLibrariesResponse = {
  headers: map[string]string(name='headers'),
  body: InstallLibrariesResponseBody(name='body'),
}

async function installLibrariesWithOptions(request: InstallLibrariesRequest, runtime: Util.RuntimeOptions): InstallLibrariesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('InstallLibraries', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function installLibraries(request: InstallLibrariesRequest): InstallLibrariesResponse {
  var runtime = new Util.RuntimeOptions{};
  return installLibrariesWithOptions(request, runtime);
}

model ListFlowJobsRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  type?: string(name='Type'),
  adhoc?: boolean(name='Adhoc'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListFlowJobsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
  jobList?: {
    job?: [ 
    {
      type?: string(name='Type'),
      failAct?: string(name='FailAct'),
      customVariables?: string(name='CustomVariables'),
      retryInterval?: long(name='RetryInterval'),
      envConf?: string(name='EnvConf'),
      paramConf?: string(name='ParamConf'),
      mode?: string(name='Mode'),
      gmtModified?: long(name='GmtModified'),
      monitorConf?: string(name='MonitorConf'),
      lastInstanceDetail?: string(name='LastInstanceDetail'),
      runConf?: string(name='RunConf'),
      params?: string(name='Params'),
      description?: string(name='Description'),
      gmtCreate?: long(name='GmtCreate'),
      categoryId?: string(name='CategoryId'),
      adhoc?: string(name='Adhoc'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      maxRetry?: int32(name='MaxRetry'),
      alertConf?: string(name='AlertConf'),
      resourceList?: {
        resource?: [ 
        {
          path?: string(name='Path'),
          alias?: string(name='Alias'),
        }
      ](name='Resource')
      }(name='ResourceList'),
    }
  ](name='Job')
  }(name='JobList'),
}

model ListFlowJobsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowJobsResponseBody(name='body'),
}

async function listFlowJobsWithOptions(request: ListFlowJobsRequest, runtime: Util.RuntimeOptions): ListFlowJobsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlowJobs', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlowJobs(request: ListFlowJobsRequest): ListFlowJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowJobsWithOptions(request, runtime);
}

model ModifyFlowRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  status?: string(name='Status'),
  description?: string(name='Description'),
  periodic?: boolean(name='Periodic'),
  startSchedule?: long(name='StartSchedule'),
  endSchedule?: long(name='EndSchedule'),
  cronExpr?: string(name='CronExpr'),
  createCluster?: boolean(name='CreateCluster'),
  clusterId?: string(name='ClusterId'),
  hostName?: string(name='HostName'),
  application?: string(name='Application'),
  alertConf?: string(name='AlertConf'),
  alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
  alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
  parentFlowList?: string(name='ParentFlowList'),
  parentCategory?: string(name='ParentCategory'),
}

model ModifyFlowResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyFlowResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowResponseBody(name='body'),
}

async function modifyFlowWithOptions(request: ModifyFlowRequest, runtime: Util.RuntimeOptions): ModifyFlowResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyFlow', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyFlow(request: ModifyFlowRequest): ModifyFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  regionId?: string(name='RegionId'),
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  businessLocations?: [ 
    {
      ordering?: string(name='Ordering'),
      type?: string(name='Type'),
      showName?: string(name='ShowName'),
      description?: string(name='Description'),
      enDescription?: string(name='EnDescription'),
      enName?: string(name='EnName'),
      cnName?: string(name='CnName'),
      name?: string(name='Name'),
      district?: {
        ordering?: string(name='Ordering'),
        cnName?: string(name='CnName'),
        showName?: string(name='ShowName'),
        districtId?: string(name='DistrictId'),
        enName?: string(name='EnName'),
      }(name='District'),
    }
  ](name='BusinessLocations'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeRegions', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model ListLibraryStatusRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  limit?: int32(name='Limit'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  currentSize?: int32(name='CurrentSize'),
  pageCount?: int32(name='PageCount'),
  orderField?: string(name='OrderField'),
  orderMode?: string(name='OrderMode'),
  libraryBizId?: string(name='LibraryBizId'),
  clusterBizId?: string(name='ClusterBizId'),
}

model ListLibraryStatusResponseBody = {
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  items?: {
    item?: [ 
    {
      status?: string(name='Status'),
      clusterName?: string(name='ClusterName'),
      clusterBizId?: string(name='ClusterBizId'),
      libraryBizId?: string(name='LibraryBizId'),
      libraryName?: string(name='LibraryName'),
    }
  ](name='Item')
  }(name='Items'),
}

model ListLibraryStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ListLibraryStatusResponseBody(name='body'),
}

async function listLibraryStatusWithOptions(request: ListLibraryStatusRequest, runtime: Util.RuntimeOptions): ListLibraryStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListLibraryStatus', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listLibraryStatus(request: ListLibraryStatusRequest): ListLibraryStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLibraryStatusWithOptions(request, runtime);
}

model DescribeClusterServiceConfigRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
  configVersion?: string(name='ConfigVersion'),
  groupId?: string(name='GroupId'),
  hostInstanceId?: string(name='HostInstanceId'),
  tagValue?: string(name='TagValue'),
}

model DescribeClusterServiceConfigResponseBody = {
  requestId?: string(name='RequestId'),
  config?: {
    applied?: string(name='Applied'),
    comment?: string(name='Comment'),
    createTime?: string(name='CreateTime'),
    configVersion?: string(name='ConfigVersion'),
    author?: string(name='Author'),
    serviceName?: string(name='ServiceName'),
    configValueList?: {
      configValue?: [ 
      {
        configName?: string(name='ConfigName'),
        scopeId?: long(name='ScopeId'),
        scope?: string(name='Scope'),
        allowCustom?: boolean(name='AllowCustom'),
        configItemValueList?: {
          configItemValue?: [ 
          {
            value?: string(name='Value'),
            description?: string(name='Description'),
            itemName?: string(name='ItemName'),
            isCustom?: boolean(name='IsCustom'),
          }
        ](name='ConfigItemValue')
        }(name='ConfigItemValueList'),
      }
    ](name='ConfigValue')
    }(name='ConfigValueList'),
    propertyInfoList?: {
      propertyInfo?: [ 
      {
        displayName?: string(name='DisplayName'),
        value?: string(name='Value'),
        description?: string(name='Description'),
        component?: string(name='Component'),
        fileName?: string(name='FileName'),
        name?: string(name='Name'),
        serviceName?: string(name='ServiceName'),
        propertyTypes?: {
          propertyType?: [ string ](name='PropertyType')
        }(name='PropertyTypes'),
        propertyValueAttributes?: {
          type?: string(name='Type'),
          maximum?: string(name='Maximum'),
          unit?: string(name='Unit'),
          hidden?: boolean(name='Hidden'),
          incrememtStep?: string(name='IncrememtStep'),
          readOnly?: boolean(name='ReadOnly'),
          mimimum?: string(name='Mimimum'),
          entries?: {
            valueEntryInfo?: [ 
            {
              value?: string(name='Value'),
              label?: string(name='Label'),
              description?: string(name='Description'),
            }
          ](name='ValueEntryInfo')
          }(name='Entries'),
        }(name='PropertyValueAttributes'),
        effectWay?: {
          effectType?: string(name='EffectType'),
          invokeServiceName?: string(name='InvokeServiceName'),
        }(name='EffectWay'),
      }
    ](name='PropertyInfo')
    }(name='PropertyInfoList'),
  }(name='Config'),
}

model DescribeClusterServiceConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterServiceConfigResponseBody(name='body'),
}

async function describeClusterServiceConfigWithOptions(request: DescribeClusterServiceConfigRequest, runtime: Util.RuntimeOptions): DescribeClusterServiceConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeClusterServiceConfig', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeClusterServiceConfig(request: DescribeClusterServiceConfigRequest): DescribeClusterServiceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterServiceConfigWithOptions(request, runtime);
}

model ModifyFlowProjectClusterSettingRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  clusterId?: string(name='ClusterId'),
  defaultUser?: string(name='DefaultUser'),
  defaultQueue?: string(name='DefaultQueue'),
  userList?: [ string ](name='UserList'),
  queueList?: [ string ](name='QueueList'),
  hostList?: [ string ](name='HostList'),
}

model ModifyFlowProjectClusterSettingResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyFlowProjectClusterSettingResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFlowProjectClusterSettingResponseBody(name='body'),
}

async function modifyFlowProjectClusterSettingWithOptions(request: ModifyFlowProjectClusterSettingRequest, runtime: Util.RuntimeOptions): ModifyFlowProjectClusterSettingResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyFlowProjectClusterSetting', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyFlowProjectClusterSetting(request: ModifyFlowProjectClusterSettingRequest): ModifyFlowProjectClusterSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyFlowProjectClusterSettingWithOptions(request, runtime);
}

model DeleteFlowProjectUserRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  userName?: string(name='UserName'),
}

model DeleteFlowProjectUserResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteFlowProjectUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFlowProjectUserResponseBody(name='body'),
}

async function deleteFlowProjectUserWithOptions(request: DeleteFlowProjectUserRequest, runtime: Util.RuntimeOptions): DeleteFlowProjectUserResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFlowProjectUser', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFlowProjectUser(request: DeleteFlowProjectUserRequest): DeleteFlowProjectUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFlowProjectUserWithOptions(request, runtime);
}

model CreateClusterV2Request {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  logPath?: string(name='LogPath'),
  securityGroupId?: string(name='SecurityGroupId'),
  isOpenPublicIp?: boolean(name='IsOpenPublicIp'),
  securityGroupName?: string(name='SecurityGroupName'),
  chargeType?: string(name='ChargeType'),
  period?: int32(name='Period'),
  auto?: boolean(name='Auto'),
  autoPayOrder?: boolean(name='AutoPayOrder'),
  vpcId?: string(name='VpcId'),
  vSwitchId?: string(name='VSwitchId'),
  netType?: string(name='NetType'),
  userDefinedEmrEcsRole?: string(name='UserDefinedEmrEcsRole'),
  emrVer?: string(name='EmrVer'),
  clusterType?: string(name='ClusterType'),
  enableHighAvailability?: boolean(name='EnableHighAvailability'),
  useLocalMetaDb?: boolean(name='UseLocalMetaDb'),
  enableSsh?: boolean(name='EnableSsh'),
  instanceGeneration?: string(name='InstanceGeneration'),
  masterPwd?: string(name='MasterPwd'),
  keyPairName?: string(name='KeyPairName'),
  metaStoreType?: string(name='MetaStoreType'),
  metaStoreConf?: string(name='MetaStoreConf'),
  clickHouseConf?: string(name='ClickHouseConf'),
  extraAttributes?: string(name='ExtraAttributes'),
  depositType?: string(name='DepositType'),
  machineType?: string(name='MachineType'),
  useCustomHiveMetaDB?: boolean(name='UseCustomHiveMetaDB'),
  initCustomHiveMetaDB?: boolean(name='InitCustomHiveMetaDB'),
  configurations?: string(name='Configurations'),
  enableEas?: boolean(name='EnableEas'),
  relatedClusterId?: string(name='RelatedClusterId'),
  whiteListType?: string(name='WhiteListType'),
  authorizeContent?: string(name='AuthorizeContent'),
  resourceGroupId?: string(name='ResourceGroupId'),
  clientToken?: string(name='ClientToken'),
  userInfo?: [ 
    {
      password?: string(name='Password'),
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='UserInfo'),
  hostComponentInfo?: [ 
    {
      componentNameList?: [ string ](name='ComponentNameList'),
      hostName?: string(name='HostName'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='HostComponentInfo'),
  serviceInfo?: [ 
    {
      serviceName?: string(name='ServiceName'),
      serviceVersion?: string(name='ServiceVersion'),
    }
  ](name='ServiceInfo'),
  promotionInfo?: [ 
    {
      productCode?: string(name='ProductCode'),
      promotionOptionCode?: string(name='PromotionOptionCode'),
      promotionOptionNo?: string(name='PromotionOptionNo'),
    }
  ](name='PromotionInfo'),
  hostGroup?: [ 
    {
      autoRenew?: boolean(name='AutoRenew'),
      chargeType?: string(name='ChargeType'),
      clusterId?: string(name='ClusterId'),
      comment?: string(name='Comment'),
      createType?: string(name='CreateType'),
      diskCapacity?: int32(name='DiskCapacity'),
      diskCount?: int32(name='DiskCount'),
      diskType?: string(name='DiskType'),
      gpuDriver?: string(name='GpuDriver'),
      hostGroupId?: string(name='HostGroupId'),
      hostGroupName?: string(name='HostGroupName'),
      hostGroupType?: string(name='HostGroupType'),
      instanceType?: string(name='InstanceType'),
      nodeCount?: int32(name='NodeCount'),
      period?: int32(name='Period'),
      sysDiskCapacity?: int32(name='SysDiskCapacity'),
      sysDiskType?: string(name='SysDiskType'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='HostGroup'),
  bootstrapAction?: [ 
    {
      arg?: string(name='Arg'),
      name?: string(name='Name'),
      path?: string(name='Path'),
    }
  ](name='BootstrapAction'),
  config?: [ 
    {
      configKey?: string(name='ConfigKey'),
      configValue?: string(name='ConfigValue'),
      encrypt?: string(name='Encrypt'),
      fileName?: string(name='FileName'),
      replace?: string(name='Replace'),
      serviceName?: string(name='ServiceName'),
    }
  ](name='Config'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model CreateClusterV2ResponseBody = {
  clusterId?: string(name='ClusterId'),
  coreOrderId?: string(name='CoreOrderId'),
  emrOrderId?: string(name='EmrOrderId'),
  masterOrderId?: string(name='MasterOrderId'),
  requestId?: string(name='RequestId'),
}

model CreateClusterV2Response = {
  headers: map[string]string(name='headers'),
  body: CreateClusterV2ResponseBody(name='body'),
}

async function createClusterV2WithOptions(request: CreateClusterV2Request, runtime: Util.RuntimeOptions): CreateClusterV2Response {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateClusterV2', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createClusterV2(request: CreateClusterV2Request): CreateClusterV2Response {
  var runtime = new Util.RuntimeOptions{};
  return createClusterV2WithOptions(request, runtime);
}

model ModifyClusterNameRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  id?: string(name='Id'),
  name?: string(name='Name'),
}

model ModifyClusterNameResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyClusterNameResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyClusterNameResponseBody(name='body'),
}

async function modifyClusterNameWithOptions(request: ModifyClusterNameRequest, runtime: Util.RuntimeOptions): ModifyClusterNameResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ModifyClusterName', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function modifyClusterName(request: ModifyClusterNameRequest): ModifyClusterNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyClusterNameWithOptions(request, runtime);
}

model ListClusterOperationHostTaskRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  operationId?: string(name='OperationId'),
  hostId?: string(name='HostId'),
  status?: string(name='Status'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListClusterOperationHostTaskResponseBody = {
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  totalCount?: int32(name='TotalCount'),
  clusterOperationHostTaskList?: {
    clusterOperationHostTask?: [ 
    {
      status?: string(name='Status'),
      percentage?: string(name='Percentage'),
      taskId?: string(name='TaskId'),
      taskName?: string(name='TaskName'),
    }
  ](name='ClusterOperationHostTask')
  }(name='ClusterOperationHostTaskList'),
}

model ListClusterOperationHostTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterOperationHostTaskResponseBody(name='body'),
}

async function listClusterOperationHostTaskWithOptions(request: ListClusterOperationHostTaskRequest, runtime: Util.RuntimeOptions): ListClusterOperationHostTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListClusterOperationHostTask', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusterOperationHostTask(request: ListClusterOperationHostTaskRequest): ListClusterOperationHostTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterOperationHostTaskWithOptions(request, runtime);
}

model DescribeScalingConfigItemRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  scalingConfigItemId?: string(name='ScalingConfigItemId'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  configItemType?: string(name='ConfigItemType'),
}

model DescribeScalingConfigItemResponseBody = {
  requestId?: string(name='RequestId', description='requestId'),
  configItemType?: string(name='ConfigItemType', description='data'),
  scalingGroupBizId?: string(name='ScalingGroupBizId'),
  scalingConfigItemBizId?: string(name='ScalingConfigItemBizId'),
  configItemInformation?: string(name='ConfigItemInformation'),
}

model DescribeScalingConfigItemResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeScalingConfigItemResponseBody(name='body'),
}

async function describeScalingConfigItemWithOptions(request: DescribeScalingConfigItemRequest, runtime: Util.RuntimeOptions): DescribeScalingConfigItemResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeScalingConfigItem', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeScalingConfigItem(request: DescribeScalingConfigItemRequest): DescribeScalingConfigItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeScalingConfigItemWithOptions(request, runtime);
}

model ListClusterHostRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostInstanceId?: string(name='HostInstanceId'),
  hostGroupId?: string(name='HostGroupId'),
  hostName?: string(name='HostName'),
  privateIp?: string(name='PrivateIp'),
  publicIp?: string(name='PublicIp'),
  groupType?: string(name='GroupType'),
  componentName?: string(name='ComponentName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  statusList?: [ string ](name='StatusList'),
}

model ListClusterHostResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  total?: int32(name='Total'),
  hostList?: {
    host?: [ 
    {
      serialNumber?: string(name='SerialNumber'),
      type?: string(name='Type'),
      status?: string(name='Status'),
      privateIp?: string(name='PrivateIp'),
      createTime?: string(name='CreateTime'),
      chargeType?: string(name='ChargeType'),
      hostName?: string(name='HostName'),
      hostGroupId?: string(name='HostGroupId'),
      instanceType?: string(name='InstanceType'),
      hostInstanceId?: string(name='HostInstanceId'),
      supportIpV6?: boolean(name='SupportIpV6'),
      cpu?: int32(name='Cpu'),
      expiredTime?: long(name='ExpiredTime'),
      zoneId?: string(name='ZoneId'),
      publicIp?: string(name='PublicIp'),
      instanceStatus?: string(name='InstanceStatus'),
      memory?: int32(name='Memory'),
      emrExpiredTime?: string(name='EmrExpiredTime'),
      role?: string(name='Role'),
      diskList?: {
        disk?: [ 
        {
          type?: string(name='Type'),
          diskType?: string(name='DiskType'),
          diskId?: string(name='DiskId'),
          device?: string(name='Device'),
          diskSize?: int32(name='DiskSize'),
        }
      ](name='Disk')
      }(name='DiskList'),
    }
  ](name='Host')
  }(name='HostList'),
}

model ListClusterHostResponse = {
  headers: map[string]string(name='headers'),
  body: ListClusterHostResponseBody(name='body'),
}

async function listClusterHostWithOptions(request: ListClusterHostRequest, runtime: Util.RuntimeOptions): ListClusterHostResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListClusterHost', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listClusterHost(request: ListClusterHostRequest): ListClusterHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClusterHostWithOptions(request, runtime);
}

model CreateScalingGroupRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  name?: string(name='Name'),
  description?: string(name='Description'),
  hostGroupId?: string(name='HostGroupId'),
}

model CreateScalingGroupResponseBody = {
  requestId?: string(name='RequestId', description='requestId'),
  data?: string(name='Data', description='data'),
}

model CreateScalingGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateScalingGroupResponseBody(name='body'),
}

async function createScalingGroupWithOptions(request: CreateScalingGroupRequest, runtime: Util.RuntimeOptions): CreateScalingGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateScalingGroup', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createScalingGroup(request: CreateScalingGroupRequest): CreateScalingGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createScalingGroupWithOptions(request, runtime);
}

model DescribeClusterServiceRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  serviceName?: string(name='ServiceName'),
}

model DescribeClusterServiceResponseBody = {
  requestId?: string(name='RequestId'),
  serviceInfo?: {
    needRestartInfo?: string(name='NeedRestartInfo'),
    serviceVersion?: string(name='ServiceVersion'),
    serviceStatus?: string(name='ServiceStatus'),
    serviceName?: string(name='ServiceName'),
    needRestartNum?: int32(name='NeedRestartNum'),
    serviceActionList?: {
      serviceAction?: [ 
      {
        displayName?: string(name='DisplayName'),
        actionName?: string(name='ActionName'),
        componentName?: string(name='ComponentName'),
        serviceName?: string(name='ServiceName'),
        command?: string(name='Command'),
      }
    ](name='ServiceAction')
    }(name='ServiceActionList'),
    clusterServiceSummaryList?: {
      clusterServiceSummary?: [ 
      {
        key?: string(name='Key'),
        displayName?: string(name='DisplayName'),
        status?: string(name='Status'),
        type?: string(name='Type'),
        value?: string(name='Value'),
        desiredStoppedValue?: int32(name='DesiredStoppedValue'),
        alertInfo?: string(name='AlertInfo'),
        category?: string(name='Category'),
      }
    ](name='ClusterServiceSummary')
    }(name='ClusterServiceSummaryList'),
    needRestartHostIdList?: {
      service?: [ string ](name='Service')
    }(name='NeedRestartHostIdList'),
    needRestartComponentNameList?: {
      service?: [ string ](name='Service')
    }(name='NeedRestartComponentNameList'),
  }(name='ServiceInfo'),
}

model DescribeClusterServiceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeClusterServiceResponseBody(name='body'),
}

async function describeClusterServiceWithOptions(request: DescribeClusterServiceRequest, runtime: Util.RuntimeOptions): DescribeClusterServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeClusterService', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeClusterService(request: DescribeClusterServiceRequest): DescribeClusterServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClusterServiceWithOptions(request, runtime);
}

model ListFlowProjectsRequest {
  productType?: string(name='ProductType'),
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model ListFlowProjectsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
  projects?: {
    project?: [ 
    {
      description?: string(name='Description'),
      userId?: string(name='UserId'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='Project')
  }(name='Projects'),
}

model ListFlowProjectsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowProjectsResponseBody(name='body'),
}

async function listFlowProjectsWithOptions(request: ListFlowProjectsRequest, runtime: Util.RuntimeOptions): ListFlowProjectsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlowProjects', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlowProjects(request: ListFlowProjectsRequest): ListFlowProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowProjectsWithOptions(request, runtime);
}

model CreateMetaTablePreviewTaskRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  databaseId?: string(name='DatabaseId'),
  tableId?: string(name='TableId'),
  user?: string(name='User'),
  password?: string(name='Password'),
  resourceGroupId?: string(name='ResourceGroupId'),
  clientToken?: string(name='ClientToken'),
}

model CreateMetaTablePreviewTaskResponseBody = {
  taskId?: string(name='TaskId'),
  requestId?: string(name='RequestId'),
}

model CreateMetaTablePreviewTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMetaTablePreviewTaskResponseBody(name='body'),
}

async function createMetaTablePreviewTaskWithOptions(request: CreateMetaTablePreviewTaskRequest, runtime: Util.RuntimeOptions): CreateMetaTablePreviewTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateMetaTablePreviewTask', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createMetaTablePreviewTask(request: CreateMetaTablePreviewTaskRequest): CreateMetaTablePreviewTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMetaTablePreviewTaskWithOptions(request, runtime);
}

model ListFlowProjectUserRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListFlowProjectUserResponseBody = {
  requestId?: string(name='RequestId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  total?: int32(name='Total'),
  users?: {
    user?: [ 
    {
      projectId?: string(name='ProjectId'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      userName?: string(name='UserName'),
      accountUserId?: string(name='AccountUserId'),
      ownerId?: string(name='OwnerId'),
    }
  ](name='User')
  }(name='Users'),
}

model ListFlowProjectUserResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowProjectUserResponseBody(name='body'),
}

async function listFlowProjectUserWithOptions(request: ListFlowProjectUserRequest, runtime: Util.RuntimeOptions): ListFlowProjectUserResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlowProjectUser', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlowProjectUser(request: ListFlowProjectUserRequest): ListFlowProjectUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowProjectUserWithOptions(request, runtime);
}

model DeleteClusterHostGroupRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  clusterId?: string(name='ClusterId'),
  hostGroupId?: string(name='HostGroupId'),
  comment?: string(name='Comment'),
}

model DeleteClusterHostGroupResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteClusterHostGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteClusterHostGroupResponseBody(name='body'),
}

async function deleteClusterHostGroupWithOptions(request: DeleteClusterHostGroupRequest, runtime: Util.RuntimeOptions): DeleteClusterHostGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteClusterHostGroup', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteClusterHostGroup(request: DeleteClusterHostGroupRequest): DeleteClusterHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterHostGroupWithOptions(request, runtime);
}

model DescribeLibraryDetailRequest {
  resourceOwnerId?: long(name='ResourceOwnerId'),
  regionId?: string(name='RegionId'),
  libraryBizId?: string(name='LibraryBizId'),
}

model DescribeLibraryDetailResponseBody = {
  type?: string(name='Type'),
  requestId?: string(name='RequestId'),
  createTime?: long(name='CreateTime'),
  userId?: string(name='UserId'),
  sourceType?: string(name='SourceType'),
  bizId?: string(name='BizId'),
  scope?: string(name='Scope'),
  libraryVersion?: string(name='LibraryVersion'),
  name?: string(name='Name'),
  properties?: string(name='Properties'),
  sourceLocation?: string(name='SourceLocation'),
}

model DescribeLibraryDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLibraryDetailResponseBody(name='body'),
}

async function describeLibraryDetailWithOptions(request: DescribeLibraryDetailRequest, runtime: Util.RuntimeOptions): DescribeLibraryDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeLibraryDetail', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeLibraryDetail(request: DescribeLibraryDetailRequest): DescribeLibraryDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLibraryDetailWithOptions(request, runtime);
}

model ListFlowsRequest {
  regionId?: string(name='RegionId'),
  projectId?: string(name='ProjectId'),
  jobId?: string(name='JobId'),
  name?: string(name='Name'),
  id?: string(name='Id'),
  clusterId?: string(name='ClusterId'),
  status?: string(name='Status'),
  periodic?: boolean(name='Periodic'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListFlowsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  total?: int32(name='Total'),
  flow?: {
    flow?: [ 
    {
      type?: string(name='Type'),
      status?: string(name='Status'),
      alertUserGroupBizId?: string(name='AlertUserGroupBizId'),
      periodic?: boolean(name='Periodic'),
      projectId?: string(name='ProjectId'),
      hostName?: string(name='HostName'),
      gmtModified?: long(name='GmtModified'),
      description?: string(name='Description'),
      startSchedule?: long(name='StartSchedule'),
      createCluster?: boolean(name='CreateCluster'),
      endSchedule?: long(name='EndSchedule'),
      graph?: string(name='Graph'),
      gmtCreate?: long(name='GmtCreate'),
      alertDingDingGroupBizId?: string(name='AlertDingDingGroupBizId'),
      cronExpr?: string(name='CronExpr'),
      categoryId?: string(name='CategoryId'),
      name?: string(name='Name'),
      id?: string(name='Id'),
      clusterId?: string(name='ClusterId'),
      alertConf?: string(name='AlertConf'),
    }
  ](name='Flow')
  }(name='Flow'),
}

model ListFlowsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFlowsResponseBody(name='body'),
}

async function listFlowsWithOptions(request: ListFlowsRequest, runtime: Util.RuntimeOptions): ListFlowsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListFlows', '2020-06-17', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listFlows(request: ListFlowsRequest): ListFlowsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFlowsWithOptions(request, runtime);
}

