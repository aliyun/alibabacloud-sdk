/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    'cn-hangzhou' = 'et-industry.cn-hangzhou.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('et-industry-openapi', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model GetMqttConnectRequest {
  request?: map[string]any(name='Request'),
}

model GetMqttConnectResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId'),
    authPrincipalType?: string(name='AuthPrincipalType'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage'),
    noPermissionType?: string(name='NoPermissionType'),
    policyType?: string(name='PolicyType'),
  }(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: {
    accessKey?: string(name='AccessKey'),
    clientId?: string(name='ClientId'),
    expireTime?: long(name='ExpireTime'),
    instanceId?: string(name='InstanceId'),
    qosLevel?: int32(name='QosLevel'),
    serverUri?: string(name='ServerUri'),
    token?: string(name='Token'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMqttConnectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMqttConnectResponseBody(name='body'),
}

/**
 * @param request GetMqttConnectRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMqttConnectResponse
 */
async function getMqttConnectWithOptions(request: GetMqttConnectRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMqttConnectResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.request)) {
    body['Request'] = request.request;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMqttConnect',
    version = '2020-08-24',
    protocol = 'HTTPS',
    pathname = `/api/igate/collaboration/pop/getmqttconnect`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetMqttConnectRequest
 * @return GetMqttConnectResponse
 */
async function getMqttConnect(request: GetMqttConnectRequest): GetMqttConnectResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMqttConnectWithOptions(request, headers, runtime);
}

model GetNonceRequest {
  request?: map[string]any(name='Request'),
}

model GetNonceResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId'),
    authPrincipalType?: string(name='AuthPrincipalType'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage'),
    noPermissionType?: string(name='NoPermissionType'),
    policyType?: string(name='PolicyType'),
  }(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: {
    expiresIn?: long(name='ExpiresIn'),
    nonce?: string(name='Nonce'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetNonceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetNonceResponseBody(name='body'),
}

/**
 * @param request GetNonceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNonceResponse
 */
async function getNonceWithOptions(request: GetNonceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetNonceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.request)) {
    body['Request'] = request.request;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetNonce',
    version = '2020-08-24',
    protocol = 'HTTPS',
    pathname = `/api/igate/collaboration/pop/getnonce`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request GetNonceRequest
 * @return GetNonceResponse
 */
async function getNonce(request: GetNonceRequest): GetNonceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getNonceWithOptions(request, headers, runtime);
}

model ListMeasurePointListByNodeCodePageRequest {
  request?: map[string]any(name='Request'),
}

model ListMeasurePointListByNodeCodePageResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId'),
    authPrincipalType?: string(name='AuthPrincipalType'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage'),
    noPermissionType?: string(name='NoPermissionType'),
    policyType?: string(name='PolicyType'),
  }(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: {
    count?: int32(name='Count'),
    currentPage?: int32(name='CurrentPage'),
    dataList?: [ 
      {
        acqFreq?: string(name='AcqFreq'),
        alarmAttribute?: string(name='AlarmAttribute'),
        alarmLevel?: string(name='AlarmLevel'),
        calcAttribute?: string(name='CalcAttribute'),
        calcFormula?: string(name='CalcFormula'),
        calcType?: string(name='CalcType'),
        code?: string(name='Code'),
        createUser?: string(name='CreateUser'),
        dataSourceId?: string(name='DataSourceId'),
        dataType?: string(name='DataType'),
        description?: string(name='Description'),
        errMsgDetail?: string(name='ErrMsgDetail'),
        fullName?: string(name='FullName'),
        gmtCreate?: long(name='GmtCreate'),
        gmtModify?: long(name='GmtModify'),
        id?: int32(name='Id'),
        initValue?: string(name='InitValue'),
        isEnable?: string(name='IsEnable'),
        lastUploadTime?: string(name='LastUploadTime'),
        latestValue?: string(name='LatestValue'),
        lowerLimit?: string(name='LowerLimit'),
        measurePointState?: string(name='MeasurePointState'),
        modifyUser?: string(name='ModifyUser'),
        name?: string(name='Name'),
        nodeCode?: string(name='NodeCode'),
        nodeId?: int32(name='NodeId'),
        nodeName?: string(name='NodeName'),
        parentFullName?: string(name='ParentFullName'),
        payLoad?: string(name='PayLoad'),
        protocolConfig?: string(name='ProtocolConfig'),
        sourcePoint?: string(name='SourcePoint'),
        tenantCode?: string(name='TenantCode'),
        time?: string(name='Time'),
        type?: string(name='Type'),
        unit?: string(name='Unit'),
        upperLimit?: string(name='UpperLimit'),
      }
    ](name='DataList'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListMeasurePointListByNodeCodePageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMeasurePointListByNodeCodePageResponseBody(name='body'),
}

/**
 * @param request ListMeasurePointListByNodeCodePageRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMeasurePointListByNodeCodePageResponse
 */
async function listMeasurePointListByNodeCodePageWithOptions(request: ListMeasurePointListByNodeCodePageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMeasurePointListByNodeCodePageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.request)) {
    body['Request'] = request.request;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMeasurePointListByNodeCodePage',
    version = '2020-08-24',
    protocol = 'HTTPS',
    pathname = `/api/igate/node/pop/measurepointlistbynodecodepage`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request ListMeasurePointListByNodeCodePageRequest
 * @return ListMeasurePointListByNodeCodePageResponse
 */
async function listMeasurePointListByNodeCodePage(request: ListMeasurePointListByNodeCodePageRequest): ListMeasurePointListByNodeCodePageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMeasurePointListByNodeCodePageWithOptions(request, headers, runtime);
}

model MultiFieldBatchUploadRequest {
  body?: map[string]any(name='body'),
}

model MultiFieldBatchUploadResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId'),
    authPrincipalType?: string(name='AuthPrincipalType'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage'),
    noPermissionType?: string(name='NoPermissionType'),
    policyType?: string(name='PolicyType'),
  }(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: {
    count?: long(name='Count'),
    message?: [ 
      {
        errorMsg?: string(name='ErrorMsg'),
        measurePoint?: string(name='MeasurePoint'),
        node?: string(name='Node'),
      }
    ](name='Message'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model MultiFieldBatchUploadResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MultiFieldBatchUploadResponseBody(name='body'),
}

/**
 * @summary 多值批量上报
 *
 * @param request MultiFieldBatchUploadRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return MultiFieldBatchUploadResponse
 */
async function multiFieldBatchUploadWithOptions(request: MultiFieldBatchUploadRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MultiFieldBatchUploadResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'MultiFieldBatchUpload',
    version = '2020-08-24',
    protocol = 'HTTPS',
    pathname = `/api/igate/timeseries/upload/pop/multifieldbatchv2`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 多值批量上报
 *
 * @param request MultiFieldBatchUploadRequest
 * @return MultiFieldBatchUploadResponse
 */
async function multiFieldBatchUpload(request: MultiFieldBatchUploadRequest): MultiFieldBatchUploadResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return multiFieldBatchUploadWithOptions(request, headers, runtime);
}

model MultiSourcePointBatchUploadRequest {
  body?: map[string]any(name='body'),
}

model MultiSourcePointBatchUploadResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId'),
    authPrincipalType?: string(name='AuthPrincipalType'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage'),
    noPermissionType?: string(name='NoPermissionType'),
    policyType?: string(name='PolicyType'),
  }(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: {
    count?: long(name='Count'),
    message?: [ 
      {
        errorMsg?: string(name='ErrorMsg'),
        node?: string(name='Node'),
        sourcePoint?: string(name='SourcePoint'),
      }
    ](name='Message'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model MultiSourcePointBatchUploadResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MultiSourcePointBatchUploadResponseBody(name='body'),
}

/**
 * @summary 多源点位批量上报
 *
 * @param request MultiSourcePointBatchUploadRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return MultiSourcePointBatchUploadResponse
 */
async function multiSourcePointBatchUploadWithOptions(request: MultiSourcePointBatchUploadRequest, headers: map[string]string, runtime: Util.RuntimeOptions): MultiSourcePointBatchUploadResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['body'] = request.body;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'MultiSourcePointBatchUpload',
    version = '2020-08-24',
    protocol = 'HTTPS',
    pathname = `/api/igate/timeseries/upload/pop/sourcepointbatchv2`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @summary 多源点位批量上报
 *
 * @param request MultiSourcePointBatchUploadRequest
 * @return MultiSourcePointBatchUploadResponse
 */
async function multiSourcePointBatchUpload(request: MultiSourcePointBatchUploadRequest): MultiSourcePointBatchUploadResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return multiSourcePointBatchUploadWithOptions(request, headers, runtime);
}

model QueryFieldLatestBySourcePointRequest {
  request?: map[string]any(name='Request'),
}

model QueryFieldLatestBySourcePointResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId'),
    authPrincipalType?: string(name='AuthPrincipalType'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage'),
    noPermissionType?: string(name='NoPermissionType'),
    policyType?: string(name='PolicyType'),
  }(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: [ 
    {
      measurePoint?: string(name='MeasurePoint'),
      node?: string(name='Node'),
      sourcePoint?: string(name='SourcePoint'),
      valueType?: string(name='ValueType'),
      values?: [ 
        {
          eventTime?: string(name='EventTime'),
          processTime?: string(name='ProcessTime'),
          quality?: int32(name='Quality'),
          sampleType?: string(name='SampleType'),
          time?: long(name='Time'),
          timestamp?: long(name='Timestamp'),
          value?: string(name='Value'),
        }
      ](name='Values'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryFieldLatestBySourcePointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryFieldLatestBySourcePointResponseBody(name='body'),
}

/**
 * @param request QueryFieldLatestBySourcePointRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryFieldLatestBySourcePointResponse
 */
async function queryFieldLatestBySourcePointWithOptions(request: QueryFieldLatestBySourcePointRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryFieldLatestBySourcePointResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.request)) {
    body['Request'] = request.request;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryFieldLatestBySourcePoint',
    version = '2020-08-24',
    protocol = 'HTTPS',
    pathname = `/api/igate/timeseries/query/pop/multifieldlatestbysourcepoint`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request QueryFieldLatestBySourcePointRequest
 * @return QueryFieldLatestBySourcePointResponse
 */
async function queryFieldLatestBySourcePoint(request: QueryFieldLatestBySourcePointRequest): QueryFieldLatestBySourcePointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryFieldLatestBySourcePointWithOptions(request, headers, runtime);
}

model QueryIndustryDeviceDataRequest {
  request?: map[string]any(name='Request'),
}

model QueryIndustryDeviceDataResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId'),
    authPrincipalType?: string(name='AuthPrincipalType'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage'),
    noPermissionType?: string(name='NoPermissionType'),
    policyType?: string(name='PolicyType'),
  }(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: [ 
    {
      measurePoint?: string(name='MeasurePoint'),
      node?: string(name='Node'),
      valueType?: string(name='ValueType'),
      values?: [ 
        {
          eventTime?: string(name='EventTime'),
          processTime?: string(name='ProcessTime'),
          quality?: int32(name='Quality'),
          time?: long(name='Time'),
          timeStamp?: long(name='TimeStamp'),
          value?: string(name='Value'),
        }
      ](name='Values'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryIndustryDeviceDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryIndustryDeviceDataResponseBody(name='body'),
}

/**
 * @param request QueryIndustryDeviceDataRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryIndustryDeviceDataResponse
 */
async function queryIndustryDeviceDataWithOptions(request: QueryIndustryDeviceDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryIndustryDeviceDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.request)) {
    body['Request'] = request.request;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryIndustryDeviceData',
    version = '2020-08-24',
    protocol = 'HTTPS',
    pathname = `/api/igate/timeseries/query/pop/multifieldlatest`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request QueryIndustryDeviceDataRequest
 * @return QueryIndustryDeviceDataResponse
 */
async function queryIndustryDeviceData(request: QueryIndustryDeviceDataRequest): QueryIndustryDeviceDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryIndustryDeviceDataWithOptions(request, headers, runtime);
}

model QueryIndustryDeviceLimitsDataRequest {
  request?: map[string]any(name='Request'),
}

model QueryIndustryDeviceLimitsDataResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId'),
    authPrincipalType?: string(name='AuthPrincipalType'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage'),
    noPermissionType?: string(name='NoPermissionType'),
    policyType?: string(name='PolicyType'),
  }(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: [ 
    {
      measurePoint?: string(name='MeasurePoint'),
      node?: string(name='Node'),
      valueType?: string(name='ValueType'),
      values?: [ 
        {
          eventTime?: string(name='EventTime'),
          processTime?: string(name='ProcessTime'),
          quality?: int32(name='Quality'),
          time?: long(name='Time'),
          timeStamp?: long(name='TimeStamp'),
          value?: string(name='Value'),
        }
      ](name='Values'),
    }
  ](name='Data'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryIndustryDeviceLimitsDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryIndustryDeviceLimitsDataResponseBody(name='body'),
}

/**
 * @param request QueryIndustryDeviceLimitsDataRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryIndustryDeviceLimitsDataResponse
 */
async function queryIndustryDeviceLimitsDataWithOptions(request: QueryIndustryDeviceLimitsDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryIndustryDeviceLimitsDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.request)) {
    body['Request'] = request.request;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryIndustryDeviceLimitsData',
    version = '2020-08-24',
    protocol = 'HTTPS',
    pathname = `/api/igate/timeseries/query/pop/multifieldrange`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request QueryIndustryDeviceLimitsDataRequest
 * @return QueryIndustryDeviceLimitsDataResponse
 */
async function queryIndustryDeviceLimitsData(request: QueryIndustryDeviceLimitsDataRequest): QueryIndustryDeviceLimitsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryIndustryDeviceLimitsDataWithOptions(request, headers, runtime);
}

model QueryIndustryDeviceStatusDataRequest {
  request?: map[string]any(name='Request'),
}

model QueryIndustryDeviceStatusDataResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId'),
    authPrincipalType?: string(name='AuthPrincipalType'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage'),
    noPermissionType?: string(name='NoPermissionType'),
    policyType?: string(name='PolicyType'),
  }(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: [ 
    {
      measurePoint?: string(name='MeasurePoint'),
      node?: string(name='Node'),
      valueType?: string(name='ValueType'),
      values?: [  map[string]any ](name='Values'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryIndustryDeviceStatusDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryIndustryDeviceStatusDataResponseBody(name='body'),
}

/**
 * @param request QueryIndustryDeviceStatusDataRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryIndustryDeviceStatusDataResponse
 */
async function queryIndustryDeviceStatusDataWithOptions(request: QueryIndustryDeviceStatusDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryIndustryDeviceStatusDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.request)) {
    body['Request'] = request.request;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryIndustryDeviceStatusData',
    version = '2020-08-24',
    protocol = 'HTTPS',
    pathname = `/api/igate/timeseries/query/pop/multifieldrangestatus`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request QueryIndustryDeviceStatusDataRequest
 * @return QueryIndustryDeviceStatusDataResponse
 */
async function queryIndustryDeviceStatusData(request: QueryIndustryDeviceStatusDataRequest): QueryIndustryDeviceStatusDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryIndustryDeviceStatusDataWithOptions(request, headers, runtime);
}

model SourcePointBatchRequest {
  request?: map[string]any(name='Request'),
}

model SourcePointBatchResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId'),
    authPrincipalType?: string(name='AuthPrincipalType'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage'),
    noPermissionType?: string(name='NoPermissionType'),
    policyType?: string(name='PolicyType'),
  }(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: {
    count?: int32(name='Count'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SourcePointBatchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SourcePointBatchResponseBody(name='body'),
}

/**
 * @param request SourcePointBatchRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SourcePointBatchResponse
 */
async function sourcePointBatchWithOptions(request: SourcePointBatchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SourcePointBatchResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.request)) {
    body['Request'] = request.request;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SourcePointBatch',
    version = '2020-08-24',
    protocol = 'HTTPS',
    pathname = `/api/igate/timeseries/upload/pop/sourcepointbatch`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request SourcePointBatchRequest
 * @return SourcePointBatchResponse
 */
async function sourcePointBatch(request: SourcePointBatchRequest): SourcePointBatchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return sourcePointBatchWithOptions(request, headers, runtime);
}

model UploadIndustryDeviceDataRequest {
  request?: map[string]any(name='Request'),
}

model UploadIndustryDeviceDataResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId'),
    authPrincipalType?: string(name='AuthPrincipalType'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage'),
    noPermissionType?: string(name='NoPermissionType'),
    policyType?: string(name='PolicyType'),
  }(name='AccessDeniedDetail'),
  code?: string(name='Code'),
  data?: {
    count?: int32(name='Count'),
    message?: [ 
      {
        errorMsg?: string(name='ErrorMsg'),
        measurePoint?: string(name='MeasurePoint'),
        node?: string(name='Node'),
      }
    ](name='Message'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UploadIndustryDeviceDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadIndustryDeviceDataResponseBody(name='body'),
}

/**
 * @param request UploadIndustryDeviceDataRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadIndustryDeviceDataResponse
 */
async function uploadIndustryDeviceDataWithOptions(request: UploadIndustryDeviceDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UploadIndustryDeviceDataResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.request)) {
    body['Request'] = request.request;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UploadIndustryDeviceData',
    version = '2020-08-24',
    protocol = 'HTTPS',
    pathname = `/api/igate/timeseries/upload/pop/multifieldbatch`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  if (Util.isUnset(@signatureVersion) || !Util.equalString(@signatureVersion, 'v4')) {
    return callApi(params, req, runtime);
  } else {
    return execute(params, req, runtime);
  }
}

/**
 * @param request UploadIndustryDeviceDataRequest
 * @return UploadIndustryDeviceDataResponse
 */
async function uploadIndustryDeviceData(request: UploadIndustryDeviceDataRequest): UploadIndustryDeviceDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uploadIndustryDeviceDataWithOptions(request, headers, runtime);
}

