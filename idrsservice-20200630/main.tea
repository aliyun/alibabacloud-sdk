/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'idrsservice.aliyuncs.com',
    ap-northeast-2-pop = 'idrsservice.aliyuncs.com',
    ap-south-1 = 'idrsservice.aliyuncs.com',
    ap-southeast-1 = 'idrsservice.aliyuncs.com',
    ap-southeast-2 = 'idrsservice.aliyuncs.com',
    ap-southeast-3 = 'idrsservice.aliyuncs.com',
    ap-southeast-5 = 'idrsservice.aliyuncs.com',
    cn-beijing = 'idrsservice.aliyuncs.com',
    cn-beijing-finance-1 = 'idrsservice.aliyuncs.com',
    cn-beijing-finance-pop = 'idrsservice.aliyuncs.com',
    cn-beijing-gov-1 = 'idrsservice.aliyuncs.com',
    cn-beijing-nu16-b01 = 'idrsservice.aliyuncs.com',
    cn-chengdu = 'idrsservice.aliyuncs.com',
    cn-edge-1 = 'idrsservice.aliyuncs.com',
    cn-fujian = 'idrsservice.aliyuncs.com',
    cn-haidian-cm12-c01 = 'idrsservice.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'idrsservice.aliyuncs.com',
    cn-hangzhou-finance = 'idrsservice.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'idrsservice.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'idrsservice.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'idrsservice.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'idrsservice.aliyuncs.com',
    cn-hangzhou-test-306 = 'idrsservice.aliyuncs.com',
    cn-hongkong = 'idrsservice.aliyuncs.com',
    cn-hongkong-finance-pop = 'idrsservice.aliyuncs.com',
    cn-huhehaote = 'idrsservice.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'idrsservice.aliyuncs.com',
    cn-north-2-gov-1 = 'idrsservice.aliyuncs.com',
    cn-qingdao = 'idrsservice.aliyuncs.com',
    cn-qingdao-nebula = 'idrsservice.aliyuncs.com',
    cn-shanghai = 'idrsservice.aliyuncs.com',
    cn-shanghai-et15-b01 = 'idrsservice.aliyuncs.com',
    cn-shanghai-et2-b01 = 'idrsservice.aliyuncs.com',
    cn-shanghai-inner = 'idrsservice.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'idrsservice.aliyuncs.com',
    cn-shenzhen = 'idrsservice.aliyuncs.com',
    cn-shenzhen-finance-1 = 'idrsservice.aliyuncs.com',
    cn-shenzhen-inner = 'idrsservice.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'idrsservice.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'idrsservice.aliyuncs.com',
    cn-wuhan = 'idrsservice.aliyuncs.com',
    cn-wulanchabu = 'idrsservice.aliyuncs.com',
    cn-yushanfang = 'idrsservice.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'idrsservice.aliyuncs.com',
    cn-zhangjiakou = 'idrsservice.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'idrsservice.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'idrsservice.aliyuncs.com',
    eu-central-1 = 'idrsservice.aliyuncs.com',
    eu-west-1 = 'idrsservice.aliyuncs.com',
    eu-west-1-oxs = 'idrsservice.aliyuncs.com',
    me-east-1 = 'idrsservice.aliyuncs.com',
    rus-west-1-pop = 'idrsservice.aliyuncs.com',
    us-east-1 = 'idrsservice.aliyuncs.com',
    us-west-1 = 'idrsservice.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('idrsservice', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AsrRealtimeRequest {
  appId?: string(name='AppId'),
  customizationId?: string(name='CustomizationId'),
  disfluency?: boolean(name='Disfluency'),
  enableIgnoreSentenceTimeout?: boolean(name='EnableIgnoreSentenceTimeout'),
  enableIntermediateResult?: boolean(name='EnableIntermediateResult'),
  enableInverseTextNormalization?: boolean(name='EnableInverseTextNormalization'),
  enablePunctuationPrediction?: boolean(name='EnablePunctuationPrediction'),
  enableSemanticSentenceDetection?: boolean(name='EnableSemanticSentenceDetection'),
  enableWords?: boolean(name='EnableWords'),
  fileUrl?: string(name='FileUrl'),
  format?: string(name='Format'),
  maxSentenceSilence?: long(name='MaxSentenceSilence'),
  sampleRate?: long(name='SampleRate'),
  speechNoiseThreshold?: float(name='SpeechNoiseThreshold'),
  vocabularyId?: string(name='VocabularyId'),
}

model AsrRealtimeResponseBody = {
  code?: int32(name='Code'),
  data?: {
    beginTime?: long(name='BeginTime'),
    code?: int32(name='Code'),
    confidence?: double(name='Confidence'),
    id?: string(name='Id'),
    message?: string(name='Message'),
    name?: string(name='Name'),
    result?: string(name='Result'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
    time?: long(name='Time'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AsrRealtimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AsrRealtimeResponseBody(name='body'),
}

async function asrRealtimeWithOptions(request: AsrRealtimeRequest, runtime: Util.RuntimeOptions): AsrRealtimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.customizationId)) {
    query['CustomizationId'] = request.customizationId;
  }
  if (!Util.isUnset(request.disfluency)) {
    query['Disfluency'] = request.disfluency;
  }
  if (!Util.isUnset(request.enableIgnoreSentenceTimeout)) {
    query['EnableIgnoreSentenceTimeout'] = request.enableIgnoreSentenceTimeout;
  }
  if (!Util.isUnset(request.enableIntermediateResult)) {
    query['EnableIntermediateResult'] = request.enableIntermediateResult;
  }
  if (!Util.isUnset(request.enableInverseTextNormalization)) {
    query['EnableInverseTextNormalization'] = request.enableInverseTextNormalization;
  }
  if (!Util.isUnset(request.enablePunctuationPrediction)) {
    query['EnablePunctuationPrediction'] = request.enablePunctuationPrediction;
  }
  if (!Util.isUnset(request.enableSemanticSentenceDetection)) {
    query['EnableSemanticSentenceDetection'] = request.enableSemanticSentenceDetection;
  }
  if (!Util.isUnset(request.enableWords)) {
    query['EnableWords'] = request.enableWords;
  }
  if (!Util.isUnset(request.fileUrl)) {
    query['FileUrl'] = request.fileUrl;
  }
  if (!Util.isUnset(request.format)) {
    query['Format'] = request.format;
  }
  if (!Util.isUnset(request.maxSentenceSilence)) {
    query['MaxSentenceSilence'] = request.maxSentenceSilence;
  }
  if (!Util.isUnset(request.sampleRate)) {
    query['SampleRate'] = request.sampleRate;
  }
  if (!Util.isUnset(request.speechNoiseThreshold)) {
    query['SpeechNoiseThreshold'] = request.speechNoiseThreshold;
  }
  if (!Util.isUnset(request.vocabularyId)) {
    query['VocabularyId'] = request.vocabularyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AsrRealtime',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function asrRealtime(request: AsrRealtimeRequest): AsrRealtimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return asrRealtimeWithOptions(request, runtime);
}

model AsrSentenceRequest {
  asrRequest?: {
    appId?: string(name='AppId'),
    enableInverseTextNormalization?: boolean(name='EnableInverseTextNormalization'),
    enablePunctuationPrediction?: boolean(name='EnablePunctuationPrediction'),
    enableVoiceDetection?: boolean(name='EnableVoiceDetection'),
    fileUrl?: string(name='FileUrl'),
    format?: string(name='Format'),
    sampleRate?: int32(name='SampleRate'),
  }(name='AsrRequest'),
}

model AsrSentenceShrinkRequest {
  asrRequestShrink?: string(name='AsrRequest'),
}

model AsrSentenceResponseBody = {
  code?: int32(name='Code'),
  data?: {
    code?: int32(name='Code'),
    id?: string(name='Id'),
    message?: string(name='Message'),
    name?: string(name='Name'),
    result?: string(name='Result'),
    taskId?: string(name='TaskId'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AsrSentenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AsrSentenceResponseBody(name='body'),
}

async function asrSentenceWithOptions(tmpReq: AsrSentenceRequest, runtime: Util.RuntimeOptions): AsrSentenceResponse {
  Util.validateModel(tmpReq);
  var request = new AsrSentenceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.asrRequest)) {
    request.asrRequestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.asrRequest, 'AsrRequest', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.asrRequestShrink)) {
    body['AsrRequest'] = request.asrRequestShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AsrSentence',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function asrSentence(request: AsrSentenceRequest): AsrSentenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return asrSentenceWithOptions(request, runtime);
}

model AsrTaskRequest {
  request?: {
    appId?: string(name='AppId'),
    asrTaskId?: string(name='AsrTaskId'),
    event?: string(name='Event'),
    roomId?: string(name='RoomId'),
    timestamp?: long(name='Timestamp'),
  }(name='Request'),
}

model AsrTaskShrinkRequest {
  requestShrink?: string(name='Request'),
}

model AsrTaskResponseBody = {
  code?: int32(name='Code'),
  data?: {
    result?: string(name='Result'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AsrTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AsrTaskResponseBody(name='body'),
}

async function asrTaskWithOptions(tmpReq: AsrTaskRequest, runtime: Util.RuntimeOptions): AsrTaskResponse {
  Util.validateModel(tmpReq);
  var request = new AsrTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.request)) {
    request.requestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.request, 'Request', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.requestShrink)) {
    body['Request'] = request.requestShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AsrTask',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function asrTask(request: AsrTaskRequest): AsrTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return asrTaskWithOptions(request, runtime);
}

model AssociateRoomRequest {
  appId?: string(name='AppId'),
  clientBaseParam?: string(name='ClientBaseParam'),
  clientVersion?: string(name='ClientVersion'),
  departmentId?: string(name='DepartmentId'),
  roomId?: string(name='RoomId'),
}

model AssociateRoomResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AssociateRoomResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AssociateRoomResponseBody(name='body'),
}

async function associateRoomWithOptions(request: AssociateRoomRequest, runtime: Util.RuntimeOptions): AssociateRoomResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clientBaseParam)) {
    query['ClientBaseParam'] = request.clientBaseParam;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.departmentId)) {
    query['DepartmentId'] = request.departmentId;
  }
  if (!Util.isUnset(request.roomId)) {
    query['RoomId'] = request.roomId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AssociateRoom',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function associateRoom(request: AssociateRoomRequest): AssociateRoomResponse {
  var runtime = new Util.RuntimeOptions{};
  return associateRoomWithOptions(request, runtime);
}

model CreateAppRequest {
  clientToken?: string(name='ClientToken'),
  departmentId?: string(name='DepartmentId'),
  name?: string(name='Name'),
  packageName?: string(name='PackageName'),
}

model CreateAppResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdAt?: string(name='CreatedAt'),
    creatorName?: string(name='CreatorName'),
    disabled?: boolean(name='Disabled'),
    id?: string(name='Id'),
    name?: string(name='Name'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAppResponseBody(name='body'),
}

async function createAppWithOptions(request: CreateAppRequest, runtime: Util.RuntimeOptions): CreateAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.departmentId)) {
    query['DepartmentId'] = request.departmentId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.packageName)) {
    query['PackageName'] = request.packageName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateApp',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createApp(request: CreateAppRequest): CreateAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAppWithOptions(request, runtime);
}

model CreateDepartmentRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  label?: string(name='Label'),
  name?: string(name='Name'),
}

model CreateDepartmentResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdAt?: string(name='CreatedAt'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateDepartmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDepartmentResponseBody(name='body'),
}

async function createDepartmentWithOptions(request: CreateDepartmentRequest, runtime: Util.RuntimeOptions): CreateDepartmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.label)) {
    query['Label'] = request.label;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDepartment',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDepartment(request: CreateDepartmentRequest): CreateDepartmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDepartmentWithOptions(request, runtime);
}

model CreateDetectProcessRequest {
  content?: string(name='Content'),
  draft?: string(name='Draft'),
  name?: string(name='Name'),
  type?: string(name='Type'),
}

model CreateDetectProcessResponseBody = {
  code?: string(name='Code'),
  data?: {
    content?: string(name='Content'),
    createdAt?: string(name='CreatedAt'),
    disabled?: boolean(name='Disabled'),
    draft?: string(name='Draft'),
    id?: string(name='Id'),
    md5?: string(name='Md5'),
    name?: string(name='Name'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateDetectProcessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDetectProcessResponseBody(name='body'),
}

async function createDetectProcessWithOptions(request: CreateDetectProcessRequest, runtime: Util.RuntimeOptions): CreateDetectProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.draft)) {
    query['Draft'] = request.draft;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDetectProcess',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDetectProcess(request: CreateDetectProcessRequest): CreateDetectProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDetectProcessWithOptions(request, runtime);
}

model CreateRuleRequest {
  clientToken?: string(name='ClientToken'),
  content?: string(name='Content'),
  name?: string(name='Name'),
}

model CreateRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    content?: string(name='Content'),
    id?: string(name='Id'),
    name?: string(name='Name'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRuleResponseBody(name='body'),
}

async function createRuleWithOptions(request: CreateRuleRequest, runtime: Util.RuntimeOptions): CreateRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRule',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRule(request: CreateRuleRequest): CreateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRuleWithOptions(request, runtime);
}

model CreateSignatureRequest {
  appId?: string(name='AppId'),
  clientBaseParam?: string(name='ClientBaseParam'),
  clientVersion?: string(name='ClientVersion'),
  expireTime?: long(name='ExpireTime'),
  uid?: string(name='Uid'),
}

model CreateSignatureResponseBody = {
  code?: string(name='Code'),
  data?: {
    expireTime?: string(name='ExpireTime'),
    rtcAppId?: string(name='RtcAppId'),
    rtcBizName?: string(name='RtcBizName'),
    rtcSign?: string(name='RtcSign'),
    rtcWorkspaceId?: string(name='RtcWorkspaceId'),
  }(name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSignatureResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSignatureResponseBody(name='body'),
}

async function createSignatureWithOptions(request: CreateSignatureRequest, runtime: Util.RuntimeOptions): CreateSignatureResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clientBaseParam)) {
    query['ClientBaseParam'] = request.clientBaseParam;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.expireTime)) {
    query['ExpireTime'] = request.expireTime;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSignature',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSignature(request: CreateSignatureRequest): CreateSignatureResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSignatureWithOptions(request, runtime);
}

model CreateTaskGroupRequest {
  appId?: string(name='AppId'),
  clientToken?: string(name='ClientToken'),
  day?: [ int32 ](name='Day'),
  expireAt?: string(name='ExpireAt'),
  groupName?: string(name='GroupName'),
  ruleId?: string(name='RuleId'),
  runnableTimeFrom?: string(name='RunnableTimeFrom'),
  runnableTimeTo?: string(name='RunnableTimeTo'),
  triggerPeriod?: string(name='TriggerPeriod'),
  videoInfo?: [ 
    {
      ruleId?: string(name='RuleId'),
      videoMetaUrl?: string(name='VideoMetaUrl'),
      videoUrl?: string(name='VideoUrl'),
    }
  ](name='VideoInfo'),
}

model CreateTaskGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    completedTasks?: int32(name='CompletedTasks'),
    createdAt?: string(name='CreatedAt'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    ruleId?: string(name='RuleId'),
    ruleName?: string(name='RuleName'),
    status?: string(name='Status'),
    taskIds?: [ string ](name='TaskIds'),
    totalTasks?: int32(name='TotalTasks'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateTaskGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTaskGroupResponseBody(name='body'),
}

async function createTaskGroupWithOptions(request: CreateTaskGroupRequest, runtime: Util.RuntimeOptions): CreateTaskGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.day)) {
    query['Day'] = request.day;
  }
  if (!Util.isUnset(request.expireAt)) {
    query['ExpireAt'] = request.expireAt;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.runnableTimeFrom)) {
    query['RunnableTimeFrom'] = request.runnableTimeFrom;
  }
  if (!Util.isUnset(request.runnableTimeTo)) {
    query['RunnableTimeTo'] = request.runnableTimeTo;
  }
  if (!Util.isUnset(request.triggerPeriod)) {
    query['TriggerPeriod'] = request.triggerPeriod;
  }
  if (!Util.isUnset(request.videoInfo)) {
    query['VideoInfo'] = request.videoInfo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTaskGroup',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTaskGroup(request: CreateTaskGroupRequest): CreateTaskGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTaskGroupWithOptions(request, runtime);
}

model CreateTtsQuestionRequest {
  request?: {
    answer?: string(name='Answer'),
    question?: string(name='Question'),
    questionGroupId?: string(name='QuestionGroupId'),
  }(name='Request'),
}

model CreateTtsQuestionShrinkRequest {
  requestShrink?: string(name='Request'),
}

model CreateTtsQuestionResponseBody = {
  code?: int32(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateTtsQuestionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTtsQuestionResponseBody(name='body'),
}

async function createTtsQuestionWithOptions(tmpReq: CreateTtsQuestionRequest, runtime: Util.RuntimeOptions): CreateTtsQuestionResponse {
  Util.validateModel(tmpReq);
  var request = new CreateTtsQuestionShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.request)) {
    request.requestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.request, 'Request', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.requestShrink)) {
    body['Request'] = request.requestShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTtsQuestion',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTtsQuestion(request: CreateTtsQuestionRequest): CreateTtsQuestionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTtsQuestionWithOptions(request, runtime);
}

model CreateTtsQuestionGroupRequest {
  request?: {
    format?: string(name='Format'),
    pitchRate?: int32(name='PitchRate'),
    sampleRate?: int32(name='SampleRate'),
    speechRate?: int32(name='SpeechRate'),
    voice?: string(name='Voice'),
    volume?: int32(name='Volume'),
  }(name='Request'),
}

model CreateTtsQuestionGroupShrinkRequest {
  requestShrink?: string(name='Request'),
}

model CreateTtsQuestionGroupResponseBody = {
  code?: int32(name='Code'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateTtsQuestionGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTtsQuestionGroupResponseBody(name='body'),
}

async function createTtsQuestionGroupWithOptions(tmpReq: CreateTtsQuestionGroupRequest, runtime: Util.RuntimeOptions): CreateTtsQuestionGroupResponse {
  Util.validateModel(tmpReq);
  var request = new CreateTtsQuestionGroupShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.request)) {
    request.requestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.request, 'Request', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.requestShrink)) {
    body['Request'] = request.requestShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTtsQuestionGroup',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTtsQuestionGroup(request: CreateTtsQuestionGroupRequest): CreateTtsQuestionGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTtsQuestionGroupWithOptions(request, runtime);
}

model CreateUserDepartmentsRequest {
  clientToken?: string(name='ClientToken'),
  departmentId?: [ string ](name='DepartmentId'),
  userId?: [ string ](name='UserId'),
}

model CreateUserDepartmentsResponseBody = {
  code?: string(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateUserDepartmentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUserDepartmentsResponseBody(name='body'),
}

async function createUserDepartmentsWithOptions(request: CreateUserDepartmentsRequest, runtime: Util.RuntimeOptions): CreateUserDepartmentsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.departmentId)) {
    query['DepartmentId'] = request.departmentId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUserDepartments',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUserDepartments(request: CreateUserDepartmentsRequest): CreateUserDepartmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserDepartmentsWithOptions(request, runtime);
}

model CreateVideoMergeTaskRequest {
  videoMergeRequest?: {
    callbackUrl?: string(name='CallbackUrl'),
    layoutStyles?: [ 
      {
        height?: long(name='Height'),
        inputNum?: long(name='InputNum'),
        videoStyles?: [ 
          {
            fileName?: string(name='FileName'),
            height?: long(name='Height'),
            positionX?: long(name='PositionX'),
            positionY?: long(name='PositionY'),
            width?: long(name='Width'),
          }
        ](name='VideoStyles'),
        width?: long(name='Width'),
      }
    ](name='LayoutStyles'),
    videoList?: [ 
      {
        endTime?: long(name='EndTime'),
        fileName?: string(name='FileName'),
        fileUrl?: string(name='FileUrl'),
        mergeBeginTime?: long(name='MergeBeginTime'),
        mergeEndTime?: long(name='MergeEndTime'),
        primeVideo?: boolean(name='PrimeVideo'),
        startTime?: long(name='StartTime'),
      }
    ](name='VideoList'),
    watermark?: {
      fontColor?: string(name='FontColor'),
      fontSize?: long(name='FontSize'),
      positionX?: long(name='PositionX'),
      positionY?: long(name='PositionY'),
      text?: string(name='Text'),
      timestamp?: long(name='Timestamp'),
    }(name='Watermark'),
  }(name='VideoMergeRequest'),
}

model CreateVideoMergeTaskShrinkRequest {
  videoMergeRequestShrink?: string(name='VideoMergeRequest'),
}

model CreateVideoMergeTaskResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  status?: boolean(name='Status'),
}

model CreateVideoMergeTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVideoMergeTaskResponseBody(name='body'),
}

async function createVideoMergeTaskWithOptions(tmpReq: CreateVideoMergeTaskRequest, runtime: Util.RuntimeOptions): CreateVideoMergeTaskResponse {
  Util.validateModel(tmpReq);
  var request = new CreateVideoMergeTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.videoMergeRequest)) {
    request.videoMergeRequestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.videoMergeRequest, 'VideoMergeRequest', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.videoMergeRequestShrink)) {
    body['VideoMergeRequest'] = request.videoMergeRequestShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVideoMergeTask',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVideoMergeTask(request: CreateVideoMergeTaskRequest): CreateVideoMergeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVideoMergeTaskWithOptions(request, runtime);
}

model CreateWatermarkRequest {
  name?: string(name='Name'),
  value?: string(name='Value'),
}

model CreateWatermarkResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdAt?: string(name='CreatedAt'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    value?: string(name='Value'),
  }(name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateWatermarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateWatermarkResponseBody(name='body'),
}

async function createWatermarkWithOptions(request: CreateWatermarkRequest, runtime: Util.RuntimeOptions): CreateWatermarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateWatermark',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createWatermark(request: CreateWatermarkRequest): CreateWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWatermarkWithOptions(request, runtime);
}

model DeleteAppRequest {
  id?: string(name='Id'),
}

model DeleteAppResponseBody = {
  code?: string(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAppResponseBody(name='body'),
}

async function deleteAppWithOptions(request: DeleteAppRequest, runtime: Util.RuntimeOptions): DeleteAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApp',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteApp(request: DeleteAppRequest): DeleteAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAppWithOptions(request, runtime);
}

model DeleteDepartmentRequest {
  id?: string(name='Id'),
}

model DeleteDepartmentResponseBody = {
  code?: string(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteDepartmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDepartmentResponseBody(name='body'),
}

async function deleteDepartmentWithOptions(request: DeleteDepartmentRequest, runtime: Util.RuntimeOptions): DeleteDepartmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDepartment',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDepartment(request: DeleteDepartmentRequest): DeleteDepartmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDepartmentWithOptions(request, runtime);
}

model DeleteDetectProcessRequest {
  id?: string(name='Id'),
}

model DeleteDetectProcessResponseBody = {
  code?: string(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteDetectProcessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDetectProcessResponseBody(name='body'),
}

async function deleteDetectProcessWithOptions(request: DeleteDetectProcessRequest, runtime: Util.RuntimeOptions): DeleteDetectProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDetectProcess',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDetectProcess(request: DeleteDetectProcessRequest): DeleteDetectProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDetectProcessWithOptions(request, runtime);
}

model DeleteRuleRequest {
  id?: string(name='Id'),
}

model DeleteRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    content?: string(name='Content'),
    createdAt?: string(name='CreatedAt'),
    id?: string(name='Id'),
    name?: string(name='Name'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRuleResponseBody(name='body'),
}

async function deleteRuleWithOptions(request: DeleteRuleRequest, runtime: Util.RuntimeOptions): DeleteRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRule',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRule(request: DeleteRuleRequest): DeleteRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRuleWithOptions(request, runtime);
}

model DeleteUserRequest {
  id?: string(name='Id'),
}

model DeleteUserResponseBody = {
  code?: string(name='Code'),
  data?: map[string]any(name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model DeleteUserDepartmentsRequest {
  departmentId?: [ string ](name='DepartmentId'),
  userId?: [ string ](name='UserId'),
}

model DeleteUserDepartmentsResponseBody = {
  code?: string(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteUserDepartmentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUserDepartmentsResponseBody(name='body'),
}

async function deleteUserDepartmentsWithOptions(request: DeleteUserDepartmentsRequest, runtime: Util.RuntimeOptions): DeleteUserDepartmentsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.departmentId)) {
    query['DepartmentId'] = request.departmentId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUserDepartments',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUserDepartments(request: DeleteUserDepartmentsRequest): DeleteUserDepartmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserDepartmentsWithOptions(request, runtime);
}

model DeleteWatermarkRequest {
  watermarkId?: string(name='WatermarkId'),
}

model DeleteWatermarkResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdAt?: string(name='CreatedAt'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    value?: string(name='Value'),
  }(name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteWatermarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWatermarkResponseBody(name='body'),
}

async function deleteWatermarkWithOptions(request: DeleteWatermarkRequest, runtime: Util.RuntimeOptions): DeleteWatermarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.watermarkId)) {
    query['WatermarkId'] = request.watermarkId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWatermark',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWatermark(request: DeleteWatermarkRequest): DeleteWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWatermarkWithOptions(request, runtime);
}

model FaceCompareRequest {
  faceRequest?: {
    appId?: string(name='AppId'),
    sourceImage?: string(name='SourceImage'),
    targetImage?: string(name='TargetImage'),
  }(name='FaceRequest'),
}

model FaceCompareShrinkRequest {
  faceRequestShrink?: string(name='FaceRequest'),
}

model FaceCompareResponseBody = {
  code?: int32(name='Code'),
  data?: {
    code?: string(name='Code'),
    id?: string(name='Id'),
    message?: string(name='Message'),
    passed?: string(name='Passed'),
    requestId?: string(name='RequestId'),
    status?: string(name='Status'),
    verifyScore?: float(name='VerifyScore'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model FaceCompareResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FaceCompareResponseBody(name='body'),
}

async function faceCompareWithOptions(tmpReq: FaceCompareRequest, runtime: Util.RuntimeOptions): FaceCompareResponse {
  Util.validateModel(tmpReq);
  var request = new FaceCompareShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.faceRequest)) {
    request.faceRequestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.faceRequest, 'FaceRequest', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.faceRequestShrink)) {
    body['FaceRequest'] = request.faceRequestShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FaceCompare',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function faceCompare(request: FaceCompareRequest): FaceCompareResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceCompareWithOptions(request, runtime);
}

model FaceLivenessRequest {
  faceRequest?: {
    appId?: string(name='AppId'),
    sourceImage?: string(name='SourceImage'),
  }(name='FaceRequest'),
}

model FaceLivenessShrinkRequest {
  faceRequestShrink?: string(name='FaceRequest'),
}

model FaceLivenessResponseBody = {
  code?: int32(name='Code'),
  data?: {
    code?: string(name='Code'),
    message?: string(name='Message'),
    passed?: string(name='Passed'),
    publicId?: string(name='PublicId'),
    score?: float(name='Score'),
    status?: string(name='Status'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model FaceLivenessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FaceLivenessResponseBody(name='body'),
}

async function faceLivenessWithOptions(tmpReq: FaceLivenessRequest, runtime: Util.RuntimeOptions): FaceLivenessResponse {
  Util.validateModel(tmpReq);
  var request = new FaceLivenessShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.faceRequest)) {
    request.faceRequestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.faceRequest, 'FaceRequest', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.faceRequestShrink)) {
    body['FaceRequest'] = request.faceRequestShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FaceLiveness',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function faceLiveness(request: FaceLivenessRequest): FaceLivenessResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceLivenessWithOptions(request, runtime);
}

model FaceRecognizeRequest {
  faceRequest?: {
    appId?: string(name='AppId'),
    liveness?: boolean(name='Liveness'),
    sourceImage?: string(name='SourceImage'),
    targetImage?: string(name='TargetImage'),
  }(name='FaceRequest'),
}

model FaceRecognizeShrinkRequest {
  faceRequestShrink?: string(name='FaceRequest'),
}

model FaceRecognizeResponseBody = {
  code?: int32(name='Code'),
  data?: {
    comparePassed?: string(name='ComparePassed'),
    compareScore?: float(name='CompareScore'),
    livenessPassed?: string(name='LivenessPassed'),
    livenessScore?: float(name='LivenessScore'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model FaceRecognizeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FaceRecognizeResponseBody(name='body'),
}

async function faceRecognizeWithOptions(tmpReq: FaceRecognizeRequest, runtime: Util.RuntimeOptions): FaceRecognizeResponse {
  Util.validateModel(tmpReq);
  var request = new FaceRecognizeShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.faceRequest)) {
    request.faceRequestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.faceRequest, 'FaceRequest', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.faceRequestShrink)) {
    body['FaceRequest'] = request.faceRequestShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FaceRecognize',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function faceRecognize(request: FaceRecognizeRequest): FaceRecognizeResponse {
  var runtime = new Util.RuntimeOptions{};
  return faceRecognizeWithOptions(request, runtime);
}

model GetAppRequest {
  clientBaseParam?: string(name='ClientBaseParam'),
  clientVersion?: string(name='ClientVersion'),
  deviceId?: string(name='DeviceId'),
  id?: string(name='Id'),
  packageName?: string(name='PackageName'),
}

model GetAppResponseBody = {
  code?: string(name='Code'),
  data?: {
    config?: string(name='Config'),
    createdAt?: string(name='CreatedAt'),
    disabled?: string(name='Disabled'),
    feeId?: string(name='FeeId'),
    name?: string(name='Name'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppResponseBody(name='body'),
}

async function getAppWithOptions(request: GetAppRequest, runtime: Util.RuntimeOptions): GetAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientBaseParam)) {
    query['ClientBaseParam'] = request.clientBaseParam;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.deviceId)) {
    query['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.packageName)) {
    query['PackageName'] = request.packageName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetApp',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getApp(request: GetAppRequest): GetAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppWithOptions(request, runtime);
}

model GetAsrResultRequest {
  asrTaskId?: string(name='AsrTaskId'),
}

model GetAsrResultResponseBody = {
  code?: int32(name='Code'),
  data?: {
    result?: string(name='Result'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAsrResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAsrResultResponseBody(name='body'),
}

async function getAsrResultWithOptions(request: GetAsrResultRequest, runtime: Util.RuntimeOptions): GetAsrResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.asrTaskId)) {
    query['AsrTaskId'] = request.asrTaskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAsrResult',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAsrResult(request: GetAsrResultRequest): GetAsrResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAsrResultWithOptions(request, runtime);
}

model GetDepartmentRequest {
  clientBaseParam?: string(name='ClientBaseParam'),
  id?: string(name='Id'),
}

model GetDepartmentResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdAt?: string(name='CreatedAt'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    updatedAt?: string(name='UpdatedAt'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetDepartmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDepartmentResponseBody(name='body'),
}

async function getDepartmentWithOptions(request: GetDepartmentRequest, runtime: Util.RuntimeOptions): GetDepartmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientBaseParam)) {
    query['ClientBaseParam'] = request.clientBaseParam;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDepartment',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDepartment(request: GetDepartmentRequest): GetDepartmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDepartmentWithOptions(request, runtime);
}

model GetDetectProcessRequest {
  clientBaseParam?: string(name='ClientBaseParam'),
  id?: string(name='Id'),
}

model GetDetectProcessResponseBody = {
  code?: string(name='Code'),
  data?: {
    content?: string(name='Content'),
    createdAt?: string(name='CreatedAt'),
    draft?: string(name='Draft'),
    id?: string(name='Id'),
    md5?: string(name='Md5'),
    name?: string(name='Name'),
    newVersion?: boolean(name='NewVersion'),
    updatedAt?: string(name='UpdatedAt'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetDetectProcessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDetectProcessResponseBody(name='body'),
}

async function getDetectProcessWithOptions(request: GetDetectProcessRequest, runtime: Util.RuntimeOptions): GetDetectProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientBaseParam)) {
    query['ClientBaseParam'] = request.clientBaseParam;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDetectProcess',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDetectProcess(request: GetDetectProcessRequest): GetDetectProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDetectProcessWithOptions(request, runtime);
}

model GetDetectProcessJsonFileRequest {
  clientBaseParam?: string(name='ClientBaseParam'),
  id?: string(name='Id'),
}

model GetDetectProcessJsonFileResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetDetectProcessJsonFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDetectProcessJsonFileResponseBody(name='body'),
}

async function getDetectProcessJsonFileWithOptions(request: GetDetectProcessJsonFileRequest, runtime: Util.RuntimeOptions): GetDetectProcessJsonFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientBaseParam)) {
    query['ClientBaseParam'] = request.clientBaseParam;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDetectProcessJsonFile',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDetectProcessJsonFile(request: GetDetectProcessJsonFileRequest): GetDetectProcessJsonFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDetectProcessJsonFileWithOptions(request, runtime);
}

model GetDetectionRequest {
  clientBaseParam?: string(name='ClientBaseParam'),
  id?: string(name='Id'),
}

model GetDetectionResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdAt?: string(name='CreatedAt'),
    departmentId?: string(name='DepartmentId'),
    departmentName?: string(name='DepartmentName'),
    id?: string(name='Id'),
    recordingType?: string(name='RecordingType'),
    ruleId?: string(name='RuleId'),
    ruleName?: string(name='RuleName'),
    status?: string(name='Status'),
    tasks?: [ 
      {
        createdAt?: string(name='CreatedAt'),
        id?: string(name='Id'),
        status?: string(name='Status'),
        videoMetaUrl?: string(name='VideoMetaUrl'),
        videoUrl?: string(name='VideoUrl'),
      }
    ](name='Tasks'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetDetectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDetectionResponseBody(name='body'),
}

async function getDetectionWithOptions(request: GetDetectionRequest, runtime: Util.RuntimeOptions): GetDetectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientBaseParam)) {
    query['ClientBaseParam'] = request.clientBaseParam;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDetection',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDetection(request: GetDetectionRequest): GetDetectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDetectionWithOptions(request, runtime);
}

model GetPreSignedUrlRequest {
  clientBaseParam?: string(name='ClientBaseParam'),
  clientVersion?: string(name='ClientVersion'),
  prefix?: string(name='Prefix'),
}

model GetPreSignedUrlResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetPreSignedUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPreSignedUrlResponseBody(name='body'),
}

async function getPreSignedUrlWithOptions(request: GetPreSignedUrlRequest, runtime: Util.RuntimeOptions): GetPreSignedUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientBaseParam)) {
    query['ClientBaseParam'] = request.clientBaseParam;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.prefix)) {
    body['Prefix'] = request.prefix;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPreSignedUrl',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPreSignedUrl(request: GetPreSignedUrlRequest): GetPreSignedUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPreSignedUrlWithOptions(request, runtime);
}

model GetRecordResultRequest {
  clientBaseParam?: string(name='ClientBaseParam'),
  recordId?: string(name='RecordId'),
}

model GetRecordResultResponseBody = {
  code?: string(name='Code'),
  data?: {
    appName?: string(name='AppName'),
    createdAt?: string(name='CreatedAt'),
    departmentName?: string(name='DepartmentName'),
    detectProcessName?: string(name='DetectProcessName'),
    duration?: long(name='Duration'),
    id?: string(name='Id'),
    metaUrl?: string(name='MetaUrl'),
    outerBusinessId?: string(name='OuterBusinessId'),
    recordAt?: string(name='RecordAt'),
    recordRoomList?: [ 
      {
        outerBusinessId?: string(name='OuterBusinessId'),
        recordType?: string(name='RecordType'),
        role?: string(name='Role'),
        roomMetaUrl?: string(name='RoomMetaUrl'),
        roomRecordAt?: string(name='RoomRecordAt'),
        roomResultUrl?: string(name='RoomResultUrl'),
        roomStatus?: string(name='RoomStatus'),
        roomVideoUrl?: string(name='RoomVideoUrl'),
        rtcRecordId?: string(name='RtcRecordId'),
      }
    ](name='RecordRoomList'),
    resultUrl?: string(name='ResultUrl'),
    roomId?: string(name='RoomId'),
    status?: string(name='Status'),
    videoUrl?: string(name='VideoUrl'),
  }(name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetRecordResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRecordResultResponseBody(name='body'),
}

async function getRecordResultWithOptions(request: GetRecordResultRequest, runtime: Util.RuntimeOptions): GetRecordResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientBaseParam)) {
    query['ClientBaseParam'] = request.clientBaseParam;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRecordResult',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRecordResult(request: GetRecordResultRequest): GetRecordResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRecordResultWithOptions(request, runtime);
}

model GetRecordsByFeeIdRequest {
  feeId?: string(name='FeeId'),
}

model GetRecordsByFeeIdResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      appName?: string(name='AppName'),
      createdAt?: string(name='CreatedAt'),
      departmentName?: string(name='DepartmentName'),
      detectProcessName?: string(name='DetectProcessName'),
      duration?: long(name='Duration'),
      id?: string(name='Id'),
      metaUrl?: string(name='MetaUrl'),
      outerBusinessId?: string(name='OuterBusinessId'),
      recordAt?: string(name='RecordAt'),
      recordRoomList?: [ 
        {
          outerBusinessId?: string(name='OuterBusinessId'),
          recordType?: string(name='RecordType'),
          role?: string(name='Role'),
          roomMetaUrl?: string(name='RoomMetaUrl'),
          roomRecordAt?: string(name='RoomRecordAt'),
          roomResultUrl?: string(name='RoomResultUrl'),
          roomStatus?: string(name='RoomStatus'),
          roomVideoUrl?: string(name='RoomVideoUrl'),
          rtcRecordId?: string(name='RtcRecordId'),
        }
      ](name='RecordRoomList'),
      resultUrl?: string(name='ResultUrl'),
      roomId?: string(name='RoomId'),
      status?: string(name='Status'),
      videoUrl?: string(name='VideoUrl'),
    }
  ](name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetRecordsByFeeIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRecordsByFeeIdResponseBody(name='body'),
}

async function getRecordsByFeeIdWithOptions(request: GetRecordsByFeeIdRequest, runtime: Util.RuntimeOptions): GetRecordsByFeeIdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.feeId)) {
    body['FeeId'] = request.feeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetRecordsByFeeId',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRecordsByFeeId(request: GetRecordsByFeeIdRequest): GetRecordsByFeeIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRecordsByFeeIdWithOptions(request, runtime);
}

model GetRecordsByOuterBusinessIdRequest {
  outerBusinessId?: string(name='OuterBusinessId'),
}

model GetRecordsByOuterBusinessIdResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      appName?: string(name='AppName'),
      createdAt?: string(name='CreatedAt'),
      departmentName?: string(name='DepartmentName'),
      detectProcessName?: string(name='DetectProcessName'),
      duration?: long(name='Duration'),
      id?: string(name='Id'),
      metaUrl?: string(name='MetaUrl'),
      outerBusinessId?: string(name='OuterBusinessId'),
      recordAt?: string(name='RecordAt'),
      recordRoomList?: [ 
        {
          outerBusinessId?: string(name='OuterBusinessId'),
          recordType?: string(name='RecordType'),
          role?: string(name='Role'),
          roomMetaUrl?: string(name='RoomMetaUrl'),
          roomRecordAt?: string(name='RoomRecordAt'),
          roomResultUrl?: string(name='RoomResultUrl'),
          roomStatus?: string(name='RoomStatus'),
          roomVideoUrl?: string(name='RoomVideoUrl'),
          rtcRecordId?: string(name='RtcRecordId'),
        }
      ](name='RecordRoomList'),
      resultUrl?: string(name='ResultUrl'),
      roomId?: string(name='RoomId'),
      status?: string(name='Status'),
      videoUrl?: string(name='VideoUrl'),
    }
  ](name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetRecordsByOuterBusinessIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRecordsByOuterBusinessIdResponseBody(name='body'),
}

async function getRecordsByOuterBusinessIdWithOptions(request: GetRecordsByOuterBusinessIdRequest, runtime: Util.RuntimeOptions): GetRecordsByOuterBusinessIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.outerBusinessId)) {
    query['OuterBusinessId'] = request.outerBusinessId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRecordsByOuterBusinessId',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRecordsByOuterBusinessId(request: GetRecordsByOuterBusinessIdRequest): GetRecordsByOuterBusinessIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRecordsByOuterBusinessIdWithOptions(request, runtime);
}

model GetRuleRequest {
  clientBaseParam?: string(name='ClientBaseParam'),
  id?: string(name='Id'),
}

model GetRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    content?: string(name='Content'),
    createdAt?: string(name='CreatedAt'),
    id?: string(name='Id'),
    name?: string(name='Name'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRuleResponseBody(name='body'),
}

async function getRuleWithOptions(request: GetRuleRequest, runtime: Util.RuntimeOptions): GetRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientBaseParam)) {
    query['ClientBaseParam'] = request.clientBaseParam;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRule',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRule(request: GetRuleRequest): GetRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRuleWithOptions(request, runtime);
}

model GetStatisticsRecordsByFeeIdRequest {
  feeId?: string(name='FeeId'),
}

model GetStatisticsRecordsByFeeIdResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      appId?: long(name='AppId'),
      beginAt?: string(name='BeginAt'),
      chargeDuration?: int32(name='ChargeDuration'),
      createdAt?: string(name='CreatedAt'),
      departmentId?: long(name='DepartmentId'),
      detectionDuration?: int32(name='DetectionDuration'),
      deviceId?: string(name='DeviceId'),
      deviceType?: int32(name='DeviceType'),
      endAt?: string(name='EndAt'),
      feeId?: string(name='FeeId'),
      hour?: int32(name='Hour'),
      tenantId?: long(name='TenantId'),
      type?: string(name='Type'),
      updatedAt?: string(name='UpdatedAt'),
    }
  ](name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetStatisticsRecordsByFeeIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStatisticsRecordsByFeeIdResponseBody(name='body'),
}

async function getStatisticsRecordsByFeeIdWithOptions(request: GetStatisticsRecordsByFeeIdRequest, runtime: Util.RuntimeOptions): GetStatisticsRecordsByFeeIdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.feeId)) {
    body['FeeId'] = request.feeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetStatisticsRecordsByFeeId',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStatisticsRecordsByFeeId(request: GetStatisticsRecordsByFeeIdRequest): GetStatisticsRecordsByFeeIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStatisticsRecordsByFeeIdWithOptions(request, runtime);
}

model GetTaskRequest {
  clientBaseParam?: string(name='ClientBaseParam'),
  taskId?: string(name='TaskId'),
}

model GetTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdAt?: string(name='CreatedAt'),
    id?: string(name='Id'),
    status?: string(name='Status'),
    videoUrl?: string(name='VideoUrl'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskResponseBody(name='body'),
}

async function getTaskWithOptions(request: GetTaskRequest, runtime: Util.RuntimeOptions): GetTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientBaseParam)) {
    query['ClientBaseParam'] = request.clientBaseParam;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTask',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTask(request: GetTaskRequest): GetTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskWithOptions(request, runtime);
}

model GetTaskGroupRequest {
  clientBaseParam?: string(name='ClientBaseParam'),
  id?: string(name='Id'),
}

model GetTaskGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    completedTasks?: int32(name='CompletedTasks'),
    createdAt?: string(name='CreatedAt'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    ruleId?: string(name='RuleId'),
    ruleName?: string(name='RuleName'),
    status?: string(name='Status'),
    taskIds?: [ string ](name='TaskIds'),
    totalTasks?: int32(name='TotalTasks'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetTaskGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskGroupResponseBody(name='body'),
}

async function getTaskGroupWithOptions(request: GetTaskGroupRequest, runtime: Util.RuntimeOptions): GetTaskGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientBaseParam)) {
    query['ClientBaseParam'] = request.clientBaseParam;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskGroup',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTaskGroup(request: GetTaskGroupRequest): GetTaskGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskGroupWithOptions(request, runtime);
}

model GetTtsQuestionByGroupIdRequest {
  groupId?: string(name='GroupId'),
}

model GetTtsQuestionByGroupIdResponseBody = {
  code?: int32(name='Code'),
  data?: {
    groupId?: string(name='GroupId'),
    questions?: [ 
      {
        answer?: string(name='Answer'),
        duration?: double(name='Duration'),
        id?: long(name='Id'),
        ossUrl?: string(name='OssUrl'),
        question?: string(name='Question'),
        questionGroupId?: long(name='QuestionGroupId'),
        questionKey?: string(name='QuestionKey'),
        tenantId?: long(name='TenantId'),
      }
    ](name='Questions'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTtsQuestionByGroupIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTtsQuestionByGroupIdResponseBody(name='body'),
}

async function getTtsQuestionByGroupIdWithOptions(request: GetTtsQuestionByGroupIdRequest, runtime: Util.RuntimeOptions): GetTtsQuestionByGroupIdResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetTtsQuestionByGroupId',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTtsQuestionByGroupId(request: GetTtsQuestionByGroupIdRequest): GetTtsQuestionByGroupIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTtsQuestionByGroupIdWithOptions(request, runtime);
}

model GetUserRequest {
  clientBaseParam?: string(name='ClientBaseParam'),
  id?: string(name='Id'),
}

model GetUserResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdAt?: string(name='CreatedAt'),
    departments?: [ 
      {
        description?: string(name='Description'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: string(name='Id'),
        name?: string(name='Name'),
      }
    ](name='Departments'),
    email?: string(name='Email'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    phoneNumber?: string(name='PhoneNumber'),
    role?: string(name='Role'),
    source?: string(name='Source'),
    updatedAt?: string(name='UpdatedAt'),
    username?: string(name='Username'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserResponseBody(name='body'),
}

async function getUserWithOptions(request: GetUserRequest, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientBaseParam)) {
    query['ClientBaseParam'] = request.clientBaseParam;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUser',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserWithOptions(request, runtime);
}

model GetVideoMergeTaskRequest {
  taskId?: string(name='TaskId'),
}

model GetVideoMergeTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    clientTraceId?: string(name='ClientTraceId'),
    duration?: float(name='Duration'),
    height?: int32(name='Height'),
    mergeFileId?: string(name='MergeFileId'),
    taskId?: string(name='TaskId'),
    width?: int32(name='Width'),
  }(name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetVideoMergeTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVideoMergeTaskResponseBody(name='body'),
}

async function getVideoMergeTaskWithOptions(request: GetVideoMergeTaskRequest, runtime: Util.RuntimeOptions): GetVideoMergeTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetVideoMergeTask',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVideoMergeTask(request: GetVideoMergeTaskRequest): GetVideoMergeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoMergeTaskWithOptions(request, runtime);
}

model GetWatermarkRequest {
  clientBaseParam?: string(name='ClientBaseParam'),
  clientVersion?: string(name='ClientVersion'),
  watermarkId?: string(name='WatermarkId'),
}

model GetWatermarkResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdAt?: string(name='CreatedAt'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    value?: string(name='Value'),
  }(name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetWatermarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWatermarkResponseBody(name='body'),
}

async function getWatermarkWithOptions(request: GetWatermarkRequest, runtime: Util.RuntimeOptions): GetWatermarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientBaseParam)) {
    query['ClientBaseParam'] = request.clientBaseParam;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.watermarkId)) {
    query['WatermarkId'] = request.watermarkId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWatermark',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWatermark(request: GetWatermarkRequest): GetWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWatermarkWithOptions(request, runtime);
}

model JoinRoomRequest {
  appId?: string(name='AppId'),
  roomId?: string(name='RoomId'),
  roomToken?: string(name='RoomToken'),
  streamId?: string(name='StreamId'),
}

model JoinRoomResponseBody = {
  code?: int32(name='Code'),
  data?: {
    roomId?: string(name='RoomId'),
    streamId?: string(name='StreamId'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model JoinRoomResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: JoinRoomResponseBody(name='body'),
}

async function joinRoomWithOptions(request: JoinRoomRequest, runtime: Util.RuntimeOptions): JoinRoomResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.roomId)) {
    query['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.roomToken)) {
    query['RoomToken'] = request.roomToken;
  }
  if (!Util.isUnset(request.streamId)) {
    query['StreamId'] = request.streamId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'JoinRoom',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function joinRoom(request: JoinRoomRequest): JoinRoomResponse {
  var runtime = new Util.RuntimeOptions{};
  return joinRoomWithOptions(request, runtime);
}

model LeaveRoomRequest {
  roomId?: string(name='RoomId'),
}

model LeaveRoomResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model LeaveRoomResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LeaveRoomResponseBody(name='body'),
}

async function leaveRoomWithOptions(request: LeaveRoomRequest, runtime: Util.RuntimeOptions): LeaveRoomResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.roomId)) {
    query['RoomId'] = request.roomId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'LeaveRoom',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function leaveRoom(request: LeaveRoomRequest): LeaveRoomResponse {
  var runtime = new Util.RuntimeOptions{};
  return leaveRoomWithOptions(request, runtime);
}

model ListAppsRequest {
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
}

model ListAppsResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        createdAt?: string(name='CreatedAt'),
        departmentId?: string(name='DepartmentId'),
        departmentName?: string(name='DepartmentName'),
        disabled?: boolean(name='Disabled'),
        id?: string(name='Id'),
        name?: string(name='Name'),
        packageName?: string(name='PackageName'),
      }
    ](name='Items'),
    totalElements?: long(name='TotalElements'),
    totalPages?: int32(name='TotalPages'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAppsResponseBody(name='body'),
}

async function listAppsWithOptions(request: ListAppsRequest, runtime: Util.RuntimeOptions): ListAppsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApps',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listApps(request: ListAppsRequest): ListAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppsWithOptions(request, runtime);
}

model ListDepartmentsRequest {
  name?: string(name='Name'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  userId?: string(name='UserId'),
}

model ListDepartmentsResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        administrators?: [ 
          {
            id?: string(name='Id'),
            name?: string(name='Name'),
          }
        ](name='Administrators'),
        createdAt?: string(name='CreatedAt'),
        description?: string(name='Description'),
        id?: string(name='Id'),
        name?: string(name='Name'),
        updatedAt?: string(name='UpdatedAt'),
      }
    ](name='Items'),
    totalElements?: long(name='TotalElements'),
    totalPages?: int32(name='TotalPages'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListDepartmentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDepartmentsResponseBody(name='body'),
}

async function listDepartmentsWithOptions(request: ListDepartmentsRequest, runtime: Util.RuntimeOptions): ListDepartmentsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDepartments',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDepartments(request: ListDepartmentsRequest): ListDepartmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDepartmentsWithOptions(request, runtime);
}

model ListDetectProcessesRequest {
  name?: string(name='Name'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  publishStatus?: boolean(name='PublishStatus'),
  sort?: string(name='Sort'),
  sortKey?: string(name='SortKey'),
  type?: string(name='Type'),
}

model ListDetectProcessesResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        content?: string(name='Content'),
        contentAt?: string(name='ContentAt'),
        createdAt?: string(name='CreatedAt'),
        draft?: string(name='Draft'),
        draftAt?: string(name='DraftAt'),
        fileUrl?: string(name='FileUrl'),
        id?: string(name='Id'),
        md5?: string(name='Md5'),
        name?: string(name='Name'),
        newVersion?: boolean(name='NewVersion'),
        published?: boolean(name='Published'),
        type?: string(name='Type'),
        updatedAt?: string(name='UpdatedAt'),
      }
    ](name='Items'),
    totalElements?: long(name='TotalElements'),
    totalPages?: int32(name='TotalPages'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListDetectProcessesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDetectProcessesResponseBody(name='body'),
}

async function listDetectProcessesWithOptions(request: ListDetectProcessesRequest, runtime: Util.RuntimeOptions): ListDetectProcessesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.publishStatus)) {
    query['PublishStatus'] = request.publishStatus;
  }
  if (!Util.isUnset(request.sort)) {
    query['Sort'] = request.sort;
  }
  if (!Util.isUnset(request.sortKey)) {
    query['SortKey'] = request.sortKey;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDetectProcesses',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDetectProcesses(request: ListDetectProcessesRequest): ListDetectProcessesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDetectProcessesWithOptions(request, runtime);
}

model ListDetectionsRequest {
  createDateFrom?: string(name='CreateDateFrom'),
  createDateTo?: string(name='CreateDateTo'),
  departmentId?: string(name='DepartmentId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  recordingType?: string(name='RecordingType'),
  ruleId?: string(name='RuleId'),
}

model ListDetectionsResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        createdAt?: string(name='CreatedAt'),
        departmentId?: string(name='DepartmentId'),
        departmentName?: string(name='DepartmentName'),
        id?: string(name='Id'),
        recordingType?: string(name='RecordingType'),
        ruleId?: string(name='RuleId'),
        ruleName?: string(name='RuleName'),
        status?: string(name='Status'),
        tasks?: [ 
          {
            createdAt?: string(name='CreatedAt'),
            id?: string(name='Id'),
            status?: string(name='Status'),
            videoMetaUrl?: string(name='VideoMetaUrl'),
            videoUrl?: string(name='VideoUrl'),
          }
        ](name='Tasks'),
      }
    ](name='Items'),
    totalElements?: long(name='TotalElements'),
    totalPages?: int32(name='TotalPages'),
  }(name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListDetectionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDetectionsResponseBody(name='body'),
}

async function listDetectionsWithOptions(request: ListDetectionsRequest, runtime: Util.RuntimeOptions): ListDetectionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createDateFrom)) {
    query['CreateDateFrom'] = request.createDateFrom;
  }
  if (!Util.isUnset(request.createDateTo)) {
    query['CreateDateTo'] = request.createDateTo;
  }
  if (!Util.isUnset(request.departmentId)) {
    query['DepartmentId'] = request.departmentId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.recordingType)) {
    query['RecordingType'] = request.recordingType;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDetections',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDetections(request: ListDetectionsRequest): ListDetectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDetectionsWithOptions(request, runtime);
}

model ListFilesRequest {
  limit?: int32(name='Limit'),
  prefix?: string(name='Prefix'),
}

model ListFilesResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFilesResponseBody(name='body'),
}

async function listFilesWithOptions(request: ListFilesRequest, runtime: Util.RuntimeOptions): ListFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.prefix)) {
    query['Prefix'] = request.prefix;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFiles',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFiles(request: ListFilesRequest): ListFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFilesWithOptions(request, runtime);
}

model ListRecordResultsRequest {
  createDateFrom?: string(name='CreateDateFrom'),
  createDateTo?: string(name='CreateDateTo'),
  departmentId?: string(name='DepartmentId'),
  outerBusinessId?: string(name='OuterBusinessId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  recordId?: string(name='RecordId'),
  type?: string(name='Type'),
}

model ListRecordResultsResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        appName?: string(name='AppName'),
        createdAt?: string(name='CreatedAt'),
        departmentName?: string(name='DepartmentName'),
        detectProcessName?: string(name='DetectProcessName'),
        duration?: long(name='Duration'),
        id?: string(name='Id'),
        metaUrl?: string(name='MetaUrl'),
        outerBusinessId?: string(name='OuterBusinessId'),
        recordAt?: string(name='RecordAt'),
        resultUrl?: string(name='ResultUrl'),
        roomId?: string(name='RoomId'),
        rtcRecordId?: string(name='RtcRecordId'),
        status?: string(name='Status'),
        videoUrl?: string(name='VideoUrl'),
      }
    ](name='Items'),
    totalElements?: long(name='TotalElements'),
    totalPages?: int32(name='TotalPages'),
  }(name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListRecordResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRecordResultsResponseBody(name='body'),
}

async function listRecordResultsWithOptions(request: ListRecordResultsRequest, runtime: Util.RuntimeOptions): ListRecordResultsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createDateFrom)) {
    query['CreateDateFrom'] = request.createDateFrom;
  }
  if (!Util.isUnset(request.createDateTo)) {
    query['CreateDateTo'] = request.createDateTo;
  }
  if (!Util.isUnset(request.departmentId)) {
    query['DepartmentId'] = request.departmentId;
  }
  if (!Util.isUnset(request.outerBusinessId)) {
    query['OuterBusinessId'] = request.outerBusinessId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.recordId)) {
    query['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRecordResults',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRecordResults(request: ListRecordResultsRequest): ListRecordResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRecordResultsWithOptions(request, runtime);
}

model ListRulesRequest {
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
}

model ListRulesResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        content?: string(name='Content'),
        createdAt?: string(name='CreatedAt'),
        id?: string(name='Id'),
        name?: string(name='Name'),
      }
    ](name='Items'),
    totalElements?: long(name='TotalElements'),
    totalPages?: int32(name='TotalPages'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListRulesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRulesResponseBody(name='body'),
}

async function listRulesWithOptions(request: ListRulesRequest, runtime: Util.RuntimeOptions): ListRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRules',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRules(request: ListRulesRequest): ListRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRulesWithOptions(request, runtime);
}

model ListTaskGroupsRequest {
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
}

model ListTaskGroupsResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        completedTasks?: int32(name='CompletedTasks'),
        createdAt?: string(name='CreatedAt'),
        id?: string(name='Id'),
        name?: string(name='Name'),
        ruleId?: string(name='RuleId'),
        ruleName?: string(name='RuleName'),
        status?: string(name='Status'),
        taskIds?: [ string ](name='TaskIds'),
        totalTasks?: int32(name='TotalTasks'),
      }
    ](name='Items'),
    totalElements?: long(name='TotalElements'),
    totalPages?: int32(name='TotalPages'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListTaskGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTaskGroupsResponseBody(name='body'),
}

async function listTaskGroupsWithOptions(request: ListTaskGroupsRequest, runtime: Util.RuntimeOptions): ListTaskGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTaskGroups',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTaskGroups(request: ListTaskGroupsRequest): ListTaskGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTaskGroupsWithOptions(request, runtime);
}

model ListTaskItemsRequest {
  taskId?: string(name='TaskId'),
}

model ListTaskItemsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      createdAt?: string(name='CreatedAt'),
      message?: string(name='Message'),
      name?: string(name='Name'),
      output?: string(name='Output'),
      segmentSeq?: long(name='SegmentSeq'),
      status?: string(name='Status'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListTaskItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTaskItemsResponseBody(name='body'),
}

async function listTaskItemsWithOptions(request: ListTaskItemsRequest, runtime: Util.RuntimeOptions): ListTaskItemsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTaskItems',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTaskItems(request: ListTaskItemsRequest): ListTaskItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTaskItemsWithOptions(request, runtime);
}

model ListTasksRequest {
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  taskGroupId?: string(name='TaskGroupId'),
}

model ListTasksResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        createdAt?: string(name='CreatedAt'),
        id?: string(name='Id'),
        status?: string(name='Status'),
        videoMetaUrl?: string(name='VideoMetaUrl'),
        videoUrl?: string(name='VideoUrl'),
      }
    ](name='Items'),
    totalElements?: long(name='TotalElements'),
    totalPages?: int32(name='TotalPages'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTasksResponseBody(name='body'),
}

async function listTasksWithOptions(request: ListTasksRequest, runtime: Util.RuntimeOptions): ListTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskGroupId)) {
    query['TaskGroupId'] = request.taskGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTasks',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTasks(request: ListTasksRequest): ListTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTasksWithOptions(request, runtime);
}

model ListUsersRequest {
  departmentId?: string(name='DepartmentId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  username?: string(name='Username'),
}

model ListUsersResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        createdAt?: string(name='CreatedAt'),
        departments?: [ 
          {
            createdAt?: string(name='CreatedAt'),
            description?: string(name='Description'),
            id?: string(name='Id'),
            name?: string(name='Name'),
            updatedAt?: string(name='UpdatedAt'),
          }
        ](name='Departments'),
        email?: string(name='Email'),
        id?: string(name='Id'),
        name?: string(name='Name'),
        phoneNumber?: string(name='PhoneNumber'),
        ramUsername?: string(name='RamUsername'),
        role?: string(name='Role'),
        source?: string(name='Source'),
        updatedAt?: string(name='UpdatedAt'),
        username?: string(name='Username'),
      }
    ](name='Items'),
    totalElements?: long(name='TotalElements'),
    totalPages?: int32(name='TotalPages'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.departmentId)) {
    query['DepartmentId'] = request.departmentId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUsers',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model ListWatermarksRequest {
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
}

model ListWatermarksResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        createdAt?: string(name='CreatedAt'),
        id?: string(name='Id'),
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Items'),
    totalElements?: long(name='TotalElements'),
    totalPages?: int32(name='TotalPages'),
  }(name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListWatermarksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWatermarksResponseBody(name='body'),
}

async function listWatermarksWithOptions(request: ListWatermarksRequest, runtime: Util.RuntimeOptions): ListWatermarksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWatermarks',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listWatermarks(request: ListWatermarksRequest): ListWatermarksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWatermarksWithOptions(request, runtime);
}

model RenameDetectProcessRequest {
  id?: string(name='Id'),
  name?: string(name='Name'),
}

model RenameDetectProcessResponseBody = {
  code?: string(name='Code'),
  data?: {
    content?: string(name='Content'),
    createdAt?: string(name='CreatedAt'),
    draft?: string(name='Draft'),
    id?: string(name='Id'),
    md5?: string(name='Md5'),
    name?: string(name='Name'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model RenameDetectProcessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenameDetectProcessResponseBody(name='body'),
}

async function renameDetectProcessWithOptions(request: RenameDetectProcessRequest, runtime: Util.RuntimeOptions): RenameDetectProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenameDetectProcess',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renameDetectProcess(request: RenameDetectProcessRequest): RenameDetectProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return renameDetectProcessWithOptions(request, runtime);
}

model TtsCommonRequest {
  ttsRequest?: {
    appId?: string(name='AppId'),
    format?: string(name='Format'),
    pitchRate?: int32(name='PitchRate'),
    sampleRate?: int32(name='SampleRate'),
    speechRate?: int32(name='SpeechRate'),
    text?: string(name='Text'),
    voice?: string(name='Voice'),
    volume?: int32(name='Volume'),
  }(name='TtsRequest'),
}

model TtsCommonShrinkRequest {
  ttsRequestShrink?: string(name='TtsRequest'),
}

model TtsCommonResponseBody = {
  code?: int32(name='Code'),
  data?: {
    code?: int32(name='Code'),
    id?: string(name='Id'),
    message?: string(name='Message'),
    name?: string(name='Name'),
    publicUrl?: string(name='PublicUrl'),
    taskId?: string(name='TaskId'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model TtsCommonResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TtsCommonResponseBody(name='body'),
}

async function ttsCommonWithOptions(tmpReq: TtsCommonRequest, runtime: Util.RuntimeOptions): TtsCommonResponse {
  Util.validateModel(tmpReq);
  var request = new TtsCommonShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ttsRequest)) {
    request.ttsRequestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ttsRequest, 'TtsRequest', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.ttsRequestShrink)) {
    body['TtsRequest'] = request.ttsRequestShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TtsCommon',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function ttsCommon(request: TtsCommonRequest): TtsCommonResponse {
  var runtime = new Util.RuntimeOptions{};
  return ttsCommonWithOptions(request, runtime);
}

model TtsTaskRequest {
  request?: {
    key?: string(name='Key'),
    roomId?: string(name='RoomId'),
    timestamp?: long(name='Timestamp'),
  }(name='Request'),
}

model TtsTaskShrinkRequest {
  requestShrink?: string(name='Request'),
}

model TtsTaskResponseBody = {
  code?: int32(name='Code'),
  data?: {
    answer?: string(name='Answer'),
    duration?: double(name='Duration'),
    question?: string(name='Question'),
    speechRate?: int32(name='SpeechRate'),
  }(name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model TtsTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TtsTaskResponseBody(name='body'),
}

async function ttsTaskWithOptions(tmpReq: TtsTaskRequest, runtime: Util.RuntimeOptions): TtsTaskResponse {
  Util.validateModel(tmpReq);
  var request = new TtsTaskShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.request)) {
    request.requestShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.request, 'Request', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.requestShrink)) {
    body['Request'] = request.requestShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TtsTask',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function ttsTask(request: TtsTaskRequest): TtsTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return ttsTaskWithOptions(request, runtime);
}

model UpdateAppRequest {
  departmentId?: string(name='DepartmentId'),
  disabled?: boolean(name='Disabled'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  packageName?: string(name='PackageName'),
}

model UpdateAppResponseBody = {
  code?: string(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppResponseBody(name='body'),
}

async function updateAppWithOptions(request: UpdateAppRequest, runtime: Util.RuntimeOptions): UpdateAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.departmentId)) {
    query['DepartmentId'] = request.departmentId;
  }
  if (!Util.isUnset(request.disabled)) {
    query['Disabled'] = request.disabled;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.packageName)) {
    query['PackageName'] = request.packageName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApp',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateApp(request: UpdateAppRequest): UpdateAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppWithOptions(request, runtime);
}

model UpdateDepartmentRequest {
  description?: string(name='Description'),
  id?: string(name='Id'),
  label?: string(name='Label'),
  name?: string(name='Name'),
}

model UpdateDepartmentResponseBody = {
  code?: string(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateDepartmentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDepartmentResponseBody(name='body'),
}

async function updateDepartmentWithOptions(request: UpdateDepartmentRequest, runtime: Util.RuntimeOptions): UpdateDepartmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.label)) {
    body['Label'] = request.label;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDepartment',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDepartment(request: UpdateDepartmentRequest): UpdateDepartmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDepartmentWithOptions(request, runtime);
}

model UpdateDetectProcessRequest {
  content?: string(name='Content'),
  draft?: string(name='Draft'),
  id?: string(name='Id'),
  name?: string(name='Name'),
}

model UpdateDetectProcessResponseBody = {
  code?: string(name='Code'),
  data?: {
    content?: string(name='Content'),
    createdAt?: string(name='CreatedAt'),
    draft?: string(name='Draft'),
    id?: string(name='Id'),
    md5?: string(name='Md5'),
    name?: string(name='Name'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateDetectProcessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDetectProcessResponseBody(name='body'),
}

async function updateDetectProcessWithOptions(request: UpdateDetectProcessRequest, runtime: Util.RuntimeOptions): UpdateDetectProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.draft)) {
    query['Draft'] = request.draft;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDetectProcess',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDetectProcess(request: UpdateDetectProcessRequest): UpdateDetectProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDetectProcessWithOptions(request, runtime);
}

model UpdateRuleRequest {
  content?: string(name='Content'),
  id?: string(name='Id'),
  name?: string(name='Name'),
}

model UpdateRuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    content?: string(name='Content'),
    createdAt?: string(name='CreatedAt'),
    id?: string(name='Id'),
    name?: string(name='Name'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRuleResponseBody(name='body'),
}

async function updateRuleWithOptions(request: UpdateRuleRequest, runtime: Util.RuntimeOptions): UpdateRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRule',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRule(request: UpdateRuleRequest): UpdateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRuleWithOptions(request, runtime);
}

model UpdateUserRequest {
  email?: string(name='Email'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  phoneNumber?: string(name='PhoneNumber'),
  role?: string(name='Role'),
}

model UpdateUserResponseBody = {
  code?: string(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUserWithOptions(request: UpdateUserRequest, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.phoneNumber)) {
    query['PhoneNumber'] = request.phoneNumber;
  }
  if (!Util.isUnset(request.role)) {
    query['Role'] = request.role;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserWithOptions(request, runtime);
}

model UpdateWatermarkRequest {
  name?: string(name='Name'),
  value?: string(name='Value'),
  watermarkId?: string(name='WatermarkId'),
}

model UpdateWatermarkResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdAt?: string(name='CreatedAt'),
    id?: string(name='Id'),
    name?: string(name='Name'),
    value?: string(name='Value'),
  }(name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateWatermarkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateWatermarkResponseBody(name='body'),
}

async function updateWatermarkWithOptions(request: UpdateWatermarkRequest, runtime: Util.RuntimeOptions): UpdateWatermarkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  if (!Util.isUnset(request.watermarkId)) {
    query['WatermarkId'] = request.watermarkId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWatermark',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateWatermark(request: UpdateWatermarkRequest): UpdateWatermarkResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWatermarkWithOptions(request, runtime);
}

model UploadReportRequest {
  appId?: string(name='AppId'),
  clientBaseParam?: string(name='ClientBaseParam'),
  clientVersion?: string(name='ClientVersion'),
  departmentId?: string(name='DepartmentId'),
  detectProcessId?: string(name='DetectProcessId'),
  duration?: long(name='Duration'),
  feeId?: string(name='FeeId'),
  metaUrl?: string(name='MetaUrl'),
  outerBusinessId?: string(name='OuterBusinessId'),
  recordAt?: string(name='RecordAt'),
  resultUrl?: string(name='ResultUrl'),
  roomId?: string(name='RoomId'),
  rtcRecordId?: string(name='RtcRecordId'),
  type?: string(name='Type'),
  userId?: string(name='UserId'),
  videoUrl?: string(name='VideoUrl'),
}

model UploadReportResponseBody = {
  code?: string(name='Code'),
  data?: {
    createdAt?: string(name='CreatedAt'),
    duration?: long(name='Duration'),
    id?: string(name='Id'),
    metaUrl?: string(name='MetaUrl'),
    outerBusinessId?: string(name='OuterBusinessId'),
    recordAt?: string(name='RecordAt'),
    resultUrl?: string(name='ResultUrl'),
    rtcRecordId?: string(name='RtcRecordId'),
    videoUrl?: string(name='VideoUrl'),
  }(name='Data'),
  errors?: [ 
    {
      field?: string(name='Field'),
      message?: string(name='Message'),
    }
  ](name='Errors'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UploadReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadReportResponseBody(name='body'),
}

async function uploadReportWithOptions(request: UploadReportRequest, runtime: Util.RuntimeOptions): UploadReportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clientBaseParam)) {
    query['ClientBaseParam'] = request.clientBaseParam;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.departmentId)) {
    query['DepartmentId'] = request.departmentId;
  }
  if (!Util.isUnset(request.detectProcessId)) {
    query['DetectProcessId'] = request.detectProcessId;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.feeId)) {
    query['FeeId'] = request.feeId;
  }
  if (!Util.isUnset(request.metaUrl)) {
    query['MetaUrl'] = request.metaUrl;
  }
  if (!Util.isUnset(request.outerBusinessId)) {
    query['OuterBusinessId'] = request.outerBusinessId;
  }
  if (!Util.isUnset(request.recordAt)) {
    query['RecordAt'] = request.recordAt;
  }
  if (!Util.isUnset(request.resultUrl)) {
    query['ResultUrl'] = request.resultUrl;
  }
  if (!Util.isUnset(request.roomId)) {
    query['RoomId'] = request.roomId;
  }
  if (!Util.isUnset(request.rtcRecordId)) {
    query['RtcRecordId'] = request.rtcRecordId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.videoUrl)) {
    query['VideoUrl'] = request.videoUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadReport',
    version = '2020-06-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadReport(request: UploadReportRequest): UploadReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadReportWithOptions(request, runtime);
}

