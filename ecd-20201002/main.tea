/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ecd', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ApproveFotaUpdateRequest {
  appVersion?: string(name='AppVersion'),
  clientId?: string(name='ClientId'),
  desktopId?: string(name='DesktopId'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model ApproveFotaUpdateResponseBody = {
  requestId?: string(name='RequestId'),
}

model ApproveFotaUpdateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApproveFotaUpdateResponseBody(name='body'),
}

async function approveFotaUpdateWithOptions(request: ApproveFotaUpdateRequest, runtime: Util.RuntimeOptions): ApproveFotaUpdateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApproveFotaUpdate',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function approveFotaUpdate(request: ApproveFotaUpdateRequest): ApproveFotaUpdateResponse {
  var runtime = new Util.RuntimeOptions{};
  return approveFotaUpdateWithOptions(request, runtime);
}

model ChangePasswordRequest {
  clientId?: string(name='ClientId'),
  endUserId?: string(name='EndUserId'),
  loginToken?: string(name='LoginToken'),
  newPassword?: string(name='NewPassword'),
  officeSiteId?: string(name='OfficeSiteId'),
  oldPassword?: string(name='OldPassword'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model ChangePasswordResponseBody = {
  loginToken?: string(name='LoginToken'),
  requestId?: string(name='RequestId'),
}

model ChangePasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangePasswordResponseBody(name='body'),
}

async function changePasswordWithOptions(request: ChangePasswordRequest, runtime: Util.RuntimeOptions): ChangePasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.newPassword)) {
    query['NewPassword'] = request.newPassword;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.oldPassword)) {
    query['OldPassword'] = request.oldPassword;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangePassword',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changePassword(request: ChangePasswordRequest): ChangePasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return changePasswordWithOptions(request, runtime);
}

model CreateOrUpdateInternetPolicyRequest {
  clientId?: string(name='ClientId'),
  domainList?: string(name='DomainList'),
  loginToken?: string(name='LoginToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  policyName?: string(name='PolicyName'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
  type?: string(name='Type'),
}

model CreateOrUpdateInternetPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateOrUpdateInternetPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrUpdateInternetPolicyResponseBody(name='body'),
}

async function createOrUpdateInternetPolicyWithOptions(request: CreateOrUpdateInternetPolicyRequest, runtime: Util.RuntimeOptions): CreateOrUpdateInternetPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.domainList)) {
    query['DomainList'] = request.domainList;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrUpdateInternetPolicy',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrUpdateInternetPolicy(request: CreateOrUpdateInternetPolicyRequest): CreateOrUpdateInternetPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrUpdateInternetPolicyWithOptions(request, runtime);
}

model DeleteFingerPrintTemplateRequest {
  clientId?: string(name='ClientId'),
  clientToken?: string(name='ClientToken'),
  index?: int32(name='Index'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model DeleteFingerPrintTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFingerPrintTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFingerPrintTemplateResponseBody(name='body'),
}

async function deleteFingerPrintTemplateWithOptions(request: DeleteFingerPrintTemplateRequest, runtime: Util.RuntimeOptions): DeleteFingerPrintTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.index)) {
    query['Index'] = request.index;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFingerPrintTemplate',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFingerPrintTemplate(request: DeleteFingerPrintTemplateRequest): DeleteFingerPrintTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFingerPrintTemplateWithOptions(request, runtime);
}

model DescribeDesktopsRequest {
  clientId?: string(name='ClientId'),
  clientType?: string(name='ClientType'),
  desktopId?: [ string ](name='DesktopId'),
  desktopName?: string(name='DesktopName'),
  desktopStatus?: string(name='DesktopStatus'),
  directoryId?: string(name='DirectoryId'),
  groupId?: string(name='GroupId'),
  html5Access?: string(name='Html5Access'),
  loginToken?: string(name='LoginToken'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  protocolType?: string(name='ProtocolType'),
  queryFotaUpdate?: boolean(name='QueryFotaUpdate'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
  userName?: string(name='UserName'),
}

model DescribeDesktopsResponseBody = {
  desktops?: [ 
    {
      chargeType?: string(name='ChargeType'),
      connectionStatus?: string(name='ConnectionStatus'),
      cpu?: int32(name='Cpu'),
      creationTime?: string(name='CreationTime'),
      dataDiskCategory?: string(name='DataDiskCategory'),
      dataDiskSize?: string(name='DataDiskSize'),
      desktopGroupId?: string(name='DesktopGroupId'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      desktopStatus?: string(name='DesktopStatus'),
      desktopType?: string(name='DesktopType'),
      directoryId?: string(name='DirectoryId'),
      disks?: [ 
        {
          diskId?: string(name='DiskId'),
          diskSize?: int32(name='DiskSize'),
          diskType?: string(name='DiskType'),
        }
      ](name='Disks'),
      endUserIds?: [ string ](name='EndUserIds'),
      expiredTime?: string(name='ExpiredTime'),
      fotaUpdate?: {
        currentAppVersion?: string(name='CurrentAppVersion'),
        newAppVersion?: string(name='NewAppVersion'),
        releaseNote?: string(name='ReleaseNote'),
        size?: long(name='Size'),
      }(name='FotaUpdate'),
      gpuMemory?: int32(name='GpuMemory'),
      imageId?: string(name='ImageId'),
      lastStartTime?: string(name='LastStartTime'),
      managementFlags?: [ string ](name='ManagementFlags'),
      memory?: long(name='Memory'),
      networkInterfaceId?: string(name='NetworkInterfaceId'),
      networkInterfaceIp?: string(name='NetworkInterfaceIp'),
      officeSiteId?: string(name='OfficeSiteId'),
      osType?: string(name='OsType'),
      policyGroupId?: string(name='PolicyGroupId'),
      protocolType?: string(name='ProtocolType'),
      realDesktopId?: string(name='RealDesktopId'),
      sessions?: [ 
        {
          endUserId?: string(name='EndUserId'),
          establishmentTime?: string(name='EstablishmentTime'),
        }
      ](name='Sessions'),
      systemDiskCategory?: string(name='SystemDiskCategory'),
      systemDiskSize?: int32(name='SystemDiskSize'),
      userCustomName?: string(name='UserCustomName'),
    }
  ](name='Desktops'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeDesktopsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDesktopsResponseBody(name='body'),
}

async function describeDesktopsWithOptions(request: DescribeDesktopsRequest, runtime: Util.RuntimeOptions): DescribeDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.desktopName)) {
    query['DesktopName'] = request.desktopName;
  }
  if (!Util.isUnset(request.desktopStatus)) {
    query['DesktopStatus'] = request.desktopStatus;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.html5Access)) {
    query['Html5Access'] = request.html5Access;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.queryFotaUpdate)) {
    query['QueryFotaUpdate'] = request.queryFotaUpdate;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDesktops',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDesktops(request: DescribeDesktopsRequest): DescribeDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDesktopsWithOptions(request, runtime);
}

model DescribeDirectoriesRequest {
  clientId?: string(name='ClientId'),
  directoryId?: [ string ](name='DirectoryId'),
  regionId?: string(name='RegionId'),
}

model DescribeDirectoriesResponseBody = {
  directories?: [ 
    {
      desktopAccessType?: string(name='DesktopAccessType'),
      directoryId?: string(name='DirectoryId'),
      directoryType?: string(name='DirectoryType'),
      providerId?: string(name='ProviderId'),
      ssoServiceUrl?: string(name='SsoServiceUrl'),
    }
  ](name='Directories'),
  requestId?: string(name='RequestId'),
}

model DescribeDirectoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDirectoriesResponseBody(name='body'),
}

async function describeDirectoriesWithOptions(request: DescribeDirectoriesRequest, runtime: Util.RuntimeOptions): DescribeDirectoriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDirectories',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDirectories(request: DescribeDirectoriesRequest): DescribeDirectoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDirectoriesWithOptions(request, runtime);
}

model DescribeDirectoryInternetPolicyRequest {
  clientId?: string(name='ClientId'),
  loginToken?: string(name='LoginToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  policyName?: string(name='PolicyName'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model DescribeDirectoryInternetPolicyResponseBody = {
  data?: {
    domainList?: string(name='DomainList'),
    policyGroupId?: string(name='PolicyGroupId'),
    policyGroupName?: string(name='PolicyGroupName'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeDirectoryInternetPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDirectoryInternetPolicyResponseBody(name='body'),
}

async function describeDirectoryInternetPolicyWithOptions(request: DescribeDirectoryInternetPolicyRequest, runtime: Util.RuntimeOptions): DescribeDirectoryInternetPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDirectoryInternetPolicy',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDirectoryInternetPolicy(request: DescribeDirectoryInternetPolicyRequest): DescribeDirectoryInternetPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDirectoryInternetPolicyWithOptions(request, runtime);
}

model DescribeFingerPrintTemplatesRequest {
  clientId?: string(name='ClientId'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model DescribeFingerPrintTemplatesResponseBody = {
  fingerPrintTemplates?: [ 
    {
      clientId?: string(name='ClientId'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      endUserId?: string(name='EndUserId'),
      index?: long(name='Index'),
      loginTime?: string(name='LoginTime'),
      officeSiteId?: string(name='OfficeSiteId'),
    }
  ](name='FingerPrintTemplates'),
  requestId?: string(name='RequestId'),
}

model DescribeFingerPrintTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFingerPrintTemplatesResponseBody(name='body'),
}

async function describeFingerPrintTemplatesWithOptions(request: DescribeFingerPrintTemplatesRequest, runtime: Util.RuntimeOptions): DescribeFingerPrintTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFingerPrintTemplates',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFingerPrintTemplates(request: DescribeFingerPrintTemplatesRequest): DescribeFingerPrintTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFingerPrintTemplatesWithOptions(request, runtime);
}

model DescribeGlobalDesktopsRequest {
  clientId?: string(name='ClientId'),
  desktopAccessType?: string(name='DesktopAccessType'),
  desktopId?: [ string ](name='DesktopId'),
  desktopName?: string(name='DesktopName'),
  desktopStatus?: string(name='DesktopStatus'),
  directoryId?: string(name='DirectoryId'),
  loginToken?: string(name='LoginToken'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  queryFotaUpdate?: boolean(name='QueryFotaUpdate'),
  regionId?: string(name='RegionId'),
  searchRegionId?: string(name='SearchRegionId'),
  sessionId?: string(name='SessionId'),
}

model DescribeGlobalDesktopsResponseBody = {
  desktops?: [ 
    {
      chargeType?: string(name='ChargeType'),
      connectionStatus?: string(name='ConnectionStatus'),
      cpu?: int32(name='Cpu'),
      creationTime?: string(name='CreationTime'),
      desktopGroupId?: string(name='DesktopGroupId'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      desktopStatus?: string(name='DesktopStatus'),
      desktopType?: string(name='DesktopType'),
      directoryId?: string(name='DirectoryId'),
      disks?: [ 
        {
          diskId?: string(name='DiskId'),
          diskSize?: int32(name='DiskSize'),
          diskType?: string(name='DiskType'),
        }
      ](name='Disks'),
      endUserId?: string(name='EndUserId'),
      endUserIds?: [ string ](name='EndUserIds'),
      expiredTime?: string(name='ExpiredTime'),
      fotaUpdate?: {
        channel?: string(name='Channel'),
        currentAppVersion?: string(name='CurrentAppVersion'),
        force?: boolean(name='Force'),
        newAppVersion?: string(name='NewAppVersion'),
        project?: string(name='Project'),
        releaseNote?: string(name='ReleaseNote'),
        size?: string(name='Size'),
      }(name='FotaUpdate'),
      gpuMemory?: int32(name='GpuMemory'),
      hostName?: string(name='HostName'),
      imageId?: string(name='ImageId'),
      lastStartTime?: string(name='LastStartTime'),
      localName?: string(name='LocalName'),
      managementFlags?: [ string ](name='ManagementFlags'),
      memory?: long(name='Memory'),
      networkInterfaceIp?: string(name='NetworkInterfaceIp'),
      officeSiteId?: string(name='OfficeSiteId'),
      osType?: string(name='OsType'),
      policyGroupId?: string(name='PolicyGroupId'),
      protocolType?: string(name='ProtocolType'),
      realDesktopId?: string(name='RealDesktopId'),
      regionId?: string(name='RegionId'),
      sessions?: [ 
        {
          endUserId?: string(name='EndUserId'),
          establishmentTime?: string(name='EstablishmentTime'),
        }
      ](name='Sessions'),
      userCustomName?: string(name='UserCustomName'),
    }
  ](name='Desktops'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeGlobalDesktopsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGlobalDesktopsResponseBody(name='body'),
}

async function describeGlobalDesktopsWithOptions(request: DescribeGlobalDesktopsRequest, runtime: Util.RuntimeOptions): DescribeGlobalDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.desktopAccessType)) {
    query['DesktopAccessType'] = request.desktopAccessType;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.desktopName)) {
    query['DesktopName'] = request.desktopName;
  }
  if (!Util.isUnset(request.desktopStatus)) {
    query['DesktopStatus'] = request.desktopStatus;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.queryFotaUpdate)) {
    query['QueryFotaUpdate'] = request.queryFotaUpdate;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.searchRegionId)) {
    query['SearchRegionId'] = request.searchRegionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGlobalDesktops',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGlobalDesktops(request: DescribeGlobalDesktopsRequest): DescribeGlobalDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGlobalDesktopsWithOptions(request, runtime);
}

model DescribeOfficeSiteInternetStatusRequest {
  clientId?: string(name='ClientId'),
  loginToken?: string(name='LoginToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model DescribeOfficeSiteInternetStatusResponseBody = {
  data?: string(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeOfficeSiteInternetStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOfficeSiteInternetStatusResponseBody(name='body'),
}

async function describeOfficeSiteInternetStatusWithOptions(request: DescribeOfficeSiteInternetStatusRequest, runtime: Util.RuntimeOptions): DescribeOfficeSiteInternetStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOfficeSiteInternetStatus',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOfficeSiteInternetStatus(request: DescribeOfficeSiteInternetStatusRequest): DescribeOfficeSiteInternetStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOfficeSiteInternetStatusWithOptions(request, runtime);
}

model DescribeOfficeSitesRequest {
  clientId?: string(name='ClientId'),
  officeSiteId?: [ string ](name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model DescribeOfficeSitesResponseBody = {
  officeSites?: [ 
    {
      desktopAccessType?: string(name='DesktopAccessType'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteType?: string(name='OfficeSiteType'),
      providerId?: string(name='ProviderId'),
      ssoServiceUrl?: string(name='SsoServiceUrl'),
    }
  ](name='OfficeSites'),
  requestId?: string(name='RequestId'),
}

model DescribeOfficeSitesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOfficeSitesResponseBody(name='body'),
}

async function describeOfficeSitesWithOptions(request: DescribeOfficeSitesRequest, runtime: Util.RuntimeOptions): DescribeOfficeSitesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOfficeSites',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOfficeSites(request: DescribeOfficeSitesRequest): DescribeOfficeSitesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOfficeSitesWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  clientId?: string(name='ClientId'),
  regionId?: string(name='RegionId'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeSnapshotsRequest {
  clientId?: string(name='ClientId'),
  desktopId?: string(name='DesktopId'),
  loginToken?: string(name='LoginToken'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
  snapshotId?: string(name='SnapshotId'),
}

model DescribeSnapshotsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  snapshots?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      desktopId?: string(name='DesktopId'),
      progress?: string(name='Progress'),
      remainTime?: int32(name='RemainTime'),
      snapshotId?: string(name='SnapshotId'),
      snapshotName?: string(name='SnapshotName'),
      snapshotType?: string(name='SnapshotType'),
      sourceDiskSize?: string(name='SourceDiskSize'),
      sourceDiskType?: string(name='SourceDiskType'),
      status?: string(name='Status'),
    }
  ](name='Snapshots'),
}

model DescribeSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSnapshotsResponseBody(name='body'),
}

async function describeSnapshotsWithOptions(request: DescribeSnapshotsRequest, runtime: Util.RuntimeOptions): DescribeSnapshotsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSnapshots',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSnapshots(request: DescribeSnapshotsRequest): DescribeSnapshotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSnapshotsWithOptions(request, runtime);
}

model EncryptPasswordRequest {
  clientId?: string(name='ClientId'),
  directoryId?: string(name='DirectoryId'),
  loginToken?: string(name='LoginToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  password?: string(name='Password'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model EncryptPasswordResponseBody = {
  encryptedPassword?: string(name='EncryptedPassword'),
  requestId?: string(name='RequestId'),
}

model EncryptPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EncryptPasswordResponseBody(name='body'),
}

async function encryptPasswordWithOptions(request: EncryptPasswordRequest, runtime: Util.RuntimeOptions): EncryptPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EncryptPassword',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function encryptPassword(request: EncryptPasswordRequest): EncryptPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return encryptPasswordWithOptions(request, runtime);
}

model GetCloudDriveServiceMountTokenRequest {
  clientId?: string(name='ClientId'),
  loginToken?: string(name='LoginToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model GetCloudDriveServiceMountTokenResponseBody = {
  requestId?: string(name='RequestId'),
  token?: {
    domainId?: string(name='DomainId'),
    expiredAfter?: string(name='ExpiredAfter'),
    status?: string(name='Status'),
    token?: string(name='Token'),
    totalSize?: long(name='TotalSize'),
    usedSize?: long(name='UsedSize'),
  }(name='Token'),
}

model GetCloudDriveServiceMountTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCloudDriveServiceMountTokenResponseBody(name='body'),
}

async function getCloudDriveServiceMountTokenWithOptions(request: GetCloudDriveServiceMountTokenRequest, runtime: Util.RuntimeOptions): GetCloudDriveServiceMountTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCloudDriveServiceMountToken',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCloudDriveServiceMountToken(request: GetCloudDriveServiceMountTokenRequest): GetCloudDriveServiceMountTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCloudDriveServiceMountTokenWithOptions(request, runtime);
}

model GetLoginTokenRequest {
  authenticationCode?: string(name='AuthenticationCode'),
  clientId?: string(name='ClientId'),
  clientOS?: string(name='ClientOS'),
  clientType?: string(name='ClientType'),
  clientVersion?: string(name='ClientVersion'),
  currentStage?: string(name='CurrentStage'),
  directoryId?: string(name='DirectoryId'),
  endUserId?: string(name='EndUserId'),
  keepAlive?: boolean(name='KeepAlive'),
  keepAliveToken?: string(name='KeepAliveToken'),
  newPassword?: string(name='NewPassword'),
  officeSiteId?: string(name='OfficeSiteId'),
  oldPassword?: string(name='OldPassword'),
  password?: string(name='Password'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
  tokenCode?: string(name='TokenCode'),
  uuid?: string(name='Uuid'),
}

model GetLoginTokenResponseBody = {
  email?: string(name='Email'),
  endUserId?: string(name='EndUserId'),
  industry?: string(name='Industry'),
  keepAliveToken?: string(name='KeepAliveToken'),
  label?: string(name='Label'),
  loginToken?: string(name='LoginToken'),
  nextStage?: string(name='NextStage'),
  phone?: string(name='Phone'),
  props?: map[string]string(name='Props'),
  qrCodePng?: string(name='QrCodePng'),
  requestId?: string(name='RequestId'),
  secret?: string(name='Secret'),
  sessionId?: string(name='SessionId'),
  tenantId?: long(name='TenantId'),
  windowDisplayMode?: string(name='WindowDisplayMode'),
}

model GetLoginTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLoginTokenResponseBody(name='body'),
}

async function getLoginTokenWithOptions(request: GetLoginTokenRequest, runtime: Util.RuntimeOptions): GetLoginTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authenticationCode)) {
    query['AuthenticationCode'] = request.authenticationCode;
  }
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientOS)) {
    query['ClientOS'] = request.clientOS;
  }
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.currentStage)) {
    query['CurrentStage'] = request.currentStage;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.keepAlive)) {
    query['KeepAlive'] = request.keepAlive;
  }
  if (!Util.isUnset(request.keepAliveToken)) {
    query['KeepAliveToken'] = request.keepAliveToken;
  }
  if (!Util.isUnset(request.newPassword)) {
    query['NewPassword'] = request.newPassword;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.oldPassword)) {
    query['OldPassword'] = request.oldPassword;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.tokenCode)) {
    query['TokenCode'] = request.tokenCode;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLoginToken',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLoginToken(request: GetLoginTokenRequest): GetLoginTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLoginTokenWithOptions(request, runtime);
}

model IsKeepAliveRequest {
  clientId?: string(name='ClientId'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model IsKeepAliveResponseBody = {
  isKeepAlive?: boolean(name='IsKeepAlive'),
  officeSiteId?: string(name='OfficeSiteId'),
  requestId?: string(name='RequestId'),
  tenantId?: string(name='TenantId'),
}

model IsKeepAliveResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: IsKeepAliveResponseBody(name='body'),
}

async function isKeepAliveWithOptions(request: IsKeepAliveRequest, runtime: Util.RuntimeOptions): IsKeepAliveResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'IsKeepAlive',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function isKeepAlive(request: IsKeepAliveRequest): IsKeepAliveResponse {
  var runtime = new Util.RuntimeOptions{};
  return isKeepAliveWithOptions(request, runtime);
}

model RebootDesktopsRequest {
  clientId?: string(name='ClientId'),
  clientOS?: string(name='ClientOS'),
  clientToken?: string(name='ClientToken'),
  clientVersion?: string(name='ClientVersion'),
  desktopId?: [ string ](name='DesktopId'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model RebootDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RebootDesktopsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RebootDesktopsResponseBody(name='body'),
}

async function rebootDesktopsWithOptions(request: RebootDesktopsRequest, runtime: Util.RuntimeOptions): RebootDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientOS)) {
    query['ClientOS'] = request.clientOS;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RebootDesktops',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rebootDesktops(request: RebootDesktopsRequest): RebootDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return rebootDesktopsWithOptions(request, runtime);
}

model RefreshLoginTokenRequest {
  clientId?: string(name='ClientId'),
  directoryId?: string(name='DirectoryId'),
  endUserId?: string(name='EndUserId'),
  loginToken?: string(name='LoginToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model RefreshLoginTokenResponseBody = {
  loginToken?: string(name='LoginToken'),
  requestId?: string(name='RequestId'),
}

model RefreshLoginTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefreshLoginTokenResponseBody(name='body'),
}

async function refreshLoginTokenWithOptions(request: RefreshLoginTokenRequest, runtime: Util.RuntimeOptions): RefreshLoginTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshLoginToken',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshLoginToken(request: RefreshLoginTokenRequest): RefreshLoginTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshLoginTokenWithOptions(request, runtime);
}

model ReportSessionStatusRequest {
  endUserId?: string(name='EndUserId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  sessionChangeTime?: long(name='SessionChangeTime'),
  sessionId?: string(name='SessionId'),
  sessionStatus?: string(name='SessionStatus'),
}

model ReportSessionStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReportSessionStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReportSessionStatusResponseBody(name='body'),
}

async function reportSessionStatusWithOptions(request: ReportSessionStatusRequest, runtime: Util.RuntimeOptions): ReportSessionStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionChangeTime)) {
    query['SessionChangeTime'] = request.sessionChangeTime;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.sessionStatus)) {
    query['SessionStatus'] = request.sessionStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReportSessionStatus',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportSessionStatus(request: ReportSessionStatusRequest): ReportSessionStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportSessionStatusWithOptions(request, runtime);
}

model ResetPasswordRequest {
  clientId?: string(name='ClientId'),
  clientToken?: string(name='ClientToken'),
  email?: string(name='Email'),
  endUserId?: string(name='EndUserId'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
  phone?: string(name='phone'),
}

model ResetPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetPasswordResponseBody(name='body'),
}

async function resetPasswordWithOptions(request: ResetPasswordRequest, runtime: Util.RuntimeOptions): ResetPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.phone)) {
    query['phone'] = request.phone;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetPassword',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetPassword(request: ResetPasswordRequest): ResetPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetPasswordWithOptions(request, runtime);
}

model ResetSnapshotRequest {
  clientId?: string(name='ClientId'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
  snapshotId?: string(name='SnapshotId'),
}

model ResetSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetSnapshotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetSnapshotResponseBody(name='body'),
}

async function resetSnapshotWithOptions(request: ResetSnapshotRequest, runtime: Util.RuntimeOptions): ResetSnapshotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetSnapshot',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetSnapshot(request: ResetSnapshotRequest): ResetSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetSnapshotWithOptions(request, runtime);
}

model SendTokenCodeRequest {
  clientId?: string(name='ClientId'),
  clientOS?: string(name='ClientOS'),
  clientVersion?: string(name='ClientVersion'),
  endUserId?: string(name='EndUserId'),
  loginToken?: string(name='LoginToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  sessionId?: string(name='SessionId'),
  tokenCode?: string(name='TokenCode'),
}

model SendTokenCodeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SendTokenCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendTokenCodeResponseBody(name='body'),
}

async function sendTokenCodeWithOptions(request: SendTokenCodeRequest, runtime: Util.RuntimeOptions): SendTokenCodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientOS)) {
    query['ClientOS'] = request.clientOS;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.tokenCode)) {
    query['TokenCode'] = request.tokenCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SendTokenCode',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendTokenCode(request: SendTokenCodeRequest): SendTokenCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendTokenCodeWithOptions(request, runtime);
}

model SetFingerPrintTemplateRequest {
  clientId?: string(name='ClientId'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  encryptedFingerPrintTemplate?: string(name='EncryptedFingerPrintTemplate'),
  encryptedKey?: string(name='EncryptedKey'),
  fingerPrintTemplate?: string(name='FingerPrintTemplate'),
  loginToken?: string(name='LoginToken'),
  password?: string(name='Password'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model SetFingerPrintTemplateResponseBody = {
  encryptedPassword?: string(name='EncryptedPassword'),
  index?: int32(name='Index'),
  requestId?: string(name='RequestId'),
}

model SetFingerPrintTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetFingerPrintTemplateResponseBody(name='body'),
}

async function setFingerPrintTemplateWithOptions(request: SetFingerPrintTemplateRequest, runtime: Util.RuntimeOptions): SetFingerPrintTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.encryptedFingerPrintTemplate)) {
    query['EncryptedFingerPrintTemplate'] = request.encryptedFingerPrintTemplate;
  }
  if (!Util.isUnset(request.encryptedKey)) {
    query['EncryptedKey'] = request.encryptedKey;
  }
  if (!Util.isUnset(request.fingerPrintTemplate)) {
    query['FingerPrintTemplate'] = request.fingerPrintTemplate;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetFingerPrintTemplate',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setFingerPrintTemplate(request: SetFingerPrintTemplateRequest): SetFingerPrintTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return setFingerPrintTemplateWithOptions(request, runtime);
}

model SetFingerPrintTemplateDescriptionRequest {
  clientId?: string(name='ClientId'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  index?: int32(name='Index'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model SetFingerPrintTemplateDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetFingerPrintTemplateDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetFingerPrintTemplateDescriptionResponseBody(name='body'),
}

async function setFingerPrintTemplateDescriptionWithOptions(request: SetFingerPrintTemplateDescriptionRequest, runtime: Util.RuntimeOptions): SetFingerPrintTemplateDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.index)) {
    query['Index'] = request.index;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetFingerPrintTemplateDescription',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setFingerPrintTemplateDescription(request: SetFingerPrintTemplateDescriptionRequest): SetFingerPrintTemplateDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return setFingerPrintTemplateDescriptionWithOptions(request, runtime);
}

model SetOfficeSiteInternetStatusRequest {
  clientId?: string(name='ClientId'),
  loginToken?: string(name='LoginToken'),
  networkStatus?: int32(name='NetworkStatus'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model SetOfficeSiteInternetStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetOfficeSiteInternetStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetOfficeSiteInternetStatusResponseBody(name='body'),
}

async function setOfficeSiteInternetStatusWithOptions(request: SetOfficeSiteInternetStatusRequest, runtime: Util.RuntimeOptions): SetOfficeSiteInternetStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.networkStatus)) {
    query['NetworkStatus'] = request.networkStatus;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetOfficeSiteInternetStatus',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setOfficeSiteInternetStatus(request: SetOfficeSiteInternetStatusRequest): SetOfficeSiteInternetStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setOfficeSiteInternetStatusWithOptions(request, runtime);
}

model SetStudentsDesktopGroupPolicyRequest {
  clientId?: string(name='ClientId'),
  loginToken?: string(name='LoginToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  policyName?: string(name='PolicyName'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model SetStudentsDesktopGroupPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetStudentsDesktopGroupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetStudentsDesktopGroupPolicyResponseBody(name='body'),
}

async function setStudentsDesktopGroupPolicyWithOptions(request: SetStudentsDesktopGroupPolicyRequest, runtime: Util.RuntimeOptions): SetStudentsDesktopGroupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetStudentsDesktopGroupPolicy',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setStudentsDesktopGroupPolicy(request: SetStudentsDesktopGroupPolicyRequest): SetStudentsDesktopGroupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setStudentsDesktopGroupPolicyWithOptions(request, runtime);
}

model StartDesktopsRequest {
  clientId?: string(name='ClientId'),
  clientOS?: string(name='ClientOS'),
  clientToken?: string(name='ClientToken'),
  clientVersion?: string(name='ClientVersion'),
  desktopId?: [ string ](name='DesktopId'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model StartDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartDesktopsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartDesktopsResponseBody(name='body'),
}

async function startDesktopsWithOptions(request: StartDesktopsRequest, runtime: Util.RuntimeOptions): StartDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientOS)) {
    query['ClientOS'] = request.clientOS;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartDesktops',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startDesktops(request: StartDesktopsRequest): StartDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDesktopsWithOptions(request, runtime);
}

model StopDesktopsRequest {
  clientId?: string(name='ClientId'),
  clientOS?: string(name='ClientOS'),
  clientToken?: string(name='ClientToken'),
  clientVersion?: string(name='ClientVersion'),
  desktopId?: [ string ](name='DesktopId'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model StopDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopDesktopsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopDesktopsResponseBody(name='body'),
}

async function stopDesktopsWithOptions(request: StopDesktopsRequest, runtime: Util.RuntimeOptions): StopDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientOS)) {
    query['ClientOS'] = request.clientOS;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopDesktops',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopDesktops(request: StopDesktopsRequest): StopDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopDesktopsWithOptions(request, runtime);
}

model UnbindUserDesktopRequest {
  clientId?: string(name='ClientId'),
  clientType?: string(name='ClientType'),
  force?: boolean(name='Force'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
  userDesktopId?: string(name='UserDesktopId'),
}

model UnbindUserDesktopResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnbindUserDesktopResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindUserDesktopResponseBody(name='body'),
}

async function unbindUserDesktopWithOptions(request: UnbindUserDesktopRequest, runtime: Util.RuntimeOptions): UnbindUserDesktopResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.userDesktopId)) {
    query['UserDesktopId'] = request.userDesktopId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindUserDesktop',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindUserDesktop(request: UnbindUserDesktopRequest): UnbindUserDesktopResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindUserDesktopWithOptions(request, runtime);
}

model VerifyCredentialRequest {
  clientId?: string(name='ClientId'),
  credential?: string(name='Credential'),
  credentialType?: string(name='CredentialType'),
  encryptedKey?: string(name='EncryptedKey'),
  loginToken?: string(name='LoginToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model VerifyCredentialResponseBody = {
  requestId?: string(name='RequestId'),
}

model VerifyCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyCredentialResponseBody(name='body'),
}

async function verifyCredentialWithOptions(request: VerifyCredentialRequest, runtime: Util.RuntimeOptions): VerifyCredentialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.credential)) {
    query['Credential'] = request.credential;
  }
  if (!Util.isUnset(request.credentialType)) {
    query['CredentialType'] = request.credentialType;
  }
  if (!Util.isUnset(request.encryptedKey)) {
    query['EncryptedKey'] = request.encryptedKey;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyCredential',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyCredential(request: VerifyCredentialRequest): VerifyCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyCredentialWithOptions(request, runtime);
}

