/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ecd', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ChangePasswordRequest {
  clientId?: string(name='ClientId'),
  endUserId?: string(name='EndUserId'),
  loginToken?: string(name='LoginToken'),
  newPassword?: string(name='NewPassword'),
  officeSiteId?: string(name='OfficeSiteId'),
  oldPassword?: string(name='OldPassword'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model ChangePasswordResponseBody = {
  loginToken?: string(name='LoginToken'),
  requestId?: string(name='RequestId'),
}

model ChangePasswordResponse = {
  headers: map[string]string(name='headers'),
  body: ChangePasswordResponseBody(name='body'),
}

async function changePasswordWithOptions(request: ChangePasswordRequest, runtime: Util.RuntimeOptions): ChangePasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.newPassword)) {
    query['NewPassword'] = request.newPassword;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.oldPassword)) {
    query['OldPassword'] = request.oldPassword;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangePassword',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changePassword(request: ChangePasswordRequest): ChangePasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return changePasswordWithOptions(request, runtime);
}

model DeleteFingerPrintTemplateRequest {
  clientId?: string(name='ClientId'),
  index?: int32(name='Index'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model DeleteFingerPrintTemplateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFingerPrintTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFingerPrintTemplateResponseBody(name='body'),
}

async function deleteFingerPrintTemplateWithOptions(request: DeleteFingerPrintTemplateRequest, runtime: Util.RuntimeOptions): DeleteFingerPrintTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.index)) {
    query['Index'] = request.index;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFingerPrintTemplate',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFingerPrintTemplate(request: DeleteFingerPrintTemplateRequest): DeleteFingerPrintTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFingerPrintTemplateWithOptions(request, runtime);
}

model DescribeDesktopsRequest {
  clientId?: string(name='ClientId'),
  clientType?: string(name='ClientType'),
  desktopId?: [ string ](name='DesktopId'),
  desktopName?: string(name='DesktopName'),
  desktopStatus?: string(name='DesktopStatus'),
  directoryId?: string(name='DirectoryId'),
  groupId?: string(name='GroupId'),
  html5Access?: string(name='Html5Access'),
  loginToken?: string(name='LoginToken'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  protocolType?: string(name='ProtocolType'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
  userName?: string(name='UserName'),
}

model DescribeDesktopsResponseBody = {
  desktops?: [ 
    {
      chargeType?: string(name='ChargeType'),
      connectionStatus?: string(name='ConnectionStatus'),
      cpu?: int32(name='Cpu'),
      creationTime?: string(name='CreationTime'),
      dataDiskCategory?: string(name='DataDiskCategory'),
      dataDiskSize?: string(name='DataDiskSize'),
      desktopGroupId?: string(name='DesktopGroupId'),
      desktopId?: string(name='DesktopId'),
      desktopName?: string(name='DesktopName'),
      desktopStatus?: string(name='DesktopStatus'),
      desktopType?: string(name='DesktopType'),
      directoryId?: string(name='DirectoryId'),
      disks?: [ 
        {
          diskId?: string(name='DiskId'),
          diskSize?: int32(name='DiskSize'),
          diskType?: string(name='DiskType'),
        }
      ](name='Disks'),
      endUserIds?: [ string ](name='EndUserIds'),
      expiredTime?: string(name='ExpiredTime'),
      gpuCount?: float(name='GpuCount'),
      imageId?: string(name='ImageId'),
      lastStartTime?: string(name='LastStartTime'),
      memory?: long(name='Memory'),
      networkInterfaceId?: string(name='NetworkInterfaceId'),
      officeSiteId?: string(name='OfficeSiteId'),
      osType?: string(name='OsType'),
      policyGroupId?: string(name='PolicyGroupId'),
      protocolType?: string(name='ProtocolType'),
      sessions?: [ 
        {
          endUserId?: string(name='EndUserId'),
          establishmentTime?: string(name='EstablishmentTime'),
        }
      ](name='Sessions'),
      systemDiskCategory?: string(name='SystemDiskCategory'),
      systemDiskSize?: int32(name='SystemDiskSize'),
    }
  ](name='Desktops'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDesktopsResponseBody(name='body'),
}

async function describeDesktopsWithOptions(request: DescribeDesktopsRequest, runtime: Util.RuntimeOptions): DescribeDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.desktopName)) {
    query['DesktopName'] = request.desktopName;
  }
  if (!Util.isUnset(request.desktopStatus)) {
    query['DesktopStatus'] = request.desktopStatus;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.html5Access)) {
    query['Html5Access'] = request.html5Access;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDesktops',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDesktops(request: DescribeDesktopsRequest): DescribeDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDesktopsWithOptions(request, runtime);
}

model DescribeDirectoriesRequest {
  clientId?: string(name='ClientId'),
  directoryId?: [ string ](name='DirectoryId'),
  regionId?: string(name='RegionId'),
}

model DescribeDirectoriesResponseBody = {
  directories?: [ 
    {
      desktopAccessType?: string(name='DesktopAccessType'),
      directoryId?: string(name='DirectoryId'),
      directoryType?: string(name='DirectoryType'),
      providerId?: string(name='ProviderId'),
      ssoServiceUrl?: string(name='SsoServiceUrl'),
    }
  ](name='Directories'),
  requestId?: string(name='RequestId'),
}

model DescribeDirectoriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDirectoriesResponseBody(name='body'),
}

async function describeDirectoriesWithOptions(request: DescribeDirectoriesRequest, runtime: Util.RuntimeOptions): DescribeDirectoriesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDirectories',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDirectories(request: DescribeDirectoriesRequest): DescribeDirectoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDirectoriesWithOptions(request, runtime);
}

model DescribeFingerPrintTemplatesRequest {
  clientId?: string(name='ClientId'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model DescribeFingerPrintTemplatesResponseBody = {
  fingerPrintTemplates?: [ 
    {
      clientId?: string(name='ClientId'),
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      endUserId?: string(name='EndUserId'),
      index?: long(name='Index'),
      loginTime?: string(name='LoginTime'),
      officeSiteId?: string(name='OfficeSiteId'),
    }
  ](name='FingerPrintTemplates'),
  requestId?: string(name='RequestId'),
}

model DescribeFingerPrintTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFingerPrintTemplatesResponseBody(name='body'),
}

async function describeFingerPrintTemplatesWithOptions(request: DescribeFingerPrintTemplatesRequest, runtime: Util.RuntimeOptions): DescribeFingerPrintTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFingerPrintTemplates',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFingerPrintTemplates(request: DescribeFingerPrintTemplatesRequest): DescribeFingerPrintTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFingerPrintTemplatesWithOptions(request, runtime);
}

model DescribeOfficeSitesRequest {
  clientId?: string(name='ClientId'),
  officeSiteId?: [ string ](name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model DescribeOfficeSitesResponseBody = {
  officeSites?: [ 
    {
      desktopAccessType?: string(name='DesktopAccessType'),
      officeSiteId?: string(name='OfficeSiteId'),
      officeSiteType?: string(name='OfficeSiteType'),
      providerId?: string(name='ProviderId'),
      ssoServiceUrl?: string(name='SsoServiceUrl'),
    }
  ](name='OfficeSites'),
  requestId?: string(name='RequestId'),
}

model DescribeOfficeSitesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeOfficeSitesResponseBody(name='body'),
}

async function describeOfficeSitesWithOptions(request: DescribeOfficeSitesRequest, runtime: Util.RuntimeOptions): DescribeOfficeSitesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOfficeSites',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOfficeSites(request: DescribeOfficeSitesRequest): DescribeOfficeSitesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOfficeSitesWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  clientId?: string(name='ClientId'),
  regionId?: string(name='RegionId'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeSnapshotsRequest {
  clientId?: string(name='ClientId'),
  desktopId?: string(name='DesktopId'),
  loginToken?: string(name='LoginToken'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
  snapshotId?: string(name='SnapshotId'),
}

model DescribeSnapshotsResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  snapshots?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      desktopId?: string(name='DesktopId'),
      progress?: string(name='Progress'),
      remainTime?: int32(name='RemainTime'),
      snapshotId?: string(name='SnapshotId'),
      snapshotName?: string(name='SnapshotName'),
      snapshotType?: string(name='SnapshotType'),
      sourceDiskSize?: string(name='SourceDiskSize'),
      sourceDiskType?: string(name='SourceDiskType'),
      status?: string(name='Status'),
    }
  ](name='Snapshots'),
}

model DescribeSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotsResponseBody(name='body'),
}

async function describeSnapshotsWithOptions(request: DescribeSnapshotsRequest, runtime: Util.RuntimeOptions): DescribeSnapshotsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSnapshots',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSnapshots(request: DescribeSnapshotsRequest): DescribeSnapshotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSnapshotsWithOptions(request, runtime);
}

model EncryptPasswordRequest {
  clientId?: string(name='ClientId'),
  directoryId?: string(name='DirectoryId'),
  loginToken?: string(name='LoginToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  password?: string(name='Password'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model EncryptPasswordResponseBody = {
  encryptedPassword?: string(name='EncryptedPassword'),
  requestId?: string(name='RequestId'),
}

model EncryptPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: EncryptPasswordResponseBody(name='body'),
}

async function encryptPasswordWithOptions(request: EncryptPasswordRequest, runtime: Util.RuntimeOptions): EncryptPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EncryptPassword',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function encryptPassword(request: EncryptPasswordRequest): EncryptPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return encryptPasswordWithOptions(request, runtime);
}

model GetConnectionTicketRequest {
  clientId?: string(name='ClientId'),
  clientOS?: string(name='ClientOS'),
  clientType?: string(name='ClientType'),
  clientVersion?: string(name='ClientVersion'),
  desktopId?: string(name='DesktopId'),
  loginToken?: string(name='LoginToken'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sessionId?: string(name='SessionId'),
  taskId?: string(name='TaskId'),
}

model GetConnectionTicketResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  taskStatus?: string(name='TaskStatus'),
  ticket?: string(name='Ticket'),
}

model GetConnectionTicketResponse = {
  headers: map[string]string(name='headers'),
  body: GetConnectionTicketResponseBody(name='body'),
}

async function getConnectionTicketWithOptions(request: GetConnectionTicketRequest, runtime: Util.RuntimeOptions): GetConnectionTicketResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientOS)) {
    query['ClientOS'] = request.clientOS;
  }
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConnectionTicket',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConnectionTicket(request: GetConnectionTicketRequest): GetConnectionTicketResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConnectionTicketWithOptions(request, runtime);
}

model GetLoginTokenRequest {
  authenticationCode?: string(name='AuthenticationCode'),
  clientId?: string(name='ClientId'),
  clientOS?: string(name='ClientOS'),
  clientVersion?: string(name='ClientVersion'),
  currentStage?: string(name='CurrentStage'),
  directoryId?: string(name='DirectoryId'),
  encryptedFingerPrintData?: string(name='EncryptedFingerPrintData'),
  encryptedKey?: string(name='EncryptedKey'),
  encryptedPassword?: string(name='EncryptedPassword'),
  endUserId?: string(name='EndUserId'),
  fingerPrintData?: string(name='FingerPrintData'),
  imageUrl?: string(name='ImageUrl'),
  keepAlive?: boolean(name='KeepAlive'),
  keepAliveToken?: string(name='KeepAliveToken'),
  newPassword?: string(name='NewPassword'),
  officeSiteId?: string(name='OfficeSiteId'),
  oldPassword?: string(name='OldPassword'),
  password?: string(name='Password'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
  ssoSessionToken?: string(name='SsoSessionToken'),
  tokenCode?: string(name='TokenCode'),
  umidToken?: string(name='UmidToken'),
  uuid?: string(name='Uuid'),
}

model GetLoginTokenResponseBody = {
  email?: string(name='Email'),
  endUserId?: string(name='EndUserId'),
  keepAliveToken?: string(name='KeepAliveToken'),
  label?: string(name='Label'),
  loginToken?: string(name='LoginToken'),
  nextStage?: string(name='NextStage'),
  phone?: string(name='Phone'),
  qrCodePng?: string(name='QrCodePng'),
  requestId?: string(name='RequestId'),
  secret?: string(name='Secret'),
  sessionId?: string(name='SessionId'),
  tenantId?: long(name='TenantId'),
}

model GetLoginTokenResponse = {
  headers: map[string]string(name='headers'),
  body: GetLoginTokenResponseBody(name='body'),
}

async function getLoginTokenWithOptions(request: GetLoginTokenRequest, runtime: Util.RuntimeOptions): GetLoginTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authenticationCode)) {
    query['AuthenticationCode'] = request.authenticationCode;
  }
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientOS)) {
    query['ClientOS'] = request.clientOS;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.currentStage)) {
    query['CurrentStage'] = request.currentStage;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.encryptedFingerPrintData)) {
    query['EncryptedFingerPrintData'] = request.encryptedFingerPrintData;
  }
  if (!Util.isUnset(request.encryptedKey)) {
    query['EncryptedKey'] = request.encryptedKey;
  }
  if (!Util.isUnset(request.encryptedPassword)) {
    query['EncryptedPassword'] = request.encryptedPassword;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.fingerPrintData)) {
    query['FingerPrintData'] = request.fingerPrintData;
  }
  if (!Util.isUnset(request.imageUrl)) {
    query['ImageUrl'] = request.imageUrl;
  }
  if (!Util.isUnset(request.keepAlive)) {
    query['KeepAlive'] = request.keepAlive;
  }
  if (!Util.isUnset(request.keepAliveToken)) {
    query['KeepAliveToken'] = request.keepAliveToken;
  }
  if (!Util.isUnset(request.newPassword)) {
    query['NewPassword'] = request.newPassword;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.oldPassword)) {
    query['OldPassword'] = request.oldPassword;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.ssoSessionToken)) {
    query['SsoSessionToken'] = request.ssoSessionToken;
  }
  if (!Util.isUnset(request.tokenCode)) {
    query['TokenCode'] = request.tokenCode;
  }
  if (!Util.isUnset(request.umidToken)) {
    query['UmidToken'] = request.umidToken;
  }
  if (!Util.isUnset(request.uuid)) {
    query['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLoginToken',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLoginToken(request: GetLoginTokenRequest): GetLoginTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLoginTokenWithOptions(request, runtime);
}

model IsKeepAliveRequest {
  clientId?: string(name='ClientId'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
}

model IsKeepAliveResponseBody = {
  isKeepAlive?: boolean(name='IsKeepAlive'),
  officeSiteId?: string(name='OfficeSiteId'),
  requestId?: string(name='RequestId'),
  tenantId?: string(name='TenantId'),
}

model IsKeepAliveResponse = {
  headers: map[string]string(name='headers'),
  body: IsKeepAliveResponseBody(name='body'),
}

async function isKeepAliveWithOptions(request: IsKeepAliveRequest, runtime: Util.RuntimeOptions): IsKeepAliveResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'IsKeepAlive',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function isKeepAlive(request: IsKeepAliveRequest): IsKeepAliveResponse {
  var runtime = new Util.RuntimeOptions{};
  return isKeepAliveWithOptions(request, runtime);
}

model RebootDesktopsRequest {
  clientId?: string(name='ClientId'),
  clientOS?: string(name='ClientOS'),
  clientVersion?: string(name='ClientVersion'),
  desktopId?: [ string ](name='DesktopId'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model RebootDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RebootDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: RebootDesktopsResponseBody(name='body'),
}

async function rebootDesktopsWithOptions(request: RebootDesktopsRequest, runtime: Util.RuntimeOptions): RebootDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientOS)) {
    query['ClientOS'] = request.clientOS;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RebootDesktops',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rebootDesktops(request: RebootDesktopsRequest): RebootDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return rebootDesktopsWithOptions(request, runtime);
}

model RefreshLoginTokenRequest {
  clientId?: string(name='ClientId'),
  directoryId?: string(name='DirectoryId'),
  endUserId?: string(name='EndUserId'),
  loginToken?: string(name='LoginToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model RefreshLoginTokenResponseBody = {
  loginToken?: string(name='LoginToken'),
  requestId?: string(name='RequestId'),
}

model RefreshLoginTokenResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshLoginTokenResponseBody(name='body'),
}

async function refreshLoginTokenWithOptions(request: RefreshLoginTokenRequest, runtime: Util.RuntimeOptions): RefreshLoginTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.directoryId)) {
    query['DirectoryId'] = request.directoryId;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefreshLoginToken',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshLoginToken(request: RefreshLoginTokenRequest): RefreshLoginTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshLoginTokenWithOptions(request, runtime);
}

model ReportSessionStatusRequest {
  endUserId?: string(name='EndUserId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  sessionChangeTime?: long(name='SessionChangeTime'),
  sessionId?: string(name='SessionId'),
  sessionStatus?: string(name='SessionStatus'),
}

model ReportSessionStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReportSessionStatusResponse = {
  headers: map[string]string(name='headers'),
  body: ReportSessionStatusResponseBody(name='body'),
}

async function reportSessionStatusWithOptions(request: ReportSessionStatusRequest, runtime: Util.RuntimeOptions): ReportSessionStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionChangeTime)) {
    query['SessionChangeTime'] = request.sessionChangeTime;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.sessionStatus)) {
    query['SessionStatus'] = request.sessionStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReportSessionStatus',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportSessionStatus(request: ReportSessionStatusRequest): ReportSessionStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportSessionStatusWithOptions(request, runtime);
}

model ResetPasswordRequest {
  clientId?: string(name='ClientId'),
  email?: string(name='Email'),
  endUserId?: string(name='EndUserId'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
  phone?: string(name='phone'),
}

model ResetPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: ResetPasswordResponseBody(name='body'),
}

async function resetPasswordWithOptions(request: ResetPasswordRequest, runtime: Util.RuntimeOptions): ResetPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.phone)) {
    query['phone'] = request.phone;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetPassword',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetPassword(request: ResetPasswordRequest): ResetPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetPasswordWithOptions(request, runtime);
}

model ResetSnapshotRequest {
  clientId?: string(name='ClientId'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
  snapshotId?: string(name='SnapshotId'),
}

model ResetSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: ResetSnapshotResponseBody(name='body'),
}

async function resetSnapshotWithOptions(request: ResetSnapshotRequest, runtime: Util.RuntimeOptions): ResetSnapshotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetSnapshot',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetSnapshot(request: ResetSnapshotRequest): ResetSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetSnapshotWithOptions(request, runtime);
}

model SendTokenCodeRequest {
  clientId?: string(name='ClientId'),
  clientOS?: string(name='ClientOS'),
  clientVersion?: string(name='ClientVersion'),
  endUserId?: string(name='EndUserId'),
  loginToken?: string(name='LoginToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  sessionId?: string(name='SessionId'),
  tokenCode?: string(name='TokenCode'),
}

model SendTokenCodeResponseBody = {
  requestId?: string(name='RequestId'),
}

model SendTokenCodeResponse = {
  headers: map[string]string(name='headers'),
  body: SendTokenCodeResponseBody(name='body'),
}

async function sendTokenCodeWithOptions(request: SendTokenCodeRequest, runtime: Util.RuntimeOptions): SendTokenCodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientOS)) {
    query['ClientOS'] = request.clientOS;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.endUserId)) {
    query['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  if (!Util.isUnset(request.tokenCode)) {
    query['TokenCode'] = request.tokenCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SendTokenCode',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendTokenCode(request: SendTokenCodeRequest): SendTokenCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendTokenCodeWithOptions(request, runtime);
}

model SetFingerPrintTemplateRequest {
  clientId?: string(name='ClientId'),
  description?: string(name='Description'),
  encryptedFingerPrintTemplate?: string(name='EncryptedFingerPrintTemplate'),
  encryptedKey?: string(name='EncryptedKey'),
  fingerPrintTemplate?: string(name='FingerPrintTemplate'),
  loginToken?: string(name='LoginToken'),
  password?: string(name='Password'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model SetFingerPrintTemplateResponseBody = {
  encryptedPassword?: string(name='EncryptedPassword'),
  index?: int32(name='Index'),
  requestId?: string(name='RequestId'),
}

model SetFingerPrintTemplateResponse = {
  headers: map[string]string(name='headers'),
  body: SetFingerPrintTemplateResponseBody(name='body'),
}

async function setFingerPrintTemplateWithOptions(request: SetFingerPrintTemplateRequest, runtime: Util.RuntimeOptions): SetFingerPrintTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.encryptedFingerPrintTemplate)) {
    query['EncryptedFingerPrintTemplate'] = request.encryptedFingerPrintTemplate;
  }
  if (!Util.isUnset(request.encryptedKey)) {
    query['EncryptedKey'] = request.encryptedKey;
  }
  if (!Util.isUnset(request.fingerPrintTemplate)) {
    query['FingerPrintTemplate'] = request.fingerPrintTemplate;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetFingerPrintTemplate',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setFingerPrintTemplate(request: SetFingerPrintTemplateRequest): SetFingerPrintTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return setFingerPrintTemplateWithOptions(request, runtime);
}

model SetFingerPrintTemplateDescriptionRequest {
  clientId?: string(name='ClientId'),
  description?: string(name='Description'),
  index?: int32(name='Index'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model SetFingerPrintTemplateDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetFingerPrintTemplateDescriptionResponse = {
  headers: map[string]string(name='headers'),
  body: SetFingerPrintTemplateDescriptionResponseBody(name='body'),
}

async function setFingerPrintTemplateDescriptionWithOptions(request: SetFingerPrintTemplateDescriptionRequest, runtime: Util.RuntimeOptions): SetFingerPrintTemplateDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.index)) {
    query['Index'] = request.index;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetFingerPrintTemplateDescription',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setFingerPrintTemplateDescription(request: SetFingerPrintTemplateDescriptionRequest): SetFingerPrintTemplateDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return setFingerPrintTemplateDescriptionWithOptions(request, runtime);
}

model StartDesktopsRequest {
  clientId?: string(name='ClientId'),
  clientOS?: string(name='ClientOS'),
  clientVersion?: string(name='ClientVersion'),
  desktopId?: [ string ](name='DesktopId'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model StartDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: StartDesktopsResponseBody(name='body'),
}

async function startDesktopsWithOptions(request: StartDesktopsRequest, runtime: Util.RuntimeOptions): StartDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientOS)) {
    query['ClientOS'] = request.clientOS;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartDesktops',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startDesktops(request: StartDesktopsRequest): StartDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDesktopsWithOptions(request, runtime);
}

model StopDesktopsRequest {
  clientId?: string(name='ClientId'),
  clientOS?: string(name='ClientOS'),
  clientVersion?: string(name='ClientVersion'),
  desktopId?: [ string ](name='DesktopId'),
  loginToken?: string(name='LoginToken'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model StopDesktopsResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopDesktopsResponse = {
  headers: map[string]string(name='headers'),
  body: StopDesktopsResponseBody(name='body'),
}

async function stopDesktopsWithOptions(request: StopDesktopsRequest, runtime: Util.RuntimeOptions): StopDesktopsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientOS)) {
    query['ClientOS'] = request.clientOS;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.desktopId)) {
    query['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopDesktops',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopDesktops(request: StopDesktopsRequest): StopDesktopsResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopDesktopsWithOptions(request, runtime);
}

model VerifyCredentialRequest {
  clientId?: string(name='ClientId'),
  credential?: string(name='Credential'),
  credentialType?: string(name='CredentialType'),
  encryptedKey?: string(name='EncryptedKey'),
  loginToken?: string(name='LoginToken'),
  officeSiteId?: string(name='OfficeSiteId'),
  regionId?: string(name='RegionId'),
  sessionId?: string(name='SessionId'),
}

model VerifyCredentialResponseBody = {
  requestId?: string(name='RequestId'),
}

model VerifyCredentialResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyCredentialResponseBody(name='body'),
}

async function verifyCredentialWithOptions(request: VerifyCredentialRequest, runtime: Util.RuntimeOptions): VerifyCredentialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.credential)) {
    query['Credential'] = request.credential;
  }
  if (!Util.isUnset(request.credentialType)) {
    query['CredentialType'] = request.credentialType;
  }
  if (!Util.isUnset(request.encryptedKey)) {
    query['EncryptedKey'] = request.encryptedKey;
  }
  if (!Util.isUnset(request.loginToken)) {
    query['LoginToken'] = request.loginToken;
  }
  if (!Util.isUnset(request.officeSiteId)) {
    query['OfficeSiteId'] = request.officeSiteId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sessionId)) {
    query['SessionId'] = request.sessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyCredential',
    version = '2020-10-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyCredential(request: VerifyCredentialRequest): VerifyCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyCredentialWithOptions(request, runtime);
}

