/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('dms-enterprise', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddDesensitizationRuleRequest {
  functionParams?: [ map[string]string ](name='FunctionParams'),
  functionType?: string(name='FunctionType'),
  ruleDescription?: string(name='RuleDescription'),
  ruleName?: string(name='RuleName'),
  ruleType?: string(name='RuleType'),
  tid?: long(name='Tid'),
}

model AddDesensitizationRuleResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  ruleId?: int32(name='RuleId'),
  success?: boolean(name='Success'),
}

model AddDesensitizationRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDesensitizationRuleResponseBody(name='body'),
}

async function addDesensitizationRuleWithOptions(request: AddDesensitizationRuleRequest, runtime: Util.RuntimeOptions): AddDesensitizationRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.functionType)) {
    query['FunctionType'] = request.functionType;
  }
  if (!Util.isUnset(request.ruleDescription)) {
    query['RuleDescription'] = request.ruleDescription;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.functionParams)) {
    bodyFlat['FunctionParams'] = request.functionParams;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddDesensitizationRule',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDesensitizationRule(request: AddDesensitizationRuleRequest): AddDesensitizationRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDesensitizationRuleWithOptions(request, runtime);
}

model AddLhMembersRequest {
  members?: [ 
    {
      roles?: [ string ](name='Roles'),
      userId?: long(name='UserId'),
    }
  ](name='Members'),
  objectId?: long(name='ObjectId'),
  objectType?: int32(name='ObjectType'),
  tid?: long(name='Tid'),
}

model AddLhMembersShrinkRequest {
  membersShrink?: string(name='Members'),
  objectId?: long(name='ObjectId'),
  objectType?: int32(name='ObjectType'),
  tid?: long(name='Tid'),
}

model AddLhMembersResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddLhMembersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddLhMembersResponseBody(name='body'),
}

async function addLhMembersWithOptions(tmpReq: AddLhMembersRequest, runtime: Util.RuntimeOptions): AddLhMembersResponse {
  Util.validateModel(tmpReq);
  var request = new AddLhMembersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.members)) {
    request.membersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.members, 'Members', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.membersShrink)) {
    query['Members'] = request.membersShrink;
  }
  if (!Util.isUnset(request.objectId)) {
    query['ObjectId'] = request.objectId;
  }
  if (!Util.isUnset(request.objectType)) {
    query['ObjectType'] = request.objectType;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddLhMembers',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addLhMembers(request: AddLhMembersRequest): AddLhMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return addLhMembersWithOptions(request, runtime);
}

model AddLogicTableRouteConfigRequest {
  routeExpr?: string(name='RouteExpr'),
  routeKey?: string(name='RouteKey'),
  tableId?: long(name='TableId'),
  tid?: long(name='Tid'),
}

model AddLogicTableRouteConfigResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddLogicTableRouteConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddLogicTableRouteConfigResponseBody(name='body'),
}

async function addLogicTableRouteConfigWithOptions(request: AddLogicTableRouteConfigRequest, runtime: Util.RuntimeOptions): AddLogicTableRouteConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.routeExpr)) {
    query['RouteExpr'] = request.routeExpr;
  }
  if (!Util.isUnset(request.routeKey)) {
    query['RouteKey'] = request.routeKey;
  }
  if (!Util.isUnset(request.tableId)) {
    query['TableId'] = request.tableId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddLogicTableRouteConfig',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addLogicTableRouteConfig(request: AddLogicTableRouteConfigRequest): AddLogicTableRouteConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return addLogicTableRouteConfigWithOptions(request, runtime);
}

model ApproveOrderRequest {
  approvalType?: string(name='ApprovalType'),
  comment?: string(name='Comment'),
  tid?: long(name='Tid'),
  workflowInstanceId?: long(name='WorkflowInstanceId'),
}

model ApproveOrderResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ApproveOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApproveOrderResponseBody(name='body'),
}

async function approveOrderWithOptions(request: ApproveOrderRequest, runtime: Util.RuntimeOptions): ApproveOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.approvalType)) {
    query['ApprovalType'] = request.approvalType;
  }
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.workflowInstanceId)) {
    query['WorkflowInstanceId'] = request.workflowInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApproveOrder',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function approveOrder(request: ApproveOrderRequest): ApproveOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return approveOrderWithOptions(request, runtime);
}

model ChangeColumnSecLevelRequest {
  columnName?: string(name='ColumnName'),
  dbId?: long(name='DbId'),
  isLogic?: boolean(name='IsLogic'),
  newLevel?: string(name='NewLevel'),
  schemaName?: string(name='SchemaName'),
  tableName?: string(name='TableName'),
  tid?: long(name='Tid'),
}

model ChangeColumnSecLevelResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ChangeColumnSecLevelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeColumnSecLevelResponseBody(name='body'),
}

async function changeColumnSecLevelWithOptions(request: ChangeColumnSecLevelRequest, runtime: Util.RuntimeOptions): ChangeColumnSecLevelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.columnName)) {
    query['ColumnName'] = request.columnName;
  }
  if (!Util.isUnset(request.dbId)) {
    query['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.isLogic)) {
    query['IsLogic'] = request.isLogic;
  }
  if (!Util.isUnset(request.newLevel)) {
    query['NewLevel'] = request.newLevel;
  }
  if (!Util.isUnset(request.schemaName)) {
    query['SchemaName'] = request.schemaName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeColumnSecLevel',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeColumnSecLevel(request: ChangeColumnSecLevelRequest): ChangeColumnSecLevelResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeColumnSecLevelWithOptions(request, runtime);
}

model ChangeLhDagOwnerRequest {
  dagId?: long(name='DagId'),
  ownerUserId?: long(name='OwnerUserId'),
  tid?: long(name='Tid'),
}

model ChangeLhDagOwnerResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ChangeLhDagOwnerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeLhDagOwnerResponseBody(name='body'),
}

async function changeLhDagOwnerWithOptions(request: ChangeLhDagOwnerRequest, runtime: Util.RuntimeOptions): ChangeLhDagOwnerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dagId)) {
    query['DagId'] = request.dagId;
  }
  if (!Util.isUnset(request.ownerUserId)) {
    query['OwnerUserId'] = request.ownerUserId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeLhDagOwner',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeLhDagOwner(request: ChangeLhDagOwnerRequest): ChangeLhDagOwnerResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeLhDagOwnerWithOptions(request, runtime);
}

model CloseOrderRequest {
  closeReason?: string(name='CloseReason'),
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model CloseOrderResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CloseOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseOrderResponseBody(name='body'),
}

async function closeOrderWithOptions(request: CloseOrderRequest, runtime: Util.RuntimeOptions): CloseOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.closeReason)) {
    query['CloseReason'] = request.closeReason;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloseOrder',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function closeOrder(request: CloseOrderRequest): CloseOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return closeOrderWithOptions(request, runtime);
}

model CreateDataCorrectOrderRequest {
  attachmentKey?: string(name='AttachmentKey'),
  comment?: string(name='Comment'),
  param?: {
    attachmentName?: string(name='AttachmentName'),
    classify?: string(name='Classify'),
    dbItemList?: [ 
      {
        dbId?: long(name='DbId'),
        logic?: boolean(name='Logic'),
      }
    ](name='DbItemList'),
    estimateAffectRows?: long(name='EstimateAffectRows'),
    execMode?: string(name='ExecMode'),
    execSQL?: string(name='ExecSQL'),
    rollbackAttachmentName?: string(name='RollbackAttachmentName'),
    rollbackSQL?: string(name='RollbackSQL'),
    rollbackSqlType?: string(name='RollbackSqlType'),
    sqlType?: string(name='SqlType'),
  }(name='Param'),
  relatedUserList?: [ long ](name='RelatedUserList'),
  tid?: long(name='Tid'),
}

model CreateDataCorrectOrderShrinkRequest {
  attachmentKey?: string(name='AttachmentKey'),
  comment?: string(name='Comment'),
  paramShrink?: string(name='Param'),
  relatedUserListShrink?: string(name='RelatedUserList'),
  tid?: long(name='Tid'),
}

model CreateDataCorrectOrderResponseBody = {
  createOrderResult?: [ long ](name='CreateOrderResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDataCorrectOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDataCorrectOrderResponseBody(name='body'),
}

async function createDataCorrectOrderWithOptions(tmpReq: CreateDataCorrectOrderRequest, runtime: Util.RuntimeOptions): CreateDataCorrectOrderResponse {
  Util.validateModel(tmpReq);
  var request = new CreateDataCorrectOrderShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.param)) {
    request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, 'Param', 'json');
  }
  if (!Util.isUnset(tmpReq.relatedUserList)) {
    request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, 'RelatedUserList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.attachmentKey)) {
    query['AttachmentKey'] = request.attachmentKey;
  }
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.paramShrink)) {
    query['Param'] = request.paramShrink;
  }
  if (!Util.isUnset(request.relatedUserListShrink)) {
    query['RelatedUserList'] = request.relatedUserListShrink;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataCorrectOrder',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDataCorrectOrder(request: CreateDataCorrectOrderRequest): CreateDataCorrectOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataCorrectOrderWithOptions(request, runtime);
}

model CreateDataCronClearOrderRequest {
  attachmentKey?: string(name='AttachmentKey'),
  comment?: string(name='Comment'),
  param?: {
    classify?: string(name='Classify'),
    cronClearItemList?: [ 
      {
        columnName?: string(name='ColumnName'),
        filterSQL?: string(name='FilterSQL'),
        remainDays?: long(name='RemainDays'),
        tableName?: string(name='TableName'),
        timeUnit?: string(name='TimeUnit'),
      }
    ](name='CronClearItemList'),
    cronFormat?: string(name='CronFormat'),
    dbItemList?: [ 
      {
        dbId?: long(name='DbId'),
        logic?: boolean(name='Logic'),
      }
    ](name='DbItemList'),
    durationHour?: long(name='DurationHour'),
    specifyDuration?: boolean(name='specifyDuration'),
  }(name='Param'),
  relatedUserList?: [ long ](name='RelatedUserList'),
  tid?: long(name='Tid'),
}

model CreateDataCronClearOrderShrinkRequest {
  attachmentKey?: string(name='AttachmentKey'),
  comment?: string(name='Comment'),
  paramShrink?: string(name='Param'),
  relatedUserListShrink?: string(name='RelatedUserList'),
  tid?: long(name='Tid'),
}

model CreateDataCronClearOrderResponseBody = {
  createOrderResult?: [ long ](name='CreateOrderResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDataCronClearOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDataCronClearOrderResponseBody(name='body'),
}

async function createDataCronClearOrderWithOptions(tmpReq: CreateDataCronClearOrderRequest, runtime: Util.RuntimeOptions): CreateDataCronClearOrderResponse {
  Util.validateModel(tmpReq);
  var request = new CreateDataCronClearOrderShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.param)) {
    request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, 'Param', 'json');
  }
  if (!Util.isUnset(tmpReq.relatedUserList)) {
    request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, 'RelatedUserList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.attachmentKey)) {
    query['AttachmentKey'] = request.attachmentKey;
  }
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.paramShrink)) {
    query['Param'] = request.paramShrink;
  }
  if (!Util.isUnset(request.relatedUserListShrink)) {
    query['RelatedUserList'] = request.relatedUserListShrink;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataCronClearOrder',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDataCronClearOrder(request: CreateDataCronClearOrderRequest): CreateDataCronClearOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataCronClearOrderWithOptions(request, runtime);
}

model CreateDataImportOrderRequest {
  attachmentKey?: string(name='AttachmentKey'),
  comment?: string(name='Comment'),
  param?: {
    attachmentName?: string(name='AttachmentName'),
    classify?: string(name='Classify'),
    csvFirstRowIsColumnDef?: boolean(name='CsvFirstRowIsColumnDef'),
    dbItemList?: [ 
      {
        dbId?: long(name='DbId'),
        logic?: boolean(name='Logic'),
      }
    ](name='DbItemList'),
    fileEncoding?: string(name='FileEncoding'),
    fileType?: string(name='FileType'),
    ignoreError?: boolean(name='IgnoreError'),
    importMode?: string(name='ImportMode'),
    insertType?: string(name='InsertType'),
    rollbackAttachmentName?: string(name='RollbackAttachmentName'),
    rollbackSQL?: string(name='RollbackSQL'),
    rollbackSqlType?: string(name='RollbackSqlType'),
    tableName?: string(name='TableName'),
  }(name='Param'),
  relatedUserList?: [ long ](name='RelatedUserList'),
  tid?: long(name='Tid'),
}

model CreateDataImportOrderShrinkRequest {
  attachmentKey?: string(name='AttachmentKey'),
  comment?: string(name='Comment'),
  paramShrink?: string(name='Param'),
  relatedUserListShrink?: string(name='RelatedUserList'),
  tid?: long(name='Tid'),
}

model CreateDataImportOrderResponseBody = {
  createOrderResult?: [ long ](name='CreateOrderResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateDataImportOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDataImportOrderResponseBody(name='body'),
}

async function createDataImportOrderWithOptions(tmpReq: CreateDataImportOrderRequest, runtime: Util.RuntimeOptions): CreateDataImportOrderResponse {
  Util.validateModel(tmpReq);
  var request = new CreateDataImportOrderShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.param)) {
    request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, 'Param', 'json');
  }
  if (!Util.isUnset(tmpReq.relatedUserList)) {
    request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, 'RelatedUserList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.attachmentKey)) {
    query['AttachmentKey'] = request.attachmentKey;
  }
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.paramShrink)) {
    query['Param'] = request.paramShrink;
  }
  if (!Util.isUnset(request.relatedUserListShrink)) {
    query['RelatedUserList'] = request.relatedUserListShrink;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDataImportOrder',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDataImportOrder(request: CreateDataImportOrderRequest): CreateDataImportOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataImportOrderWithOptions(request, runtime);
}

model CreateFreeLockCorrectOrderRequest {
  attachmentKey?: string(name='AttachmentKey'),
  comment?: string(name='Comment'),
  param?: {
    attachmentName?: string(name='AttachmentName'),
    classify?: string(name='Classify'),
    dbItemList?: [ 
      {
        dbId?: long(name='DbId'),
        logic?: boolean(name='Logic'),
      }
    ](name='DbItemList'),
    execMode?: string(name='ExecMode'),
    execSQL?: string(name='ExecSQL'),
    rollbackAttachmentName?: string(name='RollbackAttachmentName'),
    rollbackSQL?: string(name='RollbackSQL'),
    rollbackSqlType?: string(name='RollbackSqlType'),
    sqlType?: string(name='SqlType'),
  }(name='Param'),
  relatedUserList?: [ long ](name='RelatedUserList'),
  tid?: long(name='Tid'),
}

model CreateFreeLockCorrectOrderShrinkRequest {
  attachmentKey?: string(name='AttachmentKey'),
  comment?: string(name='Comment'),
  paramShrink?: string(name='Param'),
  relatedUserListShrink?: string(name='RelatedUserList'),
  tid?: long(name='Tid'),
}

model CreateFreeLockCorrectOrderResponseBody = {
  createOrderResult?: [ long ](name='CreateOrderResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateFreeLockCorrectOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFreeLockCorrectOrderResponseBody(name='body'),
}

async function createFreeLockCorrectOrderWithOptions(tmpReq: CreateFreeLockCorrectOrderRequest, runtime: Util.RuntimeOptions): CreateFreeLockCorrectOrderResponse {
  Util.validateModel(tmpReq);
  var request = new CreateFreeLockCorrectOrderShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.param)) {
    request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, 'Param', 'json');
  }
  if (!Util.isUnset(tmpReq.relatedUserList)) {
    request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, 'RelatedUserList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.attachmentKey)) {
    query['AttachmentKey'] = request.attachmentKey;
  }
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.paramShrink)) {
    query['Param'] = request.paramShrink;
  }
  if (!Util.isUnset(request.relatedUserListShrink)) {
    query['RelatedUserList'] = request.relatedUserListShrink;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFreeLockCorrectOrder',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFreeLockCorrectOrder(request: CreateFreeLockCorrectOrderRequest): CreateFreeLockCorrectOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFreeLockCorrectOrderWithOptions(request, runtime);
}

model CreateLakeHouseSpaceRequest {
  description?: string(name='Description'),
  devDbId?: string(name='DevDbId'),
  dwDbType?: string(name='DwDbType'),
  mode?: string(name='Mode'),
  prodDbId?: string(name='ProdDbId'),
  spaceConfig?: string(name='SpaceConfig'),
  spaceName?: string(name='SpaceName'),
  tid?: long(name='Tid'),
}

model CreateLakeHouseSpaceResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  spaceId?: long(name='SpaceId'),
  success?: boolean(name='Success'),
}

model CreateLakeHouseSpaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLakeHouseSpaceResponseBody(name='body'),
}

async function createLakeHouseSpaceWithOptions(request: CreateLakeHouseSpaceRequest, runtime: Util.RuntimeOptions): CreateLakeHouseSpaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.devDbId)) {
    query['DevDbId'] = request.devDbId;
  }
  if (!Util.isUnset(request.dwDbType)) {
    query['DwDbType'] = request.dwDbType;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.prodDbId)) {
    query['ProdDbId'] = request.prodDbId;
  }
  if (!Util.isUnset(request.spaceConfig)) {
    query['SpaceConfig'] = request.spaceConfig;
  }
  if (!Util.isUnset(request.spaceName)) {
    query['SpaceName'] = request.spaceName;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLakeHouseSpace',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLakeHouseSpace(request: CreateLakeHouseSpaceRequest): CreateLakeHouseSpaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLakeHouseSpaceWithOptions(request, runtime);
}

model CreateLogicDatabaseRequest {
  alias?: string(name='Alias'),
  databaseIds?: [ long ](name='DatabaseIds'),
  tid?: long(name='Tid'),
}

model CreateLogicDatabaseShrinkRequest {
  alias?: string(name='Alias'),
  databaseIdsShrink?: string(name='DatabaseIds'),
  tid?: long(name='Tid'),
}

model CreateLogicDatabaseResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  logicDbId?: long(name='LogicDbId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateLogicDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLogicDatabaseResponseBody(name='body'),
}

async function createLogicDatabaseWithOptions(tmpReq: CreateLogicDatabaseRequest, runtime: Util.RuntimeOptions): CreateLogicDatabaseResponse {
  Util.validateModel(tmpReq);
  var request = new CreateLogicDatabaseShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.databaseIds)) {
    request.databaseIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.databaseIds, 'DatabaseIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.alias)) {
    query['Alias'] = request.alias;
  }
  if (!Util.isUnset(request.databaseIdsShrink)) {
    query['DatabaseIds'] = request.databaseIdsShrink;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogicDatabase',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLogicDatabase(request: CreateLogicDatabaseRequest): CreateLogicDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLogicDatabaseWithOptions(request, runtime);
}

model CreateOrderRequest {
  attachmentKey?: string(name='AttachmentKey'),
  comment?: string(name='Comment'),
  pluginParam?: map[string]any(name='PluginParam'),
  pluginType?: string(name='PluginType'),
  relatedUserList?: string(name='RelatedUserList'),
  tid?: long(name='Tid'),
}

model CreateOrderShrinkRequest {
  attachmentKey?: string(name='AttachmentKey'),
  comment?: string(name='Comment'),
  pluginParamShrink?: string(name='PluginParam'),
  pluginType?: string(name='PluginType'),
  relatedUserList?: string(name='RelatedUserList'),
  tid?: long(name='Tid'),
}

model CreateOrderResponseBody = {
  createOrderResult?: {
    orderIds?: [ long ](name='OrderIds')
  }(name='CreateOrderResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrderResponseBody(name='body'),
}

async function createOrderWithOptions(tmpReq: CreateOrderRequest, runtime: Util.RuntimeOptions): CreateOrderResponse {
  Util.validateModel(tmpReq);
  var request = new CreateOrderShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.pluginParam)) {
    request.pluginParamShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pluginParam, 'PluginParam', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.attachmentKey)) {
    query['AttachmentKey'] = request.attachmentKey;
  }
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.pluginType)) {
    query['PluginType'] = request.pluginType;
  }
  if (!Util.isUnset(request.relatedUserList)) {
    query['RelatedUserList'] = request.relatedUserList;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.pluginParamShrink)) {
    body['PluginParam'] = request.pluginParamShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrder',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrder(request: CreateOrderRequest): CreateOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrderWithOptions(request, runtime);
}

model CreateProxyRequest {
  instanceId?: long(name='InstanceId'),
  password?: string(name='Password'),
  tid?: long(name='Tid'),
  username?: string(name='Username'),
}

model CreateProxyResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  proxyId?: long(name='ProxyId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateProxyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProxyResponseBody(name='body'),
}

async function createProxyWithOptions(request: CreateProxyRequest, runtime: Util.RuntimeOptions): CreateProxyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProxy',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createProxy(request: CreateProxyRequest): CreateProxyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProxyWithOptions(request, runtime);
}

model CreateProxyAccessRequest {
  indepAccount?: string(name='IndepAccount'),
  indepPassword?: string(name='IndepPassword'),
  proxyId?: long(name='ProxyId'),
  tid?: long(name='Tid'),
  userId?: long(name='UserId'),
}

model CreateProxyAccessResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  proxyAccessId?: long(name='ProxyAccessId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateProxyAccessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateProxyAccessResponseBody(name='body'),
}

async function createProxyAccessWithOptions(request: CreateProxyAccessRequest, runtime: Util.RuntimeOptions): CreateProxyAccessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.indepAccount)) {
    query['IndepAccount'] = request.indepAccount;
  }
  if (!Util.isUnset(request.indepPassword)) {
    query['IndepPassword'] = request.indepPassword;
  }
  if (!Util.isUnset(request.proxyId)) {
    query['ProxyId'] = request.proxyId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateProxyAccess',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createProxyAccess(request: CreateProxyAccessRequest): CreateProxyAccessResponse {
  var runtime = new Util.RuntimeOptions{};
  return createProxyAccessWithOptions(request, runtime);
}

model CreatePublishGroupTaskRequest {
  dbId?: int32(name='DbId'),
  logic?: boolean(name='Logic'),
  orderId?: long(name='OrderId'),
  planTime?: string(name='PlanTime'),
  publishStrategy?: string(name='PublishStrategy'),
  tid?: long(name='Tid'),
}

model CreatePublishGroupTaskResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: long(name='TaskId'),
}

model CreatePublishGroupTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePublishGroupTaskResponseBody(name='body'),
}

async function createPublishGroupTaskWithOptions(request: CreatePublishGroupTaskRequest, runtime: Util.RuntimeOptions): CreatePublishGroupTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbId)) {
    query['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.logic)) {
    query['Logic'] = request.logic;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.planTime)) {
    query['PlanTime'] = request.planTime;
  }
  if (!Util.isUnset(request.publishStrategy)) {
    query['PublishStrategy'] = request.publishStrategy;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePublishGroupTask',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPublishGroupTask(request: CreatePublishGroupTaskRequest): CreatePublishGroupTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPublishGroupTaskWithOptions(request, runtime);
}

model CreateSQLReviewOrderRequest {
  comment?: string(name='Comment'),
  param?: {
    attachmentKeyList?: [ string ](name='AttachmentKeyList'),
    dbId?: long(name='DbId'),
    projectName?: string(name='ProjectName'),
  }(name='Param'),
  relatedUserList?: [ long ](name='RelatedUserList'),
  tid?: long(name='Tid'),
}

model CreateSQLReviewOrderShrinkRequest {
  comment?: string(name='Comment'),
  paramShrink?: string(name='Param'),
  relatedUserListShrink?: string(name='RelatedUserList'),
  tid?: long(name='Tid'),
}

model CreateSQLReviewOrderResponseBody = {
  createOrderResult?: [ long ](name='CreateOrderResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSQLReviewOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSQLReviewOrderResponseBody(name='body'),
}

async function createSQLReviewOrderWithOptions(tmpReq: CreateSQLReviewOrderRequest, runtime: Util.RuntimeOptions): CreateSQLReviewOrderResponse {
  Util.validateModel(tmpReq);
  var request = new CreateSQLReviewOrderShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.param)) {
    request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, 'Param', 'json');
  }
  if (!Util.isUnset(tmpReq.relatedUserList)) {
    request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, 'RelatedUserList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.paramShrink)) {
    query['Param'] = request.paramShrink;
  }
  if (!Util.isUnset(request.relatedUserListShrink)) {
    query['RelatedUserList'] = request.relatedUserListShrink;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSQLReviewOrder',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSQLReviewOrder(request: CreateSQLReviewOrderRequest): CreateSQLReviewOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSQLReviewOrderWithOptions(request, runtime);
}

model CreateStandardGroupRequest {
  dbType?: string(name='DbType'),
  description?: string(name='Description'),
  groupName?: string(name='GroupName'),
  tid?: long(name='Tid'),
}

model CreateStandardGroupResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  standardGroup?: {
    dbType?: string(name='DbType'),
    description?: string(name='Description'),
    groupMode?: string(name='GroupMode'),
    groupName?: string(name='GroupName'),
    lastMenderId?: long(name='LastMenderId'),
  }(name='StandardGroup'),
  success?: boolean(name='Success'),
}

model CreateStandardGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateStandardGroupResponseBody(name='body'),
}

async function createStandardGroupWithOptions(request: CreateStandardGroupRequest, runtime: Util.RuntimeOptions): CreateStandardGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbType)) {
    query['DbType'] = request.dbType;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateStandardGroup',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createStandardGroup(request: CreateStandardGroupRequest): CreateStandardGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createStandardGroupWithOptions(request, runtime);
}

model CreateStructSyncOrderRequest {
  attachmentKey?: string(name='AttachmentKey'),
  comment?: string(name='Comment'),
  param?: {
    ignoreError?: boolean(name='IgnoreError'),
    source?: {
      dbId?: long(name='DbId'),
      dbSearchName?: string(name='DbSearchName'),
      logic?: boolean(name='Logic'),
      versionId?: string(name='VersionId'),
    }(name='Source'),
    tableInfoList?: [ 
      {
        sourceTableName?: string(name='SourceTableName'),
        targetTableName?: string(name='TargetTableName'),
      }
    ](name='TableInfoList'),
    target?: {
      dbId?: long(name='DbId'),
      dbSearchName?: string(name='DbSearchName'),
      logic?: boolean(name='Logic'),
      versionId?: string(name='VersionId'),
    }(name='Target'),
  }(name='Param'),
  relatedUserList?: [ long ](name='RelatedUserList'),
  tid?: long(name='Tid'),
}

model CreateStructSyncOrderShrinkRequest {
  attachmentKey?: string(name='AttachmentKey'),
  comment?: string(name='Comment'),
  paramShrink?: string(name='Param'),
  relatedUserListShrink?: string(name='RelatedUserList'),
  tid?: long(name='Tid'),
}

model CreateStructSyncOrderResponseBody = {
  createOrderResult?: [ long ](name='CreateOrderResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateStructSyncOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateStructSyncOrderResponseBody(name='body'),
}

async function createStructSyncOrderWithOptions(tmpReq: CreateStructSyncOrderRequest, runtime: Util.RuntimeOptions): CreateStructSyncOrderResponse {
  Util.validateModel(tmpReq);
  var request = new CreateStructSyncOrderShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.param)) {
    request.paramShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.param, 'Param', 'json');
  }
  if (!Util.isUnset(tmpReq.relatedUserList)) {
    request.relatedUserListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedUserList, 'RelatedUserList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.attachmentKey)) {
    query['AttachmentKey'] = request.attachmentKey;
  }
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.paramShrink)) {
    query['Param'] = request.paramShrink;
  }
  if (!Util.isUnset(request.relatedUserListShrink)) {
    query['RelatedUserList'] = request.relatedUserListShrink;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateStructSyncOrder',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createStructSyncOrder(request: CreateStructSyncOrderRequest): CreateStructSyncOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createStructSyncOrderWithOptions(request, runtime);
}

model CreateUploadFileJobRequest {
  fileName?: string(name='FileName'),
  fileSource?: string(name='FileSource'),
  tid?: long(name='Tid'),
  uploadURL?: string(name='UploadURL'),
}

model CreateUploadFileJobResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  jobKey?: string(name='JobKey'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateUploadFileJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUploadFileJobResponseBody(name='body'),
}

async function createUploadFileJobWithOptions(request: CreateUploadFileJobRequest, runtime: Util.RuntimeOptions): CreateUploadFileJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileSource)) {
    query['FileSource'] = request.fileSource;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.uploadURL)) {
    query['UploadURL'] = request.uploadURL;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUploadFileJob',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUploadFileJob(request: CreateUploadFileJobRequest): CreateUploadFileJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUploadFileJobWithOptions(request, runtime);
}

model CreateUploadOSSFileJobRequest {
  fileName?: string(name='FileName'),
  fileSource?: string(name='FileSource'),
  tid?: long(name='Tid'),
  uploadTarget?: {
    bucketName?: string(name='BucketName'),
    endpoint?: string(name='Endpoint'),
    objectName?: string(name='ObjectName'),
  }(name='UploadTarget'),
}

model CreateUploadOSSFileJobShrinkRequest {
  fileName?: string(name='FileName'),
  fileSource?: string(name='FileSource'),
  tid?: long(name='Tid'),
  uploadTargetShrink?: string(name='UploadTarget'),
}

model CreateUploadOSSFileJobResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  jobKey?: string(name='JobKey'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateUploadOSSFileJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUploadOSSFileJobResponseBody(name='body'),
}

async function createUploadOSSFileJobWithOptions(tmpReq: CreateUploadOSSFileJobRequest, runtime: Util.RuntimeOptions): CreateUploadOSSFileJobResponse {
  Util.validateModel(tmpReq);
  var request = new CreateUploadOSSFileJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.uploadTarget)) {
    request.uploadTargetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.uploadTarget, 'UploadTarget', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileSource)) {
    query['FileSource'] = request.fileSource;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.uploadTargetShrink)) {
    query['UploadTarget'] = request.uploadTargetShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUploadOSSFileJob',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUploadOSSFileJob(request: CreateUploadOSSFileJobRequest): CreateUploadOSSFileJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUploadOSSFileJobWithOptions(request, runtime);
}

model DeleteInstanceRequest {
  host?: string(name='Host'),
  port?: int32(name='Port'),
  sid?: string(name='Sid'),
  tid?: long(name='Tid'),
}

model DeleteInstanceResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInstanceResponseBody(name='body'),
}

async function deleteInstanceWithOptions(request: DeleteInstanceRequest, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.host)) {
    query['Host'] = request.host;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.sid)) {
    query['Sid'] = request.sid;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstance',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstanceWithOptions(request, runtime);
}

model DeleteLakeHouseSpaceRequest {
  spaceId?: long(name='SpaceId'),
  tid?: long(name='Tid'),
}

model DeleteLakeHouseSpaceResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteLakeHouseSpaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLakeHouseSpaceResponseBody(name='body'),
}

async function deleteLakeHouseSpaceWithOptions(request: DeleteLakeHouseSpaceRequest, runtime: Util.RuntimeOptions): DeleteLakeHouseSpaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.spaceId)) {
    query['SpaceId'] = request.spaceId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLakeHouseSpace',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLakeHouseSpace(request: DeleteLakeHouseSpaceRequest): DeleteLakeHouseSpaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLakeHouseSpaceWithOptions(request, runtime);
}

model DeleteLhMembersRequest {
  memberIds?: [ int32 ](name='MemberIds'),
  objectId?: long(name='ObjectId'),
  objectType?: int32(name='ObjectType'),
  tid?: long(name='Tid'),
}

model DeleteLhMembersShrinkRequest {
  memberIdsShrink?: string(name='MemberIds'),
  objectId?: long(name='ObjectId'),
  objectType?: int32(name='ObjectType'),
  tid?: long(name='Tid'),
}

model DeleteLhMembersResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteLhMembersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLhMembersResponseBody(name='body'),
}

async function deleteLhMembersWithOptions(tmpReq: DeleteLhMembersRequest, runtime: Util.RuntimeOptions): DeleteLhMembersResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteLhMembersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.memberIds)) {
    request.memberIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.memberIds, 'MemberIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.memberIdsShrink)) {
    query['MemberIds'] = request.memberIdsShrink;
  }
  if (!Util.isUnset(request.objectId)) {
    query['ObjectId'] = request.objectId;
  }
  if (!Util.isUnset(request.objectType)) {
    query['ObjectType'] = request.objectType;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLhMembers',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLhMembers(request: DeleteLhMembersRequest): DeleteLhMembersResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLhMembersWithOptions(request, runtime);
}

model DeleteLogicDatabaseRequest {
  logicDbId?: long(name='LogicDbId'),
  tid?: long(name='Tid'),
}

model DeleteLogicDatabaseResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteLogicDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLogicDatabaseResponseBody(name='body'),
}

async function deleteLogicDatabaseWithOptions(request: DeleteLogicDatabaseRequest, runtime: Util.RuntimeOptions): DeleteLogicDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.logicDbId)) {
    query['LogicDbId'] = request.logicDbId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogicDatabase',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLogicDatabase(request: DeleteLogicDatabaseRequest): DeleteLogicDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLogicDatabaseWithOptions(request, runtime);
}

model DeleteLogicTableRouteConfigRequest {
  routeKey?: string(name='RouteKey'),
  tableId?: long(name='TableId'),
  tid?: long(name='Tid'),
}

model DeleteLogicTableRouteConfigResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteLogicTableRouteConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLogicTableRouteConfigResponseBody(name='body'),
}

async function deleteLogicTableRouteConfigWithOptions(request: DeleteLogicTableRouteConfigRequest, runtime: Util.RuntimeOptions): DeleteLogicTableRouteConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.routeKey)) {
    query['RouteKey'] = request.routeKey;
  }
  if (!Util.isUnset(request.tableId)) {
    query['TableId'] = request.tableId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLogicTableRouteConfig',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLogicTableRouteConfig(request: DeleteLogicTableRouteConfigRequest): DeleteLogicTableRouteConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLogicTableRouteConfigWithOptions(request, runtime);
}

model DeleteProxyRequest {
  proxyId?: long(name='ProxyId'),
  tid?: long(name='Tid'),
}

model DeleteProxyResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteProxyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProxyResponseBody(name='body'),
}

async function deleteProxyWithOptions(request: DeleteProxyRequest, runtime: Util.RuntimeOptions): DeleteProxyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.proxyId)) {
    query['ProxyId'] = request.proxyId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProxy',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProxy(request: DeleteProxyRequest): DeleteProxyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProxyWithOptions(request, runtime);
}

model DeleteProxyAccessRequest {
  proxyAccessId?: long(name='ProxyAccessId'),
  tid?: long(name='Tid'),
}

model DeleteProxyAccessResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteProxyAccessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProxyAccessResponseBody(name='body'),
}

async function deleteProxyAccessWithOptions(request: DeleteProxyAccessRequest, runtime: Util.RuntimeOptions): DeleteProxyAccessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.proxyAccessId)) {
    query['ProxyAccessId'] = request.proxyAccessId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProxyAccess',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProxyAccess(request: DeleteProxyAccessRequest): DeleteProxyAccessResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProxyAccessWithOptions(request, runtime);
}

model DeleteTaskFlowRequest {
  dagId?: long(name='DagId'),
  tid?: long(name='Tid'),
}

model DeleteTaskFlowResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteTaskFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTaskFlowResponseBody(name='body'),
}

async function deleteTaskFlowWithOptions(request: DeleteTaskFlowRequest, runtime: Util.RuntimeOptions): DeleteTaskFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dagId)) {
    query['DagId'] = request.dagId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTaskFlow',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTaskFlow(request: DeleteTaskFlowRequest): DeleteTaskFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTaskFlowWithOptions(request, runtime);
}

model DeleteUserRequest {
  tid?: long(name='Tid'),
  uid?: string(name='Uid'),
}

model DeleteUserResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model DisableUserRequest {
  tid?: long(name='Tid'),
  uid?: string(name='Uid'),
}

model DisableUserResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableUserResponseBody(name='body'),
}

async function disableUserWithOptions(request: DisableUserRequest, runtime: Util.RuntimeOptions): DisableUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableUser',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableUser(request: DisableUserRequest): DisableUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableUserWithOptions(request, runtime);
}

model EditLogicDatabaseRequest {
  alias?: string(name='Alias'),
  databaseIds?: [ long ](name='DatabaseIds'),
  logicDbId?: long(name='LogicDbId'),
  tid?: long(name='Tid'),
}

model EditLogicDatabaseShrinkRequest {
  alias?: string(name='Alias'),
  databaseIdsShrink?: string(name='DatabaseIds'),
  logicDbId?: long(name='LogicDbId'),
  tid?: long(name='Tid'),
}

model EditLogicDatabaseResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EditLogicDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EditLogicDatabaseResponseBody(name='body'),
}

async function editLogicDatabaseWithOptions(tmpReq: EditLogicDatabaseRequest, runtime: Util.RuntimeOptions): EditLogicDatabaseResponse {
  Util.validateModel(tmpReq);
  var request = new EditLogicDatabaseShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.databaseIds)) {
    request.databaseIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.databaseIds, 'DatabaseIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.alias)) {
    query['Alias'] = request.alias;
  }
  if (!Util.isUnset(request.databaseIdsShrink)) {
    query['DatabaseIds'] = request.databaseIdsShrink;
  }
  if (!Util.isUnset(request.logicDbId)) {
    query['LogicDbId'] = request.logicDbId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EditLogicDatabase',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function editLogicDatabase(request: EditLogicDatabaseRequest): EditLogicDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return editLogicDatabaseWithOptions(request, runtime);
}

model EnableUserRequest {
  tid?: long(name='Tid'),
  uid?: string(name='Uid'),
}

model EnableUserResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableUserResponseBody(name='body'),
}

async function enableUserWithOptions(request: EnableUserRequest, runtime: Util.RuntimeOptions): EnableUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableUser',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableUser(request: EnableUserRequest): EnableUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableUserWithOptions(request, runtime);
}

model ExecuteDataCorrectRequest {
  actionDetail?: map[string]any(name='ActionDetail'),
  orderId?: long(name='OrderId'),
  tid?: string(name='Tid'),
}

model ExecuteDataCorrectShrinkRequest {
  actionDetailShrink?: string(name='ActionDetail'),
  orderId?: long(name='OrderId'),
  tid?: string(name='Tid'),
}

model ExecuteDataCorrectResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExecuteDataCorrectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecuteDataCorrectResponseBody(name='body'),
}

async function executeDataCorrectWithOptions(tmpReq: ExecuteDataCorrectRequest, runtime: Util.RuntimeOptions): ExecuteDataCorrectResponse {
  Util.validateModel(tmpReq);
  var request = new ExecuteDataCorrectShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.actionDetail)) {
    request.actionDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.actionDetail, 'ActionDetail', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.actionDetailShrink)) {
    query['ActionDetail'] = request.actionDetailShrink;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteDataCorrect',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function executeDataCorrect(request: ExecuteDataCorrectRequest): ExecuteDataCorrectResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeDataCorrectWithOptions(request, runtime);
}

model ExecuteDataExportRequest {
  actionDetail?: map[string]any(name='ActionDetail'),
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model ExecuteDataExportShrinkRequest {
  actionDetailShrink?: string(name='ActionDetail'),
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model ExecuteDataExportResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExecuteDataExportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecuteDataExportResponseBody(name='body'),
}

async function executeDataExportWithOptions(tmpReq: ExecuteDataExportRequest, runtime: Util.RuntimeOptions): ExecuteDataExportResponse {
  Util.validateModel(tmpReq);
  var request = new ExecuteDataExportShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.actionDetail)) {
    request.actionDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.actionDetail, 'ActionDetail', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.actionDetailShrink)) {
    query['ActionDetail'] = request.actionDetailShrink;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteDataExport',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function executeDataExport(request: ExecuteDataExportRequest): ExecuteDataExportResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeDataExportWithOptions(request, runtime);
}

model ExecuteScriptRequest {
  dbId?: int32(name='DbId'),
  logic?: boolean(name='Logic'),
  script?: string(name='Script'),
  tid?: long(name='Tid'),
}

model ExecuteScriptResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      columnNames?: [ string ](name='ColumnNames'),
      message?: string(name='Message'),
      rowCount?: long(name='RowCount'),
      rows?: [  map[string]any ](name='Rows'),
      success?: boolean(name='Success'),
    }
  ](name='Results'),
  success?: boolean(name='Success'),
}

model ExecuteScriptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecuteScriptResponseBody(name='body'),
}

async function executeScriptWithOptions(request: ExecuteScriptRequest, runtime: Util.RuntimeOptions): ExecuteScriptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbId)) {
    query['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.logic)) {
    query['Logic'] = request.logic;
  }
  if (!Util.isUnset(request.script)) {
    query['Script'] = request.script;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteScript',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function executeScript(request: ExecuteScriptRequest): ExecuteScriptResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeScriptWithOptions(request, runtime);
}

model ExecuteStructSyncRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model ExecuteStructSyncResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExecuteStructSyncResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecuteStructSyncResponseBody(name='body'),
}

async function executeStructSyncWithOptions(request: ExecuteStructSyncRequest, runtime: Util.RuntimeOptions): ExecuteStructSyncResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteStructSync',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function executeStructSync(request: ExecuteStructSyncRequest): ExecuteStructSyncResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeStructSyncWithOptions(request, runtime);
}

model GetApprovalDetailRequest {
  tid?: long(name='Tid'),
  workflowInstanceId?: long(name='WorkflowInstanceId'),
}

model GetApprovalDetailResponseBody = {
  approvalDetail?: {
    auditId?: long(name='AuditId'),
    createTime?: string(name='CreateTime'),
    currentHandlers?: {
      currentHandler?: [ 
      {
        id?: long(name='Id'),
        nickName?: string(name='NickName'),
      }
    ](name='CurrentHandler')
    }(name='CurrentHandlers'),
    description?: string(name='Description'),
    orderId?: long(name='OrderId'),
    orderType?: string(name='OrderType'),
    reasonList?: {
      reasons?: [ string ](name='Reasons')
    }(name='ReasonList'),
    title?: string(name='Title'),
    workflowInsCode?: string(name='WorkflowInsCode'),
    workflowNodes?: {
      workflowNode?: [ 
      {
        auditUserIdList?: {
          auditUserIds?: [ string ](name='AuditUserIds')
        }(name='AuditUserIdList'),
        nodeName?: string(name='NodeName'),
        operateComment?: string(name='OperateComment'),
        operateTime?: string(name='OperateTime'),
        operatorId?: long(name='OperatorId'),
        workflowInsCode?: string(name='WorkflowInsCode'),
      }
    ](name='WorkflowNode')
    }(name='WorkflowNodes'),
  }(name='ApprovalDetail'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetApprovalDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetApprovalDetailResponseBody(name='body'),
}

async function getApprovalDetailWithOptions(request: GetApprovalDetailRequest, runtime: Util.RuntimeOptions): GetApprovalDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.workflowInstanceId)) {
    query['WorkflowInstanceId'] = request.workflowInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetApprovalDetail',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getApprovalDetail(request: GetApprovalDetailRequest): GetApprovalDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getApprovalDetailWithOptions(request, runtime);
}

model GetDBTaskSQLJobLogRequest {
  jobId?: long(name='JobId'),
  tid?: long(name='Tid'),
}

model GetDBTaskSQLJobLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  log?: string(name='Log'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDBTaskSQLJobLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDBTaskSQLJobLogResponseBody(name='body'),
}

async function getDBTaskSQLJobLogWithOptions(request: GetDBTaskSQLJobLogRequest, runtime: Util.RuntimeOptions): GetDBTaskSQLJobLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDBTaskSQLJobLog',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDBTaskSQLJobLog(request: GetDBTaskSQLJobLogRequest): GetDBTaskSQLJobLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDBTaskSQLJobLogWithOptions(request, runtime);
}

model GetDBTopologyRequest {
  logicDbId?: long(name='LogicDbId'),
  tid?: long(name='Tid'),
}

model GetDBTopologyResponseBody = {
  DBTopology?: {
    alias?: string(name='Alias'),
    DBTopologyInfoList?: [ 
      {
        catalogName?: string(name='CatalogName'),
        dbId?: long(name='DbId'),
        dbType?: string(name='DbType'),
        envType?: string(name='EnvType'),
        instanceId?: long(name='InstanceId'),
        instanceResourceId?: string(name='InstanceResourceId'),
        instanceSource?: string(name='InstanceSource'),
        regionId?: string(name='RegionId'),
        schemaName?: string(name='SchemaName'),
        searchName?: string(name='SearchName'),
      }
    ](name='DBTopologyInfoList'),
    dbType?: string(name='DbType'),
    envType?: string(name='EnvType'),
    logicDbId?: long(name='LogicDbId'),
    logicDbName?: string(name='LogicDbName'),
    searchName?: string(name='SearchName'),
  }(name='DBTopology'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDBTopologyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDBTopologyResponseBody(name='body'),
}

async function getDBTopologyWithOptions(request: GetDBTopologyRequest, runtime: Util.RuntimeOptions): GetDBTopologyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.logicDbId)) {
    query['LogicDbId'] = request.logicDbId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDBTopology',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDBTopology(request: GetDBTopologyRequest): GetDBTopologyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDBTopologyWithOptions(request, runtime);
}

model GetDataCorrectBackupFilesRequest {
  actionDetail?: map[string]any(name='ActionDetail'),
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model GetDataCorrectBackupFilesShrinkRequest {
  actionDetailShrink?: string(name='ActionDetail'),
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model GetDataCorrectBackupFilesResponseBody = {
  dataCorrectBackupFiles?: {
    fileUrl?: [ string ](name='FileUrl')
  }(name='DataCorrectBackupFiles'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataCorrectBackupFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDataCorrectBackupFilesResponseBody(name='body'),
}

async function getDataCorrectBackupFilesWithOptions(tmpReq: GetDataCorrectBackupFilesRequest, runtime: Util.RuntimeOptions): GetDataCorrectBackupFilesResponse {
  Util.validateModel(tmpReq);
  var request = new GetDataCorrectBackupFilesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.actionDetail)) {
    request.actionDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.actionDetail, 'ActionDetail', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.actionDetailShrink)) {
    query['ActionDetail'] = request.actionDetailShrink;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDataCorrectBackupFiles',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDataCorrectBackupFiles(request: GetDataCorrectBackupFilesRequest): GetDataCorrectBackupFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataCorrectBackupFilesWithOptions(request, runtime);
}

model GetDataCorrectOrderDetailRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model GetDataCorrectOrderDetailResponseBody = {
  dataCorrectOrderDetail?: {
    databaseList?: {
      database?: [ 
      {
        dbId?: int32(name='DbId'),
        dbType?: string(name='DbType'),
        envType?: string(name='EnvType'),
        logic?: boolean(name='Logic'),
        searchName?: string(name='SearchName'),
      }
    ](name='Database')
    }(name='DatabaseList'),
    execMode?: string(name='ExecMode'),
    orderDetail?: {
      actualAffectRows?: long(name='ActualAffectRows'),
      attachmentName?: string(name='AttachmentName'),
      classify?: string(name='Classify'),
      estimateAffectRows?: long(name='EstimateAffectRows'),
      exeSQL?: string(name='ExeSQL'),
      ignoreAffectRows?: boolean(name='IgnoreAffectRows'),
      ignoreAffectRowsReason?: string(name='IgnoreAffectRowsReason'),
      rbAttachmentName?: string(name='RbAttachmentName'),
      rbSQL?: string(name='RbSQL'),
      rbSQLType?: string(name='RbSQLType'),
      sqlType?: string(name='SqlType'),
    }(name='OrderDetail'),
    preCheckDetail?: {
      taskCheckDO?: [ 
      {
        checkStatus?: string(name='CheckStatus'),
        checkStep?: string(name='CheckStep'),
        userTip?: string(name='UserTip'),
      }
    ](name='TaskCheckDO')
    }(name='PreCheckDetail'),
    status?: string(name='Status'),
  }(name='DataCorrectOrderDetail'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataCorrectOrderDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDataCorrectOrderDetailResponseBody(name='body'),
}

async function getDataCorrectOrderDetailWithOptions(request: GetDataCorrectOrderDetailRequest, runtime: Util.RuntimeOptions): GetDataCorrectOrderDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDataCorrectOrderDetail',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDataCorrectOrderDetail(request: GetDataCorrectOrderDetailRequest): GetDataCorrectOrderDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataCorrectOrderDetailWithOptions(request, runtime);
}

model GetDataCorrectSQLFileRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model GetDataCorrectSQLFileResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  fileUrl?: string(name='FileUrl'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataCorrectSQLFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDataCorrectSQLFileResponseBody(name='body'),
}

async function getDataCorrectSQLFileWithOptions(request: GetDataCorrectSQLFileRequest, runtime: Util.RuntimeOptions): GetDataCorrectSQLFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDataCorrectSQLFile',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDataCorrectSQLFile(request: GetDataCorrectSQLFileRequest): GetDataCorrectSQLFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataCorrectSQLFileWithOptions(request, runtime);
}

model GetDataCorrectTaskDetailRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model GetDataCorrectTaskDetailResponseBody = {
  dataCorrectTaskDetail?: {
    actualAffectRows?: long(name='ActualAffectRows'),
    createTime?: string(name='CreateTime'),
    DBTaskGroupId?: long(name='DBTaskGroupId'),
    jobStatus?: string(name='jobStatus'),
  }(name='DataCorrectTaskDetail'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataCorrectTaskDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDataCorrectTaskDetailResponseBody(name='body'),
}

async function getDataCorrectTaskDetailWithOptions(request: GetDataCorrectTaskDetailRequest, runtime: Util.RuntimeOptions): GetDataCorrectTaskDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDataCorrectTaskDetail',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDataCorrectTaskDetail(request: GetDataCorrectTaskDetailRequest): GetDataCorrectTaskDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataCorrectTaskDetailWithOptions(request, runtime);
}

model GetDataCronClearTaskDetailListRequest {
  orderId?: long(name='OrderId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  tid?: long(name='Tid'),
}

model GetDataCronClearTaskDetailListResponseBody = {
  dataCronClearTaskDetailList?: [ 
    {
      actualAffectRows?: long(name='ActualAffectRows'),
      createTime?: string(name='CreateTime'),
      DBTaskGroupId?: long(name='DBTaskGroupId'),
      jobStatus?: string(name='jobStatus'),
    }
  ](name='DataCronClearTaskDetailList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model GetDataCronClearTaskDetailListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDataCronClearTaskDetailListResponseBody(name='body'),
}

async function getDataCronClearTaskDetailListWithOptions(request: GetDataCronClearTaskDetailListRequest, runtime: Util.RuntimeOptions): GetDataCronClearTaskDetailListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDataCronClearTaskDetailList',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDataCronClearTaskDetailList(request: GetDataCronClearTaskDetailListRequest): GetDataCronClearTaskDetailListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataCronClearTaskDetailListWithOptions(request, runtime);
}

model GetDataExportDownloadURLRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model GetDataExportDownloadURLResponseBody = {
  downloadURLResult?: {
    hasResult?: boolean(name='HasResult'),
    tipMessage?: string(name='TipMessage'),
    URL?: string(name='URL'),
  }(name='DownloadURLResult'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataExportDownloadURLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDataExportDownloadURLResponseBody(name='body'),
}

async function getDataExportDownloadURLWithOptions(request: GetDataExportDownloadURLRequest, runtime: Util.RuntimeOptions): GetDataExportDownloadURLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDataExportDownloadURL',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDataExportDownloadURL(request: GetDataExportDownloadURLRequest): GetDataExportDownloadURLResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataExportDownloadURLWithOptions(request, runtime);
}

model GetDataExportOrderDetailRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model GetDataExportOrderDetailResponseBody = {
  dataExportOrderDetail?: {
    keyInfo?: {
      jobStatus?: string(name='JobStatus'),
      preCheckId?: long(name='PreCheckId'),
    }(name='KeyInfo'),
    orderDetail?: {
      actualAffectRows?: long(name='ActualAffectRows'),
      classify?: string(name='Classify'),
      database?: string(name='Database'),
      dbId?: int32(name='DbId'),
      envType?: string(name='EnvType'),
      exeSQL?: string(name='ExeSQL'),
      ignoreAffectRows?: boolean(name='IgnoreAffectRows'),
      ignoreAffectRowsReason?: string(name='IgnoreAffectRowsReason'),
      logic?: boolean(name='Logic'),
    }(name='OrderDetail'),
  }(name='DataExportOrderDetail'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDataExportOrderDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDataExportOrderDetailResponseBody(name='body'),
}

async function getDataExportOrderDetailWithOptions(request: GetDataExportOrderDetailRequest, runtime: Util.RuntimeOptions): GetDataExportOrderDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.orderId)) {
    body['OrderId'] = request.orderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDataExportOrderDetail',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDataExportOrderDetail(request: GetDataExportOrderDetailRequest): GetDataExportOrderDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataExportOrderDetailWithOptions(request, runtime);
}

model GetDatabaseRequest {
  host?: string(name='Host'),
  port?: int32(name='Port'),
  schemaName?: string(name='SchemaName'),
  sid?: string(name='Sid'),
  tid?: long(name='Tid'),
}

model GetDatabaseResponseBody = {
  database?: {
    catalogName?: string(name='CatalogName'),
    databaseId?: string(name='DatabaseId'),
    dbType?: string(name='DbType'),
    dbaId?: string(name='DbaId'),
    dbaName?: string(name='DbaName'),
    encoding?: string(name='Encoding'),
    envType?: string(name='EnvType'),
    host?: string(name='Host'),
    instanceId?: string(name='InstanceId'),
    ownerIdList?: {
      ownerIds?: [ string ](name='OwnerIds')
    }(name='OwnerIdList'),
    ownerNameList?: {
      ownerNames?: [ string ](name='OwnerNames')
    }(name='OwnerNameList'),
    port?: int32(name='Port'),
    schemaName?: string(name='SchemaName'),
    searchName?: string(name='SearchName'),
    sid?: string(name='Sid'),
    state?: string(name='State'),
  }(name='Database'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDatabaseResponseBody(name='body'),
}

async function getDatabaseWithOptions(request: GetDatabaseRequest, runtime: Util.RuntimeOptions): GetDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.host)) {
    query['Host'] = request.host;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.schemaName)) {
    query['SchemaName'] = request.schemaName;
  }
  if (!Util.isUnset(request.sid)) {
    query['Sid'] = request.sid;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDatabase',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDatabase(request: GetDatabaseRequest): GetDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDatabaseWithOptions(request, runtime);
}

model GetInstanceRequest {
  host?: string(name='Host'),
  port?: int32(name='Port'),
  sid?: string(name='Sid'),
  tid?: long(name='Tid'),
}

model GetInstanceResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  instance?: {
    dataLinkName?: string(name='DataLinkName'),
    databasePassword?: string(name='DatabasePassword'),
    databaseUser?: string(name='DatabaseUser'),
    dbaId?: string(name='DbaId'),
    dbaNickName?: string(name='DbaNickName'),
    ddlOnline?: int32(name='DdlOnline'),
    ecsInstanceId?: string(name='EcsInstanceId'),
    ecsRegion?: string(name='EcsRegion'),
    envType?: string(name='EnvType'),
    exportTimeout?: int32(name='ExportTimeout'),
    host?: string(name='Host'),
    instanceAlias?: string(name='InstanceAlias'),
    instanceId?: string(name='InstanceId'),
    instanceSource?: string(name='InstanceSource'),
    instanceType?: string(name='InstanceType'),
    ownerIdList?: {
      ownerIds?: [ string ](name='OwnerIds')
    }(name='OwnerIdList'),
    ownerNameList?: {
      ownerNames?: [ string ](name='OwnerNames')
    }(name='OwnerNameList'),
    port?: int32(name='Port'),
    queryTimeout?: int32(name='QueryTimeout'),
    safeRuleId?: string(name='SafeRuleId'),
    sid?: string(name='Sid'),
    standardGroup?: {
      groupMode?: string(name='GroupMode'),
      groupName?: string(name='GroupName'),
    }(name='StandardGroup'),
    state?: string(name='State'),
    useDsql?: int32(name='UseDsql'),
    vpcId?: string(name='VpcId'),
  }(name='Instance'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInstanceResponseBody(name='body'),
}

async function getInstanceWithOptions(request: GetInstanceRequest, runtime: Util.RuntimeOptions): GetInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.host)) {
    query['Host'] = request.host;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.sid)) {
    query['Sid'] = request.sid;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstance',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstance(request: GetInstanceRequest): GetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceWithOptions(request, runtime);
}

model GetLhSpaceByNameRequest {
  spaceName?: string(name='SpaceName'),
  tid?: long(name='Tid'),
}

model GetLhSpaceByNameResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  lakehouseSpace?: {
    creatorId?: string(name='CreatorId'),
    description?: string(name='Description'),
    devDbId?: int32(name='DevDbId'),
    dwDbType?: string(name='DwDbType'),
    id?: long(name='Id'),
    isDeleted?: boolean(name='IsDeleted'),
    mode?: int32(name='Mode'),
    prodDbId?: int32(name='ProdDbId'),
    spaceConfig?: string(name='SpaceConfig'),
    spaceName?: string(name='SpaceName'),
    tenantId?: string(name='TenantId'),
  }(name='LakehouseSpace'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetLhSpaceByNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLhSpaceByNameResponseBody(name='body'),
}

async function getLhSpaceByNameWithOptions(request: GetLhSpaceByNameRequest, runtime: Util.RuntimeOptions): GetLhSpaceByNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.spaceName)) {
    query['SpaceName'] = request.spaceName;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLhSpaceByName',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLhSpaceByName(request: GetLhSpaceByNameRequest): GetLhSpaceByNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLhSpaceByNameWithOptions(request, runtime);
}

model GetLogicDatabaseRequest {
  dbId?: string(name='DbId'),
  tid?: long(name='Tid'),
}

model GetLogicDatabaseResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  logicDatabase?: {
    alias?: string(name='Alias'),
    databaseId?: string(name='DatabaseId'),
    dbType?: string(name='DbType'),
    envType?: string(name='EnvType'),
    logic?: boolean(name='Logic'),
    ownerIdList?: {
      ownerIds?: [ string ](name='OwnerIds')
    }(name='OwnerIdList'),
    ownerNameList?: {
      ownerNames?: [ string ](name='OwnerNames')
    }(name='OwnerNameList'),
    schemaName?: string(name='SchemaName'),
    searchName?: string(name='SearchName'),
  }(name='LogicDatabase'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetLogicDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLogicDatabaseResponseBody(name='body'),
}

async function getLogicDatabaseWithOptions(request: GetLogicDatabaseRequest, runtime: Util.RuntimeOptions): GetLogicDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbId)) {
    query['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLogicDatabase',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLogicDatabase(request: GetLogicDatabaseRequest): GetLogicDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLogicDatabaseWithOptions(request, runtime);
}

model GetMetaTableColumnRequest {
  tableGuid?: string(name='TableGuid'),
  tid?: long(name='Tid'),
}

model GetMetaTableColumnResponseBody = {
  columnList?: [ 
    {
      autoIncrement?: boolean(name='AutoIncrement'),
      columnId?: string(name='ColumnId'),
      columnName?: string(name='ColumnName'),
      columnType?: string(name='ColumnType'),
      dataLength?: long(name='DataLength'),
      dataPrecision?: int32(name='DataPrecision'),
      dataScale?: int32(name='DataScale'),
      description?: string(name='Description'),
      nullable?: boolean(name='Nullable'),
      position?: int32(name='Position'),
      primaryKey?: string(name='PrimaryKey'),
      securityLevel?: string(name='SecurityLevel'),
    }
  ](name='ColumnList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaTableColumnResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMetaTableColumnResponseBody(name='body'),
}

async function getMetaTableColumnWithOptions(request: GetMetaTableColumnRequest, runtime: Util.RuntimeOptions): GetMetaTableColumnResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableColumn',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaTableColumn(request: GetMetaTableColumnRequest): GetMetaTableColumnResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableColumnWithOptions(request, runtime);
}

model GetMetaTableDetailInfoRequest {
  tableGuid?: string(name='TableGuid'),
  tid?: long(name='Tid'),
}

model GetMetaTableDetailInfoResponseBody = {
  detailInfo?: {
    columnList?: [ 
      {
        autoIncrement?: boolean(name='AutoIncrement'),
        columnId?: string(name='ColumnId'),
        columnName?: string(name='ColumnName'),
        columnType?: string(name='ColumnType'),
        dataLength?: long(name='DataLength'),
        dataPrecision?: int32(name='DataPrecision'),
        dataScale?: int32(name='DataScale'),
        description?: string(name='Description'),
        nullable?: boolean(name='Nullable'),
        position?: string(name='Position'),
      }
    ](name='ColumnList'),
    indexList?: [ 
      {
        indexColumns?: [ string ](name='IndexColumns'),
        indexId?: string(name='IndexId'),
        indexName?: string(name='IndexName'),
        indexType?: string(name='IndexType'),
        unique?: boolean(name='Unique'),
      }
    ](name='IndexList'),
  }(name='DetailInfo'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMetaTableDetailInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMetaTableDetailInfoResponseBody(name='body'),
}

async function getMetaTableDetailInfoWithOptions(request: GetMetaTableDetailInfoRequest, runtime: Util.RuntimeOptions): GetMetaTableDetailInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMetaTableDetailInfo',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMetaTableDetailInfo(request: GetMetaTableDetailInfoRequest): GetMetaTableDetailInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMetaTableDetailInfoWithOptions(request, runtime);
}

model GetOpLogRequest {
  endTime?: string(name='EndTime'),
  module?: string(name='Module'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: string(name='StartTime'),
  tid?: long(name='Tid'),
}

model GetOpLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  opLogDetails?: {
    opLogDetail?: [ 
    {
      database?: string(name='Database'),
      module?: string(name='Module'),
      opContent?: string(name='OpContent'),
      opTime?: string(name='OpTime'),
      opUserId?: long(name='OpUserId'),
      orderId?: long(name='OrderId'),
      userId?: string(name='UserId'),
      userNick?: string(name='UserNick'),
    }
  ](name='OpLogDetail')
  }(name='OpLogDetails'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model GetOpLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOpLogResponseBody(name='body'),
}

async function getOpLogWithOptions(request: GetOpLogRequest, runtime: Util.RuntimeOptions): GetOpLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.module)) {
    query['Module'] = request.module;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOpLog',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOpLog(request: GetOpLogRequest): GetOpLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOpLogWithOptions(request, runtime);
}

model GetOrderBaseInfoRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model GetOrderBaseInfoResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  orderBaseInfo?: {
    comment?: string(name='Comment'),
    committer?: string(name='Committer'),
    committerId?: long(name='CommitterId'),
    createTime?: string(name='CreateTime'),
    lastModifyTime?: string(name='LastModifyTime'),
    orderId?: long(name='OrderId'),
    pluginType?: string(name='PluginType'),
    relatedUserList?: {
      userIds?: [ string ](name='UserIds')
    }(name='RelatedUserList'),
    relatedUserNickList?: {
      userNicks?: [ string ](name='UserNicks')
    }(name='RelatedUserNickList'),
    statusCode?: string(name='StatusCode'),
    statusDesc?: string(name='StatusDesc'),
    workflowInstanceId?: long(name='WorkflowInstanceId'),
    workflowStatusDesc?: string(name='WorkflowStatusDesc'),
  }(name='OrderBaseInfo'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetOrderBaseInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOrderBaseInfoResponseBody(name='body'),
}

async function getOrderBaseInfoWithOptions(request: GetOrderBaseInfoRequest, runtime: Util.RuntimeOptions): GetOrderBaseInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOrderBaseInfo',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOrderBaseInfo(request: GetOrderBaseInfoRequest): GetOrderBaseInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOrderBaseInfoWithOptions(request, runtime);
}

model GetOwnerApplyOrderDetailRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model GetOwnerApplyOrderDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  ownerApplyOrderDetail?: {
    applyType?: string(name='ApplyType'),
    resources?: [ 
      {
        logic?: boolean(name='Logic'),
        resourceDetail?: {
          dbType?: string(name='DbType'),
          envType?: string(name='EnvType'),
          ownerIds?: [ long ](name='OwnerIds'),
          ownerNickNames?: [ string ](name='OwnerNickNames'),
          searchName?: string(name='SearchName'),
          tableName?: string(name='TableName'),
        }(name='ResourceDetail'),
        targetId?: string(name='TargetId'),
      }
    ](name='Resources'),
  }(name='OwnerApplyOrderDetail'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetOwnerApplyOrderDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOwnerApplyOrderDetailResponseBody(name='body'),
}

async function getOwnerApplyOrderDetailWithOptions(request: GetOwnerApplyOrderDetailRequest, runtime: Util.RuntimeOptions): GetOwnerApplyOrderDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOwnerApplyOrderDetail',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOwnerApplyOrderDetail(request: GetOwnerApplyOrderDetailRequest): GetOwnerApplyOrderDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOwnerApplyOrderDetailWithOptions(request, runtime);
}

model GetPermApplyOrderDetailRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model GetPermApplyOrderDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  permApplyOrderDetail?: {
    applyType?: string(name='ApplyType'),
    permType?: long(name='PermType'),
    resources?: [ 
      {
        columnInfo?: {
          columnName?: string(name='ColumnName'),
          tableName?: string(name='TableName'),
        }(name='ColumnInfo'),
        databaseInfo?: {
          dbId?: long(name='DbId'),
          dbType?: string(name='DbType'),
          envType?: string(name='EnvType'),
          logic?: boolean(name='Logic'),
          ownerIds?: [ long ](name='OwnerIds'),
          ownerNickNames?: [ string ](name='OwnerNickNames'),
          searchName?: string(name='SearchName'),
        }(name='DatabaseInfo'),
        instanceInfo?: {
          dbType?: string(name='DbType'),
          dbaId?: long(name='DbaId'),
          dbaNickName?: string(name='DbaNickName'),
          envType?: string(name='EnvType'),
          host?: string(name='Host'),
          instanceId?: string(name='InstanceId'),
          ownerIds?: [ long ](name='OwnerIds'),
          ownerNickName?: [ string ](name='OwnerNickName'),
          port?: long(name='Port'),
          searchName?: string(name='SearchName'),
        }(name='InstanceInfo'),
        tableInfo?: {
          tableName?: string(name='TableName'),
        }(name='TableInfo'),
      }
    ](name='Resources'),
    seconds?: long(name='Seconds'),
  }(name='PermApplyOrderDetail'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPermApplyOrderDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPermApplyOrderDetailResponseBody(name='body'),
}

async function getPermApplyOrderDetailWithOptions(request: GetPermApplyOrderDetailRequest, runtime: Util.RuntimeOptions): GetPermApplyOrderDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPermApplyOrderDetail',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPermApplyOrderDetail(request: GetPermApplyOrderDetailRequest): GetPermApplyOrderDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPermApplyOrderDetailWithOptions(request, runtime);
}

model GetPhysicalDatabaseRequest {
  dbId?: long(name='DbId'),
  tid?: long(name='Tid'),
}

model GetPhysicalDatabaseResponseBody = {
  database?: {
    catalogName?: string(name='CatalogName'),
    databaseId?: string(name='DatabaseId'),
    dbType?: string(name='DbType'),
    dbaId?: string(name='DbaId'),
    dbaName?: string(name='DbaName'),
    encoding?: string(name='Encoding'),
    envType?: string(name='EnvType'),
    host?: string(name='Host'),
    instanceId?: string(name='InstanceId'),
    ownerIdList?: {
      ownerIds?: [ string ](name='OwnerIds')
    }(name='OwnerIdList'),
    ownerNameList?: {
      ownerNames?: [ string ](name='OwnerNames')
    }(name='OwnerNameList'),
    port?: int32(name='Port'),
    schemaName?: string(name='SchemaName'),
    searchName?: string(name='SearchName'),
    sid?: string(name='Sid'),
    state?: string(name='State'),
  }(name='Database'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPhysicalDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPhysicalDatabaseResponseBody(name='body'),
}

async function getPhysicalDatabaseWithOptions(request: GetPhysicalDatabaseRequest, runtime: Util.RuntimeOptions): GetPhysicalDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbId)) {
    query['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPhysicalDatabase',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPhysicalDatabase(request: GetPhysicalDatabaseRequest): GetPhysicalDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPhysicalDatabaseWithOptions(request, runtime);
}

model GetProxyRequest {
  instanceId?: long(name='InstanceId'),
  proxyId?: long(name='ProxyId'),
  tid?: long(name='Tid'),
}

model GetProxyResponseBody = {
  creatorId?: long(name='CreatorId'),
  creatorName?: string(name='CreatorName'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  httpsPort?: int32(name='HttpsPort'),
  instanceId?: long(name='InstanceId'),
  privateEnable?: boolean(name='PrivateEnable'),
  privateHost?: string(name='PrivateHost'),
  protocolPort?: int32(name='ProtocolPort'),
  protocolType?: string(name='ProtocolType'),
  proxyId?: long(name='ProxyId'),
  publicEnable?: boolean(name='PublicEnable'),
  publicHost?: string(name='PublicHost'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetProxyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProxyResponseBody(name='body'),
}

async function getProxyWithOptions(request: GetProxyRequest, runtime: Util.RuntimeOptions): GetProxyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.proxyId)) {
    query['ProxyId'] = request.proxyId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetProxy',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProxy(request: GetProxyRequest): GetProxyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProxyWithOptions(request, runtime);
}

model GetSQLReviewCheckResultStatusRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model GetSQLReviewCheckResultStatusResponseBody = {
  checkResultStatus?: {
    checkStatusResult?: {
      checkNotPass?: long(name='CheckNotPass'),
      checkPass?: long(name='CheckPass'),
      forceNotPass?: long(name='ForceNotPass'),
      forcePass?: long(name='ForcePass'),
      new?: long(name='New'),
      unknown?: long(name='Unknown'),
    }(name='CheckStatusResult'),
    checkedCount?: long(name='CheckedCount'),
    SQLReviewResult?: {
      mustImprove?: long(name='MustImprove'),
      potentialIssue?: long(name='PotentialIssue'),
      suggestImprove?: long(name='SuggestImprove'),
      tableIndexSuggest?: long(name='TableIndexSuggest'),
      useDmsDmlUnlock?: long(name='UseDmsDmlUnlock'),
      useDmsToolkit?: long(name='UseDmsToolkit'),
    }(name='SQLReviewResult'),
    totalSQLCount?: long(name='TotalSQLCount'),
  }(name='CheckResultStatus'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSQLReviewCheckResultStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSQLReviewCheckResultStatusResponseBody(name='body'),
}

async function getSQLReviewCheckResultStatusWithOptions(request: GetSQLReviewCheckResultStatusRequest, runtime: Util.RuntimeOptions): GetSQLReviewCheckResultStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSQLReviewCheckResultStatus',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSQLReviewCheckResultStatus(request: GetSQLReviewCheckResultStatusRequest): GetSQLReviewCheckResultStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSQLReviewCheckResultStatusWithOptions(request, runtime);
}

model GetSQLReviewOptimizeDetailRequest {
  SQLReviewQueryKey?: string(name='SQLReviewQueryKey'),
  tid?: long(name='Tid'),
}

model GetSQLReviewOptimizeDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  optimizeDetail?: {
    dbId?: int32(name='DbId'),
    instanceId?: int32(name='InstanceId'),
    qualityResult?: {
      errorMessage?: string(name='ErrorMessage'),
      occurError?: boolean(name='OccurError'),
      results?: [ 
        {
          comments?: string(name='Comments'),
          feedback?: string(name='Feedback'),
          messages?: [ string ](name='Messages'),
          ruleName?: string(name='RuleName'),
          ruleType?: string(name='RuleType'),
          scripts?: [ 
            {
              content?: string(name='Content'),
              opType?: string(name='OpType'),
              tableName?: string(name='TableName'),
            }
          ](name='Scripts'),
        }
      ](name='Results'),
    }(name='QualityResult'),
    queryKey?: string(name='QueryKey'),
    sqlType?: string(name='SqlType'),
  }(name='OptimizeDetail'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSQLReviewOptimizeDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSQLReviewOptimizeDetailResponseBody(name='body'),
}

async function getSQLReviewOptimizeDetailWithOptions(request: GetSQLReviewOptimizeDetailRequest, runtime: Util.RuntimeOptions): GetSQLReviewOptimizeDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.SQLReviewQueryKey)) {
    query['SQLReviewQueryKey'] = request.SQLReviewQueryKey;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSQLReviewOptimizeDetail',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSQLReviewOptimizeDetail(request: GetSQLReviewOptimizeDetailRequest): GetSQLReviewOptimizeDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSQLReviewOptimizeDetailWithOptions(request, runtime);
}

model GetStructSyncExecSqlDetailRequest {
  orderId?: long(name='OrderId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  tid?: long(name='Tid'),
}

model GetStructSyncExecSqlDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  structSyncExecSqlDetail?: {
    execSql?: string(name='ExecSql'),
    totalSqlCount?: long(name='TotalSqlCount'),
  }(name='StructSyncExecSqlDetail'),
  success?: boolean(name='Success'),
}

model GetStructSyncExecSqlDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStructSyncExecSqlDetailResponseBody(name='body'),
}

async function getStructSyncExecSqlDetailWithOptions(request: GetStructSyncExecSqlDetailRequest, runtime: Util.RuntimeOptions): GetStructSyncExecSqlDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetStructSyncExecSqlDetail',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStructSyncExecSqlDetail(request: GetStructSyncExecSqlDetailRequest): GetStructSyncExecSqlDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStructSyncExecSqlDetailWithOptions(request, runtime);
}

model GetStructSyncJobAnalyzeResultRequest {
  compareType?: string(name='CompareType'),
  orderId?: long(name='OrderId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  tid?: long(name='Tid'),
}

model GetStructSyncJobAnalyzeResultResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  structSyncJobAnalyzeResult?: {
    resultList?: [ 
      {
        script?: string(name='Script'),
        sourceTableName?: string(name='SourceTableName'),
        targetTableName?: string(name='TargetTableName'),
      }
    ](name='ResultList'),
    summaryList?: [ 
      {
        compareType?: string(name='CompareType'),
        count?: long(name='Count'),
      }
    ](name='SummaryList'),
  }(name='StructSyncJobAnalyzeResult'),
  success?: boolean(name='Success'),
}

model GetStructSyncJobAnalyzeResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStructSyncJobAnalyzeResultResponseBody(name='body'),
}

async function getStructSyncJobAnalyzeResultWithOptions(request: GetStructSyncJobAnalyzeResultRequest, runtime: Util.RuntimeOptions): GetStructSyncJobAnalyzeResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.compareType)) {
    query['CompareType'] = request.compareType;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetStructSyncJobAnalyzeResult',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStructSyncJobAnalyzeResult(request: GetStructSyncJobAnalyzeResultRequest): GetStructSyncJobAnalyzeResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStructSyncJobAnalyzeResultWithOptions(request, runtime);
}

model GetStructSyncJobDetailRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model GetStructSyncJobDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  structSyncJobDetail?: {
    DBTaskGroupId?: long(name='DBTaskGroupId'),
    executeCount?: long(name='ExecuteCount'),
    jobStatus?: string(name='JobStatus'),
    message?: string(name='Message'),
    securityRule?: string(name='SecurityRule'),
    sqlCount?: long(name='SqlCount'),
    tableAnalyzed?: long(name='TableAnalyzed'),
    tableCount?: long(name='TableCount'),
  }(name='StructSyncJobDetail'),
  success?: boolean(name='Success'),
}

model GetStructSyncJobDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStructSyncJobDetailResponseBody(name='body'),
}

async function getStructSyncJobDetailWithOptions(request: GetStructSyncJobDetailRequest, runtime: Util.RuntimeOptions): GetStructSyncJobDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetStructSyncJobDetail',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStructSyncJobDetail(request: GetStructSyncJobDetailRequest): GetStructSyncJobDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStructSyncJobDetailWithOptions(request, runtime);
}

model GetStructSyncOrderDetailRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model GetStructSyncOrderDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  structSyncOrderDetail?: {
    ignoreError?: boolean(name='IgnoreError'),
    sourceDatabaseInfo?: {
      dbId?: long(name='DbId'),
      dbType?: string(name='DbType'),
      envType?: string(name='EnvType'),
      logic?: boolean(name='Logic'),
      searchName?: string(name='SearchName'),
    }(name='SourceDatabaseInfo'),
    sourceType?: string(name='SourceType'),
    sourceVersionInfo?: {
      versionId?: string(name='VersionId'),
    }(name='SourceVersionInfo'),
    tableInfoList?: [ 
      {
        sourceTableName?: string(name='SourceTableName'),
        targetTableName?: string(name='TargetTableName'),
      }
    ](name='TableInfoList'),
    targetDatabaseInfo?: {
      dbId?: long(name='DbId'),
      dbType?: string(name='DbType'),
      envType?: string(name='EnvType'),
      logic?: boolean(name='Logic'),
      searchName?: string(name='SearchName'),
    }(name='TargetDatabaseInfo'),
    targetType?: string(name='TargetType'),
    targetVersionInfo?: {
      versionId?: string(name='VersionId'),
    }(name='TargetVersionInfo'),
  }(name='StructSyncOrderDetail'),
  success?: boolean(name='Success'),
}

model GetStructSyncOrderDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStructSyncOrderDetailResponseBody(name='body'),
}

async function getStructSyncOrderDetailWithOptions(request: GetStructSyncOrderDetailRequest, runtime: Util.RuntimeOptions): GetStructSyncOrderDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetStructSyncOrderDetail',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStructSyncOrderDetail(request: GetStructSyncOrderDetailRequest): GetStructSyncOrderDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStructSyncOrderDetailWithOptions(request, runtime);
}

model GetTableDBTopologyRequest {
  tableGuid?: string(name='TableGuid'),
  tid?: long(name='Tid'),
}

model GetTableDBTopologyResponseBody = {
  DBTopology?: {
    dataSourceList?: [ 
      {
        databaseList?: [ 
          {
            dbId?: string(name='DbId'),
            dbName?: string(name='DbName'),
            dbType?: string(name='DbType'),
            envType?: string(name='EnvType'),
            tableList?: [ 
              {
                tableId?: string(name='TableId'),
                tableName?: string(name='TableName'),
                tableType?: string(name='TableType'),
              }
            ](name='TableList'),
          }
        ](name='DatabaseList'),
        dbType?: string(name='DbType'),
        host?: string(name='Host'),
        port?: int32(name='Port'),
        sid?: string(name='Sid'),
      }
    ](name='DataSourceList'),
    tableGuid?: string(name='TableGuid'),
    tableName?: string(name='TableName'),
  }(name='DBTopology'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTableDBTopologyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTableDBTopologyResponseBody(name='body'),
}

async function getTableDBTopologyWithOptions(request: GetTableDBTopologyRequest, runtime: Util.RuntimeOptions): GetTableDBTopologyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTableDBTopology',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTableDBTopology(request: GetTableDBTopologyRequest): GetTableDBTopologyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTableDBTopologyWithOptions(request, runtime);
}

model GetTableTopologyRequest {
  tableGuid?: string(name='TableGuid'),
  tid?: long(name='Tid'),
}

model GetTableTopologyResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tableTopology?: {
    logic?: boolean(name='Logic'),
    tableGuid?: string(name='TableGuid'),
    tableName?: string(name='TableName'),
    tableTopologyInfoList?: [ 
      {
        dbId?: long(name='DbId'),
        dbName?: string(name='DbName'),
        dbSearchName?: string(name='DbSearchName'),
        dbType?: string(name='DbType'),
        instanceId?: long(name='InstanceId'),
        instanceResourceId?: string(name='InstanceResourceId'),
        instanceSource?: string(name='InstanceSource'),
        regionId?: string(name='RegionId'),
        tableCount?: long(name='TableCount'),
        tableNameExpr?: string(name='TableNameExpr'),
        tableNameList?: string(name='TableNameList'),
      }
    ](name='TableTopologyInfoList'),
  }(name='TableTopology'),
}

model GetTableTopologyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTableTopologyResponseBody(name='body'),
}

async function getTableTopologyWithOptions(request: GetTableTopologyRequest, runtime: Util.RuntimeOptions): GetTableTopologyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tableGuid)) {
    query['TableGuid'] = request.tableGuid;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTableTopology',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTableTopology(request: GetTableTopologyRequest): GetTableTopologyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTableTopologyWithOptions(request, runtime);
}

model GetTaskInstanceRelationRequest {
  dagId?: long(name='DagId'),
  dagInstanceId?: long(name='DagInstanceId'),
  tid?: long(name='Tid'),
}

model GetTaskInstanceRelationResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  nodeList?: {
    node?: [ 
    {
      businessTime?: string(name='BusinessTime'),
      endTime?: string(name='EndTime'),
      executeTime?: long(name='ExecuteTime'),
      id?: long(name='Id'),
      message?: string(name='Message'),
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      nodeType?: int32(name='NodeType'),
      status?: int32(name='Status'),
    }
  ](name='Node')
  }(name='NodeList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTaskInstanceRelationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskInstanceRelationResponseBody(name='body'),
}

async function getTaskInstanceRelationWithOptions(request: GetTaskInstanceRelationRequest, runtime: Util.RuntimeOptions): GetTaskInstanceRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dagId)) {
    query['DagId'] = request.dagId;
  }
  if (!Util.isUnset(request.dagInstanceId)) {
    query['DagInstanceId'] = request.dagInstanceId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskInstanceRelation',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTaskInstanceRelation(request: GetTaskInstanceRelationRequest): GetTaskInstanceRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskInstanceRelationWithOptions(request, runtime);
}

model GetUserRequest {
  tid?: long(name='Tid'),
  uid?: string(name='Uid'),
  userId?: string(name='UserId'),
}

model GetUserResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  user?: {
    curExecuteCount?: long(name='CurExecuteCount'),
    curResultCount?: long(name='CurResultCount'),
    dingRobot?: string(name='DingRobot'),
    email?: string(name='Email'),
    lastLoginTime?: string(name='LastLoginTime'),
    maxExecuteCount?: long(name='MaxExecuteCount'),
    maxResultCount?: long(name='MaxResultCount'),
    mobile?: string(name='Mobile'),
    nickName?: string(name='NickName'),
    notificationMode?: string(name='NotificationMode'),
    parentUid?: long(name='ParentUid'),
    roleIdList?: {
      roleIds?: [ int32 ](name='RoleIds')
    }(name='RoleIdList'),
    roleNameList?: {
      roleNames?: [ string ](name='RoleNames')
    }(name='RoleNameList'),
    signatureMethod?: string(name='SignatureMethod'),
    state?: string(name='State'),
    uid?: string(name='Uid'),
    userId?: string(name='UserId'),
    webhook?: string(name='Webhook'),
  }(name='User'),
}

model GetUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserResponseBody(name='body'),
}

async function getUserWithOptions(request: GetUserRequest, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUser',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserWithOptions(request, runtime);
}

model GetUserActiveTenantRequest {
  tid?: long(name='Tid'),
}

model GetUserActiveTenantResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tenant?: {
    status?: string(name='Status'),
    tenantName?: string(name='TenantName'),
    tid?: long(name='Tid'),
  }(name='Tenant'),
}

model GetUserActiveTenantResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserActiveTenantResponseBody(name='body'),
}

async function getUserActiveTenantWithOptions(request: GetUserActiveTenantRequest, runtime: Util.RuntimeOptions): GetUserActiveTenantResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserActiveTenant',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserActiveTenant(request: GetUserActiveTenantRequest): GetUserActiveTenantResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserActiveTenantWithOptions(request, runtime);
}

model GetUserUploadFileJobRequest {
  jobKey?: string(name='JobKey'),
  tid?: long(name='Tid'),
}

model GetUserUploadFileJobResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  uploadFileJobDetail?: {
    attachmentKey?: string(name='AttachmentKey'),
    fileName?: string(name='FileName'),
    fileSize?: long(name='FileSize'),
    fileSource?: string(name='FileSource'),
    jobKey?: string(name='JobKey'),
    jobStatus?: string(name='JobStatus'),
    jobStatusDesc?: string(name='JobStatusDesc'),
    uploadOSSParam?: {
      bucketName?: string(name='BucketName'),
      endpoint?: string(name='Endpoint'),
      objectName?: string(name='ObjectName'),
    }(name='UploadOSSParam'),
    uploadType?: string(name='UploadType'),
    uploadURL?: string(name='UploadURL'),
    uploadedSize?: long(name='UploadedSize'),
  }(name='UploadFileJobDetail'),
}

model GetUserUploadFileJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserUploadFileJobResponseBody(name='body'),
}

async function getUserUploadFileJobWithOptions(request: GetUserUploadFileJobRequest, runtime: Util.RuntimeOptions): GetUserUploadFileJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobKey)) {
    query['JobKey'] = request.jobKey;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserUploadFileJob',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserUploadFileJob(request: GetUserUploadFileJobRequest): GetUserUploadFileJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserUploadFileJobWithOptions(request, runtime);
}

model GrantUserPermissionRequest {
  dbId?: string(name='DbId'),
  dsType?: string(name='DsType'),
  expireDate?: string(name='ExpireDate'),
  instanceId?: long(name='InstanceId'),
  logic?: boolean(name='Logic'),
  permTypes?: string(name='PermTypes'),
  tableId?: string(name='TableId'),
  tableName?: string(name='TableName'),
  tid?: long(name='Tid'),
  userId?: string(name='UserId'),
}

model GrantUserPermissionResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GrantUserPermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GrantUserPermissionResponseBody(name='body'),
}

async function grantUserPermissionWithOptions(request: GrantUserPermissionRequest, runtime: Util.RuntimeOptions): GrantUserPermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbId)) {
    query['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.dsType)) {
    query['DsType'] = request.dsType;
  }
  if (!Util.isUnset(request.expireDate)) {
    query['ExpireDate'] = request.expireDate;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.logic)) {
    query['Logic'] = request.logic;
  }
  if (!Util.isUnset(request.permTypes)) {
    query['PermTypes'] = request.permTypes;
  }
  if (!Util.isUnset(request.tableId)) {
    query['TableId'] = request.tableId;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GrantUserPermission',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function grantUserPermission(request: GrantUserPermissionRequest): GrantUserPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantUserPermissionWithOptions(request, runtime);
}

model InspectProxyAccessSecretRequest {
  proxyAccessId?: long(name='ProxyAccessId'),
  tid?: long(name='Tid'),
}

model InspectProxyAccessSecretResponseBody = {
  accessSecret?: string(name='AccessSecret'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InspectProxyAccessSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InspectProxyAccessSecretResponseBody(name='body'),
}

async function inspectProxyAccessSecretWithOptions(request: InspectProxyAccessSecretRequest, runtime: Util.RuntimeOptions): InspectProxyAccessSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.proxyAccessId)) {
    query['ProxyAccessId'] = request.proxyAccessId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InspectProxyAccessSecret',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function inspectProxyAccessSecret(request: InspectProxyAccessSecretRequest): InspectProxyAccessSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return inspectProxyAccessSecretWithOptions(request, runtime);
}

model ListColumnsRequest {
  logic?: boolean(name='Logic'),
  tableId?: string(name='TableId'),
  tid?: long(name='Tid'),
}

model ListColumnsResponseBody = {
  columnList?: {
    column?: [ 
    {
      autoIncrement?: boolean(name='AutoIncrement'),
      columnId?: string(name='ColumnId'),
      columnName?: string(name='ColumnName'),
      columnType?: string(name='ColumnType'),
      dataLength?: long(name='DataLength'),
      dataPrecision?: int32(name='DataPrecision'),
      dataScale?: int32(name='DataScale'),
      defaultValue?: string(name='DefaultValue'),
      description?: string(name='Description'),
      functionType?: string(name='FunctionType'),
      nullable?: boolean(name='Nullable'),
      securityLevel?: string(name='SecurityLevel'),
      sensitive?: boolean(name='Sensitive'),
    }
  ](name='Column')
  }(name='ColumnList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListColumnsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListColumnsResponseBody(name='body'),
}

async function listColumnsWithOptions(request: ListColumnsRequest, runtime: Util.RuntimeOptions): ListColumnsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.logic)) {
    query['Logic'] = request.logic;
  }
  if (!Util.isUnset(request.tableId)) {
    query['TableId'] = request.tableId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListColumns',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listColumns(request: ListColumnsRequest): ListColumnsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listColumnsWithOptions(request, runtime);
}

model ListDAGVersionsRequest {
  dagId?: long(name='DagId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  tid?: long(name='Tid'),
}

model ListDAGVersionsResponseBody = {
  dagVersionList?: {
    dagVersion?: [ 
    {
      dagName?: string(name='DagName'),
      dagOwnerId?: string(name='DagOwnerId'),
      dagOwnerNickName?: string(name='DagOwnerNickName'),
      lastVersionId?: long(name='LastVersionId'),
      versionComments?: string(name='VersionComments'),
      versionId?: long(name='VersionId'),
    }
  ](name='DagVersion')
  }(name='DagVersionList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListDAGVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDAGVersionsResponseBody(name='body'),
}

async function listDAGVersionsWithOptions(request: ListDAGVersionsRequest, runtime: Util.RuntimeOptions): ListDAGVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dagId)) {
    query['DagId'] = request.dagId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDAGVersions',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDAGVersions(request: ListDAGVersionsRequest): ListDAGVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDAGVersionsWithOptions(request, runtime);
}

model ListDBTaskSQLJobRequest {
  DBTaskGroupId?: long(name='DBTaskGroupId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  tid?: long(name='Tid'),
}

model ListDBTaskSQLJobResponseBody = {
  DBTaskSQLJobList?: [ 
    {
      comment?: string(name='Comment'),
      createTime?: string(name='CreateTime'),
      dbId?: long(name='DbId'),
      dbSearchName?: string(name='DbSearchName'),
      dbTaskGroupId?: long(name='DbTaskGroupId'),
      jobId?: long(name='JobId'),
      jobType?: string(name='JobType'),
      lastExecTime?: string(name='LastExecTime'),
      logic?: boolean(name='Logic'),
      status?: string(name='Status'),
      transactional?: boolean(name='Transactional'),
    }
  ](name='DBTaskSQLJobList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListDBTaskSQLJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDBTaskSQLJobResponseBody(name='body'),
}

async function listDBTaskSQLJobWithOptions(request: ListDBTaskSQLJobRequest, runtime: Util.RuntimeOptions): ListDBTaskSQLJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBTaskGroupId)) {
    query['DBTaskGroupId'] = request.DBTaskGroupId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDBTaskSQLJob',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDBTaskSQLJob(request: ListDBTaskSQLJobRequest): ListDBTaskSQLJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDBTaskSQLJobWithOptions(request, runtime);
}

model ListDBTaskSQLJobDetailRequest {
  jobId?: long(name='JobId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  tid?: long(name='Tid'),
}

model ListDBTaskSQLJobDetailResponseBody = {
  DBTaskSQLJobDetailList?: [ 
    {
      affectRows?: long(name='AffectRows'),
      currentSql?: string(name='CurrentSql'),
      dbId?: long(name='DbId'),
      endTime?: string(name='EndTime'),
      executeCount?: long(name='ExecuteCount'),
      jobDetailId?: long(name='JobDetailId'),
      jobId?: long(name='JobId'),
      log?: string(name='Log'),
      logic?: boolean(name='Logic'),
      skip?: boolean(name='Skip'),
      sqlType?: string(name='SqlType'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      timeDelay?: long(name='TimeDelay'),
    }
  ](name='DBTaskSQLJobDetailList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListDBTaskSQLJobDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDBTaskSQLJobDetailResponseBody(name='body'),
}

async function listDBTaskSQLJobDetailWithOptions(request: ListDBTaskSQLJobDetailRequest, runtime: Util.RuntimeOptions): ListDBTaskSQLJobDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDBTaskSQLJobDetail',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDBTaskSQLJobDetail(request: ListDBTaskSQLJobDetailRequest): ListDBTaskSQLJobDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDBTaskSQLJobDetailWithOptions(request, runtime);
}

model ListDDLPublishRecordsRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model ListDDLPublishRecordsResponseBody = {
  DDLPublishRecordList?: [ 
    {
      auditExpireTime?: string(name='AuditExpireTime'),
      auditStatus?: string(name='AuditStatus'),
      creatorId?: long(name='CreatorId'),
      finality?: boolean(name='Finality'),
      finalityReason?: string(name='FinalityReason'),
      publishStatus?: string(name='PublishStatus'),
      publishTaskInfoList?: [ 
        {
          dbId?: long(name='DbId'),
          logic?: boolean(name='Logic'),
          planTime?: string(name='PlanTime'),
          publishJobList?: [ 
            {
              DBTaskGroupId?: long(name='DBTaskGroupId'),
              executeCount?: long(name='ExecuteCount'),
              scripts?: string(name='Scripts'),
              statusDesc?: string(name='StatusDesc'),
              tableName?: string(name='TableName'),
              taskJobStatus?: string(name='TaskJobStatus'),
            }
          ](name='PublishJobList'),
          publishStrategy?: string(name='PublishStrategy'),
          statusDesc?: string(name='StatusDesc'),
          taskJobStatus?: string(name='TaskJobStatus'),
        }
      ](name='PublishTaskInfoList'),
      riskLevel?: string(name='RiskLevel'),
      statusDesc?: string(name='StatusDesc'),
      workflowInstanceId?: long(name='WorkflowInstanceId'),
    }
  ](name='DDLPublishRecordList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDDLPublishRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDDLPublishRecordsResponseBody(name='body'),
}

async function listDDLPublishRecordsWithOptions(request: ListDDLPublishRecordsRequest, runtime: Util.RuntimeOptions): ListDDLPublishRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDDLPublishRecords',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDDLPublishRecords(request: ListDDLPublishRecordsRequest): ListDDLPublishRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDDLPublishRecordsWithOptions(request, runtime);
}

model ListDataCorrectPreCheckDBRequest {
  orderId?: long(name='OrderId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  tid?: long(name='Tid'),
}

model ListDataCorrectPreCheckDBResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  preCheckDBList?: [ 
    {
      dbId?: long(name='DbId'),
      searchName?: string(name='SearchName'),
      sqlNum?: long(name='SqlNum'),
    }
  ](name='PreCheckDBList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDataCorrectPreCheckDBResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDataCorrectPreCheckDBResponseBody(name='body'),
}

async function listDataCorrectPreCheckDBWithOptions(request: ListDataCorrectPreCheckDBRequest, runtime: Util.RuntimeOptions): ListDataCorrectPreCheckDBResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataCorrectPreCheckDB',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDataCorrectPreCheckDB(request: ListDataCorrectPreCheckDBRequest): ListDataCorrectPreCheckDBResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataCorrectPreCheckDBWithOptions(request, runtime);
}

model ListDataCorrectPreCheckSQLRequest {
  dbId?: long(name='DbId'),
  orderId?: long(name='OrderId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  tid?: long(name='Tid'),
}

model ListDataCorrectPreCheckSQLResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  preCheckSQLList?: [ 
    {
      affectRows?: long(name='AffectRows'),
      checkSQL?: string(name='CheckSQL'),
      dbId?: long(name='DbId'),
      SQLReviewQueryKey?: string(name='SQLReviewQueryKey'),
      sqlReviewStatus?: string(name='SqlReviewStatus'),
      sqlType?: string(name='SqlType'),
      tableNames?: string(name='TableNames'),
    }
  ](name='PreCheckSQLList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDataCorrectPreCheckSQLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDataCorrectPreCheckSQLResponseBody(name='body'),
}

async function listDataCorrectPreCheckSQLWithOptions(request: ListDataCorrectPreCheckSQLRequest, runtime: Util.RuntimeOptions): ListDataCorrectPreCheckSQLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbId)) {
    query['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDataCorrectPreCheckSQL',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDataCorrectPreCheckSQL(request: ListDataCorrectPreCheckSQLRequest): ListDataCorrectPreCheckSQLResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataCorrectPreCheckSQLWithOptions(request, runtime);
}

model ListDatabaseUserPermssionsRequest {
  dbId?: string(name='DbId'),
  logic?: boolean(name='Logic'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  permType?: string(name='PermType'),
  tid?: long(name='Tid'),
  userName?: string(name='UserName'),
}

model ListDatabaseUserPermssionsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
  userPermissions?: {
    userPermission?: [ 
    {
      alias?: string(name='Alias'),
      columnName?: string(name='ColumnName'),
      dbId?: string(name='DbId'),
      dbType?: string(name='DbType'),
      dsType?: string(name='DsType'),
      envType?: string(name='EnvType'),
      instanceId?: string(name='InstanceId'),
      logic?: boolean(name='Logic'),
      permDetails?: {
        permDetail?: [ 
        {
          createDate?: string(name='CreateDate'),
          expireDate?: string(name='ExpireDate'),
          extraData?: string(name='ExtraData'),
          originFrom?: string(name='OriginFrom'),
          permType?: string(name='PermType'),
          userAccessId?: string(name='UserAccessId'),
        }
      ](name='PermDetail')
      }(name='PermDetails'),
      schemaName?: string(name='SchemaName'),
      searchName?: string(name='SearchName'),
      tableId?: string(name='TableId'),
      tableName?: string(name='TableName'),
      userId?: string(name='UserId'),
      userNickName?: string(name='UserNickName'),
    }
  ](name='UserPermission')
  }(name='UserPermissions'),
}

model ListDatabaseUserPermssionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDatabaseUserPermssionsResponseBody(name='body'),
}

async function listDatabaseUserPermssionsWithOptions(request: ListDatabaseUserPermssionsRequest, runtime: Util.RuntimeOptions): ListDatabaseUserPermssionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbId)) {
    query['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.logic)) {
    query['Logic'] = request.logic;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.permType)) {
    query['PermType'] = request.permType;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDatabaseUserPermssions',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDatabaseUserPermssions(request: ListDatabaseUserPermssionsRequest): ListDatabaseUserPermssionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDatabaseUserPermssionsWithOptions(request, runtime);
}

model ListDatabasesRequest {
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  tid?: long(name='Tid'),
}

model ListDatabasesResponseBody = {
  databaseList?: {
    database?: [ 
    {
      catalogName?: string(name='CatalogName'),
      databaseId?: string(name='DatabaseId'),
      dbType?: string(name='DbType'),
      dbaId?: string(name='DbaId'),
      dbaName?: string(name='DbaName'),
      encoding?: string(name='Encoding'),
      envType?: string(name='EnvType'),
      host?: string(name='Host'),
      instanceId?: string(name='InstanceId'),
      ownerIdList?: {
        ownerIds?: [ string ](name='OwnerIds')
      }(name='OwnerIdList'),
      ownerNameList?: {
        ownerNames?: [ string ](name='OwnerNames')
      }(name='OwnerNameList'),
      port?: int32(name='Port'),
      schemaName?: string(name='SchemaName'),
      searchName?: string(name='SearchName'),
      sid?: string(name='Sid'),
      state?: string(name='State'),
    }
  ](name='Database')
  }(name='DatabaseList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListDatabasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDatabasesResponseBody(name='body'),
}

async function listDatabasesWithOptions(request: ListDatabasesRequest, runtime: Util.RuntimeOptions): ListDatabasesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDatabases',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDatabases(request: ListDatabasesRequest): ListDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDatabasesWithOptions(request, runtime);
}

model ListDesensitizationRuleRequest {
  funcType?: string(name='FuncType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  ruleId?: int32(name='RuleId'),
  ruleName?: string(name='RuleName'),
  ruleType?: string(name='RuleType'),
  tid?: long(name='Tid'),
}

model ListDesensitizationRuleResponseBody = {
  desensitizationRuleList?: [ 
    {
      funcParams?: string(name='FuncParams'),
      funcSample?: string(name='FuncSample'),
      functionType?: string(name='FunctionType'),
      lastModifierId?: string(name='LastModifierId'),
      lastModifierName?: string(name='LastModifierName'),
      referenceCount?: int32(name='ReferenceCount'),
      ruleDesc?: string(name='RuleDesc'),
      ruleId?: int32(name='RuleId'),
      ruleName?: string(name='RuleName'),
      ruleType?: string(name='RuleType'),
    }
  ](name='DesensitizationRuleList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListDesensitizationRuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDesensitizationRuleResponseBody(name='body'),
}

async function listDesensitizationRuleWithOptions(request: ListDesensitizationRuleRequest, runtime: Util.RuntimeOptions): ListDesensitizationRuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.funcType)) {
    query['FuncType'] = request.funcType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.ruleName)) {
    query['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.ruleType)) {
    query['RuleType'] = request.ruleType;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDesensitizationRule',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDesensitizationRule(request: ListDesensitizationRuleRequest): ListDesensitizationRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDesensitizationRuleWithOptions(request, runtime);
}

model ListIndexesRequest {
  logic?: boolean(name='Logic'),
  tableId?: string(name='TableId'),
  tid?: long(name='Tid'),
}

model ListIndexesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  indexList?: {
    index?: [ 
    {
      indexComment?: string(name='IndexComment'),
      indexId?: string(name='IndexId'),
      indexName?: string(name='IndexName'),
      indexType?: string(name='IndexType'),
      tableId?: string(name='TableId'),
    }
  ](name='Index')
  }(name='IndexList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListIndexesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIndexesResponseBody(name='body'),
}

async function listIndexesWithOptions(request: ListIndexesRequest, runtime: Util.RuntimeOptions): ListIndexesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.logic)) {
    query['Logic'] = request.logic;
  }
  if (!Util.isUnset(request.tableId)) {
    query['TableId'] = request.tableId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIndexes',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listIndexes(request: ListIndexesRequest): ListIndexesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIndexesWithOptions(request, runtime);
}

model ListInstanceLoginAuditLogRequest {
  endTime?: string(name='EndTime'),
  opUserName?: string(name='OpUserName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  searchName?: string(name='SearchName'),
  startTime?: string(name='StartTime'),
  tid?: long(name='Tid'),
}

model ListInstanceLoginAuditLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  instanceLoginAuditLogList?: {
    instanceLoginAuditLog?: [ 
    {
      dbUser?: string(name='DbUser'),
      instanceId?: long(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      opTime?: string(name='OpTime'),
      requestIp?: string(name='RequestIp'),
      userId?: long(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='InstanceLoginAuditLog')
  }(name='InstanceLoginAuditLogList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListInstanceLoginAuditLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceLoginAuditLogResponseBody(name='body'),
}

async function listInstanceLoginAuditLogWithOptions(request: ListInstanceLoginAuditLogRequest, runtime: Util.RuntimeOptions): ListInstanceLoginAuditLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.opUserName)) {
    query['OpUserName'] = request.opUserName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchName)) {
    query['SearchName'] = request.searchName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceLoginAuditLog',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceLoginAuditLog(request: ListInstanceLoginAuditLogRequest): ListInstanceLoginAuditLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceLoginAuditLogWithOptions(request, runtime);
}

model ListInstanceUserPermissionsRequest {
  instanceId?: string(name='InstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  tid?: long(name='Tid'),
  userName?: string(name='UserName'),
}

model ListInstanceUserPermissionsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
  userPermissions?: {
    userPermission?: [ 
    {
      instanceId?: string(name='InstanceId'),
      permDetails?: {
        permDetail?: [ 
        {
          createDate?: string(name='CreateDate'),
          expireDate?: string(name='ExpireDate'),
          extraData?: string(name='ExtraData'),
          originFrom?: string(name='OriginFrom'),
          permType?: string(name='PermType'),
          userAccessId?: string(name='UserAccessId'),
        }
      ](name='PermDetail')
      }(name='PermDetails'),
      userId?: string(name='UserId'),
      userNickName?: string(name='UserNickName'),
    }
  ](name='UserPermission')
  }(name='UserPermissions'),
}

model ListInstanceUserPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstanceUserPermissionsResponseBody(name='body'),
}

async function listInstanceUserPermissionsWithOptions(request: ListInstanceUserPermissionsRequest, runtime: Util.RuntimeOptions): ListInstanceUserPermissionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceUserPermissions',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstanceUserPermissions(request: ListInstanceUserPermissionsRequest): ListInstanceUserPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceUserPermissionsWithOptions(request, runtime);
}

model ListInstancesRequest {
  dbType?: string(name='DbType'),
  envType?: string(name='EnvType'),
  instanceSource?: string(name='InstanceSource'),
  instanceState?: string(name='InstanceState'),
  netType?: string(name='NetType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  searchKey?: string(name='SearchKey'),
  tid?: long(name='Tid'),
}

model ListInstancesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  instanceList?: {
    instance?: [ 
    {
      dataLinkName?: string(name='DataLinkName'),
      databasePassword?: string(name='DatabasePassword'),
      databaseUser?: string(name='DatabaseUser'),
      dbaId?: string(name='DbaId'),
      dbaNickName?: string(name='DbaNickName'),
      ddlOnline?: int32(name='DdlOnline'),
      ecsInstanceId?: string(name='EcsInstanceId'),
      ecsRegion?: string(name='EcsRegion'),
      envType?: string(name='EnvType'),
      exportTimeout?: int32(name='ExportTimeout'),
      host?: string(name='Host'),
      instanceAlias?: string(name='InstanceAlias'),
      instanceId?: string(name='InstanceId'),
      instanceSource?: string(name='InstanceSource'),
      instanceType?: string(name='InstanceType'),
      ownerIdList?: {
        ownerIds?: [ string ](name='OwnerIds')
      }(name='OwnerIdList'),
      ownerNameList?: {
        ownerNames?: [ string ](name='OwnerNames')
      }(name='OwnerNameList'),
      port?: int32(name='Port'),
      queryTimeout?: int32(name='QueryTimeout'),
      safeRuleId?: string(name='SafeRuleId'),
      sid?: string(name='Sid'),
      standardGroup?: {
        groupMode?: string(name='GroupMode'),
        groupName?: string(name='GroupName'),
      }(name='StandardGroup'),
      state?: string(name='State'),
      useDsql?: int32(name='UseDsql'),
      vpcId?: string(name='VpcId'),
    }
  ](name='Instance')
  }(name='InstanceList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstancesWithOptions(request: ListInstancesRequest, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbType)) {
    query['DbType'] = request.dbType;
  }
  if (!Util.isUnset(request.envType)) {
    query['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.instanceSource)) {
    query['InstanceSource'] = request.instanceSource;
  }
  if (!Util.isUnset(request.instanceState)) {
    query['InstanceState'] = request.instanceState;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchKey)) {
    query['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancesWithOptions(request, runtime);
}

model ListLhTaskFlowAndScenarioRequest {
  spaceId?: long(name='SpaceId'),
  tid?: long(name='Tid'),
  userId?: long(name='UserId'),
}

model ListLhTaskFlowAndScenarioResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  rawDAGList?: {
    dag?: [ 
    {
      canEdit?: boolean(name='CanEdit'),
      creatorId?: string(name='CreatorId'),
      creatorNickName?: string(name='CreatorNickName'),
      dagName?: string(name='DagName'),
      dagOwnerId?: string(name='DagOwnerId'),
      dagOwnerNickName?: string(name='DagOwnerNickName'),
      dataFlowId?: long(name='DataFlowId'),
      demoId?: string(name='DemoId'),
      deployId?: long(name='DeployId'),
      id?: long(name='Id'),
      isDeleted?: boolean(name='IsDeleted'),
      latestInstanceStatus?: int32(name='LatestInstanceStatus'),
      latestInstanceTime?: int32(name='LatestInstanceTime'),
      scenarioId?: long(name='ScenarioId'),
      spaceId?: long(name='SpaceId'),
      status?: int32(name='Status'),
    }
  ](name='Dag')
  }(name='RawDAGList'),
  requestId?: string(name='RequestId'),
  scenarioDAGList?: {
    scenarioDAG?: [ 
    {
      dagList?: {
        dag?: [ 
        {
          canEdit?: boolean(name='CanEdit'),
          creatorId?: string(name='CreatorId'),
          creatorNickName?: string(name='CreatorNickName'),
          dagName?: string(name='DagName'),
          dagOwnerId?: string(name='DagOwnerId'),
          dagOwnerNickName?: string(name='DagOwnerNickName'),
          dataFlowId?: long(name='DataFlowId'),
          demoId?: string(name='DemoId'),
          deployId?: long(name='DeployId'),
          id?: long(name='Id'),
          isDeleted?: boolean(name='IsDeleted'),
          latestInstanceStatus?: int32(name='LatestInstanceStatus'),
          latestInstanceTime?: int32(name='LatestInstanceTime'),
          scenarioId?: long(name='ScenarioId'),
          spaceId?: long(name='SpaceId'),
          status?: int32(name='Status'),
        }
      ](name='Dag')
      }(name='DagList'),
      scenario?: {
        creatorId?: string(name='CreatorId'),
        description?: string(name='Description'),
        scenarioName?: string(name='ScenarioName'),
      }(name='Scenario'),
    }
  ](name='ScenarioDAG')
  }(name='ScenarioDAGList'),
  success?: boolean(name='Success'),
}

model ListLhTaskFlowAndScenarioResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLhTaskFlowAndScenarioResponseBody(name='body'),
}

async function listLhTaskFlowAndScenarioWithOptions(request: ListLhTaskFlowAndScenarioRequest, runtime: Util.RuntimeOptions): ListLhTaskFlowAndScenarioResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.spaceId)) {
    query['SpaceId'] = request.spaceId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLhTaskFlowAndScenario',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLhTaskFlowAndScenario(request: ListLhTaskFlowAndScenarioRequest): ListLhTaskFlowAndScenarioResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLhTaskFlowAndScenarioWithOptions(request, runtime);
}

model ListLogicDatabasesRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  tid?: long(name='Tid'),
}

model ListLogicDatabasesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  logicDatabaseList?: {
    logicDatabase?: [ 
    {
      alias?: string(name='Alias'),
      databaseId?: string(name='DatabaseId'),
      dbType?: string(name='DbType'),
      envType?: string(name='EnvType'),
      logic?: boolean(name='Logic'),
      ownerIdList?: {
        ownerIds?: [ string ](name='OwnerIds')
      }(name='OwnerIdList'),
      ownerNameList?: {
        ownerNames?: [ string ](name='OwnerNames')
      }(name='OwnerNameList'),
      schemaName?: string(name='SchemaName'),
      searchName?: string(name='SearchName'),
    }
  ](name='LogicDatabase')
  }(name='LogicDatabaseList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListLogicDatabasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogicDatabasesResponseBody(name='body'),
}

async function listLogicDatabasesWithOptions(request: ListLogicDatabasesRequest, runtime: Util.RuntimeOptions): ListLogicDatabasesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogicDatabases',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLogicDatabases(request: ListLogicDatabasesRequest): ListLogicDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLogicDatabasesWithOptions(request, runtime);
}

model ListLogicTableRouteConfigRequest {
  tableId?: long(name='TableId'),
  tid?: long(name='Tid'),
}

model ListLogicTableRouteConfigResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  logicTableRouteConfigList?: {
    logicTableRouteConfig?: [ 
    {
      routeExpr?: string(name='RouteExpr'),
      routeKey?: string(name='RouteKey'),
      tableId?: long(name='TableId'),
    }
  ](name='LogicTableRouteConfig')
  }(name='LogicTableRouteConfigList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListLogicTableRouteConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogicTableRouteConfigResponseBody(name='body'),
}

async function listLogicTableRouteConfigWithOptions(request: ListLogicTableRouteConfigRequest, runtime: Util.RuntimeOptions): ListLogicTableRouteConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tableId)) {
    query['TableId'] = request.tableId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogicTableRouteConfig',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLogicTableRouteConfig(request: ListLogicTableRouteConfigRequest): ListLogicTableRouteConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLogicTableRouteConfigWithOptions(request, runtime);
}

model ListLogicTablesRequest {
  databaseId?: string(name='DatabaseId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  returnGuid?: boolean(name='ReturnGuid'),
  searchName?: string(name='SearchName'),
  tid?: long(name='Tid'),
}

model ListLogicTablesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  logicTableList?: {
    logicTable?: [ 
    {
      databaseId?: string(name='DatabaseId'),
      logic?: boolean(name='Logic'),
      ownerIdList?: {
        ownerIds?: [ string ](name='OwnerIds')
      }(name='OwnerIdList'),
      ownerNameList?: {
        ownerNames?: [ string ](name='OwnerNames')
      }(name='OwnerNameList'),
      schemaName?: string(name='SchemaName'),
      tableCount?: string(name='TableCount'),
      tableExpr?: string(name='TableExpr'),
      tableGuid?: string(name='TableGuid'),
      tableId?: string(name='TableId'),
      tableName?: string(name='TableName'),
    }
  ](name='LogicTable')
  }(name='LogicTableList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListLogicTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogicTablesResponseBody(name='body'),
}

async function listLogicTablesWithOptions(request: ListLogicTablesRequest, runtime: Util.RuntimeOptions): ListLogicTablesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.databaseId)) {
    query['DatabaseId'] = request.databaseId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.returnGuid)) {
    query['ReturnGuid'] = request.returnGuid;
  }
  if (!Util.isUnset(request.searchName)) {
    query['SearchName'] = request.searchName;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogicTables',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLogicTables(request: ListLogicTablesRequest): ListLogicTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLogicTablesWithOptions(request, runtime);
}

model ListOrdersRequest {
  endTime?: string(name='EndTime'),
  orderResultType?: string(name='OrderResultType'),
  orderStatus?: string(name='OrderStatus'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  pluginType?: string(name='PluginType'),
  searchContent?: string(name='SearchContent'),
  searchDateType?: string(name='SearchDateType'),
  startTime?: string(name='StartTime'),
  tid?: long(name='Tid'),
}

model ListOrdersResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  orders?: {
    order?: [ 
    {
      comment?: string(name='Comment'),
      committer?: string(name='Committer'),
      committerId?: long(name='CommitterId'),
      createTime?: string(name='CreateTime'),
      lastModifyTime?: string(name='LastModifyTime'),
      orderId?: long(name='OrderId'),
      pluginType?: string(name='PluginType'),
      statusCode?: string(name='StatusCode'),
      statusDesc?: string(name='StatusDesc'),
    }
  ](name='Order')
  }(name='Orders'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListOrdersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOrdersResponseBody(name='body'),
}

async function listOrdersWithOptions(request: ListOrdersRequest, runtime: Util.RuntimeOptions): ListOrdersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.orderResultType)) {
    query['OrderResultType'] = request.orderResultType;
  }
  if (!Util.isUnset(request.orderStatus)) {
    query['OrderStatus'] = request.orderStatus;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pluginType)) {
    query['PluginType'] = request.pluginType;
  }
  if (!Util.isUnset(request.searchContent)) {
    query['SearchContent'] = request.searchContent;
  }
  if (!Util.isUnset(request.searchDateType)) {
    query['SearchDateType'] = request.searchDateType;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOrders',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOrders(request: ListOrdersRequest): ListOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOrdersWithOptions(request, runtime);
}

model ListProxiesRequest {
  tid?: long(name='Tid'),
}

model ListProxiesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  proxyList?: [ 
    {
      creatorId?: long(name='CreatorId'),
      creatorName?: string(name='CreatorName'),
      httpsPort?: int32(name='HttpsPort'),
      instanceId?: long(name='InstanceId'),
      privateEnable?: boolean(name='PrivateEnable'),
      privateHost?: string(name='PrivateHost'),
      protocolPort?: int32(name='ProtocolPort'),
      protocolType?: string(name='ProtocolType'),
      proxyId?: long(name='ProxyId'),
      publicEnable?: boolean(name='PublicEnable'),
      publicHost?: string(name='PublicHost'),
    }
  ](name='ProxyList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListProxiesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProxiesResponseBody(name='body'),
}

async function listProxiesWithOptions(request: ListProxiesRequest, runtime: Util.RuntimeOptions): ListProxiesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProxies',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProxies(request: ListProxiesRequest): ListProxiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProxiesWithOptions(request, runtime);
}

model ListProxyAccessesRequest {
  proxyId?: long(name='ProxyId'),
  tid?: long(name='Tid'),
}

model ListProxyAccessesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  proxyAccessList?: [ 
    {
      accessId?: string(name='AccessId'),
      gmtCreate?: string(name='GmtCreate'),
      indepAccount?: string(name='IndepAccount'),
      instanceId?: long(name='InstanceId'),
      originInfo?: string(name='OriginInfo'),
      proxyAccessId?: long(name='ProxyAccessId'),
      proxyId?: long(name='ProxyId'),
      userId?: long(name='UserId'),
      userName?: string(name='UserName'),
      userUid?: string(name='UserUid'),
    }
  ](name='ProxyAccessList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListProxyAccessesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProxyAccessesResponseBody(name='body'),
}

async function listProxyAccessesWithOptions(request: ListProxyAccessesRequest, runtime: Util.RuntimeOptions): ListProxyAccessesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.proxyId)) {
    query['ProxyId'] = request.proxyId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProxyAccesses',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProxyAccesses(request: ListProxyAccessesRequest): ListProxyAccessesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProxyAccessesWithOptions(request, runtime);
}

model ListProxySQLExecAuditLogRequest {
  endTime?: long(name='EndTime'),
  execState?: string(name='ExecState'),
  opUserName?: string(name='OpUserName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  SQLType?: string(name='SQLType'),
  searchName?: string(name='SearchName'),
  startTime?: long(name='StartTime'),
  tid?: long(name='Tid'),
}

model ListProxySQLExecAuditLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  proxySQLExecAuditLogList?: {
    proxySQLExecAuditLog?: [ 
    {
      affectRows?: long(name='AffectRows'),
      elapsedTime?: long(name='ElapsedTime'),
      execState?: string(name='ExecState'),
      instanceId?: long(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      opTime?: string(name='OpTime'),
      remark?: string(name='Remark'),
      SQL?: string(name='SQL'),
      SQLType?: string(name='SQLType'),
      schemaName?: string(name='SchemaName'),
      userId?: long(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='ProxySQLExecAuditLog')
  }(name='ProxySQLExecAuditLogList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListProxySQLExecAuditLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListProxySQLExecAuditLogResponseBody(name='body'),
}

async function listProxySQLExecAuditLogWithOptions(request: ListProxySQLExecAuditLogRequest, runtime: Util.RuntimeOptions): ListProxySQLExecAuditLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.execState)) {
    query['ExecState'] = request.execState;
  }
  if (!Util.isUnset(request.opUserName)) {
    query['OpUserName'] = request.opUserName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.SQLType)) {
    query['SQLType'] = request.SQLType;
  }
  if (!Util.isUnset(request.searchName)) {
    query['SearchName'] = request.searchName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProxySQLExecAuditLog',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProxySQLExecAuditLog(request: ListProxySQLExecAuditLogRequest): ListProxySQLExecAuditLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProxySQLExecAuditLogWithOptions(request, runtime);
}

model ListSQLExecAuditLogRequest {
  endTime?: string(name='EndTime'),
  execState?: string(name='ExecState'),
  opUserName?: string(name='OpUserName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  searchName?: string(name='SearchName'),
  sqlType?: string(name='SqlType'),
  startTime?: string(name='StartTime'),
  tid?: long(name='Tid'),
}

model ListSQLExecAuditLogResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  SQLExecAuditLogList?: {
    SQLExecAuditLog?: [ 
    {
      affectRows?: long(name='AffectRows'),
      dbId?: long(name='DbId'),
      elapsedTime?: long(name='ElapsedTime'),
      execState?: string(name='ExecState'),
      instanceId?: long(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      logic?: boolean(name='Logic'),
      opTime?: string(name='OpTime'),
      remark?: string(name='Remark'),
      SQL?: string(name='SQL'),
      SQLType?: string(name='SQLType'),
      schemaName?: string(name='SchemaName'),
      userId?: long(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='SQLExecAuditLog')
  }(name='SQLExecAuditLogList'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListSQLExecAuditLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSQLExecAuditLogResponseBody(name='body'),
}

async function listSQLExecAuditLogWithOptions(request: ListSQLExecAuditLogRequest, runtime: Util.RuntimeOptions): ListSQLExecAuditLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.execState)) {
    query['ExecState'] = request.execState;
  }
  if (!Util.isUnset(request.opUserName)) {
    query['OpUserName'] = request.opUserName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchName)) {
    query['SearchName'] = request.searchName;
  }
  if (!Util.isUnset(request.sqlType)) {
    query['SqlType'] = request.sqlType;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSQLExecAuditLog',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSQLExecAuditLog(request: ListSQLExecAuditLogRequest): ListSQLExecAuditLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSQLExecAuditLogWithOptions(request, runtime);
}

model ListSQLReviewOriginSQLRequest {
  orderActionDetail?: {
    checkStatusResult?: string(name='CheckStatusResult'),
    fileId?: long(name='FileId'),
    page?: {
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
    }(name='Page'),
    SQLReviewResult?: string(name='SQLReviewResult'),
  }(name='OrderActionDetail'),
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model ListSQLReviewOriginSQLShrinkRequest {
  orderActionDetailShrink?: string(name='OrderActionDetail'),
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model ListSQLReviewOriginSQLResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  originSQLList?: [ 
    {
      checkStatus?: string(name='CheckStatus'),
      checkedTime?: string(name='CheckedTime'),
      fileId?: long(name='FileId'),
      fileName?: string(name='FileName'),
      reviewSummary?: string(name='ReviewSummary'),
      SQLContent?: string(name='SQLContent'),
      SQLId?: long(name='SQLId'),
      SQLReviewQueryKey?: string(name='SQLReviewQueryKey'),
      sqlHash?: string(name='SqlHash'),
      statusDesc?: string(name='StatusDesc'),
    }
  ](name='OriginSQLList'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListSQLReviewOriginSQLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSQLReviewOriginSQLResponseBody(name='body'),
}

async function listSQLReviewOriginSQLWithOptions(tmpReq: ListSQLReviewOriginSQLRequest, runtime: Util.RuntimeOptions): ListSQLReviewOriginSQLResponse {
  Util.validateModel(tmpReq);
  var request = new ListSQLReviewOriginSQLShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.orderActionDetail)) {
    request.orderActionDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.orderActionDetail, 'OrderActionDetail', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.orderActionDetailShrink)) {
    query['OrderActionDetail'] = request.orderActionDetailShrink;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSQLReviewOriginSQL',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSQLReviewOriginSQL(request: ListSQLReviewOriginSQLRequest): ListSQLReviewOriginSQLResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSQLReviewOriginSQLWithOptions(request, runtime);
}

model ListSensitiveColumnsRequest {
  columnName?: string(name='ColumnName'),
  dbId?: long(name='DbId'),
  logic?: boolean(name='Logic'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  schemaName?: string(name='SchemaName'),
  securityLevel?: string(name='SecurityLevel'),
  tableName?: string(name='TableName'),
  tid?: long(name='Tid'),
}

model ListSensitiveColumnsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  sensitiveColumnList?: {
    sensitiveColumn?: [ 
    {
      columnCount?: long(name='ColumnCount'),
      columnName?: string(name='ColumnName'),
      functionType?: string(name='FunctionType'),
      schemaName?: string(name='SchemaName'),
      securityLevel?: string(name='SecurityLevel'),
      tableName?: string(name='TableName'),
    }
  ](name='SensitiveColumn')
  }(name='SensitiveColumnList'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListSensitiveColumnsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSensitiveColumnsResponseBody(name='body'),
}

async function listSensitiveColumnsWithOptions(request: ListSensitiveColumnsRequest, runtime: Util.RuntimeOptions): ListSensitiveColumnsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.columnName)) {
    query['ColumnName'] = request.columnName;
  }
  if (!Util.isUnset(request.dbId)) {
    query['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.logic)) {
    query['Logic'] = request.logic;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.schemaName)) {
    query['SchemaName'] = request.schemaName;
  }
  if (!Util.isUnset(request.securityLevel)) {
    query['SecurityLevel'] = request.securityLevel;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSensitiveColumns',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSensitiveColumns(request: ListSensitiveColumnsRequest): ListSensitiveColumnsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSensitiveColumnsWithOptions(request, runtime);
}

model ListSensitiveColumnsDetailRequest {
  columnName?: string(name='ColumnName'),
  dbId?: long(name='DbId'),
  logic?: boolean(name='Logic'),
  schemaName?: string(name='SchemaName'),
  tableName?: string(name='TableName'),
  tid?: long(name='Tid'),
}

model ListSensitiveColumnsDetailResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  sensitiveColumnsDetailList?: {
    sensitiveColumnsDetail?: [ 
    {
      columnDescription?: string(name='ColumnDescription'),
      columnName?: string(name='ColumnName'),
      columnType?: string(name='ColumnType'),
      dbId?: long(name='DbId'),
      dbType?: string(name='DbType'),
      envType?: string(name='EnvType'),
      logic?: boolean(name='Logic'),
      schemaName?: string(name='SchemaName'),
      searchName?: string(name='SearchName'),
      tableName?: string(name='TableName'),
    }
  ](name='SensitiveColumnsDetail')
  }(name='SensitiveColumnsDetailList'),
  success?: boolean(name='Success'),
}

model ListSensitiveColumnsDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSensitiveColumnsDetailResponseBody(name='body'),
}

async function listSensitiveColumnsDetailWithOptions(request: ListSensitiveColumnsDetailRequest, runtime: Util.RuntimeOptions): ListSensitiveColumnsDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.columnName)) {
    query['ColumnName'] = request.columnName;
  }
  if (!Util.isUnset(request.dbId)) {
    query['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.logic)) {
    query['Logic'] = request.logic;
  }
  if (!Util.isUnset(request.schemaName)) {
    query['SchemaName'] = request.schemaName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSensitiveColumnsDetail',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSensitiveColumnsDetail(request: ListSensitiveColumnsDetailRequest): ListSensitiveColumnsDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSensitiveColumnsDetailWithOptions(request, runtime);
}

model ListStandardGroupsRequest {
  tid?: long(name='Tid'),
}

model ListStandardGroupsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  standardGroupList?: [ 
    {
      dbType?: string(name='DbType'),
      description?: string(name='Description'),
      groupMode?: string(name='GroupMode'),
      groupName?: string(name='GroupName'),
      lastMenderId?: long(name='LastMenderId'),
    }
  ](name='StandardGroupList'),
  success?: boolean(name='Success'),
}

model ListStandardGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListStandardGroupsResponseBody(name='body'),
}

async function listStandardGroupsWithOptions(request: ListStandardGroupsRequest, runtime: Util.RuntimeOptions): ListStandardGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListStandardGroups',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listStandardGroups(request: ListStandardGroupsRequest): ListStandardGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listStandardGroupsWithOptions(request, runtime);
}

model ListTablesRequest {
  databaseId?: string(name='DatabaseId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  returnGuid?: boolean(name='ReturnGuid'),
  searchName?: string(name='SearchName'),
  tid?: long(name='Tid'),
}

model ListTablesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tableList?: {
    table?: [ 
    {
      databaseId?: string(name='DatabaseId'),
      description?: string(name='Description'),
      encoding?: string(name='Encoding'),
      engine?: string(name='Engine'),
      numRows?: long(name='NumRows'),
      ownerIdList?: {
        ownerIds?: [ string ](name='OwnerIds')
      }(name='OwnerIdList'),
      ownerNameList?: {
        ownerNames?: [ string ](name='OwnerNames')
      }(name='OwnerNameList'),
      storeCapacity?: long(name='StoreCapacity'),
      tableGuid?: string(name='TableGuid'),
      tableId?: string(name='TableId'),
      tableName?: string(name='TableName'),
      tableSchemaName?: string(name='TableSchemaName'),
      tableType?: string(name='TableType'),
    }
  ](name='Table')
  }(name='TableList'),
  totalCount?: long(name='TotalCount'),
}

model ListTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTablesResponseBody(name='body'),
}

async function listTablesWithOptions(request: ListTablesRequest, runtime: Util.RuntimeOptions): ListTablesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.databaseId)) {
    query['DatabaseId'] = request.databaseId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.returnGuid)) {
    query['ReturnGuid'] = request.returnGuid;
  }
  if (!Util.isUnset(request.searchName)) {
    query['SearchName'] = request.searchName;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTables',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTables(request: ListTablesRequest): ListTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTablesWithOptions(request, runtime);
}

model ListTaskFlowRequest {
  tid?: long(name='Tid'),
}

model ListTaskFlowResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskFlowList?: {
    taskFlow?: [ 
    {
      creatorId?: string(name='CreatorId'),
      creatorNickName?: string(name='CreatorNickName'),
      dagOwnerNickName?: string(name='DagOwnerNickName'),
      deployId?: long(name='DeployId'),
      id?: long(name='Id'),
      latestInstanceStatus?: int32(name='LatestInstanceStatus'),
      latestInstanceTime?: string(name='LatestInstanceTime'),
      status?: int32(name='Status'),
    }
  ](name='TaskFlow')
  }(name='TaskFlowList'),
}

model ListTaskFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTaskFlowResponseBody(name='body'),
}

async function listTaskFlowWithOptions(request: ListTaskFlowRequest, runtime: Util.RuntimeOptions): ListTaskFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTaskFlow',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTaskFlow(request: ListTaskFlowRequest): ListTaskFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTaskFlowWithOptions(request, runtime);
}

model ListTaskFlowInstanceRequest {
  dagId?: long(name='DagId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  startTimeBegin?: string(name='StartTimeBegin'),
  startTimeEnd?: string(name='StartTimeEnd'),
  tid?: long(name='Tid'),
  triggerType?: int32(name='TriggerType'),
}

model ListTaskFlowInstanceResponseBody = {
  DAGInstanceList?: {
    DAGInstance?: [ 
    {
      businessTime?: string(name='BusinessTime'),
      dagId?: string(name='DagId'),
      dagName?: string(name='DagName'),
      endTime?: string(name='EndTime'),
      historyDagId?: long(name='HistoryDagId'),
      id?: long(name='Id'),
      message?: string(name='Message'),
      ownerName?: string(name='OwnerName'),
      status?: int32(name='Status'),
      triggerType?: int32(name='TriggerType'),
    }
  ](name='DAGInstance')
  }(name='DAGInstanceList'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListTaskFlowInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTaskFlowInstanceResponseBody(name='body'),
}

async function listTaskFlowInstanceWithOptions(request: ListTaskFlowInstanceRequest, runtime: Util.RuntimeOptions): ListTaskFlowInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dagId)) {
    query['DagId'] = request.dagId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTimeBegin)) {
    query['StartTimeBegin'] = request.startTimeBegin;
  }
  if (!Util.isUnset(request.startTimeEnd)) {
    query['StartTimeEnd'] = request.startTimeEnd;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.triggerType)) {
    query['TriggerType'] = request.triggerType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTaskFlowInstance',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTaskFlowInstance(request: ListTaskFlowInstanceRequest): ListTaskFlowInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTaskFlowInstanceWithOptions(request, runtime);
}

model ListUserPermissionsRequest {
  databaseName?: string(name='DatabaseName'),
  dbType?: string(name='DbType'),
  envType?: string(name='EnvType'),
  logic?: boolean(name='Logic'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  permType?: string(name='PermType'),
  searchKey?: string(name='SearchKey'),
  tid?: long(name='Tid'),
  userId?: string(name='UserId'),
}

model ListUserPermissionsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
  userPermissions?: {
    userPermission?: [ 
    {
      alias?: string(name='Alias'),
      columnName?: string(name='ColumnName'),
      dbId?: string(name='DbId'),
      dbType?: string(name='DbType'),
      dsType?: string(name='DsType'),
      envType?: string(name='EnvType'),
      host?: string(name='Host'),
      instanceId?: string(name='InstanceId'),
      logic?: boolean(name='Logic'),
      permDetails?: {
        permDetail?: [ 
        {
          createDate?: string(name='CreateDate'),
          expireDate?: string(name='ExpireDate'),
          extraData?: string(name='ExtraData'),
          originFrom?: string(name='OriginFrom'),
          permType?: string(name='PermType'),
          userAccessId?: string(name='UserAccessId'),
        }
      ](name='PermDetail')
      }(name='PermDetails'),
      port?: long(name='Port'),
      schemaName?: string(name='SchemaName'),
      searchName?: string(name='SearchName'),
      tableId?: string(name='TableId'),
      tableName?: string(name='TableName'),
      userId?: string(name='UserId'),
      userNickName?: string(name='UserNickName'),
    }
  ](name='UserPermission')
  }(name='UserPermissions'),
}

model ListUserPermissionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserPermissionsResponseBody(name='body'),
}

async function listUserPermissionsWithOptions(request: ListUserPermissionsRequest, runtime: Util.RuntimeOptions): ListUserPermissionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.dbType)) {
    query['DbType'] = request.dbType;
  }
  if (!Util.isUnset(request.envType)) {
    query['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.logic)) {
    query['Logic'] = request.logic;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.permType)) {
    query['PermType'] = request.permType;
  }
  if (!Util.isUnset(request.searchKey)) {
    query['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserPermissions',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserPermissions(request: ListUserPermissionsRequest): ListUserPermissionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserPermissionsWithOptions(request, runtime);
}

model ListUserTenantsRequest {
  tid?: long(name='Tid'),
}

model ListUserTenantsResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tenantList?: [ 
    {
      status?: string(name='Status'),
      tenantName?: string(name='TenantName'),
      tid?: long(name='Tid'),
    }
  ](name='TenantList'),
}

model ListUserTenantsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserTenantsResponseBody(name='body'),
}

async function listUserTenantsWithOptions(request: ListUserTenantsRequest, runtime: Util.RuntimeOptions): ListUserTenantsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserTenants',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserTenants(request: ListUserTenantsRequest): ListUserTenantsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserTenantsWithOptions(request, runtime);
}

model ListUsersRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  role?: string(name='Role'),
  searchKey?: string(name='SearchKey'),
  tid?: long(name='Tid'),
  userState?: string(name='UserState'),
}

model ListUsersResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
  userList?: {
    user?: [ 
    {
      curExecuteCount?: long(name='CurExecuteCount'),
      curResultCount?: long(name='CurResultCount'),
      dingRobot?: string(name='DingRobot'),
      email?: string(name='Email'),
      lastLoginTime?: string(name='LastLoginTime'),
      maxExecuteCount?: long(name='MaxExecuteCount'),
      maxResultCount?: long(name='MaxResultCount'),
      mobile?: string(name='Mobile'),
      nickName?: string(name='NickName'),
      notificationMode?: string(name='NotificationMode'),
      parentUid?: string(name='ParentUid'),
      roleIdList?: {
        roleIds?: [ int32 ](name='RoleIds')
      }(name='RoleIdList'),
      roleNameList?: {
        roleNames?: [ string ](name='RoleNames')
      }(name='RoleNameList'),
      signatureMethod?: string(name='SignatureMethod'),
      state?: string(name='State'),
      uid?: string(name='Uid'),
      userId?: string(name='UserId'),
      webhook?: string(name='Webhook'),
    }
  ](name='User')
  }(name='UserList'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.role)) {
    query['Role'] = request.role;
  }
  if (!Util.isUnset(request.searchKey)) {
    query['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.userState)) {
    query['UserState'] = request.userState;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUsers',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model ListWorkFlowNodesRequest {
  searchName?: string(name='SearchName'),
  tid?: long(name='Tid'),
}

model ListWorkFlowNodesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  workflowNodes?: {
    workflowNode?: [ 
    {
      auditUsers?: {
        auditUser?: [ 
        {
          nickName?: string(name='NickName'),
          realName?: string(name='RealName'),
          userId?: long(name='UserId'),
        }
      ](name='AuditUser')
      }(name='AuditUsers'),
      comment?: string(name='Comment'),
      createUserId?: long(name='CreateUserId'),
      createUserNickName?: string(name='CreateUserNickName'),
      nodeId?: long(name='NodeId'),
      nodeName?: string(name='NodeName'),
      nodeType?: string(name='NodeType'),
    }
  ](name='WorkflowNode')
  }(name='WorkflowNodes'),
}

model ListWorkFlowNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWorkFlowNodesResponseBody(name='body'),
}

async function listWorkFlowNodesWithOptions(request: ListWorkFlowNodesRequest, runtime: Util.RuntimeOptions): ListWorkFlowNodesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.searchName)) {
    query['SearchName'] = request.searchName;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkFlowNodes',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listWorkFlowNodes(request: ListWorkFlowNodesRequest): ListWorkFlowNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWorkFlowNodesWithOptions(request, runtime);
}

model ListWorkFlowTemplatesRequest {
  searchName?: string(name='SearchName'),
  tid?: long(name='Tid'),
}

model ListWorkFlowTemplatesResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  workFlowTemplates?: {
    workFlowTemplate?: [ 
    {
      comment?: string(name='Comment'),
      createUserId?: long(name='CreateUserId'),
      enabled?: string(name='Enabled'),
      isSystem?: int32(name='IsSystem'),
      templateId?: long(name='TemplateId'),
      templateName?: string(name='TemplateName'),
      workflowNodes?: {
        workflowNode?: [ 
        {
          comment?: string(name='Comment'),
          createUserId?: long(name='CreateUserId'),
          nodeId?: long(name='NodeId'),
          nodeName?: string(name='NodeName'),
          nodeType?: string(name='NodeType'),
          position?: int32(name='Position'),
          templateId?: long(name='TemplateId'),
        }
      ](name='WorkflowNode')
      }(name='WorkflowNodes'),
    }
  ](name='WorkFlowTemplate')
  }(name='WorkFlowTemplates'),
}

model ListWorkFlowTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWorkFlowTemplatesResponseBody(name='body'),
}

async function listWorkFlowTemplatesWithOptions(request: ListWorkFlowTemplatesRequest, runtime: Util.RuntimeOptions): ListWorkFlowTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.searchName)) {
    query['SearchName'] = request.searchName;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkFlowTemplates',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listWorkFlowTemplates(request: ListWorkFlowTemplatesRequest): ListWorkFlowTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWorkFlowTemplatesWithOptions(request, runtime);
}

model ModifyDataCorrectExecSQLRequest {
  execSQL?: string(name='ExecSQL'),
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model ModifyDataCorrectExecSQLResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyDataCorrectExecSQLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDataCorrectExecSQLResponseBody(name='body'),
}

async function modifyDataCorrectExecSQLWithOptions(request: ModifyDataCorrectExecSQLRequest, runtime: Util.RuntimeOptions): ModifyDataCorrectExecSQLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.execSQL)) {
    query['ExecSQL'] = request.execSQL;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDataCorrectExecSQL',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDataCorrectExecSQL(request: ModifyDataCorrectExecSQLRequest): ModifyDataCorrectExecSQLResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDataCorrectExecSQLWithOptions(request, runtime);
}

model ModifyDesensitizationStrategyRequest {
  columnName?: string(name='ColumnName'),
  dbId?: int32(name='DbId'),
  isLogic?: boolean(name='IsLogic'),
  isReset?: boolean(name='IsReset'),
  ruleId?: int32(name='RuleId'),
  schemaName?: string(name='SchemaName'),
  tableName?: string(name='TableName'),
  tid?: long(name='Tid'),
}

model ModifyDesensitizationStrategyResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  result?: boolean(name='Result'),
  success?: boolean(name='Success'),
}

model ModifyDesensitizationStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDesensitizationStrategyResponseBody(name='body'),
}

async function modifyDesensitizationStrategyWithOptions(request: ModifyDesensitizationStrategyRequest, runtime: Util.RuntimeOptions): ModifyDesensitizationStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.columnName)) {
    query['ColumnName'] = request.columnName;
  }
  if (!Util.isUnset(request.dbId)) {
    query['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.isLogic)) {
    query['IsLogic'] = request.isLogic;
  }
  if (!Util.isUnset(request.isReset)) {
    query['IsReset'] = request.isReset;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.schemaName)) {
    query['SchemaName'] = request.schemaName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDesensitizationStrategy',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDesensitizationStrategy(request: ModifyDesensitizationStrategyRequest): ModifyDesensitizationStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDesensitizationStrategyWithOptions(request, runtime);
}

model OfflineTaskFlowRequest {
  dagId?: long(name='DagId'),
  tid?: long(name='Tid'),
}

model OfflineTaskFlowResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model OfflineTaskFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OfflineTaskFlowResponseBody(name='body'),
}

async function offlineTaskFlowWithOptions(request: OfflineTaskFlowRequest, runtime: Util.RuntimeOptions): OfflineTaskFlowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dagId)) {
    query['DagId'] = request.dagId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'OfflineTaskFlow',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function offlineTaskFlow(request: OfflineTaskFlowRequest): OfflineTaskFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return offlineTaskFlowWithOptions(request, runtime);
}

model PauseDataCorrectSQLJobRequest {
  jobId?: long(name='JobId'),
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
  type?: string(name='Type'),
}

model PauseDataCorrectSQLJobResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PauseDataCorrectSQLJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PauseDataCorrectSQLJobResponseBody(name='body'),
}

async function pauseDataCorrectSQLJobWithOptions(request: PauseDataCorrectSQLJobRequest, runtime: Util.RuntimeOptions): PauseDataCorrectSQLJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PauseDataCorrectSQLJob',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pauseDataCorrectSQLJob(request: PauseDataCorrectSQLJobRequest): PauseDataCorrectSQLJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return pauseDataCorrectSQLJobWithOptions(request, runtime);
}

model ReDeployLhDagVersionRequest {
  dagId?: long(name='DagId'),
  dagVersion?: long(name='DagVersion'),
  tid?: long(name='Tid'),
}

model ReDeployLhDagVersionResponseBody = {
  deployId?: long(name='DeployId'),
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReDeployLhDagVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReDeployLhDagVersionResponseBody(name='body'),
}

async function reDeployLhDagVersionWithOptions(request: ReDeployLhDagVersionRequest, runtime: Util.RuntimeOptions): ReDeployLhDagVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dagId)) {
    query['DagId'] = request.dagId;
  }
  if (!Util.isUnset(request.dagVersion)) {
    query['DagVersion'] = request.dagVersion;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReDeployLhDagVersion',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reDeployLhDagVersion(request: ReDeployLhDagVersionRequest): ReDeployLhDagVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return reDeployLhDagVersionWithOptions(request, runtime);
}

model RegisterInstanceRequest {
  dataLinkName?: string(name='DataLinkName'),
  databasePassword?: string(name='DatabasePassword'),
  databaseUser?: string(name='DatabaseUser'),
  dbaUid?: long(name='DbaUid'),
  ddlOnline?: int32(name='DdlOnline'),
  ecsInstanceId?: string(name='EcsInstanceId'),
  ecsRegion?: string(name='EcsRegion'),
  envType?: string(name='EnvType'),
  exportTimeout?: int32(name='ExportTimeout'),
  host?: string(name='Host'),
  instanceAlias?: string(name='InstanceAlias'),
  instanceSource?: string(name='InstanceSource'),
  instanceType?: string(name='InstanceType'),
  networkType?: string(name='NetworkType'),
  port?: int32(name='Port'),
  queryTimeout?: int32(name='QueryTimeout'),
  safeRule?: string(name='SafeRule'),
  sid?: string(name='Sid'),
  skipTest?: boolean(name='SkipTest'),
  tid?: long(name='Tid'),
  useDsql?: int32(name='UseDsql'),
  vpcId?: string(name='VpcId'),
}

model RegisterInstanceResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RegisterInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterInstanceResponseBody(name='body'),
}

async function registerInstanceWithOptions(request: RegisterInstanceRequest, runtime: Util.RuntimeOptions): RegisterInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataLinkName)) {
    query['DataLinkName'] = request.dataLinkName;
  }
  if (!Util.isUnset(request.databasePassword)) {
    query['DatabasePassword'] = request.databasePassword;
  }
  if (!Util.isUnset(request.databaseUser)) {
    query['DatabaseUser'] = request.databaseUser;
  }
  if (!Util.isUnset(request.dbaUid)) {
    query['DbaUid'] = request.dbaUid;
  }
  if (!Util.isUnset(request.ddlOnline)) {
    query['DdlOnline'] = request.ddlOnline;
  }
  if (!Util.isUnset(request.ecsInstanceId)) {
    query['EcsInstanceId'] = request.ecsInstanceId;
  }
  if (!Util.isUnset(request.ecsRegion)) {
    query['EcsRegion'] = request.ecsRegion;
  }
  if (!Util.isUnset(request.envType)) {
    query['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.exportTimeout)) {
    query['ExportTimeout'] = request.exportTimeout;
  }
  if (!Util.isUnset(request.host)) {
    query['Host'] = request.host;
  }
  if (!Util.isUnset(request.instanceAlias)) {
    query['InstanceAlias'] = request.instanceAlias;
  }
  if (!Util.isUnset(request.instanceSource)) {
    query['InstanceSource'] = request.instanceSource;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.queryTimeout)) {
    query['QueryTimeout'] = request.queryTimeout;
  }
  if (!Util.isUnset(request.safeRule)) {
    query['SafeRule'] = request.safeRule;
  }
  if (!Util.isUnset(request.sid)) {
    query['Sid'] = request.sid;
  }
  if (!Util.isUnset(request.skipTest)) {
    query['SkipTest'] = request.skipTest;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.useDsql)) {
    query['UseDsql'] = request.useDsql;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RegisterInstance',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerInstance(request: RegisterInstanceRequest): RegisterInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerInstanceWithOptions(request, runtime);
}

model RegisterUserRequest {
  mobile?: string(name='Mobile'),
  roleNames?: string(name='RoleNames'),
  tid?: long(name='Tid'),
  uid?: string(name='Uid'),
  userNick?: string(name='UserNick'),
}

model RegisterUserResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RegisterUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterUserResponseBody(name='body'),
}

async function registerUserWithOptions(request: RegisterUserRequest, runtime: Util.RuntimeOptions): RegisterUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.mobile)) {
    query['Mobile'] = request.mobile;
  }
  if (!Util.isUnset(request.roleNames)) {
    query['RoleNames'] = request.roleNames;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userNick)) {
    query['UserNick'] = request.userNick;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RegisterUser',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerUser(request: RegisterUserRequest): RegisterUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerUserWithOptions(request, runtime);
}

model RestartDataCorrectSQLJobRequest {
  jobId?: long(name='JobId'),
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
  type?: string(name='Type'),
}

model RestartDataCorrectSQLJobResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RestartDataCorrectSQLJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartDataCorrectSQLJobResponseBody(name='body'),
}

async function restartDataCorrectSQLJobWithOptions(request: RestartDataCorrectSQLJobRequest, runtime: Util.RuntimeOptions): RestartDataCorrectSQLJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartDataCorrectSQLJob',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartDataCorrectSQLJob(request: RestartDataCorrectSQLJobRequest): RestartDataCorrectSQLJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartDataCorrectSQLJobWithOptions(request, runtime);
}

model RetryDataCorrectPreCheckRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model RetryDataCorrectPreCheckResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RetryDataCorrectPreCheckResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RetryDataCorrectPreCheckResponseBody(name='body'),
}

async function retryDataCorrectPreCheckWithOptions(request: RetryDataCorrectPreCheckRequest, runtime: Util.RuntimeOptions): RetryDataCorrectPreCheckResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RetryDataCorrectPreCheck',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function retryDataCorrectPreCheck(request: RetryDataCorrectPreCheckRequest): RetryDataCorrectPreCheckResponse {
  var runtime = new Util.RuntimeOptions{};
  return retryDataCorrectPreCheckWithOptions(request, runtime);
}

model RevokeUserPermissionRequest {
  dbId?: string(name='DbId'),
  dsType?: string(name='DsType'),
  instanceId?: long(name='InstanceId'),
  logic?: boolean(name='Logic'),
  permTypes?: string(name='PermTypes'),
  tableId?: string(name='TableId'),
  tableName?: string(name='TableName'),
  tid?: long(name='Tid'),
  userAccessId?: string(name='UserAccessId'),
  userId?: string(name='UserId'),
}

model RevokeUserPermissionResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RevokeUserPermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokeUserPermissionResponseBody(name='body'),
}

async function revokeUserPermissionWithOptions(request: RevokeUserPermissionRequest, runtime: Util.RuntimeOptions): RevokeUserPermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbId)) {
    query['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.dsType)) {
    query['DsType'] = request.dsType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.logic)) {
    query['Logic'] = request.logic;
  }
  if (!Util.isUnset(request.permTypes)) {
    query['PermTypes'] = request.permTypes;
  }
  if (!Util.isUnset(request.tableId)) {
    query['TableId'] = request.tableId;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.userAccessId)) {
    query['UserAccessId'] = request.userAccessId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RevokeUserPermission',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokeUserPermission(request: RevokeUserPermissionRequest): RevokeUserPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeUserPermissionWithOptions(request, runtime);
}

model SearchDatabaseRequest {
  dbType?: string(name='DbType'),
  envType?: string(name='EnvType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  searchKey?: string(name='SearchKey'),
  searchRange?: string(name='SearchRange'),
  searchTarget?: string(name='SearchTarget'),
  tid?: long(name='Tid'),
}

model SearchDatabaseResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  searchDatabaseList?: {
    searchDatabase?: [ 
    {
      alias?: string(name='Alias'),
      databaseId?: string(name='DatabaseId'),
      datalinkName?: string(name='DatalinkName'),
      dbType?: string(name='DbType'),
      dbaId?: string(name='DbaId'),
      encoding?: string(name='Encoding'),
      envType?: string(name='EnvType'),
      host?: string(name='Host'),
      logic?: boolean(name='Logic'),
      ownerIdList?: {
        ownerIds?: [ string ](name='OwnerIds')
      }(name='OwnerIdList'),
      ownerNameList?: {
        ownerNames?: [ string ](name='OwnerNames')
      }(name='OwnerNameList'),
      port?: int32(name='Port'),
      schemaName?: string(name='SchemaName'),
      searchName?: string(name='SearchName'),
      sid?: string(name='Sid'),
    }
  ](name='SearchDatabase')
  }(name='SearchDatabaseList'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model SearchDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchDatabaseResponseBody(name='body'),
}

async function searchDatabaseWithOptions(request: SearchDatabaseRequest, runtime: Util.RuntimeOptions): SearchDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbType)) {
    query['DbType'] = request.dbType;
  }
  if (!Util.isUnset(request.envType)) {
    query['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchKey)) {
    query['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.searchRange)) {
    query['SearchRange'] = request.searchRange;
  }
  if (!Util.isUnset(request.searchTarget)) {
    query['SearchTarget'] = request.searchTarget;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchDatabase',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchDatabase(request: SearchDatabaseRequest): SearchDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchDatabaseWithOptions(request, runtime);
}

model SearchTableRequest {
  dbType?: string(name='DbType'),
  envType?: string(name='EnvType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  returnGuid?: boolean(name='ReturnGuid'),
  searchKey?: string(name='SearchKey'),
  searchRange?: string(name='SearchRange'),
  searchTarget?: string(name='SearchTarget'),
  tid?: long(name='Tid'),
}

model SearchTableResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  searchTableList?: {
    searchTable?: [ 
    {
      DBSearchName?: string(name='DBSearchName'),
      databaseId?: string(name='DatabaseId'),
      dbName?: string(name='DbName'),
      dbType?: string(name='DbType'),
      description?: string(name='Description'),
      encoding?: string(name='Encoding'),
      engine?: string(name='Engine'),
      envType?: string(name='EnvType'),
      logic?: boolean(name='Logic'),
      ownerIdList?: {
        ownerIds?: [ string ](name='OwnerIds')
      }(name='OwnerIdList'),
      ownerNameList?: {
        ownerNames?: [ string ](name='OwnerNames')
      }(name='OwnerNameList'),
      tableGuid?: string(name='TableGuid'),
      tableId?: string(name='TableId'),
      tableName?: string(name='TableName'),
      tableSchemaName?: string(name='TableSchemaName'),
    }
  ](name='SearchTable')
  }(name='SearchTableList'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model SearchTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTableResponseBody(name='body'),
}

async function searchTableWithOptions(request: SearchTableRequest, runtime: Util.RuntimeOptions): SearchTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbType)) {
    query['DbType'] = request.dbType;
  }
  if (!Util.isUnset(request.envType)) {
    query['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.returnGuid)) {
    query['ReturnGuid'] = request.returnGuid;
  }
  if (!Util.isUnset(request.searchKey)) {
    query['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.searchRange)) {
    query['SearchRange'] = request.searchRange;
  }
  if (!Util.isUnset(request.searchTarget)) {
    query['SearchTarget'] = request.searchTarget;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchTable',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTable(request: SearchTableRequest): SearchTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTableWithOptions(request, runtime);
}

model SetOwnersRequest {
  ownerIds?: string(name='OwnerIds'),
  ownerType?: string(name='OwnerType'),
  resourceId?: string(name='ResourceId'),
  tid?: long(name='Tid'),
}

model SetOwnersResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetOwnersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetOwnersResponseBody(name='body'),
}

async function setOwnersWithOptions(request: SetOwnersRequest, runtime: Util.RuntimeOptions): SetOwnersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerIds)) {
    query['OwnerIds'] = request.ownerIds;
  }
  if (!Util.isUnset(request.ownerType)) {
    query['OwnerType'] = request.ownerType;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetOwners',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setOwners(request: SetOwnersRequest): SetOwnersResponse {
  var runtime = new Util.RuntimeOptions{};
  return setOwnersWithOptions(request, runtime);
}

model SubmitOrderApprovalRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model SubmitOrderApprovalResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubmitOrderApprovalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitOrderApprovalResponseBody(name='body'),
}

async function submitOrderApprovalWithOptions(request: SubmitOrderApprovalRequest, runtime: Util.RuntimeOptions): SubmitOrderApprovalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitOrderApproval',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitOrderApproval(request: SubmitOrderApprovalRequest): SubmitOrderApprovalResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitOrderApprovalWithOptions(request, runtime);
}

model SubmitStructSyncOrderApprovalRequest {
  orderId?: long(name='OrderId'),
  tid?: long(name='Tid'),
}

model SubmitStructSyncOrderApprovalResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  workflowInstanceId?: long(name='WorkflowInstanceId'),
}

model SubmitStructSyncOrderApprovalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitStructSyncOrderApprovalResponseBody(name='body'),
}

async function submitStructSyncOrderApprovalWithOptions(request: SubmitStructSyncOrderApprovalRequest, runtime: Util.RuntimeOptions): SubmitStructSyncOrderApprovalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitStructSyncOrderApproval',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitStructSyncOrderApproval(request: SubmitStructSyncOrderApprovalRequest): SubmitStructSyncOrderApprovalResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitStructSyncOrderApprovalWithOptions(request, runtime);
}

model SyncDatabaseMetaRequest {
  dbId?: string(name='DbId'),
  logic?: boolean(name='Logic'),
  tid?: long(name='Tid'),
}

model SyncDatabaseMetaResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SyncDatabaseMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SyncDatabaseMetaResponseBody(name='body'),
}

async function syncDatabaseMetaWithOptions(request: SyncDatabaseMetaRequest, runtime: Util.RuntimeOptions): SyncDatabaseMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbId)) {
    query['DbId'] = request.dbId;
  }
  if (!Util.isUnset(request.logic)) {
    query['Logic'] = request.logic;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SyncDatabaseMeta',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function syncDatabaseMeta(request: SyncDatabaseMetaRequest): SyncDatabaseMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncDatabaseMetaWithOptions(request, runtime);
}

model SyncInstanceMetaRequest {
  ignoreTable?: boolean(name='IgnoreTable'),
  instanceId?: string(name='InstanceId'),
  tid?: long(name='Tid'),
}

model SyncInstanceMetaResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SyncInstanceMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SyncInstanceMetaResponseBody(name='body'),
}

async function syncInstanceMetaWithOptions(request: SyncInstanceMetaRequest, runtime: Util.RuntimeOptions): SyncInstanceMetaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ignoreTable)) {
    query['IgnoreTable'] = request.ignoreTable;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SyncInstanceMeta',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function syncInstanceMeta(request: SyncInstanceMetaRequest): SyncInstanceMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncInstanceMetaWithOptions(request, runtime);
}

model UpdateInstanceRequest {
  dataLinkName?: string(name='DataLinkName'),
  databasePassword?: string(name='DatabasePassword'),
  databaseUser?: string(name='DatabaseUser'),
  dbaId?: string(name='DbaId'),
  ddlOnline?: int32(name='DdlOnline'),
  ecsInstanceId?: string(name='EcsInstanceId'),
  ecsRegion?: string(name='EcsRegion'),
  envType?: string(name='EnvType'),
  exportTimeout?: int32(name='ExportTimeout'),
  host?: string(name='Host'),
  instanceAlias?: string(name='InstanceAlias'),
  instanceId?: string(name='InstanceId'),
  instanceSource?: string(name='InstanceSource'),
  instanceType?: string(name='InstanceType'),
  port?: int32(name='Port'),
  queryTimeout?: int32(name='QueryTimeout'),
  safeRuleId?: string(name='SafeRuleId'),
  sid?: string(name='Sid'),
  skipTest?: boolean(name='SkipTest'),
  tid?: long(name='Tid'),
  useDsql?: int32(name='UseDsql'),
  vpcId?: string(name='VpcId'),
}

model UpdateInstanceResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceResponseBody(name='body'),
}

async function updateInstanceWithOptions(request: UpdateInstanceRequest, runtime: Util.RuntimeOptions): UpdateInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataLinkName)) {
    query['DataLinkName'] = request.dataLinkName;
  }
  if (!Util.isUnset(request.databasePassword)) {
    query['DatabasePassword'] = request.databasePassword;
  }
  if (!Util.isUnset(request.databaseUser)) {
    query['DatabaseUser'] = request.databaseUser;
  }
  if (!Util.isUnset(request.dbaId)) {
    query['DbaId'] = request.dbaId;
  }
  if (!Util.isUnset(request.ddlOnline)) {
    query['DdlOnline'] = request.ddlOnline;
  }
  if (!Util.isUnset(request.ecsInstanceId)) {
    query['EcsInstanceId'] = request.ecsInstanceId;
  }
  if (!Util.isUnset(request.ecsRegion)) {
    query['EcsRegion'] = request.ecsRegion;
  }
  if (!Util.isUnset(request.envType)) {
    query['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.exportTimeout)) {
    query['ExportTimeout'] = request.exportTimeout;
  }
  if (!Util.isUnset(request.host)) {
    query['Host'] = request.host;
  }
  if (!Util.isUnset(request.instanceAlias)) {
    query['InstanceAlias'] = request.instanceAlias;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceSource)) {
    query['InstanceSource'] = request.instanceSource;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.queryTimeout)) {
    query['QueryTimeout'] = request.queryTimeout;
  }
  if (!Util.isUnset(request.safeRuleId)) {
    query['SafeRuleId'] = request.safeRuleId;
  }
  if (!Util.isUnset(request.sid)) {
    query['Sid'] = request.sid;
  }
  if (!Util.isUnset(request.skipTest)) {
    query['SkipTest'] = request.skipTest;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.useDsql)) {
    query['UseDsql'] = request.useDsql;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstance',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateInstance(request: UpdateInstanceRequest): UpdateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInstanceWithOptions(request, runtime);
}

model UpdateUserRequest {
  maxExecuteCount?: long(name='MaxExecuteCount'),
  maxResultCount?: long(name='MaxResultCount'),
  mobile?: string(name='Mobile'),
  roleNames?: string(name='RoleNames'),
  tid?: long(name='Tid'),
  uid?: long(name='Uid'),
  userNick?: string(name='UserNick'),
}

model UpdateUserResponseBody = {
  errorCode?: string(name='ErrorCode'),
  errorMessage?: string(name='ErrorMessage'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUserWithOptions(request: UpdateUserRequest, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxExecuteCount)) {
    query['MaxExecuteCount'] = request.maxExecuteCount;
  }
  if (!Util.isUnset(request.maxResultCount)) {
    query['MaxResultCount'] = request.maxResultCount;
  }
  if (!Util.isUnset(request.mobile)) {
    query['Mobile'] = request.mobile;
  }
  if (!Util.isUnset(request.roleNames)) {
    query['RoleNames'] = request.roleNames;
  }
  if (!Util.isUnset(request.tid)) {
    query['Tid'] = request.tid;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userNick)) {
    query['UserNick'] = request.userNick;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2018-11-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserWithOptions(request, runtime);
}

